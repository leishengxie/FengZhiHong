#include "OCR.h"

extern IMAGE page_image;

inT32 myHash(inT32 bits, void *key, inT32 keysize)
{
  inT32 bitindex;                //current bit count
  uinT32 keybits;                //bit buffer
  uinT32 hcode;                  //current hash code

  uinT32 mask = (1 << bits) - 1; //bit mask

  keysize *= 8;                  //in bits
  bitindex = 0;
  keybits = 0;
  hcode = 0;
  do
  {
    while (keysize > 0 && bitindex <= 24)
    {
      keybits |= *((uinT8 *) key) << bitindex;
      key = (uinT8 *) key + 1;
      bitindex += 8;
      keysize -= 8;
    }

    hcode ^= keybits & mask;     //key new key
    keybits >>= bits;
  }while (keysize > 0);

  return hcode;                  //initial hash
}

int myCount(LIST var_list)
{
  int temp = 0;

  iterate (var_list) temp += 1;
  return (temp);
}

LIST delete_d(LIST list, void *key, int_compare is_equal)
{
  LIST result = NIL;
  LIST last_one = NIL;

  if (is_equal == NULL)
    is_equal = is_same;

  while (list != NIL) {
    if (!(*is_equal) (first_node (list), key)) {
      if (last_one == NIL) {
        last_one = list;
        list = rest (list);
        result = last_one;
        set_rest(last_one, NIL);
      }
      else {
        set_rest(last_one, list);
        last_one = list;
        list = rest (list);
        set_rest(last_one, NIL);
      }
    }
    else {
      list = pop (list);
    }
  }
  return (result);
}

LIST delete_d(LIST list, void *key, ResultCallback2<int, void*, void*>* is_equal)
{
  LIST result = NIL;
  LIST last_one = NIL;

  while (list != NIL)
  {
    if (!(*is_equal).Run (first_node (list), key))
    {
      if (last_one == NIL)
      {
        last_one = list;
        list = rest (list);
        result = last_one;
        set_rest(last_one, NIL);
      }
      else
      {
        set_rest(last_one, list);
        last_one = list;
        list = rest (list);
        set_rest(last_one, NIL);
      }
    }
    else
    {
      list = pop (list);
    }
  }

  return (result);
}

LIST destroy(LIST list)
{
  LIST next;

  while (list != NIL)
  {
    next = rest (list);
    free_cell(list);
    list = next;
  }

  return (NIL);
}

void destroy_nodes(LIST list, void_dest destructor)
{
  if (destructor == NULL) destructor = memfree;

  while (list != NIL)
  {
    (*destructor)(first_node(list));

      list = pop (list);
  }
}

void insert(LIST list, void *node)
{
  LIST element;

  if (list != NIL)
  {
    element = push (NIL, node);
    set_rest (element, rest (list));
    set_rest(list, element);
    node = first_node (list);
    list->node = first_node (rest (list));
    list->next->node = (LIST) node;
  }
}

int is_same_node(void *item1, void *item2)
{
  return (item1 == item2);
}

int is_same(void *item1, void *item2)
{
  return (!strcmp ((char *) item1, (char *) item2));
}

LIST join(LIST list1, LIST list2)
{
  if (list1 == NIL)
    return (list2);
  set_rest (last (list1), list2);
  return (list1);
}

LIST last(LIST var_list)
{
  while (rest (var_list) != NIL)
    var_list = rest (var_list);

  return (var_list);
}

void *nth_cell(LIST var_list, int item_num)
{
  int x = 0;
  iterate(var_list)
  {
    if (x++ == item_num)
    {
      return (var_list);
    }
  }

  return (var_list);
}

LIST pop(LIST list)
{
  LIST temp;

  temp = rest (list);

  if (list != NIL)
  {
    free_cell(list);
  }

  return (temp);
}

LIST push(LIST list, void *element)
{
  LIST t;

  t = new_cell ();
  t->node = (LIST) element;
  set_rest(t, list);

  return (t);
}

LIST push_last(LIST list, void *item)
{
  LIST t;

  if (list != NIL)
  {
    t = last (list);
    t->next = push (NIL, item);

    return (list);
  }
  else
  {
    return (push (NIL, item));
  }
}

LIST reverse(LIST list)
{
  LIST newlist = NIL;

  iterate (list) copy_first (list, newlist);

  return (newlist);
}

LIST reverse_d(LIST list)
{
  LIST result = reverse (list);
  destroy(list);
  return (result);
}

LIST s_adjoin(LIST var_list, void *variable, int_compare compare)
{
  LIST l;
  int result;

  if (compare == NULL)
    compare = (int_compare) strcmp;

  l = var_list;
  iterate(l)
  {
    result = (*compare) (variable, first_node (l));
    if (result == 0)
    {
      return (var_list);
    }
    else if (result < 0)
    {
      insert(l, variable);
      return (var_list);
    }
  }

  return (push_last (var_list, variable));
}

LIST search(LIST list, void *key, int_compare is_equal)
{
  if (is_equal == NULL) is_equal = is_same;

  iterate (list) if ((*is_equal) (first_node (list), key))
  return (list);
  return (NIL);
}

LIST search(LIST list, void *key, ResultCallback2<int, void*, void*>* is_equal)
{
  iterate (list) if ((*is_equal).Run(first_node (list), key))
  return (list);
  return (NIL);
}

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
makestructure(newword, oldword, printword, TWERD, freeword, WERDBLOCK, "TWERD", wordcount)
makestructure(newoutline, oldoutline, printol, TESSLINE, freeoutline, OUTLINEBLOCK, "TESSLINE", outlinecount)
makestructure(new_cell, free_cell, printcell, list_rec, freelist, LISTBLOCK, "LIST", listcount)
newstructure(newblob, TBLOB, freeblob, BLOBBLOCK, "newblob", blobcount)
oldstructure(oldblob, TBLOB, freeblob, "BLOB", blobcount)
newstructure(newedgept, EDGEPT, freeedgept, EDGEPTBLOCK, "newedgept",edgeptcount)
oldstructure(oldedgept, EDGEPT, freeedgept, "EDGEPT", edgeptcount)


//////////////////////////////////////////////////////////////callcpp/////////////////////////////////////////////
INT_VAR(tess_cp_mapping0, 0, "Mappings for class pruner distance");
INT_VAR(tess_cp_mapping1, 1, "Mappings for class pruner distance");
INT_VAR(tess_cp_mapping2, 2, "Mappings for class pruner distance");
INT_VAR(tess_cp_mapping3, 3, "Mappings for class pruner distance");
INT_VAR(record_matcher_output, 0, "Record detailed matcher info");
INT_VAR(il1_adaption_test, 0, "Dont adapt to i/I at beginning of word");
double_VAR (permuter_pending_threshold, 0.0, "Worst conf for using pending dictionary");

//Global matcher info from the class pruner.
inT32 cp_maps[4];

//Global info to control writes of matcher info
char blob_answer[UNICHAR_LEN + 1]; //correct char
char *word_answer;                 //correct word
inT32 bits_in_states;              //no of bits in states

void setup_cp_maps() {
  cp_maps[0] = tess_cp_mapping0;
  cp_maps[1] = tess_cp_mapping1;
  cp_maps[2] = tess_cp_mapping2;
  cp_maps[3] = tess_cp_mapping3;
}

void
cprintf (                        //Trace printf
const char *format, ...          //special message
) {
  va_list args;                  //variable args
  char msg[1000];

  va_start(args, format);  //variable list
  vsprintf(msg, format, args);  //Format into msg
  va_end(args);

  tprintf ("%s", msg);
}


#ifndef GRAPHICS_DISABLED
ScrollView *c_create_window(                   /*create a window */
                      const char *name,  /*name/title of window */
                      inT16 xpos,        /*coords of window */
                      inT16 ypos,        /*coords of window */
                      inT16 xsize,       /*size of window */
                      inT16 ysize,       /*size of window */
                      double xmin,       /*scrolling limits */
                      double xmax,       /*to stop users */
                      double ymin,       /*getting lost in */
                      double ymax        /*empty space */
                     ) {
   return new ScrollView(name, xpos, ypos, xsize, ysize, xmax - xmin, ymax - ymin, true);
}

void c_line_color_index(  /*set color */
                        void *win,
                        C_COL index) {
 // The colors are the same as the SV ones except that SV has COLOR:NONE --> offset of 1
 ScrollView* window = (ScrollView*) win;
 window->Pen((ScrollView::Color) (index + 1));
}


void c_move(  /*move pen */
            void *win,
            double x,
            double y) {
  ScrollView* window = (ScrollView*) win;
  window->SetCursor((int) x, (int) y);
}


void c_draw(  /*move pen */
            void *win,
            double x,
            double y) {
  ScrollView* window = (ScrollView*) win;
  window->DrawTo((int) x, (int) y);
}


void c_make_current(  /*move pen */
                    void *win) {
  ScrollView* window = (ScrollView*) win;
  window->Update();
}


void c_clear_window(  /*move pen */
                    void *win) {
  ScrollView* window = (ScrollView*) win;
  window->Clear();
}


char window_wait(ScrollView* win) {
  SVEvent* ev;
  // Wait till an input or click event (all others are thrown away)
  char ret = '\0';
  SVEventType ev_type = SVET_ANY;
  do {
    ev = win->AwaitEvent(SVET_ANY);
    ev_type = ev->type;
    if (ev_type == SVET_INPUT)
      ret = ev->parameter[0];
    delete ev;
  } while (ev_type != SVET_INPUT && ev_type != SVET_CLICK);
  return ret;
}
#endif

void reverse32(void *ptr) {
  char tmp;
  char *cptr = (char *) ptr;

  tmp = *cptr;
  *cptr = *(cptr + 3);
  *(cptr + 3) = tmp;
  tmp = *(cptr + 1);
  *(cptr + 1) = *(cptr + 2);
  *(cptr + 2) = tmp;
}


void reverse16(void *ptr) {
  char tmp;
  char *cptr = (char *) ptr;

  tmp = *cptr;
  *cptr = *(cptr + 1);
  *(cptr + 1) = tmp;
}
//////////////////////////////////////////////////////////////callcpp//////////////////

/////////////////////////////////////////////////////globaloc//////////////////////////
/*inT16 global_loc_code = LOC_INIT;//location code
inT16 global_subloc_code = SUBLOC_NORM;
                                 //pass2 subloc code
inT16 global_subsubloc_code = SUBSUBLOC_OTHER;
                                 //location code
inT16 global_abort_code = NO_ABORT_CODE;
                                 //Prog abort code
*/

//Signal which
void signal_exit(int signal_code)
{
    /*int exit_status;

  if ((global_loc_code == LOC_PASS2) || (global_loc_code == LOC_FUZZY_SPACE))
    global_loc_code += global_subloc_code + global_subsubloc_code;

  if (signal_code < 0) {
    exit_status = global_loc_code * 8 + global_abort_code * 2 + 1;
    tprintf ("Signal_exit %d ABORT. LocCode: %d  AbortCode: %d\n",
      exit_status, global_loc_code, global_abort_code);
  }
  else {
    exit_status = global_loc_code * 8 + signal_code * 2;
    tprintf ("Signal_exit %d SIGNAL ABORT. LocCode: %d  SignalCode: %d\n",
      exit_status, global_loc_code, signal_code);
  }

  exit(exit_status);*/
    exit(signal_code);
}


/*************************************************************************
 * err_exit()
 * All program exits should go through this point. It allows a meaningful status
 * code to be generated for the real exit() call. The status code is made up
 * as follows:
 *  Bit  0    : 1 = Program Abort   0 = System Abort
 *	Bits 1,2  : IF bit 0 = 1 THEN ERRCODE::abort_code
 *				ELSE    0 = Bus Err or Seg Vi
 *								1 = Floating point exception
 *							2 = TimeOut (Signal 15 from command timer)
 *							3 = Any other signal
 *  Bits 3..7 : Location code NEVER 0 !
 *************************************************************************/

//extern "C" {

void err_exit()
{
    signal_exit (-1);
}

//The real signal
void signal_termination_handler(int sig)
{
    tprintf ("Signal_termination_handler called with signal %d\n", sig);
    switch (sig)
    {
    case SIGABRT:
        signal_exit (-1);          //use abort code
        //         case SIGBUS:
    case SIGSEGV:
        signal_exit (0);
    case SIGFPE:
        signal_exit (1);           //floating point
    case SIGTERM:
        signal_exit (2);           //timeout by cmdtimer
    default:
        signal_exit (3);           //Anything else
    }
}


//};                                                                                                            //end extern "C"


void set_global_loc_code(int loc_code)
{
    // global_loc_code = loc_code;
    Q_UNUSED(loc_code);
}


void set_global_subloc_code(int loc_code)
{
    // global_subloc_code = loc_code;
    Q_UNUSED(loc_code);
}


void set_global_subsubloc_code(int loc_code)
{
    // global_subsubloc_code = loc_code;
    Q_UNUSED(loc_code);
}
/////////////////////////////////////////////////////globaloc/////////////////////////////////////////////////////////

/////////////////////////////////////////////////////danerror/////////////////////////////////////////////////////////
#define MAXTRAPDEPTH    100

#define ERRORTRAPDEPTH    1000

/**----------------------------------------------------------------------------
        Global Data Definitions and Declarations
----------------------------------------------------------------------------**/
static jmp_buf ErrorTrapStack[MAXTRAPDEPTH];
static VOID_PROC ProcTrapStack[MAXTRAPDEPTH];
static inT32 CurrentTrapDepth = 0;

/**----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
void ReleaseErrorTrap() {
/*
 **	Parameters:
 **		None
 **	Globals:
 **		CurrentTrapDepth	number of traps on the stack
 **	Operation:
 **		This routine removes the current error trap from the
 **		error trap stack, thus returning control to the previous
 **		error trap.  If the error trap stack is empty, nothing is
 **		done.
 **	Return:
 **		None
 **	Exceptions:
 **		None
 **	History:
 **		4/3/89, DSJ, Created.
 */
  if (CurrentTrapDepth > 0) {
    CurrentTrapDepth--;
  }
}                                /* ReleaseErrorTrap */


/*---------------------------------------------------------------------------*/
void DoError(int Error, const char *Message) {
/*
 **	Parameters:
 **		Error	error number which is to be trapped
 **		Message	pointer to a string to be printed as an error message
 **	Globals:
 **		ErrorTrapStack		stack of error traps
 **		CurrentTrapDepth	number of traps on the stack
 **	Operation:
 **		This routine prints the specified error message to stderr.
 **		It then jumps to the current error trap.  If the error trap
 **		stack is empty, the calling program is terminated with a
 **		fatal error message.
 **	Return:
 **		None - this routine does not return.
 **	Exceptions:
 **		Empty error trap stack terminates the calling program.
 **	History:
 **		4/3/89, DSJ, Created.
 */
  if (Message != NULL) {
    cprintf ("\nError: %s!\n", Message);
  }

  if (CurrentTrapDepth <= 0) {
    cprintf ("\nFatal error: No error trap defined!\n");

    /* SPC 20/4/94
       There used to be a call to abort() here. I've changed it to call into the
       C++ error code to generate a meaningful status code
     */
    signal_termination_handler(Error);
  }

  if (ProcTrapStack[CurrentTrapDepth - 1] != DO_NOTHING)
    (*ProcTrapStack[CurrentTrapDepth - 1]) ();

  longjmp (ErrorTrapStack[CurrentTrapDepth - 1], 1);
}                                /* DoError */


/**----------------------------------------------------------------------------
              Private Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
jmp_buf &PushErrorTrap(VOID_PROC Procedure) {
/*
 **	Parameters:
 **		Procedure		trap procedure to execute
 **	Globals:
 **		ErrorTrapStack		stack of error traps
 **		CurrentTrapDepth	number of traps on the stack
 **	Operation:
 **		This routine pushes a new error trap onto the top of
 **		the error trap stack.  This new error trap can then be
 **		used in a call to setjmp.  This trap is then in effect
 **		until ReleaseErrorTrap is called.  WARNING: a procedure
 **		that calls PushErrorTrap should never exit before calling
 **		ReleaseErrorTrap.
 **	Return:
 **		Pointer to a new error trap buffer
 **	Exceptions:
 **		Traps an error if the error trap stack is already full
 **	History:
 **		3/17/89, DSJ, Created.
 **		9/12/90, DSJ, Added trap procedure parameter.
 */
  if (CurrentTrapDepth >= MAXTRAPDEPTH)
    DoError (ERRORTRAPDEPTH, "Error trap depth exceeded");
  ProcTrapStack[CurrentTrapDepth] = Procedure;
  return ErrorTrapStack[CurrentTrapDepth++];

}                                /* PushErrorTrap */
/////////////////////////////////////////////////////danerror/////////////////////////////////////////////////////////

/////////////////////////////////////////////////////freelist/////////////////////////////////////////////////////////
static int mem_alloc_counter = 0;
/**********************************************************************
 * memalloc
 *
 * Memory allocator with protection.
 **********************************************************************/
int *memalloc(int size)
{
    mem_alloc_counter++;

    return ((int *) alloc_mem (size));
}


/**********************************************************************
 * memrealloc
 *
 * Memory allocator with protection.
 **********************************************************************/
int *memrealloc(void *ptr, int size, int oldsize)
{
    int shiftsize;
    int *newbuf;

    shiftsize = size > oldsize ? oldsize : size;
    newbuf = (int *) alloc_mem (size);
    memcpy(newbuf, ptr, shiftsize);
    free_mem(ptr);

    return newbuf;
}


/**********************************************************************
 * memfree
 *
 * Memory allocator with protection.
 **********************************************************************/
void memfree(void *element)
{
    if (element)
    {
        free_mem(element);
        mem_alloc_counter--;
    }
    else
    {
        tprintf ("%d MEM_ALLOC's used\n", mem_alloc_counter);
        DoError (0, "Memfree of NULL pointer");
    }
}


/**********************************************************************
 * mem_tidy
 *
 * Do nothing.
 **********************************************************************/
void mem_tidy(int level)
{
    check_mem ("Old tidy", level);
}
/////////////////////////////////////////////////////freelist///////////////////////////////////////

//////////////////////////////////////////////////////////////tessarray//////////////////////////////////
/**********************************************************************
 * array_insert
 *
 * Insert a data element into a particular spot in the array.  Move all
 * the elements in the array (past that spot) down one to make room for
 * the new element.
 **********************************************************************/
ARRAY array_insert(ARRAY array, int index, void *value) {
  int x;

  array = array_push (array, NULL);
  for (x = array_count (array) - 1; x > index; x--)
    array_value (array, x) = array_value (array, x - 1);
  array_value (array, index) = value;
  return (array);
}


/**********************************************************************
 * array_new
 *
 * Create a new array with a certain number of elements.	If the number
 * of elements requested is 0 then the default number will be used.
 **********************************************************************/
ARRAY array_new(int num) {
  ARRAY temp;
  int x;

  if (num == 0)
    num = DEFAULT_SIZE;
  temp = (ARRAY)memalloc((num - 2) * sizeof(char *) + sizeof(array_record));
  if (!temp) {
    exit (1);                    //?err_exit ();
  }
  array_count (temp) = 0;
  array_limit (temp) = num;
  for (x = 0; x < num; x++)
    array_value (temp, x) = (char *) 0;
  return (temp);
}


/**********************************************************************
 * array_push
 *
 * Add a new element onto the top of the array.	If there is not room
 * more room is made by "realloc"ing the array.	This means that the
 * new array location may change.  All previous references to its old
 * location may no longer be valid.
 **********************************************************************/
ARRAY array_push(ARRAY array, void *value) {
  if (array_count (array) == array_limit (array)) {
    array = (ARRAY)memrealloc((void *)array, (array_limit(array) * 2 - 2) * sizeof(char *) + sizeof(struct array_record),
                                (array_limit(array) - 2) * sizeof (char *) + sizeof(array_record));
    if (!array) {
      cprintf ("error: Out of memory in array_push\n");
      exit (1);                  //?err_exit ();
    }
    array_limit (array) *= 2;
  }
  array_count (array)++;
  array_top (array) = value;
  return (array);
}
//////////////////////////////////////////////////////////////tessarray//////////////////////////////////

//////////////////////////////////////////////////////////////cutil//////////////////////////////////
#define RESET_COUNT 2000

/**********************************************************************
 * long_rand
 *
 *  Return a long random number whose value is less than limit.  Do this
 *  by calling the standard cheepo random number generator and reseting
 *  it pretty often.
 **********************************************************************/
long long_rand(long limit) {
#if RAND_MAX < 0x1000000
  static long seed;

  long num;
  num = (long) rand () << 16;
  num |= rand () & 0xffff;
  seed ^= num;
  long result = num % limit;
  while (result < 0) {
    result += limit;
  }
  return result;
#else
  return (long)((double)limit * rand()/(RAND_MAX + 1.0));
#endif
}


/**********************************************************************
 * open_file
 *
 *  Open a file for reading or writing.  If the file name parameter is
 *  NULL use stdin (or stdout) for the file.  If the file can not be
 *  opened then call the error routine.
 **********************************************************************/
FILE *open_file(const char *filename, const char *mode) {
  FILE *thisfile = NULL;
  if ((thisfile = fopen (filename, mode)) == NULL) {
    tprintf ("Could not open file, %s\n", filename);
    exit (1);
  }
  return (thisfile);
}

/// Check whether the file exists
bool exists_file(const char *filename) {
  bool exists = false;
  FILE *f = NULL;
  if ((f = fopen(filename, "r")) != NULL) {
    fclose(f);
    exists = true;
  }
  return exists;
}
//////////////////////////////////////////////////////////////cutil//////////////////////////////////

//////////////////////////////////////////////////////////////states//////////////////////////////////
/*-------------------------------------------------------------------------
            Variables
--------------------------------------------------------------------------*/
#define STATEBLOCK 100           /* Cells per block */
makestructure(newstate, free_state, printstate, STATE,
freestate, STATEBLOCK, "STATE", statecount)

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**
 * @name bin_to_chunks
 *
 * Convert a representation of the search state in "STATE" form to one
 * in "SEARCH_STATE" form.  Create the memory required to hold the
 * resultant state value.
 *
 * @param state The state to convert
 */
SEARCH_STATE bin_to_chunks(STATE *state, int num_joints) {
  int x;
  unsigned int mask;
  int depth;
  int pieces = 0;
  SEARCH_STATE s;

  s = memalloc (sizeof (int) * (ones_in_state (state, num_joints) + 1));

  depth = 1;
  mask = 1 << (num_joints - 1 - 32);
  for (x = num_joints; x > 32; x--) {
    if (state->part1 & mask) {
      s[depth++] = pieces;
      pieces = 0;
    }
    else {
      pieces++;
    }
    mask >>= 1;
  }

  if (num_joints > 32)
    mask = 1 << 31;
  else
    mask = 1 << (num_joints - 1);

  while (x--) {
    if (state->part2 & mask) {
      s[depth++] = pieces;
      pieces = 0;
    }
    else {
      pieces++;
    }
    mask >>= 1;
  }
  s[0] = depth - 1;

  return (s);
}


/**
 * bin_to_pieces
 *
 * Convert the binary (bit vector) format of a search state to an array
 * of piece counts. This array has a zero element after the last valid
 * character.
 */
void bin_to_pieces(STATE *state, int num_joints, PIECES_STATE pieces) {
  int x;
  unsigned int mask;             /* Bit mask */
  inT16 num_pieces = 0;
  /* Preset mask */
  if (tord_debug_8)
    print_state ("bin_to_pieces = ", state, num_joints);

  mask = ((num_joints > 32) ?
    (1 << (num_joints - 1 - 32)) : (1 << (num_joints - 1)));

  pieces[num_pieces] = 0;

  for (x = num_joints - 1; x >= 0; x--) {
                                 /* Iterate all bits */
    pieces[num_pieces]++;

    if ((x < 32) ?               /* Test for 1 bit */
      ((state->part2 & mask) ? TRUE : FALSE) :
    ((state->part1 & mask) ? TRUE : FALSE)) {
      pieces[++num_pieces] = 0;
      if (tord_debug_8)
        cprintf ("[%d]=%d ", num_pieces - 1, pieces[num_pieces - 1]);
    }
    /* Next mask value */
    mask = ((mask == 1) ? (1 << 31) : (mask >> 1));
  }
  pieces[num_pieces]++;
  pieces[++num_pieces] = 0;
  ASSERT_HOST (num_pieces < MAX_NUM_CHUNKS + 2);
  if (tord_debug_8)
    new_line();
}


/**
 * insert_new_chunk
 *
 * Add a new chunk division into this state vector at the location
 * requested.
 */
void insert_new_chunk(register STATE *state,
                      register int index,
                      register int num_joints) {
  register unsigned int mask;
  register unsigned int result;

  index = (num_joints - index);
  if (index < 32) {
    mask = ~0;
    mask <<= index;
    result = (mask & state->part2) << 1;
    result |= (~mask & state->part2);
    state->part1 <<= 1;
    if (state->part2 & 0x80000000)
      state->part1 |= 1;
    state->part2 = result;
  }
  else {
    mask = ~0;
    mask <<= index - 32;
    result = (mask & state->part1) << 1;
    result |= (~mask & state->part1);
    state->part1 = result;
  }
}


/**
 * new_state
 *
 * Create a memory space for a new state variable.  Set its initial
 * value according to the parameters.
 */
STATE *new_state(STATE *oldstate) {
  STATE *this_state;

  this_state = newstate ();
  this_state->part1 = oldstate->part1;
  this_state->part2 = oldstate->part2;
  return (this_state);
}


/**
 * ones_in_state
 *
 * Return the number of ones that are in this state.
 */
int ones_in_state(STATE *state, int num_joints) {
  inT8 num_ones = 0;
  inT8 x;
  unsigned int mask;

  if (num_joints > 32)           /* Preset mask */
    mask = 1 << (num_joints - 1 - 32);
  else
    mask = 1 << (num_joints - 1);

  for (x = num_joints - 1; x >= 0; x--) {
                                 /* Iterate all bits */

    if (x < 32)
      num_ones += ((state->part2 & mask) ? 1 : 0);
    else
      num_ones += ((state->part1 & mask) ? 1 : 0);

    if (mask == 1)               /* Next mask value */
      mask = 1 << 31;
    else
      mask >>= 1;
  }

  return (num_ones);
}


/**
 * print_state
 *
 * Print out the current state variable on a line with a label.
 */
void print_state(const char *label, STATE *state, int num_joints) {
  int x;
  unsigned int mask;             /* Bit mask */

  if (num_joints > 32)           /* Preset mask */
    mask = 1 << (num_joints - 1 - 32);
  else
    mask = 1 << (num_joints - 1);

  cprintf ("%s ", label);

  for (x = num_joints - 1; x >= 0; x--) {
                                 /* Iterate all bits */

    if (x < 32)
      cprintf ("%d", ((state->part2 & mask) ? 1 : 0));
    else
      cprintf ("%d", ((state->part1 & mask) ? 1 : 0));
    if (x % 4 == 0)
      cprintf (" ");

    if (mask == 1)               /* Next mask value */
      mask = 1 << 31;
    else
      mask >>= 1;
  }

  new_line();
}


/**
 * set_n_ones
 *
 * Set the first n bits in a state.
 */
void set_n_ones(STATE *state, int n) {
  if (n < 32) {
    state->part2 = ~0;
    state->part2 >>= 32 - n;
    state->part1 = 0;
  }
  else {
    state->part2 = ~0;
    state->part1 = ~0;
    state->part1 >>= 64 - n;
  }
}


/**
 * compare_states
 *
 * Compare the 2 states at the given blob index. Return 1 if the given
 * blob is a fragment compared to reality, 2 if correct, 4 if a join,
 * and 5 if both a join and a fragment.
 * On return the blob index is set to the corresponding index in the
 * correct string.
 */
int compare_states(STATE *true_state, STATE *this_state, int *blob_index) {
  int blob_count;                //number found
  int true_index;                //index of true blob
  int index;                     //current
  int result = 0;                //return value
  uinT32 mask;

  if (true_state->part1 == this_state->part1
    && true_state->part2 == this_state->part2)
    return 2;
  if (*blob_index == 0) {
    if (bits_in_states > 32) {
      for (mask = 1 << (bits_in_states - 33); mask != 0; mask >>= 1) {
        if (this_state->part1 & mask) {
          if (true_state->part1 & mask)
            return 2;
          else
            return 1;
        }
        else if (true_state->part1 & mask)
          return 4;
      }
      index = 31;
    }
    else
      index = bits_in_states - 1;
    for (mask = 1 << index; mask != 0; mask >>= 1) {
      if (this_state->part2 & mask) {
        if (true_state->part2 & mask)
          return 2;
        else
          return 1;
      }
      else if (true_state->part2 & mask)
        return 4;
    }
    return 2;
  }
  else {
    blob_count = 0;
    true_index = 0;
    if (bits_in_states > 32) {
      for (mask = 1 << (bits_in_states - 33); mask != 0; mask >>= 1) {
        if (true_state->part1 & mask)
          true_index++;
        if (this_state->part1 & mask) {
          blob_count++;
          if (blob_count == *blob_index) {
            if ((true_state->part1 & mask) == 0)
              result = 1;
            break;
          }
        }
      }
      if (blob_count == *blob_index) {
        for (mask >>= 1; mask != 0; mask >>= 1) {
          if (this_state->part1 & mask) {
            if ((true_state->part1 & mask) && result == 0)
              return 2;
            else
              return result | 1;
          }
          else if (true_state->part1 & mask)
            result |= 4;
        }
      }
      index = 31;
    }
    else
      index = bits_in_states - 1;
    mask = 1 << index;
    if (blob_count < *blob_index) {
      for (; mask != 0; mask >>= 1) {
        if (true_state->part2 & mask)
          true_index++;
        if (this_state->part2 & mask) {
          blob_count++;
          if (blob_count == *blob_index) {
            if ((true_state->part2 & mask) == 0)
              result = 1;
            break;
          }
        }
      }
      if (blob_count != *blob_index)
        return 2;
      mask >>= 1;
    }
    *blob_index = true_index;
    for (; mask != 0; mask >>= 1) {
      if (this_state->part2 & mask) {
        if ((true_state->part2 & mask) && result == 0)
          return 2;
        else
          return result | 1;
      }
      else if (true_state->part2 & mask)
        result |= 4;
    }
    return result == 0 ? 2 : result;
  }
}
//////////////////////////////////////////////////////////////states//////////////////////////////////



//////////////////////////////////////////////////////////////Image////////////////////////////
class CCUtil;

Image::Image(CCUtil* ccutil_ptr)
  : ccutil_ptr_(ccutil_ptr) {
}

//////////////////////////////////////////////////////////////Image////////////////////////////

//////////////////////////////////////////////////////////////debugwin//////////////////////////////////
#ifdef _MSC_VER
#pragma warning(disable:4554)  // Precedence warnings (line 101)
#endif

// Include automatically generated configuration file if running autoconf.
#ifdef HAVE_CONFIG_H
#endif
INT_VAR (debug_lines, 256, "Number of lines in debug window");
#ifndef GRAPHICS_DISABLED
#ifdef __MAC__
#define scrl_SCROLLER   101
#define text_FLOWED     100

static LCommander *pCommander = NULL;
#endif

                                 //NT implementation
#if defined(__MSW32__) && !defined(_CONSOLE)

#define ID_DEBUG_MSG       32779

/**********************************************************************
 * DEBUG_WIN::DEBUG_WIN
 *
 * Create a debug window with size according to the arguments.
 **********************************************************************/

DEBUG_WIN::DEBUG_WIN(                    //constructor
                     const char *title,  //of window
                     inT32 xpos,         //initial position
                     inT32 ypos,         //in pixels
                     inT32 xsize,        //initial size
                     inT32 ysize,        //in pixels
                     inT32 buflines      //default scroll size
                    ) {
  char cmd[1024];
  int parm;                      //output from scrolrwin
  STARTUPINFO start_info;        //process control
  PROCESS_INFORMATION proc_info; //process ids
  SECURITY_ATTRIBUTES security;  //for handles

  handle = NULL;
  shm_hand = NULL;
  shm_mem = NULL;
  msg_end = NULL;
  dbg_process = NULL;            //save handles
  dbg_thread = NULL;
  security.nLength = sizeof (security);
  security.lpSecurityDescriptor = NULL;
  security.bInheritHandle = TRUE;//make it inheritable
                                 //anonymous
  shm_hand = CreateFileMapping ((HANDLE) 0xffffffff, &security, PAGE_READWRITE, 0, 4096, NULL);
  if (shm_hand == NULL)
    return;                      //failed
  shm_mem = (char *) MapViewOfFile (shm_hand, FILE_MAP_WRITE, 0, 0, 0);
  if (shm_mem == NULL)
    return;
  shm_mem[5] = 0;
  sprintf (cmd, "scrolwin.exe %d %d", buflines, shm_hand);
  GetStartupInfo(&start_info);  //clone our stuff
  if (!CreateProcess (NULL, cmd, NULL, NULL, TRUE,
    CREATE_NO_WINDOW | DETACHED_PROCESS | CREATE_SUSPENDED,
    NULL, NULL, &start_info, &proc_info))
    return;

                                 //save handles
  dbg_process = proc_info.hProcess;
  dbg_thread = proc_info.hThread;
  if (ResumeThread (dbg_thread) != 1)
    return;
  do
  Sleep (100);
  while (shm_mem[5] == 0);       //wait for handle
  parm = ((((uinT8) shm_mem[4] << 8) + (uinT8) shm_mem[3] << 8)
    + (uinT8) shm_mem[2] << 8) + (uinT8) shm_mem[1];
  handle = (HWND) parm;
  if (handle != NULL) {
                                 //setup window
    ::SetWindowText (handle, title);
    ::MoveWindow (handle, xpos, ypos, xsize, ysize, TRUE);
    ::ShowWindow (handle, SW_SHOW);
  }
}


/**********************************************************************
 * DEBUG_WIN::DEBUG_WIN
 *
 * Destroy a debug window.
 **********************************************************************/

DEBUG_WIN::~DEBUG_WIN (
//destructor
) {
  if (IsWindow (handle))
    ::SendMessage (handle, WM_COMMAND, IDOK, 0);
  if (shm_mem != NULL)
    UnmapViewOfFile(shm_mem);
  if (shm_hand != NULL)
    CloseHandle(shm_hand);
  if (dbg_thread != NULL)
    CloseHandle(dbg_thread);
  if (dbg_process == NULL)
    CloseHandle(dbg_process);

}


/**********************************************************************
 * dprintf
 *
 * Print a message to the debug window.
 * Like printf, this function can cope with messages which do not end
 * in newline, but nothing is printed until the newline is received.
 **********************************************************************/

void
DEBUG_WIN::dprintf (             //debug printf
const char *format, ...          //special message
) {
  va_list args;                  //variable args
  char *msg_start;               //for printing

  if (!IsWindow (handle))
    return;                      //destroyed
  if (msg_end == NULL)
    msg_end = shm_mem + 1;
  va_start(args, format);  //variable list
                                 //Format into msg
  vsprintf(msg_end, format, args);
  va_end(args);
  if (*msg_end == '\0')
    return;
  msg_start = shm_mem + 1;
  do {
                                 //end of line
    msg_end = strchr (msg_start, '\n');
    if (msg_end == NULL) {
      if (msg_start != shm_mem + 1)
                                 //bring to front
        strcpy (shm_mem + 1, msg_start);
                                 //current end
      msg_end = shm_mem + 1 + strlen (shm_mem + 1);
      return;
    }
    *msg_end = '\0';
    while (IsWindow (handle) && shm_mem[0])
      Sleep (500);
    if (IsWindow (handle)) {
                                 //Visual C++2.0 macro
      ::SendMessage (handle, WM_COMMAND, ID_DEBUG_MSG, (DWORD) (msg_start - shm_mem));
    }
    msg_start = msg_end + 1;
  }
  while (*msg_start != '\0');
  msg_end = shm_mem + 1;         //buffer empty
}


/**********************************************************************
 * await_destruction
 *
 * Wait for the user to close the debug window. Then return.
 **********************************************************************/

void DEBUG_WIN::await_destruction() {  //wait for user to close
  WaitForSingleObject (dbg_process, (unsigned long) -1);
}
#endif                           //NT Implmentation

                                 //UNIX implementation
#if defined(__UNIX__) || defined(_CONSOLE)
#ifdef __UNIX__
#endif

/**********************************************************************
 * DEBUG_WIN::DEBUG_WIN
 *
 * Create a debug window with size according to the arguments.
 * Create an hpterm window with a pipe connected to it.
 **********************************************************************/

DEBUG_WIN::DEBUG_WIN(                    //constructor
                     const char *title,  //of window
                     inT32 xpos,         //initial position
                     inT32 ypos,         //in pixels
                     inT32 xsize,        //initial size
                     inT32 ysize,        //in pixels
                     inT32 buflines      //default scroll size
                    ) {
  #ifdef __UNIX__
  inT32 length;                  /*length of name */
  char command[MAX_PATH];        /*pipe command */
  pid_t pid;                     /*process id */
  char host[MAX_PATH];           //remote host
  BOOL8 remote;                  //remote host

  //      remote=remote_display(host);                                                                    //check remote host
  remote = FALSE;
  if (remote)
                                 //do it remotely
    length = sprintf (command, "remsh %s 'DISPLAY=%s;export DISPLAY;", host, getenv ("DISPLAY"));
  else
    length = 0;
  length += sprintf (command + length, "trap \"\" 1 2 3 13 15\n");
  length +=
    sprintf (command + length,
    "/usr/bin/xterm -sb -sl " INT32FORMAT " -geometry "
    INT32FORMAT "x" INT32FORMAT "", buflines, xsize / 8, ysize / 16);
  if (xpos >= 0)
    command[length++] = '+';
  length += sprintf (command + length, INT32FORMAT, xpos);
  if (ypos >= 0)
    command[length++] = '+';
  length +=
    sprintf (command + length,
    INT32FORMAT " -title \"%s\" -n \"%s\" -e /bin/sh -c ", ypos,
    title, title);
  pid = getpid ();               /*random number */
  length +=
    sprintf (command + length,
    "\"stty opost; tty >/tmp/debug%d; while [ -s /tmp/debug%d ]\ndo\nsleep 1\ndone\" &\n",
    pid, pid);
  length +=
    sprintf (command + length, "trap \"rm -f /tmp/debug%d; kill -9 $!\" 0\n",
    pid);
  length += sprintf (command + length, "trap \"exit\" 1 2 3 13 15\n");
  length +=
    sprintf (command + length,
    "while [ ! -s /tmp/debug%d ]\ndo\nsleep 1\ndone\n", pid);
  length += sprintf (command + length, "trap \"\" 1 2 3 13 15\n");
  length += sprintf (command + length, "ofile=`cat /tmp/debug%d`\n", pid);
  length +=
    sprintf (command + length, "cat -u - >$ofile; rm /tmp/debug%d\n", pid);
  if (remote) {
    command[length++] = '\'';    //terminate remsh
    command[length] = '\0';
  }
  fp = popen (command, "w");     /*create window */
  if (fp != NULL) {
                                 /*set no buffering */
    if (setvbuf (fp, NULL, _IONBF, BUFSIZ)) {
      pclose(fp);
      fp = NULL;
    }
  }
  #endif
}


/**********************************************************************
 * DEBUG_WIN::DEBUG_WIN
 *
 * Close the file and destroy the window.
 **********************************************************************/

DEBUG_WIN::~DEBUG_WIN (
//destructor
) {
  #ifdef __UNIX__
  pclose(fp);
  #endif
}


/**********************************************************************
 * dprintf
 *
 * Print a message to the debug window.
 * Like printf, this function can cope with messages which do not end
 * in newline, but nothing is printed until the newline is received.
 **********************************************************************/

void
DEBUG_WIN::dprintf (             //debug printf
const char *format, ...          //special message
) {
  va_list args;                  //variable args

  va_start(args, format);  //variable list
  #ifdef __UNIX__
  vfprintf(fp, format, args);  //Format into msg
  #else
                                 //Format into msg
  vfprintf(stderr, format, args);
  #endif
  va_end(args);
}


/**********************************************************************
 * await_destruction
 *
 * Wait for the user to close the debug window. Then return.
 **********************************************************************/

void DEBUG_WIN::await_destruction() {  //wait for user to close
  #ifdef __UNIX__
  signal(SIGPIPE, SIG_IGN);
  while (!ferror (fp)) {
    sleep (1);
    fputc (0, fp);               //send nulls until error
  }
  #endif
}
#endif                           //UNIX Implmentation

#ifdef __MAC__                   //NT implementation

// Until I can figure a way to do this without linking in PowerPlant,
// the debug window will just have empty functions so compilation can take place.

/**********************************************************************
 * DEBUG_WIN::SetCommander
 *
 * Mac-specific function to set the commander for the next debug window
 **********************************************************************/
void DEBUG_WIN::SetCommander(LCommander *pNew) {
  pCommander = pNew;
}


/**********************************************************************
 * DEBUG_WIN::DEBUG_WIN
 *
 * Create a debug window with size according to the arguments.
 * Create an hpterm window with a pipe connected to it.
 **********************************************************************/

DEBUG_WIN::DEBUG_WIN(                    //constructor
                     const char *title,  //of window
                     inT32 xpos,         //initial position
                     inT32 ypos,         //in pixels
                     inT32 xsize,        //initial size
                     inT32 ysize,        //in pixels
                     inT32 buflines      //default scroll size
                    ) {
  inT32 length;                  /*length of name */

  // don't replace this DebugStr() with a call to DEBUG_WIN!

  //if (pCommander==NULL) DebugStr("\pDEBUG_WIN::DEBUG_WIN(), Commander not set");

  // create the window

  //pWindow=LWindow::CreateWindow(2700,pCommander);
}


/**********************************************************************
 * DEBUG_WIN::DEBUG_WIN
 *
 * Close the file and destroy the window.
 **********************************************************************/

DEBUG_WIN::~DEBUG_WIN (
//destructor
) {
}


/**********************************************************************
 * dprintf
 *
 * Print a message to the debug window.
 * Like printf, this function can cope with messages which do not end
 * in newline, but nothing is printed until the newline is received.
 **********************************************************************/

void
DEBUG_WIN::dprintf (             //debug printf
const char *format, ...          //special message
) {
  #if 0
  LTextEdit *pTextEdit;
  va_list args;                  //variable args
  static char msg[1024];

  inT32 i;
  inT32 OriginalLength;
  inT32 NewLength;
  TEHandle hTextEdit;
  char *pTempBuffer;
  CharsHandle hChar;
  char *pOriginalText;
  inT32 StringLength;

  pTextEdit = (LTextEdit *) pWindow->FindPaneByID (text_FLOWED);
  if (pTextEdit == NULL)
    DebugStr ("\pwhoops");

  // get a C String from the format and args passed in

  va_start(args, format);  //variable list
  vsprintf(msg, format, args);  //Format into msg
  va_end(args);

  StringLength = strlen (msg);

  // get the handle for the text

  hTextEdit = pTextEdit->GetMacTEH ();
  if (hTextEdit == NULL)
    DebugStr ("\pDEBUG_WIN,WriteCharsToConsole()");

  // get a pointer to the characters and the length of the character stream

  hChar = TEGetText (hTextEdit);
  if (hChar == NULL)
    DebugStr ("\pDEBUG_WIN,WriteCharsToConsole()");

  pOriginalText = *hChar;        // get pointer to existing text

                                 // get the length of the original data
  OriginalLength = (*hTextEdit)->teLength;

  // setup a temporary buffer for the new text

  NewLength = OriginalLength + StringLength;

  pTempBuffer = NewPtr (NewLength);
  if (pTempBuffer == NULL)
    DebugStr ("\pDEBUG_WIN,WriteCharsToConsole()");

  // copy the original data into the new buffer

  for (i = 0; i < OriginalLength; i++)
    pTempBuffer[i] = pOriginalText[i];

  // append the new data onto the end of the original buffer

  for (i = 0; i < StringLength; i++) {
    if (msg[i] == '\n')
      pTempBuffer[i + OriginalLength] = '\r';
    else
      pTempBuffer[i + OriginalLength] = msg[i];
  }

  // put the new text into the text edit item

  TESetText(pTempBuffer, NewLength, hTextEdit);

  // clean up

  DisposePtr(pTempBuffer);
  #endif
}
#endif                           //Mac Implmentation

#else                            // Non graphical debugger

DEBUG_WIN::DEBUG_WIN( const char*, inT32, inT32, inT32, inT32, inT32 ) {
}

DEBUG_WIN::~DEBUG_WIN () {
}

void DEBUG_WIN::dprintf (const char *format, ...) {
  va_list ap;
  va_start(ap, format);
  vfprintf(stderr, format, ap);
  va_end(ap);
}

void await_destruction() {
}


#endif
//////////////////////////////////////////////////////////////debugwin//////////////////////////////////

//////////////////////////////////////////////////////////////tprintf//////////////////////////////////////////////////////////////////////
// Include automatically generated configuration file if running autoconf.
#ifdef HAVE_CONFIG_H
#endif

#define MAX_MSG_LEN     1024

#define EXTERN
STRING_VAR (debug_file, "", "File to send tprintf output to");
BOOL_VAR (debug_window_on, FALSE,
                 "Send tprintf to window unless file set");

//Trace printf     //special message
void tprintf(const char *format, ...)
{
    tprintfMutex.Lock();
    va_list args;                  //variable args
    static FILE *debugfp = NULL;   //debug file

    //debug window
    static DEBUG_WIN *debugwin = NULL;
    inT32 offset = 0;              //into message
    static char msg[MAX_MSG_LEN + 1];

    va_start(args, format);  //variable list
#ifdef __MSW32__
    //Format into msg
    offset += _vsnprintf (msg + offset, MAX_MSG_LEN - offset, format, args);
#else
    //Format into msg
    offset += vsprintf (msg + offset, format, args);
#endif
    va_end(args);

    if (debugfp == NULL && strlen (debug_file.string ()) > 0)
    {
        debugfp = fopen (debug_file.string (), "w");
    }
    else if (debugfp != NULL && strlen (debug_file.string ()) == 0)
    {
        fclose(debugfp);
        debugfp = NULL;
    }

    if (debugfp != NULL)
    {
        fprintf (debugfp, "%s", msg);
    }
    else
    {
        if (debug_window_on)
        {
            if (debugwin == NULL)
                //in pixels                                      //in pixels
                debugwin = new DEBUG_WIN ("Debug Window", DEBUG_WIN_XPOS, DEBUG_WIN_YPOS, DEBUG_WIN_XSIZE, DEBUG_WIN_YSIZE, debug_lines);
            debugwin->dprintf (msg);
        }
        else
        {
            fprintf (stderr, "%s", msg);
        }
    }

    tprintfMutex.Unlock();
}


/*************************************************************************
 * pause_continue()
 * UI for a debugging pause - to see an intermediate state
 * Returns TRUE to continue as normal to the next pause in the current mode;
 * FALSE to quit the current pausing mode.
 *************************************************************************/

//special message
BOOL8 pause_continue (const char *format, ...)
{
    va_list args;                  //variable args
    char msg[1000];
    STRING str = STRING ("DEBUG PAUSE:\n");

    va_start(args, format);  //variable list
    vsprintf(msg, format, args);  //Format into msg
    va_end(args);

#ifdef GRAPHICS_DISABLED
    // No interaction allowed -> simply go on
    return true;
#else

#ifdef __UNIX__
    printf ("%s\n", msg);
    printf ("Type \"c\" to cancel, anything else to continue: ");
    char c = getchar ();
    return (c != 'c');
#endif

#ifdef __MSW32__
    str +=
            STRING (msg) + STRING ("\nUse OK to continue, CANCEL to stop pausing");
    //   return AfxMessageBox( str.string(), MB_OKCANCEL ) == IDOK;
    return::MessageBox (NULL, msg, "IMGAPP",
                        MB_APPLMODAL | MB_OKCANCEL) == IDOK;
#endif

#endif
}
//////////////////////////////////////////////////////////////tprintf///////////////////////////////////////////

//////////////////////////////////////////////////////////////tovars////////////////////////////////////
#define EXTERN
EXTERN BOOL_VAR (textord_show_initial_words, FALSE, "Display separate words");
EXTERN BOOL_VAR (textord_show_new_words, FALSE, "Display separate words");
EXTERN BOOL_VAR (textord_show_fixed_words, FALSE,
"Display forced fixed pitch words");
EXTERN BOOL_VAR (textord_blocksall_fixed, FALSE, "Moan about prop blocks");
EXTERN BOOL_VAR (textord_blocksall_prop, FALSE,
"Moan about fixed pitch blocks");
EXTERN BOOL_VAR (textord_blocksall_testing, FALSE, "Dump stats when moaning");
EXTERN BOOL_VAR (textord_test_mode, FALSE, "Do current test");
EXTERN BOOL_VAR (textord_repeat_extraction, TRUE, "Extract repeated chars");
EXTERN INT_VAR (textord_dotmatrix_gap, 3,
"Max pixel gap for broken pixed pitch");
EXTERN INT_VAR (textord_repeat_threshold, 4,
"Min multiple for repeated char");
EXTERN INT_VAR (textord_debug_block, 0, "Block to do debug on");
EXTERN INT_VAR (textord_pitch_range, 2, "Max range test on pitch");
EXTERN double_VAR (textord_repeat_rating, 6, "Min rating for equal blobs");
EXTERN double_VAR(textord_repch_width_variance, 0.2,
"Max width change of gap/blob for repeated chars");
EXTERN double_VAR (textord_wordstats_smooth_factor, 0.05,
"Smoothing gap stats");
EXTERN double_VAR (textord_width_smooth_factor, 0.10,
"Smoothing width stats");
EXTERN double_VAR (textord_words_width_ile, 0.4,
"Ile of blob widths for space est");
EXTERN double_VAR (textord_words_maxspace, 4.0, "Multiple of xheight");
EXTERN double_VAR (textord_words_default_maxspace, 3.5,
"Max believable third space");
EXTERN double_VAR (textord_words_default_minspace, 0.6,
"Fraction of xheight");
EXTERN double_VAR (textord_words_min_minspace, 0.3, "Fraction of xheight");
EXTERN double_VAR (textord_words_default_nonspace, 0.2,
"Fraction of xheight");
EXTERN double_VAR (textord_words_initial_lower, 0.25,
"Max inital cluster size");
EXTERN double_VAR (textord_words_initial_upper, 0.15,
"Min initial cluster spacing");
EXTERN double_VAR (textord_words_minlarge, 0.75,
"Fraction of valid gaps needed");
EXTERN double_VAR (textord_words_pitchsd_threshold, 0.040,
"Pitch sync threshold");
EXTERN double_VAR (textord_words_def_fixed, 0.016,
"Threshold for definite fixed");
EXTERN double_VAR (textord_words_def_prop, 0.090,
"Threshold for definite prop");
EXTERN INT_VAR (textord_words_veto_power, 5,
"Rows required to outvote a veto");
EXTERN double_VAR (textord_pitch_rowsimilarity, 0.08,
"Fraction of xheight for sameness");
EXTERN BOOL_VAR (textord_pitch_scalebigwords, FALSE,
"Scale scores on big words");
EXTERN double_VAR (words_initial_lower, 0.5, "Max inital cluster size");
EXTERN double_VAR (words_initial_upper, 0.15, "Min initial cluster spacing");
EXTERN double_VAR (words_default_prop_nonspace, 0.25, "Fraction of xheight");
EXTERN double_VAR (words_default_fixed_space, 0.75, "Fraction of xheight");
EXTERN double_VAR (words_default_fixed_limit, 0.6, "Allowed size variance");
EXTERN double_VAR (textord_words_definite_spread, 0.30,
"Non-fuzzy spacing region");
EXTERN double_VAR (textord_spacesize_ratiofp, 2.8,
"Min ratio space/nonspace");
EXTERN double_VAR (textord_spacesize_ratioprop, 2.0,
"Min ratio space/nonspace");
EXTERN double_VAR (textord_fpiqr_ratio, 1.5, "Pitch IQR/Gap IQR threshold");
EXTERN double_VAR (textord_max_pitch_iqr, 0.20, "Xh fraction noise in pitch");
EXTERN double_VAR (textord_fp_min_width, 0.5, "Min width of decent blobs");
//////////////////////////////////////////////////////////////tovars////////////////////////////////////

//////////////////////////////////////////////////////////////coutln/////////////////////////////////////////////
ELISTIZE_S (C_OUTLINE)
ICOORD C_OUTLINE::step_coords[4] =
{
    ICOORD (-1, 0), ICOORD (0, -1), ICOORD (1, 0), ICOORD (0, 1)
};

/**********************************************************************
 * C_OUTLINE::C_OUTLINE
 *
 * Constructor to build a C_OUTLINE from a CRACKEDGE LOOP.
 **********************************************************************/
//constructor
C_OUTLINE::C_OUTLINE(
        CRACKEDGE * startpt,             //outline to convert
        ICOORD bot_left,                 //bounding box
        ICOORD top_right,
        inT16 length   //length of loop
        ):box(bot_left, top_right), start(startpt->pos)
{
    inT16 stepindex;               //index to step
    CRACKEDGE *edgept;             //current point

    stepcount = length;            //no of steps
    if (length == 0)
    {
        steps = NULL;
        return;
    }

    //get memory
    steps = (uinT8*)alloc_mem(step_mem());
    memset(steps, 0, step_mem());
    edgept = startpt;

    for (stepindex = 0; stepindex < length; stepindex++)
    {
        //set compact step
        set_step(stepindex, edgept->stepdir);
        edgept = edgept->next;
    }
}


/**********************************************************************
 * C_OUTLINE::C_OUTLINE
 *
 * Constructor to build a C_OUTLINE from a C_OUTLINE_FRAG.
 **********************************************************************/
C_OUTLINE::C_OUTLINE(
        //constructor
        //steps to copy
        ICOORD startpt, DIR128 * new_steps,
        inT16 length                     //length of loop
        ):start (startpt)
{
    inT8 dirdiff;                  //direction difference
    DIR128 prevdir;                //previous direction
    DIR128 dir;                    //current direction
    DIR128 lastdir;                //dir of last step
    TBOX new_box;                   //easy bounding
    inT16 stepindex;               //index to step
    inT16 srcindex;                //source steps
    ICOORD pos;                    //current position

    pos = startpt;
    stepcount = length;            //no of steps
    //get memory
    steps = (uinT8 *) alloc_mem (step_mem());
    memset(steps, 0, step_mem());

    lastdir = new_steps[length - 1];
    prevdir = lastdir;
    for (stepindex = 0, srcindex = 0; srcindex < length; stepindex++, srcindex++)
    {
        new_box = TBOX (pos, pos);
        box += new_box;
        //copy steps
        dir = new_steps[srcindex];
        set_step(stepindex, dir);
        dirdiff = dir - prevdir;
        pos += step(stepindex);

        if ((dirdiff == 64 || dirdiff == -64) && stepindex > 0)
        {
            stepindex -= 2;            //cancel there-and-back
            prevdir = stepindex >= 0 ? step_dir (stepindex) : lastdir;
        }
        else
        {
            prevdir = dir;
        }
    }
    ASSERT_HOST (pos.x () == startpt.x () && pos.y () == startpt.y ());

    do
    {
        dirdiff = step_dir (stepindex - 1) - step_dir (0);
        if (dirdiff == 64 || dirdiff == -64)
        {
            start += step (0);
            stepindex -= 2;            //cancel there-and-back
            for (int i = 0; i < stepindex; ++i)
            {
                set_step(i, step_dir(i + 1));
            }
        }
    }
    while (stepindex > 1 && (dirdiff == 64 || dirdiff == -64));
    stepcount = stepindex;
    ASSERT_HOST (stepcount >= 4);
}

/**********************************************************************
 * C_OUTLINE::C_OUTLINE
 *
 * Constructor to build a C_OUTLINE from a rotation of a C_OUTLINE.
 **********************************************************************/

C_OUTLINE::C_OUTLINE(                     //constructor
                                          C_OUTLINE *srcline,  //outline to
                                          FCOORD rotation      //rotate
                                          )
{
    TBOX new_box;                   //easy bounding
    inT16 stepindex;               //index to step
    inT16 dirdiff;                 //direction change
    ICOORD pos;                    //current position
    ICOORD prevpos;                //previous dest point

    ICOORD destpos;                //destination point
    inT16 destindex;               //index to step
    DIR128 dir;                    //coded direction
    uinT8 new_step;

    stepcount = srcline->stepcount * 2;
    if (stepcount == 0)
    {
        steps = NULL;
        box = srcline->box;
        box.rotate(rotation);
        return;
    }

    //get memory
    steps = (uinT8 *) alloc_mem (step_mem());
    memset(steps, 0, step_mem());

    for (int iteration = 0; iteration < 2; ++iteration)
    {
        DIR128 round1 = iteration == 0 ? 32 : 0;
        DIR128 round2 = iteration != 0 ? 32 : 0;
        pos = srcline->start;
        prevpos = pos;
        prevpos.rotate (rotation);
        start = prevpos;
        box = TBOX (start, start);
        destindex = 0;

        for (stepindex = 0; stepindex < srcline->stepcount; stepindex++)
        {
            pos += srcline->step (stepindex);
            destpos = pos;
            destpos.rotate (rotation);

            //  printf("%i %i %i %i ", destpos.x(), destpos.y(), pos.x(), pos.y());
            while (destpos.x () != prevpos.x () || destpos.y () != prevpos.y ())
            {
                dir = DIR128 (FCOORD (destpos - prevpos));
                dir += 64;                 //turn to step style
                new_step = dir.get_dir ();

                //  printf(" %i\n", new_step);
                if (new_step & 31)
                {
                    set_step(destindex++, dir + round1);
                    prevpos += step(destindex - 1);

                    if (destindex < 2 || ((dirdiff = step_dir (destindex - 1) - step_dir (destindex - 2)) != -64 && dirdiff != 64))
                    {
                        set_step(destindex++, dir + round2);
                        prevpos += step(destindex - 1);
                    }
                    else
                    {
                        prevpos -= step(destindex - 1);
                        destindex--;
                        prevpos -= step(destindex - 1);
                        set_step(destindex - 1, dir + round2);
                        prevpos += step(destindex - 1);
                    }
                }
                else
                {
                    set_step(destindex++, dir);
                    prevpos += step(destindex - 1);
                }

                while (destindex >= 2 && ((dirdiff = step_dir (destindex - 1) - step_dir (destindex - 2)) == -64 || dirdiff == 64))
                {
                    prevpos -= step(destindex - 1);
                    prevpos -= step(destindex - 2);
                    destindex -= 2;        // Forget u turn
                }

                //ASSERT_HOST(prevpos.x() == destpos.x() && prevpos.y() == destpos.y());
                new_box = TBOX (destpos, destpos);
                box += new_box;
            }
        }
        ASSERT_HOST (destpos.x() == start.x() && destpos.y() == start.y());
        dirdiff = step_dir (destindex - 1) - step_dir (0);

        while ((dirdiff == 64 || dirdiff == -64) && destindex > 1)
        {
            start += step(0);
            destindex -= 2;
            for (int i = 0; i < destindex; ++i)
            {
                set_step(i, step_dir(i + 1));
            }

            dirdiff = step_dir(destindex - 1) - step_dir(0);
        }

        if (destindex >= 4)
        {
            break;
        }
    }
    ASSERT_HOST(destindex <= stepcount);
    stepcount = destindex;
    destpos = start;

    for (stepindex = 0; stepindex < stepcount; stepindex++)
    {
        destpos += step (stepindex);
    }
    ASSERT_HOST (destpos.x() == start.x() && destpos.y() == start.y());
}

// Build a fake outline, given just a bounding box and append to the list.
void C_OUTLINE::FakeOutline(const TBOX& box, C_OUTLINE_LIST* outlines)
{
    C_OUTLINE_IT ol_it(outlines);

    // Make a C_OUTLINE from the bounds. This is a bit of a hack,
    // as there is no outline, just a bounding box, but it works nicely.
    CRACKEDGE start;
    start.pos = box.topleft();
    C_OUTLINE* outline = new C_OUTLINE(&start, box.topleft(), box.botright(), 0);
    ol_it.add_to_end(outline);
}

/**********************************************************************
 * C_OUTLINE::area
 *
 * Compute the area of the outline.
 **********************************************************************/

inT32 C_OUTLINE::area()
{
    //winding number
    int stepindex;                 //current step
    inT32 total_steps;             //steps to do
    inT32 total;                   //total area
    ICOORD pos;                    //position of point
    ICOORD next_step;              //step to next pix
    C_OUTLINE_IT it = child();

    pos = start_pos ();
    total_steps = pathlength();
    total = 0;
    for (stepindex = 0; stepindex < total_steps; stepindex++)
    {
        //all intersected
        next_step = step(stepindex);

        if (next_step.x() < 0)
        {
            total += pos.y();
        }
        else if (next_step.x() > 0)
        {
            total -= pos.y();
        }
        pos += next_step;
    }

    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
    {
        total += it.data()->area ();//add areas of children
    }

    return total;
}

/**********************************************************************
 * C_OUTLINE::perimeter
 *
 * Compute the perimeter of the outline and its first level children.
 **********************************************************************/

inT32 C_OUTLINE::perimeter()
{
    inT32 total_steps;             // Return value.
    C_OUTLINE_IT it = child();

    total_steps = pathlength();
    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
    {
        total_steps += it.data()->pathlength();  // Add perimeters of children.
    }

    return total_steps;
}


/**********************************************************************
 * C_OUTLINE::outer_area
 *
 * Compute the area of the outline.
 **********************************************************************/

inT32 C_OUTLINE::outer_area()
{  //winding number
    int stepindex;                 //current step
    inT32 total_steps;             //steps to do
    inT32 total;                   //total area
    ICOORD pos;                    //position of point
    ICOORD next_step;              //step to next pix

    pos = start_pos ();
    total_steps = pathlength ();

    if (total_steps == 0)
    {
        return box.area();
    }
    total = 0;

    for (stepindex = 0; stepindex < total_steps; stepindex++)
    {
        //all intersected
        next_step = step (stepindex);

        if (next_step.x () < 0)
        {
            total += pos.y ();
        }
        else if (next_step.x () > 0)
        {
            total -= pos.y ();
        }
        pos += next_step;
    }

    return total;
}


/**********************************************************************
 * C_OUTLINE::count_transitions
 *
 * Compute the number of x and y maxes and mins in the outline.
 **********************************************************************/

//winding number                   //on size
inT32 C_OUTLINE::count_transitions(inT32 threshold)
{
    BOOL8 first_was_max_x;         //what was first
    BOOL8 first_was_max_y;
    BOOL8 looking_for_max_x;       //what is next
    BOOL8 looking_for_min_x;
    BOOL8 looking_for_max_y;       //what is next
    BOOL8 looking_for_min_y;
    int stepindex;                 //current step
    inT32 total_steps;             //steps to do

    //current limits
    inT32 max_x, min_x, max_y, min_y;
    inT32 initial_x, initial_y;    //initial limits
    inT32 total;                   //total changes
    ICOORD pos;                    //position of point
    ICOORD next_step;              //step to next pix

    pos = start_pos ();
    total_steps = pathlength ();
    total = 0;
    max_x = min_x = pos.x ();
    max_y = min_y = pos.y ();
    looking_for_max_x = TRUE;
    looking_for_min_x = TRUE;
    looking_for_max_y = TRUE;
    looking_for_min_y = TRUE;
    first_was_max_x = FALSE;
    first_was_max_y = FALSE;
    initial_x = pos.x ();
    initial_y = pos.y ();          //stop uninit warning

    for (stepindex = 0; stepindex < total_steps; stepindex++)
    {
        //all intersected
        next_step = step (stepindex);
        pos += next_step;

        if (next_step.x () < 0)
        {
            if (looking_for_max_x && pos.x () < min_x)
            {
                min_x = pos.x ();
            }

            if (looking_for_min_x && max_x - pos.x () > threshold)
            {
                if (looking_for_max_x)
                {
                    initial_x = max_x;
                    first_was_max_x = FALSE;
                }

                total++;
                looking_for_max_x = TRUE;
                looking_for_min_x = FALSE;
                min_x = pos.x ();        //reset min
            }
        }
        else if (next_step.x () > 0)
        {
            if (looking_for_min_x && pos.x () > max_x)
            {
                max_x = pos.x ();
            }

            if (looking_for_max_x && pos.x () - min_x > threshold)
            {
                if (looking_for_min_x)
                {
                    initial_x = min_x;     //remember first min
                    first_was_max_x = TRUE;
                }

                total++;
                looking_for_max_x = FALSE;
                looking_for_min_x = TRUE;
                max_x = pos.x ();
            }
        }
        else if (next_step.y () < 0)
        {
            if (looking_for_max_y && pos.y () < min_y)
            {
                min_y = pos.y ();
            }

            if (looking_for_min_y && max_y - pos.y () > threshold)
            {
                if (looking_for_max_y)
                {
                    initial_y = max_y;     //remember first max
                    first_was_max_y = FALSE;
                }

                total++;
                looking_for_max_y = TRUE;
                looking_for_min_y = FALSE;
                min_y = pos.y ();        //reset min
            }
        }
        else
        {
            if (looking_for_min_y && pos.y () > max_y)
            {
                max_y = pos.y ();
            }

            if (looking_for_max_y && pos.y () - min_y > threshold)
            {
                if (looking_for_min_y)
                {
                    initial_y = min_y;     //remember first min
                    first_was_max_y = TRUE;
                }

                total++;
                looking_for_max_y = FALSE;
                looking_for_min_y = TRUE;
                max_y = pos.y ();
            }
        }

    }

    if (first_was_max_x && looking_for_min_x)
    {
        if (max_x - initial_x > threshold)
        {
            total++;
        }
        else
        {
            total--;
        }
    }
    else if (!first_was_max_x && looking_for_max_x)
    {
        if (initial_x - min_x > threshold)
        {
            total++;
        }
        else
        {
            total--;
        }
    }

    if (first_was_max_y && looking_for_min_y)
    {
        if (max_y - initial_y > threshold)
        {
            total++;
        }
        else
        {
            total--;
        }
    }
    else if (!first_was_max_y && looking_for_max_y)
    {
        if (initial_y - min_y > threshold)
        {
            total++;
        }
        else
        {
            total--;
        }
    }

    return total;
}


/**********************************************************************
 * C_OUTLINE::operator<
 *
 * Return TRUE if the left operand is inside the right one.
 **********************************************************************/

//winding number            //other outline
BOOL8 C_OUTLINE::operator< (const C_OUTLINE & other) const
{
    inT16 count = 0;               //winding count
    ICOORD pos;                    //position of point
    inT32 stepindex;               //index to cstep

    if (!box.overlap (other.box))
    {
        return FALSE;                //can't be contained
    }

    if (stepcount == 0)
    {
        return other.box.contains(this->box);
    }

    pos = start;
    for (stepindex = 0; stepindex < stepcount && (count = other.winding_number (pos)) == INTERSECTING; stepindex++)
    {
        pos += step (stepindex);     //try all points
    }

    if (count == INTERSECTING)
    {
        //all intersected
        pos = other.start;
        for (stepindex = 0; stepindex < other.stepcount && (count = winding_number (pos)) == INTERSECTING; stepindex++)
        {
            //try other way round
            pos += other.step (stepindex);
        }

        return count == INTERSECTING || count == 0;
    }

    return count != 0;
}


/**********************************************************************
 * C_OUTLINE::winding_number
 *
 * Return the winding number of the outline around the given point.
 **********************************************************************/

//winding number                //point to wind around
inT16 C_OUTLINE::winding_number(ICOORD point) const
{
    inT16 stepindex;               //index to cstep
    inT16 count;                   //winding count
    ICOORD vec;                    //to current point
    ICOORD stepvec;                //step vector
    inT32 cross;                   //cross product

    vec = start - point;           //vector to it
    count = 0;

    for (stepindex = 0; stepindex < stepcount; stepindex++)
    {
        stepvec = step (stepindex);  //get the step

        //crossing the line
        if (vec.y () <= 0 && vec.y () + stepvec.y () > 0)
        {
            cross = vec * stepvec;     //cross product

            if (cross > 0)
            {
                count++;                 //crossing right half
            }
            else if (cross == 0)
            {
                return INTERSECTING;     //going through point
            }
        }
        else if (vec.y () > 0 && vec.y () + stepvec.y () <= 0)
        {
            cross = vec * stepvec;

            if (cross < 0)
            {
                count--;                 //crossing back
            }
            else if (cross == 0)
            {
                return INTERSECTING;     //illegal
            }
        }

        vec += stepvec;              //sum vectors
    }

    return count;                  //winding number
}


/**********************************************************************
 * C_OUTLINE::turn_direction
 *
 * Return the sum direction delta of the outline.
 **********************************************************************/

inT16 C_OUTLINE::turn_direction() const
{  //winding number
    DIR128 prevdir;                //previous direction
    DIR128 dir;                    //current direction
    inT16 stepindex;               //index to cstep
    inT8 dirdiff;                  //direction difference
    inT16 count;                   //winding count

    if (stepcount == 0)
    {
        return 128;
    }

    count = 0;
    prevdir = step_dir (stepcount - 1);

    for (stepindex = 0; stepindex < stepcount; stepindex++)
    {
        dir = step_dir (stepindex);
        dirdiff = dir - prevdir;

        ASSERT_HOST (dirdiff == 0 || dirdiff == 32 || dirdiff == -32);

        count += dirdiff;
        prevdir = dir;
    }
    ASSERT_HOST (count == 128 || count == -128);

    return count;                  //winding number
}


/**********************************************************************
 * C_OUTLINE::reverse
 *
 * Reverse the direction of an outline.
 **********************************************************************/

void C_OUTLINE::reverse()
{  //reverse drection
    DIR128 halfturn = MODULUS / 2; //amount to shift
    DIR128 stepdir;                //direction of step
    inT16 stepindex;               //index to cstep
    inT16 farindex;                //index to other side
    inT16 halfsteps;               //half of stepcount

    halfsteps = (stepcount + 1) / 2;
    for (stepindex = 0; stepindex < halfsteps; stepindex++)
    {
        farindex = stepcount - stepindex - 1;
        stepdir = step_dir (stepindex);
        set_step (stepindex, step_dir (farindex) + halfturn);
        set_step (farindex, stepdir + halfturn);
    }
}


/**********************************************************************
 * C_OUTLINE::move
 *
 * Move C_OUTLINE by vector
 **********************************************************************/

// reposition OUTLINE  // by vector
void C_OUTLINE::move(const ICOORD vec)
{
    C_OUTLINE_IT it(&children);  // iterator

    box.move (vec);
    start += vec;

    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
    {
        it.data ()->move (vec);      // move child outlines
    }
}

// If this outline is smaller than the given min_size, delete this and
// remove from its list, via *it, after checking that *it points to this.
// Otherwise, if any children of this are too small, delete them.
// On entry, *it must be an iterator pointing to this. If this gets deleted
// then this is extracted from *it, so an iteration can continue.
void C_OUTLINE::RemoveSmallRecursive(int min_size, C_OUTLINE_IT* it)
{
    if (box.width() < min_size || box.height() < min_size)
    {
        ASSERT_HOST(this == it->data());
        delete it->extract();  // Too small so get rid of it and any children.
    }
    else if (!children.empty())
    {
        // Search the children of this, deleting any that are too small.
        C_OUTLINE_IT child_it(&children);

        for (child_it.mark_cycle_pt(); !child_it.cycled_list(); child_it.forward())
        {
            C_OUTLINE* child = child_it.data();
            child->RemoveSmallRecursive(min_size, &child_it);
        }
    }
}

/**********************************************************************
 * C_OUTLINE::plot
 *
 * Draw the outline in the given colour.
 **********************************************************************/

#ifndef GRAPHICS_DISABLED
//draw it            //window to draw in   //colour to draw in
void C_OUTLINE::plot(ScrollView* window, ScrollView::Color colour) const
{
    inT16 stepindex;               //index to cstep
    ICOORD pos;                    //current position
    DIR128 stepdir;                //direction of step
    DIR128 oldstepdir;             //previous stepdir

    pos = start;                   //current position
    window->Pen(colour);
    if (stepcount == 0)
    {
        window->Rectangle(box.left(), box.top(), box.right(), box.bottom());
        return;
    }
    window->SetCursor(pos.x(), pos.y());

    stepindex = 0;
    stepdir = step_dir (0);        //get direction
    while (stepindex < stepcount)
    {
        do
        {
            pos += step (stepindex);   //step to next
            stepindex++;               //count steps
            oldstepdir = stepdir;
            //new direction
            stepdir = step_dir (stepindex);
        }
        while (stepindex < stepcount && oldstepdir.get_dir () == stepdir.get_dir ());
        //merge straight lines
        window->DrawTo(pos.x(), pos.y());
    }
}
#endif


/**********************************************************************
 * C_OUTLINE::operator=
 *
 * Assignment - deep copy data
 **********************************************************************/

//assignment                      //from this
C_OUTLINE & C_OUTLINE::operator= (const C_OUTLINE & source)
{
    box = source.box;
    start = source.start;
    if (steps != NULL)
    {
        free_mem(steps);
    }

    stepcount = source.stepcount;
    steps = (uinT8 *) alloc_mem (step_mem());
    memmove (steps, source.steps, step_mem());

    if (!children.empty ())
    {
        children.clear ();
    }

    children.deep_copy(&source.children, &deep_copy);

    return *this;
}

ICOORD C_OUTLINE::chain_step(int chaindir)
{
    return step_coords[chaindir % 4];
}
//////////////////////////////////////////////////////////////coutln/////////////////////////////////////////////

//////////////////////////////////////////////////////////////scanutils///////////////////////////////////////
enum Flags {
  FL_SPLAT  = 0x01,   // Drop the value, do not assign
  FL_INV    = 0x02,   // Character-set with inverse
  FL_WIDTH  = 0x04,   // Field width specified
  FL_MINUS  = 0x08,   // Negative number
};

enum Ranks {
  RANK_CHAR = -2,
  RANK_SHORT  = -1,
  RANK_INT  = 0,
  RANK_LONG = 1,
  RANK_LONGLONG = 2,
  RANK_PTR      = INT_MAX // Special value used for pointers
//  RANK_PTR      = 3 // Special value used for pointers
};

const enum Ranks kMinRank = RANK_CHAR;
const enum Ranks kMaxRank = RANK_LONGLONG;

const enum Ranks kIntMaxRank = RANK_LONGLONG;
const enum Ranks kSizeTRank = RANK_LONG;
const enum Ranks kPtrDiffRank = RANK_LONG;

enum Bail {
  BAIL_NONE = 0,    // No error condition
  BAIL_EOF,         // Hit EOF
  BAIL_ERR          // Conversion mismatch
};

// Helper functions ------------------------------------------------------------
inline size_t LongBit() {
  return CHAR_BIT * sizeof(long);
}

static inline int
SkipSpace(FILE *s)
{
  int p;
  while (isspace(p = fgetc(s)));
  ungetc(p, s);  // Make sure next char is available for reading
  return p;
}

static inline void
SetBit(unsigned long *bitmap, unsigned int bit)
{
  bitmap[bit/LongBit()] |= 1UL << (bit%LongBit());
}

static inline int
TestBit(unsigned long *bitmap, unsigned int bit)
{
  return static_cast<int>(bitmap[bit/LongBit()] >> (bit%LongBit())) & 1;
}

static inline int DigitValue(int ch)
{
  if (ch >= '0' && ch <= '9') {
    return ch-'0';
  } else if (ch >= 'A' && ch <= 'Z') {
    return ch-'A'+10;
  } else if (ch >= 'a' && ch <= 'z') {
    return ch-'a'+10;
  } else {
    return -1;
  }
}

// IO (re-)implementations -----------------------------------------------------
uintmax_t streamtoumax(FILE* s, int base)
{
  int minus = 0;
  uintmax_t v = 0;
  int d, c = 0;

  for (c = fgetc(s);
    isspace(static_cast<unsigned char>(c)) && (c != EOF);
    c = fgetc(s))

  // Single optional + or -
  if (c == '-' || c == '+') {
    minus = (c == '-');
    c = fgetc(s);
  }

  // Assign correct base
  if (base == 0) {
    if (c == '0') {
      c = fgetc(s);
      if (c == 'x' || c == 'X') {
        base = 16;
        c = fgetc(s);
      } else {
        base = 8;
      }
    }
  } else if (base == 16) {
    if (c == '0') {
      c = fgetc(s);
      if (c == 'x' && c == 'X') c = fgetc(s);
    }
  }

  // Actual number parsing
  for (; (c != EOF) && (d = DigitValue(c)) >= 0 && d < base; c = fgetc(s))
    v = v*base + d;

  ungetc(c, s);
  return minus ? -v : v;
}

double streamtofloat(FILE* s)
{
  int minus = 0;
  int v = 0;
  int d, c = 0;
  int k = 1;
  int w = 0;

  for (c = fgetc(s);
    isspace(static_cast<unsigned char>(c)) && (c != EOF);
    c = fgetc(s));

  // Single optional + or -
  if (c == '-' || c == '+') {
    minus = (c == '-');
    c = fgetc(s);
  }

  // Actual number parsing
  for (; (c != EOF) && (d = DigitValue(c)) >= 0; c = fgetc(s))
    v = v*10 + d;
  if (c == '.') {
    for (c = fgetc(s); (c != EOF) && (d = DigitValue(c)) >= 0; c = fgetc(s)) {
      w = w*10 + d;
      k *= 10;
    }
  } else if (c == 'e' || c == 'E')
    tprintf("WARNING: Scientific Notation not supported!");

  ungetc(c, s);
  double f  = static_cast<double>(v)
            + static_cast<double>(w) / static_cast<double>(k);

  return minus ? -f : f;
}

double strtofloat(const char* s)
{
  int minus = 0;
  int v = 0;
  int d;
  int k = 1;
  int w = 0;

  while(*s && isspace(static_cast<unsigned char>(*s))) s++;

  // Single optional + or -
  if (*s == '-' || *s == '+') {
    minus = (*s == '-');
    s++;
  }

  // Actual number parsing
  for (; *s && (d = DigitValue(*s)) >= 0; s++)
    v = v*10 + d;
  if (*s == '.') {
    for (++s; *s && (d = DigitValue(*s)) >= 0; s++) {
      w = w*10 + d;
      k *= 10;
    }
  } else if (*s == 'e' || *s == 'E')
    tprintf("WARNING: Scientific Notation not supported!");

  double f  = static_cast<double>(v)
            + static_cast<double>(w) / static_cast<double>(k);

  return minus ? -f : f;
}

static int tess_vfscanf(FILE* stream, const char *format, va_list ap);

int tess_fscanf(FILE* stream, const char *format, ...)
{
  va_list ap;
  int rv;

  va_start(ap, format);
  rv = tess_vfscanf(stream, format, ap);
  va_end(ap);

  return rv;
}

#ifdef EMBEDDED
int fscanf(FILE* stream, const char *format, ...)
{
  va_list ap;
  int rv;

  va_start(ap, format);
  rv = tess_vfscanf(stream, format, ap);
  va_end(ap);

  return rv;
}

int vfscanf(FILE* stream, const char *format, ...)
{
  va_list ap;
  int rv;

  va_start(ap, format);
  rv = tess_vfscanf(stream, format, ap);
  va_end(ap);

  return rv;
}
#endif

#ifndef _MSV_VER
static
int tess_vfscanf(FILE* stream, const char *format, va_list ap)
{
  const char *p = format;
  char ch;
  int q = 0;
  uintmax_t val = 0;
  int rank = RANK_INT;    // Default rank
  unsigned int width = ~0;
  int base;
  int flags = 0;
  enum {
    ST_NORMAL,        // Ground state
    ST_FLAGS,         // Special flags
    ST_WIDTH,         // Field width
    ST_MODIFIERS,     // Length or conversion modifiers
    ST_MATCH_INIT,    // Initial state of %[ sequence
    ST_MATCH,         // Main state of %[ sequence
    ST_MATCH_RANGE,   // After - in a %[ sequence
  } state = ST_NORMAL;
  char *sarg = NULL;    // %s %c or %[ string argument
  enum Bail bail = BAIL_NONE;
  int sign = 0;
  int converted = 0;    // Successful conversions
  unsigned long matchmap[((1 << CHAR_BIT)+(LongBit()-1))/LongBit()];
  int matchinv = 0;   // Is match map inverted?
  unsigned char range_start = 0;
  off_t start_off = ftell(stream);
  double fval;

  Q_UNUSED(sign);

  // Skip leading spaces
  SkipSpace(stream);

  while ((ch = *p++) && !bail) {
    switch (state) {
      case ST_NORMAL:
        if (ch == '%') {
          state = ST_FLAGS;
          flags = 0; rank = RANK_INT; width = ~0;
        } else if (isspace(static_cast<unsigned char>(ch))) {
          SkipSpace(stream);
        } else {
          if (fgetc(stream) != ch)
            bail = BAIL_ERR;  // Match failure
        }
        break;

      case ST_FLAGS:
        switch (ch) {
          case '*':
            flags |= FL_SPLAT;
          break;

          case '0' ... '9':
            width = (ch-'0');
            state = ST_WIDTH;
            flags |= FL_WIDTH;
          break;

          default:
            state = ST_MODIFIERS;
            p--;      // Process this character again
          break;
        }
      break;

      case ST_WIDTH:
        if (ch >= '0' && ch <= '9') {
          width = width*10+(ch-'0');
        } else {
          state = ST_MODIFIERS;
          p--;      // Process this character again
        }
      break;

      case ST_MODIFIERS:
        switch (ch) {
          // Length modifiers - nonterminal sequences
          case 'h':
            rank--;     // Shorter rank
          break;
          case 'l':
            rank++;     // Longer rank
          break;
          case 'j':
            rank = kIntMaxRank;
          break;
          case 'z':
            rank = kSizeTRank;
          break;
          case 't':
            rank = kPtrDiffRank;
          break;
          case 'L':
          case 'q':
            rank = RANK_LONGLONG; // long double/long long
          break;

          default:
            // Output modifiers - terminal sequences
            state = ST_NORMAL;  // Next state will be normal
            if (rank < kMinRank)  // Canonicalize rank
              rank = kMinRank;
            else if (rank > kMaxRank)
              rank = kMaxRank;

          switch (ch) {
            case 'P':   // Upper case pointer
            case 'p':   // Pointer
              rank = RANK_PTR;
              base = 0; sign = 0;
            goto scan_int;

            case 'i':   // Base-independent integer
              base = 0; sign = 1;
            goto scan_int;

            case 'd':   // Decimal integer
              base = 10; sign = 1;
            goto scan_int;

            case 'o':   // Octal integer
              base = 8; sign = 0;
            goto scan_int;

            case 'u':   // Unsigned decimal integer
              base = 10; sign = 0;
            goto scan_int;

            case 'x':   // Hexadecimal integer
            case 'X':
              base = 16; sign = 0;
            goto scan_int;

            case 'n':   // Number of characters consumed
              val = ftell(stream) - start_off;
            goto set_integer;

            scan_int:
              q = SkipSpace(stream);
              if ( q <= 0 ) {
                bail = BAIL_EOF;
                break;
              }
              val = streamtoumax(stream, base);
              converted++;
              // fall through

            set_integer:
              if (!(flags & FL_SPLAT)) {
                switch(rank) {
                  case RANK_CHAR:
                    *va_arg(ap, unsigned char *)
                      = static_cast<unsigned char>(val);
                  break;
                  case RANK_SHORT:
                    *va_arg(ap, unsigned short *)
                      = static_cast<unsigned short>(val);
                  break;
                  case RANK_INT:
                    *va_arg(ap, unsigned int *)
                      = static_cast<unsigned int>(val);
                  break;
                  case RANK_LONG:
                    *va_arg(ap, unsigned long *)
                      = static_cast<unsigned long>(val);
                  break;
                  case RANK_LONGLONG:
                    *va_arg(ap, unsigned long long *)
                      = static_cast<unsigned long long>(val);
                  break;
                  case RANK_PTR:
                    *va_arg(ap, void **)
                      = reinterpret_cast<void *>(static_cast<uintptr_t>(val));
                  break;
                }
              }
            break;

            case 'f':   // Preliminary float value parsing
            case 'g':
            case 'G':
            case 'e':
            case 'E':
              q = SkipSpace(stream);
              if (q <= 0) {
                bail = BAIL_EOF;
                break;
              }

              fval = streamtofloat(stream);
              switch(rank) {
                case RANK_INT:
                  *va_arg(ap, float *) = static_cast<float>(fval);
                break;
                case RANK_LONG:
                  *va_arg(ap, double *) = static_cast<double>(fval);
                break;
              }
              converted++;
            break;

            case 'c':               // Character
              width = (flags & FL_WIDTH) ? width : 1; // Default width == 1
              sarg = va_arg(ap, char *);
              while (width--) {
                if ((q = fgetc(stream)) <= 0) {
                  bail = BAIL_EOF;
                  break;
                }
                *sarg++ = q;
              }
              if (!bail)
                converted++;
            break;

            case 's':               // String
            {
              char *sp;
              sp = sarg = va_arg(ap, char *);
              while (width--) {
                q = fgetc(stream);
                if (isspace(static_cast<unsigned char>(q)) || q <= 0) {
                  ungetc(q, stream);
                  break;
                }
                *sp++ = q;
              }
              if (sarg != sp) {
                *sp = '\0'; // Terminate output
                converted++;
              } else {
                bail = BAIL_EOF;
              }
            }
            break;

            case '[':   // Character range
              sarg = va_arg(ap, char *);
              state = ST_MATCH_INIT;
              matchinv = 0;
              memset(matchmap, 0, sizeof matchmap);
            break;

            case '%':   // %% sequence
              if (fgetc(stream) != '%' )
                bail = BAIL_ERR;
            break;

            default:    // Anything else
              bail = BAIL_ERR;  // Unknown sequence
            break;
          }
        }
      break;

      case ST_MATCH_INIT:   // Initial state for %[ match
        if (ch == '^' && !(flags & FL_INV)) {
          matchinv = 1;
        } else {
          SetBit(matchmap, static_cast<unsigned char>(ch));
          state = ST_MATCH;
        }
      break;

      case ST_MATCH:    // Main state for %[ match
        if (ch == ']') {
          goto match_run;
        } else if (ch == '-') {
          range_start = static_cast<unsigned char>(ch);
          state = ST_MATCH_RANGE;
        } else {
          SetBit(matchmap, static_cast<unsigned char>(ch));
        }
      break;

      case ST_MATCH_RANGE:    // %[ match after -
        if (ch == ']') {
          SetBit(matchmap, static_cast<unsigned char>('-'));
          goto match_run;
        } else {
          int i;
          for (i = range_start ; i < (static_cast<unsigned char>(ch)) ; i++)
          SetBit(matchmap, i);
          state = ST_MATCH;
        }
      break;

      match_run:      // Match expression finished
        char* oarg = sarg;
        while (width) {
          q = fgetc(stream);
          unsigned char qc = static_cast<unsigned char>(q);
          if (q <= 0 || !(TestBit(matchmap, qc)^matchinv)) {
            ungetc(q, stream);
            break;
          }
          *sarg++ = q;
        }
        if (oarg != sarg) {
          *sarg = '\0';
          converted++;
        } else {
          bail = (q <= 0) ? BAIL_EOF : BAIL_ERR;
        }
      break;
    }
  }

  if (bail == BAIL_EOF && !converted)
    converted = -1;   // Return EOF (-1)

  return converted;
}
#endif

#ifdef EMBEDDED
int creat(const char *pathname, mode_t mode)
{
  return open(pathname, O_CREAT | O_TRUNC | O_WRONLY, mode);
}
#endif
//////////////////////////////////////////////////////////////scanutils//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////serialis//////////////////////////////////////////////////////////////////////
void *de_serialise_bytes(FILE *f, int size) {
  void *ptr;

  ptr = alloc_mem (size);
  /*
  printf( "De_serialising bytes\n" );
  printf( "  Addr: %d    Size: %d\n", int(ptr), size );
  */
  if (fread (ptr, size, 1, f) != 1)
    READFAILED.error ("de_serialise_bytes", ABORT, NULL);
  return ptr;
}


void serialise_bytes(FILE *f, void *ptr, int size) {
  /*
  printf( "Serialising bytes\n" );
  printf( "  Addr: %d    Size: %d\n", int(ptr), size );
  */
  if (fwrite (ptr, size, 1, f) != 1)
    WRITEFAILED.error ("serialise_bytes", ABORT, NULL);
}


void serialise_INT32(FILE *f, inT32 the_int) {
  if (fprintf (f, INT32FORMAT "\n", the_int) < 0)
    WRITEFAILED.error ("serialise_INT32", ABORT, NULL);
}


inT32 de_serialise_INT32(FILE *f) {
  inT32 the_int;

  if (fscanf (f, INT32FORMAT, &the_int) != 1)
    READFAILED.error ("de_serialise_INT32", ABORT, NULL);
  return the_int;
}


void serialise_FLOAT64(FILE *f, double the_float) {
  if (fprintf (f, "%g\n", the_float) < 0)
    WRITEFAILED.error ("serialise_FLOAT64", ABORT, NULL);
}


double de_serialise_FLOAT64(FILE *f) {
  double the_float;

#ifndef _MSC_VER
  if (tess_fscanf (f, "%lg", &the_float) != 1)
#else
  if (fscanf (f, "%lg", &the_float) != 1)
#endif
    READFAILED.error ("de_serialise_FLOAT64", ABORT, NULL);
  return the_float;
}

// Byte swap an inT64 or uinT64.
uinT64 reverse64(uinT64 num) {
  return ((uinT64)reverse32((uinT32)(num & 0xffffffff)) << 32)
    | reverse32((uinT32)((num >> 32) & 0xffffffff));
}

/**********************************************************************
 * reverse32
 *
 * Byte swap an inT32 or uinT32.
 **********************************************************************/

uinT32 reverse32(            //switch endian
                        uinT32 num  //number to fix
                       ) {
  return (reverse16 ((uinT16) (num & 0xffff)) << 16)
    | reverse16 ((uinT16) ((num >> 16) & 0xffff));
}


/**********************************************************************
 * reverse16
 *
 * Byte swap an inT16 or uinT16.
 **********************************************************************/

 uinT16 reverse16(            //switch endian
                        uinT16 num  //number to fix
                       ) {
  return ((num & 0xff) << 8) | ((num >> 8) & 0xff);
}
//////////////////////////////////////////////////////////////serialis//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////STRING//////////////////////////////////////////////////////////////////////
// kDataCacheSize is cache of last n min sized buffers freed for
// cheap recyling
const int kDataCacheSize = 8;  // max number of buffers cached
// Size of buffer needed to host the decimal representation of the maximum
// possible length of an int (in 64 bits, being -<20 digits>.
const int kMaxIntSize = 22;


#if 1
#define CHECK_INVARIANT(s)  // EMPTY
#else
static void check_used_(int len, const char *s)
{
  bool ok;

  if (len == 0)
  {
    ok = (s == NULL);
  }
  else
  {
    ok = (len == (strlen(s) + 1));
  }

  if (!ok)  abort();
}

#define CHECK_INVARIANT(s)  check_used_(s->GetHeader()->used_, s->string())
#endif

// put recycled buffers into a class so we can destroy it on exit
class DataCache
{
 public:
  DataCache()
  {
    top_ = 0;
  }

  ~DataCache()
  {
    while (--top_ >= 0) free_string((char *)stack_[top_]);
  }

  // Allocate a buffer out of this cache.
  // Returs NULL if there are no cached buffers.
  // The buffers in the cache can be freed using string_free.
  void* alloc()
  {
    if (top_ == 0) return NULL;

    return stack_[--top_];
  }

  // Free pointer either by caching it on the stack of pointers
  // or freeing it with string_free if there isnt space left to cache it.
  // s should have capacity kMinCapacity.
  void free(void* p)
  {
    if (top_ == kDataCacheSize)
    {
      free_string((char *)p);
    }
    else
    {
      stack_[top_++] = p;
    }
  }

  // Stack of discarded but not-yet freed pointers.
  void* stack_[kDataCacheSize];

  // Top of stack, points to element after last cached pointer
  int   top_;
};

static DataCache MinCapacityDataCache;


/**********************************************************************
 * STRING_HEADER provides metadata about the allocated buffer,
 * including total capacity and how much used (strlen with '\0').
 *
 * The implementation hides this header at the start of the data
 * buffer and appends the string on the end to keep sizeof(STRING)
 * unchanged from earlier versions so serialization is not affected.
 *
 * The collection of MACROS provide different implementations depending
 * on whether the string keeps track of its strlen or not so that this
 * feature can be added in later when consumers dont modifify the string
 **********************************************************************/

// Smallest string to allocate by default
const int kMinCapacity = 16;

char* STRING::AllocData(int used, int capacity)
{
  if ((capacity != kMinCapacity) || ((data_ = (STRING_HEADER *)MinCapacityDataCache.alloc()) == NULL))
  {
    data_ = (STRING_HEADER *)alloc_string(capacity + sizeof(STRING_HEADER));
  }

  // header is the metadata for this memory block
  STRING_HEADER* header = GetHeader();
  header->capacity_ = capacity;
  header->used_ = used;

  return GetCStr();
}

void STRING::DiscardData()
{
  STRING_HEADER* header = GetHeader();
  if (header->capacity_ == kMinCapacity)
  {
    MinCapacityDataCache.free(data_);
  }
  else
  {
    free_string((char *)data_);
  }
}

// This is a private method; ensure FixHeader is called (or used_ is well defined)
// beforehand
char* STRING::ensure_cstr(inT32 min_capacity)
{
  STRING_HEADER* orig_header = GetHeader();
  if (min_capacity <= orig_header->capacity_)
  {
    return ((char *)this->data_) + sizeof(STRING_HEADER);
  }

  // if we are going to grow bigger, than double our existing
  // size, but if that still is not big enough then keep the
  // requested capacity
  if (min_capacity < 2 * orig_header->capacity_)
  {
    min_capacity = 2 * orig_header->capacity_;
  }

  int alloc = sizeof(STRING_HEADER) + min_capacity;
  STRING_HEADER* new_header = (STRING_HEADER*)(alloc_string(alloc));

  memcpy(&new_header[1], GetCStr(), orig_header->used_);
  new_header->capacity_ = min_capacity;
  new_header->used_ = orig_header->used_;

  // free old memory, then rebind to new memory
  DiscardData();
  data_ = new_header;

  CHECK_INVARIANT(this);
  return ((char *)data_) + sizeof(STRING_HEADER);
}

// This is const, but is modifying a mutable field
// this way it can be used on const or non-const instances.
void STRING::FixHeader() const
{
  const STRING_HEADER* header = GetHeader();
  if (header->used_ < 0) header->used_ = strlen(GetCStr()) + 1;
}


STRING::STRING()
{
  // 0 indicates old NULL -- it doesnt even have '\0'
  AllocData(0, kMinCapacity);
}

STRING::STRING(const STRING& str)
{
  str.FixHeader();
  const STRING_HEADER* str_header  = str.GetHeader();
  int   str_used  = str_header->used_;
  char *this_cstr = AllocData(str_used, str_used);
  memcpy(this_cstr, str.GetCStr(), str_used);
  CHECK_INVARIANT(this);
}

STRING::STRING(const char* cstr)
{
  if (cstr == NULL)
  {
    AllocData(0, 0);
  }
  else
  {
    int len = strlen(cstr) + 1;
    char* this_cstr = AllocData(len, len);
    memcpy(this_cstr, cstr, len);
  }

  CHECK_INVARIANT(this);
}

STRING::~STRING()
{
  DiscardData();
}

BOOL8 STRING::contains(const char c) const
{
  return (c != '\0') && (strchr (GetCStr(), c) != NULL);
}

inT32 STRING::length() const
{
  FixHeader();
  return GetHeader()->used_ - 1;
}

const char* STRING::string() const
{
  const STRING_HEADER* header = GetHeader();
  if (header->used_ == 0) return NULL;

  // mark header length unreliable because tesseract might
  // cast away the const and mutate the string directly.
  header->used_ = -1;

  return GetCStr();
}

/******
 * The STRING_IS_PROTECTED interface adds additional support to migrate
 * code that needs to modify the STRING in ways not otherwise supported
 * without violating encapsulation.
 *
 * Also makes the [] operator return a const so it is immutable
 */
#if STRING_IS_PROTECTED
const char& STRING::operator[](inT32 index) const
{
  return GetCStr()[index];
}

void STRING::insert_range(inT32 index, const char* str, int len)
{
  // if index is outside current range, then also grow size of string
  // to accmodate the requested range.
  STRING_HEADER* this_header = GetHeader();
  int used = this_header->used_;
  if (index > used) used = index;

  char* this_cstr = ensure_cstr(used + len + 1);
  if (index < used)
  {
    // move existing string from index to '\0' inclusive.
    memmove(this_cstr + index + len, this_cstr + index, this_header->used_ - index);
  }
  else if (len > 0)
  {
    // We are going to overwrite previous null terminator, so write the new one.
    this_cstr[this_header->used_ + len - 1] = '\0';

    // If the old header did not have the terminator,
    // then we need to account for it now that we've added it.
    // Otherwise it was already accounted for; we just moved it.
    if (this_header->used_ == 0)
      ++this_header->used_;
  }

  // Write new string to index.
  // The string is already terminated from the conditions above.
  memcpy(this_cstr + index, str, len);
  this_header->used_ += len;

  CHECK_INVARIANT(this);
}

void STRING::erase_range(inT32 index, int len)
{
  char* this_cstr = GetCStr();
  STRING_HEADER* this_header = GetHeader();

  memcpy(this_cstr+index, this_cstr+index+len, this_header->used_ - index - len);
  this_header->used_ -= len;
  CHECK_INVARIANT(this);
}

void STRING::truncate_at(inT32 index)
{
  char* this_cstr = ensure_cstr(index);
  this_cstr[index] = '\0';
  GetHeader()->used_ = index;
  CHECK_INVARIANT(this);
}

#else
char& STRING::operator[](inT32 index) const
{
  // Code is casting away this const and mutating the string,
  // so mark used_ as -1 to flag it unreliable.
  GetHeader()->used_ = -1;

  return ((char *)GetCStr())[index];
}
#endif

BOOL8 STRING::operator==(const STRING& str) const
{
  FixHeader();
  str.FixHeader();
  const STRING_HEADER* str_header = str.GetHeader();
  const STRING_HEADER* this_header = GetHeader();
  int this_used = this_header->used_;
  int str_used  = str_header->used_;

  return (this_used == str_used) && (memcmp(GetCStr(), str.GetCStr(), this_used) == 0);
}

BOOL8 STRING::operator!=(const STRING& str) const
{
  FixHeader();
  str.FixHeader();
  const STRING_HEADER* str_header = str.GetHeader();
  const STRING_HEADER* this_header = GetHeader();
  int this_used = this_header->used_;
  int str_used  = str_header->used_;

  return (this_used != str_used) || (memcmp(GetCStr(), str.GetCStr(), this_used) != 0);
}

BOOL8 STRING::operator!=(const char* cstr) const
{
  FixHeader();
  const STRING_HEADER* this_header = GetHeader();

  if (cstr == NULL)
  {
    return this_header->used_ > 1;  // either '\0' or NULL
  }
  else
  {
    inT32 length = strlen(cstr) + 1;

    return (this_header->used_ != length) || (memcmp(GetCStr(), cstr, length) != 0);
  }
}

STRING& STRING::operator=(const STRING& str)
{
  str.FixHeader();
  const STRING_HEADER* str_header = str.GetHeader();
  int   str_used = str_header->used_;

  GetHeader()->used_ = 0;  // clear since ensure doesnt need to copy data
  char* this_cstr = ensure_cstr(str_used);
  STRING_HEADER* this_header = GetHeader();

  memcpy(this_cstr, str.GetCStr(), str_used);
  this_header->used_ = str_used;

  CHECK_INVARIANT(this);

  return *this;
}

STRING & STRING::operator+=(const STRING& str)
{
  FixHeader();
  str.FixHeader();
  const STRING_HEADER* str_header = str.GetHeader();
  const char* str_cstr = str.GetCStr();
  int  str_used  = str_header->used_;
  int  this_used = GetHeader()->used_;
  char* this_cstr = ensure_cstr(this_used + str_used);

  STRING_HEADER* this_header = GetHeader();  // after ensure for realloc

  if (this_used > 1)
  {
    memcpy(this_cstr + this_used - 1, str_cstr, str_used);
    this_header->used_ += str_used - 1;  // overwrite '\0'
  }
  else
  {
    memcpy(this_cstr, str_cstr, str_used);
    this_header->used_ = str_used;
  }

  CHECK_INVARIANT(this);

  return *this;
}

// Appends the given string and int (as a %d) to this.
// += cannot be used for ints as there as a char += operator that would
// be ambiguous, and ints usually need a string before or between them
// anyway.
void STRING::add_str_int(const char* str, int number)
{
  *this += str;

    // Allow space for the maximum possible length of inT64.
  char num_buffer[kMaxIntSize];
  num_buffer[kMaxIntSize - 1] = '\0';
  snprintf(num_buffer, kMaxIntSize - 1, "%d", number);
  *this += num_buffer;
}

void STRING::prep_serialise()
{
  // WARNING
  // This method should only be called on a shallow bitwise copy
  // by the serialise() method (see serialis.h).
  FixHeader();
//  data_ = (STRING_HEADER *)GetHeader()->used_; //cwj
  data_ = (STRING_HEADER *)GetHeader();
}

void STRING::dump(FILE* f)
{
  FixHeader();
  serialise_bytes (f, data_, GetHeader()->used_);
}

void STRING::de_dump(FILE* f)
{
  char *instring;            //input from read
  fprintf(stderr, "de_dump\n");
  instring = (char *)de_serialise_bytes(f, (ptrdiff_t)data_);
  int len = strlen(instring) + 1;

  char* this_cstr = AllocData(len, len);
  STRING_HEADER* this_header = GetHeader();

  memcpy(this_cstr, instring, len);
  this_header->used_ = len;

  free_mem(instring);
  CHECK_INVARIANT(this);
}


STRING & STRING::operator=(const char* cstr)
{
  STRING_HEADER* this_header = GetHeader();

  if (cstr)
  {
    int len = strlen(cstr) + 1;

    this_header->used_ = 0;  // dont bother copying data if need to realloc
    char* this_cstr = ensure_cstr(len);
    this_header = GetHeader();  // for realloc
    memcpy(this_cstr, cstr, len);
    this_header->used_ = len;
  }
  else
  {
    // Reallocate to zero capacity buffer, consistent with the corresponding
    // copy constructor.
    DiscardData();
    AllocData(0, 0);
  }

  CHECK_INVARIANT(this);

  return *this;
}

STRING STRING::operator+(const STRING& str) const
{
  STRING result(*this);
  result += str;

  CHECK_INVARIANT(this);
  return result;
}


STRING STRING::operator+(const char ch) const
{
  STRING result;
  FixHeader();
  const STRING_HEADER* this_header = GetHeader();
  int this_used = this_header->used_;
  char* result_cstr = result.ensure_cstr(this_used + 1);
  STRING_HEADER* result_header = result.GetHeader();
  int result_used = result_header->used_;

  // copies '\0' but we'll overwrite that
  memcpy(result_cstr, GetCStr(), this_used);
  result_cstr[result_used] = ch;      // overwrite old '\0'
  result_cstr[result_used + 1] = '\0';  // append on '\0'
  ++result_header->used_;

  CHECK_INVARIANT(this);
  return result;
}


STRING&  STRING::operator+=(const char *str)
{
  if (!str || !*str)  // empty string has no effect
  {
    return *this;
  }

  FixHeader();
  int len = strlen(str) + 1;
  int this_used = GetHeader()->used_;
  char* this_cstr = ensure_cstr(this_used + len);
  STRING_HEADER* this_header = GetHeader();  // after ensure for realloc

  // if we had non-empty string then append overwriting old '\0'
  // otherwise replace
  if (this_used > 0)
  {
    memcpy(this_cstr + this_used - 1, str, len);
    this_header->used_ += len - 1;
  }
  else
  {
    memcpy(this_cstr, str, len);
    this_header->used_ = len;
  }

  CHECK_INVARIANT(this);

  return *this;
}


STRING& STRING::operator+=(const char ch)
{
  if (ch == '\0')
  {
    return *this;
  }

  FixHeader();
  int   this_used = GetHeader()->used_;
  char* this_cstr = ensure_cstr(this_used + 1);
  STRING_HEADER* this_header = GetHeader();

  if (this_used > 0)
    --this_used; // undo old empty null if there was one

  this_cstr[this_used++] = ch;   // append ch to end
  this_cstr[this_used++] = '\0'; // append '\0' after ch
  this_header->used_ = this_used;

  CHECK_INVARIANT(this);
  return *this;
}
//////////////////////////////////////////////////////////////STRING/////////////////////

//////////////////////////////////////////////////////////////errcode////////////////////
#ifdef __UNIX__
#endif

const ERRCODE BADERRACTION = "Illegal error action";
#define MAX_MSG       1024

/**********************************************************************
 * error
 *
 * Print an error message and continue, exit or abort according to action.
 * Makes use of error messages and numbers in a common place.
 *
 **********************************************************************/
void
ERRCODE::error (                 //handle error
const char *caller,              //name of caller
inT8 action,                     //action to take
const char *format, ...          //special message
) const
{
  va_list args;                  //variable args
  char msg[MAX_MSG] = {0};
  char *msgptr = msg;

  if (caller != NULL)
                                 //name of caller
    msgptr += sprintf (msgptr, "%s:", caller);
                                 //actual message
  msgptr += sprintf (msgptr, "Error:%s", message);
  if (format != NULL) {
    msgptr += sprintf (msgptr, ":");
    va_start(args, format);  //variable list
    #ifdef __MSW32__
                                 //print remainder
    msgptr += _vsnprintf (msgptr, MAX_MSG - 2 - (msgptr - msg), format, args);
    msg[MAX_MSG - 2] = '\0';     //ensure termination
    strcat (msg, "\n");
    #else
                                 //print remainder
    msgptr += vsprintf (msgptr, format, args);
                                 //no specific
    msgptr += sprintf (msgptr, "\n");
    #endif
    va_end(args);
  }
  else
                                 //no specific
    msgptr += sprintf (msgptr, "\n");

  fprintf(stderr, msg, 1);
  /*if ((strstr (message, "File") != NULL) ||
    (strstr (message, "file") != NULL))
  else if ((strstr (message, "List") != NULL) ||
    (strstr (message, "list") != NULL))
  else if ((strstr (message, "Memory") != NULL) ||
    (strstr (message, "memory") != NULL))
    global_abort_code = MEMORY_ABORT;
  else
    global_abort_code = NO_ABORT_CODE;
    */

  int* p = NULL;
  switch (action)
  {
    case DBG:
    case TESSLOG:
      return;                    //report only
    case EXIT:
      //err_exit();
    case ABORT:
      // Create a deliberate segv as the stack trace is more useful that way.
      if (!*p)
        abort();
    default:
      BADERRACTION.error ("error", ABORT, NULL);
  }
}
//////////////////////////////////////////////////////////////errcode//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////clst////////////////////////////////////////////////////////////////////////////
/***********************************************************************
 *  MEMBER FUNCTIONS OF CLASS: CLIST
 *  ================================
 **********************************************************************/

/***********************************************************************
 *							CLIST::internal_deep_clear
 *
 *  Used by the "deep_clear" member function of derived list
 *  classes to destroy all the elements on the list.
 *  The calling function passes a "zapper" function which can be called to
 *  delete each data element of the list, regardless of its class.  This
 *  technique permits a generic clear function to destroy elements of
 *  different derived types correctly, without requiring virtual functions and
 *  the consequential memory overhead.
 **********************************************************************/

void
CLIST::internal_deep_clear (     //destroy all links
void (*zapper) (void *)) {       //ptr to zapper functn
  CLIST_LINK *ptr;
  CLIST_LINK *next;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST::internal_deep_clear", ABORT, NULL);
  #endif

  if (!empty ()) {
    ptr = last->next;            //set to first
    last->next = NULL;           //break circle
    last = NULL;                 //set list empty
    while (ptr) {
      next = ptr->next;
      zapper (ptr->data);
      delete(ptr);
      ptr = next;
    }
  }
}


/***********************************************************************
 *							CLIST::shallow_clear
 *
 *  Used by the destructor and the "shallow_clear" member function of derived
 *  list classes to destroy the list.
 *  The data elements are NOT destroyed.
 *
 **********************************************************************/

void CLIST::shallow_clear() {  //destroy all links
  CLIST_LINK *ptr;
  CLIST_LINK *next;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST::shallow_clear", ABORT, NULL);
  #endif

  if (!empty ()) {
    ptr = last->next;            //set to first
    last->next = NULL;           //break circle
    last = NULL;                 //set list empty
    while (ptr) {
      next = ptr->next;
      delete(ptr);
      ptr = next;
    }
  }
}


/***********************************************************************
 *							CLIST::internal_deep_copy
 *
 *  Used during explict deep copy of a list.  The "copier" function passed
 *  allows each element to be correctly deep copied (assuming that each class
 *  in the inheritance hierarchy does properly deep copies its members).  The
 *  function passing technique is as for "internal_clear".
 **********************************************************************/

void
                                 //ptr to copier functn
CLIST::internal_deep_copy (void *(*copier) (void *),
const CLIST * list) {            //list being copied
  CLIST_ITERATOR from_it ((CLIST *) list);
  CLIST_ITERATOR to_it(this);

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST::internal_deep_copy", ABORT, NULL);
  if (!list)
    BAD_PARAMETER.error ("CLIST::internal_deep_copy", ABORT,
      "source list is NULL");
  #endif

  for (from_it.mark_cycle_pt (); !from_it.cycled_list (); from_it.forward ())
    to_it.add_after_then_move (copier (from_it.data ()));
}


/***********************************************************************
 *							CLIST::assign_to_sublist
 *
 *  The list is set to a sublist of another list.  "This" list must be empty
 *  before this function is invoked.  The two iterators passed must refer to
 *  the same list, different from "this" one.  The sublist removed is the
 *  inclusive list from start_it's current position to end_it's current
 *  position.  If this range passes over the end of the source list then the
 *  source list has its end set to the previous element of start_it.  The
 *  extracted sublist is unaffected by the end point of the source list, its
 *  end point is always the end_it position.
 **********************************************************************/

void CLIST::assign_to_sublist(                           //to this list
                              CLIST_ITERATOR *start_it,  //from list start
                              CLIST_ITERATOR *end_it) {  //from list end
  const ERRCODE LIST_NOT_EMPTY =
    "Destination list must be empty before extracting a sublist";

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST::assign_to_sublist", ABORT, NULL);
  #endif

  if (!empty ())
    LIST_NOT_EMPTY.error ("CLIST.assign_to_sublist", ABORT, NULL);

  last = start_it->extract_sublist (end_it);
}


/***********************************************************************
 *							CLIST::length
 *
 *  Return count of elements on list
 **********************************************************************/

inT32 CLIST::length() {  //count elements
  CLIST_ITERATOR it(this);
  inT32 count = 0;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST::length", ABORT, NULL);
  #endif

  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
    count++;
  return count;
}


/***********************************************************************
 *							CLIST::sort
 *
 *  Sort elements on list
 **********************************************************************/

void
CLIST::sort (                    //sort elements
int comparator (                 //comparison routine
const void *, const void *)) {
  CLIST_ITERATOR it(this);
  inT32 count;
  void **base;                   //ptr array to sort
  void **current;
  inT32 i;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST::sort", ABORT, NULL);
  #endif

  /* Allocate an array of pointers, one per list element */
  count = length ();
  base = (void **) malloc (count * sizeof (void *));

  /* Extract all elements, putting the pointers in the array */
  current = base;
  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
    *current = it.extract ();
    current++;
  }

  /* Sort the pointer array */
  qsort ((char *) base, count, sizeof (*base), comparator);

  /* Rebuild the list from the sorted pointers */
  current = base;
  for (i = 0; i < count; i++) {
    it.add_to_end (*current);
    current++;
  }
  free(base);
}

// Assuming list has been sorted already, insert new_data to
// keep the list sorted according to the same comparison function.
// Comparision function is the same as used by sort, i.e. uses double
// indirection. Time is O(1) to add to beginning or end.
// Time is linear to add pre-sorted items to an empty list.
// If unique, then don't add duplicate entries.
void CLIST::add_sorted(int comparator(const void*, const void*),
                       bool unique, void* new_data) {
  // Check for adding at the end.
  if (last == NULL || comparator(&last->data, &new_data) < 0) {
    CLIST_LINK* new_element = new CLIST_LINK;
    new_element->data = new_data;
    if (last == NULL) {
      new_element->next = new_element;
    } else {
      new_element->next = last->next;
      last->next = new_element;
    }
    last = new_element;
  } else if (!unique || last->data != new_data) {
    // Need to use an iterator.
    CLIST_ITERATOR it(this);
    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
      void* data = it.data();
      if (data == new_data && unique)
        return;
      if (comparator(&data, &new_data) > 0)
        break;
    }
    if (it.cycled_list())
      it.add_to_end(new_data);
    else
      it.add_before_then_move(new_data);
  }
}

/***********************************************************************
 *							CLIST::prep_serialise
 *
 *  Replace the last member with a count of elements for serialisation.
 *  This is used on list objects which are members of objects being
 *  serialised.  The containing object has been shallow copied and this member
 *  function is invoked on the COPY.
 **********************************************************************/

void CLIST::prep_serialise() {
  CLIST_ITERATOR this_it(this);
  inT32 count = 0;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST::prep_serialise", ABORT, NULL);
  #endif

  count = 0;
  if (!empty ())
    for (this_it.mark_cycle_pt ();
    !this_it.cycled_list (); this_it.forward ())
  count++;
//  last = (CLIST_LINK*)count; //cwj
  last = (CLIST_LINK*)&count;
}


/***********************************************************************
 *							CLIST::internal_dump
 *
 *  Cause each element on the list to be serialised by walking the list and
 *  calling the element_serialiser function for each element.  The
 *  element_serialiser simply does the appropriate coercion of the element to
 *  its real type and then invokes the elements serialise function
 **********************************************************************/

void
CLIST::internal_dump (FILE * f, void element_serialiser (FILE *, void *)) {
  CLIST_ITERATOR this_it(this);

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST::internal_dump", ABORT, NULL);
  #endif

  if (!empty ())
    for (this_it.mark_cycle_pt ();
    !this_it.cycled_list (); this_it.forward ())
  element_serialiser (f, this_it.data ());
}


/***********************************************************************
 *							CLIST::internal_de_dump
 *
 *  Cause each element on the list to be de_serialised by extracting the count
 *  of elements on the list, (held in the last member of the dumped version of
 *  the list object), and then de-serialising that number of list elements,
 *  adding each to the end of the reconstructed list.
 **********************************************************************/

void
CLIST::internal_de_dump (FILE * f, void *element_de_serialiser (FILE *)) {
  inT32 count = (ptrdiff_t) last;
  CLIST_ITERATOR this_it;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST::internal_de_dump", ABORT, NULL);
  #endif

  last = NULL;
  this_it.set_to_list (this);
  for (; count > 0; count--)
    this_it.add_to_end (element_de_serialiser (f));
}


/***********************************************************************
 *  MEMBER FUNCTIONS OF CLASS: CLIST_ITERATOR
 *  =========================================
 **********************************************************************/

/***********************************************************************
 *							CLIST_ITERATOR::forward
 *
 *  Move the iterator to the next element of the list.
 *  REMEMBER: ALL LISTS ARE CIRCULAR.
 **********************************************************************/

void *CLIST_ITERATOR::forward() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::forward", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::forward", ABORT, NULL);
  #endif
  if (list->empty ())
    return NULL;

  if (current) {                 //not removed so
                                 //set previous
    prev = current;
    started_cycling = TRUE;
    // In case next is deleted by another iterator, get next from current.
    current = current->next;
  } else {
    if (ex_current_was_cycle_pt)
      cycle_pt = next;
    current = next;
  }
  next = current->next;

  #ifndef NDEBUG
  if (!current)
    NULL_DATA.error ("CLIST_ITERATOR::forward", ABORT, NULL);
  if (!next)
    NULL_NEXT.error ("CLIST_ITERATOR::forward", ABORT,
                     "This is: %p  Current is: %p", this, current);
  #endif
  return current->data;
}


/***********************************************************************
 *							CLIST_ITERATOR::data_relative
 *
 *  Return the data pointer to the element "offset" elements from current.
 *  "offset" must not be less than -1.
 *  (This function can't be INLINEd because it contains a loop)
 **********************************************************************/

void *CLIST_ITERATOR::data_relative(                //get data + or - ...
                                    inT8 offset) {  //offset from current
  CLIST_LINK *ptr;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::data_relative", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::data_relative", ABORT, NULL);
  if (list->empty ())
    EMPTY_LIST.error ("CLIST_ITERATOR::data_relative", ABORT, NULL);
  if (offset < -1)
    BAD_PARAMETER.error ("CLIST_ITERATOR::data_relative", ABORT,
      "offset < -l");
  #endif

  if (offset == -1)
    ptr = prev;
  else
    for (ptr = current ? current : prev; offset-- > 0; ptr = ptr->next);

  #ifndef NDEBUG
  if (!ptr)
    NULL_DATA.error ("CLIST_ITERATOR::data_relative", ABORT, NULL);
  #endif

  return ptr->data;
}


/***********************************************************************
 *							CLIST_ITERATOR::move_to_last()
 *
 *  Move current so that it is set to the end of the list.
 *  Return data just in case anyone wants it.
 *  (This function can't be INLINEd because it contains a loop)
 **********************************************************************/

void *CLIST_ITERATOR::move_to_last() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::move_to_last", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::move_to_last", ABORT, NULL);
  #endif

  while (current != list->last)
    forward();

  if (current == NULL)
    return NULL;
  else
    return current->data;
}


/***********************************************************************
 *							CLIST_ITERATOR::exchange()
 *
 *  Given another iterator, whose current element is a different element on
 *  the same list list OR an element of another list, exchange the two current
 *  elements.  On return, each iterator points to the element which was the
 *  other iterators current on entry.
 *  (This function hasn't been in-lined because its a bit big!)
 **********************************************************************/

void CLIST_ITERATOR::exchange(                             //positions of 2 links
                              CLIST_ITERATOR *other_it) {  //other iterator
  const ERRCODE DONT_EXCHANGE_DELETED =
    "Can't exchange deleted elements of lists";

  CLIST_LINK *old_current;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::exchange", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::exchange", ABORT, NULL);
  if (!other_it)
    BAD_PARAMETER.error ("CLIST_ITERATOR::exchange", ABORT, "other_it NULL");
  if (!(other_it->list))
    NO_LIST.error ("CLIST_ITERATOR::exchange", ABORT, "other_it");
  #endif

  /* Do nothing if either list is empty or if both iterators reference the same
  link */

  if ((list->empty ()) ||
    (other_it->list->empty ()) || (current == other_it->current))
    return;

  /* Error if either current element is deleted */

  if (!current || !other_it->current)
    DONT_EXCHANGE_DELETED.error ("CLIST_ITERATOR.exchange", ABORT, NULL);

  /* Now handle the 4 cases: doubleton list; non-doubleton adjacent elements
  (other before this); non-doubleton adjacent elements (this before other);
  non-adjacent elements. */

                                 //adjacent links
  if ((next == other_it->current) ||
  (other_it->next == current)) {
                                 //doubleton list
    if ((next == other_it->current) &&
    (other_it->next == current)) {
      prev = next = current;
      other_it->prev = other_it->next = other_it->current;
    }
    else {                       //non-doubleton with
                                 //adjacent links
                                 //other before this
      if (other_it->next == current) {
        other_it->prev->next = current;
        other_it->current->next = next;
        current->next = other_it->current;
        other_it->next = other_it->current;
        prev = current;
      }
      else {                     //this before other
        prev->next = other_it->current;
        current->next = other_it->next;
        other_it->current->next = current;
        next = current;
        other_it->prev = other_it->current;
      }
    }
  }
  else {                         //no overlap
    prev->next = other_it->current;
    current->next = other_it->next;
    other_it->prev->next = current;
    other_it->current->next = next;
  }

  /* update end of list pointer when necessary (remember that the 2 iterators
    may iterate over different lists!) */

  if (list->last == current)
    list->last = other_it->current;
  if (other_it->list->last == other_it->current)
    other_it->list->last = current;

  if (current == cycle_pt)
    cycle_pt = other_it->cycle_pt;
  if (other_it->current == other_it->cycle_pt)
    other_it->cycle_pt = cycle_pt;

  /* The actual exchange - in all cases*/

  old_current = current;
  current = other_it->current;
  other_it->current = old_current;
}


/***********************************************************************
 *							CLIST_ITERATOR::extract_sublist()
 *
 *  This is a private member, used only by CLIST::assign_to_sublist.
 *  Given another iterator for the same list, extract the links from THIS to
 *  OTHER inclusive, link them into a new circular list, and return a
 *  pointer to the last element.
 *  (Can't inline this function because it contains a loop)
 **********************************************************************/

CLIST_LINK *CLIST_ITERATOR::extract_sublist(                             //from this current
                                            CLIST_ITERATOR *other_it) {  //to other current
  CLIST_ITERATOR temp_it = *this;
  CLIST_LINK *end_of_new_list;

  const ERRCODE BAD_SUBLIST = "Can't find sublist end point in original list";
  #ifndef NDEBUG
  const ERRCODE BAD_EXTRACTION_PTS =
    "Can't extract sublist from points on different lists";
  const ERRCODE DONT_EXTRACT_DELETED =
    "Can't extract a sublist marked by deleted points";

  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::extract_sublist", ABORT, NULL);
  if (!other_it)
    BAD_PARAMETER.error ("CLIST_ITERATOR::extract_sublist", ABORT,
      "other_it NULL");
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::extract_sublist", ABORT, NULL);
  if (list != other_it->list)
    BAD_EXTRACTION_PTS.error ("CLIST_ITERATOR.extract_sublist", ABORT, NULL);
  if (list->empty ())
    EMPTY_LIST.error ("CLIST_ITERATOR::extract_sublist", ABORT, NULL);

  if (!current || !other_it->current)
    DONT_EXTRACT_DELETED.error ("CLIST_ITERATOR.extract_sublist", ABORT,
      NULL);
  #endif

  ex_current_was_last = other_it->ex_current_was_last = FALSE;
  ex_current_was_cycle_pt = FALSE;
  other_it->ex_current_was_cycle_pt = FALSE;

  temp_it.mark_cycle_pt ();
  do {                           //walk sublist
    if (temp_it.cycled_list ())  //cant find end pt
      BAD_SUBLIST.error ("CLIST_ITERATOR.extract_sublist", ABORT, NULL);

    if (temp_it.at_last ()) {
      list->last = prev;
      ex_current_was_last = other_it->ex_current_was_last = TRUE;
    }

    if (temp_it.current == cycle_pt)
      ex_current_was_cycle_pt = TRUE;

    if (temp_it.current == other_it->cycle_pt)
      other_it->ex_current_was_cycle_pt = TRUE;

    temp_it.forward ();
  }
  while (temp_it.prev != other_it->current);

                                 //circularise sublist
  other_it->current->next = current;
  end_of_new_list = other_it->current;

                                 //sublist = whole list
  if (prev == other_it->current) {
    list->last = NULL;
    prev = current = next = NULL;
    other_it->prev = other_it->current = other_it->next = NULL;
  }
  else {
    prev->next = other_it->next;
    current = other_it->current = NULL;
    next = other_it->next;
    other_it->prev = prev;
  }
  return end_of_new_list;
}
/////////////////////////////////////////////////////////clst////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////varable////////////////////////////////////////////////////////////////////////////
//#define PLUS          '+'        //flag states
#define MINUS         '-'
#define EQUAL         '='

CLISTIZE (INT_VARIABLE)
CLISTIZE (BOOL_VARIABLE) CLISTIZE (STRING_VARIABLE) CLISTIZE (double_VARIABLE)
INT_VAR_FROM
INT_VARIABLE::copy;
INT_VARIABLE_CLIST
INT_VARIABLE::head;              //global definition
INT_VAR_TO
INT_VARIABLE::replace;
BOOL_VAR_FROM
BOOL_VARIABLE::copy;
BOOL_VARIABLE_CLIST
BOOL_VARIABLE::head;             //global definition
BOOL_VAR_TO
BOOL_VARIABLE::replace;
STRING_VAR_FROM
STRING_VARIABLE::copy;
STRING_VARIABLE_CLIST
STRING_VARIABLE::head;           //global definition
STRING_VAR_TO
STRING_VARIABLE::replace;
double_VAR_FROM
double_VARIABLE::copy;
double_VARIABLE_CLIST
double_VARIABLE::head;           //global definition
double_VAR_TO
double_VARIABLE::replace;

/**********************************************************************
 * INT_VAR_FROM::INT_VAR_FROM
 *
 * Constructor to copy the list to a temporary location while the
 * list head gets constructed.
 **********************************************************************/

INT_VAR_FROM::INT_VAR_FROM()
{  //constructor
    INT_VARIABLE_C_IT start_it = &INT_VARIABLE::head;
    INT_VARIABLE_C_IT end_it = &INT_VARIABLE::head;

    if (!start_it.empty ())
    {
        while (!end_it.at_last ())
            end_it.forward ();
        //move to copy
        list.assign_to_sublist (&start_it, &end_it);
    }
}


/**********************************************************************
 * INT_VAR_TO::INT_VAR_TO
 *
 * Constructor to copy the list back to its rightful place.
 **********************************************************************/

INT_VAR_TO::INT_VAR_TO()
{  //constructor
    INT_VARIABLE_C_IT start_it = &INT_VARIABLE::copy.list;
    INT_VARIABLE_C_IT end_it = &INT_VARIABLE::copy.list;

    if (!start_it.empty ())
    {
        while (!end_it.at_last ())
            end_it.forward ();
        INT_VARIABLE::head.assign_to_sublist (&start_it, &end_it);
    }
}


/**********************************************************************
 * INT_VARIABLE::INT_VARIABLE
 *
 * Constructor for INT_VARIABLE. Add the variable to the static list.
 **********************************************************************/

INT_VARIABLE::INT_VARIABLE(                     //constructor
                                                inT32 v,             //the variable
                                                const char *vname,   //of variable
                                                const char *comment  //info on variable
                                                )
{
    INT_VARIABLE_C_IT it = &head;  //list iterator

    //tprintf("Constructing %s\n",vname);
    set_value(v);  //set the value
    name = vname;                  //strings must be static
    info = comment;
    it.add_before_stay_put (this); //add it to stack
}


INT_VARIABLE::~INT_VARIABLE (    //constructor
                                 )
{
    INT_VARIABLE_C_IT it = &head;  //list iterator

    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
        if (it.data () == this)
            it.extract ();
}


/**********************************************************************
 * INT_VARIABLE::get_head
 *
 * Get the head of the list of the variables.
 **********************************************************************/

INT_VARIABLE_CLIST *INT_VARIABLE::get_head()
{  //access to static
    return &head;
}


/**********************************************************************
 * INT_VARIABLE::print
 *
 * Print the entire list of INT_VARIABLEs.
 **********************************************************************/

void INT_VARIABLE::print(          //print full list
                                   FILE *fp  //file to print on
                                   )
{
    INT_VARIABLE_C_IT it = &head;  //list iterator
    INT_VARIABLE *elt;             //current element

    if (fp == stdout)
    {
        tprintf ("#Variables of type INT_VARIABLE:\n");
        for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
        {
            elt = it.data ();
            tprintf ("%s %d #%s\n", elt->name, elt->value, elt->info);
        }
    }
    else
    {
        fprintf (fp, "#Variables of type INT_VARIABLE:\n");
        for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
        {
            elt = it.data ();
            fprintf (fp, "%s " INT32FORMAT " #%s\n", elt->name, elt->value, elt->info);
        }
    }
}


/**********************************************************************
 * BOOL_VAR_FROM::BOOL_VAR_FROM
 *
 * Constructor to copy the list to a temporary location while the
 * list head gets constructed.
 **********************************************************************/

BOOL_VAR_FROM::BOOL_VAR_FROM()
{  //constructor
    BOOL_VARIABLE_C_IT start_it = &BOOL_VARIABLE::head;
    BOOL_VARIABLE_C_IT end_it = &BOOL_VARIABLE::head;

    if (!start_it.empty ())
    {
        while (!end_it.at_last ())
            end_it.forward ();
        //move to copy
        list.assign_to_sublist (&start_it, &end_it);
    }
}


/**********************************************************************
 * BOOL_VAR_TO::BOOL_VAR_TO
 *
 * Constructor to copy the list back to its rightful place.
 **********************************************************************/

BOOL_VAR_TO::BOOL_VAR_TO()
{  //constructor
    BOOL_VARIABLE_C_IT start_it = &BOOL_VARIABLE::copy.list;
    BOOL_VARIABLE_C_IT end_it = &BOOL_VARIABLE::copy.list;

    if (!start_it.empty ())
    {
        while (!end_it.at_last ()) end_it.forward ();

        BOOL_VARIABLE::head.assign_to_sublist (&start_it, &end_it);
    }
}


/**********************************************************************
 * BOOL_VARIABLE::BOOL_VARIABLE
 *
 * Constructor for BOOL_VARIABLE. Add the variable to the static list.
 **********************************************************************/

BOOL_VARIABLE::BOOL_VARIABLE(                     //constructor
                                                  BOOL8 v,             //the variable
                                                  const char *vname,   //of variable
                                                  const char *comment  //info on variable
                                                  )
{
    BOOL_VARIABLE_C_IT it = &head; //list iterator

    //tprintf("Constructing %s\n",vname);
    set_value(v);  //set the value
    name = vname;                  //strings must be static
    info = comment;
    it.add_before_stay_put (this); //add it to stack

}


/**********************************************************************
 * BOOL_VARIABLE::BOOL_VARIABLE
 *
 * Constructor for BOOL_VARIABLE. Add the variable to the static list.
 **********************************************************************/

BOOL_VARIABLE::~BOOL_VARIABLE()
{
    BOOL_VARIABLE_C_IT it = &head; //list iterator

    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
    {
        if (it.data() == this)
        {
            it.extract();
        }
    }
}


/**********************************************************************
 * BOOL_VARIABLE::get_head
 *
 * Get the head of the list of the variables.
 **********************************************************************/

BOOL_VARIABLE_CLIST *BOOL_VARIABLE::get_head()
{  //access to static
    return &head;
}


/**********************************************************************
 * BOOL_VARIABLE::print
 *
 * Print the entire list of BOOL_VARIABLEs.
 **********************************************************************/

void BOOL_VARIABLE::print(          //print full list
                                    FILE *fp  //file to print on
                                    )
{
    BOOL_VARIABLE_C_IT it = &head; //list iterator
    BOOL_VARIABLE *elt;            //current element

    if (fp == stdout)
    {
        tprintf ("#Variables of type BOOL_VARIABLE:\n");
        for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
        {
            elt = it.data ();
            tprintf ("%s %c #%s\n", elt->name, elt->value ? 'T' : 'F', elt->info);
        }
    }
    else
    {
        fprintf (fp, "#Variables of type BOOL_VARIABLE:\n");
        for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
        {
            elt = it.data ();
            fprintf (fp, "%s %c #%s\n", elt->name, elt->value ? 'T' : 'F', elt->info);
        }
    }
}


/**********************************************************************
 * STRING_VAR_FROM::STRING_VAR_FROM
 *
 * Constructor to copy the list to a temporary location while the
 * list head gets constructed.
 **********************************************************************/

STRING_VAR_FROM::STRING_VAR_FROM()
{  //constructor
    STRING_VARIABLE_C_IT start_it = &STRING_VARIABLE::head;
    STRING_VARIABLE_C_IT end_it = &STRING_VARIABLE::head;

    if (!start_it.empty ())
    {
        while (!end_it.at_last ()) end_it.forward ();
        //move to copy
        list.assign_to_sublist (&start_it, &end_it);
    }
}


/**********************************************************************
 * STRING_VAR_TO::STRING_VAR_TO
 *
 * Constructor to copy the list back to its rightful place.
 **********************************************************************/

STRING_VAR_TO::STRING_VAR_TO()
{  //constructor
    STRING_VARIABLE_C_IT start_it = &STRING_VARIABLE::copy.list;
    STRING_VARIABLE_C_IT end_it = &STRING_VARIABLE::copy.list;

    if (!start_it.empty ())
    {
        while (!end_it.at_last ()) end_it.forward ();

        STRING_VARIABLE::head.assign_to_sublist (&start_it, &end_it);
    }
}


/**********************************************************************
 * STRING_VARIABLE::STRING_VARIABLE
 *
 * Constructor for STRING_VARIABLE. Add the variable to the static list.
 **********************************************************************/

STRING_VARIABLE::STRING_VARIABLE (
        //constructor
        const char *v,                   //the variable
        const char *vname,               //of variable
        const char *comment              //info on variable
        ): value(v)
{
    // list iterator
    STRING_VARIABLE_C_IT it = &head;

    name = vname;                  // strings must be static
    info = comment;
    it.add_before_stay_put(this);  // add it to stack
}


/**********************************************************************
 * STRING_VARIABLE::~STRING_VARIABLE
 *
 * Destructor for STRING_VARIABLE. Add the variable to the static list.
 **********************************************************************/

// constructor
STRING_VARIABLE::~STRING_VARIABLE(
        )
{
    // list iterator
    STRING_VARIABLE_C_IT it = &head;

    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
    {
        if (it.data() == this)
        {
            it.extract();
        }
    }
}


/**********************************************************************
 * STRING_VARIABLE::get_head
 *
 * Get the head of the list of the variables.
 **********************************************************************/

STRING_VARIABLE_CLIST *STRING_VARIABLE::get_head()
{  // access to static
    return &head;
}


/**********************************************************************
 * STRING_VARIABLE::print
 *
 * Print the entire list of STRING_VARIABLEs.
 **********************************************************************/

void STRING_VARIABLE::print(FILE *fp)
{
    STRING_VARIABLE_C_IT it = &head;  // list iterator
    STRING_VARIABLE *elt;          // current element

    // Comments aren't allowed with string variables, so the # character can
    // be part of a string.
    if (fp == stdout)
    {
        tprintf("#Variables of type STRING_VARIABLE:\n");
        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
        {
            elt = it.data();
            tprintf("%s %s\n", elt->name, elt->value.string());
        }
    }
    else
    {
        fprintf(fp, "#Variables of type STRING_VARIABLE:\n");
        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
        {
            elt = it.data();
            fprintf(fp, "%s %s\n", elt->name, elt->value.string());
        }
    }
}


/**********************************************************************
 * double_VAR_FROM::double_VAR_FROM
 *
 * Constructor to copy the list to a temporary location while the
 * list head gets constructed.
 **********************************************************************/

double_VAR_FROM::double_VAR_FROM()
{  // constructor
    double_VARIABLE_C_IT start_it = &double_VARIABLE::head;
    double_VARIABLE_C_IT end_it = &double_VARIABLE::head;

    if (!start_it.empty())
    {
        while (!end_it.at_last()) end_it.forward();
        // move to copy
        list.assign_to_sublist(&start_it, &end_it);
    }
}


/**********************************************************************
 * double_VAR_TO::double_VAR_TO
 *
 * Constructor to copy the list back to its rightful place.
 **********************************************************************/

double_VAR_TO::double_VAR_TO()
{  // constructor
    double_VARIABLE_C_IT start_it = &double_VARIABLE::copy.list;
    double_VARIABLE_C_IT end_it = &double_VARIABLE::copy.list;

    if (!start_it.empty())
    {
        while (!end_it.at_last()) end_it.forward();

        double_VARIABLE::head.assign_to_sublist(&start_it, &end_it);
    }
}


/**********************************************************************
 * double_VARIABLE::double_VARIABLE
 *
 * Constructor for double_VARIABLE. Add the variable to the static list.
 **********************************************************************/

double_VARIABLE::double_VARIABLE(double v,            // the variable
                                 const char *vname,   // of variable
                                 const char *comment  // info on variable
                                 )
{
    // list iterator
    double_VARIABLE_C_IT it = &head;

    set_value(v);  // set the value
    name = vname;                  // strings must be static
    info = comment;
    it.add_before_stay_put(this); // add it to stack
}


double_VARIABLE::~double_VARIABLE()
{
    // list iterator
    double_VARIABLE_C_IT it = &head;

    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
    {
        if (it.data() == this)
        {
            it.extract();
        }
    }
}


/**********************************************************************
 * double_VARIABLE::get_head
 *
 * Get the head of the list of the variables.
 **********************************************************************/

double_VARIABLE_CLIST *double_VARIABLE::get_head()
{  // access to static
    return &head;
}


/**********************************************************************
 * double_VARIABLE::print
 *
 * Print the entire list of double_VARIABLEs.
 **********************************************************************/

void double_VARIABLE::print(FILE *fp  // file to print on
                            )
{
    // list iterator
    double_VARIABLE_C_IT it = &head;
    double_VARIABLE *elt;          // current element

    if (fp == stdout)
    {
        tprintf("#Variables of type double_VARIABLE:\n");
        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
        {
            elt = it.data();
            tprintf ("%s %lg #%s\n", elt->name, elt->value, elt->info);
        }
    }
    else
    {
        fprintf(fp, "#Variables of type double_VARIABLE:\n");
        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
        {
            elt = it.data();
            fprintf(fp, "%s %g #%s\n", elt->name, elt->value, elt->info);
        }
    }
}


/**********************************************************************
 * read_variables_file
 *
 * Read a file of variables definitions and set/modify the values therein.
 * If the filename begins with a + or -, the BOOL_VARIABLEs will be
 * ORed or ANDed with any current values.
 * Blank lines and lines beginning # are ignored.
 * Values may have any whitespace after the name and are the rest of line.
 **********************************************************************/

BOOL8 read_variables_file(const char *file,  // name to read
                                 bool global_only   // only set variables
                                 )
{                // starting with "global_"
    char flag;                     // file flag
    inT16 nameoffset;              // offset for real name
    FILE *fp;                      // file pointer
    // iterators
    bool ret;

    if (*file == PLUS)
    {
        flag = PLUS;                 // file has flag
        nameoffset = 1;
    }
    else if (*file == MINUS)
    {
        flag = MINUS;
        nameoffset = 1;
    }
    else
    {
        flag = EQUAL;
        nameoffset = 0;
    }

    fp = fopen(file + nameoffset, "r");
    if (fp == NULL)
    {
        tprintf("read_variables_file: Can't open %s\n", file + nameoffset);
        return TRUE;                 // can't open it
    }

    ret = read_variables_from_fp(fp, -1, global_only);
    fclose(fp);
    Q_UNUSED(flag);

    return ret;
}

bool read_variables_from_fp(FILE *fp, inT64 end_offset, bool global_only)
{
    char line[MAX_PATH];           // input line
    bool anyerr = false;          // true if any error
    bool foundit;                 // found variable
    inT16 length;                  // length of line
    char *valptr;                  // value field

    while ((end_offset < 0 || ftell(fp) < end_offset) && fgets(line, MAX_PATH, fp))
    {
        if (line[0] != '\n' && line[0] != '#')
        {
            length = strlen (line);
            if (line[length - 1] == '\n') line[length - 1] = '\0';  // cut newline
            for (valptr = line; *valptr && *valptr != ' ' && *valptr != '\t'; valptr++);

            if (*valptr)
            {             // found blank
                *valptr = '\0';          // make name a string

                do
                    valptr++;              // find end of blanks
                while (*valptr == ' ' || *valptr == '\t');
            }

            if (global_only && strstr(line, kGlobalVariablePrefix) == NULL) continue;
            foundit = set_variable(line, valptr);

            if (!foundit)
            {
                anyerr = TRUE;         // had an error
                tprintf("read_variables_file: variable not found: %s\n", line);
                exit(1);
            }
        }
    }

    return anyerr;
}

bool set_variable(const char *variable, const char* value)
{
    INT_VARIABLE_C_IT int_it = &INT_VARIABLE::head;
    BOOL_VARIABLE_C_IT BOOL_it = &BOOL_VARIABLE::head;
    STRING_VARIABLE_C_IT STRING_it = &STRING_VARIABLE::head;
    double_VARIABLE_C_IT double_it = &double_VARIABLE::head;

    bool foundit = false;

    // find name
    for (STRING_it.mark_cycle_pt(); !STRING_it.cycled_list() && strcmp(variable, STRING_it.data()->name); STRING_it.forward());

    if (!STRING_it.cycled_list())
    {
        foundit = true;          // found the varaible
        STRING_it.data()->set_value(value);  // set its value
    }

    if (*value)
    {
        // find name
        for (int_it.mark_cycle_pt(); !int_it.cycled_list() && strcmp(variable, int_it.data()->name); int_it.forward());

        int intval;
        if (!int_it.cycled_list() && sscanf(value, INT32FORMAT, &intval) == 1)
        {
            foundit = true;        // found the varaible
            int_it.data()->set_value(intval);  // set its value.
        }

        for (BOOL_it.mark_cycle_pt(); !BOOL_it.cycled_list() && strcmp(variable, BOOL_it.data()->name); BOOL_it.forward());
        if (!BOOL_it.cycled_list())
        {
            if (*value == 'T' || *value == 't' || *value == 'Y' || *value == 'y' || *value == '1')
            {
                foundit = true;
                BOOL_it.data()->set_value(TRUE);
            }
            else if (*value == 'F' || *value == 'f' || *value == 'N' || *value == 'n' || *value == '0')
            {
                foundit = true;
                BOOL_it.data()->set_value(FALSE);
            }
        }

        for (double_it.mark_cycle_pt(); !double_it.cycled_list() && strcmp(variable, double_it.data ()->name); double_it.forward());
        double doubleval;
#ifdef EMBEDDED
        if (!double_it.cycled_list ())
        {
            doubleval = strtofloat(value);
#else
        if (!double_it.cycled_list() && sscanf(value, "%lf", &doubleval) == 1)
        {
#endif
            foundit = true;        // found the variable
            double_it.data()->set_value(doubleval);
        }
    }

    return foundit;
}

/**********************************************************************
 * print_variables
 *
 * Print all variable types to the given file
 **********************************************************************/

void print_variables(          //print all vars
                                      FILE *fp  //file to print on
                                      )
{
    INT_VARIABLE::print(fp);  //print INTs
    BOOL_VARIABLE::print(fp);  //print BOOLs
    STRING_VARIABLE::print(fp);  //print STRINGs
    double_VARIABLE::print(fp);  //print doubles
}
/////////////////////////////////////////////////////////varable//////////////////////////////////////////////

/////////////////////////////////////////////////////////tordvars/////////////////////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
FILE *rawfile;                   /* Text before dictionary */
FILE *textfile;                  /* Text output file */
FILE *matcher_fp;                //matcher log
FILE *correct_fp;                //correct text

BOOL_VAR(tord_write_output, 0, "Text file output");

BOOL_VAR(tord_write_raw_output, 0, "Text before context");

BOOL_VAR(tord_similarity_enable, 0, "Switch for Similarity");

double_VAR(tord_certainty_threshold, -2.25, "Certainty Value");

INT_VAR(tord_num_word_choices, 30, "Number of choices");

BOOL_VAR(tord_blob_skip, 0, "Skip to Next selection");

double_VAR(tord_overlap_threshold, 0.33, "Overlap Threshold");

BOOL_VAR(tord_debug_3, 0, "Textord Debug #3");

BOOL_VAR(tord_debug_5, 0, "Textord Debug #5");

BOOL_VAR(tord_debug_8, 0, "Textord Debug #8");

INT_VAR(tord_display_ratings, 0, "Ratings display");

BOOL_VAR(tord_display_text, 0, "Display Text");

BOOL_VAR(tord_show_bold, 1, "Show Bold Text");
/////////////////////////////////////////////////////////tordvars/////////////////////////////////////////////

/////////////////////////////////////////////////////////memblk////////////////////////////////////////////////////////////////////////////
#ifdef __UNIX__
#endif

class UWREC
{
  public:
    unsigned cur_frsize;         //frame size
    unsigned cursp;              //stack
    unsigned currls;             //pc space
    unsigned currlo;             //pc offset
    unsigned curdp;              //data pointer
    unsigned toprp;              //rp
    unsigned topmrp;             //mrp
    unsigned topsr0;             //sr0
    unsigned topsr4;             //sr4
    unsigned r3;                 //gr3
    unsigned cur_r19;            //gr19
};

MEMUNION *free_block = NULL;     //head of freelist

#define EXTERN

EXTERN MEM_ALLOCATOR big_mem;
EXTERN MEM_ALLOCATOR main_mem;
                                 //heads of freelists
EXTERN MEMUNION *free_structs[MAX_STRUCTS];
                                 //number issued
EXTERN inT32 structs_in_use[MAX_STRUCTS];
                                 //number issued
EXTERN inT32 blocks_in_use[MAX_STRUCTS];
                                 //head of block lists
EXTERN MEMUNION *struct_blocks[MAX_STRUCTS];
EXTERN const char *owner_names[MAX_STRUCTS][MAX_CLASSES];
EXTERN inT32 owner_counts[MAX_STRUCTS][MAX_CLASSES];
                                 //no of names
EXTERN inT16 name_counts[MAX_STRUCTS];
EXTERN inT32 free_struct_blocks; //no of free blocks

EXTERN INT_VAR (mem_mallocdepth, 0, "Malloc stack depth to trace");
EXTERN INT_VAR (mem_mallocbits, 8, "Log 2 of hash table size");
EXTERN INT_VAR (mem_freedepth, 0, "Free stack dpeth to trace");
EXTERN INT_VAR (mem_freebits, 8, "Log 2 of hash table size");
EXTERN INT_VAR (mem_countbuckets, 16, "No of buckets for histogram");
EXTERN INT_VAR (mem_checkfreq, 0, "Calls to alloc_mem between owner counts");

/**********************************************************************
 * MEM_ALLOCATOR::MEM_ALLOCATOR
 *
 * Constructor for a memory allocator.
 **********************************************************************/

void
MEM_ALLOCATOR::init (            //initialize
void *(*ext_malloc) (inT32),     //external source
void (*ext_free) (void *),       //external free
inT32 firstsize,                 //size of first block
inT32 lastsize,                  //size of last block
inT32 maxchunk                   //biggest request
) {
  blockcount = 0;
  malloc_serial = 0;
  topblock = NULL;
  currblock = NULL;
  callers = NULL;
  malloc = ext_malloc;
  free = ext_free;
  maxsize = lastsize;
  biggestblock = maxchunk;
  totalmem = 0;
  memsize = firstsize;
  malloc_div_ratio = 1;
  malloc_minor_serial = 0;
  malloc_auto_count = 0;
  call_bits = 0;
  entries = 0;
}


/**********************************************************************
 * MEM_ALLOCATOR::hash_caller
 *
 * Generate a hash code for a caller, setup the tables if necessary.
 **********************************************************************/

uinT16 MEM_ALLOCATOR::hash_caller(            //get hash code
                                  void *addr  //return address
                                 ) {
  inT32 index;                   //index to table
  inT32 initial_hash;            //initial index

  if (callers == NULL)
    init_callers();  //setup table
                                 //get hash code
  initial_hash = myHash (call_bits, &addr, sizeof (addr));
  if (initial_hash == 0)
    initial_hash = 1;
  index = initial_hash;
  if (callers[index].caller != NULL && callers[index].caller != addr) {
    do {
      index++;
      if (index >= entries)
        index = 1;
    }
    while (callers[index].caller != NULL
      && callers[index].caller != addr && index != initial_hash);
    if (index == initial_hash)
      index = 0;
  }
  if (callers[index].caller == NULL) {
    if (index != 0)
      callers[index].caller = addr;
    if (callers[index].free_list == NULL)
                                 //setup free table
      callers[index].init_freeers ();
  }
  return (uinT16) index;
}


/**********************************************************************
 * MALLOC_CALL::count_freeer
 *
 * Generate a hash code for a freeer, setup the tables if necessary.
 * Then count the call.
 **********************************************************************/

void MALLOC_CALL::count_freeer(            //count calls to free
                               void *addr  //return address
                              ) {
  inT32 entries;                 //entries in table
  inT32 index;                   //index to table
  inT32 initial_hash;            //initial index

  if (free_list == NULL)
    init_freeers();  //setup table
  entries = 1 << free_bits;
                                 //get hash code
  initial_hash = myHash(free_bits, &addr, sizeof (addr));
  if (initial_hash == 0)
    initial_hash = 1;
  index = initial_hash;
  if (free_list[index].freeer != NULL && free_list[index].freeer != addr) {
    do {
      index++;
      if (index >= entries)
        index = 1;
    }
    while (free_list[index].freeer != NULL
      && free_list[index].freeer != addr && index != initial_hash);
    if (index == initial_hash)
      index = 0;
  }
  if (free_list[index].freeer == NULL && index != 0) {
    free_list[index].freeer = addr;
  }
  free_list[index].count++;      //count them
}


/**********************************************************************
 * MEM_ALLOCATOR::init_callers
 *
 * Initialize the callers hash table.
 **********************************************************************/

void MEM_ALLOCATOR::init_callers() {  //setup hash table
  inT32 depth = mem_mallocdepth;

  mem_mallocdepth.set_value (0); //can't register it
  call_bits = mem_mallocbits;
  entries = 1 << call_bits;
                                 //make an array
  callers = new MALLOC_CALL[entries];
  mem_mallocdepth.set_value (depth);
}


/**********************************************************************
 * MALLOC_CALL::init_freeers
 *
 * Initialize the freeers hash table.
 **********************************************************************/

void MALLOC_CALL::init_freeers() {  //setup hash table
  inT32 entries;                 //entries in table
  inT32 depth = mem_mallocdepth;

  mem_mallocdepth.set_value (0); //can't register it
  free_bits = mem_freebits;
  entries = 1 << free_bits;
                                 //make an array
  free_list = new FREE_CALL[entries];
  mem_mallocdepth.set_value (depth);
}


/**********************************************************************
 * MEM_ALLOCATOR::reduce_counts
 *
 * Divide all ages by 2 to get a log use of counts.
 **********************************************************************/

void MEM_ALLOCATOR::reduce_counts() {  //divide by 2
  MEMBLOCK *block;               //current block
  MEMUNION *chunk;               //current chunk
  inT32 chunksize;               //size of chunk
  inT32 blockindex;              //index of block

  check_mem ("Reducing counts", JUSTCHECKS);
  for (blockindex = 0; blockindex < blockcount; blockindex++) {
                                 //current block
    block = &memblocks[blockindex];
                                 //scan all chunks
    for (chunk = block->blockstart; chunk != block->blockend; chunk += chunksize) {
      chunksize = chunk->size;   //size of chunk
      if (chunksize < 0)
        chunksize = -chunksize;  //absolute size
      chunk->age /= 2;           //divide ages
    }
  }
}


/**********************************************************************
 * MEM_ALLOCATOR::display_counts
 *
 * Send counts of outstanding blocks to stderr.
 **********************************************************************/

void MEM_ALLOCATOR::display_counts() {  //count up
  MEMBLOCK *block;               //current block
  MEMUNION *chunk;               //current chunk
  inT32 chunksize;               //size of chunk
  inT32 blockindex;              //index of block
  inT32 buckets;                 //required buckets
  inT32 bucketsize;              //no in each bucket
  inT32 callindex;               //index to callers
  inT32 freeindex;               //index to freeers
  inT32 freeentries;             //table size
  inT32 totalchunks;             //total chunk counts
  inT32 totalspace;              //total mem space
  inT32 totalpchunks;            //permanent chunks
  inT32 totalpspace;             //permanent space
  inT32 totalfrees;              //total free calls

  if (callers == NULL)
    return;                      //can't do anything
  check_mem ("Displaying counts", JUSTCHECKS);
  buckets = mem_countbuckets;
  bucketsize = (malloc_serial - 1) / buckets + 1;
  tprintf ("\nEach bucket covers %g counts.\n",
    (double) bucketsize * malloc_div_ratio);
  for (callindex = 0; callindex < entries; callindex++) {
    if (callers[callindex].free_list != NULL) {
      callers[callindex].counts =
        (inT32 *) malloc (buckets * 4 * sizeof (inT32));
      memset (callers[callindex].counts, 0,
        (size_t) (buckets * 4 * sizeof (inT32)));
    }
  }
  for (blockindex = 0; blockindex < blockcount; blockindex++) {
                                 //current block
    block = &memblocks[blockindex];
                                 //scan all chunks
    for (chunk = block->blockstart; chunk != block->topchunk; chunk += chunksize) {
      chunksize = chunk->size;   //size of chunk
      if (chunksize < 0) {
        chunksize = -chunksize;  //absolute size
        callindex = chunk->owner;
        if (callers[callindex].counts != NULL) {
          callers[callindex].counts[chunk->age / bucketsize * 4]++;
          callers[callindex].counts[chunk->age / bucketsize * 4 +
            1] += chunksize;
        }
      }
    }
                                 //scan all chunks
    for (; chunk != block->blockend; chunk += chunksize) {
      chunksize = chunk->size;   //size of chunk
      if (chunksize < 0) {
        chunksize = -chunksize;  //absolute size
        callindex = chunk->owner;
        if (callers[callindex].counts != NULL) {
          callers[callindex].counts[chunk->age / bucketsize * 4 +
            2]++;
          callers[callindex].counts[chunk->age / bucketsize * 4 +
            3] += chunksize;
        }
      }
    }
  }
  for (callindex = 0; callindex < entries; callindex++) {
    if (callers[callindex].counts != NULL) {
      for (totalspace = 0, totalchunks = 0, totalpspace =
        0, totalpchunks = 0, freeindex = 0; freeindex < buckets;
      freeindex++) {
        totalchunks += callers[callindex].counts[freeindex * 4];
        totalspace += callers[callindex].counts[freeindex * 4 + 1];
        totalpchunks += callers[callindex].counts[freeindex * 4 + 2];
        totalpspace += callers[callindex].counts[freeindex * 4 + 3];
      }
      freeentries = 1 << callers[callindex].free_bits;
      for (totalfrees = 0, freeindex = 0; freeindex < freeentries;
        freeindex++)
      totalfrees += callers[callindex].free_list[freeindex].count;
      if (totalspace != 0 || totalfrees != 0) {
        tprintf ("alloc_mem at %d : total held=%d(%d), frees=%d.\n",
          callers[callindex].caller,
          totalchunks, totalspace * sizeof (MEMUNION),
          totalfrees);
      }
      if (totalspace > 0) {
        for (freeindex = 0; freeindex < buckets; freeindex++) {
          tprintf ("%d(%d) ",
            callers[callindex].counts[freeindex * 4],
            callers[callindex].counts[freeindex * 4 +
            1] * sizeof (MEMUNION));
        }
        tprintf ("\n");
      }
      if (totalfrees != 0) {
        tprintf ("Calls to free : ");
        for (freeindex = 0; freeindex < freeentries; freeindex++) {
          if (callers[callindex].free_list[freeindex].count != 0)
            tprintf ("%d : %d ",
              callers[callindex].free_list[freeindex].freeer,
              callers[callindex].free_list[freeindex].count);
        }
        tprintf ("\n");
      }
      if (totalpspace != 0) {
        tprintf ("alloc_mem_p at %d : total held=%d(%d).\n",
          callers[callindex].caller,
          totalpchunks, totalpspace * sizeof (MEMUNION));
        for (freeindex = 0; freeindex < buckets; freeindex++) {
          tprintf ("%d(%d) ",
            callers[callindex].counts[freeindex * 4 + 2],
            callers[callindex].counts[freeindex * 4 +
            3] * sizeof (MEMUNION));
        }
        tprintf ("\n");
      }
      free (callers[callindex].counts);
      callers[callindex].counts = NULL;
    }
  }
}


/**********************************************************************
 * MEM_ALLOCATOR::check
 *
 * Check consistency of all memory controlled by this allocator.
 **********************************************************************/

void MEM_ALLOCATOR::check(                     //check consistency
                          const char *string,  //context message
                          inT8 level           //level of check
                         ) {
  MEMBLOCK *block;               //current block
  MEMUNION *chunk;               //current chunk
  MEMUNION *prevchunk;           //previous chunk
  inT32 chunksize;               //size of chunk
  inT32 usedcount;               //no of used chunks
  inT32 usedsize;                //size of used chunks
  inT32 freecount;               //no of free chunks
  inT32 freesize;                //size of free chunks
  inT32 biggest;                 //biggest free chunk
  inT32 totusedcount;            //no of used chunks
  inT32 totusedsize;             //size of used chunks
  inT32 totfreecount;            //no of free chunks
  inT32 totfreesize;             //size of free chunks
  inT32 totbiggest;              //biggest free chunk
  inT32 totblocksize;            //total size of blocks
  inT32 chunkindex;              //index of chunk
  inT32 blockindex;              //index of block

  if (level >= MEMCHECKS)
    tprintf ("\nMEM_ALLOCATOR::check:at '%s'\n", string);
  totusedcount = 0;              //grand totals
  totusedsize = 0;
  totfreecount = 0;
  totfreesize = 0;
  totbiggest = 0;
  totblocksize = 0;
  for (blockindex = 0; blockindex < blockcount; blockindex++) {
                                 //current block
    block = &memblocks[blockindex];
    if (level >= MEMCHECKS)
      tprintf ("Block %d:0x%x-0x%x, size=%d, top=0x%x, l=%d, u=%d\n",
        blockindex, block->blockstart, block->blockend,
        (block->blockend - block->blockstart) * sizeof (MEMUNION),
        block->topchunk, block->lowerspace, block->upperspace);
    usedcount = usedsize = 0;    //zero counters
    freecount = freesize = 0;    //zero counters
    biggest = 0;
                                 //scan all chunks
    for (chunkindex = 0, prevchunk = NULL, chunk = block->blockstart; chunk != block->blockend; chunkindex++, chunk += chunksize) {
      chunksize = chunk->size;   //size of chunk
      if (chunksize < 0)
        chunksize = -chunksize;  //absolute size
      if (level >= FULLMEMCHECKS) {
        tprintf ("%5d=%8d%c caller=%d, age=%d ", (int) chunkindex,
          chunksize * sizeof (MEMUNION),
          chunk->size < 0 ? 'U' : 'F', chunk->owner, chunk->age);
        if (chunkindex % 5 == 4)
          tprintf ("\n");
      }
                                 //illegal sizes
      if (chunksize == 0 || chunk->size == -1
                                 //out of bounds
        || chunk + chunksize - block->blockstart <= 0 || block->blockend - (chunk + chunksize) < 0)
        BADMEMCHUNKS.error ("check_mem", ABORT,
          "Block=%p, Prev chunk=%p, Chunk=%p, Size=%x",
          block, prevchunk, chunk,
          (int) chunk->size);

      else if (chunk->size < 0) {
        usedcount++;             //used block
        usedsize += chunksize;
      }
      else {
        freecount++;             //free block
        freesize += chunksize;
        if (chunksize > biggest)
          biggest = chunksize;
      }
      prevchunk = chunk;
    }
    if (level >= MEMCHECKS) {
      if (level >= FULLMEMCHECKS)
        tprintf ("\n");
      tprintf ("%d chunks in use, total size=%d bytes\n",
        (int) usedcount, usedsize * sizeof (MEMUNION));
      tprintf ("%d chunks free, total size=%d bytes\n",
        (int) freecount, freesize * sizeof (MEMUNION));
      tprintf ("Largest free fragment=%d bytes\n",
        biggest * sizeof (MEMUNION));
    }
    totusedcount += usedcount;   //grand totals
    totusedsize += usedsize;
    totfreecount += freecount;
    totfreesize += freesize;
    if (biggest > totbiggest)
      totbiggest = biggest;
    totblocksize += block->blockend - block->blockstart;
  }
  if (level >= MEMCHECKS) {
    tprintf ("%d total blocks in use, total size=%d bytes\n",
      blockcount, totblocksize * sizeof (MEMUNION));
    tprintf ("%d total chunks in use, total size=%d bytes\n",
      (int) totusedcount, totusedsize * sizeof (MEMUNION));
    tprintf ("%d total chunks free, total size=%d bytes\n",
      (int) totfreecount, totfreesize * sizeof (MEMUNION));
    tprintf ("Largest free fragment=%d bytes\n",
      totbiggest * sizeof (MEMUNION));
  }
  if (level >= MEMCHECKS)
    display_counts();
}


/**********************************************************************
 * MEM_ALLOCATOR::alloc_p
 *
 * Allocate permanent space which will never be returned.
 * This space is allocated from the top end of a memory block to
 * avoid the fragmentation which would result from alternate use
 * of alloc_mem for permanent and temporary blocks.
 **********************************************************************/

void *MEM_ALLOCATOR::alloc_p(              //permanent space
                             inT32 count,  //block size to allocate
                             void *caller  //ptr to caller
                            ) {
  MEMBLOCK *block;               //current block
  MEMUNION *chunk;               //current chunk

  if (count < 1 || count > biggestblock)
                                 //request too big
    MEMTOOBIG.error ("alloc_mem_p", ABORT, "%d", (int) count);

  count += sizeof (MEMUNION) - 1;//round up to word
  count /= sizeof (MEMUNION);
  count++;                       //and add one
  if (topblock == NULL) {
    topblock = new_block (count);//get first block
    currblock = topblock;
    if (topblock == NULL) {
      check_mem ("alloc_mem_p returning NULL", MEMCHECKS);
      return NULL;
    }
  }
  block = topblock;              //current block
  do {
    chunk = block->topchunk;
    if (chunk->size < count)
      block = block->next;       //try next block
  }
                                 //until all tried
  while (chunk->size < count && block != topblock);
  if (chunk->size < count) {     //still no good
    chunk = (MEMUNION *) alloc ((count - 1) * sizeof (MEMUNION), caller);
    //try last resort
    if (chunk != NULL)
      return chunk;
    check_mem ("alloc_mem_p returning NULL", MEMCHECKS);
    return NULL;
  }
  block->upperspace -= count;    //less above freechunk
  if (chunk->size > count) {
    chunk->size -= count;
    chunk += chunk->size;
  }
  chunk->size = -count;          //mark as in use
  if (mem_mallocdepth > 0) {
    set_owner(chunk, caller);
  }
  else {
    chunk->owner = 0;
    chunk->age = 0;
  }
  return chunk + 1;              //created chunk
}


/**********************************************************************
 * MEM_ALLOCATOR::alloc
 *
 * Return a pointer to a buffer of count bytes aligned for any type.
 **********************************************************************/

void *MEM_ALLOCATOR::alloc(              //get memory
                           inT32 count,  //no of bytes to get
                           void *caller  //ptr to caller
                          ) {
  MEMBLOCK *block;               //current block
  MEMUNION *chunk;               //current chunk
  inT32 chunksize;               //size of free chunk
  MEMUNION *chunkstart;          //start of free chunk

  if (count < 1 || count > biggestblock)
    MEMTOOBIG.error ("alloc_mem", ABORT, "%d", (int) count);
  //request too big

  count += sizeof (MEMUNION) - 1;//round up to word
  count /= sizeof (MEMUNION);
  count++;                       //and add one
  if (currblock == NULL) {
                                 //get first block
    currblock = new_block (count);
    topblock = currblock;
    if (currblock == NULL) {
      check_mem ("alloc_mem returning NULL", MEMCHECKS);
      return NULL;
    }
  }
  block = currblock;             //current block
  if (block->upperspace <= block->lowerspace) {
                                 //restart chunklist
    block->freechunk = block->blockstart;
    block->upperspace += block->lowerspace;
    block->lowerspace = 0;       //correct space counts
  }
  chunk = block->freechunk;      //current free chunk
  if (chunk->size < count) {     //big enough?
    do {
                                 //search for free chunk
      chunk = block->find_chunk (count);
      if (chunk->size < count)
        block = block->next;     //try next block
    }
                                 //until all tried
    while (chunk->size < count && block != currblock);
    if (chunk->size < count) {   //still no good
                                 //get a new block
      currblock = new_block (count);
      topblock = currblock;      //set perms here too
      if (currblock == NULL) {
        check_mem ("alloc_mem returning NULL", MEMCHECKS);
        return NULL;
      }
      block = currblock;
      chunk = block->freechunk;  //bound to be big enough
    }
  }
  chunkstart = chunk;            //start of chunk
  if (chunk == block->topchunk && chunk + count != block->blockend)
    block->topchunk += count;    //top has moved
  block->upperspace -= count;    //upper part used
  chunksize = chunk->size;       //size of free chunk
  chunk->size = -count;          //mark as used
  chunk += count;                //next free space
  totalmem -= count;             //no of free elements
  if (chunksize > count)         //bigger than exact?
                                 //remaining space
    chunk->size = chunksize - count;
  else if (chunk == block->blockend) {
    chunk = block->blockstart;   //restart block
    block->upperspace = block->lowerspace;
    block->lowerspace = 0;       //fix space counts
  }
  block->freechunk = chunk;      //next free block
  if (mem_mallocdepth > 0) {
    set_owner(chunkstart, caller);
  }
  else {
    chunkstart->owner = 0;
    chunkstart->age = 0;
  }
  chunkstart++;                  //start of block
  return chunkstart;             //pointer to block
}


/**********************************************************************
 * MEM_ALLOCATOR::set_owner
 *
 * Set the owner and time stamp of the block and check if needed.
 **********************************************************************/

void MEM_ALLOCATOR::set_owner(                       //get memory
                              MEMUNION *chunkstart,  //chunk to set
                              void *caller           //ptr to caller
                             ) {
  uinT16 callindex;              //hash code

  callindex = hash_caller (caller);
  chunkstart->owner = callindex;
                                 //store evidence
  chunkstart->age = malloc_serial;
  malloc_minor_serial++;
  if (malloc_minor_serial >= malloc_div_ratio) {
    malloc_minor_serial = 0;
    malloc_serial++;             //count calls
    if (malloc_serial == 0) {
                                 //wrap around
      reduce_counts();  //fix serial numbers
      malloc_serial = MAX_INT16 + 1;
                                 //all worth double
      malloc_div_ratio += malloc_div_ratio;
    }
  }
  malloc_auto_count++;
  if (mem_checkfreq > 0 && malloc_auto_count >= (uinT32) mem_checkfreq) {
    malloc_auto_count = 0;
    check_mem ("Auto check", MEMCHECKS);
  }
}


/**********************************************************************
 * MEM_ALLOCATOR::dealloc
 *
 * Free a block allocated by alloc (or alloc_p).
 * It checks that the pointer is legal and maintains counts of the
 * amount of free memory above and below the current free pointer.
 **********************************************************************/

void MEM_ALLOCATOR::dealloc(                 //free memory
                            void *oldchunk,  //chunk to free
                            void *caller     //ptr to caller
                           ) {
  MEMUNION *chunk;               //current chunk
  MEMBLOCK *block;               //current block

  if (oldchunk == NULL)
    FREENULLPTR.error ("free_mem", ABORT, NULL);
  chunk = (MEMUNION *) oldchunk;
  block = currblock;             //current block
  if (block == NULL)
    NOTMALLOCMEM.error ("free_mem", ABORT, NULL);
  do {
    block = block->next;
  }
                                 //outside the block
  while ((chunk - block->blockstart < 0 || block->blockend - chunk <= 0)
    && block != currblock);

  if (chunk - block->blockstart < 0 || block->blockend - chunk <= 0)
                                 //in no block
    NOTMALLOCMEM.error ("free_mem", ABORT, NULL);

  chunk--;                       //point to size
  if (chunk->size == 0)
                                 //zero size
    FREEILLEGALPTR.error ("free_mem", ABORT, NULL);
  else if (chunk->size > 0)
                                 //already free
    FREEFREEDBLOCK.error ("free_mem", ABORT, NULL);
  chunk->size = -chunk->size;    //mark it free
  if (mem_freedepth > 0 && callers != NULL) {
                                 //count calls
    callers[chunk->owner].count_freeer (caller);
  }
  totalmem += chunk->size;       //total free memory
  if (chunk - block->freechunk < 0)
                                 //extra below
    block->lowerspace += chunk->size;
  else
                                 //extra above
    block->upperspace += chunk->size;
}


/**********************************************************************
 * MEM_ALLOCATOR::new_block
 *
 * Gets a new big block of memory from malloc for use by alloc_mem.
 **********************************************************************/

MEMBLOCK *MEM_ALLOCATOR::new_block(               //get new big block
                                   inT32 minsize  //minimum size
                                  ) {
  MEMBLOCK *newblock;            //new block

  if (blockcount >= MAXBLOCKS) {
                                 //can't have another
    NOMOREBLOCKS.error ("mem_new_block", TESSLOG, NULL);
    return NULL;
  }
  if (mem_checkfreq != 0) {
    tprintf ("\nGetting new block due to request size of %d",
      minsize * sizeof (MEMUNION));
    tprintf (" from %d from %d from %d from %d from %d\n",
      trace_caller (3), trace_caller (4), trace_caller (5),
      trace_caller (6), trace_caller (7));
    check_mem ("Getting new block", MEMCHECKS);
  }
                                 //get a new one
  newblock = &memblocks[blockcount++];
  while (memsize < minsize)
    memsize *= 4;                //go up in sizes
                                 //get a big block
  newblock->blockstart = (MEMUNION *)
    malloc (memsize * sizeof (MEMUNION));
  if (newblock->blockstart == NULL) {
    NOMOREMEM.error ("mem_new_block", TESSLOG, NULL);

    #ifdef __UNIX__
    raise(SIGTTOU);  //hangup for js
    #endif
    return NULL;
  }
                                 //end of block
  newblock->blockend = newblock->blockstart + memsize;
                                 //first free chunk
  newblock->freechunk = newblock->blockstart;
  newblock->topchunk = newblock->blockstart;
  newblock->lowerspace = 0;
  newblock->upperspace = memsize;//amount available
                                 //set pointer
  newblock->freechunk->size = memsize;
  newblock->freechunk->owner = 0;
  newblock->freechunk->age = 0;

  totalmem += memsize;           //total assigned mem

  if (memsize < maxsize)
    memsize *= 4;                //successively bigger
  if (currblock == NULL) {
    newblock->next = newblock;   //first block
  }
  else {
                                 //insert in list
    newblock->next = currblock->next;
    currblock->next = newblock;
  }
  return newblock;               //new block
}


/**********************************************************************
 * MEMBLOCK::find_chunk
 *
 * Find a chunk within the block which is big enough for the given request
 **********************************************************************/

MEMUNION *MEMBLOCK::find_chunk(             //find free chunk
                               inT32 count  //size required
                              ) {
  MEMUNION *chunk;               //current chunk
  inT32 chunksize;               //size of free chunk
  MEMUNION *chunkstart;          //start of free chunk
  inT32 spaceshift;              //shift in lowerspace

  if (upperspace <= lowerspace) {
    freechunk = blockstart;      //restart chunklist
    upperspace += lowerspace;
    lowerspace = 0;              //correct space counts
  }
  chunk = freechunk;             //current free chunk
  if (chunk->size < count) {     //big enough?
    spaceshift = 0;
    do {
      while (chunk->size < 0) {  //find free chunk
        chunk -= chunk->size;    //skip forward
        if (chunk == blockend) {
          chunk = blockstart;    //restart block
                                 //gone back to start
          spaceshift = -lowerspace;
        }
        if (chunk == freechunk)
          return chunk;          //gone all round & failed
      }
      chunkstart = chunk;        //start of chunk
      chunksize = chunk->size;;
      chunk += chunk->size;
      while (chunk != blockend   //until end
      && chunk->size > 0) {      //or used
        chunksize += chunk->size;//coalesce free blocks
                                 //gone all round
        if (chunk == freechunk) {
                                 //ensure it is at end
          freechunk += chunk->size;
          upperspace -= chunk->size;
          lowerspace += chunk->size;
          spaceshift -= chunk->size;
        }
        if (chunk == topchunk)   //got back to end one
          topchunk = chunkstart; //end one bigger
        chunk += chunk->size;    //get next block
      }
                                 //new big block
      chunkstart->size = chunksize;
      if (chunksize < count)
        spaceshift += chunksize; //skipping free block
      if (chunk == blockend) {
        chunk = blockstart;      //back to start
        if (freechunk == blockend) {
          freechunk = blockstart;//so is freechunk
          upperspace += lowerspace;
          lowerspace = 0;
          spaceshift = 0;
        }
        else
                                 //so is shift
            spaceshift = -lowerspace;
      }
    }
    while (chunksize < count && chunk != freechunk);
    if (chunksize < count)
      return chunk;              //failed
    lowerspace += spaceshift;    //get space counts right
    upperspace -= spaceshift;
    freechunk = chunkstart;
    return chunkstart;           //success
  }
  return chunk;                  //easy
}


#ifdef __UNIX__
/**********************************************************************
 * trace_caller
 *
 * Return the return address of the caller at a given depth back.
 * 0 gives the return address of the caller to trace_caller.
 * S300 ONLY!!
 **********************************************************************/
//#pragma OPTIMIZE OFF                                                                                                  /*force link*/

void *trace_caller(             //trace stack
                   inT32 depth  //depth to trace
                  ) {
  #ifdef hp9000s800

  unsigned sp, pc, rp;           //registers
  UWREC rec1;                    //for unwinder
  UWREC rec2;

  sp = (unsigned) (&depth + 9);
  pc = *(int *) (sp - 20);
  rp = 0;
  get_pcspace(&rec1, pc);
  rec1.cur_frsize = 0xc0;
  rec1.currlo = pc & ~3;
  rec1.curdp = 0;
  rec1.toprp = rp;

  while (depth > 0) {
    if (U_get_previous_frame (&rec1, &rec2))
      return NULL;
    rec1.currlo = rec2.currlo;
    rec1.cur_frsize = rec2.cur_frsize;
    rec1.cursp = rec2.cursp;
    rec1.currls = rec2.currls;
    rec1.curdp = rec2.curdp;
    depth--;
  }
  return (void *) rec1.currlo;
  #else
  void *a6;                      //address register

  a6 = &depth - 2;
  while (depth > 0) {
    a6 = *(void **) a6;          //follow chain
    depth--;
  }
  return *((void **) a6 + 1);
  #endif
}


//#pragma OPTIMIZE ON

#else

// Fake procedure for non-UNIX
void *trace_caller(             //trace stack
                   inT32 depth  //depth to trace
                  ) {
  return NULL;
}
#endif

/**********************************************************************
 * identify_struct_owner
 *
 * Get an index into the table of owners of structures.
 * Implemented very inefficiently, but only a debug tool!
 **********************************************************************/

inT32 identify_struct_owner(                     //get table index
                            inT32 struct_count,  //cell size
                            const char *name     //name of type
                           ) {
  inT32 index;                   //index to structure

  for (index = 0; index < name_counts[struct_count]
    && strcmp (name, owner_names[struct_count][index]); index++);
  if (index < MAX_CLASSES) {
    if (index == name_counts[struct_count]) {
      name_counts[struct_count]++;
      owner_names[struct_count][index] = name;
      owner_counts[struct_count][index] = 0;
    }
  }
  return index;
}


/**********************************************************************
 * check_struct
 *
 * Check a particular structure size for consistency.
 **********************************************************************/

void check_struct(             //check a structure
                  inT8 level,  //print control
                  inT32 count  //no of bytes
                 ) {
  MEMUNION *element;             //current element
  MEMUNION *block;               //current block
  inT32 struct_count;            //no of required structs
  inT32 block_count;             //no of structure blocks
  inT32 free_count;              //size of freelist*/
  inT32 name_index;              //named holder
  inT32 named_total;             //total held by names

                                 //no of MEMUNIONS-1
  struct_count = (count - 1) / sizeof (MEMUNION);
  if (struct_count < 0 || struct_count >= MAX_STRUCTS)
                                 //request too big
    MEMTOOBIG.error ("check_struct", ABORT, "%d", (int) count);

  free_count = 0;                //size of freelist
                                 //count blocks
  for (block_count = 0, block = struct_blocks[struct_count]; block != NULL; block = block->ptr, block_count++);
  if (block_count > 0) {
                                 //scan freelist
    for (element = free_structs[struct_count]; element != NULL; element = element->ptr)
      free_count++;
    if (level >= MEMCHECKS) {
      tprintf ("No of structs of size %d in use=%d,",
        (int) count, (int) structs_in_use[struct_count]);
      tprintf (" %d free", free_count);
      tprintf (" in %d blocks, total space=%d\n",
        (int) block_count,
        block_count * STRUCT_BLOCK_SIZE * sizeof (MEMUNION));
      for (named_total = 0, name_index = 0;
      name_index < name_counts[struct_count]; name_index++) {
        tprintf ("No held by %s=%d\n",
          owner_names[struct_count][name_index],
          owner_counts[struct_count][name_index]);
        named_total += owner_counts[struct_count][name_index];
      }
      tprintf ("Total held by names=%d\n", named_total);
    }
  }
  if (structs_in_use[struct_count] + free_count
    != block_count * (STRUCT_BLOCK_SIZE / (struct_count + 1) - 1))
    BADSTRUCTCOUNT.error ("check_struct", ABORT, "%d+%d=%d",
      structs_in_use[struct_count], free_count,
      block_count * (STRUCT_BLOCK_SIZE /
      (struct_count + 1) - 1));
}


/**********************************************************************
 * check_structs
 *
 * Reports statistics on each maintained structure type by calling
 * free_struct(NULL) on each.  Only active structure types are reported.
 **********************************************************************/

void check_structs(            //count in use on structs
                   inT8 level  //print control
                  ) {
  inT8 index;                    //index to structs

  for (index = 1; index <= MAX_STRUCTS; index++)
                                 //check number allocated
    check_struct (level, index * sizeof (MEMUNION));
}


/**********************************************************************
 * new_struct_block
 *
 * Allocate space for a new block of structures.  The space is obtained
 * from alloc_mem, and a freelist of such blocks is maintained for when
 * the individual structure types get completely freed.
 **********************************************************************/

void *new_struct_block() {  //allocate memory
  MEMUNION *element;             //current element
  MEMUNION *returnelement;       //return value

  returnelement = free_block;
  if (returnelement == NULL) {
                                 //need a new block
    element =
      (MEMUNION *) alloc_mem_p (STRUCT_BLOCK_SIZE * sizeof (MEMUNION));
    if (element == NULL)
      return NULL;               //can't get more
    returnelement = element;     //going to return 1st
  }
  else {
                                 //new free one
    free_block = returnelement->ptr;
  }
  return returnelement;          //free cell
}


/**********************************************************************
 * old_struct_block
 *
 * Free memory allocated by new_struct_block.  The block is returned
 * to a freelist ready for a new call to new_struct_block.
 * This saves confusion over freeing "permanent" blocks, yet
 * allows them to be recycled for different structures.
 **********************************************************************/

void old_struct_block(                     //free a structure block
                      MEMUNION *deadblock  //block to free
                     ) {
  if (deadblock != NULL) {
    deadblock->ptr = free_block; //add to freelist
    free_block = deadblock;
    free_struct_blocks++;
  }
  if (free_struct_blocks > MAX_FREE_S_BLOCKS) {
    MEMUNION *next_block;        //next in list
    deadblock = free_block;
    do {
      next_block = deadblock->ptr;
      free_mem(deadblock);  //really free it
      deadblock = next_block;
    }
    while (deadblock != NULL);
    free_struct_blocks = 0;
    free_block = NULL;
  }
}
/////////////////////////////////////////////////////////memblk//////////////////////////////


/////////////////////////////////////////////////////////////////////memry///////////////////

//#define COUNTING_CLASS_STRUCTURES

/**********************************************************************
 * new
 *
 * Replace global new to get at memory leaks etc.
 **********************************************************************/
/*
void*						operator new(				//allocate memory
size_t						size						//amount to allocate
)
{
  if (size==0)
  {
    err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
      ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
      "Zero requested of new");
    size=1;
  }
  return alloc_big_mem(size);
}

void						operator delete(			//free memory
void*						addr						//mem to free
)
{
  free_big_mem(addr);
}*/

/**********************************************************************
 * check_mem
 *
 * Check consistency of all memory controlled by alloc_mem.
 **********************************************************************/

void check_mem(                     //check consistency
                      const char *string,  //context message
                      inT8 level           //level of check
                     ) {
  big_mem.check (string, level);
  main_mem.check (string, level);
  check_structs(level);
}


/**********************************************************************
 * alloc_string
 *
 * Allocate space for a string.  The space can only be used for chars as
 * it is not aligned.  Allocation is guaranteed to be fast and not cause
 * fragmentation for small strings (upto 10*worst alignment).  Calls for
 * larger strings will be satisfied with alloc_mem.
 * Use free_string to free the space from alloc_string.
 **********************************************************************/

char *alloc_string(             //allocate string
                          inT32 count  //no of chars required
                         ) {
#ifdef RAYS_MALLOC
  char *string;                  //allocated string

  if (count < 1 || count > MAX_CHUNK) {
    tprintf ("Invalid size %d requested of alloc_string", count);
    return NULL;
  }

  count++;                       //add size byte
  if (count <= MAX_STRUCTS * sizeof (MEMUNION)) {
    string = (char *) alloc_struct (count, "alloc_string");
    //get a fast structure
    if (string == NULL) {
      tprintf ("No memory for alloc_string");
      return NULL;
    }
    string[0] = (inT8) count;    //save its length
  }
  else {
                                 //get a big block
    string = (char *) alloc_mem (count);
    if (string == NULL) {
      tprintf ("No memory for alloc_string");
      return NULL;
    }
    string[0] = 0;               //mark its id
  }
  return &string[1];             //string for user
#else
  // Round up the amount allocated to a multiple of 4
  return static_cast<char*>(malloc((count + 3) & ~3));
#endif
}


/**********************************************************************
 * free_string
 *
 * Free a string allocated by alloc_string.
 **********************************************************************/

void free_string(              //free a string
                        char *string  //string to free
                       ) {
#ifdef RAYS_MALLOC
  if (((ptrdiff_t) string & 3) == 1) { //one over word
    string--;                    //get id marker
    if (*string == 0) {
      free_mem(string);  //generally free it
      return;
    }
    else if (*string <= MAX_STRUCTS * sizeof (MEMUNION)) {
                                 //free structure
      free_struct (string, *string, "alloc_string");
      return;
    }
  }
  tprintf ("Non-string given to free_string");
#else
  free(string);
#endif
}


/**********************************************************************
 * alloc_struct
 *
 * Allocate space for a structure.  This function is designed to be
 * fast and fragmentation free for arbitrary combinations of small
 * objects. (Upto 40 bytes in length.)
 * It can be used for any size of object up to 512K, but you must use
 * free_struct to release the memory it gives.  alloc_mem is better
 * for arbitrary data blocks of large size (>40 bytes.)
 * alloc_struct always aborts if the allocation fails.
 **********************************************************************/

void *
alloc_struct (                   //allocate memory
inT32 count,                     //no of chars required
#if defined COUNTING_CLASS_STRUCTURES
const char *name                 //name of type
#else
const char *                     //name of type
#endif
) {
#ifdef RAYS_MALLOC
  MEMUNION *element;             //current element
  MEMUNION *returnelement;       //return value
  inT32 struct_count;            //no of required structs
  inT32 blocksize;               //no of structs in block
  inT32 index;                   //index to structure

  if (count < 1 || count > MAX_CHUNK) {
    tprintf ("Invalid size %d requested of alloc_struct", count);
    return NULL;
  }

  //      tprintf("Allocating structure of size %d\n",count);
                                 //no of MEMUNIONS-1
  struct_count = (count - 1) / sizeof (MEMUNION);
  if (struct_count < MAX_STRUCTS) {
                                 //can do fixed sizes
    #ifdef COUNTING_CLASS_STRUCTURES
    if (name != NULL) {
      index = identify_struct_owner (struct_count, name);
      if (index < MAX_CLASSES)
        owner_counts[struct_count][index]++;
    }
    #endif
                                 //head of freelist
    returnelement = free_structs[struct_count];
    if (returnelement == NULL) {
                                 //need a new block
                                 //get one
      element = (MEMUNION *) new_struct_block ();
      if (element == NULL) {
        tprintf ("No memory to satisfy request for %d", (int) count);
        return NULL;
      }
                                 //add to block list
      element->ptr = struct_blocks[struct_count];
      struct_blocks[struct_count] = element;
      blocks_in_use[struct_count]++;
      element++;                 //free cell
      returnelement = element;   //going to return 1st
      blocksize = STRUCT_BLOCK_SIZE / (struct_count + 1) - 1;

      for (index = 1; index < blocksize; index++) {
                                 //make links
        element->ptr = element + struct_count + 1;
        element += struct_count + 1;
      }
      element->ptr = NULL;       //end of freelist
    }
                                 //new free one
    free_structs[struct_count] = returnelement->ptr;
                                 //count number issued
    structs_in_use[struct_count]++;
  }
  else {
                                 //just get some
    returnelement = (MEMUNION *) alloc_mem (count);
    if (returnelement == NULL) {
      tprintf ("No memory to satisfy request for %d", (int) count);
      return NULL;
    }
  }
  return returnelement;          //free cell
#else
  return malloc(count);
#endif
}


/**********************************************************************
 * free_struct
 *
 * Free memory allocated by alloc_struct.  The size must be supplied.
 **********************************************************************/

void
free_struct (                    //free a structure
void *deadstruct,                //structure to free
inT32 count,                     //no of bytes
#if defined COUNTING_CLASS_STRUCTURES
const char *name                 //name of type
#else
const char *                     //name of type
#endif
) {
    Q_UNUSED(count);
#ifdef RAYS_MALLOC
  MEMUNION *end_element;         //current element
  MEMUNION *element;             //current element
  MEMUNION *prev_element;        //previous element
  MEMUNION *prev_block;          //previous element
  MEMUNION *nextblock;           //next block in list
  MEMUNION *block;               //next block in list
  inT32 struct_count;            //no of required structs
  inT32 index;                   //to structure counts

  if (count < 1 || count > MAX_CHUNK) {
    tprintf ("Invalid size %d requested of free_struct", count);
    return;
  }

  //      tprintf("Freeing structure of size %d\n",count);
                                 //no of MEMUNIONS-1
  struct_count = (count - 1) / sizeof (MEMUNION);

  if (deadstruct == NULL) {
                                 //not really legal
    check_struct(MEMCHECKS, count);
  }
  else {
    if (struct_count < MAX_STRUCTS) {
                                 //can do fixed sizes
      #ifdef COUNTING_CLASS_STRUCTURES
      if (name != NULL) {
        index = identify_struct_owner (struct_count, name);
        if (index < MAX_CLASSES) {
          owner_counts[struct_count][index]--;
          ASSERT_HOST (owner_counts[struct_count][index] >= 0);
        }
      }
      #endif
      element = (MEMUNION *) deadstruct;
                                 //add to freelist
      element->ptr = free_structs[struct_count];
      free_structs[struct_count] = element;
                                 //one less in use
      structs_in_use[struct_count]--;
      if (structs_in_use[struct_count] == 0) {
        index = 0;
        for (element = struct_blocks[struct_count];
        element != NULL; element = nextblock) {
                                 //traverse and destroy
          nextblock = element->ptr;
                                 //free all the blocks
          old_struct_block(element);
          index++;
        }
                                 //none left any more
        struct_blocks[struct_count] = NULL;
                                 //no free structs
        free_structs[struct_count] = NULL;
        blocks_in_use[struct_count] = 0;
      }
      else if (structs_in_use[struct_count] < 0) {
        tprintf ("Negative number of structs of size %d in use",
          (int) count);
      }
      else if (structs_in_use[struct_count] < blocks_in_use[struct_count]) {
        prev_block = NULL;
        for (block = struct_blocks[struct_count];
        block != NULL; block = nextblock) {
          nextblock = block;
          index = STRUCT_BLOCK_SIZE / (struct_count + 1) - 1;
          end_element = block + STRUCT_BLOCK_SIZE;
          for (element = free_structs[struct_count];
          element != NULL; element = element->ptr) {
            if (element > nextblock && element < end_element) {
              index--;
              if (index == 0)
                break;
            }
          }
          if (index == 0) {
            index = STRUCT_BLOCK_SIZE / (struct_count + 1) - 1;
            for (element =
              free_structs[struct_count], prev_element = NULL;
            element != NULL; element = element->ptr) {
              if (element > nextblock && element < end_element) {
                index--;
                if (prev_element != NULL)
                  prev_element->ptr = element->ptr;
                else
                  free_structs[struct_count] = element->ptr;
                if (index == 0)
                  break;
              }
              else
                prev_element = element;
            }
            if (prev_block != NULL)
              prev_block->ptr = block->ptr;
            else
              struct_blocks[struct_count] = block->ptr;
            nextblock = block->ptr;
            blocks_in_use[struct_count]--;
                                 //free all the blocks
            old_struct_block(block);
          }
          else {
            prev_block = block;
                                 //traverse and destroy
            nextblock = block->ptr;
          }
        }
      }
    }
    else
      free_mem(deadstruct);  //free directly
  }
#else
  free(deadstruct);
#endif
}


/**********************************************************************
 * alloc_mem_p
 *
 * Allocate permanent space which will never be returned.
 * This space is allocated from the top end of a memory block to
 * avoid the fragmentation which would result from alternate use
 * of alloc_mem for permanent and temporary blocks.
 **********************************************************************/

//#ifdef __UNIX__
//#pragma OPT_LEVEL 0
//#endif
void *alloc_mem_p(             //allocate permanent space
                         inT32 count  //block size to allocate
                        ) {
  #ifdef RAYS_MALLOC
  #ifdef TESTING_BIGSTUFF
  if (main_mem.biggestblock == 0)
    main_mem.init (alloc_big_mem, free_big_mem,
      FIRSTSIZE, LASTSIZE, MAX_CHUNK);
  #else
  if (main_mem.biggestblock == 0)
    main_mem.init ((void *(*)(inT32)) malloc, free,
      FIRSTSIZE, LASTSIZE, MAX_CHUNK);
  #endif
  if (mem_mallocdepth > 0)
    return main_mem.alloc_p (count, trace_caller (mem_mallocdepth));
  else
    return main_mem.alloc_p (count, NULL);
  #else
  return malloc ((size_t) count);
  #endif
}


/**********************************************************************
 * alloc_mem
 *
 * Return a pointer to a buffer of count bytes aligned for any type.
 **********************************************************************/

void *alloc_mem(             //get some memory
                       inT32 count  //no of bytes to get
                      )
{
  #ifdef RAYS_MALLOC
  #ifdef TESTING_BIGSTUFF
  if (main_mem.biggestblock == 0)
    main_mem.init (alloc_big_mem, free_big_mem,
      FIRSTSIZE, LASTSIZE, MAX_CHUNK);
  #else
  if (main_mem.biggestblock == 0)
    main_mem.init((void *(*)(inT32)) malloc, free,
      FIRSTSIZE, LASTSIZE, MAX_CHUNK);
  #endif
  if (mem_mallocdepth > 0)
    return main_mem.alloc(count, trace_caller(mem_mallocdepth));
  else
    return main_mem.alloc(count, NULL);
  #else
  return malloc((size_t) count);
  #endif
}


/**********************************************************************
 * alloc_big_mem
 *
 * Return a pointer to a buffer of count bytes aligned for any type.
 **********************************************************************/

void *alloc_big_mem(             //get some memory
                           inT32 count  //no of bytes to get
                          ) {
  #ifdef TESTING_BIGSTUFF
  if (big_mem.biggestblock == 0)
    big_mem.init ((void *(*)(inT32)) malloc, free,
      BIGSIZE, BIGSIZE, MAX_BIGCHUNK);
  if (mem_mallocdepth > 0)
    return big_mem.alloc (count, trace_caller (mem_mallocdepth));
  else
    return big_mem.alloc (count, NULL);
  #else
  return malloc ((size_t) count);
  #endif
}


/**********************************************************************
 * alloc_big_zeros
 *
 * Return a pointer to a buffer of count bytes aligned for any type.
 **********************************************************************/

void *alloc_big_zeros(             //get some memory
                             inT32 count  //no of bytes to get
                            ) {
  #ifdef TESTING_BIGSTUFF
  if (big_mem.biggestblock == 0)
    big_mem.init ((void *(*)(inT32)) malloc, free,
      BIGSIZE, BIGSIZE, MAX_BIGCHUNK);
  void *buf;                     //return value

  if (mem_mallocdepth > 0)
    buf = big_mem.alloc (count, trace_caller (mem_mallocdepth));
  else
    buf = big_mem.alloc (count, NULL);
  memset (buf, 0, count);
  return buf;
  #else
  return calloc((size_t) count, 1);
  #endif
}


/**********************************************************************
 * free_mem
 *
 * Free a block allocated by alloc_mem (or alloc_mem_p).
 * It checks that the pointer is legal and maintains counts of the
 * amount of free memory above and below the current free pointer.
 **********************************************************************/

void free_mem(                //free mem from alloc_mem
                     void *oldchunk  //chunk to free
                    ) {
  #ifdef RAYS_MALLOC
  if (mem_freedepth > 0 && main_mem.callers != NULL)
    main_mem.dealloc (oldchunk, trace_caller (mem_freedepth));
  else
    main_mem.dealloc (oldchunk, NULL);
  #else
  free(oldchunk);
  #endif
}


/**********************************************************************
 * free_big_mem
 *
 * Free a block allocated by alloc_big_mem.
 * It checks that the pointer is legal and maintains counts of the
 * amount of free memory above and below the current free pointer.
 **********************************************************************/

void free_big_mem(                //free mem from alloc_mem
                         void *oldchunk  //chunk to free
                        ) {
  #ifdef TESTING_BIGSTUFF
  if (mem_freedepth > 0 && main_mem.callers != NULL)
    big_mem.dealloc (oldchunk, trace_caller (mem_freedepth));
  else
    big_mem.dealloc (oldchunk, NULL);
  #else
  free(oldchunk);
  #endif
}
//////////////////////////////////////////////////////////////memry/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////IMAGE///////////////////////////////////////////////////////////
#ifdef __MSW32__
#else
#endif
#ifdef __UNIX__
#endif

// Include automatically generated configuration file if running autoconf.
#ifdef HAVE_CONFIG_H
#endif

#ifdef HAVE_LIBLEPT
// Include leptonica library only if autoconf (or makefile etc) tell us to.
#endif

#define FIXED_COLOURS   32       /*number of fixed colours */
#define MIN_4BIT      48         /*4bpp range */
#define MAX_4BIT      64
#define MIN_6BIT      64         /*6bpp range */
#define MAX_6BIT      128
#define BLACK_PIX     0

const uinT8 grey_scales[FIXED_COLOURS] =
{
    0, 255, 76, 227, 151, 179, 28, 104,
    149, 72, 215, 67, 53, 44, 156, 137,
    110, 153, 79, 181, 166, 218, 55, 81,
    129, 105, 179, 149, 168, 69, 84, 126
};

#undef EXTERN
#define EXTERN

// Parameter remains truly global, as it is tough to make a member of Image
// and the whole of this code is likely to go away in the future.
EXTERN INT_VAR (image_default_resolution, 300, "Image resolution dpi");

/**********************************************************************
 * IMAGE
 *
 * Contructor for an IMAGE class. Makes the image definitely illegal.
 **********************************************************************/

IMAGE::IMAGE()
{  //construct an image
    bpp = 0;                       //all illegal
    fd = -1;
    image = NULL;
    photo_interp = 1;
    res = image_default_resolution;
}


/**********************************************************************
 * IMAGE::operator=
 *
 * Assign an IMAGE to another. The dest becomes the owner of the memory.
 **********************************************************************/

IMAGE & IMAGE::operator= (       //assignment
                                 IMAGE & source                   //source image
                                 )
{
    destroy();
    bpp = source.bpp;
    photo_interp = source.photo_interp;
    bps = source.bps;
    bytespp = (bpp + 7) / 8;
    lineskip = source.lineskip;    //copy everything
    captured = source.captured;
    xsize = source.xsize;
    ysize = source.ysize;
    res = source.res;
    image = source.image;
    xdim = source.xdim;
    bufheight = source.bufheight;
    fd = source.fd;
    reader = source.reader;
    ymin = source.ymin;
    ymax = source.ymax;

    source.captured = TRUE;        //source now captured
    source.fd = -1;

    return *this;
}

/**********************************************************************
 * check_legal_image_size
 *
 * Check that the supplied image sizes are legal.  If they are,
 * the xdim is returned, else -1.
 **********************************************************************/

inT32 check_legal_image_size(                     //get rest of image
                                                  inT32 x,             //x size required
                                                  inT32 y,             //ysize required
                                                  inT8 bits_per_pixel  //bpp required
                                                  )
{
    if (x <= 0 || y <= 0)
    {
        BADIMAGESIZE.error ("check_legal_image_size", TESSLOG, "(%d,%d)", x, y);
        return -1;                   //failed
    }

    if (bits_per_pixel != 1 && bits_per_pixel != 2 && bits_per_pixel != 4 &&
            bits_per_pixel != 5 && bits_per_pixel != 6 && bits_per_pixel != 8 && bits_per_pixel != 24 && bits_per_pixel != 32)
    {
        BADBPP.error ("check_legal_image_size", TESSLOG, "%d", bits_per_pixel);
        return -1;
    }
    //bytes per line
    return COMPUTE_IMAGE_XDIM(x, bits_per_pixel);
}

/**********************************************************************
 * create
 *
 * Create an image (allocate memory) of a specific size and bpp.
 **********************************************************************/

inT8 IMAGE::create(                     //get rest of image
                                        inT32 x,             //x size required
                                        inT32 y,             //ysize required
                                        inT8 bits_per_pixel  //bpp required
                                        )
{
    uinT8 *pixels;                 //memory for image

    xdim = check_legal_image_size(x, y, bits_per_pixel);

    if (xdim < 0) return -1;

    pixels = (uinT8 *)alloc_big_zeros((size_t)(xdim * y * sizeof (uinT8)));
    if (pixels == NULL)
    {
        MEMORY_OUT.error ("IMAGE::create", ABORT, "Size=(%d,%d)", xdim, y);
        return -1;
    }
    //allocate to image
    this->capture(pixels, x, y, bits_per_pixel);
    captured = FALSE;
    res = image_default_resolution;

    return 0;                      //success
}


/**********************************************************************
 * destroy
 *
 * Destroy an image, freeing memory and closing any open file.
 **********************************************************************/

void IMAGE::destroy()
{  //get rid of image
    if (image != NULL && !captured)
    {
        free_big_mem(image);
    }

    image = NULL;
    if (fd >= 0)
    {
        close(fd);
        fd = -1;
    }

    bpp = 0;
}

/**********************************************************************
 * capture
 *
 * Assign a given memory area to an image to use as an image of
 * given size and bpp.
 **********************************************************************/

inT8 IMAGE::capture(                     //get rest of image
                                         uinT8 *pixels,       //image memory
                                         inT32 x,             //x size required
                                         inT32 y,             //ysize required
                                         inT8 bits_per_pixel  //bpp required
                                         )
{
    destroy();
    xdim = check_legal_image_size (x, y, bits_per_pixel);
    if (xdim < 0) return -1;

    xsize = x;
    ysize = y;
    bufheight = y;
    bpp = bits_per_pixel;
    bps = bpp == 24 ? 8 : bpp;
    photo_interp = 1;
    bytespp = (bpp + 7) / 8;
    image = pixels;                //assign image area
    ymin = 0;
    ymax = bufheight;              //read it all
    captured = TRUE;
    res = image_default_resolution;

    return 0;                      //success
}


/**********************************************************************
 * pixel
 *
 * Get a single pixel out of the image.
 **********************************************************************/

uinT8 IMAGE::pixel(          //get rest of image
                             inT32 x,  //x coord
                             inT32 y   //y coord
                             )
{
    if (x < 0)
    {
        x = 0;                       //silently clip
    }
    else if (x >= xsize)
    {
        x = xsize - 1;
    }

    if (y < 0)
    {
        y = 0;
    }
    else if (y >= ysize)
    {
        y = ysize - 1;
    }

    check_legal_access (x, y, 1);

    switch (bpp)
    {
    case 5:
    case 6:
    case 8:
        return image[(ymax - 1 - y) * xdim + x];
    case 4:
        return bpp4table[image[(ymax - 1 - y) * xdim + x / 2]][x & 1];
    case 2:
        return bpp2table[image[(ymax - 1 - y) * xdim + x / 4]][x & 3];
    case 1:
        return bpp1table[image[(ymax - 1 - y) * xdim + x / 8]][x & 7];
    default:
        tprintf ("Unexpected bits per pixel %d\n", bpp);
        return 0;
    }
}


/**********************************************************************
 * copy_sub_image
 *
 * Copy a portion of one image to a portion of another image.
 * If the bpps are different, the position of the most significant
 * bit is preserved.
 **********************************************************************/

void copy_sub_image(                   //copy rectangle
                                              IMAGE *source,     //source image
                                              inT32 xstart,      //start coords
                                              inT32 ystart,
                                              inT32 xext,        //extent to copy
                                              inT32 yext,
                                              IMAGE *dest,       //destination image
                                              inT32 xdest,       //destination coords
                                              inT32 ydest,
                                              BOOL8 adjust_grey  //shift to new bpp
                                              )
{
    IMAGELINE copyline;            //copy of line
    uinT8 *copy;                   //source pointer
    inT8 shift;                    //shift factor
    inT32 pixel;                   //pixel index
    inT32 y;                       //line index
    inT32 yoffset;                 //current adjusted offset
    inT32 bytesize;                //no of bytes to copy
    inT32 srcppb;                  //pixels per byte
    BOOL8 aligned;

    if (xstart < 0 || ystart < 0 || xdest < 0 || ydest < 0) return;

    if (xext <= 0)
    {
        xext = source->xsize;        //default to all
    }
    if (xext > source->xsize - xstart)
    {
        //clip to smallest
        xext = source->xsize - xstart;
    }

    if (xext > dest->xsize - xdest)
    {
        xext = dest->xsize - xdest;
    }

    if (yext <= 0)
    {
        yext = source->ysize;        //default to all
    }

    if (yext > source->ysize - ystart)
    {
        //clip to smallest
        yext = source->ysize - ystart;
    }

    if (yext > dest->ysize - ydest)
    {
        yext = dest->ysize - ydest;
    }

    if (xext <= 0 || yext <= 0)
    {
        return;                      //nothing to do
    }

    srcppb = 8 / source->bpp;      //pixels per byte
    if (source->bpp == dest->bpp || !adjust_grey)
    {
        shift = 0;                   //no adjustment
    }
    else
    {
        shift = source->bps - dest->bps;

        if (shift < 0)
        {
            shift = -shift;            //keep positive
        }
    }

    aligned = source->bpp == dest->bpp;
    if (aligned && srcppb != 0)
    {
        aligned = xstart % srcppb == 0 && xdest % srcppb == 0 && (xext % srcppb == 0 || xdest + xext == dest->xsize);
    }

    for (y = 0; y < yext; y++)
    {
        if (ystart >= ydest)
        {
            yoffset = y;               //top down
        }
        else
        {
            yoffset = yext - y - 1;    //bottom up
        }

        source->check_legal_access (xstart, ystart + yoffset, xext);
        dest->check_legal_access (xdest, ydest + yoffset, xext);

        if (aligned)
        {
            bytesize = COMPUTE_IMAGE_XDIM (xext, source->bpp);
            //get bytes per line
            if (srcppb == 0)
            {
                //do cheap move
                memmove (dest->image + (dest->ymax - 1 - ydest - yoffset) * dest->xdim + xdest * 3, source->image + (source->ymax - 1 - ystart - yoffset) * source->xdim + xstart * 3, (unsigned) bytesize);
            }
            else
            {
                //do cheap move
                memmove (dest->image + (dest->ymax - 1 - ydest - yoffset) * dest->xdim + xdest / srcppb, source->image + (source->ymax - 1 - ystart - yoffset) * source->xdim + xstart / srcppb, (unsigned) bytesize);
            }
        }
        else
        {
            if (shift == 0)
            {
                source->fast_get_line (xstart, ystart + yoffset, xext, &copyline);
            }
            else if (source->bpp < dest->bpp)
            {
                source->get_line (xstart, ystart + yoffset, xext, &copyline, 0);
                if (source->bpp <= shift && (source->bpp == 1 || source->bpp == 4))
                {
                    if (source->bpp == 1)
                    {
                        for (pixel = 0, copy = copyline.pixels; pixel < xext; pixel++, copy++)
                        {
                            if (*copy) *copy = 0xff;
                        }
                    }
                    else
                    {
                        for (pixel = 0, copy = copyline.pixels; pixel < xext; pixel++, copy++)
                        {
                            //scale up
                            *copy = (*copy << shift) | *copy;
                        }
                    }
                }
                else
                {
                    for (pixel = 0, copy = copyline.pixels; pixel < xext; pixel++)
                    {
                        *copy++ <<= shift;     //scale up
                    }
                }
            }
            else
            {
                source->get_line (xstart, ystart + yoffset, xext, &copyline, 0);
                if (source->bpp == 24)
                {
                    for (pixel = 0, copy = copyline.pixels + 1; pixel < xext;pixel++)
                    {
                        *copy >>= shift;
                        copy += 3;
                    }
                }
                else
                {
                    for (pixel = 0, copy = copyline.pixels; pixel < xext; pixel++)
                    {
                        *copy++ >>= shift;     //scale down
                    }
                }
            }

            dest->put_line (xdest, ydest + yoffset, xext, &copyline, 0);
        }
    }
}


/**********************************************************************
 * enlarge_sub_image
 *
 * Enlarge a portion of one image to a portion of another image.
 * If the bpps are different, the position of the most significant
 * bit is preserved.
 **********************************************************************/

void enlarge_sub_image(                   //enlarge rectangle
                                                 IMAGE *source,     //source image
                                                 inT32 xstart,      //scaled start coords
                                                 inT32 ystart,
                                                 IMAGE *dest,       //destination image
                                                 inT32 xdest,       //dest coords
                                                 inT32 ydest,
                                                 inT32 xext,        //destination extent
                                                 inT32 yext,
                                                 inT32 scale,       //scale factor
                                                 BOOL8 adjust_grey  //shift to new bpp
                                                 ) {
    inT8 shift;                    //shift factor
    uinT8 pixel;                   //current pixel
    inT32 srcext;                  //source extent
    inT32 xoffset;                 //column index
    inT32 yoffset;                 //line index
    inT32 xindex, yindex;          //index in super pixel
    inT32 startxindex;             //initial x index
    inT32 xscale;                  //x scale factor
    uinT8 *src;                    //source pixels
    uinT8 *destpix;                //dest pixels
    IMAGELINE copyline;            //copy of line
    IMAGELINE bigline;             //expanded line

    if (xstart < 0 || ystart < 0 || xdest < 0 || ydest < 0) return;

    if (xext <= 0)
    {
        xext = dest->xsize;          //default to all
    }
    if (xext > source->xsize * scale - xstart)
    {
        //clip to smallest
        xext = source->xsize * scale - xstart;
    }

    if (xext > dest->xsize - xdest)
    {
        xext = dest->xsize - xdest;
    }

    if (yext <= 0)
    {
        yext = dest->ysize;          //default to all
    }

    if (yext > source->ysize * scale - ystart)
    {
        yext = source->ysize * scale - ystart;
    }

    if (yext > dest->ysize - ydest)
    {
        yext = dest->ysize - ydest;
    }

    if (xext <= 0 || yext <= 0)
    {
        return;                      //nothing to do
    }

    xindex = xstart % scale;       //offset in super pixel
    startxindex = xindex;
    yindex = ystart % scale;
    //no of source pixels
    srcext = (xext + xindex + scale - 1) / scale;
    xstart /= scale;               //actual start
    ystart /= scale;

    if (adjust_grey)
    {
        shift = dest->bps - source->bps;
    }
    else
    {
        shift = 0;                   //no adjustment
    }
    bigline.init (xext * 3);
    bigline.bpp = dest->bpp == 24 ? source->bpp : dest->bpp;

    for (yoffset = 0; yoffset < yext; ystart++)
    {
        source->check_legal_access (xstart, ystart, srcext);
        dest->check_legal_access (xdest, ydest + yoffset, xext);
        source->fast_get_line (xstart, ystart, srcext, &copyline);
        src = copyline.pixels;
        destpix = bigline.pixels;
        xscale = scale;              //enlargement factor

        if (source->bpp == 24 && dest->bpp == 24)
        {
            for (xoffset = 0, xindex = startxindex; xoffset < xext; src += source->bytespp)
            {
                xoffset += xscale - xindex;

                if (xoffset > xext)
                {
                    xscale -= xoffset - xext;
                }

                for (; xindex < xscale; xindex++)
                {
                    *destpix++ = *src;
                    *destpix++ = *(src + 1);
                    *destpix++ = *(src + 2);
                }
                xindex = 0;
            }
        }
        else
        {
            if (source->bpp == 24)
            {
                src++;
            }

            for (xoffset = 0, xindex = startxindex; xoffset < xext; src += source->bytespp)
            {
                xoffset += xscale - xindex;
                if (xoffset > xext)
                {
                    //clip to dest limit
                    xscale -= xoffset - xext;
                }

                if (shift == 0)
                {
                    pixel = *src;
                }
                else if (shift > 0)
                {
                    pixel = *src << shift;
                }
                else
                {
                    pixel = *src >> (-shift);
                }

                for (; xindex < xscale; xindex++)
                {
                    *destpix++ = pixel;    //duplicate pixel
                }

                xindex = 0;
            }
        }

        for (; yoffset < yext && yindex < scale; yindex++, yoffset++)
        {
            dest->put_line (xdest, ydest + yoffset, xext, &bigline, 0);
        }

        yindex = 0;
    }
}


/**********************************************************************
 * fast_reduce_sub_image
 *
 * Reduce a portion of one image to a portion of another image.
 * If the bpps are different, the position of the most significant
 * bit is preserved.
 * This is a fast but dirty version, which simply sub-samples.
 * It does not smooth as it reduces.
 **********************************************************************/

void fast_reduce_sub_image(                   //reduce rectangle
                                                     IMAGE *source,     //source image
                                                     inT32 xstart,      //start coords
                                                     inT32 ystart,
                                                     inT32 xext,        //extent to copy
                                                     inT32 yext,
                                                     IMAGE *dest,       //destination image
                                                     inT32 xdest,       //destination coords
                                                     inT32 ydest,
                                                     inT32 scale,       //reduction factor
                                                     BOOL8 adjust_grey  //shift to new bpp
                                                     )
{
    inT8 shift;                    //shift factor
    inT32 xfactor;                 //run on x coord
    inT32 divisor;                 //total cell area
    inT32 xindex, yindex;          //into averaging square
    inT32 xcoord;                  //current x coord
    inT32 destext;                 //destination size
    inT32 yoffset;                 //current adjusted offset
    uinT8 *pixel;                  //ptr to source pixels
    inT32 *sums;                   //ptr to sums array
    IMAGELINE copyline;            //copy of line
    inT32 *linesums;               //averaging sums

    if (xstart < 0 || ystart < 0 || xdest < 0 || ydest < 0) return;

    if (xext <= 0)
    {
        xext = source->xsize;        //default to all
    }

    if (xext > source->xsize - xstart)
    {
        //clip to smallest
        xext = source->xsize - xstart;
    }

    if (xext > (dest->xsize - xdest) * scale)
    {
        xext = (dest->xsize - xdest) * scale;
    }

    if (yext <= 0)
    {
        yext = source->ysize;        //default to all
    }

    if (yext > source->ysize - ystart)
    {
        //clip to smallest
        yext = source->ysize - ystart;
    }

    if (yext > (dest->ysize - ydest) * scale)
    {
        yext = (dest->ysize - ydest) * scale;
    }

    if (xext <= 0 || yext <= 0)
    {
        return;                      //nothing to do
    }

    xfactor = xext % scale;        //left overs
    if (xfactor == 0)  xfactor = scale;
    //destination pixels
    destext = (xext + scale - 1) / scale;
    if (adjust_grey)
    {
        //shift factor
        shift = dest->bps - source->bps;
    }
    else
    {
        shift = 0;                   //no adjustment
    }
    linesums = new inT32[destext * source->bytespp];

    for (yoffset = 0; yoffset < yext; ydest++)
    {
        source->check_legal_access (xstart, ystart + yoffset, xext);
        dest->check_legal_access (xdest, ydest, destext);

        for (xindex = destext * source->bytespp - 1; xindex >= 0; xindex--)
        {
            linesums[xindex] = 0;      //zero sums
        }

        for (yindex = 0; yindex < scale && ystart + yoffset < source->ysize; yindex += 3)
        {
            source->fast_get_line (xstart, ystart + yoffset, xext, &copyline);
            pixel = copyline.pixels;   //start of line

            if (source->bpp == 24)
            {
                for (xcoord = 1, sums = linesums; xcoord < destext; xcoord++, sums += 3)
                {
                    for (xindex = 0; xindex < scale; xindex += 2)
                    {
                        *sums += *pixel++;
                        *(sums + 1) += *pixel++;
                        *(sums + 2) += *pixel++;
                        pixel += 3;
                    }

                    if (scale & 1) pixel -= 3;          //correct position
                }

                for (xindex = 0; xindex < xfactor; xindex += 2)
                {
                    *sums += *pixel++;
                    *(sums + 1) += *pixel++;
                    *(sums + 2) += *pixel++;
                    pixel += 3;
                }
            }
            else
            {
                for (xcoord = 1, sums = linesums; xcoord < destext; xcoord++, sums++)
                {
                    for (xindex = 0; xindex < scale; xindex += 2)
                    {
                        *sums += *pixel;
                        pixel += 2;
                    }
                    if (scale & 1) pixel--;             //correct position
                }
                for (xindex = 0; xindex < xfactor; xindex += 2)
                {
                    *sums += *pixel;
                    pixel += 2;
                }
            }

            yoffset += 3;              //every 3 lines
        }

        if (yindex > scale) yoffset -= yindex - scale; //back on right scale
        copyline.init ();            //set pixels back to array
        copyline.bpp = source->bpp;
        pixel = copyline.pixels;
        //pixels in block
        divisor = ((yindex + 2) / 3) * ((scale + 1) / 2);
        if (shift <= 0)
        {
            divisor <<= (-shift);      //do greyscale correction
            for (sums = linesums, xindex = (destext - 1) * source->bytespp; xindex > 0; xindex--)
            {
                //turn to destination value
                *pixel++ = (uinT8) (*sums++ / divisor);
            }

            for (xindex = source->bytespp; xindex > 0; xindex--)
            {
                *pixel++ = *sums++ / (((yindex + 2) / 3) * ((xfactor + 1) / 2) << (-shift));
            }
            //lastone different
        }
        else
        {
            for (sums = linesums, xindex = (destext - 1) * source->bytespp; xindex > 0; xindex--)
            {
                *pixel++ = (uinT8) ((*sums++ << shift) / divisor);
            }

            //destination value
            for (xindex = source->bytespp; xindex > 0; xindex--)
            {
                //last one different
                *pixel++ = (*(sums++) << shift) / (((yindex + 2) / 3) * ((xfactor + 1) / 2));
            }
        }
        //put in destination
        dest->put_line (xdest, ydest, destext, &copyline, 0);
    }

    delete [] linesums;
}


/**********************************************************************
 * reduce_sub_image
 *
 * Reduce a portion of one image to a portion of another image.
 * If the bpps are different, the position of the most significant
 * bit is preserved.
 **********************************************************************/

void reduce_sub_image(                   //reduce rectangle
                                                IMAGE *source,     //source image
                                                inT32 xstart,      //start coords
                                                inT32 ystart,
                                                inT32 xext,        //extent to copy
                                                inT32 yext,
                                                IMAGE *dest,       //destination image
                                                inT32 xdest,       //destination coords
                                                inT32 ydest,
                                                inT32 scale,       //reduction factor
                                                BOOL8 adjust_grey  //shift to new bpp
                                                ) {
    inT8 shift;                    //shift factor
    inT32 xfactor;                 //run on x coord
    inT32 divisor;                 //total cell area
    inT32 div2;                    //total cell area divided by 2
    inT32 xindex, yindex;          //into averaging square
    inT32 xcoord;                  //current x coord
    inT32 destext;                 //destination size
    inT32 yoffset;                 //current adjusted offset
    uinT8 *pixel;                  //ptr to source pixels
    inT32 *sums;                   //ptr to sums array
    IMAGELINE copyline;            //copy of line
    inT32 *linesums;               //averaging sums

    if (xstart < 0 || ystart < 0 || xdest < 0 || ydest < 0) return;

    if (xext <= 0)
    {
        xext = source->xsize;        //default to all
    }

    if (xext > source->xsize - xstart)
    {
        //clip to smallest
        xext = source->xsize - xstart;
    }

    if (xext > (dest->xsize - xdest) * scale)
    {
        xext = (dest->xsize - xdest) * scale;
    }

    if (yext <= 0)
    {
        yext = source->ysize;        //default to all
    }

    if (yext > source->ysize - ystart)
    {
        //clip to smallest
        yext = source->ysize - ystart;
    }

    if (yext > (dest->ysize - ydest) * scale)
    {
        yext = (dest->ysize - ydest) * scale;
    }

    if (xext <= 0 || yext <= 0) return;                      //nothing to do

    xfactor = xext % scale;        //left overs
    if (xfactor == 0) xfactor = scale;
    //destination pixels
    destext = (xext + scale - 1) / scale;
    if (adjust_grey)
    {
        //shift factor
        shift = dest->bps - source->bps;
    }
    else
    {
        shift = 0;                   //no adjustment
    }
    linesums = new inT32[destext * source->bytespp];

    for (yoffset = 0; yoffset < yext; ydest++)
    {
        source->check_legal_access (xstart, ystart + yoffset, xext);
        dest->check_legal_access (xdest, ydest, destext);
        for (xindex = 0; xindex < (destext) * source->bytespp; xindex++)
        {
            linesums[xindex] = 0;      //zero sums
        }

        for (yindex = 0; yindex < scale && ystart + yoffset < source->ysize; yindex++)
        {
            source->fast_get_line (xstart, ystart + yoffset, xext, &copyline);
            pixel = copyline.pixels;   //start of line

            if (source->bpp == 24)
            {
                for (xcoord = 1, sums = linesums; xcoord < destext; xcoord++, sums += 3)
                {
                    for (xindex = 0; xindex < scale; xindex++)
                    {
                        *sums += *pixel++;
                        *(sums + 1) += *pixel++;
                        *(sums + 2) += *pixel++;
                    }
                }

                for (xindex = 0; xindex < xfactor; xindex++)
                {
                    *sums += *pixel++;
                    *(sums + 1) += *pixel++;
                    *(sums + 2) += *pixel++;
                }
            }
            else
            {
                for (xcoord = 1, sums = linesums; xcoord < destext; xcoord++, sums++)
                {
                    for (xindex = 0; xindex < scale; xindex++)
                    {
                        *sums += *pixel++;
                    }
                }

                for (xindex = 0; xindex < xfactor; xindex++)
                {
                    *sums += *pixel++;
                }
            }

            yoffset++;                 //next line
        }

        copyline.init ();            //set pixels back to array
        copyline.set_bpp (source->bpp);
        pixel = copyline.pixels;
        divisor = yindex * scale;

        if (divisor == 0)
        {
            tprintf("Impossible:divisor=0!, yindex=%d, scale=%d, yoffset=%d,yext=%d\n", yindex, scale, yoffset, yext);
            break;
        }

        if (shift <= 0)
        {
            divisor <<= (-shift);      //do greyscale correction
            div2 = divisor / 2;
            for (sums = linesums, xindex = (destext - 1) * source->bytespp; xindex > 0; xindex--)
            {
                *pixel++ = (uinT8) ((div2 + *sums++) / divisor);
            }

            //turn to destination value
            div2 = (yindex * xfactor << (-shift)) / 2;
            for (xindex = source->bytespp; xindex > 0; xindex--)
            {
                *pixel++ =(uinT8) ((div2 + *sums++) / (yindex * xfactor << (-shift)));
            }
            //lastone different
        }
        else
        {
            div2 = divisor / 2;
            for (sums = linesums, xindex = (destext - 1) * source->bytespp; xindex > 0; xindex--)
            {
                *pixel++ = (uinT8) ((div2 + (*sums++ << shift)) / divisor);
            }

            //destination value
            div2 = (yindex * xfactor) / 2;
            for (xindex = source->bytespp; xindex > 0; xindex--)
            {
                *pixel++ = (uinT8) ((div2 + (*sums++ << shift)) / (yindex * xfactor));
            }
            //last one different
        }
        //put in destination
        dest->put_line (xdest, ydest, destext, &copyline, 0);
    }
    delete [] linesums;
}


/**********************************************************************
 * invert_image
 *
 * Invert the given image (the slow way.)
 **********************************************************************/

/*invert the image */    /*image ot invert */
void invert_image(IMAGE *image)
{
    uinT8 mask;                    //bit mask
    uinT8 bytespp;                 //bytes per pixel
    inT32 xsize, ysize;            /*size of image */
    inT32 xindex, yindex;          /*index into image */
    uinT8 *pixel;                  /*current pixel */
    IMAGELINE line;                /*line of image */

    bytespp = image->get_bpp () == 24 ? 3 : 1;
    xsize = image->get_xsize ();   /*find sizes */
    ysize = image->get_ysize ();
    //pixel mask
    mask = (1 << image->get_bpp ()) - 1;
    /*do each line */
    for (yindex = ysize - 1; yindex >= 0; yindex--)
    {
        image->fast_get_line (0, yindex, xsize, &line);
        for (pixel = line.pixels, xindex = xsize * bytespp; xindex > 0; xindex--)
        {
            *pixel = (*pixel) ^ mask;  //invert image only
            ++pixel;
        }
        /*put it back */
        image->fast_put_line (0, yindex, xsize, &line);
    }
}


/**********************************************************************
 * bias_sub_image
 *
 * Add a constant to a portion of an image.
 **********************************************************************/

void bias_sub_image(                //bias rectangle
                                           IMAGE *source,  //source image
                                           inT32 xstart,   //start coords
                                           inT32 ystart,
                                           inT32 xext,     //extent to copy
                                           inT32 yext,
                                           uinT8 bias      //number to add
                                           )
{
    IMAGELINE copyline;            //copy of line
    uinT8 *copy;                   //source pointer
    inT32 pixel;                   //pixel index
    inT32 y;                       //line index
    uinT8 bytespp;                 //bytes per pixel

    if (xstart < 0 || ystart < 0) return;

    if (xext <= 0)
    {
        xext = source->get_xsize (); //default to all
    }

    if (xext > source->get_xsize () - xstart)
    {
        //clip to smallest
        xext = source->get_xsize () - xstart;
    }

    if (yext <= 0)
    {
        yext = source->get_ysize (); //default to all
    }

    if (yext > source->get_ysize () - ystart)
    {
        //clip to smallest
        yext = source->get_ysize () - ystart;
    }

    if (xext <= 0 || yext <= 0) return;                      //nothing to do

    bytespp = source->get_bpp () == 24 ? 3 : 1;
    for (y = 0; y < yext; y++)
    {
        source->check_legal_access (xstart, ystart + y, xext);
        source->fast_get_line (xstart, ystart + y, xext, &copyline);
        for (pixel = xext * bytespp, copy = copyline.pixels; pixel > 0; pixel--, copy++)
        {
            *copy += bias;               //add bias
        }

        source->fast_put_line (xstart, ystart + y, xext, &copyline);
    }
}


/**********************************************************************
 * starbase_to_normal
 *
 * Copy a portion of one image to a portion of another image.
 * This function maps the colour tables used on the screen to
 * greyscale values in the way "normally" expected.
 **********************************************************************/

void starbase_to_normal(                     //copy rectangle
                                                    IMAGE *source,       //source image
                                                    inT32 xstart,        //start coords
                                                    inT32 ystart,
                                                    inT32 xext,          //extent to copy
                                                    inT32 yext,
                                                    IMAGE *dest,         //destination image
                                                    inT32 xdest,         //destination coords
                                                    inT32 ydest,
                                                    BOOL8 preserve_grey  //shift to new bpp
                                                    )
{
    IMAGELINE copyline;            //copy of line
    uinT8 *copy;                   //source pointer
    inT8 shift4;                   //shift factor
    inT8 shift6;                   //shift factor
    inT8 colour_shift;             //shift of colours
    uinT8 white_level;             //dest white value
    inT32 pixel;                   //pixel index
    inT32 y;                       //line index
    inT32 yoffset;                 //current adjusted offset

    if (xstart < 0 || ystart < 0 || xdest < 0 || ydest < 0) return;

    if (xext <= 0)
    {
        xext = source->get_xsize (); //default to all
    }

    if (xext > source->get_xsize () - xstart)
    {
        //clip to smallest
        xext = source->get_xsize () - xstart;
    }

    if (xext > dest->get_xsize () - xdest)
    {
        xext = dest->get_xsize () - xdest;
    }

    if (yext <= 0)
    {
        yext = source->get_ysize (); //default to all
    }

    if (yext > source->get_ysize () - ystart)
    {
        //clip to smallest
        yext = source->get_ysize () - ystart;
    }

    if (yext > dest->get_ysize () - ydest)
    {
        yext = dest->get_ysize () - ydest;
    }

    if (xext <= 0 || yext <= 0) return;                      //nothing to do

    //pixels per byte
    shift4 = 4 - dest->get_bpp (); //for different bpps
    shift6 = 6 - dest->get_bpp ();
    //for grey preserve
    colour_shift = 8 - dest->get_bpp ();
    white_level = dest->get_white_level ();
    for (y = 0; y < yext; y++)
    {
        if (ystart >= ydest)
        {
            yoffset = y;               //top down
        }
        else
        {
            yoffset = yext - y - 1;    //bottom up
        }

        source->check_legal_access (xstart, ystart + yoffset, xext);
        dest->check_legal_access (xdest, ydest + yoffset, xext);
        source->get_line (xstart, ystart + yoffset, xext, &copyline, 0);

        for (pixel = 0, copy = copyline.pixels; pixel < xext; pixel++)
        {
            if (*copy < FIXED_COLOURS && preserve_grey)
            {
                *copy = grey_scales[*copy] >> colour_shift;
            }
            else if (*copy < FIXED_COLOURS)
            {
                if (*copy == BLACK_PIX)
                {
                    *copy = white_level;   //black->white
                }
                else
                {
                    *copy = 0;             //others->black
                }
            }
            else if (*copy >= MIN_4BIT && *copy < MAX_4BIT)
            {
                if (shift4 < 0)
                {
                    *copy = (*copy - MIN_4BIT) << (-shift4);
                }
                else
                {
                    *copy = (*copy - MIN_4BIT) >> shift4;
                }
            }
            else if (*copy >= MIN_6BIT && *copy < MAX_6BIT)
            {
                if (shift6 < 0)
                {
                    *copy = (*copy - MIN_6BIT) << (-shift6);
                }
                else
                {
                    *copy = (*copy - MIN_6BIT) >> shift6;
                }
            }
            else
            {
                *copy = white_level;     //white the rest
            }
            copy++;
        }

        dest->put_line (xdest, ydest + yoffset, xext, &copyline, 0);
    }
}


/**********************************************************************
 * fast_get_line
 *
 * Get a line of image into the supplied image line buffer.
 * The image is converted to 8bpp by simple assignment.
 * If the image is aleady 8 or 6bpp, no copy is done and a pointer
 * to the correct image section is put in the line buffer.
 **********************************************************************/

void IMAGE::fast_get_line(                    //get image line
                                              inT32 x,            //coord to start at
                                              inT32 y,            //line to get
                                              inT32 width,        //no of pixels to get
                                              IMAGELINE *linebuf  //line to copy to
                                              )
{
    if (width > 0 && bpp > 4)
    {
        check_legal_access(x, y, width);
        //get pointer only
        linebuf->pixels = image + xdim * (ymax - 1 - y) + x * bytespp;
    }
    else
    {
        //just copy it
        this->get_line (x, y, width, linebuf, 0);
    }
    linebuf->bpp = bpp;
}


/**********************************************************************
 * get_line
 *
 * Get a line of image into the supplied image line buffer.
 * The image is converted to 8bpp by simple assignment.
 **********************************************************************/

void IMAGE::get_line(                     //get image line
                                          inT32 x,             //coord to start at
                                          inT32 y,             //line to get
                                          inT32 width,         //no of pixels to get
                                          IMAGELINE *linebuf,  //line to copy to
                                          inT32 margins        //size of margins
                                          )
{
    uinT8 *src;                    // source pointer
    uinT8 *dest;                   // destination pointer
    const uinT8 *unpacksrc;        // unpacking pointer
    inT8 bit;                      // bit index
    inT8 pixperbyte;               // pixels per byte
    uinT8 white;                   // white colour
    inT32 pixel;                   // pixel index

    this->check_legal_access(x, y, width);
    if (width > xsize - x) width = xsize - x;           //clip to image

    width *= bytespp;
    linebuf->init(width + margins * bytespp * 2);
    linebuf->bpp = bpp;

    //start of line
    src = image + xdim * (ymax - 1 - y);
    dest = linebuf->line;          //destination line
    linebuf->pixels = dest;
    white = (1 << bpp) - 1;        //max value of pixel

    for (pixel = margins * bytespp; pixel > 0; pixel--)
    {
        *dest++ = white;             //margins are white
    }

    if (width > 0)
    {
        if (bpp > 4)
        {
            src += x;                  //offset
            //easy way
            memmove (dest, src, (unsigned) width);
        }
        else if (bpp == 4)
        {
            src += x / 2;              //offset on line
            if (x & 1)
            {
                //get coded nibble
                *dest++ = bpp4table[*src++][1];
                width--;
            }

            while (width >= 2)
            {
                //get coded bits
                unpacksrc = bpp4table[*src++];
                *dest++ = *unpacksrc++;
                *dest++ = *unpacksrc++;  //copy nibbles
                width -= 2;
            }

            if (width)
            {
                //get coded nibble
                *dest++ = bpp4table[*src++][0];
            }
        }
        else if (bpp == 2)
        {
            pixperbyte = 4;
            src += x / 4;              //offset on line
            bit = (inT8) (x % 4);      //offset in byte
            width += bit;

            while (width > 0)
            {        //until all done
                if (width < pixperbyte)
                {
                    //less on last byte
                    pixperbyte = (inT8) width;
                }

                //get coded bits
                unpacksrc = &bpp2table[*src++][bit];
                for (; bit < pixperbyte; bit++)
                {
                    *dest++ = *unpacksrc++;//copy bytes
                }

                width -= pixperbyte;
                bit = 0;
            }
        }
        else
        {
            pixperbyte = 8;
            src += x / 8;              //offset on line
            bit = (inT8)(x % 8);      //offset in byte
            width += bit;
            while (width > 0)
            {        //until all done
                if (width < pixperbyte)
                {
                    //less on last byte
                    pixperbyte = (inT8)width;
                }

                //get coded bits
                unpacksrc = &bpp1table[*src++][bit];
                for (; bit < pixperbyte; bit++)
                {
                    *dest++ = *unpacksrc++;//copy bytes
                }

                width -= pixperbyte;
                bit = 0;
            }
        }
    }

    for (pixel = margins * bytespp; pixel > 0; pixel--)
    {
        *dest++ = white;             //margins are white
    }
}


/**********************************************************************
 * get_column
 *
 * Get a column of image into the supplied image line buffer.
 * The image is converted to 8bpp by simple assignment.
 **********************************************************************/

void IMAGE::get_column(                     //get image column
                                            inT32 x,             //coord to start at
                                            inT32 y,             //line to get
                                            inT32 height,        //no of pixels to get
                                            IMAGELINE *linebuf,  //line to copy to
                                            inT32 margins        //size of margins
                                            )
{
    uinT8 *src;                    //source pointer
    uinT8 *dest;                   //destination pointer
    inT8 bit;                      //bit index
    uinT8 white;                   //white colour
    inT32 pixel;                   //pixel index

    //test coords
    this->check_legal_access (x, y, 1);

    //test coords
    this->check_legal_access (x, y + height - 1, 1);
    if (height > ysize - y)
    {
        height = ysize - y;          //clip to image
    }
    linebuf->init (height * bytespp + margins * bytespp * 2);

    //start of line
    src = image + xdim * (ymax - 1 - y);
    dest = linebuf->line;          //destination line
    linebuf->pixels = dest;
    white = (1 << bpp) - 1;        //max value of pixel

    for (pixel = margins * bytespp; pixel > 0; pixel--)
    {
        *dest++ = white;             //margins are white
    }

    if (height > 0)
    {
        if (bpp == 24)
        {
            src += x * bytespp;        //offset
            for (; height > 0; --height)
            {
                *dest++ = *src;          //copy bytes
                *dest++ = *(src + 1);
                *dest++ = *(src + 2);
                src -= xdim;
            }
        }
        else if (bpp > 4)
        {
            src += x;
            for (; height > 0; --height)
            {
                *dest++ = *src;          //copy bytes
                src -= xdim;
            }
        }
        else if (bpp == 4)
        {
            src += x / 2;              //offset on line
            if (x & 1)
            {
                for (; height > 0; --height)
                {
                    //get coded nibble
                    *dest++ = bpp4table[*src][1];
                    src -= xdim;
                }
            }
            else
            {
                for (; height > 0; --height)
                {
                    //get coded nibble
                    *dest++ = bpp4table[*src][0];
                    src -= xdim;
                }
            }
        }
        else if (bpp == 2)
        {
            src += x / 4;              //offset on line
            bit = (inT8) (x % 4);      //offset in byte
            for (; height > 0; --height)
            {
                //get coded bits
                *dest++ = bpp2table[*src][bit];
                src -= xdim;
            }
        }
        else
        {
            src += x / 8;              //offset on line
            bit = (inT8) (x % 8);      //offset in byte
            for (; height > 0; --height)
            {
                //get coded bits
                *dest++ = bpp1table[*src][bit];
                src -= xdim;
            }
        }
    }
    for (pixel = margins * bytespp; pixel > 0; pixel--)
    {
        *dest++ = white;             //margins are white
    }
}


/**********************************************************************
 * fast_put_line
 *
 * Put a line buffer back into the image.
 * If the line buffer merely points back into the image, nothing is done.
 * Otherwise, put_line is used to copy the line back.
 **********************************************************************/

void IMAGE::fast_put_line(                    //put image line
                                              inT32 x,            //coord to start at
                                              inT32 y,            //line to get
                                              inT32 width,        //no of pixels to put
                                              IMAGELINE *linebuf  //line to copy to
                                              )
{
    if (width > 0 && (bpp <= 4 || linebuf->pixels == linebuf->line))
        //just copy it
        put_line (x, y, width, linebuf, 0);
}


/**********************************************************************
 * put_line
 *
 * Put the supplied line buffer into the image.
 * The image is converted from 8bpp by simple assignment.
 **********************************************************************/

void IMAGE::put_line(                     //put image line
                                          inT32 x,             //coord to start at
                                          inT32 y,             //line to get
                                          inT32 width,         //no of pixels to get
                                          IMAGELINE *linebuf,  //line to copy to
                                          inT32 margins        //margins in buffer
                                          )
{
    uinT8 *src;                    //source pointer
    uinT8 *dest;                   //destination pointer
    inT8 bit;                      //bit index
    uinT8 pixel;                   //collected bits
    inT8 bytesperpix;              //in source

    this->check_legal_access(x, y, width);

    if (width > xsize - x)
    {
        width = xsize - x;           //clip to image
    }

    if (width <= 0) return;                      //nothing to do

    //source line
    src = linebuf->pixels + margins;

    //start of line
    dest = image + xdim * (ymax - 1 - y);

    if (linebuf->bpp == 24)
    {
        src++;
        bytesperpix = 3;
    }
    else
    {
        bytesperpix = 1;
    }

    if (bpp == 24 && linebuf->bpp == 24)
    {
        dest += x * bytespp;
        width *= bytespp;
        memmove (dest, src - 1, (unsigned) width);
    }
    else if (bpp == 24)
    {
        src--;
        dest += x * bytespp;
        while (width > 0)
        {
            pixel = *src++;
            *dest++ = pixel;
            *dest++ = pixel;
            *dest++ = pixel;
            width--;
        }
    }
    else if (bpp > 4)
    {
        dest += x;                   //offset
        if (linebuf->bpp == 24)
        {
            while (width > 0)
            {
                *dest++ = *src;
                src += 3;
                width--;
            }
        }
        else
        {
            //easy way
            memmove (dest, src, (unsigned) width);
        }
    }
    else if (bpp == 4)
    {
        dest += x / 2;               //offset on line
        if (x & 1)
        {
            *dest &= 0xf0;             //clean odd byte
            *dest++ |= *src & 0x0f;    //and copy it
            src += bytesperpix;
            width--;
        }

        while (width >= 2)
        {
            pixel = *src << 4;         //left pixel
            src += bytesperpix;
            pixel |= *src & 0x0f;      //right pixel
            src += bytesperpix;
            *dest++ = pixel;
            width -= 2;
        }

        if (width)
        {
            *dest &= 0x0f;             //clean odd byte
            *dest |= *src << 4;
        }
    }
    else if (bpp == 2)
    {
        dest += x / 4;               //offset on line
        bit = (inT8) (x % 4);        //offset in byte
        width += bit;
        pixel = *dest >> (8 - bit - bit);

        while (width >= 4)
        {         //until all done
            for (; bit < 4; bit++)
            {
                pixel <<= 2;             //make space for new one
                pixel |= *src & 3;
                src += bytesperpix;
            }
            *dest++ = pixel;           //new pixel
            width -= 4;
            bit = 0;
        }

        if (width > 0)
        {             //until all done
            for (bit = 0; bit < width; bit++)
            {
                pixel <<= 2;             //make space for new one
                pixel |= *src & 3;
                src += bytesperpix;
            }
            pixel <<= (8 - bit - bit); //shift rest

            //keep trainling bits
            pixel |= *dest & ((1 << (8 - bit - bit)) - 1);
            *dest++ = pixel;           //new pixel
        }
    }
    else
    {
        dest += x / 8;               //offset on line
        bit = (inT8) (x % 8);        //offset in byte
        width += bit;
        pixel = *dest >> (8 - bit);

        while (width >= 8)
        {         //until all done
            for (; bit < 8; bit++)
            {
                pixel <<= 1;             //make space for new one
                pixel |= *src & 1;
                src += bytesperpix;
            }
            *dest++ = pixel;           //new pixel
            width -= 8;
            bit = 0;
        }
        width -= bit;

        if (width > 0)
        {             //until all done
            while (width > 0)
            {
                pixel <<= 1;             //make space for new one
                pixel |= *src & 1;
                src += bytesperpix;
                bit++;
                width--;
            }
            pixel <<= (8 - bit);       //shift rest

            //keep trainling bits
            pixel |= *dest & ((1 << (8 - bit)) - 1);
            *dest++ = pixel;           //new pixel
        }
    }
}


/**********************************************************************
 * put_column
 *
 * Put the supplied column buffer into the image.
 * The image is converted from 8bpp by simple assignment.
 **********************************************************************/

void IMAGE::put_column(                     //put image column
                                            inT32 x,             //coord to start at
                                            inT32 y,             //line to get
                                            inT32 height,        //no of pixels to get
                                            IMAGELINE *linebuf,  //line to copy to
                                            inT32 margins        //margins in buffer
                                            )
{
    uinT8 *src;                    //source pointer
    uinT8 *dest;                   //destination pointer
    inT8 bit;                      //bit index
    uinT8 pixel;                   //collected bits
    inT8 bytesperpix;              //in source

    this->check_legal_access (x, y, 1);
    this->check_legal_access (x, y + height - 1, 1);

    if (height > ysize - y)
    {
        height = ysize - y;          //clip to image
    }

    if (height <= 0) return;                      //nothing to do
    //source line
    src = linebuf->pixels + margins;
    //start of line
    dest = image + xdim * (ymax - 1 - y);

    if (linebuf->bpp == 24)
    {
        src++;
        bytesperpix = 3;
    }
    else
    {
        bytesperpix = 1;
    }

    if (bpp == 24 && linebuf->bpp == 24)
    {
        dest += x * bytesperpix;
        src--;

        for (; height > 0; --height)
        {
            *dest = *src++;
            *(dest + 1) = *src++;
            *(dest + 2) = *src++;
            dest -= xdim;
        }
    }
    else if (bpp == 24)
    {
        src--;
        dest += x * bytesperpix;
        for (; height > 0; --height)
        {
            pixel = *src++;
            *dest = pixel;
            *(dest + 1) = pixel;
            *(dest + 2) = pixel;
            dest -= xdim;
        }
    }
    else if (bpp > 4)
    {
        dest += x;                   //offset
        for (; height > 0; --height)
        {
            *dest = *src;
            src += bytesperpix;
            dest -= xdim;
        }
    }
    else if (bpp == 4)
    {
        dest += x / 2;               //offset on line
        if (x & 1)
        {
            for (; height > 0; --height)
            {
                *dest &= 0xf0;           //clean odd byte
                *dest |= *src & 0x0f;    //and copy it
                src += bytesperpix;
                dest -= xdim;
            }
        }
        else
        {
            for (; height > 0; --height)
            {
                *dest &= 0x0f;           //clean odd byte
                *dest |= *src << 4;
                src += bytesperpix;
                dest -= xdim;
            }
        }
    }
    else if (bpp == 2)
    {
        dest += x / 4;               //offset on line
        bit = (inT8) (x % 4);        //offset in byte
        bit = 6 - bit - bit;         //bit shift
        pixel = ~(3 << bit);         //mask

        for (; height > 0; --height)
        {
            //change 2 bits
            *dest = (*dest & pixel) | ((*src & 3) << bit);
            src += bytesperpix;
            dest -= xdim;
        }
    }
    else
    {
        dest += x / 8;               //offset on line
        bit = (inT8) (x % 8);        //offset in byte
        bit = 7 - bit;
        pixel = ~(1 << bit);

        for (; height > 0; --height)
        {
            //change 1 bit
            *dest = (*dest & pixel) | ((*src & 1) << bit);
            src += bytesperpix;
            dest -= xdim;
        }
    }
}


/**********************************************************************
 * check_legal_access
 *
 * Check that x,y are within the bounds of the image.
 * Call bufread if necessary to get the image into memory.
 **********************************************************************/

void IMAGE::check_legal_access(            //check coords are legal
                                           inT32 x,    //coords to check
                                           inT32 y,
                                           inT32 xext  //xextent
                                           )
{
    if (x < 0 || x >= xsize || y < 0 || y >= ysize || x + xext > xsize)
    {
        BADIMAGECOORDS.error("IMAGE::check_legal_access", ABORT, "(%d+%d,%d)", x, xext, y);
    }

    if (y >= ymax)
    {
        BADIMAGESEEK.error("IMAGE::check_legal_access", ABORT, "(%d,%d)", x, y);
    }

    if (y < ymin)
    {
        bufread(y);  //read some more
    }
}

#ifdef HAVE_LIBLEPT
// ONLY available if you have Leptonica installed.
/**********************************************************************
 * ToPix
 *
 * Make a Pix from this image.
 **********************************************************************/
Pix* IMAGE::ToPix()
{
    int width = this->get_xsize();
    int height = this->get_ysize();
    int bpp = this->get_bpp();
    Pix* pix = pixCreate(width, height, bpp == 24 ? 32 : bpp);
    l_uint32* data = pixGetData(pix);
    IMAGELINE line;

    if (bpp == 24)
    {
        line.init(width * 3);
        line.set_bpp(24);
    }
    else
    {
        line.init(width);
    }

    switch (bpp)
    {
    case 1:
        for (int y = height - 1 ; y >= 0; --y)
        {
            this->get_line(0, y, width, &line, 0);
            for (int x = 0; x < width; ++x)
            {
                if (line.pixels[x])
                {
                    CLEAR_DATA_BIT(data, x);
                }
                else
                {
                    SET_DATA_BIT(data, x);
                }
            }
            data += pixGetWpl(pix);
        }
        break;

    case 8:
        // Greyscale just copies the bytes in the right order.
        for (int y = height - 1 ; y >= 0; --y)
        {
            this->get_line(0, y, width, &line, 0);
            for (int x = 0; x < width; ++x)
            {
                SET_DATA_BYTE(data, x, line.pixels[x]);
            }
            data += pixGetWpl(pix);
        }
        break;

    case 24:
        // Put the colors in the correct places in the line buffer.
        for (int y = height - 1 ; y >= 0; --y)
        {
            this->get_line(0, y, width, &line, 0);
            for (int x = 0; x < width; ++x, ++data)
            {
                SET_DATA_BYTE(data, COLOR_RED, line[x][RED_PIX]);
                SET_DATA_BYTE(data, COLOR_GREEN, line[x][GREEN_PIX]);
                SET_DATA_BYTE(data, COLOR_BLUE, line[x][BLUE_PIX]);
            }
        }
        break;

    default:
        tprintf("Cannot convert image to Pix with bpp = %d\n", bpp);
    }
    return pix;
}

/**********************************************************************
 * FromPix
 *
 * Copy from the given Pix into this image.
 **********************************************************************/
void IMAGE::FromPix(const Pix* src_pix)
{
    // Leptonica doesn't const its inputs, but we don't change the input.
    Pix* pix = const_cast<Pix*>(src_pix);
    Pix* destroy_this_pix = NULL;

    int depth = pixGetDepth(pix);
    if (depth > 1 && depth < 8)
        s{
            // Convert funny depths to 8 bit.
            destroy_this_pix = pixConvertTo8(pix, false);
            pix = destroy_this_pix;
            depth = pixGetDepth(pix);
        }

            int width = pixGetWidth(pix);
    int height = pixGetHeight(pix);
    const l_uint32* data = pixGetData(pix);
    this->create(width, height, depth == 32 ? 24 : depth);

    // For each line in the image, fill the IMAGELINE class and put it into the
    // destination image. Note that Tesseract stores images with the
    // bottom at y=0 and 0 is always black in grey and binary.
    IMAGELINE line;
    if (depth == 32)
    {
        line.init(width * 3);
        line.set_bpp(24);
    }
    else
    {
        line.init(width);
    }

    switch (depth)
    {
    case 1:
        // Binary images just flip the data bit.
        for (int y = height - 1 ; y >= 0; --y)
        {
            for (int x = 0; x < width; ++x)
            {
                line.pixels[x] = GET_DATA_BIT((void *)data, x) ^ 1;
            }
            this->put_line(0, y, width, &line, 0);
            data += pixGetWpl(pix);
        }
        break;

    case 8:
        // Greyscale just copies the bytes in the right order.
        for (int y = height - 1 ; y >= 0; --y)
        {
            for (int x = 0; x < width; ++x)
            {
                line.pixels[x] = GET_DATA_BYTE((void *)data, x);
            }
            this->put_line(0, y, width, &line, 0);
            data += pixGetWpl(pix);
        }
        break;

    case 32:
        // Put the colors in the correct places in the line buffer.
        for (int y = height - 1 ; y >= 0; --y)
        {
            for (int x = 0; x < width; ++x, ++data)
            {
                line[x][RED_PIX] = GET_DATA_BYTE((void *)data, COLOR_RED);
                line[x][GREEN_PIX] = GET_DATA_BYTE((void *)data, COLOR_GREEN);
                line[x][BLUE_PIX] = GET_DATA_BYTE((void *)data, COLOR_BLUE);
            }
            this->put_line(0, y, width, &line, 0);
        }
        break;

    default:
        tprintf("Cannot convert Pix to image with bpp = %d\n", depth);
    }
    if (destroy_this_pix != NULL)
        pixDestroy(&destroy_this_pix);
}
#endif  // HAVE_LIBLEPT

/*************************************************************************
 * convolver()
 *
 * Calls the specified function for each pixel in the image, passing in an m x n
 * window of the image, centred on the pixel.  The convolution function returns
 * a new value for the pixel, based on the window.
 *
 * At the edges of the image, the window is padded to white pixels.
 *************************************************************************/

void
IMAGE::convolver (               //Map fn over window
                                 inT32 win_width,                 //Window width
                                 inT32 win_height,                //Window height
                                 void (*convolve) (               //Conv Function
                                                                  uinT8 ** pixels,                 //Of window
                                                                  uinT8 bytespp,                   //1 or 3 for colour
                                                                  inT32 win_wd,                    //Window width
                                                                  inT32 win_ht,                    //Window height
                                                                  uinT8 ret_white_value,           //White value to RETURN
                                                                  uinT8 * result)                  //Ptr to result pix
                                 )
{
    IMAGELINE new_row;             //Replacement pixels
    IMAGELINE *old_rows;           //Rows being processed
    inT32 oldest_imline;           //Next imline to replace
    uinT8 **window;                //ptrs to pixel rows
    uinT8 **winmax;                //ptrs to pixel rows
    uinT8 **win;                   //ptrs to pixel rows
    inT32 current_row;             //Row being calculated
    inT32 current_col;             //Col being calculated
    inT32 row = 0;                 //Next row to get

    inT32 i, j;
    uinT8 *pix;
    uinT8 *max;
    inT32 xmargin = win_width / 2;
    inT32 ymargin = win_height / 2;
    uinT8 white = get_white_level ();
    const uinT8 max_white = 255;
    float white_scale = (float) 255 / get_white_level ();

    if (((win_width % 2) == 0) ||
            ((win_height % 2) == 0) ||
            (win_height < 3) ||
            (win_width < 3) || (win_height > ysize / 2) || (win_width > xsize / 2))
    {
        BADWINDOW.error ("IMAGE::convolver",ABORT, "(%d x %d)", win_width, win_height);
    }

    new_row.init (xsize * bytespp);
    new_row.set_bpp (bpp);
    old_rows = new IMAGELINE[win_height];
    for (i = 0; i < win_height; i++)
    {
        old_rows[i].init ((xsize + 2 * xmargin) * bytespp);
        old_rows[i].set_bpp (bpp);
    }

    window = (uinT8 **) alloc_mem (win_height * sizeof (uinT8 *));
    winmax = window + win_height;

    /* Make bottom border */
    for (oldest_imline = 0; oldest_imline < ymargin; oldest_imline++)
    {
        pix = old_rows[oldest_imline].pixels;
        max = pix + (xsize + 2 * xmargin) * bytespp;

        while (pix < max)
        {
            *pix++ = max_white;
        }
    }

    /* Initialise remaining rows but one*/
    for (; oldest_imline < win_height - 1; oldest_imline++)
    {
        get_line (0, row++, xsize, &old_rows[oldest_imline], xmargin);
        if (max_white != white)
        {
            pix = old_rows[oldest_imline].pixels;
            max = pix + (xsize + 2 * xmargin) * bytespp;
            while (pix < max)
            {
                *pix = (uinT8) (*pix * white_scale);
                ++pix;
            }
        }
    }

    /* Image Processing */

    for (current_row = 0; current_row < ysize;)
    {
        /* Get next row and re-initialise window array */
        if (row < ysize)
        {
            get_line (0, row++, xsize, &old_rows[oldest_imline], xmargin);
            if (max_white != white)
            {
                pix = old_rows[oldest_imline].pixels;
                max = pix + (xsize + 2 * xmargin) * bytespp;
                while (pix < max)
                {
                    *pix = (uinT8) (*pix * white_scale);
                    ++pix;
                }
            }
        }
        else
        {
            pix = old_rows[oldest_imline].pixels;
            max = pix + (xsize + 2 * xmargin) * bytespp;
            while (pix < max)
                *pix++ = max_white;
        }
        oldest_imline++;

        if (oldest_imline >= win_height)
        {
            oldest_imline = 0;
        }

        /* Process line */
        pix = new_row.pixels;
        for (current_col = 0; current_col < xsize;)
        {
            /* Set up window ptrs */
            if (current_col == 0)
            {
                j = oldest_imline;
                for (i = 0; i < win_height; i++)
                {
                    window[i] = old_rows[j++].pixels;
                    if (j >= win_height) j = 0;
                }
            }
            else
            {
                for (win = window; win < winmax; (*win++) += bytespp);
                //Move along rows
            }

            convolve(window, bytespp, win_width, win_height, white, pix);
            pix += bytespp;
            current_col++;
        }

        put_line (0, current_row, xsize, &new_row, 0);
        new_row.init ();
        new_row.set_bpp (bpp);
        current_row++;
    }
}
/////////////////////////////////////////////////////////////////IMAGE/////////////////////////////////////////

///////////////////////////////////////////bitstrm////////////////////////////////////////////////////////
#ifdef __MSW32__
#else
#endif

const uinT16
R_BITSTREAM::bitmasks[17] =
{
    0, 1, 3, 7, 15, 31, 63, 127, 255,
    511, 1023, 2047, 4095, 8191, 16383, 32767, 65535
};

/**********************************************************************
 * R_BITSTREAM::open
 *
 * Establish a bitstream for reading.
 **********************************************************************/

//open for read            //file to read
uinT16 R_BITSTREAM::open(int fd)
{
    bitfd = fd;
    bufsize = read (fd, (char *) bitbuf, BITBUFSIZE * sizeof (uinT8));

    //fill buffer
    if (bufsize < 0)
    {
        READFAILED.error ("R_BITSTREAM::open", TESSLOG, NULL);
        return 0;
    }

    bitword = bitbuf[0] | (bitbuf[1] << 8);
    bitindex = 2;
    bitbit = 16;

    return (uinT16) bitword;
}


/**********************************************************************
 * R_BITSTREAM::read_code
 *
 * Remove a code from the bitstream.
 **********************************************************************/

//take code out               //length of code
uinT16 R_BITSTREAM::read_code(uinT8 length)
{
    bitbit -= length;              //no of bits left
    bitword >>= length;            //remove bits
    while (bitbit < 16)
    {
        //get next byte
        bitword |= bitbuf[bitindex++] << bitbit;
        bitbit += 8;

        if (bitindex >= bufsize)
        {
            bufsize = read (bitfd, (char *) bitbuf, BITBUFSIZE * sizeof (uinT8));
            if (bufsize < 0)
            {
                READFAILED.error ("R_BITSTREAM::read_code", TESSLOG, NULL);
                return 0;
            }

            bitindex = 0;              //newly filled buffer
        }
    }

    return (uinT16) bitword;
}


/**********************************************************************
 * R_BITSTREAM::masks
 *
 * Read a code from the static member.
 **********************************************************************/

//take code out           //length of code
uinT16 R_BITSTREAM::masks(inT32 index)
{
    return bitmasks[index];
}


/**********************************************************************
 * W_BITSTREAM::open
 *
 * Establish a bitstream for writing.
 **********************************************************************/

//open for write      //file to write
void W_BITSTREAM::open(int fd)
{
    bitfd = fd;
    bitindex = 0;
    bitword = 0;
    bitbit = 0;
}


/**********************************************************************
 * W_BITSTREAM::write_code
 *
 * Add a code to the bitstream.
 **********************************************************************/

//take code out              //code to add   //length of code
inT8 W_BITSTREAM::write_code(uinT16 code,    uinT8 length)
{
    if (length == 0)
    {
        //flushing
        if (bitbit > 0)
        {
            bitbuf[bitindex++] = (uinT8) bitword; //get last byte
        }

        if ((bitindex > 0) &&(write (bitfd, (char *) bitbuf, bitindex * sizeof (uinT8)) != (inT32) (bitindex * sizeof (uinT8))))
        {
            WRITEFAILED.error ("W_BITSTREAM::write_code", TESSLOG, "Flushing");
            return -1;
        }
    }
    else
    {
        bitword |= code << bitbit;   //add new code
        bitbit += length;
        while (bitbit >= 8)
        {
            bitbuf[bitindex++] = (uinT8) bitword; //get next byte
            bitbit -= 8;
            bitword >>= 8;

            if (bitindex >= BITBUFSIZE)
            {
                if (write (bitfd, (char *) bitbuf, bitindex * sizeof (uinT8)) != (inT32) (bitindex * sizeof (uinT8)))
                {
                    WRITEFAILED.error ("W_BITSTREAM::write_code", TESSLOG, NULL);
                    return -1;
                }

                bitindex = 0;            //newly filled buffer
            }
        }
    }

    return 0;                      //success
}
///////////////////////////////////////////bitstrm////////////////////////////////////////////////////////

///////////////////////////////////////////imgtiff////////////////////////////////////////////////////////
/*
** Include automatically generated configuration file if running autoconf
*/
#ifdef HAVE_CONFIG_H
#if defined(MOTOROLA_BYTE_ORDER) || defined(WORDS_BIGENDIAN)
#define __MOTO__  // Big-endian.
#endif
#endif
#ifdef USING_GETTEXT
#define _(x) gettext(x)
#else
#define _(x) (x)
#endif

#define INTEL       0x4949
#define MOTO        0x4d4d

/*************************************************************************
 * NOTE ON BIG-ENDIAN vs LITTLE-ENDIAN
 *
 * Intel machines store numbers with LSByte in the left position.
 * Motorola	(and PA_RISC) machines use the opposite byte ordering.
 *
 * This code is written so that:
 *   a) it will compile and run on EITHER machine type   AND
 *   b) the program (on either machine) will process tiff file written in either
 *      Motorola or Intel format.
 *
 * The code is compiled with a __NATIVE__ define which is either MOTO or INTEL.
 * MOTO and INTEL are defined (above) to be the value of the first two bytes of
 * a tiff file in either format. (This identifies the filetype).
 *
 * Subsequent reads and writes normally just reverse the byte order if the
 * machine type (__NATIVE__) is not equal to the filetype determined from the
 * first two bytes of the tiff file.
 *
 * A special case is the "value" field of the tag structure. This can contain
 * EITHER a 16bit or a 32bit value. According to the "type" field. The 4 cases
 * of machine type / file type combinations need to be treated differently in
 * the case of 16 bit values
 *************************************************************************/

#define ENTRIES       19         /*no of entries */
#define START       8            /*start of tag table */

typedef struct
{
  uinT16 tag;                    //entry tag
  uinT16 type;
  uinT32 length;
  inT32 value;
} TIFFENTRY;                     //tiff tag entry

typedef struct myrational
{
  inT32 top;
  inT32 bottom;
} MYRATIONAL;                    //type 5

//statics for the run length codes
#define EOL_CODE      0x800
#define EOL_MASK      0xfff
#define EOL_LENGTH      12       //12 bits
#define SHORT_CODE_SIZE   64     //no of short codes
#define LONG_CODE_SIZE    40     //no of long codes

const uinT16 short_white_codes[SHORT_CODE_SIZE] = {
  0xac, 0x38, 0xe, 0x1, 0xd, 0x3, 0x7, 0xf,
  0x19, 0x5, 0x1c, 0x2, 0x4, 0x30, 0xb, 0x2b,
  0x15, 0x35, 0x72, 0x18, 0x8, 0x74, 0x60, 0x10,
  0xa, 0x6a, 0x64, 0x12, 0xc, 0x40, 0xc0, 0x58,
  0xd8, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x14,
  0x94, 0x54, 0xd4, 0x34, 0xb4, 0x20, 0xa0, 0x50,
  0xd0, 0x4a, 0xca, 0x2a, 0xaa, 0x24, 0xa4, 0x1a,
  0x9a, 0x5a, 0xda, 0x52, 0xd2, 0x4c, 0xcc, 0x2c
};
const uinT8 short_white_lengths[SHORT_CODE_SIZE] = {
  8, 6, 4, 4, 4, 4, 4, 4,
  5, 5, 5, 5, 6, 6, 6, 6,
  6, 6, 7, 7, 7, 7, 7, 7,
  7, 7, 7, 7, 7, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8,
  8, 8, 8, 8, 8, 8, 8, 8
};
const uinT16 short_black_codes[SHORT_CODE_SIZE] = {
  0x3b0, 0x2, 0x3, 0x1, 0x6, 0xc, 0x4, 0x18,
  0x28, 0x8, 0x10, 0x50, 0x70, 0x20, 0xe0, 0x30,
  0x3a0, 0x60, 0x40, 0x730, 0xb0, 0x1b0, 0x760, 0xa0,
  0x740, 0xc0, 0x530, 0xd30,
  0x330, 0xb30, 0x160, 0x960,
  0x560, 0xd60, 0x4b0, 0xcb0,
  0x2b0, 0xab0, 0x6b0, 0xeb0,
  0x360, 0xb60, 0x5b0, 0xdb0,
  0x2a0, 0xaa0, 0x6a0, 0xea0,
  0x260, 0xa60, 0x4a0, 0xca0,
  0x240, 0xec0, 0x1c0, 0xe40,
  0x140, 0x1a0, 0x9a0, 0xd40,
  0x340, 0x5a0, 0x660, 0xe60
};
const uinT8 short_black_lengths[SHORT_CODE_SIZE] = {
  10, 3, 2, 2, 3, 4, 4, 5,
  6, 6, 7, 7, 7, 8, 8, 9,
  10, 10, 10, 11, 11, 11, 11, 11,
  11, 11, 12, 12, 12, 12, 12, 12,
  12, 12, 12, 12, 12, 12, 12, 12,
  12, 12, 12, 12, 12, 12, 12, 12,
  12, 12, 12, 12, 12, 12, 12, 12,
  12, 12, 12, 12, 12, 12, 12, 12
};
const uinT16 long_white_codes[LONG_CODE_SIZE] = {
  0x1b, 0x9, 0x3a, 0x76, 0x6c, 0xec, 0x26, 0xa6,
  0x16, 0xe6, 0x66, 0x166, 0x96, 0x196, 0x56, 0x156,
  0xd6, 0x1d6, 0x36, 0x136, 0xb6, 0x1b6, 0x32, 0x132,
  0xb2, 0x6, 0x1b2,
  0x80, 0x180, 0x580, 0x480, 0xc80,
  0x280, 0xa80, 0x680, 0xe80, 0x380, 0xb80, 0x780, 0xf80
};
const uinT8 long_white_lengths[LONG_CODE_SIZE] = {
  5, 5, 6, 7, 8, 8, 8, 8,
  8, 8, 9, 9, 9, 9, 9, 9,
  9, 9, 9, 9, 9, 9, 9, 9,
  9, 6, 9, 11, 11, 11, 12, 12,
  12, 12, 12, 12, 12, 12, 12, 12
};
const uinT16 long_black_codes[LONG_CODE_SIZE] = {
  0x3c0, 0x130, 0x930, 0xda0,
  0xcc0, 0x2c0, 0xac0, 0x6c0,
  0x16c0, 0xa40, 0x1a40, 0x640,
  0x1640, 0x9c0, 0x19c0, 0x5c0,
  0x15c0, 0xdc0, 0x1dc0, 0x940,
  0x1940, 0x540, 0x1540, 0xb40,
  0x1b40, 0x4c0, 0x14c0,
  0x80, 0x180, 0x580, 0x480, 0xc80,
  0x280, 0xa80, 0x680, 0xe80, 0x380, 0xb80, 0x780, 0xf80
};
const uinT8 long_black_lengths[LONG_CODE_SIZE] = {
  10, 12, 12, 12, 12, 12, 12, 13,
  13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 11, 11, 11, 12, 12,
  12, 12, 12, 12, 12, 12, 12, 12
};

/**********************************************************************
 * open_tif_image
 *
 * Read the header of a tif format image and prepare to read the rest.
 **********************************************************************/

inT8 open_tif_image(               //read header
                    int fd,        //file to read
                    inT32 *xsize,  //size of image
                    inT32 *ysize,
                    inT8 *bpp,     //bits per pixel
                    inT8 *photo,   //interpretation
                    inT32 *res     //resolution
                   ) {
  inT16 filetype;
  inT32 start;                   //start of tiff directory
  inT16 entries;                 //no of tiff entries
  inT32 imagestart;              //location of image in file
  inT32 resoffset;               //location of res
  TIFFENTRY tiffentry;           //tag table entry
  BOOL8 compressed;              //compression control
  MYRATIONAL resinfo;            //resolution
  BOOL8 strips = false;          //if in strips

  *xsize = -1;                   //illegal values
  *ysize = -1;
  *bpp = -1;
  *res = -1;
  resoffset = -1;
  if (read (fd, (char *) &filetype, sizeof filetype) != sizeof filetype
  || (filetype != INTEL && filetype != MOTO)) {
    BADIMAGEFORMAT.error ("read_tif_image", TESSLOG, "Filetype");
    return -1;
  }
  lseek (fd, 4L, 0);
  if (read (fd, (char *) &start, sizeof start) != sizeof start) {
    READFAILED.error ("read_tif_image", TESSLOG, "Start of tag table");
    return -1;
  }

  if (filetype != __NATIVE__)
    start = reverse32 (start);
  if (start <= 0) {
    BADIMAGEFORMAT.error ("read_tif_image", TESSLOG, "Start of tag table");
    return -1;
  }
  lseek (fd, start, 0);
  if (read (fd, (char *) &entries, sizeof (inT16)) != sizeof (inT16)) {
    BADIMAGEFORMAT.error ("read_tif_image", TESSLOG, "Size of tag table");
    return -1;
  }
  if (filetype != __NATIVE__)
    entries = reverse16 (entries);
  //      printf("No of tiff directory entries=%d\n",entries);
  imagestart = 0;
  compressed = FALSE;
  int samples_per_pixel = 1;
  int bits_per_sample = 1;
  for (; entries-- > 0;) {
    if (read (fd, (char *) &tiffentry, sizeof tiffentry) !=
    sizeof tiffentry) {
      BADIMAGEFORMAT.error ("read_tif_image", TESSLOG, "Tag table entry");
      return -1;
    }
    if (filetype != __NATIVE__) {
      tiffentry.type = reverse16 (tiffentry.type);
      tiffentry.tag = reverse16 (tiffentry.tag);
      tiffentry.length = reverse32 (tiffentry.length);
    }
    if (tiffentry.type != 3) {   //Full 32bit value
      if (filetype != __NATIVE__)
        tiffentry.value = reverse32 (tiffentry.value);
    }
    else {
      /* A 16bit value in 4 bytes - handle with care. SEE NOTE at start of file */
      if (__NATIVE__ == MOTO) {
        if (filetype == MOTO)    //MOTO file on MOTO Machine
          tiffentry.value = tiffentry.value >> 16;
        else                     //INTEL file on MOTO Machine
          tiffentry.value = reverse32 (tiffentry.value);
      }
      else {                     //INTEL Machine
        if (filetype == MOTO)    //MOTO file on INTEL Machine
          tiffentry.value = reverse16 ((uinT16) tiffentry.value);
        //INTEL file on INTEL Machine NO ACTION NEEDED
      }
                                 //Clear top 2 MSBytes
      tiffentry.value &= 0x0000ffff;
    }

    //              printf("Tag=%x, Type=%x, Length=%x, value=%x\n",
    //                      tiffentry.tag,tiffentry.type,tiffentry.length,tiffentry.value);
    switch (tiffentry.tag) {
      case 0x101:
        *ysize = tiffentry.value;
        break;
      case 0x100:
        *xsize = tiffentry.value;
        break;
      case 0x102:
        if (tiffentry.length == 1)
          bits_per_sample = (inT8) tiffentry.value;
        else
          bits_per_sample = 8;
        break;
      case 0x115:
        samples_per_pixel = (inT8) tiffentry.value;
        break;
      case 0x111:
        imagestart = tiffentry.value;
        strips = tiffentry.length > 1;
        break;
      case 0x103:
        if (tiffentry.value == 3) {
          compressed = TRUE;
        }
        else if (tiffentry.value != 1) {
          BADIMAGEFORMAT.error ("read_tif_image", TESSLOG, "Compression");
          return -1;
        }
        break;
      case 0x11a:
      case 0x11b:
                                 //resolution
        resoffset = tiffentry.value;
        break;
      case 0x106:
        *photo = (inT8) tiffentry.value;
        break;
    }                            //endswitch
  }
  if (*xsize <= 0 || *ysize <= 0 || imagestart <= 0) {
    BADIMAGEFORMAT.error ("read_tif_image", TESSLOG, "Vital tag");
    return -1;
  }
  tprintf(_("Image has %d * %d bit%c per pixel, and size (%d,%d)\n"),
          bits_per_sample, samples_per_pixel, bits_per_sample == 1 ? ' ' : 's',
          *xsize, *ysize);
  *bpp = bits_per_sample * samples_per_pixel;
  if (resoffset >= 0) {
    lseek (fd, resoffset, 0);
    if (read (fd, (char *) &resinfo, sizeof (resinfo)) != sizeof (resinfo)) {
      READFAILED.error ("read_tif_image", TESSLOG, "Resolution");
      return -1;
    }
    if (filetype != __NATIVE__) {
      resinfo.top = reverse32 (resinfo.top);
      resinfo.bottom = reverse32 (resinfo.bottom);
    }
    *res = resinfo.top / resinfo.bottom;
    tprintf (_("Resolution=%d\n"), *res);
  }
  lseek (fd, (long) imagestart, 0);
  if (strips) {
    if (read (fd, (char *) &imagestart, sizeof (imagestart)) !=
    sizeof (imagestart)) {
      READFAILED.error ("read_tif_image", TESSLOG, "Strip offset");
      return -1;
    }
    if (filetype != __NATIVE__)
      imagestart = reverse32 (imagestart);
                                 //indirection
    lseek (fd, (long) imagestart, 0);
  }
  return compressed ? -2 : 0;
}


/**********************************************************************
 * read_tif_image
 *
 * Read a whole tif image into memory.
 **********************************************************************/

inT8 read_tif_image(int fd,         // file to read
                    uinT8 *pixels,  // pixels of image
                    inT32 xsize,    // size of image
                    inT32 ysize,
                    inT8 bpp,       // bits per pixel
                    inT32) {        // bytes per line
  inT32 xindex;                  // indices in image
  inT32 yindex;
  inT32 length;                  // short length
  inT32 biglength;               // extender
  const uinT8 *lengths;          // current lengths
  const uinT16 *codes;           // current codes
  uinT16 codeword;               // current code word
  IMAGELINE imageline;           // current line
  IMAGE image;                   // dummy image
  R_BITSTREAM bits;              // read bitstream
  uinT8 colour;                  // current colour

  image.capture(pixels, xsize, ysize, bpp);
  codeword = bits.open(fd);      // open bitstream
  read_eol(&bits, codeword);     // find end of line
  for (yindex = ysize - 1; yindex >= 0; yindex--) {
    imageline.init();
    colour = TRUE;
    for (xindex = 0; xindex < xsize;) {
      if (colour) {
        lengths = long_white_lengths;
        codes = long_white_codes;
      }
      else {
        lengths = long_black_lengths;
        codes = long_black_codes;
      }
      for (biglength = 0; biglength < LONG_CODE_SIZE
        && (codeword & bits.masks (*lengths))
        != *codes; codes++, lengths++, biglength++);
      if (biglength < LONG_CODE_SIZE) {
        codeword = bits.read_code (*lengths);
        biglength++;
        biglength *= SHORT_CODE_SIZE;
      }
      else
        biglength = 0;
      if (colour) {
        lengths = short_white_lengths;
        codes = short_white_codes;
      }
      else {
        lengths = short_black_lengths;
        codes = short_black_codes;
      }
      for (length = 0; length < SHORT_CODE_SIZE
        && (codeword & bits.masks (*lengths))
        != *codes; codes++, lengths++, length++);
      if (length < SHORT_CODE_SIZE) {
        codeword = bits.read_code (*lengths);
        for (length += biglength; length > 0; length--, xindex++)
          imageline.pixels[xindex] = colour;
        colour = !colour;
      }
      else
        break;
    }
    if (xindex < xsize) {
      tprintf (_("%d pixels short on line %d"), xsize - xindex, yindex);
      tprintf (_(", unknown code=%x\n"), codeword);
    }
    xindex = read_eol (&bits, codeword);
    if (xindex > 0)
      tprintf (_("Discarding %d bits on line %d\n"), xindex, yindex);
    image.put_line (0, yindex, xsize, &imageline, 0);
  }
  return 0;
}


/**********************************************************************
 * read_eol
 *
 * Take bits out of the stream until and end-of-line code is hit.
 **********************************************************************/

inT32 read_eol(                    //read end of line
               R_BITSTREAM *bits,  //bitstream to read
               uinT16 &code        //current code
              ) {
  BOOL8 anyones;                 //any 1 bits skipped
  inT32 bitcount;                //total bits skipped

  anyones = FALSE;
  bitcount = 0;
  while ((code & EOL_MASK) != EOL_CODE) {
    if (code & 1)
      anyones = TRUE;            //discarded one bit
    bitcount++;                  //total discarded bits
    code = bits->read_code (1);  //take single bits
  }
                                 //extract EOL code
  code = bits->read_code (EOL_LENGTH);

  if (!anyones)
    bitcount = 0;                //ignore filler bits
  return bitcount;
}


/**********************************************************************
 * write_moto_tif
 *
 * Write a whole tif format image and close the file.
 **********************************************************************/

inT8 write_moto_tif(                //write whole image
                    int fd,         //file to write on
                    uinT8 *pixels,  //image pixels
                    inT32 xsize,    //size of image
                    inT32 ysize,
                    inT8 bpp,       //bits per pixel
                    inT8 photo,
                    inT32 res       //resolution
                   ) {
  return write_tif_image (fd, pixels, xsize, ysize, bpp, res, MOTO, photo);
  //use moto format
}


/**********************************************************************
 * write_intel_tif
 *
 * Write a whole tif format image and close the file.
 **********************************************************************/

inT8 write_intel_tif(                //write whole image
                     int fd,         //file to write on
                     uinT8 *pixels,  //image pixels
                     inT32 xsize,    //size of image
                     inT32 ysize,
                     inT8 bpp,       //bits per pixel
                     inT8 photo,
                     inT32 res       //resolution
                    ) {
  return write_tif_image (fd, pixels, xsize, ysize, bpp, res, INTEL, photo);
  //use intel format
}


/**********************************************************************
 * write_inverse_tif
 *
 * Write a whole tif format image and close the file.
 **********************************************************************/

inT8 write_inverse_tif(                //write whole image
                       int fd,         //file to write on
                       uinT8 *pixels,  //image pixels
                       inT32 xsize,    //size of image
                       inT32 ysize,
                       inT8 bpp,       //bits per pixel
                       inT8 photo,
                       inT32 res       //resolution
                      ) {
  return write_tif_image (fd, pixels, xsize, ysize, bpp, res, INTEL,
    1 - photo);
  //use intel format
}


/**********************************************************************
 * write_tif_image
 *
 * Write a whole tif format image and close the file.
 **********************************************************************/

inT8 write_tif_image(                //write whole image
                     int fd,         //file to write on
                     uinT8 *pixels,  //image pixels
                     inT32 xsize,    //size of image
                     inT32 ysize,
                     inT8 bpp,       //bits per pixel
                     inT32 res,      //resolution
                     inT16 type,     //format type
                     inT16 photo     //metric interp
                    ) {
  inT32 size;                    //line/image size
  inT16 entries;                 //no of tiff entries
  inT32 start;                   //start of tag table
  inT32 zero = 0;
  MYRATIONAL resolution;         //resolution
  TIFFENTRY entry;               //current entry

  TIFFENTRY tags[ENTRIES] = {
    {0xfe, 4, 1, 0},
    {0x100, 3, 1, 0},
    {0x101, 3, 1, 0},
    {0x102, 3, 1, 0},
    {0x103, 3, 1, 1},
    {0x106, 3, 1, 1},
    {                            /*line art */
      0x107, 3, 1, 1
    },
    {0x10a, 3, 1, 1},
    {
      0x111, 4, 1, START + ENTRIES * sizeof (TIFFENTRY)
      + sizeof (inT32) + sizeof (short) + sizeof (MYRATIONAL) * 2
    }
    ,
    {0x112, 3, 1, 1}
    ,
    {0x115, 3, 1, 1}
    ,
    {0x116, 4, 1, 0}
    ,
    {0x117, 4, 1, 0}
    ,
    {0x118, 3, 1, 0}
    ,
    {0x119, 3, 1, 1}
    ,
    {
      0x11a, 5, 1, START + ENTRIES * sizeof (TIFFENTRY)
      + sizeof (inT32) + sizeof (short)
    },
    {
      0x11b, 5, 1, START + ENTRIES * sizeof (TIFFENTRY)
      + sizeof (inT32) + sizeof (short) + sizeof (MYRATIONAL)
    }
    ,
    {0x11c, 3, 1, 1}
    ,
    {0x128, 3, 1, 2}
  };

  resolution.top = res;
  resolution.bottom = 1;
  if (write (fd, (char *) &type, sizeof type) != sizeof type
  || (type != INTEL && type != MOTO)) {
    WRITEFAILED.error ("write_tif_image", TESSLOG, "Filetype");
    return -1;
  }
  start = START;
  entries = 0x002a;
  if (type != __NATIVE__)
    entries = reverse16 (entries);
  if (write (fd, (char *) &entries, sizeof entries) != sizeof entries) {
    WRITEFAILED.error ("write_tif_image", TESSLOG, "Version");
    return -1;
  }
  if (type != __NATIVE__)
    start = reverse32 (start);
  if (write (fd, (char *) &start, sizeof start) != sizeof start) {
    WRITEFAILED.error ("write_tif_image", TESSLOG, "Start");
    return -1;
  }
  lseek (fd, (long) START, 0);
  entries = ENTRIES;
  if (type != __NATIVE__)
    entries = reverse16 (entries);
  if (write (fd, (char *) &entries, sizeof entries) != sizeof entries) {
    WRITEFAILED.error ("write_tif_image", TESSLOG, "Entries");
    return -1;
  }
                                 //line length
  size = COMPUTE_IMAGE_XDIM (xsize, bpp);
  size *= ysize;                 //total image size
  tags[1].value = xsize;
  tags[2].value = ysize;
  if (bpp == 24) {
    tags[3].value = 8;
    tags[10].value = 3;
    tags[5].value = 2;
  }
  else {
    tags[3].value = bpp;
    tags[5].value = photo;
  }
  tags[11].value = ysize;
  tags[14].value = (1 << bpp) - 1;
  tags[12].value = size;
  for (entries = 0; entries < ENTRIES; entries++) {
    entry = tags[entries];       //get an entry
    /* NB Convert entry.value BEFORE converting entry.type!!! */
    if (entry.type != 3) {       //Full 32bit value
      if (type != __NATIVE__)
        entry.value = reverse32 (entry.value);
    }
    else {
      /* A 16bit value in 4 bytes - handle with care. SEE NOTE at start of file */
      entry.value &= 0x0000ffff; //Ensure top 2 MSBytes clear
      if (__NATIVE__ == MOTO) {
        if (type == MOTO)        //MOTO file on MOTO Machine
          entry.value = entry.value << 16;
        else                     //INTEL file on MOTO Machine
          entry.value = reverse32 (entry.value);
      }
      else {                     //INTEL Machine
        if (type == MOTO)        //MOTO file on INTEL Machine
          entry.value = reverse16 ((uinT16) entry.value);
        //INTEL file on INTEL Machine NO ACTION NEEDED
      }
    }
    if (type != __NATIVE__) {
      entry.tag = reverse16 (entry.tag);
      entry.type = reverse16 (entry.type);
      entry.length = reverse32 (entry.length);
    }
    if (write (fd, (char *) &entry, sizeof (TIFFENTRY)) !=
    sizeof (TIFFENTRY)) {
      WRITEFAILED.error ("write_tif_image", TESSLOG, "Tag Table");
      return -1;
    }
  }
  if (write (fd, (char *) &zero, sizeof zero) != sizeof zero) {
    WRITEFAILED.error ("write_tif_image", TESSLOG, "Tag table Terminator");
    return -1;
  }
  if (type != __NATIVE__) {
    resolution.top = reverse32 (resolution.top);
    resolution.bottom = reverse32 (resolution.bottom);
  }
  if (write (fd, (char *) &resolution, sizeof resolution) != sizeof resolution
    || write (fd, (char *) &resolution,
  sizeof resolution) != sizeof resolution) {
    WRITEFAILED.error ("write_tif_image", TESSLOG, "Resolution");
    return -1;
  }
  if (write (fd, (char *) pixels, (size_t) size) != size) {
    WRITEFAILED.error ("write_tif_image", TESSLOG, "Image");
    return -1;
  }
  close(fd);
  return 0;
}
///////////////////////////////////////////imgtiff////////////////////////////////////////////////////////

/////////////////////////////////////////////////imgbmp/////////////////////////////////////////////////
#ifdef _MSC_VER
#pragma warning(disable:4244)  // Conversion warnings
#endif

typedef struct
{                                // bmfh
  char bfType1;                  //'B'
  char bfType2;                  //'M'
} BMPHEADER0;
typedef struct
{                                // bmfh
  uinT32 bfSize;                 //filesize
  uinT16 bfReserved1;            //zero
  uinT16 bfReserved2;            //zero
  uinT32 bfOffBits;              //offset to bitmap
} BMPHEADER;

typedef struct
{                                // bmih
  uinT32 biSize;                 //size of struct
  inT32 biWidth;                 //image width
  inT32 biHeight;                //image height
  uinT16 biPlanes;               //1
  uinT16 biBitCount;             //bpp
  uinT32 biCompression;          //0 for uncompressed
  uinT32 biSizeImage;            //image size
  inT32 biXPelsPerMeter;         //res in pp metre
  inT32 biYPelsPerMeter;
  uinT32 biClrUsed;              //0 or actual size of colour table
  uinT32 biClrImportant;         //usually 0
} BMPHEADER2;

typedef struct
{                                // rgbq
  uinT8 rgbBlue;
  uinT8 rgbGreen;
  uinT8 rgbRed;
  uinT8 rgbReserved;             //0
} WIN32_RGBQUAD;

/**
 * @name open_bmp_image
 *
 * Read the header of a bmp format image and prepare to read the rest.
 */

inT8 open_bmp_image(               //read header
                    int fd,        //file to read
                    inT32 *xsize,  //size of image
                    inT32 *ysize,
                    inT8 *bpp,     //bits per pixel
                    inT8 *photo,
                    inT32 *res     //resolution
                   ) {
  uinT32 nread;                  //current bits
  BMPHEADER0 head0;              //first part of header
  BMPHEADER head1;               //first part of header
  BMPHEADER2 head2;              //first part of header

  *photo = 1;
  nread = read (fd, &head0, sizeof (head0));
  if (nread != sizeof (head0))
    return -1;
  nread = read (fd, &head1, sizeof (head1));
  if (nread != sizeof (head1))
    return -1;
  nread = read (fd, &head2, sizeof (head2));
  if (nread != sizeof (head2))
    return -1;

  if (head0.bfType1 != 'B')
    return -1;
  if (head0.bfType2 != 'M')
    return -1;
  lseek (fd, head1.bfOffBits, SEEK_SET);
  *bpp = head2.biBitCount;
  *xsize = head2.biWidth;
  *ysize = head2.biHeight;
  *res = 300;                    //make up resolution
  return -2;                     //success
}


/**
 * @name read_bmp_image
 *
 * Read a whole lz format image and close the file.
 */

inT8 read_bmp_image(                //read header
                    int fd,         //file to read
                    uinT8 *pixels,  //pixels of image
                    inT32 xsize,    //size of image
                    inT32 ysize,
                    inT8 bpp,       //bits per pixel
                    inT32           //bytes per line
                   ) {
  uinT32 bpl;                    //bytes per line
  uinT32 wpl;                    //words per line
  uinT32 nread;                  //current bits
  inT32 index;                   //to cols

  bpl = (xsize * bpp + 7) / 8;   //bytes per line
  wpl = (bpl + 3) / 4;
  wpl *= 4;
  for (index = 0; index < ysize; index++) {
    nread = read (fd, pixels + bpl * (ysize - 1 - index), bpl);
    if (nread != bpl)
      return -1;
    if (wpl != bpl)
      lseek (fd, wpl - bpl, SEEK_CUR);
  }
  return 0;
}


/**
 * @name write_bmp_image
 *
 * Write a whole lz format image and close the file.
 */

inT8 write_bmp_image(                //write whole image
                     int fd,         //file to write on
                     uinT8 *pixels,  //image pixels
                     inT32 xsize,    //size of image
                     inT32 ysize,
                     inT8 bpp,       //bits per pixel
                     inT8,
                     inT32 res       //resolution
                    ) {
  uinT32 bpl;                    //bytes per line
  uinT32 wpl;                    //words per line
  uinT32 nread;                  //current bits
  inT32 cols;                    //entries in table
  inT32 index;                   //to cols
  BMPHEADER0 head0;              //first part of header
  BMPHEADER head1;               //first part of header
  BMPHEADER2 head2;              //first part of header
  WIN32_RGBQUAD coltab[256];     //colour table

  if (bpp == 24)
    cols = 0;
  else
    cols = 1 << bpp;             //size of colour table
  bpl = (xsize * bpp + 7) / 8;   //bytes per line
  wpl = (bpl + 3) / 4;

  head2.biSize = sizeof (head2); //size of struct
  head2.biWidth = xsize;         //image width
  head2.biHeight = ysize;        //image height
  head2.biPlanes = 1;            //1
  head2.biBitCount = bpp;        //bpp
  head2.biCompression = 0;       //0 for uncompressed
                                 //image size
  head2.biSizeImage = wpl * 4 * ysize;
                                 //res in pp metre
  head2.biXPelsPerMeter = (uinT32) (res * 39.37);
  head2.biYPelsPerMeter = (uinT32) (res * 39.37);
  head2.biClrUsed = cols;        //0 or actual size of colour table
  head2.biClrImportant = 0;      //usually 0

  head0.bfType1 = 'B';
  head0.bfType2 = 'M';
  head1.bfReserved1 = 0;         //zero
  head1.bfReserved2 = 0;         //zero
                                 //offset to bitmap
  head1.bfOffBits = sizeof (head0) + sizeof (head1) + sizeof (head2) + sizeof (WIN32_RGBQUAD) * cols;
                                 //filesize
  head1.bfSize = head1.bfOffBits + head2.biSizeImage;

  for (index = 0; index < cols; index++) {
    coltab[index].rgbBlue = index * 255 / (cols - 1);
    coltab[index].rgbGreen = coltab[index].rgbBlue;
    coltab[index].rgbRed = coltab[index].rgbBlue;
    coltab[index].rgbReserved = 0;
  }

  nread = write (fd, &head0, sizeof (head0));
  if (nread != sizeof (head0))
    return -1;
  nread = write (fd, &head1, sizeof (head1));
  if (nread != sizeof (head1))
    return -1;
  nread = write (fd, &head2, sizeof (head2));
  if (nread != sizeof (head2))
    return -1;
  nread = write (fd, coltab, cols * sizeof (WIN32_RGBQUAD));
  if (nread != cols * sizeof (WIN32_RGBQUAD))
    return -1;
  for (index = 0; index < ysize; index++) {
    nread = write (fd, pixels + bpl * (ysize - 1 - index), wpl * 4);
    if (nread != wpl * 4)
      return -1;
  }
  close(fd);  //done it
  return 0;
}
/////////////////////////////////////////////////imgbmp/////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////imgio////////////////////////////////
#define DEFAULTIMAGETYPE  "tif"  //default to im files

typedef struct
{
  const char *string;            //extension
  IMAGE_OPENER opener;           //opening function
  IMAGE_READER reader;           //reading function
  IMAGE_WRITER writer;           //writing function
} IMAGETYPE;                     //image type record

static IMAGETYPE imagetypes[] = { {
    "TIF",
    open_tif_image,
    read_tif_image,
    write_moto_tif
  },
  {
    "itf",
    open_tif_image,
    read_tif_image,
    write_inverse_tif
  },
  {
    "tif",
    open_tif_image,
    read_tif_image,
    write_intel_tif
  },
  {
    "TIFF",
    open_tif_image,
    read_tif_image,
    write_moto_tif
  },
  {
    "tiff",
    open_tif_image,
    read_tif_image,
    write_intel_tif
  },
  {
    "bmp",
    open_bmp_image,
    read_bmp_image,
    write_bmp_image
  },
  {
    "BMP",
    open_bmp_image,
    read_bmp_image,
    write_bmp_image
  },
};                               //image readers/writers

#define MAXIMAGETYPES   (sizeof(imagetypes)/sizeof(IMAGETYPE))

/**********************************************************************
 * name_to_image_type
 *
 * Convert a file name to an image type, picking defaults if it is
 * has no extension, and complaining if the extension is not supported.
 **********************************************************************/

static inT8 name_to_image_type(                  //get image type
                               const char *name  //name of image
                              ) {
  const char *nametype;          //type part of name

  nametype = strrchr (name, '.');//find extension
  if (nametype != NULL)
    nametype++;                  //ptr to extension
  else
    nametype = DEFAULTIMAGETYPE; //had none

  int type = 0;
  //find type of image
  for (type = 0; type < (int)MAXIMAGETYPES && strcmp(imagetypes[type].string, nametype); type++);
  if (type >= (int)MAXIMAGETYPES)
  {
    //unrecognized type
    BADIMAGETYPE.error ("name_to_image_type", TESSLOG, name);
    return -1;
  }
  return type;
}


/**********************************************************************
 * read_header
 *
 * Read the header of an image, typed according to the extension of
 * the name.  Return is 0 for success, -1 for failure.
 **********************************************************************/

inT8 IMAGE::read_header(                  //get file header
                        const char *name  //name of image
                       ) {
  inT8 type;                     //image type

  destroy();  //destroy old image
                                 //get type
  type = name_to_image_type (name);
  if (type < 0 || imagetypes[type].opener == NULL) {
    CANTREADIMAGETYPE.error ("IMAGE::read_header", TESSLOG, name);
    return -1;                   //read not supported
  }
  #ifdef __UNIX__
  if ((fd = open (name, O_RDONLY)) < 0)
  #endif
  #if defined (__MSW32__) || defined (__MAC__)
    if ((fd = open (name, O_RDONLY | O_BINARY)) < 0)
  #endif
  {
    CANTOPENFILE.error ("IMAGE::read_header", TESSLOG, name);
    return -1;                   //failed
  }
  lineskip =
    (*imagetypes[type].opener) (fd, &xsize, &ysize, &bpp, &photo_interp,
    &res);
  if (lineskip == -1) {
                                 //get header
    bpp = 0;                     //still empty
    close(fd);
    fd = -1;
    return -1;                   //failed
  }
  if (res <= 0)
    res = image_default_resolution;
  //      fprintf(stderr,"Image size=(%d,%d), bpp=%d\n",
  //              xsize,ysize,bpp);
                                 //bytes per line
  xdim = COMPUTE_IMAGE_XDIM (xsize, bpp);
  bps = bpp == 24 ? 8 : bpp;
  bytespp = (bpp + 7) / 8;
                                 //funtion to read with
  reader = imagetypes[type].reader;
  return 0;                      //success
}


/**********************************************************************
 * read
 *
 * Read a previously opened image file into memory.
 * If buflines is 0, the whole image is read in one go.
 * If buflines>0, memory space is reserved for reading just that many
 * lines at once.
 * As soon as a request is made to get a line past the end of the buffer,
 * the buffer is re-read with a 50% overlap.
 * Backward seeks are not allowed.
 * Read returns -1 in case of failure or 0 if successful.
 **********************************************************************/

inT8 IMAGE::read(                //get rest of image
                 inT32 buflines  //size of buffer
                ) {
  inT32 row;                     //image row
  BOOL8 failed;                  //read failed

  if (fd < 0 || image != NULL)
    IMAGEUNDEFINED.error ("IMAGE::read", ABORT, NULL);

  if (buflines <= 0 || buflines > ysize || reader == NULL)
    buflines = ysize;            //default to all
  bufheight = buflines;
  image =
    (uinT8 *) alloc_big_mem ((size_t) (xdim * bufheight * sizeof (uinT8)));
  if (image == NULL) {
    MEMORY_OUT.error ("IMAGE::read", TESSLOG, NULL);
    destroy();
    return -1;
  }
  captured = FALSE;
  ymax = ysize;
  ymin = ysize - buflines;       //amount of image read
  if (reader != NULL && lineskip < 0)
    failed = (*reader) (fd, image, xsize, ysize, bpp, xdim) < 0;
  else {
    if (lineskip == 0)
      failed =::read (fd, (char *) image,
        (size_t) (xdim * bufheight)) != xdim * bufheight;
    else {
      for (failed = FALSE, row = 0; row < bufheight && !failed; row++) {
        failed =::read (fd, (char *) image + row * xdim,
          (size_t) xdim) != xdim;
        failed |= lseek (fd, lineskip, SEEK_CUR) < 0;
      }
    }
  }
  if (failed) {
    READFAILED.error ("IMAGE::read", TESSLOG, NULL);
    destroy();
    return -1;                   //read failed
  }
  if (ymin <= 0) {
    close(fd);  //finished reading
    fd = -1;                     //not open now
  }
  return 0;                      //success
}


/**********************************************************************
 * bufread
 *
 * Read a bit more of an image into the buffer.
 **********************************************************************/

inT8 IMAGE::bufread(         //read more into buffer
                    inT32 y  //required coord
                   ) {
  inT32 readtop;                 //no of lines copied
  inT32 linestoread;             //no of lines to read
  inT32 row;                     //row to read
  BOOL8 failed;                  //read failed

                                 //copy needed?
  if (y + bufheight / 2 >= ymin) {
                                 //no of lines to move
    readtop = y + bufheight / 2 - ymin + 1;
                                 //copy inside it
    copy_sub_image (this, 0, ymin, xsize, readtop, this, 0, ymax - readtop, TRUE);
  }
  else
    readtop = 0;
  ymax = y + bufheight / 2;      //new top of image
  ymin = ymax - bufheight;       //possible bottom
  if (ymin < 0)
    ymin = 0;                    //clip to image size
  linestoread = ymax - ymin - readtop;
  if (lineskip == 0)
    failed =::read (fd, (char *) (image + xdim * readtop),
      (size_t) (xdim * linestoread)) != xdim * linestoread;
  else {
    for (failed = FALSE, row = 0; row < linestoread && !failed; row++) {
      failed =::read (fd, (char *) (image + (readtop + row) * xdim),
        (size_t) xdim) != xdim;
      failed |= lseek (fd, lineskip, SEEK_CUR) < 0;
    }
  }
  if (failed) {
    READFAILED.error ("IMAGE::bufread", TESSLOG, NULL);
    return -1;                   //read failed
  }
  if (ymin <= 0) {
    close(fd);  //finished reading
    fd = -1;                     //not open now
  }
  return 0;                      //success
}


/**********************************************************************
 * write
 *
 * Write an image to a file in a format determined by the name.
 **********************************************************************/

inT8 IMAGE::write(                  //write image
                  const char *name  //name to write
                 ) {
  inT8 type;                     //type of image

  if (bpp == 0 || image == NULL || bufheight != ysize)
    IMAGEUNDEFINED.error ("IMAGE::write", ABORT, NULL);
  if (fd >= 0) {
    close(fd);  //close old file
    fd = -1;                     //no longer open
  }
                                 //get image type
  type = name_to_image_type (name);
  if (type < 0 || imagetypes[type].writer == NULL) {
    CANTWRITEIMAGETYPE.error ("IMAGE::write", TESSLOG, name);
    return -1;                   //write not supported
  }
  #ifdef __UNIX__
  if ((fd = creat (name, 0666)) < 0)
  #endif
  #ifdef __MSW32__
    if ((fd = open (name, _O_CREAT | _O_WRONLY | _O_BINARY, _S_IWRITE)) < 0)
  #endif
  #ifdef __MAC__
      if ((fd = creat (name, O_WRONLY | O_BINARY)) < 0)
  #endif
  {
    CANTCREATEFILE.error ("IMAGE::write", TESSLOG, name);
    return -1;                   //failed
  }
  if (res <= 0)
    res = image_default_resolution;
  if ((*imagetypes[type].writer) (fd, image, xsize, ysize, bpp, photo_interp,
  res) < 0) {
                                 //get header
                                 //write failed
    WRITEFAILED.error ("IMAGE::write", TESSLOG, name);
    close(fd);
    fd = -1;
    return -1;                   //failed
  }
  return 0;                      //success
}
/////////////////////////////////////////////////////////////////imgio////////////////////////////////

/////////////////////////////////////////////////////////////////OtsuThresold////////////////////////////////
// Compute the Otsu threshold(s) for the given image rectangle, making one
// for each channel. Each channel is always one byte per pixel.
// Returns an array of threshold values and an array of hi_values, such
// that a pixel value >threshold[channel] is considered foreground if
// hi_values[channel] is 0 or background if 1. A hi_value of -1 indicates
// that there is no apparent foreground. At least one hi_value will not be -1.
// Delete thresholds and hi_values with delete [] after use.
void OtsuThreshold(const unsigned char* imagedata,  int bytes_per_pixel, int bytes_per_line,
                   int left, int top, int width, int height, int** thresholds, int** hi_values)
{
  // Of all channels with no good hi_value, keep the best so we can always
  // produce at least one answer.
  int best_hi_value = 1;
  int best_hi_index = 0;
  bool any_good_hivalue = false;
  double best_hi_dist = 0.0;
  *thresholds = new int[bytes_per_pixel];
  *hi_values = new int[bytes_per_pixel];

  for (int ch = 0; ch < bytes_per_pixel; ++ch)
  {
    (*thresholds)[ch] = -1;
    (*hi_values)[ch] = -1;

    // Compute the histogram of the image rectangle.
    int histogram[kHistogramSize];
    HistogramRect(imagedata + ch, bytes_per_pixel, bytes_per_line, left, top, width, height, histogram);
    int H;
    int best_omega_0;
    int best_t = OtsuStats(histogram, &H, &best_omega_0);
    if (best_omega_0 == 0 || best_omega_0 == H)
    {
       // This channel is empty.
       continue;
    }

    // To be a convincing foreground we must have a small fraction of H
    // or to be a convincing background we must have a large fraction of H.
    // In between we assume this channel contains no thresholding information.
    int hi_value = best_omega_0 < H * 0.5;
    (*thresholds)[ch] = best_t;

    if (best_omega_0 > H * 0.75)
    {
      any_good_hivalue = true;
      (*hi_values)[ch] = 0;
    }
    else if (best_omega_0 < H * 0.25)
    {
      any_good_hivalue = true;
      (*hi_values)[ch] = 1;
    }
    else
    {
      // In case all channels are like this, keep the best of the bad lot.
      double hi_dist = hi_value ? (H - best_omega_0) : best_omega_0;

      if (hi_dist > best_hi_dist)
      {
        best_hi_dist = hi_dist;
        best_hi_value = hi_value;
        best_hi_index = ch;
      }
    }
  }

  if (!any_good_hivalue)
  {
    // Use the best of the ones that were not good enough.
    (*hi_values)[best_hi_index] = best_hi_value;
  }
}

// Compute the histogram for the given image rectangle, and the given
// channel. (Channel pointed to by imagedata.) Each channel is always
// one byte per pixel.
// Bytes per pixel is used to skip channels not being
// counted with this call in a multi-channel (pixel-major) image.
// Histogram is always a kHistogramSize(256) element array to count
// occurrences of each pixel value.
void HistogramRect(const unsigned char* imagedata, int bytes_per_pixel, int bytes_per_line, int left, int top, int width, int height, int* histogram)
{
  int bottom = top + height;
  memset(histogram, 0, sizeof(*histogram) * kHistogramSize);
  const unsigned char* pixels = imagedata + top * bytes_per_line + left * bytes_per_pixel;

  for (int y = top; y < bottom; ++y)
  {
    for (int x = 0; x < width; ++x)
    {
      ++histogram[pixels[x * bytes_per_pixel]];
    }

    pixels += bytes_per_line;
  }
}

// Compute the Otsu threshold(s) for the given histogram.
// Also returns H = total count in histogram, and
// omega0 = count of histogram below threshold.
int OtsuStats(const int* histogram, int* H_out, int* omega0_out)
{
  int H = 0;
  double mu_T = 0.0;
  for (int i = 0; i < kHistogramSize; ++i)
  {
    H += histogram[i];
    mu_T += static_cast<double>(i) * histogram[i];
  }

  // Now maximize sig_sq_B over t.
  // http://www.ctie.monash.edu.au/hargreave/Cornall_Terry_328.pdf
  int best_t = -1;
  int omega_0, omega_1;
  int best_omega_0 = 0;
  double best_sig_sq_B = 0.0;
  double mu_0, mu_1, mu_t;
  omega_0 = 0;
  mu_t = 0.0;

  for (int t = 0; t < kHistogramSize - 1; ++t)
  {
    omega_0 += histogram[t];
    mu_t += t * static_cast<double>(histogram[t]);
    if (omega_0 == 0) continue;

    omega_1 = H - omega_0;
    if (omega_1 == 0) break;

    mu_0 = mu_t / omega_0;
    mu_1 = (mu_T - mu_t) / omega_1;
    double sig_sq_B = mu_1 - mu_0;
    sig_sq_B *= sig_sq_B * omega_0 * omega_1;
    if (best_t < 0 || sig_sq_B > best_sig_sq_B)
    {
      best_sig_sq_B = sig_sq_B;
      best_t = t;
      best_omega_0 = omega_0;
    }
  }

  if (H_out != NULL) *H_out = H;
  if (omega0_out != NULL) *omega0_out = best_omega_0;
  return best_t;
}
/////////////////////////////////////////////////////////////////OtsuThresold///////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////ImageThresholder///////////////////////////////////////////////////////////
// Include automatically generated configuration file if running autoconf.
#ifdef HAVE_CONFIG_H
#endif

#ifdef HAVE_LIBLEPT
// Include leptonica library only if autoconf (or makefile etc) tell us to.
#endif
ImageThresholder::ImageThresholder()
  :
#ifdef HAVE_LIBLEPT
    pix_(NULL),
#endif
    image_data_(NULL),
    image_width_(0), image_height_(0),
    image_bytespp_(0), image_bytespl_(0)
{
  SetRectangle(0, 0, 0, 0);
}

ImageThresholder::~ImageThresholder()
{
  Clear();
}

// Destroy the Pix if there is one, freeing memory.
void ImageThresholder::Clear()
{
#ifdef HAVE_LIBLEPT
  if (pix_ != NULL)
  {
    pixDestroy(&pix_);
    pix_ = NULL;
  }
#endif
  image_data_ = NULL;
}

// Return true if no image has been set.
bool ImageThresholder::IsEmpty() const
{
#ifdef HAVE_LIBLEPT
  if (pix_ != NULL) return false;
#endif
  return image_data_ == NULL;
}

// SetImage makes a copy of only the metadata, not the underlying
// image buffer. It promises to treat the source as read-only in either case,
// but in return assumes that the Pix or image buffer remain valid
// throughout the life of the ImageThresholder.
// Greyscale of 8 and color of 24 or 32 bits per pixel may be given.
// Palette color images will not work properly and must be converted to
// 24 bit.
// Binary images of 1 bit per pixel may also be given but they must be
// byte packed with the MSB of the first byte being the first pixel, and a
// one pixel is WHITE. For binary images set bytes_per_pixel=0.
void ImageThresholder::SetImage(const unsigned char* imagedata, int width, int height, int bytes_per_pixel, int bytes_per_line)
{
#ifdef HAVE_LIBLEPT
  if (pix_ != NULL) pixDestroy(&pix_);
  pix_ = NULL;
#endif
  image_data_ = imagedata;
  image_width_ = width;
  image_height_ = height;
  image_bytespp_ = bytes_per_pixel;
  image_bytespl_ = bytes_per_line;
  Init();
}

// Store the coordinates of the rectangle to process for later use.
// Doesn't actually do any thresholding.
void ImageThresholder::SetRectangle(int left, int top, int width, int height)
{
  rect_left_ = left;
  rect_top_ = top;
  rect_width_ = width;
  rect_height_ = height;
}

// Get enough parameters to be able to rebuild bounding boxes in the
// original image (not just within the rectangle).
// Left and top are enough with top-down coordinates, but
// the height of the rectangle and the image are needed for bottom-up.
void ImageThresholder::GetImageSizes(int* left, int* top, int* width, int* height, int* imagewidth, int* imageheight)
{
  *left = rect_left_;
  *top = rect_top_;
  *width = rect_width_;
  *height = rect_height_;
  *imagewidth = image_width_;
  *imageheight = image_height_;
}

// Return true if HAVE_LIBLEPT and this thresholder implements the Pix
// interface.
bool ImageThresholder::HasThresholdToPix() const
{
#ifdef HAVE_LIBLEPT
  return true;
#else
  return false;
#endif
}

// Threshold the source image as efficiently as possible to the output
// tesseract IMAGE class.
void ImageThresholder::ThresholdToIMAGE(IMAGE* image)
{
#ifdef HAVE_LIBLEPT
  if (pix_ != NULL)
  {
    if (image_bytespp_ == 0)
    {
      // We have a binary image, so it just has to be converted.
      CopyBinaryRectPixToIMAGE(image);
    }
    else
    {
      if (image_bytespp_ == 4)
      {
        // Color data can just be passed direct.
        const uinT32* data = pixGetData(pix_);
        OtsuThresholdRectToIMAGE(reinterpret_cast<const uinT8*>(data), image_bytespp_, image_bytespl_, image);
      }
      else
      {
        // Convert 8-bit to IMAGE and then pass its
        // buffer to the raw interface to complete the conversion.
        IMAGE temp_image;
        temp_image.FromPix(pix_);
        OtsuThresholdRectToIMAGE(temp_image.get_buffer(), image_bytespp_, COMPUTE_IMAGE_XDIM(temp_image.get_xsize(), temp_image.get_bpp()), image);
      }
    }
    return;
  }
#endif
  if (image_bytespp_ > 0)
  {
    // Threshold grey or color.
    OtsuThresholdRectToIMAGE(image_data_, image_bytespp_, image_bytespl_, image);
  }
  else
  {
    CopyBinaryRectRawToIMAGE(image);
  }
}

#ifdef HAVE_LIBLEPT
// NOTE: Opposite to SetImage for raw images, SetImage for Pix clones its
// input, so the source pix may be pixDestroyed immediately after.
void ImageThresholder::SetImage(const Pix* pix)
{
  image_data_ = NULL;
  if (pix_ != NULL) pixDestroy(&pix_);
  Pix* src = const_cast<Pix*>(pix);
  int depth;
  pixGetDimensions(src, &image_width_, &image_height_, &depth);

  // Convert the image as necessary so it is one of binary, plain RGB, or
  // 8 bit with no colormap.
  if (depth > 1 && depth < 8)
  {
      pix_ = pixConvertTo8(src, false);
  }
  else if (pixGetColormap(src))
  {
    pix_ = pixRemoveColormap(src, REMOVE_CMAP_BASED_ON_SRC);
  }
  else
  {
    pix_ = pixClone(src);
  }

  depth = pixGetDepth(pix_);
  image_bytespp_ = depth / 8;
  image_bytespl_ = pixGetWpl(pix_) * sizeof(l_uint32);
  Init();
}

// Threshold the source image as efficiently as possible to the output Pix.
// Creates a Pix and sets pix to point to the resulting pointer.
// Caller must use pixDestroy to free the created Pix.
void ImageThresholder::ThresholdToPix(Pix** pix)
{
  if (pix_ != NULL)
  {
    if (image_bytespp_ == 0)
    {
      // We have a binary image, so it just has to be cloned.
      *pix = GetPixRect();
    }
    else
    {
      if (image_bytespp_ == 4)
      {
        // Color data can just be passed direct.
        const uinT32* data = pixGetData(pix_);
        OtsuThresholdRectToPix(reinterpret_cast<const uinT8*>(data), image_bytespp_, image_bytespl_, pix);
      }
      else
      {
        // Convert 8-bit to IMAGE and then pass its
        // buffer to the raw interface to complete the conversion.
        IMAGE temp_image;
        temp_image.FromPix(pix_);
        OtsuThresholdRectToPix(temp_image.get_buffer(), image_bytespp_, COMPUTE_IMAGE_XDIM(temp_image.get_xsize(), temp_image.get_bpp()), pix);
      }
    }

    return;
  }

  if (image_bytespp_ > 0)
  {
    // Threshold grey or color.
    OtsuThresholdRectToPix(image_data_, image_bytespp_, image_bytespl_, pix);
  }
  else
  {
    RawRectToPix(pix);
  }
}

// Get a clone/copy of the source image rectangle.
// The returned Pix must be pixDestroyed.
// This function will be used in the future by the page layout analysis, and
// the layout analysis that uses it will only be available with Leptonica,
// so there is no raw equivalent.
Pix* ImageThresholder::GetPixRect()
{
  if (pix_ != NULL)
  {
    if (IsFullImage())
    {
      // Just clone the whole thing.
      return pixClone(pix_);
    }
    else
    {
      // Crop to the given rectangle.
      Box* box = boxCreate(rect_left_, rect_top_, rect_width_, rect_height_);
      Pix* cropped = pixClipRectangle(pix_, box, NULL);
      boxDestroy(&box);
      return cropped;
    }
  }

  // The input is raw, so we have to make a copy of it.
  Pix* raw_pix;
  RawRectToPix(&raw_pix);
  return raw_pix;
}
#endif

// Common initialization shared between SetImage methods.
void ImageThresholder::Init()
{
  SetRectangle(0, 0, image_width_, image_height_);
}

// Otsu threshold the rectangle, taking everything except the image buffer
// pointer from the class, to the output IMAGE.
void ImageThresholder::OtsuThresholdRectToIMAGE(const unsigned char* imagedata, int bytes_per_pixel, int bytes_per_line, IMAGE* image) const
{
  int* thresholds;
  int* hi_values;
  OtsuThreshold(imagedata, bytes_per_pixel, bytes_per_line, rect_left_, rect_top_, rect_width_, rect_height_, &thresholds, &hi_values);

  // Threshold the image to the given IMAGE.
  ThresholdRectToIMAGE(imagedata, bytes_per_pixel, bytes_per_line, thresholds, hi_values, image);

  delete [] thresholds;
  delete [] hi_values;
}

// Threshold the given grey or color image into the tesseract global
// image ready for recognition. Requires thresholds and hi_value
// produced by OtsuThreshold in otsuthr.cpp.
void ImageThresholder::ThresholdRectToIMAGE(const unsigned char* imagedata, int bytes_per_pixel, int bytes_per_line,
                                            const int* thresholds, const int* hi_values, IMAGE* image) const
{
  IMAGELINE line;
  image->create(rect_width_, rect_height_, 1);
  line.init(rect_width_);

  Mat mat(rect_height_, rect_width_, CV_8UC3, Scalar(0));
  Mat mat1(rect_height_, rect_width_, CV_8UC1, Scalar(0));
  mat1.data = (uchar*)imagedata;
  imwrite("/home/osatnbzs/Desktop/bbb1.bmp", mat1);

  // For each line in the image, fill the IMAGELINE class and put it into the
  // output IMAGE. Note that Tesseract stores images with the
  // bottom at y=0 and 0 is black, so we need 2 kinds of inversion.
  const unsigned char* data = imagedata + rect_top_* bytes_per_line + rect_left_ * bytes_per_pixel;
//  for (int y = 0 ; y <= rect_height_ - 1; y++)
  for (int y = rect_height_ - 1 ; y >= 0; --y)
  {
    const unsigned char* pix = data;
    for (int x = 0; x < rect_width_; ++x, pix += bytes_per_pixel)
    {
      line.pixels[x] = 1;
      cv::line(mat, Point(x, y), Point(x, y), Scalar(255, 255, 255));
      for (int ch = 0; ch < bytes_per_pixel; ++ch)
      {
        if (hi_values[ch] >= 0 && (pix[ch] > thresholds[ch]) == (hi_values[ch] == 0))
        {
          line.pixels[x] = 0;
          cv::line(mat, Point(x, y), Point(x, y), Scalar(0, 0, 0));
          break;
        }
      }

//        //自己二值化
//        if (*pix == 255)
//        {
//            line.pixels[x] = 0;
//        }
//        else
//        {
//            line.pixels[x] = 1;
//        }
    }

    image->put_line(0, y, rect_width_, &line, 0);
    data += bytes_per_line;
  }

  imwrite("/home/osatnbzs/Desktop/bbb.bmp", mat);
}

// Cut out the requested rectangle of the binary image to the output IMAGE.
void ImageThresholder::CopyBinaryRectRawToIMAGE(IMAGE* image) const
{
  IMAGE rect_image;
  rect_image.capture(const_cast<unsigned char*>(image_data_), image_width_, rect_top_ + rect_height_, 1);
  image->create(rect_width_, rect_height_, 1);

  // copy_sub_image uses coords starting at the bottom, so the y coord of the
  // copy is the bottom of the rect_image.
  copy_sub_image(&rect_image, rect_left_, 0, rect_width_, rect_height_, image, 0, 0, false);
}

#ifdef HAVE_LIBLEPT
// Otsu threshold the rectangle, taking everything except the image buffer
// pointer from the class, to the output Pix.
void ImageThresholder::OtsuThresholdRectToPix(const unsigned char* imagedata, int bytes_per_pixel, int bytes_per_line, Pix** pix) const
{
  int* thresholds;
  int* hi_values;
  OtsuThreshold(imagedata, bytes_per_pixel, bytes_per_line, rect_left_, rect_top_, rect_width_, rect_height_, &thresholds, &hi_values);

  // Threshold the image to the given IMAGE.
  ThresholdRectToPix(imagedata, bytes_per_pixel, bytes_per_line, thresholds, hi_values, pix);

  delete [] thresholds;
  delete [] hi_values;
}

// Threshold the rectangle, taking everything except the image buffer pointer
// from the class, using thresholds/hi_values to the output IMAGE.
void ImageThresholder::ThresholdRectToPix(const unsigned char* imagedata, int bytes_per_pixel,
                                          int bytes_per_line, const int* thresholds, const int* hi_values, Pix** pix) const
{
  *pix = pixCreate(rect_width_, rect_height_, 1);
  uinT32* pixdata = pixGetData(*pix);
  int wpl = pixGetWpl(*pix);
  const unsigned char* srcdata = imagedata + rect_top_* bytes_per_line + rect_left_ * bytes_per_pixel;

  for (int y = 0; y < rect_height_; ++y)
  {
    const uinT8* linedata = srcdata;
    uinT32* pixline = pixdata + y * wpl;
    for (int x = 0; x < rect_width_; ++x, linedata += bytes_per_pixel)
    {
      bool white_result = true;
      for (int ch = 0; ch < bytes_per_pixel; ++ch)
      {
        if (hi_values[ch] >= 0 && (linedata[ch] > thresholds[ch]) == (hi_values[ch] == 0))
        {
          white_result = false;
          break;
        }
      }

      if (white_result)
      {
        CLEAR_DATA_BIT(pixline, x);
      }
      else
      {
        SET_DATA_BIT(pixline, x);
      }
    }
    srcdata += bytes_per_line;
  }
}

// Copy the raw image rectangle, taking all data from the class, to the Pix.
void ImageThresholder::RawRectToPix(Pix** pix) const\
{
  if (image_bytespp_ < 4)
  {
    // Go via a tesseract image structure (doesn't copy the data)
    // and use ToPix.
    IMAGE image;
    int bits_per_pixel = image_bytespp_ * 8;
    if (image_bytespp_ == 0) bits_per_pixel = 1;
    image.capture(const_cast<uinT8*>(image_data_), image_width_, rect_top_ + rect_height_, bits_per_pixel);

    if (IsFullImage())
    {
      *pix = image.ToPix();
    }
    else
    {
      IMAGE rect;
      rect.create(rect_width_, rect_height_, bits_per_pixel);

      // The capture chopped the image off at top+height, so copy
      // the rectangle with y = 0 to get a rectangle of height
      // starting at the bottom, since copy_sub_image uses bottom-up coords.
      copy_sub_image(&image, rect_left_, 0, rect_width_, rect_height_, &rect, 0, 0, true);
      *pix = rect.ToPix();
    }
  }
  else
  {
    *pix = pixCreate(rect_width_, rect_height_, 32);
    uinT32* data = pixGetData(*pix);
    int wpl = pixGetWpl(*pix);
    const uinT8* imagedata = image_data_ + rect_top_ * image_bytespl_ + rect_left_ * image_bytespp_;

    for (int y = 0; y < rect_height_; ++y)
    {
      const uinT8* linedata = imagedata;
      uinT32* line = data + y * wpl;

      for (int x = 0; x < rect_width_; ++x)
      {
        line[x] = (linedata[0] << 24) | (linedata[1] << 16) | (linedata[2] << 8) | linedata[3];
        linedata += 4;
      }

      imagedata += image_bytespl_;
    }
  }
}

// Cut out the requested rectangle of the binary image to the output IMAGE.
void ImageThresholder::CopyBinaryRectPixToIMAGE(IMAGE* image) const
{
  if (IsFullImage())
  {
    // Just poke it directly into the tess image.
    image->FromPix(pix_);
  }
  else
  {
    // Crop to the given rectangle.
    Box* box = boxCreate(rect_left_, rect_top_, rect_width_, rect_height_);
    Pix* cropped = pixClipRectangle(pix_, box, NULL);
    image->FromPix(cropped);
    pixDestroy(&cropped);
    boxDestroy(&box);
  }
}
#endif
/////////////////////////////////////////////////////////////////ImageThresholder///////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////ccutil////////////////////////////////////////
CCUtil::CCUtil()
    : //// mainblk.* /////////////////////////////////////////////////////
      BOOL_MEMBER(m_print_variables, FALSE,
                  "Print initial values of all variables"),
      STRING_MEMBER(m_data_sub_dir,
                  "tessdata/", "Directory for data files")
      ////////////////////////////////////////////////////////////////////
      {

}

CCUtil::~CCUtil() {
}


CCUtilMutex::CCUtilMutex() {
#ifdef WIN32
  mutex_ = CreateMutex(0, FALSE, 0);
#else
  pthread_mutex_init(&mutex_, NULL);
#endif
}

void CCUtilMutex::Lock() {
#ifdef WIN32
  WaitForSingleObject(mutex_, INFINITE);
#else
  pthread_mutex_lock(&mutex_);
#endif
}

void CCUtilMutex::Unlock() {
#ifdef WIN32
  ReleaseMutex(mutex_);
#else
  pthread_mutex_unlock(&mutex_);
#endif
}


CCUtilMutex tprintfMutex;
/////////////////////////////////////////////////////////////////ccutil////////////////////////////////////////

/////////////////////////////////////////////////////////////////cutil_class////////////////////////////////////////
CUtil::CUtil() {
}

CUtil::~CUtil() {
}
/////////////////////////////////////////////////////////////////cutil_class////////////////////////////////////////

/////////////////////////////////////////////////////////////////ccstruct////////////////////////////////////////
CCStruct::CCStruct()
  : image_(this) {
}

CCStruct::~CCStruct() {
}
/////////////////////////////////////////////////////////////////ccstruct////////////////////////////////////////

/////////////////////////////////////////////////////////////////trie////////////////////////////////////////
bool Trie::edge_char_of(NODE_REF node_ref, NODE_REF next_node,
                        int direction, bool word_end, UNICHAR_ID unichar_id,
                        EDGE_RECORD **edge_ptr, EDGE_INDEX *edge_index) const {
  if (dawg_debug_level == 3) {
    tprintf("edge_char_of() given node_ref " REFFORMAT " next_node " REFFORMAT
            " direction %d word_end %d unichar_id %d, exploring node:\n",
            node_ref, next_node, direction, word_end, unichar_id);
    if (node_ref != NO_EDGE) {
      print_node(node_ref, nodes_[node_ref]->forward_edges.size());
    }
  }
  if (node_ref == NO_EDGE) return false;
  assert(node_ref < nodes_.size());
  EDGE_VECTOR &vec = (direction == FORWARD_EDGE) ?
    nodes_[node_ref]->forward_edges : nodes_[node_ref]->backward_edges;
  int vec_size = vec.size();
  if (node_ref == 0) { // binary search
    EDGE_INDEX start = 0;
    EDGE_INDEX end = vec_size - 1;
    EDGE_INDEX k;
    int compare;
    while (start <= end) {
      k = (start + end) >> 1;  // (start + end) / 2
      compare = given_greater_than_edge_rec(next_node, word_end,
                                            unichar_id, vec[k]);
      if (compare == 0) {  // given == vec[k]
        *edge_ptr = &(vec[k]);
        *edge_index = k;
        return true;
      } else if (compare == 1) {  // given > vec[k]
        start = k + 1;
      } else {  // given < vec[k]
        end = k - 1;
      }
    }
  } else {  // linear search
    for (int i = 0; i < vec_size; ++i) {
      EDGE_RECORD &edge_rec = vec[i];
      if (edge_rec_match(next_node, word_end, unichar_id,
                         next_node_from_edge_rec(edge_rec),
                         end_of_word_from_edge_rec(edge_rec),
                         unichar_id_from_edge_rec(edge_rec))) {
        *edge_ptr = &(edge_rec);
        *edge_index = i;
        return true;
      }
    }
  }
  return false;  // not found
}

bool Trie::add_edge_linkage(NODE_REF node1, NODE_REF node2, int direction,
                            bool word_end, UNICHAR_ID unichar_id) {
  if (num_edges_ == max_num_edges_) return false;
  EDGE_VECTOR *vec = (direction == FORWARD_EDGE) ?
    &(nodes_[node1]->forward_edges) : &(nodes_[node1]->backward_edges);
  int search_index;
  if (node1 == 0) {
    search_index = 0;  // find the index to make the add sorted
    while (search_index < vec->size() &&
           given_greater_than_edge_rec(node2, word_end, unichar_id,
                                       (*vec)[search_index]) == 1) {
      search_index++;
    }
  } else {
    search_index = vec->size();  // add is unsorted, so index does not matter
  }
  EDGE_RECORD edge_rec;
  link_edge(&edge_rec, node2, direction, word_end, unichar_id);
  if (search_index < vec->size()) {
    vec->insert(edge_rec, search_index);
  } else {
    vec->push_back(edge_rec);
  }
  if (dawg_debug_level > 1) {
    tprintf("new edge in nodes_[" REFFORMAT "]: ", node1);
    print_edge_rec(edge_rec);
    tprintf("\n");
  }
  num_edges_++;
  return true;
}

void Trie::add_word_ending(EDGE_RECORD *edge_ptr,
                           NODE_REF the_next_node,
                           UNICHAR_ID unichar_id) {
  EDGE_RECORD *back_edge_ptr;
  EDGE_INDEX back_edge_index;
  ASSERT_HOST(edge_char_of(the_next_node, NO_EDGE, BACKWARD_EDGE, false,
                           unichar_id, &back_edge_ptr, &back_edge_index));
  // Mark both directions as end of word.
  *back_edge_ptr |= (WERD_END_FLAG << flag_start_bit_);
  *edge_ptr |= (WERD_END_FLAG << flag_start_bit_);
}

void Trie::add_word_to_dawg(const WERD_CHOICE &word) {
  if (word.length() <= 0) return;  // can't add empty words

  EDGE_RECORD *edge_ptr;
  NODE_REF last_node = 0;
  NODE_REF the_next_node;
  EDGE_INDEX edge_index;
  int i;
  inT32 still_finding_chars = true;
  inT32 word_end = false;
  bool  add_failed = false;
  bool found;

  if (dawg_debug_level > 1) word.print("\nAdding word: ");

  UNICHAR_ID unichar_id;
  for (i = 0; i < word.length() - 1; ++i) {
    unichar_id = word.unichar_id(i);
    if (dawg_debug_level > 1) tprintf("Adding letter %d\n", unichar_id);
    if (still_finding_chars) {
      found = edge_char_of(last_node, NO_EDGE, FORWARD_EDGE, word_end,
                           unichar_id, &edge_ptr, &edge_index);
      if (found && dawg_debug_level > 1) {
        tprintf("exploring edge " REFFORMAT " in node " REFFORMAT "\n",
                edge_index, last_node);
      }
      if (!found) {
        still_finding_chars = false;
      } else if (next_node_from_edge_rec(*edge_ptr) == 0) {
        word_end = true;
        still_finding_chars = false;
        remove_edge(last_node, 0, word_end, unichar_id);
      } else {
        last_node = next_node_from_edge_rec(*edge_ptr);
      }
    }
    if (!still_finding_chars) {
      the_next_node = new_dawg_node();
      if (dawg_debug_level > 1)
        tprintf("adding node " REFFORMAT "\n", the_next_node);
      if (the_next_node == 0) {
        add_failed = true;
        break;
      }
      if (!add_new_edge(last_node, the_next_node, word_end, unichar_id)) {
        add_failed = true;
        break;
      }
      word_end = false;
      last_node = the_next_node;
    }
  }
  the_next_node = 0;
  unichar_id = word.unichar_id(i);
  if (dawg_debug_level > 1) tprintf("Adding letter %d\n", unichar_id);
  if (still_finding_chars &&
      edge_char_of(last_node, NO_EDGE, FORWARD_EDGE, false,
                   unichar_id, &edge_ptr, &edge_index)) {
    // An extension of this word already exists in the trie, so we
    // only have to add the ending flags in both directions.
    add_word_ending(edge_ptr, next_node_from_edge_rec(*edge_ptr), unichar_id);
  } else {
    if (!add_failed &&
        !add_new_edge(last_node, the_next_node, true, unichar_id))
      add_failed = true;
  }
  if (add_failed) {
    tprintf("Re-initializing document dictionary...\n");
    nodes_.delete_data_pointers();
    num_edges_ = 0;
    new_dawg_node();  // need to allocate node 0
  }
}

NODE_REF Trie::new_dawg_node() {
  TRIE_NODE_RECORD *node = new TRIE_NODE_RECORD();
  if (node == NULL) return 0;  // failed to create new node
  nodes_.push_back(node);
  return nodes_.length() - 1;
}

bool Trie::read_word_list(const char *filename,
                          const UNICHARSET &unicharset) {
  FILE *word_file;
  char string [CHARS_PER_LINE];
  int  word_count = 0;

  word_file = open_file (filename, "r");

  while (fgets(string, CHARS_PER_LINE, word_file) != NULL) {
    chomp_string(string);  // remove newline
    WERD_CHOICE word(string, unicharset);
    ++word_count;
    if (dawg_debug_level && word_count % 10000 == 0)
      tprintf("Read %d words so far\n", word_count);
    if (word.length() != 0 && !word.contains_unichar_id(INVALID_UNICHAR_ID)) {
      if (!this->word_in_dawg(word)) {
        this->add_word_to_dawg(word);
        if (!this->word_in_dawg(word)) {
          tprintf("Error: word '%s' not in DAWG after adding it\n", string);
          return false;
        }
      }
    } else if (dawg_debug_level) {
      tprintf("Skipping invalid word %s\n", string);
      if (dawg_debug_level >= 3) word.print();
    }
  }
  if (dawg_debug_level)
    tprintf("Read %d words total.\n", word_count);
  fclose(word_file);
  return true;
}

void Trie::remove_edge_linkage(NODE_REF node1, NODE_REF node2, int direction,
                               bool word_end, UNICHAR_ID unichar_id) {
  EDGE_RECORD *edge_ptr;
  EDGE_INDEX edge_index;
  ASSERT_HOST(edge_char_of(node1, node2, direction, word_end,
                           unichar_id, &edge_ptr, &edge_index));
  if (dawg_debug_level > 1) {
    tprintf("removed edge in nodes_[" REFFORMAT "]: ", node1);
    print_edge_rec(*edge_ptr);
    tprintf("\n");
  }
  if (direction == FORWARD_EDGE) {
    nodes_[node1]->forward_edges.remove(edge_index);
  } else {
    nodes_[node1]->backward_edges.remove(edge_index);
  }
  --num_edges_;
}

SquishedDawg *Trie::trie_to_dawg() {
  if (dawg_debug_level > 2) {
    print_all("Before reduction:", MAX_NODE_EDGES_DISPLAY);
  }
  NODE_MARKER reduced_nodes = new bool[nodes_.size()];
  for (int i = 0; i < nodes_.size(); i++) reduced_nodes[i] = 0;
  this->reduce_node_input(0, reduced_nodes);
  delete[] reduced_nodes;

  if (dawg_debug_level > 2) {
    print_all("After reduction:", MAX_NODE_EDGES_DISPLAY);
  }
  // Build a translation map from node indices in nodes_ vector to
  // their target indices in EDGE_ARRAY.
  NODE_REF *node_ref_map = new NODE_REF[nodes_.size() + 1];
  int i, j;
  node_ref_map[0] = 0;
  for (i = 0; i < nodes_.size(); ++i) {
    node_ref_map[i+1] = node_ref_map[i] + nodes_[i]->forward_edges.size();
  }
  int num_forward_edges = node_ref_map[i];

  // Convert nodes_ vector into EDGE_ARRAY translating the next node references
  // in edges using node_ref_map. Empty nodes and backward edges are dropped.
  EDGE_ARRAY edge_array =
    (EDGE_ARRAY)memalloc(num_forward_edges * sizeof(EDGE_RECORD));
  EDGE_ARRAY edge_array_ptr = edge_array;
  for (i = 0; i < nodes_.size(); ++i) {
    TRIE_NODE_RECORD *node_ptr = nodes_[i];
    int end = node_ptr->forward_edges.size();
    for (j = 0; j < end; ++j) {
      EDGE_RECORD &edge_rec = node_ptr->forward_edges[j];
      NODE_REF node_ref = next_node_from_edge_rec(edge_rec);
      ASSERT_HOST(node_ref < nodes_.size());
      UNICHAR_ID unichar_id = unichar_id_from_edge_rec(edge_rec);
      link_edge(edge_array_ptr, node_ref_map[node_ref], FORWARD_EDGE,
                end_of_word_from_edge_rec(edge_rec), unichar_id);
      if (j == end - 1) set_last_flag_in_edge_rec(edge_array_ptr);
      ++edge_array_ptr;
    }
  }
  delete[] node_ref_map;

  return new SquishedDawg(edge_array, num_forward_edges,
                          type_, lang_, perm_, unicharset_size_);
}

bool Trie::eliminate_redundant_edges(NODE_REF node,
                                     const EDGE_RECORD &edge1,
                                     const EDGE_RECORD &edge2) {
  if (dawg_debug_level > 1) {
    tprintf("\nCollapsing node %d:\n", node);
    print_node(node, MAX_NODE_EDGES_DISPLAY);
    tprintf("Candidate edges: ");
    print_edge_rec(edge1);
    tprintf(", ");
    print_edge_rec(edge2);
    tprintf("\n\n");
  }
  NODE_REF next_node1 = next_node_from_edge_rec(edge1);
  NODE_REF next_node2 = next_node_from_edge_rec(edge2);
  TRIE_NODE_RECORD *next_node2_ptr = nodes_[next_node2];
  // Translate all edges going to/from next_node2 to go to/from next_node1.
  EDGE_RECORD *edge_ptr;
  EDGE_INDEX edge_index;
  int i;
  // Remove the backward link in node to next_node2.
  const EDGE_RECORD &fwd_edge = next_node2_ptr->forward_edges[0];
  remove_edge_linkage(node, next_node2, BACKWARD_EDGE,
                      end_of_word_from_edge_rec(fwd_edge),
                      unichar_id_from_edge_rec(fwd_edge));
  // Copy all the backward links in next_node2 to node next_node1
  for (i = 0; i < next_node2_ptr->backward_edges.size(); ++i) {
    const EDGE_RECORD &bkw_edge = next_node2_ptr->backward_edges[i];
    NODE_REF curr_next_node = next_node_from_edge_rec(bkw_edge);
    UNICHAR_ID curr_unichar_id = unichar_id_from_edge_rec(bkw_edge);
    int curr_word_end = end_of_word_from_edge_rec(bkw_edge);
    add_edge_linkage(next_node1, curr_next_node, BACKWARD_EDGE,
                     curr_word_end, curr_unichar_id);
    // Relocate the corresponding forward edge in curr_next_node
    ASSERT_HOST(edge_char_of(curr_next_node, next_node2, FORWARD_EDGE,
                             curr_word_end, curr_unichar_id,
                             &edge_ptr, &edge_index));
    set_next_node_in_edge_rec(edge_ptr, next_node1);
  }
  int next_node2_num_edges = (next_node2_ptr->forward_edges.size() +
                              next_node2_ptr->backward_edges.size());
  if (dawg_debug_level > 1) {
    tprintf("removed %d edges from node " REFFORMAT "\n",
            next_node2_num_edges, next_node2);
  }
  next_node2_ptr->forward_edges.clear();
  next_node2_ptr->backward_edges.clear();
  num_edges_ -= next_node2_num_edges;
  return true;
}

bool Trie::reduce_lettered_edges(EDGE_INDEX edge_index,
                                 UNICHAR_ID unichar_id,
                                 NODE_REF node,
                                 const EDGE_VECTOR &backward_edges,
                                 NODE_MARKER reduced_nodes) {
  if (dawg_debug_level > 1)
    tprintf("reduce_lettered_edges(edge=" REFFORMAT ")\n", edge_index);
  // Compare each of the edge pairs with the given unichar_id.
  bool did_something = false;
  for (int i = edge_index; i < backward_edges.size() - 1; ++i) {
    // Find the first edge that can be eliminated.
    UNICHAR_ID curr_unichar_id = INVALID_UNICHAR_ID;
    while (i < backward_edges.size() &&
           ((curr_unichar_id = unichar_id_from_edge_rec(backward_edges[i])) ==
            unichar_id) &&
           !can_be_eliminated(backward_edges[i])) ++i;
    if (i == backward_edges.size() || curr_unichar_id != unichar_id) break;
    const EDGE_RECORD &edge_rec = backward_edges[i];
    // Compare it to the rest of the edges with the given unichar_id.
    for (int j = i + 1; j < backward_edges.size(); ++j) {
      const EDGE_RECORD &next_edge_rec = backward_edges[j];
      if (unichar_id_from_edge_rec(next_edge_rec) != unichar_id) break;
      if (end_of_word_from_edge_rec(next_edge_rec) ==
          end_of_word_from_edge_rec(edge_rec) &&
          can_be_eliminated(next_edge_rec) &&
          eliminate_redundant_edges(node, edge_rec, next_edge_rec)) {
        reduced_nodes[next_node_from_edge_rec(edge_rec)] = 0;
        did_something = true;
        --j;  // do not increment j if next_edge_rec was removed
      }
    }
  }
  return did_something;
}

void Trie::sort_edges(EDGE_VECTOR *edges) {
  int num_edges = edges->size();
  if (num_edges <= 1) return;
  for (int i = 0; i < num_edges - 1; ++i) {
    int min = i;
    for (int j = (i + 1); j < num_edges; ++j) {
      if (unichar_id_from_edge_rec((*edges)[j]) <
          unichar_id_from_edge_rec((*edges)[min])) min = j;
    }
    if (i != min) {
      EDGE_RECORD temp = (*edges)[i];
      (*edges)[i] = (*edges)[min];
      (*edges)[min] = temp;
    }
  }
}

void Trie::reduce_node_input(NODE_REF node,
                             NODE_MARKER reduced_nodes) {
  if (dawg_debug_level > 1) {
    tprintf("reduce_node_input(node=" REFFORMAT ")\n", node);
    print_node(node, MAX_NODE_EDGES_DISPLAY);
  }

  EDGE_VECTOR &backward_edges = nodes_[node]->backward_edges;
  if (node != 0) sort_edges(&backward_edges);
  EDGE_INDEX edge_index = 0;
  while (edge_index < backward_edges.size()) {
    UNICHAR_ID unichar_id =
      unichar_id_from_edge_rec(backward_edges[edge_index]);
    while (reduce_lettered_edges(edge_index, unichar_id, node,
                                 backward_edges, reduced_nodes));
    while (++edge_index < backward_edges.size() &&
           unichar_id_from_edge_rec(backward_edges[edge_index]) == unichar_id);
  }
  reduced_nodes[node] = true;  // mark as reduced

  if (dawg_debug_level > 1) {
    tprintf("Node " REFFORMAT " after reduction:\n", node);
    print_node(node, MAX_NODE_EDGES_DISPLAY);
  }

  for (int i = 0; i < backward_edges.size(); ++i) {
    NODE_REF next_node = next_node_from_edge_rec(backward_edges[i]);
    if (next_node != 0 && !reduced_nodes[next_node]) {
      reduce_node_input(next_node, reduced_nodes);
    }
  }
}

void Trie::print_node(NODE_REF node, int max_num_edges) const {
  if (node == NO_EDGE) return;  // nothing to print
  TRIE_NODE_RECORD *node_ptr = nodes_[node];
  int num_fwd = node_ptr->forward_edges.size();
  int num_bkw = node_ptr->backward_edges.size();
  EDGE_VECTOR *vec;
  for (int dir = 0; dir < 2; ++dir) {
    if (dir == 0) {
      vec = &(node_ptr->forward_edges);
      tprintf(REFFORMAT " (%d %d): ", node, num_fwd, num_bkw);
    } else {
      vec = &(node_ptr->backward_edges);
      tprintf("\t");
    }
    int i;
    for (i = 0; (dir == 0 ? i < num_fwd : i < num_bkw) &&
         i < max_num_edges; ++i) {
      print_edge_rec((*vec)[i]);
      tprintf(" ");
    }
    if (dir == 0 ? i < num_fwd : i < num_bkw) tprintf("...");
    tprintf("\n");
  }
}
/////////////////////////////////////////////////////////////////trie////////////////////////////////////////

/////////////////////////////////////////////////////////////////dawg////////////////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
INT_VAR(dawg_debug_level, 0, "Set to 1 for general debug info"
        ", to 2 for more details, to 3 to see all the debug messages");

/*----------------------------------------------------------------------
              F u n c t i o n s   f o r   D a w g
----------------------------------------------------------------------*/
bool Dawg::word_in_dawg(const WERD_CHOICE &word) const {
  if (word.length() == 0) return false;
  NODE_REF node = 0;
  int end_index = word.length() - 1;
  for (int i = 0; i <= end_index; i++) {
    if (dawg_debug_level > 1) {
      tprintf("word_in_dawg: exploring node " REFFORMAT ":\n", node);
      print_node(node, MAX_NODE_EDGES_DISPLAY);
      tprintf("\n");
    }
    EDGE_REF edge = edge_char_of(node, word.unichar_id(i), i == end_index);
    if (edge != NO_EDGE) {
      node = next_node(edge);
      if (node == 0) node = NO_EDGE;
    } else {
      return false;
    }
  }
  return true;
}

int Dawg::check_for_words(const char *filename,
                          const UNICHARSET &unicharset,
                          bool enable_wildcard) const {
  if (filename == NULL) return 0;

  FILE       *word_file;
  char       string [CHARS_PER_LINE];
  int misses = 0;
  UNICHAR_ID wildcard = unicharset.unichar_to_id(kWildcard);

  word_file = open_file (filename, "r");

  while (fgets (string, CHARS_PER_LINE, word_file) != NULL) {
    chomp_string(string);  // remove newline
    WERD_CHOICE word(string, unicharset);
    if (word.length() > 0 &&
        !word.contains_unichar_id(INVALID_UNICHAR_ID)) {
      if (!match_words(&word, 0, 0,
                       enable_wildcard ? wildcard : INVALID_UNICHAR_ID)) {
        tprintf("Missing word: %s\n", string);
        ++misses;
      }
    } else {
      tprintf("Failed to create a valid word from %s\n", string);
    }
  }
  fclose (word_file);
  // Make sure the user sees this with fprintf instead of tprintf.
  if (dawg_debug_level) tprintf("Number of lost words=%d\n", misses);
  return misses;
}

bool Dawg::match_words(WERD_CHOICE *word, inT32 index,
                       NODE_REF node, UNICHAR_ID wildcard) const {
  EDGE_REF edge;
  inT32 word_end;

  if (wildcard != INVALID_UNICHAR_ID && word->unichar_id(index) == wildcard) {
    bool any_matched = false;
    NodeChildVector vec;
    this->unichar_ids_of(node, &vec);
    for (int i = 0; i < vec.size(); ++i) {
      word->set_unichar_id(vec[i].unichar_id, index);
      if (match_words(word, index, node, wildcard))
        any_matched = true;
    }
    word->set_unichar_id(wildcard, index);
    return any_matched;
  } else {
    word_end = index == word->length() - 1;
    edge = edge_char_of(node, word->unichar_id(index), word_end);
    if (edge != NO_EDGE) {  // normal edge in DAWG
      node = next_node(edge);
      if (word_end) {
        if (dawg_debug_level > 1) word->print("match_words() found: ");
        return true;
      } else if (node != 0) {
        return match_words(word, index+1, node, wildcard);
      }
    }
  }
  return false;
}

void Dawg::init(DawgType type, const STRING &lang,
                PermuterType perm, int unicharset_size) {
  type_ = type;
  lang_ = lang;
  perm_ = perm;
  ASSERT_HOST(unicharset_size > 0);
  unicharset_size_ = unicharset_size;
  // Set bit masks.
  flag_start_bit_ = ceil(log(static_cast<double>(unicharset_size_)) / log(2.0));
  next_node_start_bit_ = flag_start_bit_ + NUM_FLAG_BITS;
  letter_mask_ = ~(~0 << flag_start_bit_);
  next_node_mask_ = ~0 << (flag_start_bit_ + NUM_FLAG_BITS);
  flags_mask_ = ~(letter_mask_ | next_node_mask_);
}


/*----------------------------------------------------------------------
         F u n c t i o n s   f o r   S q u i s h e d    D a w g
----------------------------------------------------------------------*/

SquishedDawg::~SquishedDawg() { memfree(edges_); }

EDGE_REF SquishedDawg::edge_char_of(NODE_REF node,
                                    UNICHAR_ID unichar_id,
                                    bool word_end) const {
  EDGE_REF edge = node;
  if (node == 0) {  // binary search
    EDGE_REF start = 0;
    EDGE_REF end = num_forward_edges_in_node0 - 1;
    int compare;
    while (start <= end) {
      edge = (start + end) >> 1;  // (start + end) / 2
      compare = given_greater_than_edge_rec(NO_EDGE, word_end,
                                            unichar_id, edges_[edge]);
      if (compare == 0) {  // given == vec[k]
        return edge;
      } else if (compare == 1) {  // given > vec[k]
        start = edge + 1;
      } else {  // given < vec[k]
        end = edge - 1;
      }
    }
  } else {  // linear search
    if (edge != NO_EDGE && edge_occupied(edge)) {
      do {
        if ((unichar_id_from_edge_rec(edges_[edge]) == unichar_id) &&
            (!word_end || end_of_word_from_edge_rec(edges_[edge])))
          return (edge);
      } while (!last_edge(edge++));
    }
  }
  return (NO_EDGE);  // not found
}

inT32 SquishedDawg::num_forward_edges(NODE_REF node) const {
  EDGE_REF   edge = node;
  inT32        num  = 0;

  if (forward_edge (edge)) {
    do {
      num++;
    } while (!last_edge(edge++));
  }

  return (num);
}

void SquishedDawg::print_node(NODE_REF node, int max_num_edges) const {
  if (node == NO_EDGE) return;  // nothing to print

  EDGE_REF   edge = node;
  const char       *forward_string  = "FORWARD";
  const char       *backward_string = "       ";

  const char       *last_string     = "LAST";
  const char       *not_last_string = "    ";

  const char       *eow_string      = "EOW";
  const char       *not_eow_string  = "   ";

  const char       *direction;
  const char       *is_last;
  const char       *eow;

  UNICHAR_ID unichar_id;

  if (edge_occupied(edge)) {
    do {
      direction =
        forward_edge(edge) ? forward_string : backward_string;
      is_last = last_edge(edge) ? last_string : not_last_string;
      eow = end_of_word(edge) ? eow_string : not_eow_string;

      unichar_id = edge_letter(edge);
      tprintf(REFFORMAT " : next = " REFFORMAT ", unichar_id = %d, %s %s %s\n",
              edge, next_node(edge), unichar_id,
              direction, is_last, eow);

      if (edge - node > max_num_edges) return;
    } while (!last_edge(edge++));

    if (edge < num_edges_ &&
        edge_occupied(edge) && backward_edge(edge)) {
      do {
        direction =
          forward_edge(edge) ? forward_string : backward_string;
        is_last = last_edge(edge) ? last_string : not_last_string;
        eow = end_of_word(edge) ? eow_string : not_eow_string;

        unichar_id = edge_letter(edge);
        tprintf(REFFORMAT " : next = " REFFORMAT
                ", unichar_id = %d, %s %s %s\n",
                edge, next_node(edge), unichar_id,
                direction, is_last, eow);

        if (edge - node > MAX_NODE_EDGES_DISPLAY) return;
      } while (!last_edge(edge++));
    }
  }
  else {
    tprintf(REFFORMAT " : no edges in this node\n", node);
  }
  tprintf("\n");
}

void SquishedDawg::print_edge(EDGE_REF edge) const {
  if (edge == NO_EDGE) {
    tprintf("NO_EDGE\n");
  } else {
    tprintf(REFFORMAT " : next = " REFFORMAT
            ", unichar_id = '%d', %s %s %s\n", edge,
            next_node(edge), edge_letter(edge),
            (forward_edge(edge) ? "FORWARD" : "       "),
            (last_edge(edge) ? "LAST"    : "    "),
            (end_of_word(edge) ? "EOW"     : ""));
  }
}

void SquishedDawg::read_squished_dawg(FILE *file, DawgType type,
                                      const STRING &lang, PermuterType perm) {
  if (dawg_debug_level) tprintf("Reading squished dawg\n");

  // Read the magic number and if it does not match kDawgMagicNumber
  // set swap to true to indicate that we need to switch endianness.
  inT16 magic;
  fread(&magic, sizeof(inT16), 1, file);
  bool swap = (magic != kDawgMagicNumber);

  int unicharset_size;
  fread(&unicharset_size, sizeof(inT32), 1, file);
  fread(&num_edges_, sizeof(inT32), 1, file);

  if (swap) {
    unicharset_size = reverse32(unicharset_size);
    num_edges_ = reverse32(num_edges_);
  }
  Dawg::init(type, lang, perm, unicharset_size);

  edges_ = (EDGE_ARRAY) memalloc(sizeof(EDGE_RECORD) * num_edges_);
  fread(&edges_[0], sizeof(EDGE_RECORD), num_edges_, file);
  EDGE_REF edge;
  if (swap) {
    for (edge = 0; edge < num_edges_; ++edge) {
      edges_[edge] = reverse64(edges_[edge]);
    }
  }
  if (dawg_debug_level > 2) {
    tprintf("type: %d lang: %s perm: %d unicharset_size: %d num_edges: %d\n",
            type_, lang_.string(), perm_, unicharset_size_, num_edges_);
    for (edge = 0; edge < num_edges_; ++edge)
      print_edge(edge);
  }
}

NODE_MAP SquishedDawg::build_node_map(inT32 *num_nodes) const {
  EDGE_REF   edge;
  NODE_MAP   node_map;
  inT32       node_counter;
  inT32       num_edges;

  node_map = (NODE_MAP) malloc(sizeof(EDGE_REF) * num_edges_);

  for (edge=0; edge < num_edges_; edge++)       // init all slots
    node_map [edge] = -1;

  node_counter = num_forward_edges(0);

  *num_nodes   = 0;
  for (edge=0; edge < num_edges_; edge++) {     // search all slots

    if (forward_edge(edge)) {
      (*num_nodes)++;                          // count nodes links
      node_map[edge] = (edge ? node_counter : 0);
      num_edges = num_forward_edges(edge);
      if (edge != 0) node_counter += num_edges;
      edge += num_edges;
      if (backward_edge(edge)) while (!last_edge(edge++));
      edge--;
    }
  }
  return (node_map);
}

void SquishedDawg::write_squished_dawg(const char *filename) {
  FILE       *file;
  EDGE_REF    edge;
  inT32       num_edges;
  inT32       node_count = 0;
  NODE_MAP    node_map;
  EDGE_REF    old_index;
  EDGE_RECORD temp_record;

  if (dawg_debug_level) tprintf("write_squished_dawg\n");

  node_map = build_node_map(&node_count);

#ifdef WIN32
  file = open_file(filename, "wb");
#else
  file = open_file(filename, "w");
#endif

  // Write the magic number to help detecting a change in endianness.
  inT16 magic = kDawgMagicNumber;
  fwrite(&magic, sizeof(inT16), 1, file);
  fwrite(&unicharset_size_, sizeof(inT32), 1, file);

  // Count the number of edges in this Dawg.
  num_edges = 0;
  for (edge=0; edge < num_edges_; edge++)
    if (forward_edge(edge))
      num_edges++;

  fwrite(&num_edges, sizeof(inT32), 1, file);  // write edge count to file

  if (dawg_debug_level) {
    tprintf("%d nodes in DAWG\n", node_count);
    tprintf("%d edges in DAWG\n", num_edges);
  }

  for (edge=0; edge<num_edges_; edge++) {
    if (forward_edge(edge)) {  // write forward edges
      do {
        old_index = next_node_from_edge_rec(edges_[edge]);
        set_next_node(edge, node_map[old_index]);
        temp_record = edges_[edge];
        fwrite(&(temp_record), sizeof(EDGE_RECORD), 1, file);
        set_next_node(edge, old_index);
      } while (!last_edge(edge++));

      if (backward_edge(edge))  // skip back links
        while (!last_edge(edge++));

      edge--;
    }
  }
  free(node_map);
  fclose(file);
}
/////////////////////////////////////////////////////////////////dawg////////////////////////////////////////

/////////////////////////////////////////////////////////////////choices////////////////////////////////////////
/*----------------------------------------------------------------------
            Variables
------------------------------------------------------------------------*/
#define CHOICEBLOCK 100          /*  Cells per block */

makestructure (newchoice, oldchoice, printchoice, A_CHOICE,
freechoice, CHOICEBLOCK, "A_CHOICE", choicecount)
/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**
 * append_char_choice
 *
 * Create a new choice record. Store the string value in a safe place.
 * Add the new choice record to the list.
 *
 * NB - This is only used by matchers, so permuter is always NO_PERM
 * SPC 16/9/92
 */
CHOICES append_char_choice(CHOICES ratings,
                           const char *string,
                           const char *lengths,
                           float rating,
                           float certainty,
                           inT8 config,
                           int script_id) {
  A_CHOICE *this_choice;

  this_choice = new_choice (string, lengths, rating, certainty,
                            config, script_id, NO_PERM, false, NULL);
  ratings = push_last (ratings, (LIST) this_choice);
  return (ratings);
}

/**
 * copy_choices
 *
 * Copy a list of choices.  This means that there will be two copies
 * in memory.
 */
CHOICES copy_choices(CHOICES choices) {
  CHOICES l;
  CHOICES result = NIL;

  iterate_list(l, choices) {
    A_CHOICE *choice = (A_CHOICE *)(first_node(l));
    result = push (result,
      (LIST) new_choice (class_string(choice),
                         class_lengths(choice),
                         class_rating(choice),
                         class_certainty(choice),
                         class_config(choice),
                         class_script_id(choice),
                         class_permuter(choice),
                         class_fragment_mark(choice),
                         class_fragment_lengths(choice)));
  }
  return (reverse_d (result));
}

/**
 * clone_choice
 *
 * Copy the contents of the given values to the corresponding values in
 * a given choice replacing any previous values it might have had.
 */
void clone_choice(A_CHOICE *choice, const char *string,
                  const char *lengths, float rating, float certainty,
                  inT8 permuter, bool fragment_mark,
                  const char *fragment_lengths) {
  if (choice->string) strfree (class_string (choice));
  if (choice->lengths) strfree (class_lengths (choice));
  if (choice->fragment_lengths) strfree(choice->fragment_lengths);

  choice->string = strsave (string);
  choice->lengths = strsave (lengths);
  choice->rating = rating;
  choice->certainty = certainty;
  choice->permuter = permuter;
  choice->fragment_mark = fragment_mark;
  choice->fragment_lengths =
    fragment_lengths ? strsave(fragment_lengths) : NULL;
}

/**
 * clear_choice
 *
 * Set the fields in this choice to be defaulted bad initial values.
 */
void clear_choice(A_CHOICE *choice) {
  choice->string = NULL;
  choice->lengths =  NULL;
  choice->rating =  MAX_FLOAT32;
  choice->certainty = -MAX_FLOAT32;
  choice->fragment_mark = false;
  choice->fragment_lengths = NULL;
}


/**
 * free_choice
 *
 * Free up the memory taken by one choice rating.
 */
void free_choice(void *arg) {  //LIST choice)
  A_CHOICE *this_choice;
  LIST choice = (LIST) arg;

  this_choice = (A_CHOICE *) choice;
  if (this_choice) {
    if (this_choice->string)
      strfree (this_choice->string);
    if (this_choice->lengths)
      strfree (this_choice->lengths);
    if (this_choice->fragment_lengths)
      strfree (this_choice->fragment_lengths);
    oldchoice(this_choice);
  }
}

/**
 * get_best_free_other
 *
 * Returns the best of two choices and frees the other (worse) choice.
 * A choice is better if it has a non-NULL string and has a lower rating
 * than the other choice.
 */
A_CHOICE *get_best_free_other(A_CHOICE *choice_1, A_CHOICE *choice_2) {
  if (!choice_1) return choice_2;
  if (!choice_2) return choice_1;
  if (class_rating (choice_1) < class_rating (choice_2) ||
      class_string (choice_2) == NULL) {
    free_choice(choice_2);
    return choice_1;
  } else {
    free_choice(choice_1);
    return choice_2;
  }
}

/**
 * new_choice
 *
 * Create a new choice record. Store the string value in a safe place.
 */
A_CHOICE *new_choice(const char *string,
                     const char *lengths,
                     float rating,
                     float certainty,
                     inT8 config,
                     int script_id,
                     char permuter,
                     bool fragment_mark,
                     const char *fragment_lengths) {
  A_CHOICE *this_choice;

  this_choice = newchoice();
  this_choice->string = strsave(string);
  this_choice->lengths = strsave(lengths);
  this_choice->rating = rating;
  this_choice->certainty = certainty;
  this_choice->config = config;
  this_choice->permuter = permuter;
  this_choice->script_id = script_id;
  this_choice->fragment_mark = fragment_mark;
  this_choice->fragment_lengths =
    fragment_lengths ? strsave(fragment_lengths) : NULL;

  return (this_choice);
}

A_CHOICE *new_choice(const char *string,
                     const char *lengths,
                     float rating,
                     float certainty,
                     inT8 config,
                     char permuter) {
  return new_choice(string, lengths, rating, certainty,
                    config, -1, permuter, false, NULL);
}


/**
 * print_choices
 *
 * Print the rating for a particular blob or word.
 */
void DictT::print_choices(const char *label,
                         CHOICES choices) {   // List of (A_CHOICE*).
  tprintf("%s\n", label);
  if (choices == NIL)
    tprintf(" No rating ");

  iterate(choices) {
    tprintf("%.2f %.2f", best_rating(choices), best_certainty(choices));
    print_word_string(best_string(choices));
  }
  tprintf("\n");
}

/**
 * print_word_choice
 *
 * Print the string in a human-readable format and ratings for a word.
 */
void DictT::print_word_choice(const char *label, A_CHOICE* choice) {
  tprintf("%s : ", label);
  if (choice == NULL) {
    tprintf("No rating\n");
  } else {
    tprintf("%.2f %.2f", class_rating(choice), class_certainty(choice));
    print_word_string(class_string(choice));
    tprintf("\n");
  }
}

/**
 * print_word_string
 *
 * Print the string in a human-readable format.
 * The output is not newline terminated.
 */
void DictT::print_word_string(const char* str) {
  int step = 1;
  for (int i = 0; str[i] != '\0'; i += step) {
    step = (getUnicharset().get_fragment(str) ?
      strlen(str) : getUnicharset().step(str + i));
    int unichar_id = getUnicharset().unichar_to_id(str + i, step);
    tprintf(" : %s ", getUnicharset().debug_str(unichar_id).string());
  }
}
/////////////////////////////////////////////////////////////////choices////////////////////////////////////////

/////////////////////////////////////////////////////////////////DictT////////////////////////////////////////
class Image;

DictT::DictT(Image* image_ptr)
    : letter_is_okay_(&DictT::def_letter_is_okay),
      image_ptr_(image_ptr) {
  dang_ambigs_table_ = NULL;
  replace_ambigs_table_ = NULL;
  keep_word_choices_ = false;
  reject_offset_ = 0.0;
  best_raw_choice_ = NULL;
  best_choices_ = NIL;
  raw_choices_ = NIL;
  go_deeper_fxn_ = NULL;
  hyphen_word_ = NULL;
  last_word_on_line_ = false;
  hyphen_unichar_id_ = INVALID_UNICHAR_ID;
  document_words_ = NULL;
  pending_words_ = NULL;
  freq_dawg_ = NULL;
}

DictT::~DictT() {
  if (hyphen_word_ != NULL) delete hyphen_word_;
}

// Returns true if in light of the current state the letter at word_index
// in the given word is allowed according to at least one of the dawgs in
// dawgs_.
//
// See more extensive comments in dict.h where this function is declared.
//
int DictT::def_letter_is_okay(void* void_dawg_args, int word_index,
                             const void *void_word, bool word_end) {
  DawgArgs *dawg_args = reinterpret_cast<DawgArgs*>(void_dawg_args);
  const WERD_CHOICE *word = reinterpret_cast<const WERD_CHOICE*>(void_word);

  if (dawg_debug_level >= 3) {
    tprintf("def_letter_is_okay: word_index=%d word_end=%d"
            " word=%s num active dawgs=%d num constraints=%d\n",
            word_index, word_end,
            word->debug_string(getUnicharset()).string(),
            dawg_args->active_dawgs->length(),
            dawg_args->constraints->length());
  }

  // Do not accept words that contain kPatternUnicharID.
  // (otherwise pattern dawgs would not function correctly).
  // Do not accept words containing INVALID_UNICHAR_IDs.
  UNICHAR_ID unichar_id = word->unichar_id(word_index);
  if (unichar_id == Dawg::kPatternUnicharID ||
      unichar_id == INVALID_UNICHAR_ID) {
    dawg_args->permuter = NO_PERM;
    return NO_PERM;
  }

  // Initialization.
  PermuterType current_permuter = NO_PERM;
  dawg_args->updated_active_dawgs->clear();
  const DawgInfoVector &constraints = *(dawg_args->constraints);
  *dawg_args->updated_constraints = constraints;

  // Go over the active_dawgs vector and insert DawgInfo records with the
  // updated ref (an edge with the corresponding unichar id) into
  // dawg_args->updated_active_dawgs.
  for (int a = 0; a < dawg_args->active_dawgs->length(); ++a) {
    const DawgInfo &info = (*dawg_args->active_dawgs)[a];
    const Dawg *dawg = dawgs_[info.dawg_index];
    // Obtain unichar_id at this position (could be changed later, so this
    // needs to be inside the loop over all active dawgs).
     unichar_id = word->unichar_id(word_index);
    // The number dawg generalizes all digits to be kPatternUnicharID,
    // so try to match kPatternUnicharID if the current unichar is a digit.
    if (dawg->type() == DAWG_TYPE_NUMBER &&
        getUnicharset().get_isdigit(unichar_id)) {
      unichar_id = Dawg::kPatternUnicharID;
    }
    // Get the starting node for this letter.
    NODE_REF node;
    if (info.ref == NO_EDGE) {
      node = 0;  // beginning to explore this dawg
    } else {
      node = dawg->next_node(info.ref);
      if (node == 0) node = NO_EDGE;  // end of word
    }
    // Find the edge out of the node for the curent unichar_id.
    EDGE_REF edge = (node != NO_EDGE) ?
      dawg->edge_char_of(node, unichar_id, word_end) : NO_EDGE;

    if (dawg_debug_level >= 3) {
      tprintf("Active dawg: [%d, " REFFORMAT "] edge=" REFFORMAT "\n",
              info.dawg_index, node, edge);
    }

    if (edge != NO_EDGE) {  // the unichar was found in the current dawg
      if (ConstraintsOk(*(dawg_args->updated_constraints),
                        word_end, dawg->type())) {
        UpdatePermuter(dawg->permuter(), &current_permuter);
        dawg_args->updated_active_dawgs->add_unique(
            DawgInfo(info.dawg_index, edge),
            "Append current dawg to updated active dawgs: ");
      }
    } else {                // the unichar was not found in the current dawg
      // Handle leading/trailing punctuation dawgs that denote a word pattern
      // as an edge with kPatternUnicharID. If such an edge is found we add a
      // constraint denoting the state of the dawg before the word pattern.
      // This constraint will be applied later when this dawg is found among
      // successor dawgs as well potentially at the end of the word.
      if (dawg->type() == DAWG_TYPE_PUNCTUATION) {
        edge = dawg->edge_char_of(node, Dawg::kPatternUnicharID, word_end);
        if (edge != NO_EDGE) {
          dawg_args->updated_constraints->add_unique(
              DawgInfo(info.dawg_index, edge), "Recording constraint: ");
        } else {
          // Do not explore successors of this dawg, since this
          // must be invalid leading or trailing punctuation.
          if (dawg_debug_level >= 3) {
            tprintf("Invalid punctuation from dawg %d\n", info.dawg_index);
          }
          continue;
        }
      }

      if (info.ref == NO_EDGE) {
        if (dawg_debug_level >= 3) {
          tprintf("No letters matched in dawg %d\n", info.dawg_index);
        }
        continue;
      }

      // Discard the dawg if the pattern can not end at previous letter.
      if (edge == NO_EDGE &&  // previous part is not leading punctuation
          !dawg->end_of_word(info.ref)) {
        if (dawg_debug_level >= 3) {
          tprintf("No valid pattern end in dawg %d\n", info.dawg_index);
        }
        continue;
      }

      // Look for the unichar in each of this dawg's successors
      // and append those in which it is found to active_dawgs.
      const SuccessorList &slist = *(successors_[info.dawg_index]);
      for (int s = 0; s < slist.length(); ++s) {
        int sdawg_index = slist[s];
        const Dawg *sdawg = dawgs_[sdawg_index];
        NODE_REF snode = 0;
        // Apply constraints to the successor dawg.
        for (int c = 0; c < constraints.length(); ++c) {
          // If the successor dawg is described in the constraints change
          // the start ref from 0 to the one recorded as the constraint.
          const DawgInfo &cinfo = constraints[c];
          if (cinfo.dawg_index == sdawg_index) {
            snode = sdawg->next_node(cinfo.ref);
            // Make sure we do not search the successor dawg if after
            // applying the saved constraint we are at the end of the word.
            if (snode == 0) snode = NO_EDGE;
            if (dawg_debug_level >= 3) {
               tprintf("Applying constraint [%d, " REFFORMAT "]\n",
                       sdawg_index, snode);
            }
          }
        }
        // Look for the letter in this successor dawg.
        EDGE_REF sedge = sdawg->edge_char_of(
            snode, word->unichar_id(word_index), word_end);
        // If we found the letter append sdawg to the active_dawgs list.
        if (sedge != NO_EDGE &&
            ConstraintsOk(*(dawg_args->updated_constraints), word_end,
                          dawgs_[sdawg_index]->type())) {
          UpdatePermuter(sdawg->permuter(), &current_permuter);
          if (sdawg->next_node(sedge) != 0) {  // if not word end
            dawg_args->updated_active_dawgs->add_unique(
              DawgInfo(sdawg_index, sedge),
              "Append successor to updated active dawgs: ");
          }
        }
      }  // end successors loop
    }  // end if/else
  }  // end for
  // Update dawg_args->permuter if it used to be NO_PERM or if we found
  // the current letter in a non-punctuation dawg. This allows preserving
  // information on which dawg the "core" word came from.
  if ((current_permuter == PUNC_PERM &&
       current_permuter > dawg_args->permuter) ||
      current_permuter != PUNC_PERM) {
    dawg_args->permuter = current_permuter;
  }
  return dawg_args->permuter;
}

// Unless the previous word was the last one on the line, and the current
// one is not (thus it is the first one on the line), erase hyphen_word_,
// clear hyphen_active_dawgs_, hyphen_constraints_ update last_word_on_line_.
void DictT::reset_hyphen_vars(bool last_word_on_line) {
  if (!(last_word_on_line_ == true && last_word_on_line == false)) {
    if (hyphen_word_ != NULL) {
      delete hyphen_word_;
      hyphen_word_ = NULL;
      hyphen_active_dawgs_.clear();
      hyphen_constraints_.clear();
    }
  }
  if (/*hyphen_debug_level*/0) {
    tprintf("reset_hyphen_vars: last_word_on_line %d -> %d\n",
            last_word_on_line_, last_word_on_line);
  }
  last_word_on_line_ = last_word_on_line;
}

// Update hyphen_word_, and copy the given DawgInfoVectors into
// hyphen_active_dawgs_ and hyphen_constraints_.
void DictT::set_hyphen_word(const WERD_CHOICE &word,
                           const DawgInfoVector &active_dawgs,
                           const DawgInfoVector &constraints) {
  if (hyphen_word_ == NULL) {
    hyphen_word_ = new WERD_CHOICE();
    hyphen_word_->make_bad();
  }
  if (hyphen_word_->rating() > word.rating()) {
    *hyphen_word_ = word;
    hyphen_word_->remove_last_unichar_id();  // last unichar id is a hyphen
    hyphen_active_dawgs_ = active_dawgs;
    hyphen_constraints_ = constraints;
  }
  if (/*hyphen_debug_level*/0) {
    hyphen_word_->print("set_hyphen_word: ");
  }
}
/////////////////////////////////////////////////////////////////DictT////////////////////////////////////////

//////////////////////////////////////////////////////////////context////////////////////////////////////
PROBABILITY_IN_CONTEXT_FUNCTION probability_in_context = &def_probability_in_context;

double def_probability_in_context(const char* context,
                                  int context_bytes,
                                  const char* character,
                                  int character_bytes) {
  (void) context;
  (void) context_bytes;
  (void) character;
  (void) character_bytes;
  return 0.0;
}

/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
static FILE *choice_file = NULL; /* File to save choices */

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**********************************************************************
 * close_choices
 *
 * Close the choices file.
 **********************************************************************/
void close_choices() {
  if (choice_file)
    fclose(choice_file);
}

/**********************************************************************
 * case_ok
 *
 * Check a string to see if it matches a set of lexical rules.
 **********************************************************************/
int Context::case_ok(const WERD_CHOICE &word,
                     const UNICHARSET &unicharset) {
  static int case_state_table[6][4] = { {
                                 /*  0. Begining of word         */
    /*    P   U   L   D                                     */
    /* -1. Error on case            */
      0, 1, 5, 4
    },
    {                            /*  1. After initial capital    */
      0, 3, 2, 4
    },
    {                            /*  2. After lower case         */
      0, -1, 2, -1
    },
    {                            /*  3. After upper case         */
      0, 3, -1, 4
    },
    {                            /*  4. After a digit            */
      0, -1, -1, 4
    },
    {                            /*  5. After initial lower case */
      5, -1, 2, -1
    },
  };

  register int state = 0;
  register int x;

  for (x = 0; x < word.length(); ++x) {
    UNICHAR_ID ch_id = word.unichar_id(x);
    if (unicharset.get_isupper(ch_id))
      state = case_state_table[state][1];
    else if (unicharset.get_islower(ch_id))
      state = case_state_table[state][2];
    else if (unicharset.get_isdigit(ch_id))
      state = case_state_table[state][3];
    else
      state = case_state_table[state][0];

    if (tord_debug_3)
      tprintf("Case state = %d, char = %s\n", state,
              unicharset.id_to_unichar(ch_id));
    if (state == -1) {
                                 /* Handle ACCRONYMs */
#if 0
      if (word[x] == 's' &&
        !isalpha (word[x + 1]) && !isdigit (word[x + 1]))
      else
#endif
        return (FALSE);
    }
  }
  return state != 5;             /*single lower is bad */
}
/**********************************************************************
 * write_choice_line
 *
 * Write a blank line to the choices file.  This will indicate that
 * there is a new word that is following.
 **********************************************************************/
void write_choice_line() {
  if (choice_file) {
    fprintf (choice_file, "\n");
    fflush(choice_file);
  }
}
//////////////////////////////////////////////////////////////context////////////////////////////////////

//////////////////////////////////////////////////////////////stopper//////////////////////////////////
#ifdef __UNIX__
#endif

#ifdef _MSC_VER
#pragma warning(disable:4244)  // Conversion warnings
#pragma warning(disable:4800)  // int/bool warnings
#endif

/* these are kludges - add appropriate .h file later */
/* from adaptmatch.cpp */
#define MAX_WERD_SIZE   100

typedef struct
{
  VIABLE_CHOICE Choice;
  float ChunkCertainty[MAX_NUM_CHUNKS];
  UNICHAR_ID ChunkClass[MAX_NUM_CHUNKS];
} EXPANDED_CHOICE;

/**----------------------------------------------------------------------------
          Macros
----------------------------------------------------------------------------**/
#define BestCertainty(Choices)  (((VIABLE_CHOICE) first_node (Choices))->Certainty)
#define BestRating(Choices) (((VIABLE_CHOICE) first_node (Choices))->Rating)
#define BestFactor(Choices) (((VIABLE_CHOICE) first_node (Choices))->AdjustFactor)

#define AmbigThreshold(F1,F2)	(((F2) - (F1)) * stopper_ambiguity_threshold_gain - \
                stopper_ambiguity_threshold_offset)

/*---------------------------------------------------------------------------
          Private Function Prototoypes
----------------------------------------------------------------------------*/
void AddNewChunk(VIABLE_CHOICE Choice, int Blob);

int CmpChoiceRatings(void *arg1,   //VIABLE_CHOICE         Choice1,
                     void *arg2);  //VIABLE_CHOICE         Choice2);

void ExpandChoice(VIABLE_CHOICE Choice, EXPANDED_CHOICE *ExpandedChoice);

int FreeBadChoice(void *item1,   //VIABLE_CHOICE                 Choice,
                  void *item2);  //EXPANDED_CHOICE                       *BestChoice);

int UniformCertainties(const BLOB_CHOICE_LIST_VECTOR &Choices,
                       const WERD_CHOICE &BestChoice);

/**----------------------------------------------------------------------
                     V a r i a b l e s
----------------------------------------------------------------------**/
double_VAR(certainty_scale, 20.0, "Certainty scaling factor");

double_VAR(stopper_nondict_certainty_base, -2.50,
           "Certainty threshold for non-dict words");

double_VAR(stopper_phase2_certainty_rejection_offset, 1.0,
           "Reject certainty offset");

INT_VAR(stopper_smallword_size, 2,
        "Size of dict word to be treated as non-dict word");

double_VAR(stopper_certainty_per_char, -0.50,
           "Certainty to add for each dict char above small word size.");

double_VAR(stopper_allowable_character_badness, 3.0,
           "Max certaintly variation allowed in a word (in sigma)");

INT_VAR(stopper_debug_level, 0, "Stopper debug level");

double_VAR(stopper_ambiguity_threshold_gain, 8.0,
           "Gain factor for ambiguity threshold");

double_VAR(stopper_ambiguity_threshold_offset, 1.5,
           "Certainty offset for ambiguity threshold");

BOOL_VAR(stopper_no_acceptable_choices, false,
         "Make AcceptableChoice() always return false. Useful"
         " when there is a need to explore all segmentations");

BOOL_VAR(save_raw_choices, false, "Save all explored raw choices");

INT_VAR (tessedit_truncate_wordchoice_log, 10, "Max words to keep in list");

STRING_VAR(word_to_debug, "", "Word for which stopper debug information"
           " should be printed to stdout");

STRING_VAR(word_to_debug_lengths, "", "Lengths of unichars in word_to_debug");

/**----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
int DictT::AcceptableChoice(BLOB_CHOICE_LIST_VECTOR *Choices,
                           WERD_CHOICE *BestChoice,
                           const WERD_CHOICE &RawChoice,
                           DANGERR *fixpt,
                           ACCEPTABLE_CHOICE_CALLER caller,
                           bool *modified_blobs) {
/*
 **	Parameters:
 **		Choices		choices for current segmentation
 **		BestChoice	best choice for current segmentation
 **		RawChoice	best raw choice for current segmentation
 **	Variables Used:
 **		stopper_nondict_certainty_base	certainty for a non-dict word
 **		stopper_smallword_size		size of word to be treated as non-word
 **		stopper_certainty_per_char	certainty to add for each dict char
 **	Operation: Return TRUE if the results from this segmentation are
 **		good enough to stop.  Otherwise return FALSE.
 **	Return: TRUE or FALSE.
 **	Exceptions: none
 **	History: Mon Apr 29 14:57:32 1991, DSJ, Created.
 */
  Q_UNUSED(RawChoice);
  float CertaintyThreshold = stopper_nondict_certainty_base;
  int WordSize;

  if (stopper_no_acceptable_choices) return false;

  if (fixpt != NULL)
    fixpt->index = -1;
  if (BestChoice->length() == 0)
    return (FALSE);
  if (caller == CHOPPER_CALLER && BestChoice->fragment_mark()) {
    if (stopper_debug_level >= 1) {
      cprintf("AcceptableChoice(): a choice with fragments beats BestChoice");
    }
    return false;
  }

  bool no_dang_ambigs =
    NoDangerousAmbig(BestChoice, fixpt, true, Choices, modified_blobs);

  if (stopper_debug_level >= 1)
    tprintf("\nStopper:  %s (word=%c, case=%c)\n",
            BestChoice->debug_string(getUnicharset()).string(),
            (valid_word(*BestChoice) ? 'y' : 'n'),
            (Context::case_ok(*BestChoice, getUnicharset()) ? 'y' : 'n'));

  if (valid_word(*BestChoice) &&
      Context::case_ok(*BestChoice, getUnicharset())) {
    WordSize = LengthOfShortestAlphaRun(*BestChoice);
    WordSize -= stopper_smallword_size;
    if (WordSize < 0)
      WordSize = 0;
    CertaintyThreshold += WordSize * stopper_certainty_per_char;
  }

  if (stopper_debug_level >= 1)
    tprintf("Stopper:  Certainty = %4.1f, Threshold = %4.1f\n",
            BestChoice->certainty(), CertaintyThreshold);

  if (no_dang_ambigs &&
      BestChoice->certainty() > CertaintyThreshold &&
      UniformCertainties(*Choices, *BestChoice)) {
    return (TRUE);
  } else {
    return (FALSE);
  }
}                                /* AcceptableChoice */


/*---------------------------------------------------------------------------*/
int DictT::AcceptableResult(const WERD_CHOICE &BestChoice,
                           const WERD_CHOICE &RawChoice) {
/*
 **	Parameters:
 **		BestChoice	best choice for current word
 **		RawChoice	best raw choice for current word
 **	Variables Used:
 **		stopper_nondict_certainty_base	certainty for a non-dict word
 **		stopper_smallword_size		size of word to be treated as non-word
 **		stopper_certainty_per_char	certainty to add for each dict char
 **		best_choices_		list of all good choices found
 **		reject_offset_		allowed offset before a word is rejected
 **	Operation: Return FALSE if the best choice for the current word
 **		is questionable and should be tried again on the second
 **		pass or should be flagged to the user.
 **	Return: TRUE or FALSE.
 **	Exceptions: none
 **	History: Thu May  9 14:05:05 1991, DSJ, Created.
 */
  Q_UNUSED(RawChoice);
  float CertaintyThreshold = stopper_nondict_certainty_base - reject_offset_;
  int WordSize;

  if (stopper_debug_level >= 1) {
    tprintf("\nRejecter: %s (word=%c, case=%c, unambig=%c)\n",
            BestChoice.debug_string(getUnicharset()).string(),
            (valid_word(BestChoice) ? 'y' : 'n'),
            (Context::case_ok(BestChoice, getUnicharset()) ? 'y' : 'n'),
            ((rest (best_choices_) != NIL) ? 'n' : 'y'));
  }

  if (BestChoice.length() == 0 || CurrentWordAmbig())
    return (FALSE);
  if (BestChoice.fragment_mark()) {
    if (stopper_debug_level >= 1) {
      cprintf("AcceptableResult(): a choice with fragments beats BestChoice\n");
    }
    return false;
  }
  if (valid_word(BestChoice) &&
      Context::case_ok(BestChoice, getUnicharset())) {
    WordSize = LengthOfShortestAlphaRun(BestChoice);
    WordSize -= stopper_smallword_size;
    if (WordSize < 0)
      WordSize = 0;
    CertaintyThreshold += WordSize * stopper_certainty_per_char;
  }

  if (stopper_debug_level >= 1)
    cprintf ("Rejecter: Certainty = %4.1f, Threshold = %4.1f   ",
      BestChoice.certainty(), CertaintyThreshold);

  if (BestChoice.certainty() > CertaintyThreshold &&
      !stopper_no_acceptable_choices) {
    if (stopper_debug_level >= 1)
      cprintf("ACCEPTED\n");
    return (TRUE);
  }
  else {
    if (stopper_debug_level >= 1)
      cprintf("REJECTED\n");
    return (FALSE);
  }
}                                /* AcceptableResult */


/*---------------------------------------------------------------------------*/
int DictT::AlternativeChoicesWorseThan(FLOAT32 Threshold) {
/*
 **	Parameters:
 **		Threshold	minimum adjust factor for alternative choices
 **	Variables Used:
 **		best_choices_	alternative choices for current word
 **	Operation: This routine returns TRUE if there are no alternative
 **		choices for the current word OR if all alternatives have
 **		an adjust factor worse than Threshold.
 **	Return: TRUE or FALSE.
 **	Exceptions: none
 **	History: Mon Jun  3 09:36:31 1991, DSJ, Created.
 */
  LIST Alternatives;
  VIABLE_CHOICE Choice;

  Alternatives = rest (best_choices_);
  iterate(Alternatives) {
    Choice = (VIABLE_CHOICE) first_node (Alternatives);
    if (Choice->AdjustFactor <= Threshold)
      return (FALSE);
  }

  return (TRUE);

}                                /* AlternativeChoicesWorseThan */


/*---------------------------------------------------------------------------*/
int DictT::CurrentBestChoiceIs(const WERD_CHOICE &WordChoice) {
/*
 **	Parameters:
 **             Word            word that will be compared to the best choice
 **	Variables Used:
 **		best_choices_	set of best choices for current word
 **	Operation: Returns TRUE if Word is the same as the current best
 **		choice, FALSE otherwise.
 **	Return: TRUE or FALSE
 **	Exceptions: none
 **	History: Thu May 30 14:44:22 1991, DSJ, Created.
 */
  return (best_choices_ != NIL &&
          StringSameAs(WordChoice, (VIABLE_CHOICE)first_node(best_choices_)));
}                                /* CurrentBestChoiceIs */


/*---------------------------------------------------------------------------*/
FLOAT32 DictT::CurrentBestChoiceAdjustFactor() {
/*
 **	Parameters: none
 **	Variables Used:
 **		best_choices_	set of best choices for current word
 **	Operation: Return the adjustment factor for the best choice for
 **		the current word.
 **	Return: Adjust factor for current best choice.
 **	Exceptions: none
 **	History: Thu May 30 14:48:24 1991, DSJ, Created.
 */
  VIABLE_CHOICE BestChoice;

  if (best_choices_ == NIL)
    return (MAX_FLOAT32);

  BestChoice = (VIABLE_CHOICE) first_node (best_choices_);
  return (BestChoice->AdjustFactor);

}                                /* CurrentBestChoiceAdjustFactor */


/*---------------------------------------------------------------------------*/
int DictT::CurrentWordAmbig() {
/*
 **	Parameters: none
 **	Variables Used:
 **		best_choices_	set of best choices for current word
 **	Operation: This routine returns TRUE if there are multiple good
 **		choices for the current word and FALSE otherwise.
 **	Return: TRUE or FALSE
 **	Exceptions: none
 **	History: Wed May 22 15:38:38 1991, DSJ, Created.
 */
  return (rest (best_choices_) != NIL);

}                                /* CurrentWordAmbig */


/*---------------------------------------------------------------------------*/
void DictT::DebugWordChoices() {
/*
 **	Parameters: none
 **	Variables Used:
 **		best_raw_choice_
 **		best_choices_
 **	Operation: Print the current choices for this word to stdout.
 **	Return: none
 **	Exceptions: none
 **	History: Wed May 15 13:52:08 1991, DSJ, Created.
 */
  LIST Choices;
  int i;
  char LabelString[80];
  VIABLE_CHOICE VChoice = (VIABLE_CHOICE)first_node(best_choices_);
  bool force_debug = fragments_debug && VChoice != NULL && VChoice->ComposedFromCharFragments;

  if (stopper_debug_level >= 1 || force_debug ||
  (((STRING)word_to_debug).length() > 0 && best_choices_ &&
       StringSameAs(word_to_debug.string(), word_to_debug_lengths.string(),
                    (VIABLE_CHOICE)first_node(best_choices_)))) {
    if (best_raw_choice_)
      PrintViableChoice(stderr, "\nBest Raw Choice:   ", best_raw_choice_);

    i = 1;
    Choices = best_choices_;
    if (Choices)
      cprintf("\nBest Cooked Choices:\n");
    iterate(Choices) {
      sprintf(LabelString, "Cooked Choice #%d:  ", i);
      PrintViableChoice(stderr, LabelString,
                        (VIABLE_CHOICE)first_node(Choices));
      i++;
    }
  }
}                                /* DebugWordChoices */

// Print all the choices in raw_choices_ list for non 1-1 ambiguities.
void DictT::PrintAmbigAlternatives(FILE *file, const char *label,
                                  int label_num_unichars) {
  iterate(raw_choices_) {
    VIABLE_CHOICE Choice = (VIABLE_CHOICE)first_node(raw_choices_);
    if (Choice->Length > 0 &&
        (label_num_unichars > 1 || Choice->Length > 1)) {
      for (int i = 0; i < Choice->Length; i++) {
        fprintf(file, "%s",
                getUnicharset().id_to_unichar(Choice->Blob[i].Class));
      }
      fflush(file);
      fprintf(file, "\t%s\t%.4f\t%.4f\n", label,
              Choice->Rating, Choice->Certainty);
    }
  }
}

/*---------------------------------------------------------------------------*/
void DictT::FilterWordChoices() {
/*
 **	Parameters: none
 **	Variables Used:
 **		best_choices_	set of choices for current word
 **	Operation: This routine removes from best_choices_ all choices which
 **		are not within a reasonable range of the best choice.
 **	Return: none
 **	Exceptions: none
 **	History: Wed May 15 13:08:24 1991, DSJ, Created.
 */
  EXPANDED_CHOICE BestChoice;

  if (best_choices_ == NIL || second_node (best_choices_) == NIL)
    return;

  /* compute certainties and class for each chunk in best choice */
  ExpandChoice((VIABLE_CHOICE_STRUCT *)first_node(best_choices_), &BestChoice);

  set_rest (best_choices_, delete_d (rest (best_choices_),
    &BestChoice, FreeBadChoice));

}                                /* FilterWordChoices */

/*---------------------------------------------------------------------------*/
void DictT::FindClassifierErrors(FLOAT32 MinRating,
                                FLOAT32 MaxRating,
                                FLOAT32 RatingMargin,
                                FLOAT32 Thresholds[]) {
/*
 **	Parameters:
 **		MinRating		limits how tight to make a template
 **		MaxRating		limits how loose to make a template
 **		RatingMargin		amount of margin to put in template
 **		Thresholds[]		place to put error thresholds
 **	Operation: This routine compares the best choice for the current
 **		word to the best raw choice to determine which characters
 **		were classified incorrectly by the classifier.  It then
 **		places a separate threshold into Thresholds for each
 **		character in the word.  If the classifier was correct,
 **		MaxRating is placed into Thresholds.  If the
 **		classifier was incorrect, the avg. match rating (error
 **		percentage) of the classifier's incorrect choice minus
 **		some margin is
 **		placed into thresholds.  This can then be used by the
 **		caller to try to create a new template for the desired
 **		class that will classify the character with a rating better
 **		than the threshold value.  The match rating placed into
 **		Thresholds is never allowed to be below MinRating in order
 **		to prevent trying to make overly tight templates.
 **	Return: none (results are placed in Thresholds)
 **	Exceptions: none
 **	History: Fri May 31 16:02:57 1991, DSJ, Created.
 */
  EXPANDED_CHOICE BestRaw;
  VIABLE_CHOICE Choice;
  int i, j, Chunk;
  FLOAT32 AvgRating;
  int NumErrorChunks;

  assert (best_choices_ != NIL);
  assert (best_raw_choice_ != NULL);

  ExpandChoice(best_raw_choice_, &BestRaw);
  Choice = (VIABLE_CHOICE) first_node (best_choices_);

  for (i = 0, Chunk = 0; i < Choice->Length; i++, Thresholds++) {
    AvgRating = 0.0;
    NumErrorChunks = 0;

    for (j = 0; j < Choice->Blob[i].NumChunks; j++, Chunk++) {
      if (Choice->Blob[i].Class != BestRaw.ChunkClass[Chunk]) {
        AvgRating += BestRaw.ChunkCertainty[Chunk];
        NumErrorChunks++;
      }
    }

    if (NumErrorChunks > 0) {
      AvgRating /= NumErrorChunks;
      *Thresholds = (AvgRating / -certainty_scale) * (1.0 - RatingMargin);
    }
    else
      *Thresholds = MaxRating;

    if (*Thresholds > MaxRating)
      *Thresholds = MaxRating;
    if (*Thresholds < MinRating)
      *Thresholds = MinRating;
  }
}                                /* FindClassifierErrors */


/*---------------------------------------------------------------------------*/
void DictT::InitChoiceAccum() {
/*
 **	Parameters: none
 **	Operation: This routine initializes the data structures used to
 **		keep track the good word choices found for a word.
 **	Return: none
 **	Exceptions: none
 **	History: Fri May 17 07:59:00 1991, DSJ, Created.
 */
  BLOB_WIDTH *BlobWidth, *End;

  if (best_raw_choice_)
    memfree(best_raw_choice_);
  best_raw_choice_ = NULL;

  if (best_choices_)
    destroy_nodes(best_choices_, memfree);
  best_choices_ = NIL;

  if (raw_choices_)
    destroy_nodes(raw_choices_, memfree);
  raw_choices_ = NIL;

  EnableChoiceAccum();

  for (BlobWidth = current_segmentation_,
    End = current_segmentation_ + MAX_NUM_CHUNKS;
    BlobWidth < End; *BlobWidth++ = 1);

}                                /* InitChoiceAccum */


/*---------------------------------------------------------------------------*/
void DictT::LogNewSegmentation(PIECES_STATE BlobWidth) {
/*
 **	Parameters:
 **		BlobWidth[]	number of chunks in each blob in segmentation
 **	Variables Used:
 **		current_segmentation	blob widths for current segmentation
 **	Operation: This routine updates the blob widths in current_segmentation
 **		to be the same as provided in BlobWidth.
 **	Return: none
 **	Exceptions: none
 **	History: Mon May 20 11:52:26 1991, DSJ, Created.
 */
  BLOB_WIDTH *Segmentation;

  for (Segmentation = current_segmentation_; *BlobWidth != 0;
    BlobWidth++, Segmentation++)
  *Segmentation = *BlobWidth;
  *Segmentation = 0;

}                                /* LogNewSegmentation */


/*---------------------------------------------------------------------------*/
void DictT::LogNewSplit(int Blob) {
/*
 **	Parameters:
 **		Blob	index of blob that was split
 **	Variables Used:
 **		best_raw_choice_	current best raw choice
 **		best_choices_	list of best choices found so far
 **	Operation: This routine adds 1 chunk to the specified blob for each
 **		choice in best_choices_ and for the best_raw_choice_.
 **	Return: none
 **	Exceptions: none
 **	History: Mon May 20 11:38:56 1991, DSJ, Created.
 */
  LIST Choices;

  if (best_raw_choice_) {
    AddNewChunk(best_raw_choice_, Blob);
  }

  Choices = best_choices_;
  iterate(Choices) {
    AddNewChunk ((VIABLE_CHOICE) first_node (Choices), Blob);
  }
  Choices = raw_choices_;
  iterate(Choices) {
    AddNewChunk ((VIABLE_CHOICE) first_node (Choices), Blob);
  }
}                                /* LogNewSplit */


/*---------------------------------------------------------------------------*/
void DictT::LogNewChoice(const WERD_CHOICE &WordChoice,
                        FLOAT32 AdjustFactor,
                        const float Certainties[],
                        bool raw_choice) {
/*
 **	Parameters:
 **		Choice		new choice for current word
 **		AdjustFactor	adjustment factor which was applied to choice
 **		Certainties	certainties for each char in new choice
 **		ChoicesList	list with choices seen so far
 **     Variables Used:
 **		best_raw_choice_	best raw choice so far for current word
 **	Operation: This routine adds Choice to ChoicesList if the
 **		adjusted certainty for Choice is within a reasonable range
 **		of the best choice in ChoicesList.  The ChoicesList
 **		list is kept in sorted order by rating. Duplicates are
 **		removed.
 **	Return: none
 **	Exceptions: none
 **	History: Wed May 15 09:57:19 1991, DSJ, Created.
 */
  VIABLE_CHOICE NewChoice;
  LIST ChoicesList;
  LIST Choices;
  FLOAT32 Threshold;

  if (!keep_word_choices_)
    return;

  if (raw_choice) {
    if (!best_raw_choice_)
      best_raw_choice_ = NewViableChoice(WordChoice, AdjustFactor, Certainties);
    else if (WordChoice.rating() < best_raw_choice_->Rating) {
      if (ChoiceSameAs(WordChoice, best_raw_choice_))
        FillViableChoice(WordChoice, AdjustFactor, Certainties, true,
                         best_raw_choice_);
      else {
        memfree(best_raw_choice_);
        best_raw_choice_ =
          NewViableChoice(WordChoice, AdjustFactor, Certainties);
      }
    }
    if (!save_raw_choices) return;
    ChoicesList = raw_choices_;
  } else {
    ChoicesList = best_choices_;
  }

  /* throw out obviously bad choices to save some work */
  if (ChoicesList != NIL) {
    Threshold = AmbigThreshold (BestFactor (ChoicesList), AdjustFactor);
    if (Threshold > -stopper_ambiguity_threshold_offset)
      Threshold = -stopper_ambiguity_threshold_offset;
    if (WordChoice.certainty() - BestCertainty (ChoicesList) < Threshold)
      return;
  }

  /* see if a choice with the same text string has already been found */
  NewChoice = NULL;
  Choices = ChoicesList;

  iterate(Choices) {
    if (ChoiceSameAs (WordChoice, (VIABLE_CHOICE) first_node (Choices))) {
      if (WordChoice.rating() < BestRating (Choices)) {
        NewChoice = (VIABLE_CHOICE) first_node (Choices);
      } else {
        return;
      }
    }
  }

  if (NewChoice) {
    FillViableChoice(WordChoice, AdjustFactor, Certainties, true, NewChoice);
    ChoicesList = delete_d(ChoicesList, NewChoice, is_same_node);
  }
  else {
    NewChoice = NewViableChoice (WordChoice, AdjustFactor, Certainties);
  }

  ChoicesList = s_adjoin (ChoicesList, NewChoice, CmpChoiceRatings);
  if (stopper_debug_level >= 2)
    raw_choice ? PrintViableChoice (stderr, "New Raw Choice:  ", NewChoice) :
      PrintViableChoice (stderr, "New Word Choice:  ", NewChoice);
  if (myCount(ChoicesList) > tessedit_truncate_wordchoice_log) {
    Choices =
      (LIST) nth_cell (ChoicesList, tessedit_truncate_wordchoice_log);
    destroy_nodes (rest (Choices), Efree);
    set_rest(Choices, NIL);
  }

  // Update raw_choices_/best_choices_ pointer.
  if (raw_choice) {
    raw_choices_ = ChoicesList;
  } else {
    best_choices_ = ChoicesList;
  }
}                                /* LogNewChoice */


/*---------------------------------------------------------------------------*/
int DictT::NoDangerousAmbig(WERD_CHOICE *best_choice,
                           DANGERR *fix_pt,
                           bool fix_replaceable,
                           BLOB_CHOICE_LIST_VECTOR *blob_choices,
                           bool *modified_blobs) {
  Q_UNUSED(fix_pt);
  Q_UNUSED(fix_replaceable);
  if (stopper_debug_level > 2) {
    tprintf("\nRunning NoDangerousAmbig() for %s\n",
            best_choice->debug_string(getUnicharset()).string());
  }

  // Construct BLOB_CHOICE_LIST_VECTOR with ambiguities
  // for each unichar id in BestChoice.
  BLOB_CHOICE_LIST_VECTOR ambig_blob_choices;
  int i;
  bool modified_best_choice = false;
  bool ambigs_found = false;
  // For each position in best_choice:
  // -- choose AMBIG_SPEC_LIST that corresponds to unichar_id at best_choice[i]
  // -- initialize wrong_ngram with a single unichar_id at best_choice[i]
  // -- look for ambiguities corresponding to wrong_ngram in the list while
  //    adding the following unichar_ids from best_choice to wrong_ngram
  //
  // Repeat the above procedure twice: first time look through
  // ambigs to be replaced and replace all the ambiguities found;
  // second time look through dangerous ambiguities and construct
  // ambig_blob_choices with fake a blob choice for each ambiguity
  // and pass them to dawg_permute_and_select() to search for
  // ambiguous words in the dictionaries.
  //
  // Note that during the execution of the for loop (on the first pass)
  // if replacements are made the length of best_choice might change.
  for (int pass = 0; pass < 2; ++pass) {
    bool replace = (pass == 0);
    const UnicharAmbigsVector &table = replace ?
      getUnicharAmbigs().replace_ambigs() : getUnicharAmbigs().dang_ambigs();
    if (!replace) {
      // Initialize ambig_blob_choices with lists containing a single
      // unichar id for the correspoding position in best_choice.
      // best_choice consisting from only the original letters will
      // have a rating of 0.0.
      for (i = 0; i < best_choice->length(); ++i) {
        BLOB_CHOICE_LIST *lst = new BLOB_CHOICE_LIST();
        BLOB_CHOICE_IT lst_it(lst);
        lst_it.add_to_end(new BLOB_CHOICE(best_choice->unichar_id(i),
                                          0.0, 0.0, 0, -1));
        ambig_blob_choices.push_back(lst);
      }
    }
    UNICHAR_ID wrong_ngram[MAX_AMBIG_SIZE + 1];
    int wrong_ngram_index;
    int next_index;
    for (i = 0; i < best_choice->length(); ++i) {
      UNICHAR_ID curr_unichar_id = best_choice->unichar_id(i);
      if (stopper_debug_level > 2) {
        tprintf("Looking for %s ngrams starting with %s:\n",
                replace ? "replaceable" : "ambiguous",
                getUnicharset().debug_str(curr_unichar_id).string());
      }
      wrong_ngram_index = 0;
      wrong_ngram[wrong_ngram_index] = curr_unichar_id;
      if (curr_unichar_id == INVALID_UNICHAR_ID ||
          curr_unichar_id >= table.size() ||
          table[curr_unichar_id] == NULL) {
        continue;  // there is no ambig spec for this unichar id
      }
      AmbigSpec_IT spec_it(table[curr_unichar_id]);
      for (spec_it.mark_cycle_pt(); !spec_it.cycled_list();) {
        const AmbigSpec *ambig_spec = spec_it.data();
        wrong_ngram[wrong_ngram_index+1] = INVALID_UNICHAR_ID;
        int compare = UnicharIdArrayUtils::compare(wrong_ngram,
                                                   ambig_spec->wrong_ngram);
        if (stopper_debug_level > 2) {
          tprintf("candidate ngram: ");
          UnicharIdArrayUtils::print(wrong_ngram, getUnicharset());
          tprintf("current ngram from spec: ");
          UnicharIdArrayUtils::print(ambig_spec->wrong_ngram, getUnicharset());
          tprintf("comparison result: %d\n", compare);
        }
        if (compare == 0) {
          if (replace) {
            if (stopper_debug_level > 2) {
              tprintf("replace ambiguity with: ");
              UnicharIdArrayUtils::print(
                  ambig_spec->correct_fragments, getUnicharset());
            }
            ReplaceAmbig(i, ambig_spec->wrong_ngram_size,
                         ambig_spec->correct_ngram_id,
                         best_choice, blob_choices, modified_blobs);
            modified_best_choice = true;
          } else if (i > 0 || ambig_spec->type != CASE_AMBIG) {
            // We found dang ambig - update ambig_blob_choices.
            if (stopper_debug_level > 2) {
              tprintf("found ambiguity: ");
              UnicharIdArrayUtils::print(
                  ambig_spec->correct_fragments, getUnicharset());
            }
            ambigs_found = true;
            for (int tmp_index = 0; tmp_index <= wrong_ngram_index;
                 ++tmp_index) {
              // Add a blob choice for the corresponding fragment of the
              // ambiguity. These fake blob choices are initialized with
              // negative ratings (which are not possible for real blob
              // choices), so that dawg_permute_and_select() considers any
              // word not consisting of only the original letters a better
              // choice and stops searching for alternatives once such a
              // choice is found.
              BLOB_CHOICE_IT bc_it(ambig_blob_choices[i+tmp_index]);
              bc_it.add_to_end(new BLOB_CHOICE(
                  ambig_spec->correct_fragments[tmp_index], -1.0, 0.0, 0, -1));
            }
          }
          spec_it.forward();
        } else if (compare == -1) {
          if (wrong_ngram_index+1 < ambig_spec->wrong_ngram_size &&
              ((next_index = wrong_ngram_index+1+i) < best_choice->length())) {
            // Add the next unichar id to wrong_ngram and keep looking for
            // more ambigs starting with curr_unichar_id in AMBIG_SPEC_LIST.
            wrong_ngram[++wrong_ngram_index] =
              best_choice->unichar_id(next_index);
          } else {
            break;  // no more matching ambigs in this AMBIG_SPEC_LIST
          }
        } else {
          spec_it.forward();
        }
      }  // end searching AmbigSpec_LIST
    }  // end searching best_choice
  }  // end searching replace and dangerous ambigs
  if (modified_best_choice) best_choice->populate_unichars(getUnicharset());
  // If any ambiguities were found permute the constructed ambig_blob_choices
  // to see if an alternative dictionary word can be found.
  if (ambigs_found) {
    if (stopper_debug_level > 2) {
      tprintf("\nResulting ambig_blob_choices:\n");
      for (i = 0; i < ambig_blob_choices.length(); ++i) {
        print_ratings_list("", ambig_blob_choices.get(i), getUnicharset());
        tprintf("\n");
      }
    }
    WERD_CHOICE *alt_word = dawg_permute_and_select(ambig_blob_choices, 0.0);
    ambigs_found = (alt_word->rating() < 0.0);
    if (ambigs_found && stopper_debug_level >= 1) {
      tprintf ("Stopper: Possible ambiguous word = %s\n",
               alt_word->debug_string(getUnicharset()).string());
    }
    delete alt_word;
  }
  ambig_blob_choices.delete_data_pointers();
  return !ambigs_found;
}

void DictT::EndDangerousAmbigs() {}

/*---------------------------------------------------------------------------*/
void DictT::SettupStopperPass1() {
/*
 **	Parameters: none
 **	Variables Used:
 **		reject_offset_	offset allowed before word is rejected
 **	Operation: This routine performs any settup of stopper variables
 **		that is needed in preparation for the first pass.
 **	Return: none
 **	Exceptions: none
 **	History: Mon Jun  3 12:32:00 1991, DSJ, Created.
 */
  reject_offset_ = 0.0;
}                                /* SettupStopperPass1 */


/*---------------------------------------------------------------------------*/
void DictT::SettupStopperPass2() {
/*
 **	Parameters: none
 **	Variables Used:
 **		reject_offset_	offset allowed before word is rejected
 **	Operation: This routine performs any settup of stopper variables
 **		that is needed in preparation for the second pass.
 **	Return: none
 **	Exceptions: none
 **	History: Mon Jun  3 12:32:00 1991, DSJ, Created.
 */
  reject_offset_ = stopper_phase2_certainty_rejection_offset;
}                                /* SettupStopperPass2 */


/**----------------------------------------------------------------------------
              Private Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
void AddNewChunk(VIABLE_CHOICE Choice, int Blob) {
/*
 **	Parameters:
 **		Choice	choice to add a new chunk to
 **		Blob	index of blob being split
 **	Operation: This routine increments the chunk count of the character
 **		in Choice which corresponds to Blob.
 **	Return: none
 **	Exceptions: none
 **	History: Mon May 20 11:43:27 1991, DSJ, Created.
 */
  int i, LastChunk;

  for (i = 0, LastChunk = 0; i < Choice->Length; i++) {
    LastChunk += Choice->Blob[i].NumChunks;
    if (Blob < LastChunk) {
      (Choice->Blob[i].NumChunks)++;
      return;
    }
  }
  mem_tidy (1);
  cprintf ("AddNewChunk failed:Choice->Length=%d, LastChunk=%d, Blob=%d\n",
           Choice->Length, LastChunk, Blob);
  assert(FALSE);  /* this should never get executed */

}                                /* AddNewChunk */


/*---------------------------------------------------------------------------*/
// Replaces the corresponding wrong ngram in werd_choice with the correct one.
// We indicate that this newly inserted ngram unichar is composed from several
// fragments and modify the corresponding entries in blob_choices to contain
// fragments of the correct ngram unichar instead of the original unichars.
// Ratings and certainties of entries in blob_choices and werd_choice are
// unichaged. E.g. for werd_choice mystring'' and ambiguity ''->":
// werd_choice becomes mystring", first ' in blob_choices becomes |"|0|2,
// second one is set to |"|1|2.
void DictT::ReplaceAmbig(int wrong_ngram_begin_index, int wrong_ngram_size,
                        UNICHAR_ID correct_ngram_id, WERD_CHOICE *werd_choice,
                        BLOB_CHOICE_LIST_VECTOR *blob_choices,
                        bool *modified_blobs) {
  int num_blobs_to_replace = 0;
  int begin_blob_index = 0;
  int i;
  for (i = 0; i < wrong_ngram_begin_index + wrong_ngram_size; ++i) {
    if (i >= wrong_ngram_begin_index) {
      num_blobs_to_replace +=  werd_choice->fragment_length(i);
    } else {
      begin_blob_index += werd_choice->fragment_length(i);
    }
  }
  BLOB_CHOICE_IT bit;
  int temp_blob_index = begin_blob_index;
  const char *temp_uch = NULL;
  const char *correct_ngram_str =
    getUnicharset().id_to_unichar(correct_ngram_id);
  for (int replaced_count = 0; replaced_count < wrong_ngram_size;
       ++replaced_count) {
    if (blob_choices != NULL) {
      UNICHAR_ID uch_id = werd_choice->unichar_id(wrong_ngram_begin_index);
      int fraglen = werd_choice->fragment_length(wrong_ngram_begin_index);
      if (fraglen > 1) temp_uch = getUnicharset().id_to_unichar(uch_id);
      for (i = 0; i < fraglen; ++i) {
        if (fraglen > 1) {
          STRING frag_str =
            CHAR_FRAGMENT::to_string(temp_uch, i, fraglen);
          getUnicharset().unichar_insert(frag_str.string());
          uch_id = getUnicharset().unichar_to_id(frag_str.string());
        }
        bit.set_to_list(blob_choices->get(temp_blob_index));
        STRING correct_frag_uch =
          CHAR_FRAGMENT::to_string(correct_ngram_str,
                                   temp_blob_index - begin_blob_index,
                                   num_blobs_to_replace);
        getUnicharset().unichar_insert(correct_frag_uch.string());
        UNICHAR_ID correct_frag_uch_id =
          getUnicharset().unichar_to_id(correct_frag_uch.string());
        // Find the WERD_CHOICE corresponding to the original unichar in
        // the list of blob choices, add the derived character fragment
        // before it with the same rating and certainty.
        for (bit.mark_cycle_pt(); !bit.cycled_list(); bit.forward()) {
          if (bit.data()->unichar_id() == correct_frag_uch_id) {
            break;  // the unichar we want to insert is already there
          }
          if (bit.data()->unichar_id() == uch_id) {
            bit.add_before_then_move(new BLOB_CHOICE(*(bit.data())));
            bit.data()->set_unichar_id(correct_frag_uch_id);
            if (modified_blobs != NULL) *modified_blobs = true;
            break;
          }
        }
        temp_blob_index++;
      }
    }
    // Remove current unichar from werd_choice. On the last iteration
    // set the correct replacement unichar instead of removing a unichar.
    if (replaced_count + 1 == wrong_ngram_size) {
      werd_choice->set_unichar_id(correct_ngram_id,
          num_blobs_to_replace, 0.0, 0.0, wrong_ngram_begin_index);
    } else {
      werd_choice->remove_unichar_id(wrong_ngram_begin_index);
    }
  }
  if (stopper_debug_level >= 1) {
    tprintf("ReplaceAmbigs() modified werd_choice: %s\n",
            werd_choice->debug_string(getUnicharset()).string());
    werd_choice->print();
    if (modified_blobs != NULL && *modified_blobs && blob_choices != NULL) {
      tprintf("Modified blob_choices: ");
      for (int i = 0; i < blob_choices->size(); ++i) {
        print_ratings_list("\n", blob_choices->get(i), getUnicharset());
      }
    }
  }
}


/*---------------------------------------------------------------------------*/
int DictT::ChoiceSameAs(const WERD_CHOICE &WordChoice,
                       VIABLE_CHOICE ViableChoice) {
/*
 **	Parameters:
 **		Choice		choice to compare to ViableChoice
 **		ViableChoice	viable choice to compare to Choice
 **	Operation: This routine compares the corresponding strings of
 **		Choice and ViableChoice and returns TRUE if they are the
 **		same, FALSE otherwise.
 **	Return: TRUE or FALSE.
 **	Exceptions: none
 **	History: Fri May 17 08:48:04 1991, DSJ, Created.
 */
  return (StringSameAs(WordChoice, ViableChoice));

}                                /* ChoiceSameAs */


/*---------------------------------------------------------------------------*/
int CmpChoiceRatings(void *arg1,    //VIABLE_CHOICE                 Choice1,
                     void *arg2) {  //VIABLE_CHOICE                 Choice2)
/*
 **	Parameters:
 **		Choice1, Choice2	choices to compare ratings for
 **	Operation: Return -1 if the rating for Choice1 is less than the
 **		rating for Choice2, otherwise return (1).
 **	Return: -1 or 1
 **	Exceptions: none
 **	History: Wed May 15 13:02:37 1991, DSJ, Created.
 */
  float R1, R2;
  VIABLE_CHOICE Choice1 = (VIABLE_CHOICE) arg1;
  VIABLE_CHOICE Choice2 = (VIABLE_CHOICE) arg2;

  R1 = Choice1->Rating;
  R2 = Choice2->Rating;

  if (R1 < R2)
    return (-1);
  else
    return (1);

}                                /* CmpChoiceRatings */


/*---------------------------------------------------------------------------*/
void ExpandChoice(VIABLE_CHOICE Choice, EXPANDED_CHOICE *ExpandedChoice) {
/*
 **	Parameters:
 **		Choice		choice to be expanded
 **		ExpandedChoice	place to put resulting expanded choice
 **	Operation: This routine expands Choice and places the results
 **		in ExpandedChoice.  The primary function of expansion
 **		is to create an two arrays, one which holds the corresponding
 **		certainty for each chunk in Choice, and one which holds
 **		the class for each chunk.
 **	Return: none (results are placed in ExpandedChoice)
 **	Exceptions: none
 **	History: Fri May 31 15:21:57 1991, DSJ, Created.
 */
  int i, j, Chunk;

  ExpandedChoice->Choice = Choice;
  for (i = 0, Chunk = 0; i < Choice->Length; i++)
  for (j = 0; j < Choice->Blob[i].NumChunks; j++, Chunk++) {
    ExpandedChoice->ChunkCertainty[Chunk] = Choice->Blob[i].Certainty;
    ExpandedChoice->ChunkClass[Chunk] = Choice->Blob[i].Class;
  }
}                                /* ExpandChoice */

/*---------------------------------------------------------------------------*/
int FreeBadChoice(void *item1,    //VIABLE_CHOICE                 Choice,
                  void *item2) {  //EXPANDED_CHOICE                       *BestChoice)
/*
 **	Parameters:
 **		Choice			choice to be tested
 **		BestChoice		best choice found
 **	Variables Used:
 **		stopper_ambiguity_threshold_gain
 **		stopper_ambiguity_threshold_offset
 **	Operation: If the certainty of any chunk in Choice is not ambiguous
 **		with the corresponding chunk in the best choice, free
 **		Choice and return TRUE.  Otherwise, return FALSE.
 **	Return: TRUE or FALSE.
 **	Exceptions: none
 **	History: Wed May 15 13:20:26 1991, DSJ, Created.
 */
  int i, j, Chunk;
  FLOAT32 Threshold;
  VIABLE_CHOICE Choice;
  EXPANDED_CHOICE *BestChoice;

  Choice = (VIABLE_CHOICE) item1;
  BestChoice = (EXPANDED_CHOICE *) item2;

  Threshold = AmbigThreshold (BestChoice->Choice->AdjustFactor,
    Choice->AdjustFactor);

  for (i = 0, Chunk = 0; i < Choice->Length; i++)
    for (j = 0; j < Choice->Blob[i].NumChunks; j++, Chunk++)
      if (Choice->Blob[i].Class != BestChoice->ChunkClass[Chunk] &&
    Choice->Blob[i].Certainty - BestChoice->ChunkCertainty[Chunk] <
      Threshold) {
        memfree(Choice);
    return (TRUE);
  }

  return (FALSE);

}                                /* FreeBadChoice */


/*---------------------------------------------------------------------------*/
int DictT::LengthOfShortestAlphaRun(const WERD_CHOICE &WordChoice) {
/*
 **	Parameters:
 **		Word            word to be tested
 **	Operation: Return the length of the shortest alpha run in Word.
 **	Return:  Return the length of the shortest alpha run in Word.
 **	Exceptions: none
 **	History: Tue May 14 07:50:45 1991, DSJ, Created.
 */
  register int Shortest = MAX_INT32;
  register int Length;
  int x;
  int y;

  for (x = 0; x < WordChoice.length(); ++x) {
    if (getUnicharset().get_isalpha(WordChoice.unichar_id(x))) {
      for (y = x + 1, Length = 1;
           y < WordChoice.length() &&
           getUnicharset().get_isalpha(WordChoice.unichar_id(y));
           ++y, ++Length);
      if (Length < Shortest) {
        Shortest = Length;
      }
      if (y == WordChoice.length()) {
        break;
      }
    }
  }
  if (Shortest == MAX_INT32)
    Shortest = 0;

  return (Shortest);

}                                /* LengthOfShortestAlphaRun */


/*---------------------------------------------------------------------------*/
VIABLE_CHOICE DictT::NewViableChoice(const WERD_CHOICE &WordChoice,
                                    FLOAT32 AdjustFactor,
                                    const float Certainties[]) {
/*
 **	Parameters:
 **		Choice		choice to be converted to a viable choice
 **		AdjustFactor	factor used to adjust ratings for Choice
 **		Certainties	certainty for each character in Choice
 **	Variables Used:
 **		current_segmentation	segmentation corresponding to Choice
 **	Operation: Allocate a new viable choice data structure, copy
 **		Choice, Certainties, and current_segmentation_ into it,
 **		and return a pointer to it.
 **	Return: Ptr to new viable choice.
 **	Exceptions: none
 **	History: Thu May 16 15:28:29 1991, DSJ, Created.
 */
  int Length = WordChoice.length();
  assert (Length <= MAX_NUM_CHUNKS && Length > 0);
  VIABLE_CHOICE NewChoice = (VIABLE_CHOICE) Emalloc (
      sizeof (VIABLE_CHOICE_STRUCT) + (Length - 1) * sizeof (CHAR_CHOICE));
  FillViableChoice(WordChoice, AdjustFactor, Certainties, false, NewChoice);
  return (NewChoice);
}                                /* NewViableChoice */


/*---------------------------------------------------------------------------*/
void DictT::PrintViableChoice(FILE *File, const char *Label, VIABLE_CHOICE Choice) {
/*
 **	Parameters:
 **		File	open text file to print Choice to
 **		Label	text label to be printed with Choice
 **		Choice	choice to be printed
 **	Operation: This routine dumps a text representation of the
 **		specified Choice to File.
 **	Return: none
 **	Exceptions: none
 **	History: Mon May 20 11:16:44 1991, DSJ, Created.
 */
  int i, j;

  fprintf (File, "%s", Label);

  fprintf(File, "(R=%5.1f, C=%4.1f, F=%4.2f, Frag=%d)  ",
    Choice->Rating, Choice->Certainty,
    Choice->AdjustFactor, Choice->ComposedFromCharFragments);

  for (i = 0; i < Choice->Length; i++)
    fprintf(File, "%s", getUnicharset().id_to_unichar(Choice->Blob[i].Class));
  fprintf(File, "\n");

  for (i = 0; i < Choice->Length; i++) {
    fprintf(File, "  %s", getUnicharset().id_to_unichar(Choice->Blob[i].Class));
    for (j = 0; j < Choice->Blob[i].NumChunks - 1; j++)
      fprintf(File, "    ");
  }
  fprintf(File, "\n");

  for (i = 0; i < Choice->Length; i++) {
    for (j = 0; j < Choice->Blob[i].NumChunks; j++)
      fprintf(File, "%3d ", (int) (Choice->Blob[i].Certainty * -10.0));
  }
  fprintf(File, "\n");

  for (i = 0; i < Choice->Length; i++) {
    for (j = 0; j < Choice->Blob[i].NumChunks; j++)
      fprintf(File, "%3d ", Choice->Blob[i].NumChunks);
  }
  fprintf(File, "\n");
}                                /* PrintViableChoice */


/*---------------------------------------------------------------------------*/
void DictT::FillViableChoice(const WERD_CHOICE &WordChoice,
                            FLOAT32 AdjustFactor, const float Certainties[],
                            bool SameString, VIABLE_CHOICE ViableChoice) {
/*
 **	Parameters:
 **		WordChoice 	a choice with info that will be copied
 **		AdjustFactor	factor used to adjust ratings for AChoice
 **		Certainties	certainty for each character in AChoice
 **             SameString      if true the string in the viable choice
 **                             will not be changed
 **		ViableChoice	existing viable choice to fill in
 **	Variables Used:
 **		current_segmentation_	segmentation for NewChoice
 **	Operation:
 **             Fill ViableChoice with information from AChoice,
 **             AdjustFactor, and Certainties.
 **	Return: none
 **	Exceptions: none
 **	History: Fri May 17 13:35:58 1991, DSJ, Created.
 */
  CHAR_CHOICE *NewChar;
  BLOB_WIDTH *BlobWidth;
  int x;

  ViableChoice->Rating = WordChoice.rating();
  ViableChoice->Certainty = WordChoice.certainty();
  ViableChoice->AdjustFactor = AdjustFactor;
  ViableChoice->ComposedFromCharFragments = false;
  if (!SameString) {
    ViableChoice->Length = WordChoice.length();
  }
  for (x = 0,
       NewChar = &(ViableChoice->Blob[0]),
       BlobWidth = current_segmentation_;
       x < WordChoice.length();
       x++, NewChar++, Certainties++, BlobWidth++) {
    if (!SameString) {
      NewChar->Class = WordChoice.unichar_id(x);
    }
    NewChar->NumChunks = *BlobWidth;
    NewChar->Certainty = *Certainties;
    for (int i = 1; i < WordChoice.fragment_length(x); ++i) {
      BlobWidth++;
      assert(*BlobWidth > 0);
      NewChar->NumChunks += *BlobWidth;
      ViableChoice->ComposedFromCharFragments = true;
    }
  }
}                                /* FillViableChoice */


// Compares unichar ids in word_choice to those in viable_choice,
// returns true if they are the same, false otherwise.
bool DictT::StringSameAs(const WERD_CHOICE &WordChoice,
                        VIABLE_CHOICE ViableChoice) {
  if (WordChoice.length() != ViableChoice->Length) {
    return false;
  }
  int i;
  CHAR_CHOICE *CharChoice;
  for (i = 0, CharChoice = &(ViableChoice->Blob[0]);
       i < ViableChoice->Length; CharChoice++, i++) {
    if (CharChoice->Class != WordChoice.unichar_id(i)) {
      return false;
    }
  }
  return true;
}

/*---------------------------------------------------------------------------*/
int DictT::StringSameAs(const char *String,
                       const char *String_lengths,
                       VIABLE_CHOICE ViableChoice) {
/*
 **	Parameters:
 **		String		string to compare to ViableChoice
 **		String_lengths	lengths of unichars in String
 **		ViableChoice	viable choice to compare to String
 **	Operation: This routine compares String to ViableChoice and
 **		returns TRUE if they are the same, FALSE otherwise.
 **	Return: TRUE or FALSE.
 **	Exceptions: none
 **	History: Fri May 17 08:48:04 1991, DSJ, Created.
 */
  CHAR_CHOICE *Char;
  int i;
  int current_unichar_length;

  for (Char = &(ViableChoice->Blob[0]), i = 0;
    i < ViableChoice->Length;
       String += *(String_lengths++), Char++, i++) {
    current_unichar_length = strlen(getUnicharset().id_to_unichar(Char->Class));
  if (current_unichar_length != *String_lengths ||
      strncmp(String, getUnicharset().id_to_unichar(Char->Class),
              current_unichar_length) != 0)
    return (FALSE);
  }

  if (*String == 0)
    return (TRUE);
  else
    return (FALSE);

}                                /* StringSameAs */

/*---------------------------------------------------------------------------*/
int UniformCertainties(const BLOB_CHOICE_LIST_VECTOR &Choices,
                       const WERD_CHOICE &BestChoice) {
/*
 **	Parameters:
 **		Choices		choices for current segmentation
 **		BestChoice	best choice for current segmentation
 **	Variables Used:
 **		stopper_allowable_character_badness
 **             max allowed certainty variation
 **	Operation: This routine returns TRUE if the certainty of the
 **		BestChoice word is within a reasonable range of the average
 **		certainties for the best choices for each character in
 **		the segmentation.  This test is used to catch words in which
 **		one character is much worse than the other characters in
 **		the word (i.e. FALSE will be returned in that case).
 **		The algorithm computes the mean and std deviation of the
 **		certainties in the word with the worst certainty thrown out.
 **	Return: TRUE or FALSE.
 **	Exceptions: none
 **	History: Tue May 14 08:23:21 1991, DSJ, Created.
 */
  float Certainty;
  float WorstCertainty = MAX_FLOAT32;
  float CertaintyThreshold;
  FLOAT64 TotalCertainty;
  FLOAT64 TotalCertaintySquared;
  FLOAT64 Variance;
  FLOAT32 Mean, StdDev;
  int WordLength;

  WordLength = Choices.length();
  if (WordLength < 3)
    return (TRUE);

  TotalCertainty = TotalCertaintySquared = 0.0;
  BLOB_CHOICE_IT BlobChoiceIt;
  for (int i = 0; i < Choices.length(); ++i) {
    BlobChoiceIt.set_to_list(Choices.get(i));
    Certainty = BlobChoiceIt.data()->certainty();
    TotalCertainty += Certainty;
    TotalCertaintySquared += Certainty * Certainty;
    if (Certainty < WorstCertainty)
      WorstCertainty = Certainty;
  }

  /* subtract off worst certainty from statistics */
  WordLength--;
  TotalCertainty -= WorstCertainty;
  TotalCertaintySquared -= WorstCertainty * WorstCertainty;

  Mean = TotalCertainty / WordLength;
  Variance = ((WordLength * TotalCertaintySquared -
    TotalCertainty * TotalCertainty) /
    (WordLength * (WordLength - 1)));
  if (Variance < 0.0)
    Variance = 0.0;
  StdDev = sqrt (Variance);

  CertaintyThreshold = Mean - stopper_allowable_character_badness * StdDev;
  if (CertaintyThreshold > stopper_nondict_certainty_base)
    CertaintyThreshold = stopper_nondict_certainty_base;

  if (BestChoice.certainty() < CertaintyThreshold) {
    if (stopper_debug_level >= 1)
      cprintf("Stopper: Non-uniform certainty = %4.1f"
              " (m=%4.1f, s=%4.1f, t=%4.1f)\n",
              BestChoice.certainty(), Mean, StdDev, CertaintyThreshold);
    return (FALSE);
  } else {
    return (TRUE);
  }
}                                /* UniformCertainties */
//////////////////////////////////////////////////////////////stopper//////////////////////////////////

//////////////////////////////////////////////////////////////permdawg////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
BOOL_VAR(segment_dawg_debug, 0, "Debug mode for word segmentation");

double_VAR(segment_penalty_dict_case_bad, OK_WERD,
           "Default score multiplier for word matches, which may have "
           "case issues (lower is better).");

double_VAR(segment_penalty_dict_case_ok, GOOD_WERD,
           "Score multiplier for word matches that have good case "
           "(lower is better).");

double_VAR(segment_penalty_dict_frequent_word, FREQ_WERD,
           "Score multiplier for word matches which have good case and are "
           "frequent in the given language (lower is better).");

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
static const float kPermDawgRatingPad = 5.0;

/**
 * @name adjust_word
 *
 * Assign an adjusted value to a string that is a word. The value
 * that this word choice has is based on case and punctuation rules.
 */
void DictT::adjust_word(WERD_CHOICE *word,
                       float *certainty_array) {
  float adjust_factor;
  float new_rating = word->rating();

  if (segment_dawg_debug) {
    tprintf("Word: %s %4.2f ",
            word->debug_string(getUnicharset()).string(), word->rating());
  }

  new_rating += RATING_PAD;
  if (Context::case_ok(*word, getUnicharset())) {
    if (freq_dawg_ != NULL && freq_dawg_->word_in_dawg(*word)) {
      word->set_permuter(FREQ_DAWG_PERM);
      new_rating *= segment_penalty_dict_frequent_word;
      adjust_factor = segment_penalty_dict_frequent_word;
      if (segment_dawg_debug)
        tprintf(", F, %4.2f ", (double)segment_penalty_dict_frequent_word);
    } else {
      new_rating *= segment_penalty_dict_case_ok;
      adjust_factor = segment_penalty_dict_case_ok;
      if (segment_dawg_debug)
        tprintf(", %4.2f ", (double)segment_penalty_dict_case_ok);
    }
  } else {
    new_rating *= segment_penalty_dict_case_bad;
    adjust_factor = segment_penalty_dict_case_bad;
    if (segment_dawg_debug) {
      tprintf(", C %4.2f ", (double)segment_penalty_dict_case_bad);
    }
  }
  new_rating -= RATING_PAD;
  word->set_rating(new_rating);

  LogNewChoice(*word, adjust_factor, certainty_array, false);

  if (segment_dawg_debug)
    tprintf(" --> %4.2f\n", new_rating);
}

/**
 * @name go_deeper_dawg_fxn
 *
 * If the choice being composed so far could be a dictionary word
 * keep exploring choices.
 *
 * There are two modes for deciding whether to go deeper: regular dawg
 * permuter mode and the special ambigs mode. If *limit is <= 0.0 the
 * function switches to the ambigs mode (this is the case when
 * dawg_permute_and_select() function is called from NoDangerousAmbigs()) and
 * only searches for the first choice that has a rating better than *limit
 * (in this case ratings are fake, since the real ratings can not be < 0).
 * Modification of the hyphen state is turned off in the ambigs mode.
 * When in the regular dawg permuter mode, the function explores all the
 * possible words and chooses the one with the best rating. The letters with
 * ratings that are far worse than the ones seen so far are pruned out.
 */
void DictT::go_deeper_dawg_fxn(
    const char *debug, const BLOB_CHOICE_LIST_VECTOR &char_choices,
    int char_choice_index,
    const CHAR_FRAGMENT_INFO *prev_char_frag_info,
    bool word_ending, WERD_CHOICE *word, float certainties[],
    float *limit, WERD_CHOICE *best_choice, void *void_more_args) {
  DawgArgs *more_args = reinterpret_cast<DawgArgs*>(void_more_args);
  int word_index = word->length() - 1;

  bool ambigs_mode = (*limit <= 0.0);
  if (ambigs_mode) {
    if (best_choice->rating() < *limit) return;
  } else {
    // Prune bad subwords
    if (more_args->rating_array[word_index] == NO_RATING) {
      more_args->rating_array[word_index] = word->rating();
    } else {
      float permdawg_limit = more_args->rating_array[word_index] *
        more_args->rating_margin + kPermDawgRatingPad;
      if (permdawg_limit < word->rating()) {
        if (segment_dawg_debug) {
          tprintf("early pruned word rating=%4.2f,"
                  " permdawg_limit=%4.2f, word=%s\n", word->rating(),
                  permdawg_limit, word->debug_string(getUnicharset()).string());
        }
        return;
      }
    }
  }
  // Deal with hyphens
  if (word_ending && has_hyphen_end(*word) && !ambigs_mode) {
    if (segment_dawg_debug)
      tprintf("new hyphen choice = %s\n",
              word->debug_string(getUnicharset()).string());
    word->set_permuter(more_args->permuter);
    adjust_word(word, certainties);
    set_hyphen_word(*word, *(more_args->active_dawgs), *(more_args->constraints));
    update_best_choice(*word, best_choice);
  } else {  // Look up char in DAWG
    // TODO(daria): update the rest of the code that specifies alternative
    // letter_is_okay_ functions (e.g. TessCharNgram class) to work with
    // multi-byte unichars and/or unichar ids.

    // If the current unichar is an ngram first try calling
    // letter_is_okay() for each unigram it contains separately.
    UNICHAR_ID orig_uch_id = word->unichar_id(word_index);
    bool checked_unigrams = false;
    if (getUnicharset().get_isngram(orig_uch_id)) {
      if (segment_dawg_debug) {
        tprintf("checking unigrams in an ngram %s\n",
                getUnicharset().debug_str(orig_uch_id).string());
      }
      int orig_num_fragments = word->fragment_length(word_index);
      int num_unigrams = 0;
      word->remove_last_unichar_id();
      const char *ngram_str = getUnicharset().id_to_unichar(orig_uch_id);
      const char *ngram_str_end = ngram_str + strlen(ngram_str);
      const char *ngram_ptr = ngram_str;
      bool unigrams_ok = true;
      // Construct DawgArgs that reflect the current state.
      DawgInfoVector unigram_active_dawgs = *(more_args->active_dawgs);
      DawgInfoVector unigram_constraints = *(more_args->constraints);
      DawgInfoVector unigram_updated_active_dawgs;
      DawgInfoVector unigram_updated_constraints;
      DawgArgs unigram_dawg_args(&unigram_active_dawgs, &unigram_constraints,
                                 &unigram_updated_active_dawgs,
                                 &unigram_updated_constraints, 0.0);
      unigram_dawg_args.permuter = more_args->permuter;
      // Check unigrams in the ngram with letter_is_okay().
      while (unigrams_ok && ngram_ptr < ngram_str_end) {
        int step = getUnicharset().step(ngram_ptr);
        UNICHAR_ID uch_id = (step <= 0) ? INVALID_UNICHAR_ID :
            getUnicharset().unichar_to_id(ngram_ptr, step);
        ngram_ptr += step;
        ++num_unigrams;
        word->append_unichar_id(uch_id, 1, 0.0, 0.0);
        unigrams_ok = unigrams_ok && (this->*letter_is_okay_)(
            &unigram_dawg_args, word_index+num_unigrams-1, word,
            word_ending && (ngram_ptr == ngram_str_end));
        (*unigram_dawg_args.active_dawgs) =
          *(unigram_dawg_args.updated_active_dawgs);
        (*unigram_dawg_args.constraints) =
          *(unigram_dawg_args.updated_constraints);
        if (segment_dawg_debug) {
          tprintf("unigram %s is %s\n",
                  getUnicharset().debug_str(uch_id).string(),
                  unigrams_ok ? "OK" : "not OK");
        }
      }
      // Restore the word and copy the updated dawg state if needed.
      while (num_unigrams-- > 0) word->remove_last_unichar_id();
      word->append_unichar_id_space_allocated(
          orig_uch_id, orig_num_fragments, 0.0, 0.0);
      if (unigrams_ok) {
        checked_unigrams = true;
        more_args->permuter = unigram_dawg_args.permuter;
        *(more_args->updated_active_dawgs) =
          *(unigram_dawg_args.updated_active_dawgs);
        *(more_args->updated_constraints) =
          *(unigram_dawg_args.updated_constraints);
      }
    }

    // Check which dawgs from dawgs_ vector contain the word
    // up to and including the current unichar.
    if (checked_unigrams ||
        (this->*letter_is_okay_)(more_args, word_index, word, word_ending)) {
      // Add a new word choice
      if (word_ending) {
        if (segment_dawg_debug) {
          tprintf("found word = %s\n",
                  word->debug_string(getUnicharset()).string());
        }
        WERD_CHOICE *adjusted_word = word;
        WERD_CHOICE hyphen_tail_word;
        if (!ambigs_mode && hyphen_base_size() > 0) {
          hyphen_tail_word = *word;
          remove_hyphen_head(&hyphen_tail_word);
          adjusted_word = &hyphen_tail_word;
        }
        adjusted_word->set_permuter(more_args->permuter);
        if (!ambigs_mode) {
          adjust_word(adjusted_word, &certainties[hyphen_base_size()]);
        }
        update_best_choice(*adjusted_word, best_choice);
      } else {  // search the next letter
        // Make updated_* point to the next entries in the DawgInfoVector
        // arrays (that were originally created in dawg_permute_and_select)
        ++(more_args->updated_active_dawgs);
        ++(more_args->updated_constraints);
        // Make active_dawgs and constraints point to the updated ones.
        ++(more_args->active_dawgs);
        ++(more_args->constraints);
        permute_choices(debug, char_choices, char_choice_index + 1,
                        prev_char_frag_info, word, certainties, limit,
                        best_choice, more_args);
        // Restore previous state to explore another letter in this position.
        --(more_args->updated_active_dawgs);
        --(more_args->updated_constraints);
        --(more_args->active_dawgs);
        --(more_args->constraints);
      }
    } else {
      if (segment_dawg_debug) {
        tprintf("last unichar not OK at index %d in %s\n",
                word_index, word->debug_string(getUnicharset()).string());
      }
    }
  }
}

/**
 * dawg_permute_and_select
 *
 * Recursively explore all the possible character combinations in
 * the given char_choices. Use go_deeper_dawg_fxn() to search all the
 * dawgs in the dawgs_ vector in parallel and discard invalid words.
 *
 * Allocate and return a WERD_CHOICE with the best valid word found.
 */
WERD_CHOICE *DictT::dawg_permute_and_select(
    const BLOB_CHOICE_LIST_VECTOR &char_choices, float rating_limit) {
  WERD_CHOICE *best_choice = new WERD_CHOICE();
  best_choice->make_bad();
  best_choice->set_rating(rating_limit);
  if (char_choices.length() == 0) return best_choice;
  DawgInfoVector *active_dawgs = new DawgInfoVector[char_choices.length() + 1];
  DawgInfoVector *constraints =  new DawgInfoVector[char_choices.length() + 1];
  init_active_dawgs(&(active_dawgs[0]));
  init_constraints(&(constraints[0]));
  DawgArgs dawg_args(&(active_dawgs[0]), &(constraints[0]),
                     &(active_dawgs[1]), &(constraints[1]),
                     (segment_penalty_dict_case_bad /
                      segment_penalty_dict_case_ok));
  WERD_CHOICE word(MAX_WERD_LENGTH);
  copy_hyphen_info(&word);
  // Discard rating and certainty of the hyphen base (if any).
  word.set_rating(0.0);
  word.set_certainty(0.0);
  if (word.length() + char_choices.length() > MAX_WERD_LENGTH) {
    delete[] active_dawgs;
    delete[] constraints;
    return best_choice;  // the word is too long to permute
  }
  float certainties[MAX_WERD_LENGTH];
  this->go_deeper_fxn_ = &DictT::go_deeper_dawg_fxn;
  permute_choices(segment_dawg_debug ? "segment_dawg_debug" : NULL,
                  char_choices, 0, NULL, &word, certainties,
                  &rating_limit, best_choice, &dawg_args);
  delete[] active_dawgs;
  delete[] constraints;
  return best_choice;
}

/**
 * Fill the given active_dawgs vector with dawgs that could contain the
 * beginning of the word. If hyphenated() returns true, copy the entries
 * from hyphen_active_dawgs_ instead.
 */
void DictT::init_active_dawgs(DawgInfoVector *active_dawgs) {
  int i;
  if (hyphenated()) {
    *active_dawgs = hyphen_active_dawgs_;
    if (dawg_debug_level >= 3) {
      for (i = 0; i < hyphen_active_dawgs_.size(); ++i) {
        tprintf("Adding hyphen beginning dawg [%d, " REFFORMAT "]\n",
                hyphen_active_dawgs_[i].dawg_index,
                hyphen_active_dawgs_[i].ref);
      }
    }
  } else {
    for (i = 0; i < dawgs_.length(); ++i) {
      if (kBeginningDawgsType[(dawgs_[i])->type()]) {
        *active_dawgs += DawgInfo(i, NO_EDGE);
        if (dawg_debug_level >= 3) {
          tprintf("Adding beginning dawg [%d, " REFFORMAT "]\n", i, NO_EDGE);
        }
      }
    }
  }
}

/**
 * If hyphenated() returns true, copy the entries from hyphen_constraints_
 * into the given constraints vector.
 */
void DictT::init_constraints(DawgInfoVector *constraints) {
  if (hyphenated()) {
    *constraints = hyphen_constraints_;
    if (dawg_debug_level >= 3) {
      for (int i = 0; i < hyphen_constraints_.size(); ++i) {
        tprintf("Adding hyphen constraint [%d, " REFFORMAT "]\n",
                hyphen_constraints_[i].dawg_index,
                hyphen_constraints_[i].ref);
      }
    }
  }
}
//////////////////////////////////////////////////////////////permdawg////////////////////////////

//////////////////////////////////////////////////////////////permute////////////////////////////
int permutation_count;           // Used in metrics.cpp.
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
// TODO(tkielbus) Choose a value for the MAX_NUM_EDGES constant
// (or make it dynamic)
#define MAX_NUM_EDGES          2000000
#define MAX_DOC_EDGES          250000
#define MAX_USER_EDGES         50000
                                 /* Weights for adjustment */
#define NON_WERD               1.25
#define GARBAGE_STRING         1.5
#define MAX_PERM_LENGTH        128

// debugging flags
INT_VAR(fragments_debug, 0, "Debug character fragments");

BOOL_VAR(segment_debug, 0, "Debug the whole segmentation process");

BOOL_VAR(permute_debug, 0, "Debug char permutation process");


// control parameters
double_VAR(bestrate_pruning_factor, 2.0,
           "Multiplying factor of current best rate to prune other hypotheses");

BOOL_VAR(permute_script_word, 0,
         "Turn on word script consistency permuter");

BOOL_VAR(segment_segcost_rating, 0,
         "incorporate segmentation cost in word rating?");

double_VAR(segment_reward_script, 0.95,
           "Score multipler for script consistency within a word. "
           "Being a 'reward' factor, it should be <= 1. "
           "Smaller value implies bigger reward.");

double_VAR(segment_penalty_dict_nonword, NON_WERD,
           "Score multiplier for glyph fragment segmentations which do not "
           "match a dictionary word (lower is better).");

double_VAR(segment_penalty_garbage, GARBAGE_STRING,
           "Score multiplier for poorly cased strings that are not in the "
           "dictionary and generally look like garbage (lower is better).");

BOOL_VAR(save_doc_words, 0, "Save Document Words");

BOOL_VAR(doc_dict_enable, 1, "Enable Document Dictionary ");

BOOL_VAR(ngram_permuter_activated, FALSE,
         "Activate character-level n-gram-based permuter");

STRING_VAR(global_user_words_suffix, "user-words", "A list of user-provided words.");

// This is an ugly way to incorporate segmentation cost in word rating.
// See comments in incorporate_segcost.
float wordseg_rating_adjust_factor;

int permute_only_top = 0;

#define SIM_CERTAINTY_SCALE  -10.0   /*< Similarity matcher values */
#define SIM_CERTAINTY_OFFSET -10.0   /*< Similarity matcher values */
#define SIMILARITY_FLOOR     100.0   /*< Worst E*L product to stop on */

// TODO(daria): If hyphens are different in different languages and can be
// inferred from training data we should load their values dynamically.
static const char kHyphenSymbol[] = "-";

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/

/**
 * get_best_delete_other
 *
 * Returns the best of two choices and deletes the other (worse) choice.
 * A choice is better if it has a non-empty string and has a lower
 * rating than the other choice. If the ratings are the same,
 * choice2 is preferred over choice1.
 */
WERD_CHOICE *get_best_delete_other(WERD_CHOICE *choice1,
                                   WERD_CHOICE *choice2) {
  if (!choice1) return choice2;
  if (!choice2) return choice1;
  if (choice1->rating() < choice2->rating() || choice2->length() == 0) {
    delete choice2;
    return choice1;
  } else {
    delete choice1;
    return choice2;
  }
}


/**
 * good_choice
 *
 * Return TRUE if a good answer is found for the unknown blob rating.
 */
int good_choice(const WERD_CHOICE &choice) {
  register float certainty;
  if (tord_similarity_enable) {
    if ((choice.rating() + 1) * choice.certainty() > SIMILARITY_FLOOR)
      return false;
    certainty =
      SIM_CERTAINTY_OFFSET + choice.rating() * SIM_CERTAINTY_SCALE;
  } else {
    certainty = choice.certainty();
  }

  return (certainty > tord_certainty_threshold) ? true : false;
}

/**
 * add_document_word
 *
 * Add a word found on this document to the document specific
 * dictionary.
 */
void DictT::add_document_word(const WERD_CHOICE &best_choice) {
  // Do not add hyphenated word parts to the document dawg.
  // hyphen_word_ will be non-NULL after the set_hyphen_word() is
  // called when the first part of the hyphenated word is
  // discovered and while the second part of the word is recognized.
  // hyphen_word_ is cleared in cc_recg() before the next word on
  // the line is recognized.
  if (hyphen_word_) return;

  char filename[CHARS_PER_LINE];
  FILE *doc_word_file;
  int stringlen = best_choice.length();

  if (!doc_dict_enable || valid_word(best_choice) ||
      CurrentWordAmbig() || stringlen < 2)
    return;

  if (!good_choice(best_choice) || stringlen == 2) {
    if (best_choice.certainty() < permuter_pending_threshold)
      return;

    if (!pending_words_->word_in_dawg(best_choice)) {
      if (stringlen > 2 ||
          (stringlen == 2 &&
           getUnicharset().get_isupper(best_choice.unichar_id(0)) &&
           getUnicharset().get_isupper(best_choice.unichar_id(1)))) {
        pending_words_->add_word_to_dawg(best_choice);
      }
      return;
    }
  }

  if (save_doc_words) {
    strcpy(filename, getImage()->getCCUtil()->imagefile.string());
    strcat (filename, ".doc");
    doc_word_file = open_file (filename, "a");
    fprintf (doc_word_file, "%s\n",
             best_choice.debug_string(getUnicharset()).string());
    fclose(doc_word_file);
  }
  document_words_->add_word_to_dawg(best_choice);
}


/**
 * adjust_non_word
 *
 * Assign an adjusted value to a string that is a non-word.  The value
 * that this word choice has is based on case and punctuation rules.
 * The adjustment value applied is stored in adjust_factor upon return.
 */
void DictT::adjust_non_word(WERD_CHOICE *word, float *adjust_factor) {
  float new_rating;
  if (permute_debug)
    cprintf("Non-word: %s %4.2f ",
            word->debug_string(getUnicharset()).string(), word->rating());

  new_rating = word->rating() + RATING_PAD;
  if (Context::case_ok(*word, getUnicharset()) && valid_punctuation(*word)) {
    new_rating *= segment_penalty_dict_nonword;
    *adjust_factor = segment_penalty_dict_nonword;
    if (permute_debug) tprintf(", W");
  } else {
    new_rating *= segment_penalty_garbage;
    *adjust_factor = segment_penalty_garbage;
    if (permute_debug) {
      if (!Context::case_ok(*word, getUnicharset())) tprintf(", C");
      if (!valid_punctuation(*word)) tprintf(", P");
    }
  }
  new_rating -= RATING_PAD;
  word->set_rating(new_rating);
  if (permute_debug)
    cprintf (" %4.2f --> %4.2f\n", *adjust_factor, new_rating);
}


/**
 * init_permute
 *
 * Initialize anything that needs to be set up for the permute
 * functions.
 */
void DictT::init_permute() {
  STRING name;
  STRING &lang = getImage()->getCCUtil()->lang;

  if (dawgs_.length() != 0) end_permute();

  hyphen_unichar_id_ = getUnicharset().unichar_to_id(kHyphenSymbol);
  TessdataManager &tessdata_manager =
    getImage()->getCCUtil()->tessdata_manager;

  // Load dawgs_.
  if (global_load_punc_dawg &&
      tessdata_manager.SeekToStart(TESSDATA_PUNC_DAWG)) {
    dawgs_ += new SquishedDawg(tessdata_manager.GetDataFilePtr(),
                               DAWG_TYPE_PUNCTUATION, lang, PUNC_PERM);
  }
  if (global_load_system_dawg &&
      tessdata_manager.SeekToStart(TESSDATA_SYSTEM_DAWG)) {
    dawgs_ += new SquishedDawg(tessdata_manager.GetDataFilePtr(),
                               DAWG_TYPE_WORD, lang, SYSTEM_DAWG_PERM);
  }
  if (global_load_number_dawg &&
      tessdata_manager.SeekToStart(TESSDATA_NUMBER_DAWG)) {
    dawgs_ +=
      new SquishedDawg(tessdata_manager.GetDataFilePtr(),
                       DAWG_TYPE_NUMBER, lang, NUMBER_PERM);
  }
  if (((STRING &)global_user_words_suffix).length() > 0) {
    name = getImage()->getCCUtil()->language_data_path_prefix;
    name += global_user_words_suffix;
    if (exists_file(name.string())) {
      Trie *trie_ptr = new Trie(DAWG_TYPE_WORD, lang, USER_DAWG_PERM,
                                MAX_USER_EDGES, getUnicharset().size());
      if (!trie_ptr->read_word_list(name.string(), getUnicharset())) {
        tprintf("Error: failed to load %s\n", name.string());
        exit(1);
      }
      dawgs_ += trie_ptr;
    }
  }
  document_words_ = new Trie(DAWG_TYPE_WORD, lang, DOC_DAWG_PERM,
                             MAX_DOC_EDGES, getUnicharset().size());
  dawgs_ += document_words_;

  // This dawg is temporary and should not be searched by letter_is_ok.
  pending_words_ = new Trie(DAWG_TYPE_WORD, lang, NO_PERM,
                            MAX_DOC_EDGES, getUnicharset().size());

  // The frequent words dawg is only searched when a word
  // is found in any of the other dawgs.
  if (tessdata_manager.SeekToStart(TESSDATA_FREQ_DAWG)) {
    freq_dawg_ = new SquishedDawg(tessdata_manager.GetDataFilePtr(),
                                  DAWG_TYPE_WORD, lang, FREQ_DAWG_PERM);
  }

  // Construct a list of corresponding successors for each dawg. Each entry i
  // in the successors_ vector is a vector of integers that represent the
  // indices into the dawgs_ vector of the successors for dawg i.
  successors_.reserve(dawgs_.length());
  for (int i = 0; i < dawgs_.length(); ++i) {
    const Dawg *dawg = dawgs_[i];
    SuccessorList *lst = new SuccessorList();
    for (int j = 0; j < dawgs_.length(); ++j) {
      const Dawg *other = dawgs_[j];
      if (dawg->lang() == other->lang() &&
          kDawgSuccessors[dawg->type()][other->type()]) *lst += j;
    }
    successors_ += lst;
  }
}

void DictT::end_permute() {
  if (dawgs_.length() == 0)
    return;  // Not safe to call twice.
  dawgs_.delete_data_pointers();
  successors_.delete_data_pointers();
  dawgs_.clear();
  successors_.clear();
  document_words_ = NULL;
  if (pending_words_ != NULL) delete pending_words_;
  pending_words_ = NULL;
  if (freq_dawg_ != NULL) delete freq_dawg_;
  freq_dawg_ = NULL;
}


/**
 * permute_all
 *
 * Permute all the characters together using all of the different types
 * of permuters/selectors available.  Each of the characters must have
 * a non-NULL choice list.
 *
 * Note: order of applying permuters does matter, since the latter
 * permuter will be recorded if the resulting word ratings are the same.
 */
WERD_CHOICE *DictT::permute_all(const BLOB_CHOICE_LIST_VECTOR &char_choices,
                               float rating_limit,
                               WERD_CHOICE *raw_choice) {
  WERD_CHOICE *result1;
  WERD_CHOICE *result2 = NULL;
  BOOL8 any_alpha;
  float top_choice_rating_limit = rating_limit;

  // Initialize result1 from the result of permute_top_choice.
  result1 = permute_top_choice(char_choices, &top_choice_rating_limit,
                               raw_choice, &any_alpha);

  // Enforce script consistency within a word on some scripts
  if (permute_script_word &&
      !word_script_eq(char_choices, getUnicharset().common_sid()) &&
      !word_script_eq(char_choices, getUnicharset().latin_sid())) {
    result2 = permute_script_words(char_choices);
    // TODO(dsl): incorporate segmentation cost into word rating.
    // This should only be turned on for scripts that we have a segmentation
    // cost model for, such as CJK.
    if (segment_segcost_rating)
      incorporate_segcost(result2);
    result1 = get_best_delete_other(result1, result2);
  }

  // Permute character fragments if necessary.
  if (result1 == NULL || result1->fragment_mark()) {
    result2 = top_fragments_permute_and_select(char_choices,
                                               top_choice_rating_limit);
    result1 = get_best_delete_other(result1, result2);
  }

  // TODO(daria): update ngram permuter code.
  if (ngram_permuter_activated) {
    tprintf("Error: ngram permuter functionality is not available\n");
    exit(1);
    // A_CHOICE *ngram_choice =
    //  ngram_permute_and_select(old_char_choices, rating_limit, word_dawg_);
    // return ngram_choice;
  }

  if (result1 == NULL)
    return (NULL);
  if (permute_only_top)
    return result1;

  result2 = dawg_permute_and_select(char_choices, rating_limit);
  result1 = get_best_delete_other(result1, result2);

  result2 = permute_compound_words(char_choices, rating_limit);
  result1 = get_best_delete_other(result1, result2);

  return (result1);
}

/** Returns the top choice char id.  A helper function to make code cleaner. */
UNICHAR_ID get_top_choice_uid(BLOB_CHOICE_LIST *blob_list) {
  BLOB_CHOICE_IT blob_choice_it;
  blob_choice_it.set_to_list(blob_list);
  return (blob_choice_it.data()) ? blob_choice_it.data()->unichar_id()
                                 : INVALID_UNICHAR_ID;
}

/**
 * Return the "dominant" script ID for the word.  By "dominant", the script
 * must account for at least half the characters.  Otherwise, it returns 0.
 */
int get_top_word_script(const BLOB_CHOICE_LIST_VECTOR &char_choices,
                        const UNICHARSET &unicharset) {
  int max_script = unicharset.get_script_table_size();
  int *sid = new int[max_script];
  int x;
  for (x = 0; x < max_script; x++) sid[x] = 0;
  for (x = 0; x < char_choices.length(); ++x) {
    BLOB_CHOICE_IT blob_choice_it;
    blob_choice_it.set_to_list(char_choices.get(x));
    sid[blob_choice_it.data()->script_id()]++;
  }
  // Note that high script ID overrides lower one on a tie, thus biasing
  // towards non-Common script (if sorted that way in unicharset file).
  int max_sid = 0;
  for (x = 1; x < max_script; x++)
    if (sid[x] >= sid[max_sid]) max_sid = x;
  if (sid[max_sid] < char_choices.length() / 2)
    max_sid = unicharset.null_sid();
  delete[] sid;
  return max_sid;
}

/**
 * Checks whether the dominant word script, if there is one, matches
 * the given target script ID.
 */
bool DictT::word_script_eq(const BLOB_CHOICE_LIST_VECTOR &char_choices,
                          int target_sid) {
  int max_sid = get_top_word_script(char_choices, getUnicharset());
  // If "Latin" is not a loaded script, then latin_sid() would return 0.
  // max_sid could also be 0 if there is no dominant script.
  // This is faster than
  // strcmp(getUnicharset().get_script_from_script_id(max_sid), "Latin")
  return (max_sid > 0 && max_sid == target_sid);
}

/**
 * Iterate through all the character choices (for a single blob) and
 * return the first that matches the given type, which is one of 'aA0px*',
 * for lower, upper, digit, punctuation, other, and 'any', respectively.
 * If not match is found, a NULL is returned.
 */
BLOB_CHOICE* find_choice_by_type(
    BLOB_CHOICE_LIST *char_choices,
    char target_type,
    const UNICHARSET &unicharset) {
  BLOB_CHOICE_IT c_it;
  c_it.set_to_list(char_choices);
  for (c_it.mark_cycle_pt(); !c_it.cycled_list(); c_it.forward()) {
    bool found = false;
    UNICHAR_ID unichar_id = c_it.data()->unichar_id();
    switch (target_type) {
      case '*': found = true;  break;
      case 'A': found = unicharset.get_isupper(unichar_id); break;
      case 'a': found = unicharset.get_islower(unichar_id); break;
      case '0': found = unicharset.get_isdigit(unichar_id); break;
      case 'p': found = unicharset.get_ispunctuation(unichar_id); break;
      case 'x': found = !unicharset.get_isupper(unichar_id) &&
                        !unicharset.get_islower(unichar_id) &&
                        !unicharset.get_isdigit(unichar_id) &&
                        !unicharset.get_ispunctuation(unichar_id);
                break;
    }
    if (found) return c_it.data();
  }
  return NULL;
}

/**
 * Iterate through all the character choices (for a single blob) and
 * return the first that matches the target script ID.  If backup_sid
 * is not 0, then a match on either the target or backup sid is allowed.
 * Note that there is no preference between a target or backup sid.
 * To search for another sid only if no target_sid matched, use
 * secondary_sid.
 * So for example, to find first Han or Common char choice, do
 *   find_choice_by_script(cchoice, han_sid, common_sid, 0);
 * To find first Han choice, but allow Common if none is found, do
 *   find_choice_by_script(cchoice, han_sid, 0, common_sid);
 */
BLOB_CHOICE* find_choice_by_script(
    BLOB_CHOICE_LIST *char_choices,
    int target_sid,
    int backup_sid,
    int secondary_sid) {
  BLOB_CHOICE_IT c_it;
  c_it.set_to_list(char_choices);
  for (c_it.mark_cycle_pt(); !c_it.cycled_list(); c_it.forward()) {
    bool found = false;
    if (c_it.data()->script_id() == 0) continue;
    if (c_it.data()->script_id() == target_sid) found = true;
    if (backup_sid > 0 && c_it.data()->script_id() == backup_sid) found = true;
    if (found) return c_it.data();
  }
  if (secondary_sid > 0) {
    c_it.set_to_list(char_choices);
    for (c_it.mark_cycle_pt(); !c_it.cycled_list(); c_it.forward()) {
      if (c_it.data()->script_id() == 0) continue;
      if (c_it.data()->script_id() == secondary_sid)
        return c_it.data();
    }
  }
  return NULL;
}

/**
 * Incorporate segmentation cost into the word rating.  This is done
 * through a mutliplier wordseg_rating_adjust_factor which is determined
 * in bestfirst.cpp during state evaluation.  This is not the cleanest
 * way to do this.  It would be better to reorganize the SEARCH_STATE
 * to keep track of associated states, or do the rating adjustment
 * outside the permuter in evalaute_state.
 */
void DictT::incorporate_segcost(WERD_CHOICE *word) {
  if (!word || wordseg_rating_adjust_factor <= 0) return;

  float old_rating = word->rating();
  float new_rating = old_rating * wordseg_rating_adjust_factor;
  word->set_rating(new_rating);
  if (permute_debug)
    tprintf("Permute segadjust %f * %f --> %f\n",
            old_rating, wordseg_rating_adjust_factor, new_rating);
}

/**
 * Try flipping characters in a word to get better script consistency.
 * Similar to how upper/lower case checking is done in top_choice_permuter,
 * this permuter tries to suggest a more script-consistent choice AND
 * modifieds the rating.  So it combines both the case_ok check and
 * adjust_non_word functionality.  However, instead of penalizing an
 * inconsistent word with a > 1 multiplier, we reward the script-consistent
 * choice with a < 1 multiplier.
 */
WERD_CHOICE* DictT::permute_script_words(
    const BLOB_CHOICE_LIST_VECTOR &char_choices) {
  if (char_choices.length() > MAX_WERD_LENGTH)
    return NULL;

  int word_sid = get_top_word_script(char_choices, getUnicharset());
  if (word_sid == getUnicharset().null_sid())
    return NULL;

  if (permute_debug) {
    tprintf("\n\nPermuteScript %s\n",
            getUnicharset().get_script_from_script_id(word_sid));
    print_char_choices_list("", char_choices, getUnicharset(),
                            permute_debug > 1);
  }

  WERD_CHOICE *current_word = new WERD_CHOICE(MAX_WERD_LENGTH);
  BLOB_CHOICE_IT blob_choice_it;
  bool replaced = false;
  bool prev_is_consistent = false;
  for (int x = 0; x < char_choices.length(); ++x) {
    blob_choice_it.set_to_list(char_choices.get(x));
    BLOB_CHOICE *first_choice = blob_choice_it.data();
    if (!first_choice) return NULL;
    UNICHAR_ID unichar_id = first_choice->unichar_id();
    bool sid_consistent = (first_choice->script_id() == word_sid);
    bool this_is_punct = getUnicharset().get_ispunctuation(unichar_id);

    if (!sid_consistent && !this_is_punct && prev_is_consistent) {
      // If the previous char is CJK, we prefer a cjk over non-cjk char
      if (permute_debug) {
        tprintf("Checking %s r%g\n", getUnicharset().id_to_unichar(unichar_id),
                                     first_choice->rating());
        print_ratings_list("\t", char_choices.get(x), getUnicharset());
      }
      // prefer a script consistent choice
      BLOB_CHOICE* c_it = find_choice_by_script(char_choices.get(x),
                                                word_sid, 0, 0);
      // make this a separate check
      // otherwise, prefer a punctuation
      if (c_it == NULL)
        c_it = find_choice_by_type(char_choices.get(x), 'p', getUnicharset());

      if (c_it != NULL) {
        if (permute_debug)
          tprintf("Replacing %d r%g ==> %d r%g\n",
                  first_choice->unichar_id(), first_choice->rating(),
                  c_it->unichar_id(), c_it->rating());
        first_choice = c_it;
        replaced = true;
      }
    }
    current_word->append_unichar_id_space_allocated(
      first_choice->unichar_id(), 1,
      first_choice->rating(), first_choice->certainty());
    prev_is_consistent = sid_consistent;
  }
  if (replaced) {
    // When we replace a word choice (usually top choice) with
    // another for the sake of script consistency, we need to improve its
    // rating so that it will replace the best choice.  How much we modify
    // the rating determines how strong is the script consistency constraint.
    // We need a more consistent solution for all contextual constraints
    // like case, punct pattern, script, etc.  Right now, this does the same
    // thing as adjust_non_words for case and punctuation rules.
    float rating = current_word->rating();
    rating *= segment_reward_script;
    current_word->set_rating(rating);
  }
  current_word->populate_unichars(getUnicharset());
  if (permute_debug && replaced)
    current_word->print("<== permute_script_word **");
  return current_word;
}

/**
 * permute_characters
 *
 * Permute these characters together according to each of the different
 * permuters that are enabled.
 */
void DictT::permute_characters(const BLOB_CHOICE_LIST_VECTOR &char_choices,
                              float limit,
                              WERD_CHOICE *best_choice,
                              WERD_CHOICE *raw_choice) {
  float old_raw_choice_rating = raw_choice->rating();
  permutation_count++;           /* Global counter */
  if (tord_display_ratings > 1) {
    cprintf("\nchar_choices in permute_characters:\n");
    print_char_choices_list("\n==> Input CharChoices", char_choices,
                            getUnicharset(), true);
  }

  if (char_choices.length() == 1 &&
      get_top_choice_uid(char_choices.get(0)) == 0)
    return;
  WERD_CHOICE *this_choice = permute_all(char_choices, limit, raw_choice);

  if (raw_choice->rating() < old_raw_choice_rating) {
    // Populate unichars_ and unichar_lengths_ of raw_choice. This is
    // needed for various components that still work with unichars rather
    // than unichar ids (e.g. AdaptToWord).
    raw_choice->populate_unichars(getUnicharset());
  }
  if (this_choice && this_choice->rating() < best_choice->rating()) {
    *best_choice = *this_choice;
    // Populate unichars_ and unichar_lengths_ of best_choice. This is
    // needed for various components that still work with unichars rather
    // than unichar ids (dawg, *_ok functions, various hard-coded hacks).
    best_choice->populate_unichars(getUnicharset());

    if (tord_display_ratings) {
      cprintf("permute_characters: %s\n",
              best_choice->debug_string(getUnicharset()).string());
    }
  }
  delete this_choice;
}

/**
 * permute_compound_words
 *
 * Return the top choice for each character as the choice for the word.
 */
WERD_CHOICE *DictT::permute_compound_words(
    const BLOB_CHOICE_LIST_VECTOR &char_choices,
    float rating_limit) {
  BLOB_CHOICE *first_choice;
  WERD_CHOICE *best_choice = NULL;
  WERD_CHOICE current_word(MAX_WERD_LENGTH);
  int first_index = 0;
  int x;
  BLOB_CHOICE_IT blob_choice_it;

  if (char_choices.length() > MAX_WERD_LENGTH) {
    WERD_CHOICE *bad_word_choice = new WERD_CHOICE();
    bad_word_choice->make_bad();
    return bad_word_choice;
  }

  UNICHAR_ID slash = getUnicharset().unichar_to_id("/");
  UNICHAR_ID dash = getUnicharset().unichar_to_id("-");
  for (x = 0; x < char_choices.length(); ++x) {
    blob_choice_it.set_to_list(char_choices.get(x));
    first_choice = blob_choice_it.data();
    if (first_choice->unichar_id() == slash ||
        first_choice->unichar_id() == dash) {
      if (x > first_index) {
        if (segment_debug)
          cprintf ("Hyphenated word found\n");
        permute_subword(char_choices, rating_limit, first_index,
                        x - 1, &current_word);
        if (current_word.rating() > rating_limit)
          break;
      }
      // Append hyphen/slash separator to current_word.
      current_word.append_unichar_id_space_allocated(
          first_choice->unichar_id(), 1,
          first_choice->rating(), first_choice->certainty());

      first_index = x + 1;  // update first_index
    }
  }

  if (first_index > 0 && first_index < x &&
      current_word.rating() <= rating_limit) {
    permute_subword(char_choices, rating_limit, first_index,
                    x - 1, &current_word);
    current_word.populate_unichars(getUnicharset());
    best_choice = new WERD_CHOICE(current_word);
    best_choice->set_permuter(COMPOUND_PERM);
  }
  return (best_choice);
}


/**
 * permute_subword
 *
 * Permute a part of a compound word this subword is bounded by hyphens
 * and the start and end of the word.  Call the standard word permute
 * function on a set of choices covering only part of the original
 * word.  When it is done reclaim the memory that was used in the
 * excercise.
 */
void DictT::permute_subword(const BLOB_CHOICE_LIST_VECTOR &char_choices,
                           float rating_limit,
                           int start,
                           int end,
                           WERD_CHOICE *current_word) {
  int x;
  BLOB_CHOICE_LIST_VECTOR subchoices;
  WERD_CHOICE *best_choice = NULL;
  WERD_CHOICE raw_choice;
  raw_choice.make_bad();

  DisableChoiceAccum();

  for (x = start; x <= end; x++) {
    if (char_choices.get(x) != NULL) {
      subchoices += char_choices.get(x);
    }
  }

  if (!subchoices.empty()) {
    bool old_segment_dawg_debug = segment_dawg_debug;
    if (segment_debug) segment_dawg_debug.set_value(true);
    best_choice = permute_all(subchoices, rating_limit, &raw_choice);

    if (segment_debug) {
      segment_dawg_debug.set_value(old_segment_dawg_debug);
    }
    if (best_choice && best_choice->length() > 0) {
      *current_word += *best_choice;
    } else {
      current_word->set_rating(MAX_FLOAT32);
    }
  } else {
    current_word->set_rating(MAX_FLOAT32);
  }

  if (best_choice)
    delete best_choice;

  if (segment_debug && current_word->rating() < MAX_FLOAT32) {
    cprintf ("Subword permuted = %s, %5.2f, %5.2f\n\n",
             current_word->debug_string(getUnicharset()).string(),
             current_word->rating(), current_word->certainty());
  }

  EnableChoiceAccum();
}

/**
 * permute_top_choice
 *
 * Return the top choice for each character as the choice for the word.
 * In addition a choice is created for the best lower and upper case
 * non-words.  In each character position the best lower (or upper) case
 * character is substituted for the best overall character.
 */
WERD_CHOICE *DictT::permute_top_choice(
    const BLOB_CHOICE_LIST_VECTOR &char_choices,
    float* rating_limit,
    WERD_CHOICE *raw_choice,
    BOOL8 *any_alpha) {
  BLOB_CHOICE *first_choice;
  const char *first_char;             //first choice
  const char *second_char;            //second choice
  const char *third_char;             //third choice
  char prev_char[UNICHAR_LEN + 1];    //prev in word
  const char *next_char = "";         //next in word
  const char *next_next_char = "";    //after next next in word

  WERD_CHOICE word(MAX_PERM_LENGTH);
  word.set_permuter(TOP_CHOICE_PERM);
  WERD_CHOICE capital_word(MAX_PERM_LENGTH);
  capital_word.set_permuter(UPPER_CASE_PERM);
  WERD_CHOICE lower_word(MAX_PERM_LENGTH);
  lower_word.set_permuter(LOWER_CASE_PERM);

  int x;
  BOOL8 char_alpha;
  float first_rating = 0;
  float adjust_factor;

  float certainties[MAX_PERM_LENGTH + 1];
  float lower_certainties[MAX_PERM_LENGTH + 1];
  float upper_certainties[MAX_PERM_LENGTH + 1];

  BLOB_CHOICE_IT blob_choice_it;
  UNICHAR_ID temp_id;
  UNICHAR_ID unichar_id;
  UNICHAR_ID space = getUnicharset().unichar_to_id(" ");
  register const char* ch;
  register inT8 lower_done;
  register inT8 upper_done;

  prev_char[0] = '\0';

  if (any_alpha != NULL)
    *any_alpha = FALSE;

  if (char_choices.length() > MAX_PERM_LENGTH) {
    return (NULL);
  }

  for (x = 0; x < char_choices.length(); ++x) {
    if (x + 1 < char_choices.length()) {
      unichar_id = get_top_choice_uid(char_choices.get(x+1));
      next_char = unichar_id != INVALID_UNICHAR_ID ?
        getUnicharset().id_to_unichar(unichar_id) : "";
    } else {
      next_char = "";
    }

    if (x + 2 < char_choices.length()) {
      unichar_id = get_top_choice_uid(char_choices.get(x+2));
      next_next_char = unichar_id != INVALID_UNICHAR_ID ?
        getUnicharset().id_to_unichar(unichar_id) : "";
    } else {
      next_next_char = "";
    }

    blob_choice_it.set_to_list(char_choices.get(x));
    ASSERT_HOST(!blob_choice_it.empty());
    first_choice = NULL;
    for (blob_choice_it.mark_cycle_pt(); !blob_choice_it.cycled_list();
         blob_choice_it.forward()) {  // find the best non-fragment char choice
      temp_id = blob_choice_it.data()->unichar_id();
      if (!(getUnicharset().get_fragment(temp_id))) {
        first_choice = blob_choice_it.data();
        break;
      } else if (char_choices.length() > 1) {
        word.set_fragment_mark(true);
        capital_word.set_fragment_mark(true);
        lower_word.set_fragment_mark(true);
      }
    }
    if (first_choice == NULL) {
      cprintf("Permuter found only fragments for"
              " character at position %d; word=%s\n",
              x, word.debug_string(getUnicharset()).string());
    }
    ASSERT_HOST(first_choice != NULL);

    unichar_id = first_choice->unichar_id() != INVALID_UNICHAR_ID ?
      first_choice->unichar_id() : space;
    first_char = getUnicharset().id_to_unichar(unichar_id);
    first_rating = first_choice->rating();
    word.append_unichar_id_space_allocated(
        unichar_id, 1, first_choice->rating(), first_choice->certainty());
    capital_word.append_unichar_id_space_allocated(
        unichar_id, 1, first_choice->rating(), first_choice->certainty());
    lower_word.append_unichar_id_space_allocated(
        unichar_id, 1, first_choice->rating(), first_choice->certainty());

    certainties[x] = first_choice->certainty();
    lower_certainties[x] = first_choice->certainty();
    upper_certainties[x] = first_choice->certainty();

    lower_done = FALSE;
    upper_done = FALSE;
    char_alpha = FALSE;
    second_char = "";
    third_char = "";
    for (; !blob_choice_it.cycled_list(); blob_choice_it.forward()) {
      unichar_id = blob_choice_it.data()->unichar_id();
      if (getUnicharset().eq(unichar_id, "l") && !blob_choice_it.at_last() &&
          blob_choice_it.data_relative(1)->rating() == first_rating) {
        temp_id = blob_choice_it.data_relative(1)->unichar_id();
        if (getUnicharset().eq(temp_id, "1") ||
            getUnicharset().eq(temp_id, "I")) {
          second_char = getUnicharset().id_to_unichar(temp_id);
          blob_choice_it.forward();
          if (!blob_choice_it.at_last() &&
              blob_choice_it.data_relative(1)->rating() == first_rating) {
            temp_id = blob_choice_it.data_relative(1)->unichar_id();
            if (getUnicharset().eq(temp_id, "1") ||
                getUnicharset().eq(temp_id, "I")) {
              third_char = getUnicharset().id_to_unichar(temp_id);
              blob_choice_it.forward();
            }
          }
          ch = choose_il1 (first_char, second_char, third_char,
            prev_char, next_char, next_next_char);
          unichar_id = (ch != NULL && *ch != '\0') ?
            getUnicharset().unichar_to_id(ch) : INVALID_UNICHAR_ID;
          if (strcmp(ch, "l") != 0 &&
              getUnicharset().eq(word.unichar_id(x), "l")) {
            word.set_unichar_id(unichar_id, x);
            lower_word.set_unichar_id(unichar_id, x);
            capital_word.set_unichar_id(unichar_id, x);
          }
        }
      }
      if (unichar_id != INVALID_UNICHAR_ID) {
        /* Find lower case */
        if (!lower_done &&
            (getUnicharset().get_islower(unichar_id) ||
             (getUnicharset().get_isupper(unichar_id) && x == 0))) {
          lower_word.set_unichar_id(unichar_id, x);
          lower_word.set_rating(lower_word.rating() -
            first_choice->rating() + blob_choice_it.data()->rating());
          if (blob_choice_it.data()->certainty() < lower_word.certainty()) {
            lower_word.set_certainty(blob_choice_it.data()->certainty());
          }
          lower_certainties[x] = blob_choice_it.data()->certainty();
          lower_done = TRUE;
        }
        /* Find upper case */
        if (!upper_done && getUnicharset().get_isupper(unichar_id)) {
          capital_word.set_unichar_id(unichar_id, x);
          capital_word.set_rating(capital_word.rating() -
            first_choice->rating() + blob_choice_it.data()->rating());
          if (blob_choice_it.data()->certainty() < capital_word.certainty()) {
            capital_word.set_certainty(blob_choice_it.data()->certainty());
          }
          upper_certainties[x] = blob_choice_it.data()->certainty();
          upper_done = TRUE;
        }
        if (!char_alpha) {
          const CHAR_FRAGMENT *fragment =
            getUnicharset().get_fragment(unichar_id);
          temp_id = !fragment ? unichar_id :
            getUnicharset().unichar_to_id(fragment->get_unichar());
          if (getUnicharset().get_isalpha(temp_id)) {
            char_alpha = TRUE;
          }
        }
        if (lower_done && upper_done)
          break;
      }
    }
    if (char_alpha && any_alpha != NULL)
      *any_alpha = TRUE;

    if (word.rating() > bestrate_pruning_factor * *rating_limit) {
      if (permute_debug)
        tprintf("\n***** Aborting high-cost word: %g > limit %g \n",
                word.rating(), bestrate_pruning_factor * *rating_limit);
      return (NULL);
    }

    *prev_char = '\0';
    temp_id = word.unichar_id(word.length()-1);
    if (temp_id != INVALID_UNICHAR_ID) {
      strcpy(prev_char, getUnicharset().id_to_unichar(temp_id));
    }
  }

  if (word.rating() < raw_choice->rating()) {
    *raw_choice = word;
    LogNewChoice(*raw_choice, 1.0, certainties, true);
  }

  if (ngram_permuter_activated)
    return NULL;

  float rating = word.rating();
  adjust_non_word(&word, &adjust_factor);
  LogNewChoice(word, adjust_factor, certainties, false);

  float lower_rating = lower_word.rating();
  adjust_non_word(&lower_word, &adjust_factor);
  LogNewChoice(lower_word, adjust_factor, lower_certainties, false);

  float upper_rating = capital_word.rating();
  adjust_non_word(&capital_word, &adjust_factor);
  LogNewChoice(capital_word, adjust_factor, upper_certainties, false);

  WERD_CHOICE *best_choice = &word;
  *rating_limit = rating;
  if (lower_word.rating() < best_choice->rating()) {
    best_choice = &lower_word;
    *rating_limit = lower_rating;
  }
  if (capital_word.rating() < best_choice->rating()) {
    best_choice = &capital_word;
    *rating_limit = upper_rating;
  }
  return new WERD_CHOICE(*best_choice);
}


/**
 * @name choose_il1
 *
 * Choose between the candidate il1 chars.
 * @param first_char first choice
 * @param second_char second choice
 * @param third_char third choice
 * @param prev_char prev in word
 * @param next_char next in word
 * @param next_next_char after next next in word
 */
const char* DictT::choose_il1(const char *first_char,
                             const char *second_char,
                             const char *third_char,
                             const char *prev_char,
                             const char *next_char,
                             const char *next_next_char) {
  int prev_char_length = strlen(prev_char);
  int next_char_length = strlen(next_char);
  int next_next_char_length = strlen(next_next_char);

  if (*first_char == 'l' && *second_char != '\0') {
    if (*second_char == 'I'
        && (((prev_char_length != 0 &&
            getUnicharset().get_isupper (prev_char, prev_char_length)) &&
            (next_char_length == 0 ||
             !getUnicharset().get_islower (next_char, next_char_length)) &&
            (next_char_length == 0 ||
             !getUnicharset().get_isdigit (next_char, next_char_length))) ||
            ((next_char_length != 0 &&
             getUnicharset().get_isupper (next_char, next_char_length)) &&
            (prev_char_length == 0 ||
             !getUnicharset().get_islower (prev_char, prev_char_length)) &&
            (prev_char_length == 0 ||
             !getUnicharset().get_isdigit (prev_char, prev_char_length)))))
      first_char = second_char;  //override
    else if (*second_char == '1' || *third_char == '1') {
      if ((next_char_length != 0 &&
           getUnicharset().get_isdigit (next_char, next_char_length)) ||
          (prev_char_length != 0 &&
           getUnicharset().get_isdigit (prev_char, prev_char_length))
          || (*next_char == 'l' &&
          (next_next_char_length != 0 &&
           getUnicharset().get_isdigit (next_next_char,
                                        next_next_char_length)))) {
        first_char = "1";
      }
      else if ((prev_char_length == 0 ||
                !getUnicharset().get_islower (prev_char, prev_char_length)) &&
               ((next_char_length == 0 ||
                 !getUnicharset().get_islower (next_char, next_char_length)) ||
                (*next_char == 's' &&
                *next_next_char == 't'))) {
        if (((*prev_char != '\'' && *prev_char != '`') || *next_char != '\0')
            && ((*next_char != '\'' && *next_char != '`')
                || *prev_char != '\0')) {
          first_char = "1";
        }
      }
    }
  }
  return first_char;
}

/**
 * Check all the DAWGs to see if this word is in any of them.
 */
int DictT::valid_word(const WERD_CHOICE &word, bool numbers_ok) {
  const WERD_CHOICE *word_ptr = &word;
  WERD_CHOICE temp_word;
  if (hyphenated()) {
    copy_hyphen_info(&temp_word);
    temp_word += word;
    word_ptr = &temp_word;
  }
  if (word_ptr->length() == 0) return NO_PERM;
  // Allocate vectors for holding current and updated
  // active_dawgs and constraints and initialize them.
  DawgInfoVector *active_dawgs = new DawgInfoVector[2];
  DawgInfoVector *constraints = new DawgInfoVector[2];
  init_active_dawgs(&(active_dawgs[0]));
  init_constraints(&(constraints[0]));
  DawgArgs dawg_args(&(active_dawgs[0]), &(constraints[0]),
                     &(active_dawgs[1]), &(constraints[1]), 0.0);
  int last_index = word_ptr->length() - 1;
  // Call leter_is_okay for each letter in the word.
  for (int i = hyphen_base_size(); i <= last_index; ++i) {
    if (!((this->*letter_is_okay_)(&dawg_args, i, word_ptr,
                                   i == last_index))) break;
    // Swap active_dawgs, constraints with the corresponding updated vector.
    if (dawg_args.updated_active_dawgs == &(active_dawgs[1])) {
      dawg_args.updated_active_dawgs = &(active_dawgs[0]);
      dawg_args.updated_constraints = &(constraints[0]);
      ++(dawg_args.active_dawgs);
      ++(dawg_args.constraints);
    } else {
      ++(dawg_args.updated_active_dawgs);
      ++(dawg_args.updated_constraints);
      dawg_args.active_dawgs = &(active_dawgs[0]);
      dawg_args.constraints = &(constraints[0]);
    }
  }
  delete[] active_dawgs;
  delete[] constraints;
  if (dawg_args.permuter == SYSTEM_DAWG_PERM ||
      dawg_args.permuter == DOC_DAWG_PERM ||
      dawg_args.permuter == USER_DAWG_PERM ||
      (numbers_ok && dawg_args.permuter == NUMBER_PERM)){
    return dawg_args.permuter;
  } else {
    return NO_PERM;
  }
}

/**
 * @return true if the word contains a valid punctuation pattern.
 *
 * @note Since the domains of punctuation symbols and symblos
 * used in numbers are not disjoint, a valid number might contain
 * an invalid punctuation pattern (e.g. .99).
 */
bool DictT::valid_punctuation(const WERD_CHOICE &word) {
  if (word.length() == 0) return NO_PERM;
  int i;
  WERD_CHOICE new_word;
  int last_index = word.length() - 1;
  int new_len = 0;
  for (i = 0; i <= last_index; ++i) {
    UNICHAR_ID unichar_id = (word.unichar_id(i));
    if (getUnicharset().get_ispunctuation(unichar_id)) {
      new_word.append_unichar_id(unichar_id, 1, 0.0, 0.0);
    } else if (!getUnicharset().get_isalpha(unichar_id) &&
               !getUnicharset().get_isdigit(unichar_id)) {
      return false;  // neither punc, nor alpha, nor digit
    } else if ((new_len = new_word.length()) == 0 ||
               new_word.unichar_id(new_len-1) != Dawg::kPatternUnicharID) {
      new_word.append_unichar_id(Dawg::kPatternUnicharID, 1, 0.0, 0.0);
    }
  }
  for (i = 0; i < dawgs_.size(); ++i) {
    if (dawgs_[i]->type() == DAWG_TYPE_PUNCTUATION &&
        dawgs_[i]->word_in_dawg(new_word)) return true;
  }
  return false;
}

/**
 * @name fragment_state
 *
 * Given the current char choice and information about previously seen
 * fragments, determines whether adjacent character fragments are
 * present and whether they can be concatenated.
 *
 * The given prev_char_frag_info contains:
 * - fragment: if not NULL contains information about immediately
 *   preceeding fragmented character choice
 * - num_fragments: number of fragments that have been used so far
 *   to construct a character
 * - certainty: certainty of the current choice or minimum
 *   certainty of all fragments concatenated so far
 * - rating: rating of the current choice or sum of fragment
 *   ratings concatenated so far
 *
 * The output char_frag_info is filled in as follows:
 * - character: is set to be NULL if the choice is a non-matching
 *   or non-ending fragment piece; is set to unichar of the given choice
 *   if it represents a regular character or a matching ending fragment
 * - fragment,num_fragments,certainty,rating are set as described above
 *
 * @returns false if a non-matching fragment is discovered, true otherwise.
 */
bool DictT::fragment_state_okay(UNICHAR_ID curr_unichar_id,
                               float curr_rating, float curr_certainty,
                               const CHAR_FRAGMENT_INFO *prev_char_frag_info,
                               const char *debug, int word_ending,
                               CHAR_FRAGMENT_INFO *char_frag_info) {
  const CHAR_FRAGMENT *this_fragment =
    getUnicharset().get_fragment(curr_unichar_id);
  const CHAR_FRAGMENT *prev_fragment =
    prev_char_frag_info != NULL ? prev_char_frag_info->fragment : NULL;

  // Print debug info for fragments.
  if (debug && (prev_fragment || this_fragment)) {
    cprintf("%s check fragments: choice=%s word_ending=%d\n", debug,
            getUnicharset().debug_str(curr_unichar_id).string(),
            word_ending);
    if (prev_fragment) {
      cprintf("prev_fragment %s\n", prev_fragment->to_string().string());
    }
    if (this_fragment) {
      cprintf("this_fragment %s\n", this_fragment->to_string().string());
    }
  }

  char_frag_info->unichar_id = curr_unichar_id;
  char_frag_info->fragment = this_fragment;
  char_frag_info->rating = curr_rating;
  char_frag_info->certainty = curr_certainty;
  char_frag_info->num_fragments = 1;
  if (prev_fragment && !this_fragment) {
    if (debug) tprintf("Skip choice with incomplete fragment\n");
    return false;
  }
  if (this_fragment) {
    // We are dealing with a fragment.
    char_frag_info->unichar_id = INVALID_UNICHAR_ID;
    if (prev_fragment) {
      if (!this_fragment->is_continuation_of(prev_fragment)) {
        if (debug) tprintf("Non-matching fragment piece\n");
        return false;
      }
      if (this_fragment->is_ending()) {
        char_frag_info->unichar_id =
          getUnicharset().unichar_to_id(this_fragment->get_unichar());
        char_frag_info->fragment = NULL;
        if (debug) {
          tprintf("Built character %s from fragments\n",
                  getUnicharset().debug_str(
                      char_frag_info->unichar_id).string());
        }
      } else {
        if (debug) tprintf("Record fragment continuation\n");
        char_frag_info->fragment = this_fragment;
      }
      // Update certainty and rating.
      char_frag_info->rating =
        prev_char_frag_info->rating + curr_rating;
      char_frag_info->num_fragments = prev_char_frag_info->num_fragments + 1;
      char_frag_info->certainty =
        MIN(curr_certainty, prev_char_frag_info->certainty);
    } else {
      if (this_fragment->is_beginning()) {
        if (debug) cprintf("Record fragment beginning\n");
      } else {
        if (debug) {
          tprintf("Non-starting fragment piece with no prev_fragment\n");
        }
        return false;
      }
    }
  }
  if (word_ending && char_frag_info->fragment) {
    if (debug) tprintf("Word can not end with a fragment\n");
    return false;
  }
  return true;
}
/**
 * top_fragments_permute_and_select
 *
 * Creates a copy of character choices list that contain only fragments
 * and the best non-fragmented character choice.
 * Permutes character in this shortened list, builds characters from
 * fragments if possible and returns a better choice if found.
 */
WERD_CHOICE *DictT::top_fragments_permute_and_select(
    const BLOB_CHOICE_LIST_VECTOR &char_choices,
    float rating_limit) {
  if (char_choices.length() <= 1 ||
      char_choices.length() > MAX_PERM_LENGTH) {
    return NULL;
  }
  // See it would be possible to benefit from permuting fragments.
  int x;
  float min_rating = 0.0;
  BLOB_CHOICE_IT blob_choice_it;
  for (x = 0; x < char_choices.length(); ++x) {
    blob_choice_it.set_to_list(char_choices.get(x));
    if (blob_choice_it.data()) {
      min_rating += blob_choice_it.data()->rating();
    }
    if (min_rating >= rating_limit) {
      return NULL;
    }
  }
  if (fragments_debug > 1) {
    tprintf("A choice with fragment beats top choice\n");
    tprintf("Running fragment permuter...\n");
  }

  // Construct a modified choices list that contains (for each position):
  // the best choice, all fragments and at least one choice for
  // a non-fragmented character.
  BLOB_CHOICE_LIST_VECTOR frag_char_choices(char_choices.length());
  for (x = 0; x < char_choices.length(); ++x) {
    bool need_nonfrag_char = true;
    BLOB_CHOICE_LIST *frag_choices = new BLOB_CHOICE_LIST();
    BLOB_CHOICE_IT frag_choices_it;
    frag_choices_it.set_to_list(frag_choices);
    blob_choice_it.set_to_list(char_choices.get(x));
    for (blob_choice_it.mark_cycle_pt(); !blob_choice_it.cycled_list();
         blob_choice_it.forward()) {
      if (getUnicharset().get_fragment(blob_choice_it.data()->unichar_id())) {
        frag_choices_it.add_after_then_move(
            new BLOB_CHOICE(*(blob_choice_it.data())));
      } else if (need_nonfrag_char) {
        frag_choices_it.add_after_then_move(
            new BLOB_CHOICE(*(blob_choice_it.data())));
        need_nonfrag_char = false;
      }
    }
    frag_char_choices += frag_choices;
  }

  WERD_CHOICE *best_choice = new WERD_CHOICE();
  best_choice->make_bad();
  WERD_CHOICE word(MAX_PERM_LENGTH);
  word.set_permuter(TOP_CHOICE_PERM);
  float certainties[MAX_PERM_LENGTH];
  this->go_deeper_fxn_ = &DictT::go_deeper_top_fragments_fxn;
  permute_choices((fragments_debug > 1) ? "fragments_debug" : NULL,
                  frag_char_choices, 0, NULL, &word, certainties,
                  &rating_limit, best_choice, NULL);

  frag_char_choices.delete_data_pointers();
  return best_choice;
}

/**
 * permute_choices
 *
 * Call append_choices() for each BLOB_CHOICE in BLOB_CHOICE_LIST
 * with the given char_choice_index in char_choices.
 */
void DictT::permute_choices(
    const char *debug,
    const BLOB_CHOICE_LIST_VECTOR &char_choices,
    int char_choice_index,
    const CHAR_FRAGMENT_INFO *prev_char_frag_info,
    WERD_CHOICE *word,
    float certainties[],
    float *limit,
    WERD_CHOICE *best_choice,
    void *more_args) {
  if (debug) {
    tprintf("%s permute_choices: char_choice_index=%d"
            " limit=%4.2f rating=%4.2f, certainty=%4.2f word=%s\n",
            debug, char_choice_index, *limit, word->rating(),
            word->certainty(), word->debug_string(getUnicharset()).string());
  }
  if (char_choice_index < char_choices.length()) {
    BLOB_CHOICE_IT blob_choice_it;
    blob_choice_it.set_to_list(char_choices.get(char_choice_index));
    for (blob_choice_it.mark_cycle_pt(); !blob_choice_it.cycled_list();
         blob_choice_it.forward()) {
      append_choices(debug, char_choices, *(blob_choice_it.data()),
                     char_choice_index, prev_char_frag_info, word,
                     certainties, limit, best_choice, more_args);

    }
  }
}

/**
 * append_choices
 *
 * Check to see whether or not the next choice is worth appending to
 * the word being generated. If so then keep going deeper into the word.
 *
 * This function assumes that DictT::go_deeper_fxn_ is set.
 */
void DictT::append_choices(
    const char *debug,
    const BLOB_CHOICE_LIST_VECTOR &char_choices,
    const BLOB_CHOICE &blob_choice,
    int char_choice_index,
    const CHAR_FRAGMENT_INFO *prev_char_frag_info,
    WERD_CHOICE *word,
    float certainties[],
    float *limit,
    WERD_CHOICE *best_choice,
    void *more_args) {
  int word_ending =
    (char_choice_index == char_choices.length() - 1) ? true : false;

  // Deal with fragments.
  CHAR_FRAGMENT_INFO char_frag_info;
  if (!fragment_state_okay(blob_choice.unichar_id(), blob_choice.rating(),
                           blob_choice.certainty(), prev_char_frag_info, debug,
                           word_ending, &char_frag_info)) {
    return;  // blob_choice must be an invalid fragment
  }
  // Search the next letter if this character is a fragment.
  if (char_frag_info.unichar_id == INVALID_UNICHAR_ID) {
    permute_choices(debug, char_choices, char_choice_index + 1,
                    &char_frag_info, word, certainties, limit,
                    best_choice, more_args);
    return;
  }

  // Add the next unichar.
  float old_rating = word->rating();
  float old_certainty = word->certainty();
  uinT8 old_permuter = word->permuter();
  certainties[word->length()] = char_frag_info.certainty;
  word->append_unichar_id_space_allocated(
      char_frag_info.unichar_id, char_frag_info.num_fragments,
      char_frag_info.rating, char_frag_info.certainty);

  // Explore the next unichar.
  (this->*go_deeper_fxn_)(debug, char_choices, char_choice_index,
                          &char_frag_info, word_ending, word, certainties,
                          limit, best_choice, more_args);

  // Remove the unichar we added to explore other choices in it's place.
  word->remove_last_unichar_id();
  word->set_rating(old_rating);
  word->set_certainty(old_certainty);
  word->set_permuter(old_permuter);
}

/**
 * go_deeper_top_fragments_fxn
 *
 * If the choice being composed so far could be better
 * than best_choice keep exploring choices.
 */
void DictT::go_deeper_top_fragments_fxn(
    const char *debug, const BLOB_CHOICE_LIST_VECTOR &char_choices,
    int char_choice_index,
    const CHAR_FRAGMENT_INFO *prev_char_frag_info,
    bool word_ending, WERD_CHOICE *word, float certainties[],
    float *limit, WERD_CHOICE *best_choice, void *more_args) {
  if (word->rating() < *limit) {
    if (word_ending) {
      if (fragments_debug > 1) {
        tprintf("fragments_debug new choice = %s\n",
                word->debug_string(getUnicharset()).string());
      }
      *limit = word->rating();

      float adjust_factor;
      adjust_non_word(word, &adjust_factor);
      LogNewChoice(*word, adjust_factor, certainties, false);

      if (word->rating() < best_choice->rating()) {
        *best_choice = *word;
      }
    } else {  // search the next letter
      permute_choices(debug, char_choices, char_choice_index + 1,
                      prev_char_frag_info, word, certainties, limit,
                      best_choice, more_args);
    }
  } else {
    if (fragments_debug > 1) {
      tprintf("fragments_debug pruned word (%s, rating=%4.2f, limit=%4.2f)\n",
              word->debug_string(getUnicharset()).string(),
              word->rating(), *limit);
    }
  }
}
//////////////////////////////////////////////////////////////permute////////////////////////////

//////////////////////////////////////////////////////////////ippoints////////////////////////////
/**********************************************************************
 * operator!
 *
 * Rotate an ICOORD 90 degrees anticlockwise.
 **********************************************************************/

inline ICOORD
operator! (                      //rotate 90 deg anti
const ICOORD & src               //thing to rotate
) {
  ICOORD result;                 //output

  result.xcoord = -src.ycoord;
  result.ycoord = src.xcoord;
  return result;
}


/**********************************************************************
 * operator-
 *
 * Unary minus of an ICOORD.
 **********************************************************************/

inline ICOORD
operator- (                      //unary minus
const ICOORD & src               //thing to minus
) {
  ICOORD result;                 //output

  result.xcoord = -src.xcoord;
  result.ycoord = -src.ycoord;
  return result;
}


/**********************************************************************
 * operator+
 *
 * Add 2 ICOORDS.
 **********************************************************************/

inline ICOORD
operator+ (                      //sum vectors
const ICOORD & op1,              //operands
const ICOORD & op2) {
  ICOORD sum;                    //result

  sum.xcoord = op1.xcoord + op2.xcoord;
  sum.ycoord = op1.ycoord + op2.ycoord;
  return sum;
}


/**********************************************************************
 * operator+=
 *
 * Add 2 ICOORDS.
 **********************************************************************/

inline ICOORD &
operator+= (                     //sum vectors
ICOORD & op1,                    //operands
const ICOORD & op2) {
  op1.xcoord += op2.xcoord;
  op1.ycoord += op2.ycoord;
  return op1;
}


/**********************************************************************
 * operator-
 *
 * Subtract 2 ICOORDS.
 **********************************************************************/

inline ICOORD
operator- (                      //subtract vectors
const ICOORD & op1,              //operands
const ICOORD & op2) {
  ICOORD sum;                    //result

  sum.xcoord = op1.xcoord - op2.xcoord;
  sum.ycoord = op1.ycoord - op2.ycoord;
  return sum;
}


/**********************************************************************
 * operator-=
 *
 * Subtract 2 ICOORDS.
 **********************************************************************/

inline ICOORD &
operator-= (                     //sum vectors
ICOORD & op1,                    //operands
const ICOORD & op2) {
  op1.xcoord -= op2.xcoord;
  op1.ycoord -= op2.ycoord;
  return op1;
}


/**********************************************************************
 * operator%
 *
 * Scalar product of 2 ICOORDS.
 **********************************************************************/

inline inT32
operator% (                      //scalar product
const ICOORD & op1,              //operands
const ICOORD & op2) {
  return op1.xcoord * op2.xcoord + op1.ycoord * op2.ycoord;
}


/**********************************************************************
 * operator*
 *
 * Cross product of 2 ICOORDS.
 **********************************************************************/

inline inT32 operator *(                    //cross product
                        const ICOORD &op1,  //operands
                        const ICOORD &op2) {
  return op1.xcoord * op2.ycoord - op1.ycoord * op2.xcoord;
}


/**********************************************************************
 * operator*
 *
 * Scalar multiply of an ICOORD.
 **********************************************************************/

inline ICOORD operator *(                    //scalar multiply
                         const ICOORD &op1,  //operands
                         inT16 scale) {
  ICOORD result;                 //output

  result.xcoord = op1.xcoord * scale;
  result.ycoord = op1.ycoord * scale;
  return result;
}


inline ICOORD operator *(                   //scalar multiply
                         inT16 scale,
                         const ICOORD &op1  //operands
                        ) {
  ICOORD result;                 //output

  result.xcoord = op1.xcoord * scale;
  result.ycoord = op1.ycoord * scale;
  return result;
}


/**********************************************************************
 * operator*=
 *
 * Scalar multiply of an ICOORD.
 **********************************************************************/

inline ICOORD &
operator*= (                     //scalar multiply
ICOORD & op1,                    //operands
inT16 scale) {
  op1.xcoord *= scale;
  op1.ycoord *= scale;
  return op1;
}


/**********************************************************************
 * operator/
 *
 * Scalar divide of an ICOORD.
 **********************************************************************/

inline ICOORD
operator/ (                      //scalar divide
const ICOORD & op1,              //operands
inT16 scale) {
  ICOORD result;                 //output

  result.xcoord = op1.xcoord / scale;
  result.ycoord = op1.ycoord / scale;
  return result;
}


/**********************************************************************
 * operator/=
 *
 * Scalar divide of an ICOORD.
 **********************************************************************/

inline ICOORD &
operator/= (                     //scalar divide
ICOORD & op1,                    //operands
inT16 scale) {
  op1.xcoord /= scale;
  op1.ycoord /= scale;
  return op1;
}


/**********************************************************************
 * ICOORD::rotate
 *
 * Rotate an ICOORD by the given (normalized) (cos,sin) vector.
 **********************************************************************/

inline void ICOORD::rotate(  //rotate by vector
                           const FCOORD& vec) {
  inT16 tmp;

  tmp = (inT16) floor (xcoord * vec.x () - ycoord * vec.y () + 0.5);
  ycoord = (inT16) floor (ycoord * vec.x () + xcoord * vec.y () + 0.5);
  xcoord = tmp;
}


/**********************************************************************
 * operator!
 *
 * Rotate an FCOORD 90 degrees anticlockwise.
 **********************************************************************/

inline FCOORD
operator! (                      //rotate 90 deg anti
const FCOORD & src               //thing to rotate
) {
  FCOORD result;                 //output

  result.xcoord = -src.ycoord;
  result.ycoord = src.xcoord;
  return result;
}


/**********************************************************************
 * operator-
 *
 * Unary minus of an FCOORD.
 **********************************************************************/

inline FCOORD
operator- (                      //unary minus
const FCOORD & src               //thing to minus
) {
  FCOORD result;                 //output

  result.xcoord = -src.xcoord;
  result.ycoord = -src.ycoord;
  return result;
}


/**********************************************************************
 * operator+
 *
 * Add 2 FCOORDS.
 **********************************************************************/

inline FCOORD
operator+ (                      //sum vectors
const FCOORD & op1,              //operands
const FCOORD & op2) {
  FCOORD sum;                    //result

  sum.xcoord = op1.xcoord + op2.xcoord;
  sum.ycoord = op1.ycoord + op2.ycoord;
  return sum;
}


/**********************************************************************
 * operator+=
 *
 * Add 2 FCOORDS.
 **********************************************************************/

inline FCOORD &
operator+= (                     //sum vectors
FCOORD & op1,                    //operands
const FCOORD & op2) {
  op1.xcoord += op2.xcoord;
  op1.ycoord += op2.ycoord;
  return op1;
}


/**********************************************************************
 * operator-
 *
 * Subtract 2 FCOORDS.
 **********************************************************************/

inline FCOORD
operator- (                      //subtract vectors
const FCOORD & op1,              //operands
const FCOORD & op2) {
  FCOORD sum;                    //result

  sum.xcoord = op1.xcoord - op2.xcoord;
  sum.ycoord = op1.ycoord - op2.ycoord;
  return sum;
}


/**********************************************************************
 * operator-=
 *
 * Subtract 2 FCOORDS.
 **********************************************************************/

inline FCOORD &
operator-= (                     //sum vectors
FCOORD & op1,                    //operands
const FCOORD & op2) {
  op1.xcoord -= op2.xcoord;
  op1.ycoord -= op2.ycoord;
  return op1;
}


/**********************************************************************
 * operator%
 *
 * Scalar product of 2 FCOORDS.
 **********************************************************************/

inline float
operator% (                      //scalar product
const FCOORD & op1,              //operands
const FCOORD & op2) {
  return op1.xcoord * op2.xcoord + op1.ycoord * op2.ycoord;
}


/**********************************************************************
 * operator*
 *
 * Cross product of 2 FCOORDS.
 **********************************************************************/

inline float operator *(                    //cross product
                        const FCOORD &op1,  //operands
                        const FCOORD &op2) {
  return op1.xcoord * op2.ycoord - op1.ycoord * op2.xcoord;
}


/**********************************************************************
 * operator*
 *
 * Scalar multiply of an FCOORD.
 **********************************************************************/

inline FCOORD operator *(                    //scalar multiply
                         const FCOORD &op1,  //operands
                         float scale) {
  FCOORD result;                 //output

  result.xcoord = op1.xcoord * scale;
  result.ycoord = op1.ycoord * scale;
  return result;
}


inline FCOORD operator *(                   //scalar multiply
                         float scale,
                         const FCOORD &op1  //operands
                        ) {
  FCOORD result;                 //output

  result.xcoord = op1.xcoord * scale;
  result.ycoord = op1.ycoord * scale;
  return result;
}


/**********************************************************************
 * operator*=
 *
 * Scalar multiply of an FCOORD.
 **********************************************************************/

inline FCOORD &
operator*= (                     //scalar multiply
FCOORD & op1,                    //operands
float scale) {
  op1.xcoord *= scale;
  op1.ycoord *= scale;
  return op1;
}


/**********************************************************************
 * operator/
 *
 * Scalar divide of an FCOORD.
 **********************************************************************/

inline FCOORD
operator/ (                      //scalar divide
const FCOORD & op1,              //operands
float scale) {
  FCOORD result;                 //output

  if (scale != 0) {
    result.xcoord = op1.xcoord / scale;
    result.ycoord = op1.ycoord / scale;
  }
  return result;
}


/**********************************************************************
 * operator/=
 *
 * Scalar divide of an FCOORD.
 **********************************************************************/

inline FCOORD &
operator/= (                     //scalar divide
FCOORD & op1,                    //operands
float scale) {
  if (scale != 0) {
    op1.xcoord /= scale;
    op1.ycoord /= scale;
  }
  return op1;
}


/**********************************************************************
 * rotate
 *
 * Rotate an FCOORD by the given (normalized) (cos,sin) vector.
 **********************************************************************/

inline void FCOORD::rotate(  //rotate by vector
                           const FCOORD vec) {
  float tmp;

  tmp = xcoord * vec.x () - ycoord * vec.y ();
  ycoord = ycoord * vec.x () + xcoord * vec.y ();
  xcoord = tmp;
}
//////////////////////////////////////////////////////////////ippoints////////////////////////////

/////////////////////////////////////////////////////////////////emalloc////////////////////////////////////////
/**----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
void *Emalloc(size_t Size) {
/*
 **							Parameters:
 **							Size
              number of bytes of memory to be allocated
**							Globals: none
**							Operation:
**							This routine attempts to allocate the specified number of
**							bytes.  If the memory can be allocated, a pointer to the
**							memory is returned.  If the memory cannot be allocated, or
**							if the allocation request is negative or zero,
**							an error is trapped.
**							Return: Pointer to allocated memory.
**							Exceptions: NOTENOUGHMEMORY
              unable to allocate Size bytes
**							ILLEGALMALLOCREQUEST
              negative or zero request size
**							History: 4/3/89, DSJ, Created.
*/
  void *Buffer;

  if (Size <= 0)
    DoError (ILLEGALMALLOCREQUEST, "Illegal malloc request size");
  Buffer = (void *) malloc (Size);
  if (Buffer == NULL) {
    DoError (NOTENOUGHMEMORY, "Not enough memory");
    return (NULL);
  }
  else
    return (Buffer);

}                                /* Emalloc */


/*---------------------------------------------------------------------------*/
void *Erealloc(void *ptr, size_t size) {
  void *Buffer;

  if (size <= 0 || (size == 0 && ptr == NULL))
    DoError (ILLEGALMALLOCREQUEST, "Illegal realloc request size");

  Buffer = (void *) realloc (ptr, size);
  if (Buffer == NULL && size != 0)
    DoError (NOTENOUGHMEMORY, "Not enough memory");
  return (Buffer);

}                                /* Erealloc */


/*---------------------------------------------------------------------------*/
void Efree(void *ptr) {
  if (ptr == NULL)
    DoError (ILLEGALMALLOCREQUEST, "Attempted to free NULL ptr");

  free(ptr);

}                                /* Efree */
/////////////////////////////////////////////////////////////////emalloc////////////////////////////////////////

/////////////////////////////////////////////////////////////////bitvec////////////////////////////////////////
/*-----------------------------------------------------------------------------
        Global Data Definitions and Declarations
-----------------------------------------------------------------------------*/
static int BitVectorCount = 0;

/*-----------------------------------------------------------------------------
              Public Code
-----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/**
 * This routine uses realloc to increase the size of
 * the specified bit vector.
 *
 * Globals:
 * - none
 *
 * @param Vector bit vector to be expanded
 * @param NewNumBits new size of bit vector
 *
 * @return New expanded bit vector.
 * @note Exceptions: none
 * @note History: Fri Nov 16 10:11:16 1990, DSJ, Created.
 */
BIT_VECTOR ExpandBitVector(BIT_VECTOR Vector, int NewNumBits)
{
    return ((BIT_VECTOR) Erealloc(Vector, sizeof(Vector[0]) * WordsInVectorOfSize(NewNumBits)));
}                                /* ExpandBitVector */


/*---------------------------------------------------------------------------*/
void FreeBitVector(BIT_VECTOR BitVector)
{
    /**
 * This routine frees a bit vector.  It also decrements
 * the global counter that keeps track of the number of
 * bit vectors allocated.  If BitVector is NULL, then
 * the count is printed to stderr.
 *
 * Globals:
 * - BitVectorCount count of number of bit vectors allocated
 *
 * @param BitVector bit vector to be freed
 *
 * @note Exceptions: none
 * @note History: Tue Oct 23 16:46:09 1990, DSJ, Created.
 */
    if (BitVector)
    {
        Efree(BitVector);
        BitVectorCount--;
    }
    else
    {
        tprintf("%6d BITVECTOR elements in use\n", BitVectorCount);
    }
}                                /* FreeBitVector */


/*hamming_distance(array1,array2,length) computes the hamming distance
   between two bit strings */
/*--------------------------------------------------------------------------*/
int hamming_distance(uinT32* array1, uinT32* array2, int length)
{
    register uinT32 diff;   /*bit difference */
    register int dist;             /*total distance */

    dist = 0;
    for (; length > 0; length--)
    {
        diff = *array1++ ^ *array2++;/*different bits */

        while (diff)
        {
            diff &= diff - 1;          /*lose a bit */
            dist++;
        }
    }

    return dist;                   /*total distance */
}


/*---------------------------------------------------------------------------*/
/**
 * Allocate and return a new bit vector large enough to
 * hold the specified number of bits.
 *
 * Globals:
 * - BitVectorCount	number of bit vectors allocated
 *
 * @param NumBits number of bits in new bit vector
 *
 * @return New bit vector.
 * @note Exceptions: none
 * @note History: Tue Oct 23 16:51:27 1990, DSJ, Created.
 */
BIT_VECTOR NewBitVector(int NumBits)
{
    BitVectorCount++;
    return ((BIT_VECTOR) Emalloc(sizeof(uinT32) * WordsInVectorOfSize(NumBits)));
}                                /* NewBitVector */
/////////////////////////////////////////////////////////////////bitvec////////////////////////////////////////

/////////////////////////////////////////////////////////////////protos////////////////////////////////////////
#define PROTO_INCREMENT   32
#define CONFIG_INCREMENT  16

/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
CLASS_STRUCT TrainingData[NUMBER_OF_CLASSES];

STRING_VAR(classify_training_file, "MicroFeatures", "Training file");

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**
 * @name AddConfigToClass
 *
 * Add a new config to this class.  Malloc new space and copy the
 * old configs if necessary.  Return the config id for the new config.
 *
 * @param Class The class to add to
 */
int AddConfigToClass(CLASS_TYPE Class) {
  int NewNumConfigs;
  int NewConfig;
  int MaxNumProtos;
  BIT_VECTOR Config;

  MaxNumProtos = Class->MaxNumProtos;

  if (Class->NumConfigs >= Class->MaxNumConfigs) {
    /* add configs in CONFIG_INCREMENT chunks at a time */
    NewNumConfigs = (((Class->MaxNumConfigs + CONFIG_INCREMENT) /
      CONFIG_INCREMENT) * CONFIG_INCREMENT);

    Class->Configurations =
      (CONFIGS) Erealloc (Class->Configurations,
      sizeof (BIT_VECTOR) * NewNumConfigs);

    Class->MaxNumConfigs = NewNumConfigs;
  }
  NewConfig = Class->NumConfigs++;
  Config = NewBitVector (MaxNumProtos);
  Class->Configurations[NewConfig] = Config;
  zero_all_bits (Config, WordsInVectorOfSize (MaxNumProtos));

  return (NewConfig);
}


/**
 * @name AddProtoToClass
 *
 * Add a new proto to this class.  Malloc new space and copy the
 * old protos if necessary.  Return the proto id for the new proto.
 *
 * @param Class The class to add to
 */
int AddProtoToClass(CLASS_TYPE Class) {
  int i;
  int Bit;
  int NewNumProtos;
  int NewProto;
  BIT_VECTOR Config;

  if (Class->NumProtos >= Class->MaxNumProtos) {
    /* add protos in PROTO_INCREMENT chunks at a time */
    NewNumProtos = (((Class->MaxNumProtos + PROTO_INCREMENT) /
      PROTO_INCREMENT) * PROTO_INCREMENT);

    Class->Prototypes = (PROTO) Erealloc (Class->Prototypes,
      sizeof (PROTO_STRUCT) *
      NewNumProtos);

    Class->MaxNumProtos = NewNumProtos;

    for (i = 0; i < Class->NumConfigs; i++) {
      Config = Class->Configurations[i];
      Class->Configurations[i] = ExpandBitVector (Config, NewNumProtos);

      for (Bit = Class->NumProtos; Bit < NewNumProtos; Bit++)
        reset_bit(Config, Bit);
    }
  }
  NewProto = Class->NumProtos++;
  if (Class->NumProtos > MAX_NUM_PROTOS) {
    tprintf("Ouch! number of protos = %d, vs max of %d!",
            Class->NumProtos, MAX_NUM_PROTOS);
  }
  return (NewProto);
}


/**
 * @name ClassConfigLength
 *
 * Return the length of all the protos in this class.
 *
 * @param Class The class to add to
 * @param Config FIXME
 */
FLOAT32 ClassConfigLength(CLASS_TYPE Class, BIT_VECTOR Config) {
  inT16 Pid;
  FLOAT32 TotalLength = 0;

  for (Pid = 0; Pid < Class->NumProtos; Pid++) {
    if (test_bit (Config, Pid)) {

      TotalLength += (ProtoIn (Class, Pid))->Length;
    }
  }
  return (TotalLength);
}


/**
 * @name ClassProtoLength
 *
 * Return the length of all the protos in this class.
 *
 * @param Class The class to use
 */
FLOAT32 ClassProtoLength(CLASS_TYPE Class) {
  inT16 Pid;
  FLOAT32 TotalLength = 0;

  for (Pid = 0; Pid < Class->NumProtos; Pid++) {
    TotalLength += (ProtoIn (Class, Pid))->Length;
  }
  return (TotalLength);
}


/**
 * @name CopyProto
 *
 * Copy the first proto into the second.
 *
 * @param Src Source
 * @param Dest Destination
 */
void CopyProto(PROTO Src, PROTO Dest) {
  Dest->X = Src->X;
  Dest->Y = Src->Y;
  Dest->Length = Src->Length;
  Dest->Angle = Src->Angle;
  Dest->A = Src->A;
  Dest->B = Src->B;
  Dest->C = Src->C;
}


/**********************************************************************
 * FillABC
 *
 * Fill in Protos A, B, C fields based on the X, Y, Angle fields.
 **********************************************************************/
void FillABC(PROTO Proto) {
  FLOAT32 Slope, Intercept, Normalizer;

  Slope = tan (Proto->Angle * 2.0 * PI);
  Intercept = Proto->Y - Slope * Proto->X;
  Normalizer = 1.0 / sqrt (Slope * Slope + 1.0);
  Proto->A = Slope * Normalizer;
  Proto->B = -Normalizer;
  Proto->C = Intercept * Normalizer;
}


/**********************************************************************
 * FreeClass
 *
 * Deallocate the memory consumed by the specified class.
 **********************************************************************/
void FreeClass(CLASS_TYPE Class) {
  if (Class) {
    FreeClassFields(Class);
    delete Class;
  }
}


/**********************************************************************
 * FreeClassFields
 *
 * Deallocate the memory consumed by subfields of the specified class.
 **********************************************************************/
void FreeClassFields(CLASS_TYPE Class) {
  int i;

  if (Class) {
    if (Class->MaxNumProtos > 0)
      memfree (Class->Prototypes);
    if (Class->MaxNumConfigs > 0) {
      for (i = 0; i < Class->NumConfigs; i++)
        FreeBitVector (Class->Configurations[i]);
      memfree (Class->Configurations);
    }
  }
}

/**********************************************************************
 * NewClass
 *
 * Allocate a new class with enough memory to hold the specified number
 * of prototypes and configurations.
 **********************************************************************/
CLASS_TYPE NewClass(int NumProtos, int NumConfigs) {
  CLASS_TYPE Class;

  Class = new CLASS_STRUCT;

  if (NumProtos > 0)
    Class->Prototypes = (PROTO) Emalloc (NumProtos * sizeof (PROTO_STRUCT));

  if (NumConfigs > 0)
    Class->Configurations = (CONFIGS) Emalloc (NumConfigs *
      sizeof (BIT_VECTOR));
  Class->MaxNumProtos = NumProtos;
  Class->MaxNumConfigs = NumConfigs;
  Class->NumProtos = 0;
  Class->NumConfigs = 0;
  return (Class);

}


/**********************************************************************
 * PrintProtos
 *
 * Print the list of prototypes in this class type.
 **********************************************************************/
void PrintProtos(CLASS_TYPE Class) {
  inT16 Pid;

  for (Pid = 0; Pid < Class->NumProtos; Pid++) {
    cprintf ("Proto %d:\t", Pid);
    PrintProto (ProtoIn (Class, Pid));
    cprintf ("\t");
    PrintProtoLine (ProtoIn (Class, Pid));
    new_line();
  }
}

/**
 * @name ReadClassFile
 *
 * Read in the training data from a file.  All of the classes are read
 * in.  The results are stored in the global variable, 'TrainingData'.
 */
void Classify::ReadClassFile() {
 FILE *File;
 char TextLine[CHARS_PER_LINE];
 char unichar[CHARS_PER_LINE];

 cprintf ("Reading training data from '%s' ...",
          static_cast<STRING>(classify_training_file).string());
 fflush(stdout);

 File = open_file(static_cast<STRING>(classify_training_file).string(), "r");
 while (fgets (TextLine, CHARS_PER_LINE, File) != NULL) {

   sscanf(TextLine, "%s", unichar);
   ReadClassFromFile (File, unicharset.unichar_to_id(unichar));
   fgets(TextLine, CHARS_PER_LINE, File);
   fgets(TextLine, CHARS_PER_LINE, File);
 }
 fclose(File);
 new_line();
}

/**
 * ReadClassFromFile
 *
 * Read in a class description (protos and configs) from a file.  Update
 * the class structure record.
 */
void ReadClassFromFile(FILE *File, UNICHAR_ID unichar_id) {
  CLASS_TYPE Class;

  Class = &TrainingData[unichar_id];

  ReadProtos(File, Class);

  ReadConfigs(File, Class);
}

/**
 * ReadConfigs
 *
 * Read the prototype configurations for this class from a file.  Read
 * the requested number of lines.
 */
void ReadConfigs(register FILE *File, CLASS_TYPE Class) {
  inT16 Cid;
  register inT16 Wid;
  register BIT_VECTOR ThisConfig;
  int NumWords;
  int NumConfigs;

  fscanf (File, "%d %d\n", &NumConfigs, &NumWords);
  Class->NumConfigs = NumConfigs;
  Class->MaxNumConfigs = NumConfigs;
  Class->Configurations =
    (CONFIGS) Emalloc (sizeof (BIT_VECTOR) * NumConfigs);
  NumWords = WordsInVectorOfSize (Class->NumProtos);

  for (Cid = 0; Cid < NumConfigs; Cid++) {

    ThisConfig = NewBitVector (Class->NumProtos);
    for (Wid = 0; Wid < NumWords; Wid++)
      fscanf (File, "%x", &ThisConfig[Wid]);
    Class->Configurations[Cid] = ThisConfig;
  }
}


/**
 * ReadProtos
 *
 * Read in all the prototype information from a file.  Read the number
 * of lines requested.
 */
void ReadProtos(register FILE *File, CLASS_TYPE Class) {
  register inT16 Pid;
  register PROTO Proto;
  int NumProtos;

  fscanf (File, "%d\n", &NumProtos);
  Class->NumProtos = NumProtos;
  Class->MaxNumProtos = NumProtos;
  Class->Prototypes = (PROTO) Emalloc (sizeof (PROTO_STRUCT) * NumProtos);

  for (Pid = 0; Pid < NumProtos; Pid++) {
    Proto = ProtoIn (Class, Pid);
#ifndef _MSC_VER
    tess_fscanf (File, "%f %f %f %f %f %f %f\n",
#else
    fscanf (File, "%f %f %f %f %f %f %f\n",
#endif
      &Proto->X,
      &Proto->Y,
      &Proto->Length,
      &Proto->Angle,
      &Proto->A,
      &Proto->B, &Proto->C);
  }
}


/**
 * @name SplitProto
 *
 * Add a new proto to this class.  Malloc new space and copy the
 * old protos if necessary.  Return the proto id for the new proto.
 * Update all configurations so that each config which contained the
 * specified old proto will also contain the new proto.  The caller
 * is responsible for actually filling in the appropriate proto params.
 */
int SplitProto(CLASS_TYPE Class, int OldPid) {
  int i;
  int NewPid;
  BIT_VECTOR Config;

  NewPid = AddProtoToClass (Class);

  for (i = 0; i < Class->NumConfigs; i++) {
    Config = Class->Configurations[i];
    if (test_bit (Config, OldPid))
      SET_BIT(Config, NewPid);
  }
  return (NewPid);
}


/**
 * @deprecated
 * @nameWriteOldConfigFile
 *
 * Write the configs in the given class to the specified file in the
 * old config format.
 *
 * @param File The file to write to
 * @param Class The class to write
 */
void WriteOldConfigFile(FILE *File, CLASS_TYPE Class) {
  int Cid, Pid;
  BIT_VECTOR Config;

  fprintf (File, "%d %d\n", Class->NumConfigs, Class->NumProtos);

  for (Cid = 0; Cid < Class->NumConfigs; Cid++) {
    fprintf (File, "1 ");

    Config = Class->Configurations[Cid];

    for (Pid = 0; Pid < Class->NumProtos; Pid++) {
      if (test_bit (Config, Pid))
        fprintf (File, "1");
      else
        fprintf (File, "0");
    }
    fprintf (File, "\n");
  }
}


/**
 * @deprecated
 * @name WriteOldProtoFile
 *
 * Write the protos in the given class to the specified file in the
 * old proto format.
 *
 * @param File The file to write to
 * @param Class The class to write
 */
void WriteOldProtoFile(FILE *File, CLASS_TYPE Class) {
  int Pid;
  PROTO Proto;

  /* print old header */
  fprintf (File, "6\n");
  fprintf (File, "linear   essential      -0.500000   0.500000\n");
  fprintf (File, "linear   essential      -0.250000   0.750000\n");
  fprintf (File, "linear   essential       0.000000   1.000000\n");
  fprintf (File, "circular essential       0.000000   1.000000\n");
  fprintf (File, "linear   non-essential  -0.500000   0.500000\n");
  fprintf (File, "linear   non-essential  -0.500000   0.500000\n");

  for (Pid = 0; Pid < Class->NumProtos; Pid++) {
    Proto = ProtoIn (Class, Pid);

    fprintf (File, "significant   elliptical   1\n");
    fprintf (File, "     %9.6f %9.6f %9.6f %9.6f %9.6f %9.6f\n",
      Proto->X, Proto->Y,
      Proto->Length, Proto->Angle, 0.0, 0.0);
    fprintf (File, "     %9.6f %9.6f %9.6f %9.6f %9.6f %9.6f\n",
      0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001);
  }
}
/////////////////////////////////////////////////////////////////protos////////////////////////////////////////

/////////////////////////////////////////////////////////////////fpoint////////////////////////////////////////
/**----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/

FLOAT32 DistanceBetween(FPOINT A, FPOINT B) {
  double xd = XDelta(A, B);
  double yd = YDelta(A, B);
  return sqrt(static_cast<double>(xd * xd + yd * yd));
}



FLOAT32 NormalizedAngleFrom(FPOINT *Point1,
                            FPOINT *Point2,
                            FLOAT32 FullScale) {
/*
 **	Parameters:
 **		Point1, Point2	points to compute angle between
 **		FullScale	value to associate with 2*pi
 **	Globals: none
 **	Operation: Return the angle from Point1 to Point2 normalized to
 **		lie in the range 0 to FullScale (where FullScale corresponds
 **		to 2*pi or 360 degrees).
 **	Return: none
 **	Exceptions: none
 **	History: Wed Mar 28 14:27:25 1990, DSJ, Created.
 */
  FLOAT32 Angle;
  FLOAT32 NumRadsInCircle = 2.0 * PI;

  Angle = AngleFrom (*Point1, *Point2);
  if (Angle < 0.0)
    Angle += NumRadsInCircle;
  Angle *= FullScale / NumRadsInCircle;
  if (Angle < 0.0 || Angle >= FullScale)
    Angle = 0.0;
  return (Angle);

}                                /* NormalizedAngleFrom */
/////////////////////////////////////////////////////////////////fpoint////////////////////////////////////////

/////////////////////////////////////////////////////////////////blobs////////////////////////////////////////
/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**********************************************************************
 * blob_origin
 *
 * Compute the origin of a compound blob, define to be the centre
 * of the bounding box.
 **********************************************************************/
void blob_origin(TBLOB *blob,       /*blob to compute on */
                 TPOINT *origin) {  /*return value */
  TPOINT topleft;                /*bounding box */
  TPOINT botright;

                                 /*find bounding box */
  blob_bounding_box(blob, &topleft, &botright);
                                 /*centre of box */
  origin->x = (topleft.x + botright.x) / 2;
  origin->y = (topleft.y + botright.y) / 2;
}


/**********************************************************************
 * blob_bounding_box
 *
 * Compute the bounding_box of a compound blob, define to be the
 * max coordinate value of the bounding boxes of all the top-level
 * outlines in the box.
 **********************************************************************/
void blob_bounding_box(TBLOB *blob,               /*blob to compute on */
                       register TPOINT *topleft,  /*bounding box */
                       register TPOINT *botright) {
  register TESSLINE *outline;    /*current outline */

  if (blob == NULL || blob->outlines == NULL) {
    topleft->x = topleft->y = 0;
    *botright = *topleft;        /*default value */
  }
  else {
    outline = blob->outlines;
    *topleft = outline->topleft;
    *botright = outline->botright;
    for (outline = outline->next; outline != NULL; outline = outline->next) {
      if (outline->topleft.x < topleft->x)
                                 /*find extremes */
        topleft->x = outline->topleft.x;
      if (outline->botright.x > botright->x)
                                 /*find extremes */
        botright->x = outline->botright.x;
      if (outline->topleft.y > topleft->y)
                                 /*find extremes */
        topleft->y = outline->topleft.y;
      if (outline->botright.y < botright->y)
                                 /*find extremes */
        botright->y = outline->botright.y;
    }
  }
}


/**********************************************************************
 * blobs_bounding_box
 *
 * Return the smallest extreme point that contain this word.
 **********************************************************************/
void blobs_bounding_box(TBLOB *blobs, TPOINT *topleft, TPOINT *botright) {
  TPOINT tl;
  TPOINT br;
  TBLOB *blob;
  /* Start with first blob */
  blob_bounding_box(blobs, topleft, botright);

  iterate_blobs(blob, blobs) {
    blob_bounding_box(blob, &tl, &br);

    if (tl.x < topleft->x)
      topleft->x = tl.x;
    if (tl.y > topleft->y)
      topleft->y = tl.y;
    if (br.x > botright->x)
      botright->x = br.x;
    if (br.y < botright->y)
      botright->y = br.y;
  }
}


/**********************************************************************
 * blobs_origin
 *
 * Compute the origin of a compound blob, define to be the centre
 * of the bounding box.
 **********************************************************************/
void blobs_origin(TBLOB *blobs,      /*blob to compute on */
                  TPOINT *origin) {  /*return value */
  TPOINT topleft;                /*bounding box */
  TPOINT botright;

                                 /*find bounding box */
  blobs_bounding_box(blobs, &topleft, &botright);
                                 /*center of box */
  origin->x = (topleft.x + botright.x) / 2;
  origin->y = (topleft.y + botright.y) / 2;
}


/**********************************************************************
 * blobs_widths
 *
 * Compute the widths of a list of blobs. Return an array of the widths
 * and gaps.
 **********************************************************************/
WIDTH_RECORD *blobs_widths(TBLOB *blobs) {  /*blob to compute on */
  WIDTH_RECORD *width_record;
  TPOINT topleft;                /*bounding box */
  TPOINT botright;
  TBLOB *blob;                   /*blob to compute on */
  int i = 0;
  int blob_end;
  int num_blobs = count_blobs (blobs);

  /* Get memory */
  width_record = (WIDTH_RECORD *) memalloc (sizeof (int) * num_blobs * 2);
  width_record->num_chars = num_blobs;

  blob_bounding_box(blobs, &topleft, &botright);
  width_record->widths[i++] = botright.x - topleft.x;
  /* First width */
  blob_end = botright.x;

  iterate_blobs (blob, blobs->next) {
    blob_bounding_box(blob, &topleft, &botright);
    width_record->widths[i++] = topleft.x - blob_end;
    width_record->widths[i++] = botright.x - topleft.x;
    blob_end = botright.x;
  }
  return (width_record);
}


/**********************************************************************
 * count_blobs
 *
 * Return a count of the number of blobs attached to this one.
 **********************************************************************/
int count_blobs(TBLOB *blobs) {
  TBLOB *b;
  int x = 0;

  iterate_blobs (b, blobs) x++;
  return (x);
}


/**********************************************************************
 * delete_word
 *
 * Reclaim the memory taken by this word structure and all of its
 * lower level structures.
 **********************************************************************/
void delete_word(TWERD *word) {
  TBLOB *blob;
  TBLOB *nextblob;
  TESSLINE *outline;
  TESSLINE *nextoutline;
  TESSLINE *child;
  TESSLINE *nextchild;

  for (blob = word->blobs; blob; blob = nextblob) {
    nextblob = blob->next;

    for (outline = blob->outlines; outline; outline = nextoutline) {
      nextoutline = outline->next;

      delete_edgepts (outline->loop);

      for (child = outline->child; child; child = nextchild) {
        nextchild = child->next;

        delete_edgepts (child->loop);

        oldoutline(child);
      }
      oldoutline(outline);
    }
    oldblob(blob);
  }
  if (word->correct != NULL)
    strfree (word->correct);     /* Reclaim memory */
  oldword(word);
}


/**********************************************************************
 * delete_edgepts
 *
 * Delete a list of EDGEPT structures.
 **********************************************************************/
void delete_edgepts(register EDGEPT *edgepts) {
  register EDGEPT *this_edge;
  register EDGEPT *next_edge;

  if (edgepts == NULL)
    return;

  this_edge = edgepts;
  do {
    next_edge = this_edge->next;
    oldedgept(this_edge);
    this_edge = next_edge;
  }
  while (this_edge != edgepts);
}
/////////////////////////////////////////////////////////////////blobs////////////////////////////////////////

/////////////////////////////////////////////////////////////////baseline////////////////////////////////////////
typedef TPOINT SCALE;
INT_VAR(classify_baseline_normalized, 1, "Baseline Enable");
/////////////////////////////////////////////////////////////////baseline////////////////////////////////////////

/////////////////////////////////////////////////////////////////kdtree////////////////////////////////////////
#define Magnitude(X)    ((X) < 0 ? -(X) : (X))
//#define MIN(A,B)    ((A) < (B) ? (A) : (B))
#define NodeFound(N,K,D)  (( (N)->Key == (K) ) && ( (N)->Data == (D) ))

/*-----------------------------------------------------------------------------
        Global Data Definitions and Declarations
-----------------------------------------------------------------------------*/
#define MINSEARCH -MAX_FLOAT32
#define MAXSEARCH MAX_FLOAT32

static int NumberOfNeighbors;
static inT16 N;                  /* number of dimensions in the kd tree */

static FLOAT32 *QueryPoint;
static int MaxNeighbors;
static FLOAT32 Radius;
static int Furthest;
static char **Neighbor;
static FLOAT32 *Distance;

static int MaxDimension = 0;
static FLOAT32 *SBMin;
static FLOAT32 *SBMax;
static FLOAT32 *LBMin;
static FLOAT32 *LBMax;

static PARAM_DESC *KeyDesc;

static jmp_buf QuickExit;

static void_proc WalkAction;

// Helper function to find the next essential dimension in a cycle.
static int NextLevel(int level) {
  do {
    ++level;
    if (level >= N)
      level = 0;
  } while (KeyDesc[level].NonEssential);
  return level;
}

/// Helper function to find the previous essential dimension in a cycle.
static int PrevLevel(int level) {
  do {
    --level;
    if (level < 0)
      level = N - 1;
  } while (KeyDesc[level].NonEssential);
  return level;
}

/*-----------------------------------------------------------------------------
              Public Code
-----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/**
 * This routine allocates and returns a new K-D tree data
 * structure.  It also reallocates the small and large
 * search region boxes if they are not large enough to
 * accomodate the size of the new K-D tree.  KeyDesc is
 * an array of key descriptors that indicate which dimensions
 * are circular and, if they are circular, what the range is.
 *
 * Globals:
 * - MaxDimension	largest # of dimensions in any K-D tree
 * - SBMin		small search region box
 * - SBMax
 * - LBMin		large search region box
 * - LBMax
 * - Key		description of key dimensions
 *
 * @param KeySize # of dimensions in the K-D tree
 * @param KeyDesc array of params to describe key dimensions
 *
 * @return Pointer to new K-D tree
 * @note Exceptions: None
 * @note History: 3/13/89, DSJ, Created.
 */
KDTREE *
MakeKDTree (inT16 KeySize, PARAM_DESC KeyDesc[]) {
  int i;
  void *NewMemory;
  KDTREE *KDTree;

  if (KeySize > MaxDimension) {
    NewMemory = Emalloc (KeySize * 4 * sizeof (FLOAT32));
    if (MaxDimension > 0) {
      memfree ((char *) SBMin);
      memfree ((char *) SBMax);
      memfree ((char *) LBMin);
      memfree ((char *) LBMax);
    }
    SBMin = (FLOAT32 *) NewMemory;
    SBMax = SBMin + KeySize;
    LBMin = SBMax + KeySize;
    LBMax = LBMin + KeySize;
  }

  KDTree =
    (KDTREE *) Emalloc (sizeof (KDTREE) +
    (KeySize - 1) * sizeof (PARAM_DESC));
  for (i = 0; i < KeySize; i++) {
    KDTree->KeyDesc[i].NonEssential = KeyDesc[i].NonEssential;
    KDTree->KeyDesc[i].Circular = KeyDesc[i].Circular;
    if (KeyDesc[i].Circular) {
      KDTree->KeyDesc[i].Min = KeyDesc[i].Min;
      KDTree->KeyDesc[i].Max = KeyDesc[i].Max;
      KDTree->KeyDesc[i].Range = KeyDesc[i].Max - KeyDesc[i].Min;
      KDTree->KeyDesc[i].HalfRange = KDTree->KeyDesc[i].Range / 2;
      KDTree->KeyDesc[i].MidRange = (KeyDesc[i].Max + KeyDesc[i].Min) / 2;
    }
    else {
      KDTree->KeyDesc[i].Min = MINSEARCH;
      KDTree->KeyDesc[i].Max = MAXSEARCH;
    }
  }
  KDTree->KeySize = KeySize;
  KDTree->Root.Left = NULL;
  KDTree->Root.Right = NULL;
  return (KDTree);
}                                /* MakeKDTree */


/*---------------------------------------------------------------------------*/
void KDStore(KDTREE *Tree, FLOAT32 *Key, void *Data) {
/**
 * This routine stores Data in the K-D tree specified by Tree
 * using Key as an access key.
 *
 * @param Tree		K-D tree in which data is to be stored
 * @param Key		ptr to key by which data can be retrieved
 * @param Data		ptr to data to be stored in the tree
 *
 * Globals:
 * - N		dimension of the K-D tree
 * - KeyDesc		descriptions of tree dimensions
 * - StoreCount	debug variables for performance tests
 * - StoreUniqueCount
 * - StoreProbeCount
 *
 * @note Exceptions: none
 * @note History:	3/10/89, DSJ, Created.
 *			7/13/89, DSJ, Changed return to void.
 */
  int Level;
  KDNODE *Node;
  KDNODE **PtrToNode;

  N = Tree->KeySize;
  KeyDesc = &(Tree->KeyDesc[0]);
  PtrToNode = &(Tree->Root.Left);
  Node = *PtrToNode;
  Level = NextLevel(-1);
  while (Node != NULL) {
    if (Key[Level] < Node->BranchPoint) {
      PtrToNode = &(Node->Left);
      if (Key[Level] > Node->LeftBranch)
        Node->LeftBranch = Key[Level];
    }
    else {
      PtrToNode = &(Node->Right);
      if (Key[Level] < Node->RightBranch)
        Node->RightBranch = Key[Level];
    }
    Level = NextLevel(Level);
    Node = *PtrToNode;
  }

  *PtrToNode = MakeKDNode (Key, (char *) Data, Level);
}                                /* KDStore */


/*---------------------------------------------------------------------------*/
/**
 * This routine deletes a node from Tree.  The node to be
 * deleted is specified by the Key for the node and the Data
 * contents of the node.  These two pointers must be identical
 * to the pointers that were used for the node when it was
 * originally stored in the tree.  A node will be deleted from
 * the tree only if its key and data pointers are identical
 * to Key and Data respectively.  The empty space left in the tree
 * is filled by pulling a leaf up from the bottom of one of
 * the subtrees of the node being deleted.  The leaf node will
 * be pulled from left subtrees whenever possible (this was
 * an arbitrary decision).  No attempt is made to pull the leaf
 * from the deepest subtree (to minimize length).  The branch
 * point for the replacement node is changed to be the same as
 * the branch point of the deleted node.  This keeps us from
 * having to rearrange the tree every time we delete a node.
 * Also, the LeftBranch and RightBranch numbers of the
 * replacement node are set to be the same as the deleted node.
 * The makes the delete easier and more efficient, but it may
 * make searches in the tree less efficient after many nodes are
 * deleted.  If the node specified by Key and Data does not
 * exist in the tree, then nothing is done.
 *
 * Globals:
 * - N		dimension of the K-D tree
 * - KeyDesc		description of each dimension
 * - DeleteCount	debug variables for performance tests
 * - DeleteProbeCount
 *
 * @param Tree K-D tree to delete node from
 * @param Key key of node to be deleted
 * @param Data data contents of node to be deleted
 *
 * @note Exceptions: none
 *
 * @note History:	3/13/89, DSJ, Created.
 *    		        7/13/89, DSJ, Specify node indirectly by key and data.
 */
void
KDDelete (KDTREE * Tree, FLOAT32 Key[], void *Data) {
  int Level;
  KDNODE *Current;
  KDNODE *Father;
  KDNODE *Replacement;
  KDNODE *FatherReplacement;

  /* initialize search at root of tree */
  N = Tree->KeySize;
  KeyDesc = &(Tree->KeyDesc[0]);
  Father = &(Tree->Root);
  Current = Father->Left;
  Level = NextLevel(-1);

  /* search tree for node to be deleted */
  while ((Current != NULL) && (!NodeFound (Current, Key, Data))) {
    Father = Current;
    if (Key[Level] < Current->BranchPoint)
      Current = Current->Left;
    else
      Current = Current->Right;

    Level = NextLevel(Level);
  }

  if (Current != NULL) {         /* if node to be deleted was found */
    Replacement = Current;
    FatherReplacement = Father;

    /* search for replacement node (a leaf under node to be deleted */
    while (TRUE) {
      if (Replacement->Left != NULL) {
        FatherReplacement = Replacement;
        Replacement = Replacement->Left;
      }
      else if (Replacement->Right != NULL) {
        FatherReplacement = Replacement;
        Replacement = Replacement->Right;
      }
      else
        break;

      Level = NextLevel(Level);
    }

    /* compute level of replacement node's father */
    Level = PrevLevel(Level);

    /* disconnect replacement node from it's father */
    if (FatherReplacement->Left == Replacement) {
      FatherReplacement->Left = NULL;
      FatherReplacement->LeftBranch = KeyDesc[Level].Min;
    }
    else {
      FatherReplacement->Right = NULL;
      FatherReplacement->RightBranch = KeyDesc[Level].Max;
    }

    /* replace deleted node with replacement (unless they are the same) */
    if (Replacement != Current) {
      Replacement->BranchPoint = Current->BranchPoint;
      Replacement->LeftBranch = Current->LeftBranch;
      Replacement->RightBranch = Current->RightBranch;
      Replacement->Left = Current->Left;
      Replacement->Right = Current->Right;

      if (Father->Left == Current)
        Father->Left = Replacement;
      else
        Father->Right = Replacement;
    }
    FreeKDNode(Current);
  }
}                                /* KDDelete */


/*---------------------------------------------------------------------------*/
int
KDNearestNeighborSearch (KDTREE * Tree,
FLOAT32 Query[],
int QuerySize,
FLOAT32 MaxDistance,
void *NBuffer, FLOAT32 DBuffer[]) {
/*
 **	Parameters:
 **		Tree		ptr to K-D tree to be searched
 **		Query		ptr to query key (point in D-space)
 **		QuerySize	number of nearest neighbors to be found
 **		MaxDistance	all neighbors must be within this distance
 **		NBuffer		ptr to QuerySize buffer to hold nearest neighbors
 **		DBuffer		ptr to QuerySize buffer to hold distances
 **					from nearest neighbor to query point
 **	Globals:
 **		NumberOfNeighbors	# of neighbors found so far
 **		N			# of features in each key
 **		KeyDesc			description of tree dimensions
 **		QueryPoint		point in D-space to find neighbors of
 **		MaxNeighbors		maximum # of neighbors to find
 **		Radius			current distance of furthest neighbor
 **		Furthest		index of furthest neighbor
 **		Neighbor		buffer of current neighbors
 **		Distance		buffer of neighbor distances
 **		SBMin			lower extent of small search region
 **		SBMax			upper extent of small search region
 **		LBMin			lower extent of large search region
 **		LBMax			upper extent of large search region
 **		QuickExit		quick exit from recursive search
 **	Operation:
 **		This routine searches the K-D tree specified by Tree and
 **		finds the QuerySize nearest neighbors of Query.  All neighbors
 **		must be within MaxDistance of Query.  The data contents of
 **		the nearest neighbors
 **		are placed in NBuffer and their distances from Query are
 **		placed in DBuffer.
 **	Return: Number of nearest neighbors actually found
 **	Exceptions: none
 **	History:
 **		3/10/89, DSJ, Created.
 **		7/13/89, DSJ, Return contents of node instead of node itself.
 */
  int i;

  NumberOfNeighbors = 0;
  N = Tree->KeySize;
  KeyDesc = &(Tree->KeyDesc[0]);
  QueryPoint = Query;
  MaxNeighbors = QuerySize;
  Radius = MaxDistance;
  Furthest = 0;
  Neighbor = (char **) NBuffer;
  Distance = DBuffer;

  for (i = 0; i < N; i++) {
    SBMin[i] = KeyDesc[i].Min;
    SBMax[i] = KeyDesc[i].Max;
    LBMin[i] = KeyDesc[i].Min;
    LBMax[i] = KeyDesc[i].Max;
  }

  if (Tree->Root.Left != NULL) {
    if (setjmp (QuickExit) == 0)
      Search (0, Tree->Root.Left);
  }
  return (NumberOfNeighbors);
}                                /* KDNearestNeighborSearch */


/*---------------------------------------------------------------------------*/
void KDWalk(KDTREE *Tree, void_proc Action) {
/*
 **	Parameters:
 **		Tree	ptr to K-D tree to be walked
 **		Action	ptr to function to be executed at each node
 **	Globals:
 **		WalkAction	action to be performed at every node
 **	Operation:
 **		This routine stores the desired action in a global
 **		variable and starts a recursive walk of Tree.  The walk
 **		is started at the root node.
 **	Return:
 **		None
 **	Exceptions:
 **		None
 **	History:
 **		3/13/89, DSJ, Created.
 */
  WalkAction = Action;
  if (Tree->Root.Left != NULL)
    Walk (Tree->Root.Left, NextLevel(-1));
}                                /* KDWalk */


/*---------------------------------------------------------------------------*/
void FreeKDTree(KDTREE *Tree) {
/*
 **	Parameters:
 **		Tree	tree data structure to be released
 **	Globals: none
 **	Operation:
 **		This routine frees all memory which is allocated to the
 **		specified KD-tree.  This includes the data structure for
 **		the kd-tree itself plus the data structures for each node
 **		in the tree.  It does not include the Key and Data items
 **		which are pointed to by the nodes.  This memory is left
 **		untouched.
 **	Return: none
 **	Exceptions: none
 **	History:
 **		5/26/89, DSJ, Created.
 */
  FreeSubTree (Tree->Root.Left);
  memfree(Tree);
}                                /* FreeKDTree */


/*-----------------------------------------------------------------------------
              Private Code
-----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
int
Equal (FLOAT32 Key1[], FLOAT32 Key2[]) {
/*
 **	Parameters:
 **		Key1,Key2	search keys to be compared for equality
 **	Globals:
 **		N		number of parameters per key
 **	Operation:
 **		This routine returns TRUE if Key1 = Key2.
 **	Return:
 **		TRUE if Key1 = Key2, else FALSE.
 **	Exceptions:
 **		None
 **	History:
 **		3/11/89, DSJ, Created.
 */
  int i;

  for (i = N; i > 0; i--, Key1++, Key2++)
    if (*Key1 != *Key2)
      return (FALSE);
  return (TRUE);
}                                /* Equal */


/*---------------------------------------------------------------------------*/
KDNODE *
MakeKDNode (FLOAT32 Key[], char *Data, int Index) {
/*
 **	Parameters:
 **		Key	Access key for new node in KD tree
 **		Data	ptr to data to be stored in new node
 **		Index	index of Key to branch on
 **	Globals:
 **		KeyDesc	descriptions of key dimensions
 **	Operation:
 **		This routine allocates memory for a new K-D tree node
 **		and places the specified Key and Data into it.  The
 **		left and right subtree pointers for the node are
 **		initialized to empty subtrees.
 **	Return:
 **		pointer to new K-D tree node
 **	Exceptions:
 **		None
 **	History:
 **		3/11/89, DSJ, Created.
 */
  KDNODE *NewNode;

  NewNode = (KDNODE *) Emalloc (sizeof (KDNODE));

  NewNode->Key = Key;
  NewNode->Data = Data;
  NewNode->BranchPoint = Key[Index];
  NewNode->LeftBranch = KeyDesc[Index].Min;
  NewNode->RightBranch = KeyDesc[Index].Max;
  NewNode->Left = NULL;
  NewNode->Right = NULL;

  return (NewNode);
}                                /* MakeKDNode */


/*---------------------------------------------------------------------------*/
void FreeKDNode(KDNODE *Node) {
/*
 **	Parameters:
 **		Node	ptr to node data structure to be freed
 **	Globals:
 **		None
 **	Operation:
 **		This routine frees up the memory allocated to Node.
 **	Return:
 **		None
 **	Exceptions:
 **		None
 **	History:
 **		3/13/89, DSJ, Created.
 */
  memfree ((char *) Node);
}                                /* FreeKDNode */


/*---------------------------------------------------------------------------*/
void Search(int Level, KDNODE *SubTree) {
/*
 **	Parameters:
 **		Level		level in tree of sub-tree to be searched
 **		SubTree		sub-tree to be searched
 **	Globals:
 **		NumberOfNeighbors	# of neighbors found so far
 **		N			# of features in each key
 **		KeyDesc			description of key dimensions
 **		QueryPoint		point in D-space to find neighbors of
 **		MaxNeighbors		maximum # of neighbors to find
 **		Radius			current distance of furthest neighbor
 **		Furthest		index of furthest neighbor
 **		Neighbor		buffer of current neighbors
 **		Distance		buffer of neighbor distances
 **		SBMin			lower extent of small search region
 **		SBMax			upper extent of small search region
 **		LBMin			lower extent of large search region
 **		LBMax			upper extent of large search region
 **		QuickExit		quick exit from recursive search
 **	Operation:
 **		This routine searches SubTree for those entries which are
 **		possibly among the MaxNeighbors nearest neighbors of the
 **		QueryPoint and places their data in the Neighbor buffer and
 **		their distances from QueryPoint in the Distance buffer.
 **	Return: none
 **	Exceptions: none
 **	History:
 **		3/11/89, DSJ, Created.
 **		7/13/89, DSJ, Save node contents, not node, in neighbor buffer
 */
  FLOAT32 d;
  FLOAT32 OldSBoxEdge;
  FLOAT32 OldLBoxEdge;

  if (Level >= N)
    Level = 0;

  d = ComputeDistance (N, KeyDesc, QueryPoint, SubTree->Key);
  if (d < Radius) {
    if (NumberOfNeighbors < MaxNeighbors) {
      Neighbor[NumberOfNeighbors] = SubTree->Data;
      Distance[NumberOfNeighbors] = d;
      NumberOfNeighbors++;
      if (NumberOfNeighbors == MaxNeighbors)
        FindMaxDistance();
    }
    else {
      Neighbor[Furthest] = SubTree->Data;
      Distance[Furthest] = d;
      FindMaxDistance();
    }
  }
  if (QueryPoint[Level] < SubTree->BranchPoint) {
    OldSBoxEdge = SBMax[Level];
    SBMax[Level] = SubTree->LeftBranch;
    OldLBoxEdge = LBMax[Level];
    LBMax[Level] = SubTree->RightBranch;
    if (SubTree->Left != NULL)
      Search (NextLevel(Level), SubTree->Left);
    SBMax[Level] = OldSBoxEdge;
    LBMax[Level] = OldLBoxEdge;
    OldSBoxEdge = SBMin[Level];
    SBMin[Level] = SubTree->RightBranch;
    OldLBoxEdge = LBMin[Level];
    LBMin[Level] = SubTree->LeftBranch;
    if ((SubTree->Right != NULL) && QueryIntersectsSearch ())
      Search (NextLevel(Level), SubTree->Right);
    SBMin[Level] = OldSBoxEdge;
    LBMin[Level] = OldLBoxEdge;
  }
  else {
    OldSBoxEdge = SBMin[Level];
    SBMin[Level] = SubTree->RightBranch;
    OldLBoxEdge = LBMin[Level];
    LBMin[Level] = SubTree->LeftBranch;
    if (SubTree->Right != NULL)
      Search (NextLevel(Level), SubTree->Right);
    SBMin[Level] = OldSBoxEdge;
    LBMin[Level] = OldLBoxEdge;
    OldSBoxEdge = SBMax[Level];
    SBMax[Level] = SubTree->LeftBranch;
    OldLBoxEdge = LBMax[Level];
    LBMax[Level] = SubTree->RightBranch;
    if ((SubTree->Left != NULL) && QueryIntersectsSearch ())
      Search (NextLevel(Level), SubTree->Left);
    SBMax[Level] = OldSBoxEdge;
    LBMax[Level] = OldLBoxEdge;
  }
  if (QueryInSearch ())
    longjmp (QuickExit, 1);
}                                /* Search */


/*---------------------------------------------------------------------------*/
FLOAT32
ComputeDistance (register int N,
register PARAM_DESC Dim[],
register FLOAT32 p1[], register FLOAT32 p2[]) {
/*
 **	Parameters:
 **		N		number of dimensions in K-D space
 **		Dim		descriptions of each dimension
 **		p1,p2		two different points in K-D space
 **	Globals:
 **		None
 **	Operation:
 **		This routine computes the euclidian distance
 **		between p1 and p2 in K-D space (an N dimensional space).
 **	Return:
 **		Distance between p1 and p2.
 **	Exceptions:
 **		None
 **	History:
 **		3/11/89, DSJ, Created.
 */
  register FLOAT32 TotalDistance;
  register FLOAT32 DimensionDistance;
  FLOAT32 WrapDistance;

  TotalDistance = 0;
  for (; N > 0; N--, p1++, p2++, Dim++) {
    if (Dim->NonEssential)
      continue;

    DimensionDistance = *p1 - *p2;

    /* if this dimension is circular - check wraparound distance */
    if (Dim->Circular) {
      DimensionDistance = Magnitude (DimensionDistance);
      WrapDistance = Dim->Max - Dim->Min - DimensionDistance;
      DimensionDistance = MIN (DimensionDistance, WrapDistance);
    }

    TotalDistance += DimensionDistance * DimensionDistance;
  }
  return ((FLOAT32) sqrt ((FLOAT64) TotalDistance));
}                                /* ComputeDistance */


/*---------------------------------------------------------------------------*/
void FindMaxDistance() {
/*
 **	Parameters:
 **		None
 **	Globals:
 **		MaxNeighbors		maximum # of neighbors to find
 **		Radius			current distance of furthest neighbor
 **		Furthest		index of furthest neighbor
 **		Distance		buffer of neighbor distances
 **	Operation:
 **		This routine searches the Distance buffer for the maximum
 **		distance, places this distance in Radius, and places the
 **		index of this distance in Furthest.
 **	Return:
 **		None
 **	Exceptions:
 **		None
 **	History:
 **		3/11/89, DSJ, Created.
 */
  int i;

  Radius = Distance[Furthest];
  for (i = 0; i < MaxNeighbors; i++) {
    if (Distance[i] > Radius) {
      Radius = Distance[i];
      Furthest = i;
    }
  }
}                                /* FindMaxDistance */


/*---------------------------------------------------------------------------*/
int QueryIntersectsSearch() {
/*
 **	Parameters:
 **		None
 **	Globals:
 **		N			# of features in each key
 **		KeyDesc			descriptions of each dimension
 **		QueryPoint		point in D-space to find neighbors of
 **		Radius			current distance of furthest neighbor
 **		SBMin			lower extent of small search region
 **		SBMax			upper extent of small search region
 **	Operation:
 **		This routine returns TRUE if the query region intersects
 **		the current smallest search region.  The query region is
 **		the circle of radius Radius centered at QueryPoint.
 **		The smallest search region is the box (in N dimensions)
 **		whose edges in each dimension are specified by SBMin and SBMax.
 **		In the case of circular dimensions, we must also check the
 **		point which is one wrap-distance away from the query to
 **		see if it would intersect the search region.
 **	Return:
 **		TRUE if query region intersects search region, else FALSE
 **	Exceptions:
 **		None
 **	History:
 **		3/11/89, DSJ, Created.
 */
  register int i;
  register FLOAT32 *Query;
  register FLOAT32 *Lower;
  register FLOAT32 *Upper;
  register FLOAT64 TotalDistance;
  register FLOAT32 DimensionDistance;
  register FLOAT64 RadiusSquared;
  register PARAM_DESC *Dim;
  register FLOAT32 WrapDistance;

  RadiusSquared = Radius * Radius;
  Query = QueryPoint;
  Lower = SBMin;
  Upper = SBMax;
  TotalDistance = 0.0;
  Dim = KeyDesc;
  for (i = N; i > 0; i--, Dim++, Query++, Lower++, Upper++) {
    if (Dim->NonEssential)
      continue;

    if (*Query < *Lower)
      DimensionDistance = *Lower - *Query;
    else if (*Query > *Upper)
      DimensionDistance = *Query - *Upper;
    else
      DimensionDistance = 0;

    /* if this dimension is circular - check wraparound distance */
    if (Dim->Circular) {
      if (*Query < *Lower)
        WrapDistance = *Query + Dim->Max - Dim->Min - *Upper;
      else if (*Query > *Upper)
        WrapDistance = *Lower - (*Query - (Dim->Max - Dim->Min));
      else
        WrapDistance = MAX_FLOAT32;

      DimensionDistance = MIN (DimensionDistance, WrapDistance);
    }

    TotalDistance += DimensionDistance * DimensionDistance;
    if (TotalDistance >= RadiusSquared)
      return (FALSE);
  }
  return (TRUE);
}                                /* QueryIntersectsSearch */


/*---------------------------------------------------------------------------*/
int QueryInSearch() {
/*
 **	Parameters:
 **		None
 **	Globals:
 **		N			# of features in each key
 **		KeyDesc			descriptions of each dimension
 **		QueryPoint		point in D-space to find neighbors of
 **		Radius			current distance of furthest neighbor
 **		LBMin			lower extent of large search region
 **		LBMax			upper extent of large search region
 **	Operation:
 **		This routine returns TRUE if the current query region is
 **		totally contained in the current largest search region.
 **		The query region is the circle of
 **		radius Radius centered at QueryPoint.  The search region is
 **		the box (in N dimensions) whose edges in each
 **		dimension are specified by LBMin and LBMax.
 **	Return:
 **		TRUE if query region is inside search region, else FALSE
 **	Exceptions:
 **		None
 **	History:
 **		3/11/89, DSJ, Created.
 */
  register int i;
  register FLOAT32 *Query;
  register FLOAT32 *Lower;
  register FLOAT32 *Upper;
  register PARAM_DESC *Dim;

  Query = QueryPoint;
  Lower = LBMin;
  Upper = LBMax;
  Dim = KeyDesc;

  for (i = N - 1; i >= 0; i--, Dim++, Query++, Lower++, Upper++) {
    if (Dim->NonEssential)
      continue;

    if ((*Query < *Lower + Radius) || (*Query > *Upper - Radius))
      return (FALSE);
  }
  return (TRUE);
}                                /* QueryInSearch */


/*---------------------------------------------------------------------------*/
void Walk(KDNODE *SubTree, inT32 Level) {
/*
 **	Parameters:
 **		SubTree		ptr to root of subtree to be walked
 **		Level		current level in the tree for this node
 **	Globals:
 **		WalkAction	action to be performed at every node
 **	Operation:
 **		This routine walks thru the specified SubTree and invokes
 **		WalkAction at each node.  WalkAction is invoked with three
 **		arguments as follows:
 **			WalkAction( NodeData, Order, Level )
 **		Data is the data contents of the node being visited,
 **		Order is either preorder,
 **		postorder, endorder, or leaf depending on whether this is
 **		the 1st, 2nd, or 3rd time a node has been visited, or
 **		whether the node is a leaf.  Level is the level of the node in
 **		the tree with the root being level 0.
 **	Return: none
 **	Exceptions: none
 **	History:
 **		3/13/89, DSJ, Created.
 **		7/13/89, DSJ, Pass node contents, not node, to WalkAction().
 */
  if ((SubTree->Left == NULL) && (SubTree->Right == NULL))
    (*WalkAction) (SubTree->Data, leaf, Level);
  else {
    (*WalkAction) (SubTree->Data, preorder, Level);
    if (SubTree->Left != NULL)
      Walk (SubTree->Left, NextLevel(Level));
    (*WalkAction) (SubTree->Data, postorder, Level);
    if (SubTree->Right != NULL)
      Walk (SubTree->Right, NextLevel(Level));
    (*WalkAction) (SubTree->Data, endorder, Level);
  }
}                                /* Walk */


/*---------------------------------------------------------------------------*/
void FreeSubTree(KDNODE *SubTree) {
/*
 **	Parameters:
 **		SubTree		ptr to root node of sub-tree to be freed
 **	Globals: none
 **	Operation:
 **		This routine recursively frees the memory allocated to
 **		to the specified subtree.
 **	Return: none
 **	Exceptions: none
 **	History: 7/13/89, DSJ, Created.
 */
  if (SubTree != NULL) {
    FreeSubTree (SubTree->Left);
    FreeSubTree (SubTree->Right);
    memfree(SubTree);
  }
}                                /* FreeSubTree */
/////////////////////////////////////////////////////////////////kdtree////////////////////////////////////////

/////////////////////////////////////////////////////////////////oldheap////////////////////////////////////////
#define FATHER(N) ((N)>>1)
#define LEFTSON(N)  ((N)<<1)
#define RIGHTSON(N) ((N)<<1 + 1)

/*-----------------------------------------------------------------------------
              Public Code
-----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/**
 * This routine creates and initializes a new heap data
 * structure containing Size elements.  In actuality, Size + 1
 * elements are allocated.  The first element, element 0, is
 * unused, this makes the index arithmetic easier.
 *
 * Globals:
 * - None
 *
 * @param Size maximum number of entries in the heap
 * @return Pointer to the new heap.
 * @note Exceptions: None
 * @note History: 3/13/89, DSJ, Created.
 */
HEAP *MakeHeap(int Size) {
  HEAP *NewHeap;

  NewHeap = (HEAP *) Emalloc (sizeof (HEAP) + Size * sizeof (HEAPENTRY));

  NewHeap->Size = Size;
  NewHeap->FirstFree = 1;
  return (NewHeap);
}                                /* MakeHeap */


/*---------------------------------------------------------------------------*/
/**
 * This routine removes the top item on the heap and places
 * its contents into Key and Data.
 *
 * Globals:
 * - None
 *
 * @param Heap ptr to heap whose top is to be removed and returned
 * @param Key place to put key of top heap item
 * @param Data place to put data of top heap item
 *
 * @return OK if top entry returned, EMPTY if heap is empty
 * @note Exceptions: None
 * @note History: 5/10/91, DSJ, Created (Modified from GetTopOfHeap).
 */
int HeapPop(HEAP *Heap, FLOAT32 *Key, void *out_ptr) {
  inT32 Hole;
  FLOAT32 HoleKey;
  inT32 Son;
  void **Data = (void **) out_ptr;

  if (Heap->FirstFree <= 1)
    return (EMPTY);

  *Key = Heap->Entry[1].Key;
  *Data = Heap->Entry[1].Data;

  Heap->FirstFree--;

  /* imagine the hole at the root is filled with the last entry in the heap */
  HoleKey = Heap->Entry[Heap->FirstFree].Key;
  Hole = 1;

                                 /* while hole has 2 sons */
  while ((Son = LEFTSON (Hole)) < Heap->FirstFree) {
    /* find the son with the smallest key */
    if (Heap->Entry[Son].Key > Heap->Entry[Son + 1].Key)
      Son++;

    /* if key for hole is greater than key for son, sift hole down */
    if (HoleKey > Heap->Entry[Son].Key) {
      Heap->Entry[Hole].Key = Heap->Entry[Son].Key;
      Heap->Entry[Hole].Data = Heap->Entry[Son].Data;
      Hole = Son;
    }
    else
      break;
  }
  Heap->Entry[Hole].Key = HoleKey;
  Heap->Entry[Hole].Data = Heap->Entry[Heap->FirstFree].Data;
  return (OK);
}                                /* HeapPop */


/**
 * HeapPopWorst
 *
 * Remove the largest item from the heap.
 *
 * @param Heap ptr to heap whose top is to be removed and returned
 * @param Key place to put key of top heap item
 * @param Data place to put data of top heap item
 */
int HeapPopWorst(HEAP *Heap, FLOAT32 *Key, void *out_ptr) {
  inT32 Index;                   /*current index */
  inT32 Hole;
  FLOAT32 HoleKey;
  inT32 Father;
  void *HoleData;
  void **Data = (void **) out_ptr;

  if (Heap->FirstFree <= 1)
    return (EMPTY);

  HoleKey = Heap->Entry[1].Key;
  Hole = 1;
  Heap->FirstFree--;
  for (Index = Heap->FirstFree, Father = FATHER (Index); Index > Father;
    Index--)
  if (Heap->Entry[Index].Key > HoleKey) {
                                 /*find biggest */
    HoleKey = Heap->Entry[Index].Key;
    Hole = Index;
  }
  *Key = HoleKey;
  *Data = Heap->Entry[Hole].Data;

  HoleKey = Heap->Entry[Heap->FirstFree].Key;
  Heap->Entry[Hole].Key = HoleKey;
  HoleData = Heap->Entry[Heap->FirstFree].Data;
  Heap->Entry[Hole].Data = HoleData;

  /* now sift last entry to its rightful place */
  Father = FATHER (Hole);        /*father of hole */
  while (Hole > 1 && Heap->Entry[Father].Key > HoleKey) {
                                 /*swap entries */
    Heap->Entry[Hole].Key = Heap->Entry[Father].Key;
    Heap->Entry[Hole].Data = Heap->Entry[Father].Data;
    Heap->Entry[Father].Data = HoleData;
    Heap->Entry[Father].Key = HoleKey;
    Hole = Father;
    Father = FATHER (Hole);
  }
  return (OK);
}                                /* HeapPop */


/*---------------------------------------------------------------------------*/
/**
 * This routine stores Data into Heap and associates it
 * with Key.  The heap is
 * maintained in such a way that the item with the lowest key
 * is always at the top of the heap.
 *
 * Globals:
 * - None
 *
 * @param Heap ptr to heap to store new item in
 * @param Key numeric key associated with new item
 * @param Data ptr to data contents of new item
 *
 * @note Exceptions:
 * - HEAPFULL error if heap size is exceeded
 *
 * @note History: 5/10/91, DSJ, Created (Modified version of HeapStore).
 */
void HeapPush(HEAP *Heap, FLOAT32 Key, void *Data) {
  inT32 Item;
  inT32 Father;

  if (Heap->FirstFree > Heap->Size)
    DoError (HEAPFULL, "Heap size exceeded");

  Item = Heap->FirstFree;
  Heap->FirstFree++;
  while (Item != 1) {
    Father = FATHER (Item);
    if (Heap->Entry[Father].Key > Key) {
      Heap->Entry[Item].Key = Heap->Entry[Father].Key;
      Heap->Entry[Item].Data = Heap->Entry[Father].Data;
      Item = Father;
    }
    else
      break;
  }
  Heap->Entry[Item].Key = Key;
  Heap->Entry[Item].Data = Data;
}                                /* HeapPush */


/*---------------------------------------------------------------------------*/
/**
 * This routine stores Entry into Heap.  The heap is
 * maintained in such a way that the item with the lowest key
 * is always at the top of the heap.
 *
 * Globals:
 * - None
 *
 * @param Heap ptr to heap to store new item in
 * @param Entry ptr to item to be stored in Heap
 * @note Exceptions:
 * - HEAPFULL error if heap size is exceeded
 * @note History: 3/13/89, DSJ, Created.
 */
void HeapStore(HEAP *Heap, HEAPENTRY *Entry) {
  inT32 Item;
  inT32 Father;

  if (Heap->FirstFree > Heap->Size)
    DoError (HEAPFULL, "Heap size exceeded");

  Item = Heap->FirstFree;
  Heap->FirstFree++;
  while (Item != 1) {
    Father = FATHER (Item);
    if (Heap->Entry[Father].Key > Entry->Key) {
      Heap->Entry[Item].Key = Heap->Entry[Father].Key;
      Heap->Entry[Item].Data = Heap->Entry[Father].Data;
      Item = Father;
    }
    else
      break;
  }
  Heap->Entry[Item].Key = Entry->Key;
  Heap->Entry[Item].Data = Entry->Data;
}                                /* HeapStore */


/*---------------------------------------------------------------------------*/
/**
 * This routine removes the top item on the heap and copies its
 * contents into Entry.
 *
 * @param Heap ptr to heap whose top is to be removed and returned
 * @param Entry ptr to heap entry to be filled with top entry on Heap
 *
 * Globals:
 * - None
 *
 * @return OK if top entry returned, EMPTY if heap is empty
 * @note Exceptions: None
 * @note History: 3/13/89, DSJ, Created.
 */
int GetTopOfHeap(HEAP *Heap, HEAPENTRY *Entry) {
  inT32 Hole;
  FLOAT32 HoleKey;
  inT32 Son;

  if (Heap->FirstFree <= 1)
    return (EMPTY);

  Entry->Key = Heap->Entry[1].Key;
  Entry->Data = Heap->Entry[1].Data;

  Heap->FirstFree--;

  /* imagine the hole at the root is filled with the last entry in the heap */
  HoleKey = Heap->Entry[Heap->FirstFree].Key;
  Hole = 1;

                                 /* while hole has 2 sons */
  while ((Son = LEFTSON (Hole)) < Heap->FirstFree) {
    /* find the son with the smallest key */
    if (Heap->Entry[Son].Key > Heap->Entry[Son + 1].Key)
      Son++;

    /* if key for hole is greater than key for son, sift hole down */
    if (HoleKey > Heap->Entry[Son].Key) {
      Heap->Entry[Hole].Key = Heap->Entry[Son].Key;
      Heap->Entry[Hole].Data = Heap->Entry[Son].Data;
      Hole = Son;
    }
    else
      break;
  }
  Heap->Entry[Hole].Key = HoleKey;
  Heap->Entry[Hole].Data = Heap->Entry[Heap->FirstFree].Data;
  return (OK);
}                                /* GetTopOfHeap */


/*---------------------------------------------------------------------------*/
/**
 * This routine is similar to FreeHeap in that it
 * deallocates the memory consumed by the heap.  However, it
 * also calls Deallocator for each item in the heap so that
 * this data is also deallocated.
 *
 * @param Heap heap whose data is to be freed
 * @param Deallocator function to be used to deallocate data
 *
 * Globals:
 * - None
 *
 * @note Exceptions: none
 * @note History: Tue May 15 08:52:04 1990, DSJ, Created.
 */
void FreeHeapData(HEAP *Heap, void_dest destructor) {
  HEAPENTRY Entry;

  while (GetTopOfHeap (Heap, &Entry) != EMPTY)
    destructor (Entry.Data);

  FreeHeap(Heap);
}                                /* FreeHeapData */
/////////////////////////////////////////////////////////////////oldheap////////////////////////////////////////

/////////////////////////////////////////////////////////////////cluster////////////////////////////////////////
#define HOTELLING 1  // If true use Hotelling's test to decide where to split.
#define FTABLE_X 10  // Size of FTable.
#define FTABLE_Y 100  // Size of FTable.

// Table of values approximating the cumulative F-distribution for a confidence of 1%.
double FTable[FTABLE_Y][FTABLE_X] = {
 {4052.19, 4999.52, 5403.34, 5624.62, 5763.65, 5858.97, 5928.33, 5981.10, 6022.50, 6055.85,},
  {98.502,  99.000,  99.166,  99.249,  99.300,  99.333,  99.356,  99.374,  99.388,  99.399,},
  {34.116,  30.816,  29.457,  28.710,  28.237,  27.911,  27.672,  27.489,  27.345,  27.229,},
  {21.198,  18.000,  16.694,  15.977,  15.522,  15.207,  14.976,  14.799,  14.659,  14.546,},
  {16.258,  13.274,  12.060,  11.392,  10.967,  10.672,  10.456,  10.289,  10.158,  10.051,},
  {13.745,  10.925,   9.780,   9.148,   8.746,   8.466,   8.260,   8.102,   7.976,   7.874,},
  {12.246,   9.547,   8.451,   7.847,   7.460,   7.191,   6.993,   6.840,   6.719,   6.620,},
  {11.259,   8.649,   7.591,   7.006,   6.632,   6.371,   6.178,   6.029,   5.911,   5.814,},
  {10.561,   8.022,   6.992,   6.422,   6.057,   5.802,   5.613,   5.467,   5.351,   5.257,},
  {10.044,   7.559,   6.552,   5.994,   5.636,   5.386,   5.200,   5.057,   4.942,   4.849,},
  { 9.646,   7.206,   6.217,   5.668,   5.316,   5.069,   4.886,   4.744,   4.632,   4.539,},
  { 9.330,   6.927,   5.953,   5.412,   5.064,   4.821,   4.640,   4.499,   4.388,   4.296,},
  { 9.074,   6.701,   5.739,   5.205,   4.862,   4.620,   4.441,   4.302,   4.191,   4.100,},
  { 8.862,   6.515,   5.564,   5.035,   4.695,   4.456,   4.278,   4.140,   4.030,   3.939,},
  { 8.683,   6.359,   5.417,   4.893,   4.556,   4.318,   4.142,   4.004,   3.895,   3.805,},
  { 8.531,   6.226,   5.292,   4.773,   4.437,   4.202,   4.026,   3.890,   3.780,   3.691,},
  { 8.400,   6.112,   5.185,   4.669,   4.336,   4.102,   3.927,   3.791,   3.682,   3.593,},
  { 8.285,   6.013,   5.092,   4.579,   4.248,   4.015,   3.841,   3.705,   3.597,   3.508,},
  { 8.185,   5.926,   5.010,   4.500,   4.171,   3.939,   3.765,   3.631,   3.523,   3.434,},
  { 8.096,   5.849,   4.938,   4.431,   4.103,   3.871,   3.699,   3.564,   3.457,   3.368,},
  { 8.017,   5.780,   4.874,   4.369,   4.042,   3.812,   3.640,   3.506,   3.398,   3.310,},
  { 7.945,   5.719,   4.817,   4.313,   3.988,   3.758,   3.587,   3.453,   3.346,   3.258,},
  { 7.881,   5.664,   4.765,   4.264,   3.939,   3.710,   3.539,   3.406,   3.299,   3.211,},
  { 7.823,   5.614,   4.718,   4.218,   3.895,   3.667,   3.496,   3.363,   3.256,   3.168,},
  { 7.770,   5.568,   4.675,   4.177,   3.855,   3.627,   3.457,   3.324,   3.217,   3.129,},
  { 7.721,   5.526,   4.637,   4.140,   3.818,   3.591,   3.421,   3.288,   3.182,   3.094,},
  { 7.677,   5.488,   4.601,   4.106,   3.785,   3.558,   3.388,   3.256,   3.149,   3.062,},
  { 7.636,   5.453,   4.568,   4.074,   3.754,   3.528,   3.358,   3.226,   3.120,   3.032,},
  { 7.598,   5.420,   4.538,   4.045,   3.725,   3.499,   3.330,   3.198,   3.092,   3.005,},
  { 7.562,   5.390,   4.510,   4.018,   3.699,   3.473,   3.305,   3.173,   3.067,   2.979,},
  { 7.530,   5.362,   4.484,   3.993,   3.675,   3.449,   3.281,   3.149,   3.043,   2.955,},
  { 7.499,   5.336,   4.459,   3.969,   3.652,   3.427,   3.258,   3.127,   3.021,   2.934,},
  { 7.471,   5.312,   4.437,   3.948,   3.630,   3.406,   3.238,   3.106,   3.000,   2.913,},
  { 7.444,   5.289,   4.416,   3.927,   3.611,   3.386,   3.218,   3.087,   2.981,   2.894,},
  { 7.419,   5.268,   4.396,   3.908,   3.592,   3.368,   3.200,   3.069,   2.963,   2.876,},
  { 7.396,   5.248,   4.377,   3.890,   3.574,   3.351,   3.183,   3.052,   2.946,   2.859,},
  { 7.373,   5.229,   4.360,   3.873,   3.558,   3.334,   3.167,   3.036,   2.930,   2.843,},
  { 7.353,   5.211,   4.343,   3.858,   3.542,   3.319,   3.152,   3.021,   2.915,   2.828,},
  { 7.333,   5.194,   4.327,   3.843,   3.528,   3.305,   3.137,   3.006,   2.901,   2.814,},
  { 7.314,   5.179,   4.313,   3.828,   3.514,   3.291,   3.124,   2.993,   2.888,   2.801,},
  { 7.296,   5.163,   4.299,   3.815,   3.501,   3.278,   3.111,   2.980,   2.875,   2.788,},
  { 7.280,   5.149,   4.285,   3.802,   3.488,   3.266,   3.099,   2.968,   2.863,   2.776,},
  { 7.264,   5.136,   4.273,   3.790,   3.476,   3.254,   3.087,   2.957,   2.851,   2.764,},
  { 7.248,   5.123,   4.261,   3.778,   3.465,   3.243,   3.076,   2.946,   2.840,   2.754,},
  { 7.234,   5.110,   4.249,   3.767,   3.454,   3.232,   3.066,   2.935,   2.830,   2.743,},
  { 7.220,   5.099,   4.238,   3.757,   3.444,   3.222,   3.056,   2.925,   2.820,   2.733,},
  { 7.207,   5.087,   4.228,   3.747,   3.434,   3.213,   3.046,   2.916,   2.811,   2.724,},
  { 7.194,   5.077,   4.218,   3.737,   3.425,   3.204,   3.037,   2.907,   2.802,   2.715,},
  { 7.182,   5.066,   4.208,   3.728,   3.416,   3.195,   3.028,   2.898,   2.793,   2.706,},
  { 7.171,   5.057,   4.199,   3.720,   3.408,   3.186,   3.020,   2.890,   2.785,   2.698,},
  { 7.159,   5.047,   4.191,   3.711,   3.400,   3.178,   3.012,   2.882,   2.777,   2.690,},
  { 7.149,   5.038,   4.182,   3.703,   3.392,   3.171,   3.005,   2.874,   2.769,   2.683,},
  { 7.139,   5.030,   4.174,   3.695,   3.384,   3.163,   2.997,   2.867,   2.762,   2.675,},
  { 7.129,   5.021,   4.167,   3.688,   3.377,   3.156,   2.990,   2.860,   2.755,   2.668,},
  { 7.119,   5.013,   4.159,   3.681,   3.370,   3.149,   2.983,   2.853,   2.748,   2.662,},
  { 7.110,   5.006,   4.152,   3.674,   3.363,   3.143,   2.977,   2.847,   2.742,   2.655,},
  { 7.102,   4.998,   4.145,   3.667,   3.357,   3.136,   2.971,   2.841,   2.736,   2.649,},
  { 7.093,   4.991,   4.138,   3.661,   3.351,   3.130,   2.965,   2.835,   2.730,   2.643,},
  { 7.085,   4.984,   4.132,   3.655,   3.345,   3.124,   2.959,   2.829,   2.724,   2.637,},
  { 7.077,   4.977,   4.126,   3.649,   3.339,   3.119,   2.953,   2.823,   2.718,   2.632,},
  { 7.070,   4.971,   4.120,   3.643,   3.333,   3.113,   2.948,   2.818,   2.713,   2.626,},
  { 7.062,   4.965,   4.114,   3.638,   3.328,   3.108,   2.942,   2.813,   2.708,   2.621,},
  { 7.055,   4.959,   4.109,   3.632,   3.323,   3.103,   2.937,   2.808,   2.703,   2.616,},
  { 7.048,   4.953,   4.103,   3.627,   3.318,   3.098,   2.932,   2.803,   2.698,   2.611,},
  { 7.042,   4.947,   4.098,   3.622,   3.313,   3.093,   2.928,   2.798,   2.693,   2.607,},
  { 7.035,   4.942,   4.093,   3.618,   3.308,   3.088,   2.923,   2.793,   2.689,   2.602,},
  { 7.029,   4.937,   4.088,   3.613,   3.304,   3.084,   2.919,   2.789,   2.684,   2.598,},
  { 7.023,   4.932,   4.083,   3.608,   3.299,   3.080,   2.914,   2.785,   2.680,   2.593,},
  { 7.017,   4.927,   4.079,   3.604,   3.295,   3.075,   2.910,   2.781,   2.676,   2.589,},
  { 7.011,   4.922,   4.074,   3.600,   3.291,   3.071,   2.906,   2.777,   2.672,   2.585,},
  { 7.006,   4.917,   4.070,   3.596,   3.287,   3.067,   2.902,   2.773,   2.668,   2.581,},
  { 7.001,   4.913,   4.066,   3.591,   3.283,   3.063,   2.898,   2.769,   2.664,   2.578,},
  { 6.995,   4.908,   4.062,   3.588,   3.279,   3.060,   2.895,   2.765,   2.660,   2.574,},
  { 6.990,   4.904,   4.058,   3.584,   3.275,   3.056,   2.891,   2.762,   2.657,   2.570,},
  { 6.985,   4.900,   4.054,   3.580,   3.272,   3.052,   2.887,   2.758,   2.653,   2.567,},
  { 6.981,   4.896,   4.050,   3.577,   3.268,   3.049,   2.884,   2.755,   2.650,   2.563,},
  { 6.976,   4.892,   4.047,   3.573,   3.265,   3.046,   2.881,   2.751,   2.647,   2.560,},
  { 6.971,   4.888,   4.043,   3.570,   3.261,   3.042,   2.877,   2.748,   2.644,   2.557,},
  { 6.967,   4.884,   4.040,   3.566,   3.258,   3.039,   2.874,   2.745,   2.640,   2.554,},
  { 6.963,   4.881,   4.036,   3.563,   3.255,   3.036,   2.871,   2.742,   2.637,   2.551,},
  { 6.958,   4.877,   4.033,   3.560,   3.252,   3.033,   2.868,   2.739,   2.634,   2.548,},
  { 6.954,   4.874,   4.030,   3.557,   3.249,   3.030,   2.865,   2.736,   2.632,   2.545,},
  { 6.950,   4.870,   4.027,   3.554,   3.246,   3.027,   2.863,   2.733,   2.629,   2.542,},
  { 6.947,   4.867,   4.024,   3.551,   3.243,   3.025,   2.860,   2.731,   2.626,   2.539,},
  { 6.943,   4.864,   4.021,   3.548,   3.240,   3.022,   2.857,   2.728,   2.623,   2.537,},
  { 6.939,   4.861,   4.018,   3.545,   3.238,   3.019,   2.854,   2.725,   2.621,   2.534,},
  { 6.935,   4.858,   4.015,   3.543,   3.235,   3.017,   2.852,   2.723,   2.618,   2.532,},
  { 6.932,   4.855,   4.012,   3.540,   3.233,   3.014,   2.849,   2.720,   2.616,   2.529,},
  { 6.928,   4.852,   4.010,   3.538,   3.230,   3.012,   2.847,   2.718,   2.613,   2.527,},
  { 6.925,   4.849,   4.007,   3.535,   3.228,   3.009,   2.845,   2.715,   2.611,   2.524,},
  { 6.922,   4.846,   4.004,   3.533,   3.225,   3.007,   2.842,   2.713,   2.609,   2.522,},
  { 6.919,   4.844,   4.002,   3.530,   3.223,   3.004,   2.840,   2.711,   2.606,   2.520,},
  { 6.915,   4.841,   3.999,   3.528,   3.221,   3.002,   2.838,   2.709,   2.604,   2.518,},
  { 6.912,   4.838,   3.997,   3.525,   3.218,   3.000,   2.835,   2.706,   2.602,   2.515,},
  { 6.909,   4.836,   3.995,   3.523,   3.216,   2.998,   2.833,   2.704,   2.600,   2.513,},
  { 6.906,   4.833,   3.992,   3.521,   3.214,   2.996,   2.831,   2.702,   2.598,   2.511,},
  { 6.904,   4.831,   3.990,   3.519,   3.212,   2.994,   2.829,   2.700,   2.596,   2.509,},
  { 6.901,   4.829,   3.988,   3.517,   3.210,   2.992,   2.827,   2.698,   2.594,   2.507,},
  { 6.898,   4.826,   3.986,   3.515,   3.208,   2.990,   2.825,   2.696,   2.592,   2.505,},
  { 6.895,   4.824,   3.984,   3.513,   3.206,   2.988,   2.823,   2.694,   2.590,   2.503}
};

/* define the variance which will be used as a minimum variance for any
  dimension of any feature. Since most features are calculated from numbers
  with a precision no better than 1 in 128, the variance should never be
  less than the square of this number for parameters whose range is 1. */
#define MINVARIANCE     0.0001

/* define the absolute minimum number of samples which must be present in
  order to accurately test hypotheses about underlying probability
  distributions.  Define separately the minimum samples that are needed
  before a statistical analysis is attempted; this number should be
  equal to MINSAMPLES but can be set to a lower number for early testing
  when very few samples are available. */
#define MINBUCKETS      5
#define MINSAMPLESPERBUCKET 5
#define MINSAMPLES    (MINBUCKETS * MINSAMPLESPERBUCKET)
#define MINSAMPLESNEEDED  1

/* define the size of the table which maps normalized samples to
  histogram buckets.  Also define the number of standard deviations
  in a normal distribution which are considered to be significant.
  The mapping table will be defined in such a way that it covers
  the specified number of standard deviations on either side of
  the mean.  BUCKETTABLESIZE should always be even. */
#define BUCKETTABLESIZE   1024
#define NORMALEXTENT    3.0

typedef struct
{
  CLUSTER *Cluster;
  CLUSTER *Neighbor;
}


TEMPCLUSTER;

typedef struct
{
  FLOAT32 AvgVariance;
  FLOAT32 *CoVariance;
  FLOAT32 *Min;                  // largest negative distance from the mean
  FLOAT32 *Max;                  // largest positive distance from the mean
}


STATISTICS;

typedef struct
{
  DISTRIBUTION Distribution;     // distribution being tested for
  uinT32 SampleCount;            // # of samples in histogram
  FLOAT64 Confidence;            // confidence level of test
  FLOAT64 ChiSquared;            // test threshold
  uinT16 NumberOfBuckets;        // number of cells in histogram
  uinT16 Bucket[BUCKETTABLESIZE];// mapping to histogram buckets
  uinT32 *Count;                 // frequency of occurence histogram
  FLOAT32 *ExpectedCount;        // expected histogram
}


BUCKETS;

typedef struct
{
  uinT16 DegreesOfFreedom;
  FLOAT64 Alpha;
  FLOAT64 ChiSquared;
}


CHISTRUCT;

typedef FLOAT64 (*DENSITYFUNC) (inT32);
typedef FLOAT64 (*SOLVEFUNC) (CHISTRUCT *, double);

#define Odd(N) ((N)%2)
#define Mirror(N,R) ((R) - (N) - 1)
#define Abs(N) ( ( (N) < 0 ) ? ( -(N) ) : (N) )

//--------------Global Data Definitions and Declarations----------------------
/* the following variables are declared as global so that routines which
are called from the kd-tree walker can get to them. */
static HEAP *Heap;
static TEMPCLUSTER *TempCluster;
static KDTREE *Tree;
static inT32 CurrentTemp;

/* the following variables describe a discrete normal distribution
  which is used by NormalDensity() and NormalBucket().  The
  constant NORMALEXTENT determines how many standard
  deviations of the distribution are mapped onto the fixed
  discrete range of x.  x=0 is mapped to -NORMALEXTENT standard
  deviations and x=BUCKETTABLESIZE is mapped to
  +NORMALEXTENT standard deviations. */
#define SqrtOf2Pi     2.506628275
static FLOAT64 NormalStdDev = BUCKETTABLESIZE / (2.0 * NORMALEXTENT);
static FLOAT64 NormalVariance =
(BUCKETTABLESIZE * BUCKETTABLESIZE) / (4.0 * NORMALEXTENT * NORMALEXTENT);
static FLOAT64 NormalMagnitude =
(2.0 * NORMALEXTENT) / (SqrtOf2Pi * BUCKETTABLESIZE);
static FLOAT64 NormalMean = BUCKETTABLESIZE / 2;

// keep a list of histogram buckets to minimize recomputing them
static LIST OldBuckets[] = { NIL, NIL, NIL };

/* define lookup tables used to compute the number of histogram buckets
  that should be used for a given number of samples. */
#define LOOKUPTABLESIZE   8
#define MAXBUCKETS      39
#define MAXDEGREESOFFREEDOM MAXBUCKETS

static uinT32 CountTable[LOOKUPTABLESIZE] = {
  MINSAMPLES, 200, 400, 600, 800, 1000, 1500, 2000
};
static uinT16 BucketsTable[LOOKUPTABLESIZE] = {
  MINBUCKETS, 16, 20, 24, 27, 30, 35, MAXBUCKETS
};

/*-------------------------------------------------------------------------
          Private Function Prototypes
--------------------------------------------------------------------------*/
void CreateClusterTree(CLUSTERER *Clusterer);

void MakePotentialClusters(CLUSTER *Cluster, VISIT Order, inT32 Level);

CLUSTER *FindNearestNeighbor(KDTREE *Tree,
                             CLUSTER *Cluster,
                             FLOAT32 *Distance);

CLUSTER *MakeNewCluster(CLUSTERER *Clusterer, TEMPCLUSTER *TempCluster);

inT32 MergeClusters (inT16 N,
register PARAM_DESC ParamDesc[],
register inT32 n1,
register inT32 n2,
register FLOAT32 m[],
register FLOAT32 m1[], register FLOAT32 m2[]);

void ComputePrototypes(CLUSTERER *Clusterer, CLUSTERCONFIG *Config);

PROTOTYPE *MakePrototype(CLUSTERER *Clusterer,
                         CLUSTERCONFIG *Config,
                         CLUSTER *Cluster);

PROTOTYPE *MakeDegenerateProto(uinT16 N,
                               CLUSTER *Cluster,
                               STATISTICS *Statistics,
                               PROTOSTYLE Style,
                               inT32 MinSamples);

PROTOTYPE *TestEllipticalProto(CLUSTERER *Clusterer,
                               CLUSTERCONFIG *Config,
                               CLUSTER *Cluster,
                               STATISTICS *Statistics);

PROTOTYPE *MakeSphericalProto(CLUSTERER *Clusterer,
                              CLUSTER *Cluster,
                              STATISTICS *Statistics,
                              BUCKETS *Buckets);

PROTOTYPE *MakeEllipticalProto(CLUSTERER *Clusterer,
                               CLUSTER *Cluster,
                               STATISTICS *Statistics,
                               BUCKETS *Buckets);

PROTOTYPE *MakeMixedProto(CLUSTERER *Clusterer,
                          CLUSTER *Cluster,
                          STATISTICS *Statistics,
                          BUCKETS *NormalBuckets,
                          FLOAT64 Confidence);

void MakeDimRandom(uinT16 i, PROTOTYPE *Proto, PARAM_DESC *ParamDesc);

void MakeDimUniform(uinT16 i, PROTOTYPE *Proto, STATISTICS *Statistics);

STATISTICS *ComputeStatistics (inT16 N,
PARAM_DESC ParamDesc[], CLUSTER * Cluster);

PROTOTYPE *NewSphericalProto(uinT16 N,
                             CLUSTER *Cluster,
                             STATISTICS *Statistics);

PROTOTYPE *NewEllipticalProto(inT16 N,
                              CLUSTER *Cluster,
                              STATISTICS *Statistics);

PROTOTYPE *NewMixedProto(inT16 N, CLUSTER *Cluster, STATISTICS *Statistics);

PROTOTYPE *NewSimpleProto(inT16 N, CLUSTER *Cluster);

BOOL8 Independent (PARAM_DESC ParamDesc[],
inT16 N, FLOAT32 * CoVariance, FLOAT32 Independence);

BUCKETS *GetBuckets(DISTRIBUTION Distribution,
                    uinT32 SampleCount,
                    FLOAT64 Confidence);

BUCKETS *MakeBuckets(DISTRIBUTION Distribution,
                     uinT32 SampleCount,
                     FLOAT64 Confidence);

uinT16 OptimumNumberOfBuckets(uinT32 SampleCount);

FLOAT64 ComputeChiSquared(uinT16 DegreesOfFreedom, FLOAT64 Alpha);

FLOAT64 NormalDensity(inT32 x);

FLOAT64 UniformDensity(inT32 x);

FLOAT64 Integral(FLOAT64 f1, FLOAT64 f2, FLOAT64 Dx);

void FillBuckets(BUCKETS *Buckets,
                 CLUSTER *Cluster,
                 uinT16 Dim,
                 PARAM_DESC *ParamDesc,
                 FLOAT32 Mean,
                 FLOAT32 StdDev);

uinT16 NormalBucket(PARAM_DESC *ParamDesc,
                    FLOAT32 x,
                    FLOAT32 Mean,
                    FLOAT32 StdDev);

uinT16 UniformBucket(PARAM_DESC *ParamDesc,
                     FLOAT32 x,
                     FLOAT32 Mean,
                     FLOAT32 StdDev);

BOOL8 DistributionOK(BUCKETS *Buckets);

void FreeStatistics(STATISTICS *Statistics);

void FreeBuckets(BUCKETS *Buckets);

void FreeCluster(CLUSTER *Cluster);

uinT16 DegreesOfFreedom(DISTRIBUTION Distribution, uinT16 HistogramBuckets);

int NumBucketsMatch(void *arg1,   //BUCKETS                                       *Histogram,
                    void *arg2);  //uinT16                        *DesiredNumberOfBuckets);

int ListEntryMatch(void *arg1, void *arg2);

void AdjustBuckets(BUCKETS *Buckets, uinT32 NewSampleCount);

void InitBuckets(BUCKETS *Buckets);

int AlphaMatch(void *arg1,   //CHISTRUCT                             *ChiStruct,
               void *arg2);  //CHISTRUCT                             *SearchKey);

CHISTRUCT *NewChiStruct(uinT16 DegreesOfFreedom, FLOAT64 Alpha);

FLOAT64 Solve(SOLVEFUNC Function,
              void *FunctionParams,
              FLOAT64 InitialGuess,
              FLOAT64 Accuracy);

FLOAT64 ChiArea(CHISTRUCT *ChiParams, FLOAT64 x);

BOOL8 MultipleCharSamples(CLUSTERER *Clusterer,
                          CLUSTER *Cluster,
                          FLOAT32 MaxIllegal);

double InvertMatrix(const float* input, int size, float* inv);

//--------------------------Public Code--------------------------------------
/** MakeClusterer **********************************************************
Parameters:	SampleSize	number of dimensions in feature space
      ParamDesc	description of each dimension
Globals:	None
Operation:	This routine creates a new clusterer data structure,
      initializes it, and returns a pointer to it.
Return:		pointer to the new clusterer data structure
Exceptions:	None
History:	5/29/89, DSJ, Created.
****************************************************************************/
CLUSTERER *
MakeClusterer (inT16 SampleSize, PARAM_DESC ParamDesc[]) {
  CLUSTERER *Clusterer;
  int i;

  // allocate main clusterer data structure and init simple fields
  Clusterer = (CLUSTERER *) Emalloc (sizeof (CLUSTERER));
  Clusterer->SampleSize = SampleSize;
  Clusterer->NumberOfSamples = 0;
  Clusterer->NumChar = 0;

  // init fields which will not be used initially
  Clusterer->Root = NULL;
  Clusterer->ProtoList = NIL;

  // maintain a copy of param descriptors in the clusterer data structure
  Clusterer->ParamDesc =
    (PARAM_DESC *) Emalloc (SampleSize * sizeof (PARAM_DESC));
  for (i = 0; i < SampleSize; i++) {
    Clusterer->ParamDesc[i].Circular = ParamDesc[i].Circular;
    Clusterer->ParamDesc[i].NonEssential = ParamDesc[i].NonEssential;
    Clusterer->ParamDesc[i].Min = ParamDesc[i].Min;
    Clusterer->ParamDesc[i].Max = ParamDesc[i].Max;
    Clusterer->ParamDesc[i].Range = ParamDesc[i].Max - ParamDesc[i].Min;
    Clusterer->ParamDesc[i].HalfRange = Clusterer->ParamDesc[i].Range / 2;
    Clusterer->ParamDesc[i].MidRange =
      (ParamDesc[i].Max + ParamDesc[i].Min) / 2;
  }

  // allocate a kd tree to hold the samples
  Clusterer->KDTree = MakeKDTree (SampleSize, ParamDesc);

  // execute hook for monitoring clustering operation
  // (*ClustererCreationHook)( Clusterer );

  return (Clusterer);
}                                // MakeClusterer


/** MakeSample ***********************************************************
Parameters:	Clusterer	clusterer data structure to add sample to
      Feature		feature to be added to clusterer
      CharID		unique ident. of char that sample came from
Globals:	None
Operation:	This routine creates a new sample data structure to hold
      the specified feature.  This sample is added to the clusterer
      data structure (so that it knows which samples are to be
      clustered later), and a pointer to the sample is returned to
      the caller.
Return:		Pointer to the new sample data structure
Exceptions:	ALREADYCLUSTERED	MakeSample can't be called after
      ClusterSamples has been called
History:	5/29/89, DSJ, Created.
*****************************************************************************/
SAMPLE *
MakeSample (CLUSTERER * Clusterer, FLOAT32 Feature[], inT32 CharID) {
  SAMPLE *Sample;
  int i;

  // see if the samples have already been clustered - if so trap an error
  if (Clusterer->Root != NULL)
    DoError (ALREADYCLUSTERED,
      "Can't add samples after they have been clustered");

  // allocate the new sample and initialize it
  Sample = (SAMPLE *) Emalloc (sizeof (SAMPLE) +
    (Clusterer->SampleSize -
    1) * sizeof (FLOAT32));
  Sample->Clustered = FALSE;
  Sample->Prototype = FALSE;
  Sample->SampleCount = 1;
  Sample->Left = NULL;
  Sample->Right = NULL;
  Sample->CharID = CharID;

  for (i = 0; i < Clusterer->SampleSize; i++)
    Sample->Mean[i] = Feature[i];

  // add the sample to the KD tree - keep track of the total # of samples
  Clusterer->NumberOfSamples++;
  KDStore (Clusterer->KDTree, Sample->Mean, (char *) Sample);
  if (CharID >= Clusterer->NumChar)
    Clusterer->NumChar = CharID + 1;

  // execute hook for monitoring clustering operation
  // (*SampleCreationHook)( Sample );

  return (Sample);
}                                // MakeSample


/** ClusterSamples ***********************************************************
Parameters:	Clusterer	data struct containing samples to be clustered
      Config		parameters which control clustering process
Globals:	None
Operation:	This routine first checks to see if the samples in this
      clusterer have already been clustered before; if so, it does
      not bother to recreate the cluster tree.  It simply recomputes
      the prototypes based on the new Config info.
        If the samples have not been clustered before, the
      samples in the KD tree are formed into a cluster tree and then
      the prototypes are computed from the cluster tree.
        In either case this routine returns a pointer to a
      list of prototypes that best represent the samples given
      the constraints specified in Config.
Return:		Pointer to a list of prototypes
Exceptions:	None
History:	5/29/89, DSJ, Created.
*******************************************************************************/
LIST ClusterSamples(CLUSTERER *Clusterer, CLUSTERCONFIG *Config) {
  //only create cluster tree if samples have never been clustered before
  if (Clusterer->Root == NULL)
    CreateClusterTree(Clusterer);

  //deallocate the old prototype list if one exists
  FreeProtoList (&Clusterer->ProtoList);
  Clusterer->ProtoList = NIL;

  //compute prototypes starting at the root node in the tree
  ComputePrototypes(Clusterer, Config);
  return (Clusterer->ProtoList);
}                                // ClusterSamples


/** FreeClusterer *************************************************************
Parameters:	Clusterer	pointer to data structure to be freed
Globals:	None
Operation:	This routine frees all of the memory allocated to the
      specified data structure.  It will not, however, free
      the memory used by the prototype list.  The pointers to
      the clusters for each prototype in the list will be set
      to NULL to indicate that the cluster data structures no
      longer exist.  Any sample lists that have been obtained
      via calls to GetSamples are no longer valid.
Return:		None
Exceptions:	None
History:	6/6/89, DSJ, Created.
*******************************************************************************/
void FreeClusterer(CLUSTERER *Clusterer) {
  if (Clusterer != NULL) {
    memfree (Clusterer->ParamDesc);
    if (Clusterer->KDTree != NULL)
      FreeKDTree (Clusterer->KDTree);
    if (Clusterer->Root != NULL)
      FreeCluster (Clusterer->Root);
    iterate (Clusterer->ProtoList) {
      ((PROTOTYPE *) (first_node (Clusterer->ProtoList)))->Cluster = NULL;
    }
    memfree(Clusterer);
  }
}                                // FreeClusterer


/** FreeProtoList ************************************************************
Parameters:	ProtoList	pointer to list of prototypes to be freed
Globals:	None
Operation:	This routine frees all of the memory allocated to the
      specified list of prototypes.  The clusters which are
      pointed to by the prototypes are not freed.
Return:		None
Exceptions:	None
History:	6/6/89, DSJ, Created.
*****************************************************************************/
void FreeProtoList(LIST *ProtoList) {
  destroy_nodes(*ProtoList, FreePrototype);
}                                // FreeProtoList


/** FreePrototype ************************************************************
Parameters:	Prototype	prototype data structure to be deallocated
Globals:	None
Operation:	This routine deallocates the memory consumed by the specified
      prototype and modifies the corresponding cluster so that it
      is no longer marked as a prototype.  The cluster is NOT
      deallocated by this routine.
Return:		None
Exceptions:	None
History:	5/30/89, DSJ, Created.
*******************************************************************************/
void FreePrototype(void *arg) {  //PROTOTYPE     *Prototype)
  PROTOTYPE *Prototype = (PROTOTYPE *) arg;

  // unmark the corresponding cluster (if there is one
  if (Prototype->Cluster != NULL)
    Prototype->Cluster->Prototype = FALSE;

  // deallocate the prototype statistics and then the prototype itself
  if (Prototype->Distrib != NULL)
    memfree (Prototype->Distrib);
  if (Prototype->Mean != NULL)
    memfree (Prototype->Mean);
  if (Prototype->Style != spherical) {
    if (Prototype->Variance.Elliptical != NULL)
      memfree (Prototype->Variance.Elliptical);
    if (Prototype->Magnitude.Elliptical != NULL)
      memfree (Prototype->Magnitude.Elliptical);
    if (Prototype->Weight.Elliptical != NULL)
      memfree (Prototype->Weight.Elliptical);
  }
  memfree(Prototype);
}                                // FreePrototype


/** NextSample ************************************************************
Parameters:	SearchState	ptr to list containing clusters to be searched
Globals:	None
Operation:	This routine is used to find all of the samples which
      belong to a cluster.  It starts by removing the top
      cluster on the cluster list (SearchState).  If this cluster is
      a leaf it is returned.  Otherwise, the right subcluster
      is pushed on the list and we continue the search in the
      left subcluster.  This continues until a leaf is found.
      If all samples have been found, NULL is returned.
      InitSampleSearch() must be called
      before NextSample() to initialize the search.
Return:		Pointer to the next leaf cluster (sample) or NULL.
Exceptions:	None
History:	6/16/89, DSJ, Created.
****************************************************************************/
CLUSTER *NextSample(LIST *SearchState) {
  CLUSTER *Cluster;

  if (*SearchState == NIL)
    return (NULL);
  Cluster = (CLUSTER *) first_node (*SearchState);
  *SearchState = pop (*SearchState);
  while (TRUE) {
    if (Cluster->Left == NULL)
      return (Cluster);
    *SearchState = push (*SearchState, Cluster->Right);
    Cluster = Cluster->Left;
  }
}                                // NextSample


/** Mean ***********************************************************
Parameters:	Proto		prototype to return mean of
      Dimension	dimension whose mean is to be returned
Globals:	none
Operation:	This routine returns the mean of the specified
      prototype in the indicated dimension.
Return:		Mean of Prototype in Dimension
Exceptions: none
History:	7/6/89, DSJ, Created.
*********************************************************************/
FLOAT32 Mean(PROTOTYPE *Proto, uinT16 Dimension) {
  return (Proto->Mean[Dimension]);
}                                // Mean


/** StandardDeviation *************************************************
Parameters:	Proto		prototype to return standard deviation of
      Dimension	dimension whose stddev is to be returned
Globals:	none
Operation:	This routine returns the standard deviation of the
      prototype in the indicated dimension.
Return:		Standard deviation of Prototype in Dimension
Exceptions: none
History:	7/6/89, DSJ, Created.
**********************************************************************/
FLOAT32 StandardDeviation(PROTOTYPE *Proto, uinT16 Dimension) {
  switch (Proto->Style) {
    case spherical:
      return ((FLOAT32) sqrt ((double) Proto->Variance.Spherical));
    case elliptical:
      return ((FLOAT32)
        sqrt ((double) Proto->Variance.Elliptical[Dimension]));
    case mixed:
      switch (Proto->Distrib[Dimension]) {
        case normal:
          return ((FLOAT32)
            sqrt ((double) Proto->Variance.Elliptical[Dimension]));
        case uniform:
        case D_random:
          return (Proto->Variance.Elliptical[Dimension]);
      }
  }
  return 0.0f;
}                                // StandardDeviation


/*---------------------------------------------------------------------------
            Private Code
----------------------------------------------------------------------------*/
/** CreateClusterTree *******************************************************
Parameters:	Clusterer	data structure holdings samples to be clustered
Globals:	Tree		kd-tree holding samples
      TempCluster	array of temporary clusters
      CurrentTemp	index of next temp cluster to be used
      Heap		heap used to hold temp clusters - "best" on top
Operation:	This routine performs a bottoms-up clustering on the samples
      held in the kd-tree of the Clusterer data structure.  The
      result is a cluster tree.  Each node in the tree represents
      a cluster which conceptually contains a subset of the samples.
      More precisely, the cluster contains all of the samples which
      are contained in its two sub-clusters.  The leaves of the
      tree are the individual samples themselves; they have no
      sub-clusters.  The root node of the tree conceptually contains
      all of the samples.
Return:		None (the Clusterer data structure is changed)
Exceptions:	None
History:	5/29/89, DSJ, Created.
******************************************************************************/
void CreateClusterTree(CLUSTERER *Clusterer) {
  HEAPENTRY HeapEntry;
  TEMPCLUSTER *PotentialCluster;

  // save the kd-tree in a global variable so kd-tree walker can get at it
  Tree = Clusterer->KDTree;

  // allocate memory to to hold all of the "potential" clusters
  TempCluster = (TEMPCLUSTER *)
    Emalloc (Clusterer->NumberOfSamples * sizeof (TEMPCLUSTER));
  CurrentTemp = 0;

  // each sample and its nearest neighbor form a "potential" cluster
  // save these in a heap with the "best" potential clusters on top
  Heap = MakeHeap (Clusterer->NumberOfSamples);
  KDWalk (Tree, (void_proc) MakePotentialClusters);

  // form potential clusters into actual clusters - always do "best" first
  while (GetTopOfHeap (Heap, &HeapEntry) != EMPTY) {
    PotentialCluster = (TEMPCLUSTER *) (HeapEntry.Data);

    // if main cluster of potential cluster is already in another cluster
    // then we don't need to worry about it
    if (PotentialCluster->Cluster->Clustered) {
      continue;
    }

    // if main cluster is not yet clustered, but its nearest neighbor is
    // then we must find a new nearest neighbor
    else if (PotentialCluster->Neighbor->Clustered) {
      PotentialCluster->Neighbor =
        FindNearestNeighbor (Tree, PotentialCluster->Cluster,
        &(HeapEntry.Key));
      if (PotentialCluster->Neighbor != NULL) {
        HeapStore(Heap, &HeapEntry);
      }
    }

    // if neither cluster is already clustered, form permanent cluster
    else {
      PotentialCluster->Cluster =
        MakeNewCluster(Clusterer, PotentialCluster);
      PotentialCluster->Neighbor =
        FindNearestNeighbor (Tree, PotentialCluster->Cluster,
        &(HeapEntry.Key));
      if (PotentialCluster->Neighbor != NULL) {
        HeapStore(Heap, &HeapEntry);
      }
    }
  }

  // the root node in the cluster tree is now the only node in the kd-tree
  Clusterer->Root = (CLUSTER *) RootOf (Clusterer->KDTree);

  // free up the memory used by the K-D tree, heap, and temp clusters
  FreeKDTree(Tree);
  Clusterer->KDTree = NULL;
  FreeHeap(Heap);
  memfree(TempCluster);
}                                // CreateClusterTree


/** MakePotentialClusters **************************************************
Parameters:	Cluster	current cluster being visited in kd-tree walk
      Order	order in which cluster is being visited
      Level	level of this cluster in the kd-tree
Globals:	Tree		kd-tree to be searched for neighbors
      TempCluster	array of temporary clusters
      CurrentTemp	index of next temp cluster to be used
      Heap		heap used to hold temp clusters - "best" on top
Operation:	This routine is designed to be used in concert with the
      KDWalk routine.  It will create a potential cluster for
      each sample in the kd-tree that is being walked.  This
      potential cluster will then be pushed on the heap.
Return:		none
Exceptions: none
History:	5/29/89, DSJ, Created.
      7/13/89, DSJ, Removed visibility of kd-tree node data struct.
******************************************************************************/
void MakePotentialClusters(CLUSTER *Cluster, VISIT Order, inT32 Level) {
  Q_UNUSED(Level);
  HEAPENTRY HeapEntry;

  if ((Order == preorder) || (Order == leaf)) {
    TempCluster[CurrentTemp].Cluster = Cluster;
    HeapEntry.Data = (char *) &(TempCluster[CurrentTemp]);
    TempCluster[CurrentTemp].Neighbor =
      FindNearestNeighbor (Tree, TempCluster[CurrentTemp].Cluster,
      &(HeapEntry.Key));
    if (TempCluster[CurrentTemp].Neighbor != NULL) {
      HeapStore(Heap, &HeapEntry);
      CurrentTemp++;
    }
  }
}                                // MakePotentialClusters


/** FindNearestNeighbor *********************************************************
Parameters:	Tree		kd-tree to search in for nearest neighbor
      Cluster		cluster whose nearest neighbor is to be found
      Distance	ptr to variable to report distance found
Globals:	none
Operation:	This routine searches the specified kd-tree for the nearest
      neighbor of the specified cluster.  It actually uses the
      kd routines to find the 2 nearest neighbors since one of them
      will be the original cluster.  A pointer to the nearest
      neighbor is returned, if it can be found, otherwise NULL is
      returned.  The distance between the 2 nodes is placed
      in the specified variable.
Return:		Pointer to the nearest neighbor of Cluster, or NULL
Exceptions: none
History:	5/29/89, DSJ, Created.
      7/13/89, DSJ, Removed visibility of kd-tree node data struct
********************************************************************************/
CLUSTER *
FindNearestNeighbor (KDTREE * Tree, CLUSTER * Cluster, FLOAT32 * Distance)
#define MAXNEIGHBORS  2
#define MAXDISTANCE   MAX_FLOAT32
{
  CLUSTER *Neighbor[MAXNEIGHBORS];
  FLOAT32 Dist[MAXNEIGHBORS];
  inT32 NumberOfNeighbors;
  inT32 i;
  CLUSTER *BestNeighbor;

  // find the 2 nearest neighbors of the cluster
  NumberOfNeighbors = KDNearestNeighborSearch
    (Tree, Cluster->Mean, MAXNEIGHBORS, MAXDISTANCE, Neighbor, Dist);

  // search for the nearest neighbor that is not the cluster itself
  *Distance = MAXDISTANCE;
  BestNeighbor = NULL;
  for (i = 0; i < NumberOfNeighbors; i++) {
    if ((Dist[i] < *Distance) && (Neighbor[i] != Cluster)) {
      *Distance = Dist[i];
      BestNeighbor = Neighbor[i];
    }
  }
  return (BestNeighbor);
}                                // FindNearestNeighbor


/** MakeNewCluster *************************************************************
Parameters:	Clusterer	current clustering environment
      TempCluster	potential cluster to make permanent
Globals:	none
Operation:	This routine creates a new permanent cluster from the
      clusters specified in TempCluster.  The 2 clusters in
      TempCluster are marked as "clustered" and deleted from
      the kd-tree.  The new cluster is then added to the kd-tree.
      Return: Pointer to the new permanent cluster
Exceptions:	none
History:	5/29/89, DSJ, Created.
      7/13/89, DSJ, Removed visibility of kd-tree node data struct
********************************************************************************/
CLUSTER *MakeNewCluster(CLUSTERER *Clusterer, TEMPCLUSTER *TempCluster) {
  CLUSTER *Cluster;

  // allocate the new cluster and initialize it
  Cluster = (CLUSTER *) Emalloc (sizeof (CLUSTER) +
    (Clusterer->SampleSize -
    1) * sizeof (FLOAT32));
  Cluster->Clustered = FALSE;
  Cluster->Prototype = FALSE;
  Cluster->Left = TempCluster->Cluster;
  Cluster->Right = TempCluster->Neighbor;
  Cluster->CharID = -1;

  // mark the old clusters as "clustered" and delete them from the kd-tree
  Cluster->Left->Clustered = TRUE;
  Cluster->Right->Clustered = TRUE;
  KDDelete (Clusterer->KDTree, Cluster->Left->Mean, Cluster->Left);
  KDDelete (Clusterer->KDTree, Cluster->Right->Mean, Cluster->Right);

  // compute the mean and sample count for the new cluster
  Cluster->SampleCount =
    MergeClusters (Clusterer->SampleSize, Clusterer->ParamDesc,
    Cluster->Left->SampleCount, Cluster->Right->SampleCount,
    Cluster->Mean, Cluster->Left->Mean, Cluster->Right->Mean);

  // add the new cluster to the KD tree
  KDStore (Clusterer->KDTree, Cluster->Mean, Cluster);
  return (Cluster);
}                                // MakeNewCluster


/** MergeClusters ************************************************************
Parameters:	N	# of dimensions (size of arrays)
      ParamDesc	array of dimension descriptions
      n1, n2	number of samples in each old cluster
      m	array to hold mean of new cluster
      m1, m2	arrays containing means of old clusters
Globals:	None
Operation:	This routine merges two clusters into one larger cluster.
      To do this it computes the number of samples in the new
      cluster and the mean of the new cluster.  The ParamDesc
      information is used to ensure that circular dimensions
      are handled correctly.
Return:		The number of samples in the new cluster.
Exceptions:	None
History:	5/31/89, DSJ, Created.
*********************************************************************************/
inT32
MergeClusters (inT16 N,
register PARAM_DESC ParamDesc[],
register inT32 n1,
register inT32 n2,
register FLOAT32 m[],
register FLOAT32 m1[], register FLOAT32 m2[]) {
  register inT32 i, n;

  n = n1 + n2;
  for (i = N; i > 0; i--, ParamDesc++, m++, m1++, m2++) {
    if (ParamDesc->Circular) {
      // if distance between means is greater than allowed
      // reduce upper point by one "rotation" to compute mean
      // then normalize the mean back into the accepted range
      if ((*m2 - *m1) > ParamDesc->HalfRange) {
        *m = (n1 * *m1 + n2 * (*m2 - ParamDesc->Range)) / n;
        if (*m < ParamDesc->Min)
          *m += ParamDesc->Range;
      }
      else if ((*m1 - *m2) > ParamDesc->HalfRange) {
        *m = (n1 * (*m1 - ParamDesc->Range) + n2 * *m2) / n;
        if (*m < ParamDesc->Min)
          *m += ParamDesc->Range;
      }
      else
        *m = (n1 * *m1 + n2 * *m2) / n;
    }
    else
      *m = (n1 * *m1 + n2 * *m2) / n;
  }
  return (n);
}                                // MergeClusters


/** ComputePrototypes *******************************************************
Parameters:	Clusterer	data structure holding cluster tree
      Config		parameters used to control prototype generation
Globals:	None
Operation:	This routine decides which clusters in the cluster tree
      should be represented by prototypes, forms a list of these
      prototypes, and places the list in the Clusterer data
      structure.
Return:		None
Exceptions:	None
History:	5/30/89, DSJ, Created.
*******************************************************************************/
void ComputePrototypes(CLUSTERER *Clusterer, CLUSTERCONFIG *Config) {
  LIST ClusterStack = NIL;
  CLUSTER *Cluster;
  PROTOTYPE *Prototype;

  // use a stack to keep track of clusters waiting to be processed
  // initially the only cluster on the stack is the root cluster
  if (Clusterer->Root != NULL)
    ClusterStack = push (NIL, Clusterer->Root);

  // loop until we have analyzed all clusters which are potential prototypes
  while (ClusterStack != NIL) {
    // remove the next cluster to be analyzed from the stack
    // try to make a prototype from the cluster
    // if successful, put it on the proto list, else split the cluster
    Cluster = (CLUSTER *) first_node (ClusterStack);
    ClusterStack = pop (ClusterStack);
    Prototype = MakePrototype (Clusterer, Config, Cluster);
    if (Prototype != NULL) {
      Clusterer->ProtoList = push (Clusterer->ProtoList, Prototype);
    }
    else {
      ClusterStack = push (ClusterStack, Cluster->Right);
      ClusterStack = push (ClusterStack, Cluster->Left);
    }
  }
}                                // ComputePrototypes


/** MakePrototype ***********************************************************
Parameters:	Clusterer	data structure holding cluster tree
      Config		parameters used to control prototype generation
      Cluster		cluster to be made into a prototype
Globals:	None
Operation:	This routine attempts to create a prototype from the
      specified cluster that conforms to the distribution
      specified in Config.  If there are too few samples in the
      cluster to perform a statistical analysis, then a prototype
      is generated but labelled as insignificant.  If the
      dimensions of the cluster are not independent, no prototype
      is generated and NULL is returned.  If a prototype can be
      found that matches the desired distribution then a pointer
      to it is returned, otherwise NULL is returned.
Return:		Pointer to new prototype or NULL
Exceptions:	None
History:	6/19/89, DSJ, Created.
*******************************************************************************/
PROTOTYPE *MakePrototype(CLUSTERER *Clusterer,
                         CLUSTERCONFIG *Config,
                         CLUSTER *Cluster) {
  STATISTICS *Statistics;
  PROTOTYPE *Proto;
  BUCKETS *Buckets;

  // filter out clusters which contain samples from the same character
  if (MultipleCharSamples (Clusterer, Cluster, Config->MaxIllegal))
    return (NULL);

  // compute the covariance matrix and ranges for the cluster
  Statistics =
    ComputeStatistics (Clusterer->SampleSize, Clusterer->ParamDesc, Cluster);

  // check for degenerate clusters which need not be analyzed further
  // note that the MinSamples test assumes that all clusters with multiple
  // character samples have been removed (as above)
  Proto = MakeDegenerateProto (Clusterer->SampleSize, Cluster, Statistics,
    Config->ProtoStyle,
    (inT32) (Config->MinSamples *
    Clusterer->NumChar));
  if (Proto != NULL) {
    FreeStatistics(Statistics);
    return (Proto);
  }
  // check to ensure that all dimensions are independent
  if (!Independent (Clusterer->ParamDesc, Clusterer->SampleSize,
  Statistics->CoVariance, Config->Independence)) {
    FreeStatistics(Statistics);
    return (NULL);
  }

  if (HOTELLING && Config->ProtoStyle == elliptical) {
    Proto = TestEllipticalProto(Clusterer, Config, Cluster, Statistics);
    if (Proto != NULL) {
      FreeStatistics(Statistics);
      return Proto;
    }
  }

  // create a histogram data structure used to evaluate distributions
  Buckets = GetBuckets (normal, Cluster->SampleCount, Config->Confidence);

  // create a prototype based on the statistics and test it
  switch (Config->ProtoStyle) {
    case spherical:
      Proto = MakeSphericalProto (Clusterer, Cluster, Statistics, Buckets);
      break;
    case elliptical:
      Proto = MakeEllipticalProto (Clusterer, Cluster, Statistics, Buckets);
      break;
    case mixed:
      Proto = MakeMixedProto (Clusterer, Cluster, Statistics, Buckets,
        Config->Confidence);
      break;
    case automatic:
      Proto = MakeSphericalProto (Clusterer, Cluster, Statistics, Buckets);
      if (Proto != NULL)
        break;
      Proto = MakeEllipticalProto (Clusterer, Cluster, Statistics, Buckets);
      if (Proto != NULL)
        break;
      Proto = MakeMixedProto (Clusterer, Cluster, Statistics, Buckets,
        Config->Confidence);
      break;
  }
  FreeBuckets(Buckets);
  FreeStatistics(Statistics);
  return (Proto);
}                                // MakePrototype


/** MakeDegenerateProto ******************************************************
Parameters:	N		number of dimensions
      Cluster		cluster being analyzed
      Statistics	statistical info about cluster
      Style		type of prototype to be generated
      MinSamples	minimum number of samples in a cluster
Globals:	None
Operation:	This routine checks for clusters which are degenerate and
      therefore cannot be analyzed in a statistically valid way.
      A cluster is defined as degenerate if it does not have at
      least MINSAMPLESNEEDED samples in it.  If the cluster is
      found to be degenerate, a prototype of the specified style
      is generated and marked as insignificant.  A cluster is
      also degenerate if it does not have at least MinSamples
      samples in it.
      If the cluster is not degenerate, NULL is returned.
Return:		Pointer to degenerate prototype or NULL.
Exceptions:	None
History:	6/20/89, DSJ, Created.
      7/12/89, DSJ, Changed name and added check for 0 stddev.
      8/8/89, DSJ, Removed check for 0 stddev (handled elsewhere).
********************************************************************************/
PROTOTYPE *MakeDegenerateProto(  //this was MinSample
                               uinT16 N,
                               CLUSTER *Cluster,
                               STATISTICS *Statistics,
                               PROTOSTYLE Style,
                               inT32 MinSamples) {
  PROTOTYPE *Proto = NULL;

  if (MinSamples < MINSAMPLESNEEDED)
    MinSamples = MINSAMPLESNEEDED;

  if (Cluster->SampleCount < MinSamples) {
    switch (Style) {
      case spherical:
        Proto = NewSphericalProto (N, Cluster, Statistics);
        break;
      case elliptical:
      case automatic:
        Proto = NewEllipticalProto (N, Cluster, Statistics);
        break;
      case mixed:
        Proto = NewMixedProto (N, Cluster, Statistics);
        break;
    }
    Proto->Significant = FALSE;
  }
  return (Proto);
}                                // MakeDegenerateProto

/** TestEllipticalProto ****************************************************
Parameters:	Clusterer	data struct containing samples being clustered
      Config provides the magic number of samples that make a good cluster
      Cluster		cluster to be made into an elliptical prototype
      Statistics	statistical info about cluster
Globals:	None
Operation:	This routine tests the specified cluster to see if **
*     there is a statistically significant difference between
*     the sub-clusters that would be made if the cluster were to
*     be split. If not, then a new prototype is formed and
*     returned to the caller. If there is, then NULL is returned
*     to the caller.
Return:		Pointer to new elliptical prototype or NULL.
****************************************************************************/
PROTOTYPE *TestEllipticalProto(CLUSTERER *Clusterer,
                               CLUSTERCONFIG *Config,
                               CLUSTER *Cluster,
                               STATISTICS *Statistics) {
  // Fraction of the number of samples used as a range around 1 within
  // which a cluster has the magic size that allows a boost to the
  // FTable by kFTableBoostMargin, thus allowing clusters near the
  // magic size (equal to the number of sample characters) to be more
  // likely to stay together.
  const double kMagicSampleMargin = 0.0625;
  const double kFTableBoostMargin = 2.0;

  int N = Clusterer->SampleSize;
  CLUSTER* Left = Cluster->Left;
  CLUSTER* Right = Cluster->Right;
  if (Left == NULL || Right == NULL)
    return NULL;
  int TotalDims = Left->SampleCount + Right->SampleCount;
  if (TotalDims < N + 1 || TotalDims < 2)
    return NULL;
  const int kMatrixSize = N * N * sizeof(FLOAT32);
  FLOAT32* Covariance = reinterpret_cast<FLOAT32 *>(Emalloc(kMatrixSize));
  FLOAT32* Inverse = reinterpret_cast<FLOAT32 *>(Emalloc(kMatrixSize));
  FLOAT32* Delta = reinterpret_cast<FLOAT32*>(Emalloc(N * sizeof(FLOAT32)));
  // Compute a new covariance matrix that only uses essential features.
  for (int i = 0; i < N; ++i) {
    int row_offset = i * N;
    if (!Clusterer->ParamDesc[i].NonEssential) {
      for (int j = 0; j < N; ++j) {
        if (!Clusterer->ParamDesc[j].NonEssential)
          Covariance[j + row_offset] = Statistics->CoVariance[j + row_offset];
        else
          Covariance[j + row_offset] = 0.0f;
      }
    } else {
      for (int j = 0; j < N; ++j) {
        if (i == j)
          Covariance[j + row_offset] = 1.0f;
        else
          Covariance[j + row_offset] = 0.0f;
      }
    }
  }
  double err = InvertMatrix(Covariance, N, Inverse);
  if (err > 1) {
    tprintf("Clustering error: Matrix inverse failed with error %g\n", err);
  }
  int EssentialN = 0;
  for (int dim = 0; dim < N; ++dim) {
    if (!Clusterer->ParamDesc[dim].NonEssential) {
      Delta[dim] = Left->Mean[dim] - Right->Mean[dim];
      ++EssentialN;
    } else {
      Delta[dim] = 0.0f;
    }
  }
  // Compute Hotelling's T-squared.
  double Tsq = 0.0;
  for (int x = 0; x < N; ++x) {
    double temp = 0.0;
    for (int y = 0; y < N; ++y) {
      temp += Inverse[y + N*x] * Delta[y];
    }
    Tsq += Delta[x] * temp;
  }
  memfree(Covariance);
  memfree(Inverse);
  memfree(Delta);
  // Changed this function to match the formula in
  // Statistical Methods in Medical Research p 473
  // By Peter Armitage, Geoffrey Berry, J. N. S. Matthews.
  // Tsq *= Left->SampleCount * Right->SampleCount / TotalDims;
  double F = Tsq * (TotalDims - EssentialN - 1) / ((TotalDims - 2)*EssentialN);
  int Fx = EssentialN;
  if (Fx > FTABLE_X)
    Fx = FTABLE_X;
  --Fx;
  int Fy = TotalDims - EssentialN - 1;
  if (Fy > FTABLE_Y)
    Fy = FTABLE_Y;
  --Fy;
  double FTarget = FTable[Fy][Fx];
  if (Config->MagicSamples > 0 &&
      TotalDims >= Config->MagicSamples * (1.0 - kMagicSampleMargin) &&
      TotalDims <= Config->MagicSamples * (1.0 + kMagicSampleMargin)) {
    // Give magic-sized clusters a magic FTable boost.
    FTarget += kFTableBoostMargin;
  }
  if (F < FTarget) {
    return NewEllipticalProto (Clusterer->SampleSize, Cluster, Statistics);
  }
  return NULL;
}

/* MakeSphericalProto *******************************************************
Parameters:	Clusterer	data struct containing samples being clustered
      Cluster		cluster to be made into a spherical prototype
      Statistics	statistical info about cluster
      Buckets		histogram struct used to analyze distribution
Globals:	None
Operation:	This routine tests the specified cluster to see if it can
      be approximated by a spherical normal distribution.  If it
      can be, then a new prototype is formed and returned to the
      caller.  If it can't be, then NULL is returned to the caller.
Return:		Pointer to new spherical prototype or NULL.
Exceptions:	None
History:	6/1/89, DSJ, Created.
******************************************************************************/
PROTOTYPE *MakeSphericalProto(CLUSTERER *Clusterer,
                              CLUSTER *Cluster,
                              STATISTICS *Statistics,
                              BUCKETS *Buckets) {
  PROTOTYPE *Proto = NULL;
  int i;

  // check that each dimension is a normal distribution
  for (i = 0; i < Clusterer->SampleSize; i++) {
    if (Clusterer->ParamDesc[i].NonEssential)
      continue;

    FillBuckets (Buckets, Cluster, i, &(Clusterer->ParamDesc[i]),
      Cluster->Mean[i],
      sqrt ((FLOAT64) (Statistics->AvgVariance)));
    if (!DistributionOK (Buckets))
      break;
  }
  // if all dimensions matched a normal distribution, make a proto
  if (i >= Clusterer->SampleSize)
    Proto = NewSphericalProto (Clusterer->SampleSize, Cluster, Statistics);
  return (Proto);
}                                // MakeSphericalProto


/** MakeEllipticalProto ****************************************************
Parameters:	Clusterer	data struct containing samples being clustered
      Cluster		cluster to be made into an elliptical prototype
      Statistics	statistical info about cluster
      Buckets		histogram struct used to analyze distribution
Globals:	None
Operation:	This routine tests the specified cluster to see if it can
      be approximated by an elliptical normal distribution.  If it
      can be, then a new prototype is formed and returned to the
      caller.  If it can't be, then NULL is returned to the caller.
Return:		Pointer to new elliptical prototype or NULL.
Exceptions:	None
History:	6/12/89, DSJ, Created.
****************************************************************************/
PROTOTYPE *MakeEllipticalProto(CLUSTERER *Clusterer,
                               CLUSTER *Cluster,
                               STATISTICS *Statistics,
                               BUCKETS *Buckets) {
  PROTOTYPE *Proto = NULL;
  int i;

  // check that each dimension is a normal distribution
  for (i = 0; i < Clusterer->SampleSize; i++) {
    if (Clusterer->ParamDesc[i].NonEssential)
      continue;

    FillBuckets (Buckets, Cluster, i, &(Clusterer->ParamDesc[i]),
      Cluster->Mean[i],
      sqrt ((FLOAT64) Statistics->
      CoVariance[i * (Clusterer->SampleSize + 1)]));
    if (!DistributionOK (Buckets))
      break;
  }
  // if all dimensions matched a normal distribution, make a proto
  if (i >= Clusterer->SampleSize)
    Proto = NewEllipticalProto (Clusterer->SampleSize, Cluster, Statistics);
  return (Proto);
}                                // MakeEllipticalProto


/** MakeMixedProto ***********************************************************
Parameters:	Clusterer	data struct containing samples being clustered
      Cluster		cluster to be made into a prototype
      Statistics	statistical info about cluster
      NormalBuckets	histogram struct used to analyze distribution
      Confidence	confidence level for alternate distributions
Globals:	None
Operation:	This routine tests each dimension of the specified cluster to
      see what distribution would best approximate that dimension.
      Each dimension is compared to the following distributions
      in order: normal, random, uniform.  If each dimension can
      be represented by one of these distributions,
      then a new prototype is formed and returned to the
      caller.  If it can't be, then NULL is returned to the caller.
Return:		Pointer to new mixed prototype or NULL.
Exceptions:	None
History:	6/12/89, DSJ, Created.
********************************************************************************/
PROTOTYPE *MakeMixedProto(CLUSTERER *Clusterer,
                          CLUSTER *Cluster,
                          STATISTICS *Statistics,
                          BUCKETS *NormalBuckets,
                          FLOAT64 Confidence) {
  PROTOTYPE *Proto;
  int i;
  BUCKETS *UniformBuckets = NULL;
  BUCKETS *RandomBuckets = NULL;

  // create a mixed proto to work on - initially assume all dimensions normal*/
  Proto = NewMixedProto (Clusterer->SampleSize, Cluster, Statistics);

  // find the proper distribution for each dimension
  for (i = 0; i < Clusterer->SampleSize; i++) {
    if (Clusterer->ParamDesc[i].NonEssential)
      continue;

    FillBuckets (NormalBuckets, Cluster, i, &(Clusterer->ParamDesc[i]),
      Proto->Mean[i],
      sqrt ((FLOAT64) Proto->Variance.Elliptical[i]));
    if (DistributionOK (NormalBuckets))
      continue;

    if (RandomBuckets == NULL)
      RandomBuckets =
        GetBuckets (D_random, Cluster->SampleCount, Confidence);
    MakeDimRandom (i, Proto, &(Clusterer->ParamDesc[i]));
    FillBuckets (RandomBuckets, Cluster, i, &(Clusterer->ParamDesc[i]),
      Proto->Mean[i], Proto->Variance.Elliptical[i]);
    if (DistributionOK (RandomBuckets))
      continue;

    if (UniformBuckets == NULL)
      UniformBuckets =
        GetBuckets (uniform, Cluster->SampleCount, Confidence);
    MakeDimUniform(i, Proto, Statistics);
    FillBuckets (UniformBuckets, Cluster, i, &(Clusterer->ParamDesc[i]),
      Proto->Mean[i], Proto->Variance.Elliptical[i]);
    if (DistributionOK (UniformBuckets))
      continue;
    break;
  }
  // if any dimension failed to match a distribution, discard the proto
  if (i < Clusterer->SampleSize) {
    FreePrototype(Proto);
    Proto = NULL;
  }
  if (UniformBuckets != NULL)
    FreeBuckets(UniformBuckets);
  if (RandomBuckets != NULL)
    FreeBuckets(RandomBuckets);
  return (Proto);
}                                // MakeMixedProto


/* MakeDimRandom *************************************************************
Parameters:	i		index of dimension to be changed
      Proto		prototype whose dimension is to be altered
      ParamDesc	description of specified dimension
Globals:	None
Operation:	This routine alters the ith dimension of the specified
      mixed prototype to be D_random.
Return:		None
Exceptions:	None
History:	6/20/89, DSJ, Created.
******************************************************************************/
void MakeDimRandom(uinT16 i, PROTOTYPE *Proto, PARAM_DESC *ParamDesc) {
  Proto->Distrib[i] = D_random;
  Proto->Mean[i] = ParamDesc->MidRange;
  Proto->Variance.Elliptical[i] = ParamDesc->HalfRange;

  // subtract out the previous magnitude of this dimension from the total
  Proto->TotalMagnitude /= Proto->Magnitude.Elliptical[i];
  Proto->Magnitude.Elliptical[i] = 1.0 / ParamDesc->Range;
  Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
  Proto->LogMagnitude = log ((double) Proto->TotalMagnitude);

  // note that the proto Weight is irrelevant for D_random protos
}                                // MakeDimRandom


/** MakeDimUniform ***********************************************************
Parameters:	i		index of dimension to be changed
      Proto		prototype whose dimension is to be altered
      Statistics	statistical info about prototype
Globals:	None
Operation:	This routine alters the ith dimension of the specified
      mixed prototype to be uniform.
Return:		None
Exceptions:	None
History:	6/20/89, DSJ, Created.
******************************************************************************/
void MakeDimUniform(uinT16 i, PROTOTYPE *Proto, STATISTICS *Statistics) {
  Proto->Distrib[i] = uniform;
  Proto->Mean[i] = Proto->Cluster->Mean[i] +
    (Statistics->Min[i] + Statistics->Max[i]) / 2;
  Proto->Variance.Elliptical[i] =
    (Statistics->Max[i] - Statistics->Min[i]) / 2;
  if (Proto->Variance.Elliptical[i] < MINVARIANCE)
    Proto->Variance.Elliptical[i] = MINVARIANCE;

  // subtract out the previous magnitude of this dimension from the total
  Proto->TotalMagnitude /= Proto->Magnitude.Elliptical[i];
  Proto->Magnitude.Elliptical[i] =
    1.0 / (2.0 * Proto->Variance.Elliptical[i]);
  Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
  Proto->LogMagnitude = log ((double) Proto->TotalMagnitude);

  // note that the proto Weight is irrelevant for uniform protos
}                                // MakeDimUniform


/** ComputeStatistics *********************************************************
Parameters:	N		number of dimensions
      ParamDesc	array of dimension descriptions
      Cluster		cluster whose stats are to be computed
Globals:	None
Operation:	This routine searches the cluster tree for all leaf nodes
      which are samples in the specified cluster.  It computes
      a full covariance matrix for these samples as well as
      keeping track of the ranges (min and max) for each
      dimension.  A special data structure is allocated to
      return this information to the caller.  An incremental
      algorithm for computing statistics is not used because
      it will not work with circular dimensions.
Return:		Pointer to new data structure containing statistics
Exceptions:	None
History:	6/2/89, DSJ, Created.
*********************************************************************************/
STATISTICS *
ComputeStatistics (inT16 N, PARAM_DESC ParamDesc[], CLUSTER * Cluster) {
  STATISTICS *Statistics;
  int i, j;
  FLOAT32 *CoVariance;
  FLOAT32 *Distance;
  LIST SearchState;
  SAMPLE *Sample;
  uinT32 SampleCountAdjustedForBias;

  // allocate memory to hold the statistics results
  Statistics = (STATISTICS *) Emalloc (sizeof (STATISTICS));
  Statistics->CoVariance = (FLOAT32 *) Emalloc (N * N * sizeof (FLOAT32));
  Statistics->Min = (FLOAT32 *) Emalloc (N * sizeof (FLOAT32));
  Statistics->Max = (FLOAT32 *) Emalloc (N * sizeof (FLOAT32));

  // allocate temporary memory to hold the sample to mean distances
  Distance = (FLOAT32 *) Emalloc (N * sizeof (FLOAT32));

  // initialize the statistics
  Statistics->AvgVariance = 1.0;
  CoVariance = Statistics->CoVariance;
  for (i = 0; i < N; i++) {
    Statistics->Min[i] = 0.0;
    Statistics->Max[i] = 0.0;
    for (j = 0; j < N; j++, CoVariance++)
      *CoVariance = 0;
  }
  // find each sample in the cluster and merge it into the statistics
  InitSampleSearch(SearchState, Cluster);
  while ((Sample = NextSample (&SearchState)) != NULL) {
    for (i = 0; i < N; i++) {
      Distance[i] = Sample->Mean[i] - Cluster->Mean[i];
      if (ParamDesc[i].Circular) {
        if (Distance[i] > ParamDesc[i].HalfRange)
          Distance[i] -= ParamDesc[i].Range;
        if (Distance[i] < -ParamDesc[i].HalfRange)
          Distance[i] += ParamDesc[i].Range;
      }
      if (Distance[i] < Statistics->Min[i])
        Statistics->Min[i] = Distance[i];
      if (Distance[i] > Statistics->Max[i])
        Statistics->Max[i] = Distance[i];
    }
    CoVariance = Statistics->CoVariance;
    for (i = 0; i < N; i++)
      for (j = 0; j < N; j++, CoVariance++)
        *CoVariance += Distance[i] * Distance[j];
  }
  // normalize the variances by the total number of samples
  // use SampleCount-1 instead of SampleCount to get an unbiased estimate
  // also compute the geometic mean of the diagonal variances
  // ensure that clusters with only 1 sample are handled correctly
  if (Cluster->SampleCount > 1)
    SampleCountAdjustedForBias = Cluster->SampleCount - 1;
  else
    SampleCountAdjustedForBias = 1;
  CoVariance = Statistics->CoVariance;
  for (i = 0; i < N; i++)
  for (j = 0; j < N; j++, CoVariance++) {
    *CoVariance /= SampleCountAdjustedForBias;
    if (j == i) {
      if (*CoVariance < MINVARIANCE)
        *CoVariance = MINVARIANCE;
      Statistics->AvgVariance *= *CoVariance;
    }
  }
  Statistics->AvgVariance = (float)pow((double)Statistics->AvgVariance,
                                       1.0 / N);

  // release temporary memory and return
  memfree(Distance);
  return (Statistics);
}                                // ComputeStatistics


/** NewSpericalProto *********************************************************
Parameters:	N		number of dimensions
      Cluster		cluster to be made into a spherical prototype
      Statistics	statistical info about samples in cluster
Globals:	None
Operation:	This routine creates a spherical prototype data structure to
      approximate the samples in the specified cluster.
      Spherical prototypes have a single variance which is
      common across all dimensions.  All dimensions are normally
      distributed and independent.
Return:		Pointer to a new spherical prototype data structure
Exceptions:	None
History:	6/19/89, DSJ, Created.
******************************************************************************/
PROTOTYPE *NewSphericalProto(uinT16 N,
                             CLUSTER *Cluster,
                             STATISTICS *Statistics) {
  PROTOTYPE *Proto;

  Proto = NewSimpleProto (N, Cluster);

  Proto->Variance.Spherical = Statistics->AvgVariance;
  if (Proto->Variance.Spherical < MINVARIANCE)
    Proto->Variance.Spherical = MINVARIANCE;

  Proto->Magnitude.Spherical =
    1.0 / sqrt ((double) (2.0 * PI * Proto->Variance.Spherical));
  Proto->TotalMagnitude = (float)pow((double)Proto->Magnitude.Spherical,
                                     (double) N);
  Proto->Weight.Spherical = 1.0 / Proto->Variance.Spherical;
  Proto->LogMagnitude = log ((double) Proto->TotalMagnitude);

  return (Proto);
}                                // NewSphericalProto


/** NewEllipticalProto *******************************************************
Parameters:	N		number of dimensions
      Cluster		cluster to be made into an elliptical prototype
      Statistics	statistical info about samples in cluster
Globals:	None
Operation:	This routine creates an elliptical prototype data structure to
      approximate the samples in the specified cluster.
      Elliptical prototypes have a variance for each dimension.
      All dimensions are normally distributed and independent.
Return:		Pointer to a new elliptical prototype data structure
Exceptions:	None
History:	6/19/89, DSJ, Created.
*******************************************************************************/
PROTOTYPE *NewEllipticalProto(inT16 N,
                              CLUSTER *Cluster,
                              STATISTICS *Statistics) {
  PROTOTYPE *Proto;
  FLOAT32 *CoVariance;
  int i;

  Proto = NewSimpleProto (N, Cluster);
  Proto->Variance.Elliptical = (FLOAT32 *) Emalloc (N * sizeof (FLOAT32));
  Proto->Magnitude.Elliptical = (FLOAT32 *) Emalloc (N * sizeof (FLOAT32));
  Proto->Weight.Elliptical = (FLOAT32 *) Emalloc (N * sizeof (FLOAT32));

  CoVariance = Statistics->CoVariance;
  Proto->TotalMagnitude = 1.0;
  for (i = 0; i < N; i++, CoVariance += N + 1) {
    Proto->Variance.Elliptical[i] = *CoVariance;
    if (Proto->Variance.Elliptical[i] < MINVARIANCE)
      Proto->Variance.Elliptical[i] = MINVARIANCE;

    Proto->Magnitude.Elliptical[i] =
      1.0 / sqrt ((double) (2.0 * PI * Proto->Variance.Elliptical[i]));
    Proto->Weight.Elliptical[i] = 1.0 / Proto->Variance.Elliptical[i];
    Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
  }
  Proto->LogMagnitude = log ((double) Proto->TotalMagnitude);
  Proto->Style = elliptical;
  return (Proto);
}                                // NewEllipticalProto


/** MewMixedProto ************************************************************
Parameters:	N		number of dimensions
      Cluster		cluster to be made into a mixed prototype
      Statistics	statistical info about samples in cluster
Globals:	None
Operation:	This routine creates a mixed prototype data structure to
      approximate the samples in the specified cluster.
      Mixed prototypes can have different distributions for
      each dimension.  All dimensions are independent.  The
      structure is initially filled in as though it were an
      elliptical prototype.  The actual distributions of the
      dimensions can be altered by other routines.
Return:		Pointer to a new mixed prototype data structure
Exceptions:	None
History:	6/19/89, DSJ, Created.
********************************************************************************/
PROTOTYPE *NewMixedProto(inT16 N, CLUSTER *Cluster, STATISTICS *Statistics) {
  PROTOTYPE *Proto;
  int i;

  Proto = NewEllipticalProto (N, Cluster, Statistics);
  Proto->Distrib = (DISTRIBUTION *) Emalloc (N * sizeof (DISTRIBUTION));

  for (i = 0; i < N; i++) {
    Proto->Distrib[i] = normal;
  }
  Proto->Style = mixed;
  return (Proto);
}                                // NewMixedProto


/** NewSimpleProto ***********************************************************
Parameters:	N		number of dimensions
      Cluster		cluster to be made into a prototype
Globals:	None
Operation:	This routine allocates memory to hold a simple prototype
      data structure, i.e. one without independent distributions
      and variances for each dimension.
Return:		Pointer to new simple prototype
Exceptions:	None
History:	6/19/89, DSJ, Created.
*******************************************************************************/
PROTOTYPE *NewSimpleProto(inT16 N, CLUSTER *Cluster) {
  PROTOTYPE *Proto;
  int i;

  Proto = (PROTOTYPE *) Emalloc (sizeof (PROTOTYPE));
  Proto->Mean = (FLOAT32 *) Emalloc (N * sizeof (FLOAT32));

  for (i = 0; i < N; i++)
    Proto->Mean[i] = Cluster->Mean[i];
  Proto->Distrib = NULL;

  Proto->Significant = TRUE;
  Proto->Style = spherical;
  Proto->NumSamples = Cluster->SampleCount;
  Proto->Cluster = Cluster;
  Proto->Cluster->Prototype = TRUE;
  return (Proto);
}                                // NewSimpleProto


/** Independent ***************************************************************
Parameters:	ParamDesc	descriptions of each feature space dimension
      N		number of dimensions
      CoVariance	ptr to a covariance matrix
      Independence	max off-diagonal correlation coefficient
Globals:	None
Operation:	This routine returns TRUE if the specified covariance
      matrix indicates that all N dimensions are independent of
      one another.  One dimension is judged to be independent of
      another when the magnitude of the corresponding correlation
      coefficient is
      less than the specified Independence factor.  The
      correlation coefficient is calculated as: (see Duda and
      Hart, pg. 247)
      coeff[ij] = stddev[ij] / sqrt (stddev[ii] * stddev[jj])
      The covariance matrix is assumed to be symmetric (which
      should always be true).
Return:		TRUE if dimensions are independent, FALSE otherwise
Exceptions:	None
History:	6/4/89, DSJ, Created.
*******************************************************************************/
BOOL8
Independent (PARAM_DESC ParamDesc[],
inT16 N, FLOAT32 * CoVariance, FLOAT32 Independence) {
  int i, j;
  FLOAT32 *VARii;                // points to ith on-diagonal element
  FLOAT32 *VARjj;                // points to jth on-diagonal element
  FLOAT32 CorrelationCoeff;

  VARii = CoVariance;
  for (i = 0; i < N; i++, VARii += N + 1) {
    if (ParamDesc[i].NonEssential)
      continue;

    VARjj = VARii + N + 1;
    CoVariance = VARii + 1;
    for (j = i + 1; j < N; j++, CoVariance++, VARjj += N + 1) {
      if (ParamDesc[j].NonEssential)
        continue;

      if ((*VARii == 0.0) || (*VARjj == 0.0))
        CorrelationCoeff = 0.0;
      else
        CorrelationCoeff =
          sqrt (sqrt (*CoVariance * *CoVariance / (*VARii * *VARjj)));
      if (CorrelationCoeff > Independence)
        return (FALSE);
    }
  }
  return (TRUE);
}                                // Independent


/** GetBuckets **************************************************************
Parameters:	Distribution	type of probability distribution to test for
      SampleCount	number of samples that are available
      Confidence	probability of a Type I error
Globals:	none
Operation:	This routine returns a histogram data structure which can
      be used by other routines to place samples into histogram
      buckets, and then apply a goodness of fit test to the
      histogram data to determine if the samples belong to the
      specified probability distribution.  The routine keeps
      a list of bucket data structures which have already been
      created so that it minimizes the computation time needed
      to create a new bucket.
Return:		Bucket data structure
Exceptions: none
History:	Thu Aug  3 12:58:10 1989, DSJ, Created.
*****************************************************************************/
BUCKETS *GetBuckets(DISTRIBUTION Distribution,
                    uinT32 SampleCount,
                    FLOAT64 Confidence) {
  uinT16 NumberOfBuckets;
  BUCKETS *Buckets;

  // search for an old bucket structure with the same number of buckets
  NumberOfBuckets = OptimumNumberOfBuckets (SampleCount);
  Buckets = (BUCKETS *) first_node (search (OldBuckets[(int) Distribution],
    &NumberOfBuckets, NumBucketsMatch));

  // if a matching bucket structure is found, delete it from the list
  if (Buckets != NULL) {
    OldBuckets[(int) Distribution] =
      delete_d (OldBuckets[(int) Distribution], Buckets, ListEntryMatch);
    if (SampleCount != Buckets->SampleCount)
      AdjustBuckets(Buckets, SampleCount);
    if (Confidence != Buckets->Confidence) {
      Buckets->Confidence = Confidence;
      Buckets->ChiSquared = ComputeChiSquared
        (DegreesOfFreedom (Distribution, Buckets->NumberOfBuckets),
        Confidence);
    }
    InitBuckets(Buckets);
  }
  else                           // otherwise create a new structure
    Buckets = MakeBuckets (Distribution, SampleCount, Confidence);
  return (Buckets);
}                                // GetBuckets


/** Makebuckets *************************************************************
Parameters:	Distribution	type of probability distribution to test for
      SampleCount	number of samples that are available
      Confidence	probability of a Type I error
Globals:	None
Operation:	This routine creates a histogram data structure which can
      be used by other routines to place samples into histogram
      buckets, and then apply a goodness of fit test to the
      histogram data to determine if the samples belong to the
      specified probability distribution.  The buckets are
      allocated in such a way that the expected frequency of
      samples in each bucket is approximately the same.  In
      order to make this possible, a mapping table is
      computed which maps "normalized" samples into the
      appropriate bucket.
Return:		Pointer to new histogram data structure
Exceptions:	None
History:	6/4/89, DSJ, Created.
*****************************************************************************/
BUCKETS *MakeBuckets(DISTRIBUTION Distribution,
                     uinT32 SampleCount,
                     FLOAT64 Confidence) {
  static DENSITYFUNC DensityFunction[] =
    { NormalDensity, UniformDensity, UniformDensity };
  int i, j;
  BUCKETS *Buckets;
  FLOAT64 BucketProbability;
  FLOAT64 NextBucketBoundary;
  FLOAT64 Probability;
  FLOAT64 ProbabilityDelta;
  FLOAT64 LastProbDensity;
  FLOAT64 ProbDensity;
  uinT16 CurrentBucket;
  BOOL8 Symmetrical;

  // allocate memory needed for data structure
  Buckets = (BUCKETS *) Emalloc (sizeof (BUCKETS));
  Buckets->NumberOfBuckets = OptimumNumberOfBuckets (SampleCount);
  Buckets->SampleCount = SampleCount;
  Buckets->Confidence = Confidence;
  Buckets->Count =
    (uinT32 *) Emalloc (Buckets->NumberOfBuckets * sizeof (uinT32));
  Buckets->ExpectedCount =
    (FLOAT32 *) Emalloc (Buckets->NumberOfBuckets * sizeof (FLOAT32));

  // initialize simple fields
  Buckets->Distribution = Distribution;
  for (i = 0; i < Buckets->NumberOfBuckets; i++) {
    Buckets->Count[i] = 0;
    Buckets->ExpectedCount[i] = 0.0;
  }

  // all currently defined distributions are symmetrical
  Symmetrical = TRUE;
  Buckets->ChiSquared = ComputeChiSquared
    (DegreesOfFreedom (Distribution, Buckets->NumberOfBuckets), Confidence);

  if (Symmetrical) {
    // allocate buckets so that all have approx. equal probability
    BucketProbability = 1.0 / (FLOAT64) (Buckets->NumberOfBuckets);

    // distribution is symmetric so fill in upper half then copy
    CurrentBucket = Buckets->NumberOfBuckets / 2;
    if (Odd (Buckets->NumberOfBuckets))
      NextBucketBoundary = BucketProbability / 2;
    else
      NextBucketBoundary = BucketProbability;

    Probability = 0.0;
    LastProbDensity =
      (*DensityFunction[(int) Distribution]) (BUCKETTABLESIZE / 2);
    for (i = BUCKETTABLESIZE / 2; i < BUCKETTABLESIZE; i++) {
      ProbDensity = (*DensityFunction[(int) Distribution]) (i + 1);
      ProbabilityDelta = Integral (LastProbDensity, ProbDensity, 1.0);
      Probability += ProbabilityDelta;
      if (Probability > NextBucketBoundary) {
        if (CurrentBucket < Buckets->NumberOfBuckets - 1)
          CurrentBucket++;
        NextBucketBoundary += BucketProbability;
      }
      Buckets->Bucket[i] = CurrentBucket;
      Buckets->ExpectedCount[CurrentBucket] +=
        (FLOAT32) (ProbabilityDelta * SampleCount);
      LastProbDensity = ProbDensity;
    }
    // place any leftover probability into the last bucket
    Buckets->ExpectedCount[CurrentBucket] +=
      (FLOAT32) ((0.5 - Probability) * SampleCount);

    // copy upper half of distribution to lower half
    for (i = 0, j = BUCKETTABLESIZE - 1; i < j; i++, j--)
      Buckets->Bucket[i] =
        Mirror (Buckets->Bucket[j], Buckets->NumberOfBuckets);

    // copy upper half of expected counts to lower half
    for (i = 0, j = Buckets->NumberOfBuckets - 1; i <= j; i++, j--)
      Buckets->ExpectedCount[i] += Buckets->ExpectedCount[j];
  }
  return (Buckets);
}                                // MakeBuckets


//---------------------------------------------------------------------------
uinT16 OptimumNumberOfBuckets(uinT32 SampleCount) {
/*
 **	Parameters:
 **		SampleCount	number of samples to be tested
 **	Globals:
 **		CountTable	lookup table for number of samples
 **		BucketsTable	lookup table for necessary number of buckets
 **	Operation:
 **		This routine computes the optimum number of histogram
 **		buckets that should be used in a chi-squared goodness of
 **		fit test for the specified number of samples.  The optimum
 **		number is computed based on Table 4.1 on pg. 147 of
 **		"Measurement and Analysis of Random Data" by Bendat & Piersol.
 **		Linear interpolation is used to interpolate between table
 **		values.  The table is intended for a 0.05 level of
 **		significance (alpha).  This routine assumes that it is
 **		equally valid for other alpha's, which may not be true.
 **	Return:
 **		Optimum number of histogram buckets
 **	Exceptions:
 **		None
 **	History:
 **		6/5/89, DSJ, Created.
 */
  uinT8 Last, Next;
  FLOAT32 Slope;

  if (SampleCount < CountTable[0])
    return (BucketsTable[0]);

  for (Last = 0, Next = 1; Next < LOOKUPTABLESIZE; Last++, Next++) {
    if (SampleCount <= CountTable[Next]) {
      Slope = (FLOAT32) (BucketsTable[Next] - BucketsTable[Last]) /
        (FLOAT32) (CountTable[Next] - CountTable[Last]);
      return ((uinT16) (BucketsTable[Last] +
        Slope * (SampleCount - CountTable[Last])));
    }
  }
  return (BucketsTable[Last]);
}                                // OptimumNumberOfBuckets


//---------------------------------------------------------------------------
FLOAT64
ComputeChiSquared (uinT16 DegreesOfFreedom, FLOAT64 Alpha)
/*
 **	Parameters:
 **		DegreesOfFreedom	determines shape of distribution
 **		Alpha			probability of right tail
 **	Globals: none
 **	Operation:
 **		This routine computes the chi-squared value which will
 **		leave a cumulative probability of Alpha in the right tail
 **		of a chi-squared distribution with the specified number of
 **		degrees of freedom.  Alpha must be between 0 and 1.
 **		DegreesOfFreedom must be even.  The routine maintains an
 **		array of lists.  Each list corresponds to a different
 **		number of degrees of freedom.  Each entry in the list
 **		corresponds to a different alpha value and its corresponding
 **		chi-squared value.  Therefore, once a particular chi-squared
 **		value is computed, it is stored in the list and never
 **		needs to be computed again.
 **	Return: Desired chi-squared value
 **	Exceptions: none
 **	History: 6/5/89, DSJ, Created.
 */
#define CHIACCURACY     0.01
#define MINALPHA  (1e-200)
{
  static LIST ChiWith[MAXDEGREESOFFREEDOM + 1];

  CHISTRUCT *OldChiSquared;
  CHISTRUCT SearchKey;

  // limit the minimum alpha that can be used - if alpha is too small
  //      it may not be possible to compute chi-squared.
  if (Alpha < MINALPHA)
    Alpha = MINALPHA;
  if (Alpha > 1.0)
    Alpha = 1.0;
  if (Odd (DegreesOfFreedom))
    DegreesOfFreedom++;

  /* find the list of chi-squared values which have already been computed
     for the specified number of degrees of freedom.  Search the list for
     the desired chi-squared. */
  SearchKey.Alpha = Alpha;
  OldChiSquared = (CHISTRUCT *) first_node (search (ChiWith[DegreesOfFreedom],
    &SearchKey, AlphaMatch));

  if (OldChiSquared == NULL) {
    OldChiSquared = NewChiStruct (DegreesOfFreedom, Alpha);
    OldChiSquared->ChiSquared = Solve (ChiArea, OldChiSquared,
      (FLOAT64) DegreesOfFreedom,
      (FLOAT64) CHIACCURACY);
    ChiWith[DegreesOfFreedom] = push (ChiWith[DegreesOfFreedom],
      OldChiSquared);
  }
  else {
    // further optimization might move OldChiSquared to front of list
  }

  return (OldChiSquared->ChiSquared);

}                                // ComputeChiSquared


//---------------------------------------------------------------------------
FLOAT64 NormalDensity(inT32 x) {
/*
 **	Parameters:
 **		x	number to compute the normal probability density for
 **	Globals:
 **		NormalMean	mean of a discrete normal distribution
 **		NormalVariance	variance of a discrete normal distribution
 **		NormalMagnitude	magnitude of a discrete normal distribution
 **	Operation:
 **		This routine computes the probability density function
 **		of a discrete normal distribution defined by the global
 **		variables NormalMean, NormalVariance, and NormalMagnitude.
 **		Normal magnitude could, of course, be computed in terms of
 **		the normal variance but it is precomputed for efficiency.
 **	Return:
 **		The value of the normal distribution at x.
 **	Exceptions:
 **		None
 **	History:
 **		6/4/89, DSJ, Created.
 */
  FLOAT64 Distance;

  Distance = x - NormalMean;
  return (NormalMagnitude *
    exp (-0.5 * Distance * Distance / NormalVariance));
}                                // NormalDensity


//---------------------------------------------------------------------------
FLOAT64 UniformDensity(inT32 x) {
/*
 **	Parameters:
 **		x	number to compute the uniform probability density for
 **	Globals:
 **		BUCKETTABLESIZE		determines range of distribution
 **	Operation:
 **		This routine computes the probability density function
 **		of a uniform distribution at the specified point.  The
 **		range of the distribution is from 0 to BUCKETTABLESIZE.
 **	Return:
 **		The value of the uniform distribution at x.
 **	Exceptions:
 **		None
 **	History:
 **		6/5/89, DSJ, Created.
 */
  static FLOAT64 UniformDistributionDensity = (FLOAT64) 1.0 / BUCKETTABLESIZE;

  if ((x >= 0.0) && (x <= BUCKETTABLESIZE))
    return (UniformDistributionDensity);
  else
    return ((FLOAT64) 0.0);
}                                // UniformDensity


//---------------------------------------------------------------------------
FLOAT64 Integral(FLOAT64 f1, FLOAT64 f2, FLOAT64 Dx) {
/*
 **	Parameters:
 **		f1	value of function at x1
 **		f2	value of function at x2
 **		Dx	x2 - x1 (should always be positive)
 **	Globals:
 **		None
 **	Operation:
 **		This routine computes a trapezoidal approximation to the
 **		integral of a function over a small delta in x.
 **	Return:
 **		Approximation of the integral of the function from x1 to x2.
 **	Exceptions:
 **		None
 **	History:
 **		6/5/89, DSJ, Created.
 */
  return ((f1 + f2) * Dx / 2.0);
}                                // Integral


//---------------------------------------------------------------------------
void FillBuckets(BUCKETS *Buckets,
                 CLUSTER *Cluster,
                 uinT16 Dim,
                 PARAM_DESC *ParamDesc,
                 FLOAT32 Mean,
                 FLOAT32 StdDev) {
/*
 **	Parameters:
 **		Buckets		histogram buckets to count samples
 **		Cluster		cluster whose samples are being analyzed
 **		Dim		dimension of samples which is being analyzed
 **		ParamDesc	description of the dimension
 **		Mean		"mean" of the distribution
 **		StdDev		"standard deviation" of the distribution
 **	Globals:
 **		None
 **	Operation:
 **		This routine counts the number of cluster samples which
 **		fall within the various histogram buckets in Buckets.  Only
 **		one dimension of each sample is examined.  The exact meaning
 **		of the Mean and StdDev parameters depends on the
 **		distribution which is being analyzed (this info is in the
 **		Buckets data structure).  For normal distributions, Mean
 **		and StdDev have the expected meanings.  For uniform and
 **		random distributions the Mean is the center point of the
 **		range and the StdDev is 1/2 the range.  A dimension with
 **		zero standard deviation cannot be statistically analyzed.
 **		In this case, a pseudo-analysis is used.
 **	Return:
 **		None (the Buckets data structure is filled in)
 **	Exceptions:
 **		None
 **	History:
 **		6/5/89, DSJ, Created.
 */
  uinT16 BucketID;
  int i;
  LIST SearchState;
  SAMPLE *Sample;

  // initialize the histogram bucket counts to 0
  for (i = 0; i < Buckets->NumberOfBuckets; i++)
    Buckets->Count[i] = 0;

  if (StdDev == 0.0) {
    /* if the standard deviation is zero, then we can't statistically
       analyze the cluster.  Use a pseudo-analysis: samples exactly on
       the mean are distributed evenly across all buckets.  Samples greater
       than the mean are placed in the last bucket; samples less than the
       mean are placed in the first bucket. */

    InitSampleSearch(SearchState, Cluster);
    i = 0;
    while ((Sample = NextSample (&SearchState)) != NULL) {
      if (Sample->Mean[Dim] > Mean)
        BucketID = Buckets->NumberOfBuckets - 1;
      else if (Sample->Mean[Dim] < Mean)
        BucketID = 0;
      else
        BucketID = i;
      Buckets->Count[BucketID] += 1;
      i++;
      if (i >= Buckets->NumberOfBuckets)
        i = 0;
    }
  }
  else {
    // search for all samples in the cluster and add to histogram buckets
    InitSampleSearch(SearchState, Cluster);
    while ((Sample = NextSample (&SearchState)) != NULL) {
      switch (Buckets->Distribution) {
        case normal:
          BucketID = NormalBucket (ParamDesc, Sample->Mean[Dim],
            Mean, StdDev);
          break;
        case D_random:
        case uniform:
          BucketID = UniformBucket (ParamDesc, Sample->Mean[Dim],
            Mean, StdDev);
          break;
        default:
          BucketID = 0;
      }
      Buckets->Count[Buckets->Bucket[BucketID]] += 1;
    }
  }
}                                // FillBuckets


//---------------------------------------------------------------------------*/
uinT16 NormalBucket(PARAM_DESC *ParamDesc,
                    FLOAT32 x,
                    FLOAT32 Mean,
                    FLOAT32 StdDev) {
/*
 **	Parameters:
 **		ParamDesc	used to identify circular dimensions
 **		x		value to be normalized
 **		Mean		mean of normal distribution
 **		StdDev		standard deviation of normal distribution
 **	Globals:
 **		NormalMean	mean of discrete normal distribution
 **		NormalStdDev	standard deviation of discrete normal dist.
 **		BUCKETTABLESIZE	range of the discrete distribution
 **	Operation:
 **		This routine determines which bucket x falls into in the
 **		discrete normal distribution defined by NormalMean
 **		and NormalStdDev.  x values which exceed the range of
 **		the discrete distribution are clipped.
 **	Return:
 **		Bucket number into which x falls
 **	Exceptions:
 **		None
 **	History:
 **		6/5/89, DSJ, Created.
 */
  FLOAT32 X;

  // wraparound circular parameters if necessary
  if (ParamDesc->Circular) {
    if (x - Mean > ParamDesc->HalfRange)
      x -= ParamDesc->Range;
    else if (x - Mean < -ParamDesc->HalfRange)
      x += ParamDesc->Range;
  }

  X = ((x - Mean) / StdDev) * NormalStdDev + NormalMean;
  if (X < 0)
    return ((uinT16) 0);
  if (X > BUCKETTABLESIZE - 1)
    return ((uinT16) (BUCKETTABLESIZE - 1));
  return ((uinT16) floor ((FLOAT64) X));
}                                // NormalBucket


//---------------------------------------------------------------------------
uinT16 UniformBucket(PARAM_DESC *ParamDesc,
                     FLOAT32 x,
                     FLOAT32 Mean,
                     FLOAT32 StdDev) {
/*
 **	Parameters:
 **		ParamDesc	used to identify circular dimensions
 **		x		value to be normalized
 **		Mean		center of range of uniform distribution
 **		StdDev		1/2 the range of the uniform distribution
 **	Globals:
 **		BUCKETTABLESIZE	range of the discrete distribution
 **	Operation:
 **		This routine determines which bucket x falls into in the
 **		discrete uniform distribution defined by
 **		BUCKETTABLESIZE.  x values which exceed the range of
 **		the discrete distribution are clipped.
 **	Return:
 **		Bucket number into which x falls
 **	Exceptions:
 **		None
 **	History:
 **		6/5/89, DSJ, Created.
 */
  FLOAT32 X;

  // wraparound circular parameters if necessary
  if (ParamDesc->Circular) {
    if (x - Mean > ParamDesc->HalfRange)
      x -= ParamDesc->Range;
    else if (x - Mean < -ParamDesc->HalfRange)
      x += ParamDesc->Range;
  }

  X = ((x - Mean) / (2 * StdDev) * BUCKETTABLESIZE + BUCKETTABLESIZE / 2.0);
  if (X < 0)
    return ((uinT16) 0);
  if (X > BUCKETTABLESIZE - 1)
    return ((uinT16) (BUCKETTABLESIZE - 1));
  return ((uinT16) floor ((FLOAT64) X));
}                                // UniformBucket


//---------------------------------------------------------------------------
BOOL8 DistributionOK(BUCKETS *Buckets) {
/*
 **	Parameters:
 **		Buckets		histogram data to perform chi-square test on
 **	Globals:
 **		None
 **	Operation:
 **		This routine performs a chi-square goodness of fit test
 **		on the histogram data in the Buckets data structure.  TRUE
 **		is returned if the histogram matches the probability
 **		distribution which was specified when the Buckets
 **		structure was originally created.  Otherwise FALSE is
 **		returned.
 **	Return:
 **		TRUE if samples match distribution, FALSE otherwise
 **	Exceptions:
 **		None
 **	History:
 **		6/5/89, DSJ, Created.
 */
  FLOAT32 FrequencyDifference;
  FLOAT32 TotalDifference;
  int i;

  // compute how well the histogram matches the expected histogram
  TotalDifference = 0.0;
  for (i = 0; i < Buckets->NumberOfBuckets; i++) {
    FrequencyDifference = Buckets->Count[i] - Buckets->ExpectedCount[i];
    TotalDifference += (FrequencyDifference * FrequencyDifference) /
      Buckets->ExpectedCount[i];
  }

  // test to see if the difference is more than expected
  if (TotalDifference > Buckets->ChiSquared)
    return (FALSE);
  else
    return (TRUE);
}                                // DistributionOK


//---------------------------------------------------------------------------
void FreeStatistics(STATISTICS *Statistics) {
/*
 **	Parameters:
 **		Statistics	pointer to data structure to be freed
 **	Globals:
 **		None
 **	Operation:
 **		This routine frees the memory used by the statistics
 **		data structure.
 **	Return:
 **		None
 **	Exceptions:
 **		None
 **	History:
 **		6/5/89, DSJ, Created.
 */
  memfree (Statistics->CoVariance);
  memfree (Statistics->Min);
  memfree (Statistics->Max);
  memfree(Statistics);
}                                // FreeStatistics


//---------------------------------------------------------------------------
void FreeBuckets(BUCKETS *Buckets) {
/*
 **	Parameters:
 **		Buckets		pointer to data structure to be freed
 **	Globals: none
 **	Operation:
 **		This routine places the specified histogram data structure
 **		at the front of a list of histograms so that it can be
 **		reused later if necessary.  A separate list is maintained
 **		for each different type of distribution.
 **	Return: none
 **	Exceptions: none
 **	History: 6/5/89, DSJ, Created.
 */
  int Dist;

  if (Buckets != NULL) {
    Dist = (int) Buckets->Distribution;
    OldBuckets[Dist] = (LIST) push (OldBuckets[Dist], Buckets);
  }

}                                // FreeBuckets


//---------------------------------------------------------------------------
void FreeCluster(CLUSTER *Cluster) {
/*
 **	Parameters:
 **		Cluster		pointer to cluster to be freed
 **	Globals:
 **		None
 **	Operation:
 **		This routine frees the memory consumed by the specified
 **		cluster and all of its subclusters.  This is done by
 **		recursive calls to FreeCluster().
 **	Return:
 **		None
 **	Exceptions:
 **		None
 **	History:
 **		6/6/89, DSJ, Created.
 */
  if (Cluster != NULL) {
    FreeCluster (Cluster->Left);
    FreeCluster (Cluster->Right);
    memfree(Cluster);
  }
}                                // FreeCluster


//---------------------------------------------------------------------------
uinT16 DegreesOfFreedom(DISTRIBUTION Distribution, uinT16 HistogramBuckets) {
/*
 **	Parameters:
 **		Distribution		distribution being tested for
 **		HistogramBuckets	number of buckets in chi-square test
 **	Globals: none
 **	Operation:
 **		This routine computes the degrees of freedom that should
 **		be used in a chi-squared test with the specified number of
 **		histogram buckets.  The result is always rounded up to
 **		the next even number so that the value of chi-squared can be
 **		computed more easily.  This will cause the value of
 **		chi-squared to be higher than the optimum value, resulting
 **		in the chi-square test being more lenient than optimum.
 **	Return: The number of degrees of freedom for a chi-square test
 **	Exceptions: none
 **	History: Thu Aug  3 14:04:18 1989, DSJ, Created.
 */
  static uinT8 DegreeOffsets[] = { 3, 3, 1 };

  uinT16 AdjustedNumBuckets;

  AdjustedNumBuckets = HistogramBuckets - DegreeOffsets[(int) Distribution];
  if (Odd (AdjustedNumBuckets))
    AdjustedNumBuckets++;
  return (AdjustedNumBuckets);

}                                // DegreesOfFreedom


//---------------------------------------------------------------------------
int NumBucketsMatch(void *arg1,    //BUCKETS                                       *Histogram,
                    void *arg2) {  //uinT16                                        *DesiredNumberOfBuckets)
/*
 **	Parameters:
 **		Histogram	current histogram being tested for a match
 **		DesiredNumberOfBuckets	match key
 **	Globals: none
 **	Operation:
 **		This routine is used to search a list of histogram data
 **		structures to find one with the specified number of
 **		buckets.  It is called by the list search routines.
 **	Return: TRUE if Histogram matches DesiredNumberOfBuckets
 **	Exceptions: none
 **	History: Thu Aug  3 14:17:33 1989, DSJ, Created.
 */
  BUCKETS *Histogram = (BUCKETS *) arg1;
  uinT16 *DesiredNumberOfBuckets = (uinT16 *) arg2;

  return (*DesiredNumberOfBuckets == Histogram->NumberOfBuckets);

}                                // NumBucketsMatch


//---------------------------------------------------------------------------
int ListEntryMatch(void *arg1,    //ListNode
                   void *arg2) {  //Key
/*
 **	Parameters: none
 **	Globals: none
 **	Operation:
 **		This routine is used to search a list for a list node
 **		whose contents match Key.  It is called by the list
 **		delete_d routine.
 **	Return: TRUE if ListNode matches Key
 **	Exceptions: none
 **	History: Thu Aug  3 14:23:58 1989, DSJ, Created.
 */
  return (arg1 == arg2);

}                                // ListEntryMatch


//---------------------------------------------------------------------------
void AdjustBuckets(BUCKETS *Buckets, uinT32 NewSampleCount) {
/*
 **	Parameters:
 **		Buckets		histogram data structure to adjust
 **		NewSampleCount	new sample count to adjust to
 **	Globals: none
 **	Operation:
 **		This routine multiplies each ExpectedCount histogram entry
 **		by NewSampleCount/OldSampleCount so that the histogram
 **		is now adjusted to the new sample count.
 **	Return: none
 **	Exceptions: none
 **	History: Thu Aug  3 14:31:14 1989, DSJ, Created.
 */
  int i;
  FLOAT64 AdjustFactor;

  AdjustFactor = (((FLOAT64) NewSampleCount) /
    ((FLOAT64) Buckets->SampleCount));

  for (i = 0; i < Buckets->NumberOfBuckets; i++) {
    Buckets->ExpectedCount[i] *= AdjustFactor;
  }

  Buckets->SampleCount = NewSampleCount;

}                                // AdjustBuckets


//---------------------------------------------------------------------------
void InitBuckets(BUCKETS *Buckets) {
/*
 **	Parameters:
 **		Buckets		histogram data structure to init
 **	Globals: none
 **	Operation:
 **		This routine sets the bucket counts in the specified histogram
 **		to zero.
 **	Return: none
 **	Exceptions: none
 **	History: Thu Aug  3 14:31:14 1989, DSJ, Created.
 */
  int i;

  for (i = 0; i < Buckets->NumberOfBuckets; i++) {
    Buckets->Count[i] = 0;
  }

}                                // InitBuckets


//---------------------------------------------------------------------------
int AlphaMatch(void *arg1,    //CHISTRUCT                             *ChiStruct,
               void *arg2) {  //CHISTRUCT                             *SearchKey)
/*
 **	Parameters:
 **		ChiStruct	chi-squared struct being tested for a match
 **		SearchKey	chi-squared struct that is the search key
 **	Globals: none
 **	Operation:
 **		This routine is used to search a list of structures which
 **		hold pre-computed chi-squared values for a chi-squared
 **		value whose corresponding alpha field matches the alpha
 **		field of SearchKey.
 **		It is called by the list search routines.
 **	Return: TRUE if ChiStruct's Alpha matches SearchKey's Alpha
 **	Exceptions: none
 **	History: Thu Aug  3 14:17:33 1989, DSJ, Created.
 */
  CHISTRUCT *ChiStruct = (CHISTRUCT *) arg1;
  CHISTRUCT *SearchKey = (CHISTRUCT *) arg2;

  return (ChiStruct->Alpha == SearchKey->Alpha);

}                                // AlphaMatch


//---------------------------------------------------------------------------
CHISTRUCT *NewChiStruct(uinT16 DegreesOfFreedom, FLOAT64 Alpha) {
/*
 **	Parameters:
 **		DegreesOfFreedom	degrees of freedom for new chi value
 **		Alpha			confidence level for new chi value
 **	Globals: none
 **	Operation:
 **		This routine allocates a new data structure which is used
 **		to hold a chi-squared value along with its associated
 **		number of degrees of freedom and alpha value.
 **	Return: none
 **	Exceptions: none
 **	History: Fri Aug  4 11:04:59 1989, DSJ, Created.
 */
  CHISTRUCT *NewChiStruct;

  NewChiStruct = (CHISTRUCT *) Emalloc (sizeof (CHISTRUCT));
  NewChiStruct->DegreesOfFreedom = DegreesOfFreedom;
  NewChiStruct->Alpha = Alpha;
  return (NewChiStruct);

}                                // NewChiStruct


//---------------------------------------------------------------------------
FLOAT64
Solve (SOLVEFUNC Function,
void *FunctionParams, FLOAT64 InitialGuess, FLOAT64 Accuracy)
/*
 **	Parameters:
 **		Function	function whose zero is to be found
 **		FunctionParams	arbitrary data to pass to function
 **		InitialGuess	point to start solution search at
 **		Accuracy	maximum allowed error
 **	Globals: none
 **	Operation:
 **		This routine attempts to find an x value at which Function
 **		goes to zero (i.e. a root of the function ).  It will only
 **		work correctly if a solution actually exists and there
 **		are no extrema between the solution and the InitialGuess.
 **		The algorithms used are extremely primitive.
 **	Return: Solution of function ( x for which f(x) = 0 ).
 **	Exceptions: none
 **	History: Fri Aug  4 11:08:59 1989, DSJ, Created.
 */
#define INITIALDELTA    0.1
#define  DELTARATIO     0.1
{
  FLOAT64 x;
  FLOAT64 f;
  FLOAT64 Slope;
  FLOAT64 Delta;
  FLOAT64 NewDelta;
  FLOAT64 xDelta;
  FLOAT64 LastPosX, LastNegX;

  x = InitialGuess;
  Delta = INITIALDELTA;
  LastPosX = MAX_FLOAT32;
  LastNegX = -MAX_FLOAT32;
  f = (*Function) ((CHISTRUCT *) FunctionParams, x);
  while (Abs (LastPosX - LastNegX) > Accuracy) {
    // keep track of outer bounds of current estimate
    if (f < 0)
      LastNegX = x;
    else
      LastPosX = x;

    // compute the approx. slope of f(x) at the current point
    Slope =
      ((*Function) ((CHISTRUCT *) FunctionParams, x + Delta) - f) / Delta;

    // compute the next solution guess */
    xDelta = f / Slope;
    x -= xDelta;

    // reduce the delta used for computing slope to be a fraction of
    //the amount moved to get to the new guess
    NewDelta = Abs (xDelta) * DELTARATIO;
    if (NewDelta < Delta)
      Delta = NewDelta;

    // compute the value of the function at the new guess
    f = (*Function) ((CHISTRUCT *) FunctionParams, x);
  }
  return (x);

}                                // Solve


//---------------------------------------------------------------------------
FLOAT64 ChiArea(CHISTRUCT *ChiParams, FLOAT64 x) {
/*
 **	Parameters:
 **		ChiParams	contains degrees of freedom and alpha
 **		x		value of chi-squared to evaluate
 **	Globals: none
 **	Operation:
 **		This routine computes the area under a chi density curve
 **		from 0 to x, minus the desired area under the curve.  The
 **		number of degrees of freedom of the chi curve is specified
 **		in the ChiParams structure.  The desired area is also
 **		specified in the ChiParams structure as Alpha ( or 1 minus
 **		the desired area ).  This routine is intended to be passed
 **		to the Solve() function to find the value of chi-squared
 **		which will yield a desired area under the right tail of
 **		the chi density curve.  The function will only work for
 **		even degrees of freedom.  The equations are based on
 **		integrating the chi density curve in parts to obtain
 **		a series that can be used to compute the area under the
 **		curve.
 **	Return: Error between actual and desired area under the chi curve.
 **	Exceptions: none
 **	History: Fri Aug  4 12:48:41 1989, DSJ, Created.
 */
  int i, N;
  FLOAT64 SeriesTotal;
  FLOAT64 Denominator;
  FLOAT64 PowerOfx;

  N = ChiParams->DegreesOfFreedom / 2 - 1;
  SeriesTotal = 1;
  Denominator = 1;
  PowerOfx = 1;
  for (i = 1; i <= N; i++) {
    Denominator *= 2 * i;
    PowerOfx *= x;
    SeriesTotal += PowerOfx / Denominator;
  }
  return ((SeriesTotal * exp (-0.5 * x)) - ChiParams->Alpha);

}                                // ChiArea


//---------------------------------------------------------------------------
BOOL8
MultipleCharSamples (CLUSTERER * Clusterer,
CLUSTER * Cluster, FLOAT32 MaxIllegal)
/*
 **	Parameters:
 **		Clusterer	data structure holding cluster tree
 **		Cluster		cluster containing samples to be tested
 **		MaxIllegal	max percentage of samples allowed to have
 **				more than 1 feature in the cluster
 **	Globals: none
 **	Operation:
 **		This routine looks at all samples in the specified cluster.
 **		It computes a running estimate of the percentage of the
 **		charaters which have more than 1 sample in the cluster.
 **		When this percentage exceeds MaxIllegal, TRUE is returned.
 **		Otherwise FALSE is returned.  The CharID
 **		fields must contain integers which identify the training
 **		characters which were used to generate the sample.  One
 **		integer is used for each sample.  The NumChar field in
 **		the Clusterer must contain the number of characters in the
 **		training set.  All CharID fields must be between 0 and
 **		NumChar-1.  The main function of this routine is to help
 **		identify clusters which need to be split further, i.e. if
 **		numerous training characters have 2 or more features which are
 **		contained in the same cluster, then the cluster should be
 **		split.
 **	Return: TRUE if the cluster should be split, FALSE otherwise.
 **	Exceptions: none
 **	History: Wed Aug 30 11:13:05 1989, DSJ, Created.
 **		2/22/90, DSJ, Added MaxIllegal control rather than always
 **				splitting illegal clusters.
 */
#define ILLEGAL_CHAR    2
{
  static BOOL8 *CharFlags = NULL;
  static inT32 NumFlags = 0;
  int i;
  LIST SearchState;
  SAMPLE *Sample;
  inT32 CharID;
  inT32 NumCharInCluster;
  inT32 NumIllegalInCluster;
  FLOAT32 PercentIllegal;

  // initial estimate assumes that no illegal chars exist in the cluster
  NumCharInCluster = Cluster->SampleCount;
  NumIllegalInCluster = 0;

  if (Clusterer->NumChar > NumFlags) {
    if (CharFlags != NULL)
      memfree(CharFlags);
    NumFlags = Clusterer->NumChar;
    CharFlags = (BOOL8 *) Emalloc (NumFlags * sizeof (BOOL8));
  }

  for (i = 0; i < NumFlags; i++)
    CharFlags[i] = FALSE;

  // find each sample in the cluster and check if we have seen it before
  InitSampleSearch(SearchState, Cluster);
  while ((Sample = NextSample (&SearchState)) != NULL) {
    CharID = Sample->CharID;
    if (CharFlags[CharID] == FALSE) {
      CharFlags[CharID] = TRUE;
    }
    else {
      if (CharFlags[CharID] == TRUE) {
        NumIllegalInCluster++;
        CharFlags[CharID] = ILLEGAL_CHAR;
      }
      NumCharInCluster--;
      PercentIllegal = (FLOAT32) NumIllegalInCluster / NumCharInCluster;
      if (PercentIllegal > MaxIllegal)
        return (TRUE);
    }
  }
  return (FALSE);

}                                // MultipleCharSamples

// Compute the inverse of a matrix using LU decomposition with partial pivoting.
// The return value is the sum of norms of the off-diagonal terms of the
// product of a and inv. (A measure of the error.)
double InvertMatrix(const float* input, int size, float* inv) {
  double** U;  // The upper triangular array.
  double* Umem;
  double** U_inv;  // The inverse of U.
  double* U_invmem;
  double** L;  // The lower triangular array.
  double* Lmem;

  // Allocate memory for the 2D arrays.
  ALLOC_2D_ARRAY(size, size, Umem, U, double);
  ALLOC_2D_ARRAY(size, size, U_invmem, U_inv, double);
  ALLOC_2D_ARRAY(size, size, Lmem, L, double);

  // Initialize the working matrices. U starts as input, L as I and U_inv as O.
  int row;
  int col;
  for (row = 0; row < size; row++) {
    for (col = 0; col < size; col++) {
      U[row][col] = input[row*size + col];
      L[row][col] = row == col ? 1.0 : 0.0;
      U_inv[row][col] = 0.0;
    }
  }

  // Compute forward matrix by inversion by LU decomposition of input.
  for (col = 0; col < size; ++col) {
    // Find best pivot
    int best_row = 0;
    double best_pivot = -1.0;
    for (row = col; row < size; ++row) {
      if (Abs(U[row][col]) > best_pivot) {
        best_pivot = Abs(U[row][col]);
        best_row = row;
      }
    }
    // Exchange pivot rows.
    if (best_row != col) {
      for (int k = 0; k < size; ++k) {
        double tmp = U[best_row][k];
        U[best_row][k] = U[col][k];
        U[col][k] = tmp;
        tmp = L[best_row][k];
        L[best_row][k] = L[col][k];
        L[col][k] = tmp;
      }
    }
    // Now do the pivot itself.
    for (row = col + 1; row < size; ++row) {
      double ratio = -U[row][col] / U[col][col];
      for (int j = col; j < size; ++j) {
        U[row][j] += U[col][j] * ratio;
      }
      for (int k = 0; k < size; ++k) {
        L[row][k] += L[col][k] * ratio;
      }
    }
  }
  // Next invert U.
  for (col = 0; col < size; ++col) {
    U_inv[col][col] = 1.0 / U[col][col];
    for (row = col - 1; row >= 0; --row) {
      double total = 0.0;
      for (int k = col; k > row; --k) {
        total += U[row][k] * U_inv[k][col];
      }
      U_inv[row][col] = -total / U[row][row];
    }
  }
  // Now the answer is U_inv.L.
  for (row = 0; row < size; row++) {
    for (col = 0; col < size; col++) {
      double sum = 0.0;
      for (int k = row; k < size; ++k) {
        sum += U_inv[row][k] * L[k][col];
      }
      inv[row*size + col] = sum;
    }
  }
  // Check matrix product.
  double error_sum = 0.0;
  for (row = 0; row < size; row++) {
    for (col = 0; col < size; col++) {
      double sum = 0.0;
      for (int k = 0; k < size; ++k) {
        sum += input[row*size + k] * inv[k *size + col];
      }
      if (row != col) {
        error_sum += Abs(sum);
      }
    }
  }
  return error_sum;
}
/////////////////////////////////////////////////////////////////cluster////////////////////////////////////////

/////////////////////////////////////////////////////////////////clusttool////////////////////////////////////////
//---------------Global Data Definitions and Declarations--------------------
#define TOKENSIZE 80             //max size of tokens read from an input file
#define MAXSAMPLESIZE 65535      //max num of dimensions in feature space
//#define MAXBLOCKSIZE  65535   //max num of samples in a character (block size)

/*---------------------------------------------------------------------------
          Public Code
-----------------------------------------------------------------------------*/
/** ReadSampleSize ***********************************************************
Parameters:	File	open text file to read sample size from
Globals:	None
Operation:	This routine reads a single integer from the specified
      file and checks to ensure that it is between 0 and
      MAXSAMPLESIZE.
Return:		Sample size
Exceptions:	ILLEGALSAMPLESIZE	illegal format or range
History:	6/6/89, DSJ, Created.
******************************************************************************/
uinT16 ReadSampleSize(FILE *File) {
  int SampleSize;

  if ((fscanf (File, "%d", &SampleSize) != 1) ||
    (SampleSize < 0) || (SampleSize > MAXSAMPLESIZE))
    DoError (ILLEGALSAMPLESIZE, "Illegal sample size");
  return (SampleSize);
}                                // ReadSampleSize


/** ReadParamDesc *************************************************************
Parameters:	File	open text file to read N parameter descriptions from
      N	number of parameter descriptions to read
Globals:	None
Operation:	This routine reads textual descriptions of sets of parameters
      which describe the characteristics of feature dimensions.
Return:		Pointer to an array of parameter descriptors.
Exceptions:	ILLEGALCIRCULARSPEC
      ILLEGALESSENTIALSPEC
      ILLEGALMINMAXSPEC
History:	6/6/89, DSJ, Created.
******************************************************************************/
PARAM_DESC *ReadParamDesc(FILE *File, uinT16 N) {
  int i;
  PARAM_DESC *ParamDesc;
  char Token[TOKENSIZE];

  ParamDesc = (PARAM_DESC *) Emalloc (N * sizeof (PARAM_DESC));
  for (i = 0; i < N; i++) {
    if (fscanf (File, "%s", Token) != 1)
      DoError (ILLEGALCIRCULARSPEC,
        "Illegal circular/linear specification");
    if (Token[0] == 'c')
      ParamDesc[i].Circular = TRUE;
    else
      ParamDesc[i].Circular = FALSE;

    if (fscanf (File, "%s", Token) != 1)
      DoError (ILLEGALESSENTIALSPEC,
        "Illegal essential/non-essential spec");
    if (Token[0] == 'e')
      ParamDesc[i].NonEssential = FALSE;
    else
      ParamDesc[i].NonEssential = TRUE;
#ifndef _MSC_VER
    if (tess_fscanf (File, "%f%f", &(ParamDesc[i].Min), &(ParamDesc[i].Max)) !=
      2)
#else
    if (fscanf (File, "%f%f", &(ParamDesc[i].Min), &(ParamDesc[i].Max)) !=
      2)
#endif
      DoError (ILLEGALMINMAXSPEC, "Illegal min or max specification");
    ParamDesc[i].Range = ParamDesc[i].Max - ParamDesc[i].Min;
    ParamDesc[i].HalfRange = ParamDesc[i].Range / 2;
    ParamDesc[i].MidRange = (ParamDesc[i].Max + ParamDesc[i].Min) / 2;
  }
  return (ParamDesc);
}                                // ReadParamDesc


/** ReadPrototype *************************************************************
Parameters:	File	open text file to read prototype from
      N	number of dimensions used in prototype
Globals:	None
Operation:	This routine reads a textual description of a prototype from
      the specified file.
Return:		List of prototypes
Exceptions:	ILLEGALSIGNIFICANCESPEC
      ILLEGALSAMPLECOUNT
      ILLEGALMEANSPEC
      ILLEGALVARIANCESPEC
      ILLEGALDISTRIBUTION
History:	6/6/89, DSJ, Created.
******************************************************************************/
PROTOTYPE *ReadPrototype(FILE *File, uinT16 N) {
  char Token[TOKENSIZE];
  int Status;
  PROTOTYPE *Proto;
  int SampleCount;
  int i;

  if ((Status = fscanf (File, "%s", Token)) == 1) {
    Proto = (PROTOTYPE *) Emalloc (sizeof (PROTOTYPE));
    Proto->Cluster = NULL;
    if (Token[0] == 's')
      Proto->Significant = TRUE;
    else
      Proto->Significant = FALSE;

    Proto->Style = ReadProtoStyle (File);

    if ((fscanf (File, "%d", &SampleCount) != 1) || (SampleCount < 0))
      DoError (ILLEGALSAMPLECOUNT, "Illegal sample count");
    Proto->NumSamples = SampleCount;

    Proto->Mean = ReadNFloats (File, N, NULL);
    if (Proto->Mean == NULL)
      DoError (ILLEGALMEANSPEC, "Illegal prototype mean");

    switch (Proto->Style) {
      case spherical:
        if (ReadNFloats (File, 1, &(Proto->Variance.Spherical)) == NULL)
          DoError (ILLEGALVARIANCESPEC, "Illegal prototype variance");
        Proto->Magnitude.Spherical =
          1.0 / sqrt ((double) (2.0 * PI * Proto->Variance.Spherical));
        Proto->TotalMagnitude =
          pow (Proto->Magnitude.Spherical, (float) N);
        Proto->LogMagnitude = log ((double) Proto->TotalMagnitude);
        Proto->Weight.Spherical = 1.0 / Proto->Variance.Spherical;
        Proto->Distrib = NULL;
        break;
      case elliptical:
        Proto->Variance.Elliptical = ReadNFloats (File, N, NULL);
        if (Proto->Variance.Elliptical == NULL)
          DoError (ILLEGALVARIANCESPEC, "Illegal prototype variance");
        Proto->Magnitude.Elliptical =
          (FLOAT32 *) Emalloc (N * sizeof (FLOAT32));
        Proto->Weight.Elliptical =
          (FLOAT32 *) Emalloc (N * sizeof (FLOAT32));
        Proto->TotalMagnitude = 1.0;
        for (i = 0; i < N; i++) {
          Proto->Magnitude.Elliptical[i] =
            1.0 /
            sqrt ((double) (2.0 * PI * Proto->Variance.Elliptical[i]));
          Proto->Weight.Elliptical[i] =
            1.0 / Proto->Variance.Elliptical[i];
          Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
        }
        Proto->LogMagnitude = log ((double) Proto->TotalMagnitude);
        Proto->Distrib = NULL;
        break;
      case mixed:
        Proto->Distrib =
          (DISTRIBUTION *) Emalloc (N * sizeof (DISTRIBUTION));
        for (i = 0; i < N; i++) {
          if (fscanf (File, "%s", Token) != 1)
            DoError (ILLEGALDISTRIBUTION,
              "Illegal prototype distribution");
          switch (Token[0]) {
            case 'n':
              Proto->Distrib[i] = normal;
              break;
            case 'u':
              Proto->Distrib[i] = uniform;
              break;
            case 'r':
              Proto->Distrib[i] = D_random;
              break;
            default:
              DoError (ILLEGALDISTRIBUTION,
                "Illegal prototype distribution");
          }
        }
        Proto->Variance.Elliptical = ReadNFloats (File, N, NULL);
        if (Proto->Variance.Elliptical == NULL)
          DoError (ILLEGALVARIANCESPEC, "Illegal prototype variance");
        Proto->Magnitude.Elliptical =
          (FLOAT32 *) Emalloc (N * sizeof (FLOAT32));
        Proto->Weight.Elliptical =
          (FLOAT32 *) Emalloc (N * sizeof (FLOAT32));
        Proto->TotalMagnitude = 1.0;
        for (i = 0; i < N; i++) {
          switch (Proto->Distrib[i]) {
            case normal:
              Proto->Magnitude.Elliptical[i] = 1.0 /
                sqrt ((double)
                (2.0 * PI * Proto->Variance.Elliptical[i]));
              Proto->Weight.Elliptical[i] =
                1.0 / Proto->Variance.Elliptical[i];
              break;
            case uniform:
            case D_random:
              Proto->Magnitude.Elliptical[i] = 1.0 /
                (2.0 * Proto->Variance.Elliptical[i]);
              break;
          }
          Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
        }
        Proto->LogMagnitude = log ((double) Proto->TotalMagnitude);
        break;
    }
    return (Proto);
  }
  else if (Status == EOF)
    return (NULL);
  else {
    DoError (ILLEGALSIGNIFICANCESPEC, "Illegal significance specification");
    return (NULL);
  }
}                                // ReadPrototype


/* ReadProtoStyle *************************************************************
Parameters:	File	open text file to read prototype style from
Globals:	None
Operation:	This routine reads an single token from the specified
      text file and interprets it as a prototype specification.
Return:		Prototype style read from text file
Exceptions:	ILLEGALSTYLESPEC	illegal prototype style specification
History:	6/8/89, DSJ, Created.
*******************************************************************************/
PROTOSTYLE ReadProtoStyle(FILE *File) {
  char Token[TOKENSIZE];
  PROTOSTYLE Style;

  if (fscanf (File, "%s", Token) != 1)
    DoError (ILLEGALSTYLESPEC, "Illegal prototype style specification");
  switch (Token[0]) {
    case 's':
      Style = spherical;
      break;
    case 'e':
      Style = elliptical;
      break;
    case 'm':
      Style = mixed;
      break;
    case 'a':
      Style = automatic;
      break;
    default:
      Style = elliptical;
      DoError (ILLEGALSTYLESPEC, "Illegal prototype style specification");
  }
  return (Style);
}                                // ReadProtoStyle


/** ReadNFloats *************************************************************
Parameters:	File	open text file to read floats from
      N	number of floats to read
      Buffer	pointer to buffer to place floats into
Globals:	None
Operation:	This routine reads N floats from the specified text file
      and places them into Buffer.  If Buffer is NULL, a buffer
      is created and passed back to the caller.  If EOF is
      encountered before any floats can be read, NULL is
      returned.
Return:		Pointer to buffer holding floats or NULL if EOF
Exceptions:	ILLEGALFLOAT
History:	6/6/89, DSJ, Created.
******************************************************************************/
FLOAT32 *
ReadNFloats (FILE * File, uinT16 N, FLOAT32 Buffer[]) {
  int i;
  int NumFloatsRead;

  if (Buffer == NULL)
    Buffer = (FLOAT32 *) Emalloc (N * sizeof (FLOAT32));

  for (i = 0; i < N; i++) {
#ifndef _MSC_VER
    NumFloatsRead = tess_fscanf (File, "%f", &(Buffer[i]));
#else
    NumFloatsRead = fscanf (File, "%f", &(Buffer[i]));
#endif
    if (NumFloatsRead != 1) {
      if ((NumFloatsRead == EOF) && (i == 0))
        return (NULL);
      else
        DoError (ILLEGALFLOAT, "Illegal float specification");
    }
  }
  return (Buffer);
}                                // ReadNFloats


/** WriteParamDesc ************************************************************
Parameters:	File	open text file to write param descriptors to
      N		number of param descriptors to write
      ParamDesc	array of param descriptors to write
Globals:	None
Operation:	This routine writes an array of dimension descriptors to
      the specified text file.
Return:		None
Exceptions:	None
History:	6/6/89, DSJ, Created.
******************************************************************************/
void
WriteParamDesc (FILE * File, uinT16 N, PARAM_DESC ParamDesc[]) {
  int i;

  for (i = 0; i < N; i++) {
    if (ParamDesc[i].Circular)
      fprintf (File, "circular ");
    else
      fprintf (File, "linear   ");

    if (ParamDesc[i].NonEssential)
      fprintf (File, "non-essential ");
    else
      fprintf (File, "essential     ");

    fprintf (File, "%10.6f %10.6f\n", ParamDesc[i].Min, ParamDesc[i].Max);
  }
}                                // WriteParamDesc


/** WritePrototype ************************************************************
Parameters:	File	open text file to write prototype to
      N		number of dimensions in feature space
      Proto	prototype to write out
Globals:	None
Operation:	This routine writes a textual description of a prototype
      to the specified text file.
Return:		None
Exceptions:	None
History:	6/12/89, DSJ, Created.
*******************************************************************************/
void WritePrototype(FILE *File, uinT16 N, PROTOTYPE *Proto) {
  int i;

  if (Proto->Significant)
    fprintf (File, "significant   ");
  else
    fprintf (File, "insignificant ");
  WriteProtoStyle (File, (PROTOSTYLE) Proto->Style);
  fprintf (File, "%6d\n\t", Proto->NumSamples);
  WriteNFloats (File, N, Proto->Mean);
  fprintf (File, "\t");

  switch (Proto->Style) {
    case spherical:
      WriteNFloats (File, 1, &(Proto->Variance.Spherical));
      break;
    case elliptical:
      WriteNFloats (File, N, Proto->Variance.Elliptical);
      break;
    case mixed:
      for (i = 0; i < N; i++)
      switch (Proto->Distrib[i]) {
        case normal:
          fprintf (File, " %9s", "normal");
          break;
        case uniform:
          fprintf (File, " %9s", "uniform");
          break;
        case D_random:
          fprintf (File, " %9s", "random");
          break;
      }
      fprintf (File, "\n\t");
      WriteNFloats (File, N, Proto->Variance.Elliptical);
  }
}                                // WritePrototype


/** WriteNFloats ***********************************************************
Parameters:	File	open text file to write N floats to
      N		number of floats to write
      Array	array of floats to write
Globals:	None
Operation:	This routine writes a text representation of N floats from
      an array to a file.  All of the floats are placed on one line.
Return:		None
Exceptions:	None
History:	6/6/89, DSJ, Created.
****************************************************************************/
void
WriteNFloats (FILE * File, uinT16 N, FLOAT32 Array[]) {
  int i;

  for (i = 0; i < N; i++)
    fprintf (File, " %9.6f", Array[i]);
  fprintf (File, "\n");
}                                // WriteNFloats


/** WriteProtoSyle **********************************************************
Parameters:	File	open text file to write prototype style to
      ProtoStyle	prototype style to write
Globals:	None
Operation:	This routine writes to the specified text file a word
      which represents the ProtoStyle.  It does not append
      a carriage return to the end.
Return:		None
Exceptions:	None
History:	6/8/89, DSJ, Created.
****************************************************************************/
void WriteProtoStyle(FILE *File, PROTOSTYLE ProtoStyle) {
  switch (ProtoStyle) {
    case spherical:
      fprintf (File, "spherical");
      break;
    case elliptical:
      fprintf (File, "elliptical");
      break;
    case mixed:
      fprintf (File, "mixed");
      break;
    case automatic:
      fprintf (File, "automatic");
      break;
  }
}                                // WriteProtoStyle

/*---------------------------------------------------------------------------*/
void WriteProtoList(
     FILE	*File,
     uinT16	N,
     PARAM_DESC	ParamDesc[],
     LIST	ProtoList,
     BOOL8	WriteSigProtos,
     BOOL8	WriteInsigProtos)

/*
**	Parameters:
**		File		open text file to write prototypes to
**		N		number of dimensions in feature space
**		ParamDesc	descriptions for each dimension
**		ProtoList	list of prototypes to be written
**		WriteSigProtos	TRUE to write out significant prototypes
**		WriteInsigProtos	TRUE to write out insignificants
**	Globals:
**		None
**	Operation:
**		This routine writes a textual description of each prototype
**		in the prototype list to the specified file.  It also
**		writes a file header which includes the number of dimensions
**		in feature space and the descriptions for each dimension.
**	Return:
**		None
**	Exceptions:
**		None
**	History:
**		6/12/89, DSJ, Created.
*/

{
  PROTOTYPE	*Proto;

  /* write file header */
  fprintf(File,"%0d\n",N);
  WriteParamDesc(File,N,ParamDesc);

  /* write prototypes */
  iterate(ProtoList)
    {
      Proto = (PROTOTYPE *) first_node ( ProtoList );
      if (( Proto->Significant && WriteSigProtos )	||
      ( ! Proto->Significant && WriteInsigProtos ) )
    WritePrototype( File, N, Proto );
    }
}	/* WriteProtoList */

/** UniformRandomNumber ********************************************************
Parameters:	MMin	lower range of uniform distribution
      MMax	upper range of uniform distribution
Globals:	None
Operation:	This routine computes a random number which comes from a
      uniform distribution over the range from MMin to MMax.
Return:		Uniform random number
Exceptions:	None
History:	6/6/89, DSJ, Created.
*******************************************************************************/
FLOAT32 UniformRandomNumber(FLOAT32 MMin, FLOAT32 MMax) {
  double fake_drand48();
  FLOAT32 RandomNumber;

  RandomNumber = fake_drand48 ();
  return (MMin + (RandomNumber * (MMax - MMin)));
}                                // UniformRandomNumber


/** drand48 *************************************************************
Cheap replacement for drand48 which is not available on the PC.
**********************************************************************/

double fake_drand48() {
  return rand () / (RAND_MAX + 1.0);
}
/////////////////////////////////////////////////////////////////clusttool////////////////////////////////////////

/////////////////////////////////////////////////////////////////mfoutline////////////////////////////////////////
#define MIN_INERTIA (0.00001)

/*---------------------------------------------------------------------------
        Global Data Definitions and Declarations
----------------------------------------------------------------------------*/
/* center of current blob being processed - used when "unexpanding"
  expanded blobs */
static TPOINT BlobCenter;

/*----------------------------------------------------------------------------
             Variables
----------------------------------------------------------------------------*/

/* control knobs used to control normalization of outlines */
INT_VAR(classify_norm_method, character, "Normalization Method   ...");
/* PREV DEFAULT "baseline" */
double_VAR(classify_char_norm_range, 0.2, "Character Normalization Range ...");
double_VAR(classify_min_norm_scale_x, 0.0, "Min char x-norm scale ...");
/* PREV DEFAULT 0.1 */
double_VAR(classify_max_norm_scale_x, 0.325, "Max char x-norm scale ...");
/* PREV DEFAULT 0.3 */
double_VAR(classify_min_norm_scale_y, 0.0, "Min char y-norm scale ...");
/* PREV DEFAULT 0.1 */
double_VAR(classify_max_norm_scale_y, 0.325, "Max char y-norm scale ...");
/* PREV DEFAULT 0.3 */
/*----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
void ComputeBlobCenter(TBLOB *Blob, TPOINT *BlobCenter) {
/*
 ** Parameters:
 **   Blob    blob to compute centerpoint of
 **   BlobCenter  data struct to place results in
 ** Globals: none
 ** Operation:
 **   This routine computes the center point of the specified
 **   blob using the bounding box of all top level outlines in the
 **   blob.  The center point is computed in a coordinate system
 **   which is scaled up by VECSCALE from the page coordinate
 **   system.
 ** Return: none
 ** Exceptions: none
 ** History: Fri Sep  8 10:45:39 1989, DSJ, Created.
 */
  TPOINT TopLeft;
  TPOINT BottomRight;

  blob_bounding_box(Blob, &TopLeft, &BottomRight);

  BlobCenter->x = ((TopLeft.x << VECSCALE) + (BottomRight.x << VECSCALE)) / 2;
  BlobCenter->y = ((TopLeft.y << VECSCALE) + (BottomRight.y << VECSCALE)) / 2;

}                                /* ComputeBlobCenter */


/*---------------------------------------------------------------------------*/
LIST ConvertBlob(TBLOB *Blob) {
/*
 ** Parameters:
 **   Blob  blob to be converted
 ** Globals: none
 ** Operation: Convert Blob into a list of outlines.
 ** Return: List of outlines representing blob.
 ** Exceptions: none
 ** History: Thu Dec 13 15:40:17 1990, DSJ, Created.
 */
  LIST ConvertedOutlines = NIL;

  if (Blob != NULL) {
    SettupBlobConversion(Blob);  //ComputeBlobCenter (Blob, &BlobCenter);
    ConvertedOutlines = ConvertOutlines (Blob->outlines,
      ConvertedOutlines, outer);
  }

  return (ConvertedOutlines);
}                                /* ConvertBlob */


/*---------------------------------------------------------------------------*/
MFOUTLINE ConvertOutline(TESSLINE *Outline) {
/*
 ** Parameters:
 **   Outline   outline to be converted
 ** Globals:
 **   BlobCenter  pre-computed center of current blob
 ** Operation:
 **   This routine converts the specified outline into a special
 **   data structure which is used for extracting micro-features.
 **   If the outline has been pre-normalized by the splitter,
 **   then it is assumed to be in expanded form and all we must
 **   do is copy the points.  Otherwise,
 **   if the outline is expanded, then the expanded form is used
 **   and the coordinates of the points are returned to page
 **   coordinates using the global variable BlobCenter and the
 **   scaling factor REALSCALE.  If the outline is not expanded,
 **   then the compressed form is used.
 ** Return: Outline converted into special micro-features format.
 ** Exceptions: none
 ** History: 8/2/89, DSJ, Created.
 **   9/8/89, DSJ, Added ability to convert expanded blobs.
 **   1/11/90, DSJ, Changed to use REALSCALE instead of VECSCALE
 **         to eliminate round-off problems.
 **   2/21/91, DSJ, Added ability to work with pre-normalized
 **         blobs.
 **   4/30/91, DSJ, Added concept of "hidden" segments.
 */
  register BYTEVEC *Vector;
  TPOINT Position;
  TPOINT StartPosition;
  MFEDGEPT *NewPoint;
  MFOUTLINE MFOutline = NIL;
  EDGEPT *EdgePoint;
  EDGEPT *StartPoint;
  EDGEPT *NextPoint;

  if (Outline == NULL ||
    (Outline->compactloop == NULL && Outline->loop == NULL))
    return (MFOutline);

                                 /* have outlines been prenormalized */
  if (classify_baseline_normalized) {
    StartPoint = Outline->loop;
    EdgePoint = StartPoint;
    do {
      NextPoint = EdgePoint->next;

      /* filter out duplicate points */
      if (EdgePoint->pos.x != NextPoint->pos.x ||
      EdgePoint->pos.y != NextPoint->pos.y) {
        NewPoint = NewEdgePoint ();
        ClearMark(NewPoint);
        NewPoint->Hidden = is_hidden_edge(EdgePoint) ? TRUE : FALSE;
        NewPoint->Point.x = EdgePoint->pos.x;
        NewPoint->Point.y = EdgePoint->pos.y;
        MFOutline = push(MFOutline, NewPoint);
      }
      EdgePoint = NextPoint;
    }
    while (EdgePoint != StartPoint);
  }
                                 /* use compressed version of outline */
  else if (Outline->loop == NULL) {
    Position.x = StartPosition.x = Outline->start.x;
    Position.y = StartPosition.y = Outline->start.y;
    Vector = Outline->compactloop;
    do {
      if (Vector->dx != 0 || Vector->dy != 0) {
        NewPoint = NewEdgePoint ();
        ClearMark(NewPoint);
                                 /* all edges are visible */
        NewPoint->Hidden = FALSE;
        NewPoint->Point.x = Position.x;
        NewPoint->Point.y = Position.y;
        MFOutline = push (MFOutline, NewPoint);
      }
      Position.x += Vector->dx;
      Position.y += Vector->dy;
      Vector++;
    }
    while (Position.x != StartPosition.x ||
      (Position.y != StartPosition.y));
  }
  else {                         /* use expanded version of outline */
    StartPoint = Outline->loop;
    EdgePoint = StartPoint;
    do {
      NextPoint = EdgePoint->next;

      /* filter out duplicate points */
      if (EdgePoint->pos.x != NextPoint->pos.x ||
      EdgePoint->pos.y != NextPoint->pos.y) {
        NewPoint = NewEdgePoint ();
        ClearMark(NewPoint);
        NewPoint->Hidden = is_hidden_edge (EdgePoint) ? TRUE : FALSE;
        NewPoint->Point.x =
          (EdgePoint->pos.x + BlobCenter.x) / REALSCALE;
        NewPoint->Point.y =
          (EdgePoint->pos.y + BlobCenter.y) / REALSCALE;
        MFOutline = push (MFOutline, NewPoint);
      }
      EdgePoint = NextPoint;
    }
    while (EdgePoint != StartPoint);
  }

  MakeOutlineCircular(MFOutline);
  return (MFOutline);

}                                /* ConvertOutline */


/*---------------------------------------------------------------------------*/
LIST ConvertOutlines(TESSLINE *Outline,
                     LIST ConvertedOutlines,
                     OUTLINETYPE OutlineType) {
/*
 ** Parameters:
 **   Outline     first outline to be converted
 **   ConvertedOutlines list to add converted outlines to
 **   OutlineType   are the outlines outer or holes?
 ** Globals: none
 ** Operation:
 **              This routine converts all given outlines into a new format.
 **              of outlines.  Outline points to a list of the top level
 **   outlines to be converted.  The children of these outlines
 **   are also recursively converted.  All converted outlines
 **   are added to ConvertedOutlines.  This is a list of outlines,
 **   one for each outline that was converted.
 ** Return: Updated list of converted outlines.
 ** Exceptions: none
 ** History: Thu Dec 13 15:57:38 1990, DSJ, Created.
 */
  MFOUTLINE MFOutline;

  while (Outline != NULL) {
    if (Outline->child != NULL) {
      if (OutlineType == outer)
        ConvertedOutlines = ConvertOutlines (Outline->child,
          ConvertedOutlines, hole);
      else
        ConvertedOutlines = ConvertOutlines (Outline->child,
          ConvertedOutlines, outer);
    }

    MFOutline = ConvertOutline (Outline);
    ConvertedOutlines = push (ConvertedOutlines, MFOutline);
    Outline = Outline->next;
  }
  return (ConvertedOutlines);
}                                /* ConvertOutlines */


/*---------------------------------------------------------------------------*/
void ComputeOutlineStats(LIST Outlines, OUTLINE_STATS *OutlineStats) {
/*
 ** Parameters:
 **   Outlines  list of outlines to compute stats for
 **   OutlineStats  place to put results
 ** Globals: none
 ** Operation: This routine computes several statistics about the outlines
 **   in Outlines.  These statistics are usually used to perform
 **   anistropic normalization of all of the outlines.  The
 **   statistics generated are:
 **     first moments about x and y axes
 **     total length of all outlines
 **     center of mass of all outlines
 **     second moments about center of mass axes
 **     radius of gyration about center of mass axes
 ** Return: none (results are returned in OutlineStats)
 ** Exceptions: none
 ** History: Fri Dec 14 08:32:03 1990, DSJ, Created.
 */
  MFOUTLINE Outline;
  MFOUTLINE EdgePoint;
  MFEDGEPT *Current;
  MFEDGEPT *Last;

  InitOutlineStats(OutlineStats);
  iterate(Outlines) {
    Outline = (MFOUTLINE) first_node (Outlines);

    Last = PointAt (Outline);
    Outline = NextPointAfter (Outline);
    EdgePoint = Outline;
    do {
      Current = PointAt (EdgePoint);

      UpdateOutlineStats (OutlineStats,
        Last->Point.x, Last->Point.y,
        Current->Point.x, Current->Point.y);

      Last = Current;
      EdgePoint = NextPointAfter (EdgePoint);
    }
    while (EdgePoint != Outline);
  }
  FinishOutlineStats(OutlineStats);

}                                /* ComputeOutlineStats */


/*---------------------------------------------------------------------------*/
void FilterEdgeNoise(MFOUTLINE Outline, FLOAT32 NoiseSegmentLength) {
/*
 ** Parameters:
 **   Outline   outline to be filtered
 **   NoiseSegmentLength  maximum length of a "noise" segment
 ** Globals: none
 ** Operation: Filter out noise from the specified outline.  This is
 **   done by changing the direction of short segments of the
 **   outline to the same direction as the preceding outline
 **   segment.
 ** Return: none
 ** Exceptions: none
 ** History: Fri May  4 10:23:45 1990, DSJ, Created.
 */
  MFOUTLINE Current;
  MFOUTLINE Last;
  MFOUTLINE First;
  FLOAT32 Length;
  int NumFound = 0;
  DIRECTION DirectionOfFirst = north;

  if (DegenerateOutline (Outline))
    return;

  /* find 2 segments of different orientation which are long enough to
     not be filtered.  If two cannot be found, leave the outline unchanged. */
  First = NextDirectionChange (Outline);
  Last = First;
  do {
    Current = NextDirectionChange (Last);
    Length = DistanceBetween ((PointAt (Current)->Point),
      PointAt (Last)->Point);
    if (Length >= NoiseSegmentLength) {
      if (NumFound == 0) {
        NumFound = 1;
        DirectionOfFirst = PointAt (Last)->Direction;
      }
      else if (DirectionOfFirst != PointAt (Last)->Direction)
        break;
    }
    Last = Current;
  }
  while (Last != First);
  if (Current == Last)
    return;

  /* find each segment and filter it out if it is too short.  Note that
     the above code guarantees that the initial direction change will
     not be removed, therefore the loop will terminate. */
  First = Last;
  do {
    Current = NextDirectionChange (Last);
    Length = DistanceBetween (PointAt (Current)->Point,
      PointAt (Last)->Point);
    if (Length < NoiseSegmentLength)
      ChangeDirection (Last, Current, PointAt (Last)->PreviousDirection);

    Last = Current;
  }
  while (Last != First);

}                                /* FilterEdgeNoise */


/*---------------------------------------------------------------------------*/
void FindDirectionChanges(MFOUTLINE Outline,
                          FLOAT32 MinSlope,
                          FLOAT32 MaxSlope) {
/*
 ** Parameters:
 **   Outline   micro-feature outline to analyze
 **   MinSlope  controls "snapping" of segments to horizontal
 **   MaxSlope  controls "snapping" of segments to vertical
 ** Globals: none
 ** Operation:
 **   This routine searches thru the specified outline, computes
 **   a slope for each vector in the outline, and marks each
 **   vector as having one of the following directions:
 **     N, S, E, W, NE, NW, SE, SW
 **   This information is then stored in the outline and the
 **   outline is returned.
 ** Return: none
 ** Exceptions: none
 ** History: 7/21/89, DSJ, Created.
 */
  MFEDGEPT *Current;
  MFEDGEPT *Last;
  MFOUTLINE EdgePoint;

  if (DegenerateOutline (Outline))
    return;

  Last = PointAt (Outline);
  Outline = NextPointAfter (Outline);
  EdgePoint = Outline;
  do {
    Current = PointAt (EdgePoint);
    ComputeDirection(Last, Current, MinSlope, MaxSlope);

    Last = Current;
    EdgePoint = NextPointAfter (EdgePoint);
  }
  while (EdgePoint != Outline);

}                                /* FindDirectionChanges */


/*---------------------------------------------------------------------------*/
void FreeMFOutline(void *arg) {  //MFOUTLINE                             Outline)
/*
 ** Parameters:
 **   Outline   micro-feature outline to be freed
 ** Globals: none
 ** Operation:
 **   This routine deallocates all of the memory consumed by
 **   a micro-feature outline.
 ** Return: none
 ** Exceptions: none
 ** History: 7/27/89, DSJ, Created.
 */
  MFOUTLINE Start;
  MFOUTLINE Outline = (MFOUTLINE) arg;

  /* break the circular outline so we can use std. techniques to deallocate */
  Start = rest (Outline);
  set_rest(Outline, NIL);
  while (Start != NULL) {
    free_struct (first_node (Start), sizeof (MFEDGEPT), "MFEDGEPT");
    Start = pop (Start);
  }

}                                /* FreeMFOutline */


/*---------------------------------------------------------------------------*/
void FreeOutlines(LIST Outlines) {
/*
 ** Parameters:
 **   Outlines  list of mf-outlines to be freed
 ** Globals: none
 ** Operation: Release all memory consumed by the specified list
 **   of outlines.
 ** Return: none
 ** Exceptions: none
 ** History: Thu Dec 13 16:14:50 1990, DSJ, Created.
 */
  destroy_nodes(Outlines, FreeMFOutline);
}                                /* FreeOutlines */


/*---------------------------------------------------------------------------*/
void MarkDirectionChanges(MFOUTLINE Outline) {
/*
 ** Parameters:
 **   Outline   micro-feature outline to analyze
 ** Globals: none
 ** Operation:
 **   This routine searches thru the specified outline and finds
 **   the points at which the outline changes direction.  These
 **   points are then marked as "extremities".  This routine is
 **   used as an alternative to FindExtremities().  It forces the
 **   endpoints of the microfeatures to be at the direction
 **   changes rather than at the midpoint between direction
 **   changes.
 ** Return: none
 ** Exceptions: none
 ** History: 6/29/90, DSJ, Created.
 */
  MFOUTLINE Current;
  MFOUTLINE Last;
  MFOUTLINE First;

  if (DegenerateOutline (Outline))
    return;

  First = NextDirectionChange (Outline);
  Last = First;
  do {
    Current = NextDirectionChange (Last);
    MarkPoint (PointAt (Current));
    Last = Current;
  }
  while (Last != First);

}                                /* MarkDirectionChanges */


/*---------------------------------------------------------------------------*/
MFEDGEPT *NewEdgePoint() {
/*
 ** Parameters: none
 ** Globals: none
 ** Operation:
 **   This routine allocates and returns a new edge point for
 **   a micro-feature outline.
 ** Return: New edge point.
 ** Exceptions: none
 ** History: 7/21/89, DSJ, Created.
 */
  return ((MFEDGEPT *) alloc_struct (sizeof (MFEDGEPT), "MFEDGEPT"));

}                                /* NewEdgePoint */


/*---------------------------------------------------------------------------*/
MFOUTLINE NextExtremity(MFOUTLINE EdgePoint) {
/*
 ** Parameters:
 **   EdgePoint start search from this point
 ** Globals: none
 ** Operation:
 **   This routine returns the next point in the micro-feature
 **   outline that is an extremity.  The search starts after
 **   EdgePoint.  The routine assumes that the outline being
 **   searched is not a degenerate outline (i.e. it must have
 **   2 or more edge points).
 ** Return: Next extremity in the outline after EdgePoint.
 ** Exceptions: none
 ** History: 7/26/89, DSJ, Created.
 */
  EdgePoint = NextPointAfter (EdgePoint);
  while (!PointAt (EdgePoint)->ExtremityMark)
    EdgePoint = NextPointAfter (EdgePoint);

  return (EdgePoint);

}                                /* NextExtremity */


/*---------------------------------------------------------------------------*/
void NormalizeOutline(MFOUTLINE Outline,
                      LINE_STATS *LineStats,
                      FLOAT32 XOrigin) {
/*
 ** Parameters:
 **   Outline   outline to be normalized
 **   LineStats statistics for text line normalization
 **   XOrigin   x-origin of text
 ** Globals: none
 ** Operation:
 **   This routine normalizes the coordinates of the specified
 **   outline so that the outline is deskewed down to the
 **   baseline, translated so that x=0 is at XOrigin, and scaled
 **   so that the height of a character cell from descender to
 **   ascender is 1.  Of this height, 0.25 is for the descender,
 **   0.25 for the ascender, and 0.5 for the x-height.  The
 **   y coordinate of the baseline is 0.
 ** Return: none
 ** Exceptions: none
 ** History: 8/2/89, DSJ, Created.
 **   10/23/89, DSJ, Added ascender/descender stretching.
 **   11/89, DSJ, Removed ascender/descender stretching.
 */
  MFEDGEPT *Current;
  MFOUTLINE EdgePoint;
  FLOAT32 ScaleFactor;
  FLOAT32 AscStretch;
  FLOAT32 DescStretch;

  if (Outline != NIL) {
    ScaleFactor = ComputeScaleFactor (LineStats);
    AscStretch = 1.0;
    DescStretch = 1.0;

    EdgePoint = Outline;
    do {
      Current = PointAt (EdgePoint);

      Current->Point.y = ScaleFactor *
        (Current->Point.y -
        BaselineAt (LineStats, XPositionOf (Current)));

      if (Current->Point.y > NORMAL_X_HEIGHT)
        Current->Point.y = NORMAL_X_HEIGHT +
          (Current->Point.y - NORMAL_X_HEIGHT) / AscStretch;

      else if (Current->Point.y < NORMAL_BASELINE)
        Current->Point.y = NORMAL_BASELINE +
            (Current->Point.y - NORMAL_BASELINE) / DescStretch;

      Current->Point.x = ScaleFactor *
        (Current->Point.x - XOrigin);

      EdgePoint = NextPointAfter (EdgePoint);
    }
    while (EdgePoint != Outline);
  }
}                                /* NormalizeOutline */


/*---------------------------------------------------------------------------*/
void NormalizeOutlines(LIST Outlines,
                       LINE_STATS *LineStats,
                       FLOAT32 *XScale,
                       FLOAT32 *YScale) {
/*
 ** Parameters:
 **   Outlines  list of outlines to be normalized
 **   LineStats statistics for text line normalization
 **   XScale    x-direction scale factor used by routine
 **   YScale    y-direction scale factor used by routine
 ** Globals:
 **   classify_norm_method  method being used for normalization
 **   classify_char_norm_range map radius of gyration to this value
 ** Operation: This routine normalizes every outline in Outlines
 **   according to the currently selected normalization method.
 **   It also returns the scale factors that it used to do this
 **   scaling.  The scale factors returned represent the x and
 **   y sizes in the normalized coordinate system that correspond
 **   to 1 pixel in the original coordinate system.
 ** Return: none (Outlines are changed and XScale and YScale are updated)
 ** Exceptions: none
 ** History: Fri Dec 14 08:14:55 1990, DSJ, Created.
 */
  MFOUTLINE Outline;
  OUTLINE_STATS OutlineStats;
  FLOAT32 BaselineScale;

  switch (classify_norm_method) {
    case character:
      ComputeOutlineStats(Outlines, &OutlineStats);

      /* limit scale factor to avoid overscaling small blobs (.,`'),
         thin blobs (l1ift), and merged blobs */
      *XScale = *YScale = BaselineScale = ComputeScaleFactor (LineStats);
      *XScale *= OutlineStats.Ry;
      *YScale *= OutlineStats.Rx;
      if (*XScale < classify_min_norm_scale_x)
        *XScale = classify_min_norm_scale_x;
      if (*YScale < classify_min_norm_scale_y)
        *YScale = classify_min_norm_scale_y;
      if (*XScale > classify_max_norm_scale_x &&
          *YScale <= classify_max_norm_scale_y)
        *XScale = classify_max_norm_scale_x;
      *XScale = classify_char_norm_range * BaselineScale / *XScale;
      *YScale = classify_char_norm_range * BaselineScale / *YScale;

      iterate(Outlines) {
        Outline = (MFOUTLINE) first_node (Outlines);
        CharNormalizeOutline (Outline,
          OutlineStats.x, OutlineStats.y,
          *XScale, *YScale);
      }
      break;

    case baseline:
      iterate(Outlines) {
        Outline = (MFOUTLINE) first_node (Outlines);
        NormalizeOutline (Outline, LineStats, 0.0);
      }
      *XScale = *YScale = ComputeScaleFactor (LineStats);
      break;
  }
}                                /* NormalizeOutlines */


/*---------------------------------------------------------------------------*/
void SettupBlobConversion(TBLOB *Blob) {
/*
 ** Parameters:
 **   Blob    blob that is to be converted
 ** Globals:
 **   BlobCenter  center of blob to be converted
 ** Operation: Compute the center of the blob's bounding box and save
 **   it in a global variable.  This routine must be called before
 **   any calls to ConvertOutline.  It must be called once per
 **   blob.
 ** Return: none
 ** Exceptions: none
 ** History: Thu May 17 11:06:17 1990, DSJ, Created.
 */
  ComputeBlobCenter(Blob, &BlobCenter);
}                                /* SettupBlobConversion */


/*---------------------------------------------------------------------------*/
void SmearExtremities(MFOUTLINE Outline, FLOAT32 XScale, FLOAT32 YScale) {
/*
 ** Parameters:
 **   Outline   outline whose extremities are to be smeared
 **   XScale    factor used to normalize outline in x dir
 **   YScale    factor used to normalize outline in y dir
 ** Globals: none
 ** Operation:
 **   This routine smears the extremities of the specified outline.
 **   It does this by adding a random number between
 **   -0.5 and 0.5 pixels (that is why X/YScale are needed) to
 **   the x and y position of the point.  This is done so that
 **   the discrete nature of the original scanned image does not
 **   affect the statistical clustering used during training.
 ** Return: none
 ** Exceptions: none
 ** History: 1/11/90, DSJ, Created.
 */
  MFEDGEPT *Current;
  MFOUTLINE EdgePoint;
  FLOAT32 MinXSmear;
  FLOAT32 MaxXSmear;
  FLOAT32 MinYSmear;
  FLOAT32 MaxYSmear;

  if (Outline != NIL) {
    MinXSmear = -0.5 * XScale;
    MaxXSmear = 0.5 * XScale;
    MinYSmear = -0.5 * YScale;
    MaxYSmear = 0.5 * YScale;
    EdgePoint = Outline;
    do {
      Current = PointAt (EdgePoint);
      if (Current->ExtremityMark) {
        Current->Point.x +=
          UniformRandomNumber(MinXSmear, MaxXSmear);
        Current->Point.y +=
          UniformRandomNumber(MinYSmear, MaxYSmear);
      }

      EdgePoint = NextPointAfter (EdgePoint);
    }
    while (EdgePoint != Outline);
  }
}                                /* SmearExtremities */


/**----------------------------------------------------------------------------
              Private Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
void ChangeDirection(MFOUTLINE Start, MFOUTLINE End, DIRECTION Direction) {
/*
 ** Parameters:
 **   Start, End  defines segment of outline to be modified
 **   Direction new direction to assign to segment
 ** Globals: none
 ** Operation: Change the direction of every vector in the specified
 **   outline segment to Direction.  The segment to be changed
 **   starts at Start and ends at End.  Note that the previous
 **   direction of End must also be changed to reflect the
 **   change in direction of the point before it.
 ** Return: none
 ** Exceptions: none
 ** History: Fri May  4 10:42:04 1990, DSJ, Created.
 */
  MFOUTLINE Current;

  for (Current = Start; Current != End; Current = NextPointAfter (Current))
    PointAt (Current)->Direction = Direction;

  PointAt (End)->PreviousDirection = Direction;

}                                /* ChangeDirection */


/*---------------------------------------------------------------------------*/
void CharNormalizeOutline(MFOUTLINE Outline,
                          FLOAT32 XCenter,
                          FLOAT32 YCenter,
                          FLOAT32 XScale,
                          FLOAT32 YScale) {
/*
 ** Parameters:
 **   Outline     outline to be character normalized
 **   XCenter, YCenter  center point for normalization
 **   XScale, YScale    scale factors for normalization
 ** Globals: none
 ** Operation: This routine normalizes each point in Outline by
 **   translating it to the specified center and scaling it
 **   anisotropically according to the given scale factors.
 ** Return: none
 ** Exceptions: none
 ** History: Fri Dec 14 10:27:11 1990, DSJ, Created.
 */
  MFOUTLINE First, Current;
  MFEDGEPT *CurrentPoint;

  if (Outline == NIL)
    return;

  First = Outline;
  Current = First;
  do {
    CurrentPoint = PointAt (Current);
    CurrentPoint->Point.x =
      (CurrentPoint->Point.x - XCenter) * XScale;
    CurrentPoint->Point.y =
      (CurrentPoint->Point.y - YCenter) * YScale;

    Current = NextPointAfter (Current);
  }
  while (Current != First);

}                                /* CharNormalizeOutline */


/*---------------------------------------------------------------------------*/
void ComputeDirection(MFEDGEPT *Start,
                      MFEDGEPT *Finish,
                      FLOAT32 MinSlope,
                      FLOAT32 MaxSlope) {
/*
 ** Parameters:
 **   Start   starting point to compute direction from
 **   Finish    finishing point to compute direction to
 **   MinSlope  slope below which lines are horizontal
 **   MaxSlope  slope above which lines are vertical
 ** Globals: none
 ** Operation:
 **   This routine computes the slope from Start to Finish and
 **   and then computes the approximate direction of the line
 **   segment from Start to Finish.  The direction is quantized
 **   into 8 buckets:
 **     N, S, E, W, NE, NW, SE, SW
 **   Both the slope and the direction are then stored into
 **   the appropriate fields of the Start edge point.  The
 **   direction is also stored into the PreviousDirection field
 **   of the Finish edge point.
 ** Return: none
 ** Exceptions: none
 ** History: 7/25/89, DSJ, Created.
 */
  FVECTOR Delta;

  Delta.x = Finish->Point.x - Start->Point.x;
  Delta.y = Finish->Point.y - Start->Point.y;
  if (Delta.x == 0)
  if (Delta.y < 0) {
    Start->Slope = -MAX_FLOAT32;
    Start->Direction = south;
  }
  else {
    Start->Slope = MAX_FLOAT32;
    Start->Direction = north;
  }
  else {
    Start->Slope = Delta.y / Delta.x;
    if (Delta.x > 0)
      if (Delta.y > 0)
        if (Start->Slope > MinSlope)
          if (Start->Slope < MaxSlope)
            Start->Direction = northeast;
    else
      Start->Direction = north;
    else
      Start->Direction = east;
    else if (Start->Slope < -MinSlope)
    if (Start->Slope > -MaxSlope)
      Start->Direction = southeast;
    else
      Start->Direction = south;
    else
      Start->Direction = east;
    else if (Delta.y > 0)
    if (Start->Slope < -MinSlope)
      if (Start->Slope > -MaxSlope)
        Start->Direction = northwest;
    else
      Start->Direction = north;
    else
      Start->Direction = west;
    else if (Start->Slope > MinSlope)
    if (Start->Slope < MaxSlope)
      Start->Direction = southwest;
    else
      Start->Direction = south;
    else
      Start->Direction = west;
  }
  Finish->PreviousDirection = Start->Direction;
}                                /* ComputeDirection */


/*---------------------------------------------------------------------------*/
void FinishOutlineStats(register OUTLINE_STATS *OutlineStats) {
/*
 ** Parameters:
 **   OutlineStats  statistics about a set of outlines
 ** Globals: none
 ** Operation: Use the preliminary statistics accumulated in OutlineStats
 **   to compute the final statistics.
 **   (see Dan Johnson's Tesseract lab
 **   notebook #2, pgs. 74-78).
 ** Return: none
 ** Exceptions: none
 ** History: Fri Dec 14 10:13:36 1990, DSJ, Created.
 */
  OutlineStats->x = 0.5 * OutlineStats->My / OutlineStats->L;
  OutlineStats->y = 0.5 * OutlineStats->Mx / OutlineStats->L;

  OutlineStats->Ix = (OutlineStats->Ix / 3.0 -
    OutlineStats->y * OutlineStats->Mx +
    OutlineStats->y * OutlineStats->y * OutlineStats->L);

  OutlineStats->Iy = (OutlineStats->Iy / 3.0 -
    OutlineStats->x * OutlineStats->My +
    OutlineStats->x * OutlineStats->x * OutlineStats->L);

  /* Ix and/or Iy could possibly be negative due to roundoff error */
  if (OutlineStats->Ix < 0.0)
    OutlineStats->Ix = MIN_INERTIA;
  if (OutlineStats->Iy < 0.0)
    OutlineStats->Iy = MIN_INERTIA;

  OutlineStats->Rx = sqrt (OutlineStats->Ix / OutlineStats->L);
  OutlineStats->Ry = sqrt (OutlineStats->Iy / OutlineStats->L);

  OutlineStats->Mx *= 0.5;
  OutlineStats->My *= 0.5;

}                                /* FinishOutlineStats */


/*---------------------------------------------------------------------------*/
void InitOutlineStats(OUTLINE_STATS *OutlineStats) {
/*
 ** Parameters:
 **   OutlineStats  stats data structure to be initialized
 ** Globals: none
 ** Operation: Initialize the outline statistics data structure so
 **   that it is ready to start accumulating statistics.
 ** Return: none
 ** Exceptions: none
 ** History: Fri Dec 14 08:55:22 1990, DSJ, Created.
 */
  OutlineStats->Mx = 0.0;
  OutlineStats->My = 0.0;
  OutlineStats->L = 0.0;
  OutlineStats->x = 0.0;
  OutlineStats->y = 0.0;
  OutlineStats->Ix = 0.0;
  OutlineStats->Iy = 0.0;
  OutlineStats->Rx = 0.0;
  OutlineStats->Ry = 0.0;
}                                /* InitOutlineStats */


/*---------------------------------------------------------------------------*/
MFOUTLINE NextDirectionChange(MFOUTLINE EdgePoint) {
/*
 ** Parameters:
 **   EdgePoint start search from this point
 ** Globals: none
 ** Operation:
 **   This routine returns the next point in the micro-feature
 **   outline that has a direction different than EdgePoint.  The
 **   routine assumes that the outline being searched is not a
 **   degenerate outline (i.e. it must have 2 or more edge points).
 ** Return: Point of next direction change in micro-feature outline.
 ** Exceptions: none
 ** History: 7/25/89, DSJ, Created.
 */
  DIRECTION InitialDirection;

  InitialDirection = PointAt (EdgePoint)->Direction;

  do
  EdgePoint = NextPointAfter (EdgePoint);
  while (PointAt (EdgePoint)->Direction == InitialDirection);

  return (EdgePoint);
}                                /* NextDirectionChange */


/*---------------------------------------------------------------------------*/
void UpdateOutlineStats(register OUTLINE_STATS *OutlineStats,
                        register FLOAT32 x1,
                        register FLOAT32 x2,
                        register FLOAT32 y1,
                        register FLOAT32 y2) {
/*
 ** Parameters:
 **   OutlineStats  statistics to add this segment to
 **   x1, y1, x2, y2  segment to be added to statistics
 ** Globals: none
 ** Operation: This routine adds the statistics for the specified
 **   line segment to OutlineStats.  The statistics that are
 **   kept are:
 **     sum of length of all segments
 **     sum of 2*Mx for all segments
 **     sum of 2*My for all segments
 **     sum of 2*Mx*(y1+y2) - L*y1*y2 for all segments
 **     sum of 2*My*(x1+x2) - L*x1*x2 for all segments
 **   These numbers, once collected can later be used to easily
 **   compute the center of mass, first and second moments,
 **   and radii of gyration.  (see Dan Johnson's Tesseract lab
 **   notebook #2, pgs. 74-78).
 ** Return: none
 ** Exceptions: none
 ** History: Fri Dec 14 08:59:17 1990, DSJ, Created.
 */
  register FLOAT64 L;
  register FLOAT64 Mx2;
  register FLOAT64 My2;

  /* compute length of segment */
  L = sqrt ((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  OutlineStats->L += L;

  /* compute 2Mx and 2My components */
  Mx2 = L * (y1 + y2);
  My2 = L * (x1 + x2);
  OutlineStats->Mx += Mx2;
  OutlineStats->My += My2;

  /* compute second moment component */
  OutlineStats->Ix += Mx2 * (y1 + y2) - L * y1 * y2;
  OutlineStats->Iy += My2 * (x1 + x2) - L * x1 * x2;

}                                /* UpdateOutlineStats */
/////////////////////////////////////////////////////////////////mfoutline////////////////////////////////////////

/////////////////////////////////////////////////////////////////picofeat////////////////////////////////////////
/*---------------------------------------------------------------------------
          Variables
----------------------------------------------------------------------------*/

double_VAR(classify_pico_feature_length, 0.05, "Pico Feature Length");

/*---------------------------------------------------------------------------
          Private Function Prototypes
----------------------------------------------------------------------------*/
void ConvertSegmentToPicoFeat(FPOINT *Start,
                              FPOINT *End,
                              FEATURE_SET FeatureSet);

void ConvertToPicoFeatures2(MFOUTLINE Outline, FEATURE_SET FeatureSet);

void NormalizePicoX(FEATURE_SET FeatureSet);

/**----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
FEATURE_SET ExtractPicoFeatures(TBLOB *Blob, LINE_STATS *LineStats) {
/*
 **	Parameters:
 **		Blob		blob to extract pico-features from
 **		LineStats	statistics on text row blob is in
 **	Globals:
 **		classify_norm_method	normalization method currently specified
 **	Operation: Dummy for now.
 **	Return: Pico-features for Blob.
 **	Exceptions: none
 **	History: 9/4/90, DSJ, Created.
 */
  LIST Outlines;
  LIST RemainingOutlines;
  MFOUTLINE Outline;
  FEATURE_SET FeatureSet;
  FLOAT32 XScale, YScale;

  FeatureSet = NewFeatureSet(MAX_PICO_FEATURES);

  Outlines = ConvertBlob (Blob);

  NormalizeOutlines(Outlines, LineStats, &XScale, &YScale);
  RemainingOutlines = Outlines;
  iterate(RemainingOutlines) {
    Outline = (MFOUTLINE) first_node (RemainingOutlines);
    /*---------Debug--------------------------------------------------*
    OFile = fopen ("f:/ims/debug/pfOutline.logCPP", "r");
    if (OFile == NULL)
    {
      OFile = Efopen ("f:/ims/debug/pfOutline.logCPP", "w");
      WriteOutline(OFile, Outline);
    }
    else
    {
      fclose (OFile);
      OFile = Efopen ("f:/ims/debug/pfOutline.logCPP", "a");
    }
    WriteOutline(OFile, Outline);
    fclose (OFile);
    *--------------------------------------------------------------------*/
    ConvertToPicoFeatures2(Outline, FeatureSet);
  }
  if (classify_norm_method == baseline)
    NormalizePicoX(FeatureSet);
  /*---------Debug--------------------------------------------------*
  File = fopen ("f:/ims/debug/pfFeatSet.logCPP", "r");
  if (File == NULL)
  {
    File = Efopen ("f:/ims/debug/pfFeatSet.logCPP", "w");
    WriteFeatureSet(File, FeatureSet);
  }
  else
  {
    fclose (File);
    File = Efopen ("f:/ims/debug/pfFeatSet.logCPP", "a");
  }
  WriteFeatureSet(File, FeatureSet);
  fclose (File);
  *--------------------------------------------------------------------*/
  FreeOutlines(Outlines);
  return (FeatureSet);

}                                /* ExtractPicoFeatures */

/**----------------------------------------------------------------------------
              Private Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
void ConvertSegmentToPicoFeat(FPOINT *Start,
                              FPOINT *End,
                              FEATURE_SET FeatureSet) {
/*
 **	Parameters:
 **		Start		starting point of pico-feature
 **		End		ending point of pico-feature
 **		FeatureSet	set to add pico-feature to
 **	Globals:
 **		classify_pico_feature_length	length of a single pico-feature
 **	Operation: This routine converts an entire segment of an outline
 **		into a set of pico features which are added to
 **		FeatureSet.  The length of the segment is rounded to the
 **		nearest whole number of pico-features.  The pico-features
 **		are spaced evenly over the entire segment.
 **	Return: none (results are placed in FeatureSet)
 **	Exceptions: none
 **	History: Tue Apr 30 15:44:34 1991, DSJ, Created.
 */
  FEATURE Feature;
  FLOAT32 Angle;
  FLOAT32 Length;
  int NumFeatures;
  FPOINT Center;
  FPOINT Delta;
  int i;

  Angle = NormalizedAngleFrom (Start, End, 1.0);
  Length = DistanceBetween (*Start, *End);
  NumFeatures = (int) floor (Length / classify_pico_feature_length + 0.5);
  if (NumFeatures < 1)
    NumFeatures = 1;

  /* compute vector for one pico feature */
  Delta.x = XDelta (*Start, *End) / NumFeatures;
  Delta.y = YDelta (*Start, *End) / NumFeatures;

  /* compute position of first pico feature */
  Center.x = Start->x + Delta.x / 2.0;
  Center.y = Start->y + Delta.y / 2.0;

  /* compute each pico feature in segment and add to feature set */
  for (i = 0; i < NumFeatures; i++) {
    Feature = NewFeature (&PicoFeatDesc);
    Feature->Params[PicoFeatDir] = Angle;
    Feature->Params[PicoFeatX] = Center.x;
    Feature->Params[PicoFeatY] = Center.y;
    AddFeature(FeatureSet, Feature);

    Center.x += Delta.x;
    Center.y += Delta.y;
  }
}                                /* ConvertSegmentToPicoFeat */


/*---------------------------------------------------------------------------*/
void ConvertToPicoFeatures2(MFOUTLINE Outline, FEATURE_SET FeatureSet) {
/*
 **	Parameters:
 **		Outline		outline to extract micro-features from
 **		FeatureSet	set of features to add pico-features to
 **	Globals:
 **		classify_pico_feature_length
 **                             length of features to be extracted
 **	Operation:
 **		This routine steps thru the specified outline and cuts it
 **		up into pieces of equal length.  These pieces become the
 **		desired pico-features.  Each segment in the outline
 **		is converted into an integral number of pico-features.
 **	Return: none (results are returned in FeatureSet)
 **	Exceptions: none
 **	History: 4/30/91, DSJ, Adapted from ConvertToPicoFeatures().
 */
  MFOUTLINE Next;
  MFOUTLINE First;
  MFOUTLINE Current;

  if (DegenerateOutline(Outline))
    return;

  First = Outline;
  Current = First;
  Next = NextPointAfter(Current);
  do {
    /* note that an edge is hidden if the ending point of the edge is
       marked as hidden.  This situation happens because the order of
       the outlines is reversed when they are converted from the old
       format.  In the old format, a hidden edge is marked by the
       starting point for that edge. */
    if (!(PointAt(Next)->Hidden))
      ConvertSegmentToPicoFeat (&(PointAt(Current)->Point),
        &(PointAt(Next)->Point), FeatureSet);

    Current = Next;
    Next = NextPointAfter(Current);
  }
  while (Current != First);

}                                /* ConvertToPicoFeatures2 */


/*---------------------------------------------------------------------------*/
void NormalizePicoX(FEATURE_SET FeatureSet) {
/*
 **	Parameters:
 **		FeatureSet	pico-features to be normalized
 **	Globals: none
 **	Operation: This routine computes the average x position over all
 **		of the pico-features in FeatureSet and then renormalizes
 **		the pico-features to force this average to be the x origin
 **		(i.e. x=0).
 **	Return: none (FeatureSet is changed)
 **	Exceptions: none
 **	History: Tue Sep  4 16:50:08 1990, DSJ, Created.
 */
  int i;
  FEATURE Feature;
  FLOAT32 Origin = 0.0;

  for (i = 0; i < FeatureSet->NumFeatures; i++) {
    Feature = FeatureSet->Features[i];
    Origin += Feature->Params[PicoFeatX];
  }
  Origin /= FeatureSet->NumFeatures;

  for (i = 0; i < FeatureSet->NumFeatures; i++) {
    Feature = FeatureSet->Features[i];
    Feature->Params[PicoFeatX] -= Origin;
  }
}                                /* NormalizePicoX */
/////////////////////////////////////////////////////////////////picofeat////////////////////////////////////////

/////////////////////////////////////////////////////////////////intfx////////////////////////////////////////
/**----------------------------------------------------------------------------
          Private Function Prototypes
----------------------------------------------------------------------------**/
int SaveFeature();
uinT8 TableLookup();
uinT8 MySqrt2();
void ClipRadius();

INT_VAR(classify_radius_gyr_min_man, 255,
        "Minimum Radius of Gyration Mantissa 0-255:        ");

INT_VAR(classify_radius_gyr_min_exp, 0,
        "Minimum Radius of Gyration Exponent 0-255:        ");

INT_VAR(classify_radius_gyr_max_man, 158,
        "Maximum Radius of Gyration Mantissa 0-255:        ");

INT_VAR(classify_radius_gyr_max_exp, 8,
        "Maximum Radius of Gyration Exponent 0-255:        ");

/**----------------------------------------------------------------------------
        Global Data Definitions and Declarations
----------------------------------------------------------------------------**/
#define  ATAN_TABLE_SIZE    64

static uinT8 AtanTable[ATAN_TABLE_SIZE];

/**----------------------------------------------------------------------------
            Public Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
void InitIntegerFX() {
  int i;

  for (i = 0; i < ATAN_TABLE_SIZE; i++)
    AtanTable[i] =
      (uinT8) (atan ((i / (float) ATAN_TABLE_SIZE)) * 128.0 / PI + 0.5);

}


/*--------------------------------------------------------------------------*/
int ExtractIntFeat(TBLOB *Blob,
                   INT_FEATURE_ARRAY BLFeat,
                   INT_FEATURE_ARRAY CNFeat,
                   INT_FX_RESULT Results) {

  TESSLINE *OutLine;
  EDGEPT *Loop, *LoopStart, *Segment;
  inT16 LastX, LastY, Xmean, Ymean;
  inT32 NormX, NormY, DeltaX, DeltaY;
  inT32 Xsum, Ysum;
  uinT32 Ix, Iy, LengthSum;
  uinT16 n;
  uinT8 Theta;
  uinT16 NumBLFeatures, NumCNFeatures;
  uinT8 RxInv, RyInv;            /* x.xxxxxxx  *  2^Exp  */
  uinT8 RxExp, RyExp;
                                 /* sxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxx */
  register inT32 pfX, pfY, dX, dY;
  uinT16 Length;
  register int i;

  Results->Length = 0;
  Results->Xmean = 0;
  Results->Ymean = 0;
  Results->Rx = 0;
  Results->Ry = 0;
  Results->NumBL = 0;
  Results->NumCN = 0;

  /* find Xmean, Ymean */
  NumBLFeatures = 0;
  NumCNFeatures = 0;
  OutLine = Blob->outlines;
  Xsum = 0;
  Ysum = 0;
  LengthSum = 0;
  while (OutLine != NULL) {
    LoopStart = OutLine->loop;
    Loop = LoopStart;
    LastX = Loop->pos.x;
    LastY = Loop->pos.y;
    /* Check for bad loops */
    if ((Loop == NULL) || (Loop->next == NULL) || (Loop->next == LoopStart))
      return FALSE;
    do {
      Segment = Loop;
      Loop = Loop->next;
      NormX = Loop->pos.x;
      NormY = Loop->pos.y;

      n = 1;
      if (!is_hidden_edge (Segment)) {
        DeltaX = NormX - LastX;
        DeltaY = NormY - LastY;
        Length = MySqrt (DeltaX, DeltaY);
        n = ((Length << 2) + Length + 32) >> 6;
        if (n != 0) {
          Xsum += ((LastX << 1) + DeltaX) * (int) Length;
          Ysum += ((LastY << 1) + DeltaY) * (int) Length;
          LengthSum += Length;
        }
      }
      if (n != 0) {              /* Throw away a point that is too close */
        LastX = NormX;
        LastY = NormY;
      }
    }
    while (Loop != LoopStart);
    OutLine = OutLine->next;
  }
  if (LengthSum == 0)
    return FALSE;
  Xmean = (Xsum / (inT32) LengthSum) >> 1;
  Ymean = (Ysum / (inT32) LengthSum) >> 1;

  Results->Length = LengthSum;
  Results->Xmean = Xmean;
  Results->Ymean = Ymean;

  /* extract Baseline normalized features,     */
  /* and find 2nd moments & radius of gyration */
  Ix = 0;
  Iy = 0;
  NumBLFeatures = 0;
  OutLine = Blob->outlines;
  while (OutLine != NULL) {
    LoopStart = OutLine->loop;
    Loop = LoopStart;
    LastX = Loop->pos.x - Xmean;
    LastY = Loop->pos.y;
    /* Check for bad loops */
    if ((Loop == NULL) || (Loop->next == NULL) || (Loop->next == LoopStart))
      return FALSE;
    do {
      Segment = Loop;
      Loop = Loop->next;
      NormX = Loop->pos.x - Xmean;
      NormY = Loop->pos.y;

      n = 1;
      if (!is_hidden_edge (Segment)) {
        DeltaX = NormX - LastX;
        DeltaY = NormY - LastY;
        Length = MySqrt (DeltaX, DeltaY);
        n = ((Length << 2) + Length + 32) >> 6;
        if (n != 0) {
          Theta = TableLookup (DeltaY, DeltaX);
          dX = (DeltaX << 8) / n;
          dY = (DeltaY << 8) / n;
          pfX = (LastX << 8) + (dX >> 1);
          pfY = (LastY << 8) + (dY >> 1);
          Ix += ((pfY >> 8) - Ymean) * ((pfY >> 8) - Ymean);
          Iy += (pfX >> 8) * (pfX >> 8);
          if (SaveFeature (BLFeat, NumBLFeatures, (inT16) (pfX >> 8),
            (inT16) ((pfY >> 8) - 128),
            Theta) == FALSE)
            return FALSE;
          NumBLFeatures++;
          for (i = 1; i < n; i++) {
            pfX += dX;
            pfY += dY;
            Ix += ((pfY >> 8) - Ymean) * ((pfY >> 8) - Ymean);
            Iy += (pfX >> 8) * (pfX >> 8);
            if (SaveFeature
              (BLFeat, NumBLFeatures, (inT16) (pfX >> 8),
              (inT16) ((pfY >> 8) - 128), Theta) == FALSE)
              return FALSE;
            NumBLFeatures++;
          }
        }
      }
      if (n != 0) {              /* Throw away a point that is too close */
        LastX = NormX;
        LastY = NormY;
      }
    }
    while (Loop != LoopStart);
    OutLine = OutLine->next;
  }
  if (Ix == 0)
    Ix = 1;
  if (Iy == 0)
    Iy = 1;
  RxInv = MySqrt2 (NumBLFeatures, Ix, &RxExp);
  RyInv = MySqrt2 (NumBLFeatures, Iy, &RyExp);
  ClipRadius(&RxInv, &RxExp, &RyInv, &RyExp);

  Results->Rx = (inT16) (51.2 / (double) RxInv * pow (2.0, (double) RxExp));
  Results->Ry = (inT16) (51.2 / (double) RyInv * pow (2.0, (double) RyExp));
  if (Results->Ry == 0) {
    /*
        This would result in features having 'nan' values.
        Since the expression is always > 0, assign a value of 1.
    */
    Results->Ry = 1;
  }
  Results->NumBL = NumBLFeatures;

  /* extract character normalized features */
  NumCNFeatures = 0;
  OutLine = Blob->outlines;
  while (OutLine != NULL) {
    LoopStart = OutLine->loop;
    Loop = LoopStart;
    LastX = (Loop->pos.x - Xmean) * RyInv;
    LastY = (Loop->pos.y - Ymean) * RxInv;
    LastX >>= (inT8) RyExp;
    LastY >>= (inT8) RxExp;
    /* Check for bad loops */
    if ((Loop == NULL) || (Loop->next == NULL) || (Loop->next == LoopStart))
      return FALSE;
    do {
      Segment = Loop;
      Loop = Loop->next;
      NormX = (Loop->pos.x - Xmean) * RyInv;
      NormY = (Loop->pos.y - Ymean) * RxInv;
      NormX >>= (inT8) RyExp;
      NormY >>= (inT8) RxExp;

      n = 1;
      if (!is_hidden_edge (Segment)) {
        DeltaX = NormX - LastX;
        DeltaY = NormY - LastY;
        Length = MySqrt (DeltaX, DeltaY);
        n = ((Length << 2) + Length + 32) >> 6;
        if (n != 0) {
          Theta = TableLookup (DeltaY, DeltaX);
          dX = (DeltaX << 8) / n;
          dY = (DeltaY << 8) / n;
          pfX = (LastX << 8) + (dX >> 1);
          pfY = (LastY << 8) + (dY >> 1);
          if (SaveFeature (CNFeat, NumCNFeatures, (inT16) (pfX >> 8),
            (inT16) ((pfY >> 8)), Theta) == FALSE)
            return FALSE;
          NumCNFeatures++;
          for (i = 1; i < n; i++) {
            pfX += dX;
            pfY += dY;
            if (SaveFeature
              (CNFeat, NumCNFeatures, (inT16) (pfX >> 8),
              (inT16) ((pfY >> 8)), Theta) == FALSE)
              return FALSE;
            NumCNFeatures++;
          }
        }
      }
      if (n != 0) {              /* Throw away a point that is too close */
        LastX = NormX;
        LastY = NormY;
      }
    }
    while (Loop != LoopStart);
    OutLine = OutLine->next;
  }

  Results->NumCN = NumCNFeatures;
  return TRUE;
}


/*--------------------------------------------------------------------------*/
uinT8 TableLookup(inT32 Y, inT32 X) {
  inT16 Angle;
  uinT16 Ratio;
  uinT32 AbsX, AbsY;

  assert ((X != 0) || (Y != 0));
  if (X < 0)
    AbsX = -X;
  else
    AbsX = X;
  if (Y < 0)
    AbsY = -Y;
  else
    AbsY = Y;
  if (AbsX > AbsY)
    Ratio = AbsY * ATAN_TABLE_SIZE / AbsX;
  else
    Ratio = AbsX * ATAN_TABLE_SIZE / AbsY;
  if (Ratio >= ATAN_TABLE_SIZE)
    Ratio = ATAN_TABLE_SIZE - 1;
  Angle = AtanTable[Ratio];
  if (X >= 0)
    if (Y >= 0)
      if (AbsX > AbsY)
        Angle = Angle;
  else
    Angle = 64 - Angle;
  else if (AbsX > AbsY)
    Angle = 256 - Angle;
  else
    Angle = 192 + Angle;
  else if (Y >= 0)
  if (AbsX > AbsY)
    Angle = 128 - Angle;
  else
    Angle = 64 + Angle;
  else if (AbsX > AbsY)
    Angle = 128 + Angle;
  else
    Angle = 192 - Angle;

  /* reverse angles to match old feature extractor:   Angle += PI */
  Angle += 128;
  Angle &= 255;
  return (uinT8) Angle;
}


/*--------------------------------------------------------------------------*/
int SaveFeature(INT_FEATURE_ARRAY FeatureArray,
                uinT16 FeatureNum,
                inT16 X,
                inT16 Y,
                uinT8 Theta) {
  INT_FEATURE Feature;

  if (FeatureNum >= MAX_NUM_INT_FEATURES)
    return FALSE;

  Feature = &(FeatureArray[FeatureNum]);

  X = X + 128;
  Y = Y + 128;

  if (X > 255)
    Feature->X = 255;
  else if (X < 0)
    Feature->X = 0;
  else
    Feature->X = X;

  if (Y > 255)
    Feature->Y = 255;
  else if (Y < 0)
    Feature->Y = 0;
  else
    Feature->Y = Y;

  Feature->Theta = Theta;

  return TRUE;
}


/*---------------------------------------------------------------------------*/
uinT16 MySqrt(inT32 X, inT32 Y) {
  register uinT16 SqRoot;
  register uinT32 Square;
  register uinT16 BitLocation;
  register uinT32 Sum;

  if (X < 0)
    X = -X;
  if (Y < 0)
    Y = -Y;

  if (X > (inT32)EvidenceMultMask)
    X = EvidenceMultMask;
  if (Y > (inT32)EvidenceMultMask)
    Y = EvidenceMultMask;

  Sum = X * X + Y * Y;

  BitLocation = 1024;
  SqRoot = 0;
  do {
    Square = (SqRoot | BitLocation) * (SqRoot | BitLocation);
    if (Square <= Sum)
      SqRoot |= BitLocation;
    BitLocation >>= 1;
  }
  while (BitLocation);

  return SqRoot;
}


/*--------------------------------------------------------------------------*/
uinT8 MySqrt2(uinT16 N, uinT32 I, uinT8 *Exp) {
  register inT8 k;
  register uinT32 N2;
  register uinT8 SqRoot;
  register uinT16 Square;
  register uinT8 BitLocation;
  register uinT16 Ratio;

  N2 = N * 41943;

  k = 9;
  while ((N2 & 0xc0000000) == 0) {
    N2 <<= 2;
    k += 1;
  }

  while ((I & 0xc0000000) == 0) {
    I <<= 2;
    k -= 1;
  }

  if (((N2 & 0x80000000) == 0) && ((I & 0x80000000) == 0)) {
    N2 <<= 1;
    I <<= 1;
  }

  N2 &= 0xffff0000;
  I >>= 14;
  Ratio = N2 / I;

  BitLocation = 128;
  SqRoot = 0;
  do {
    Square = (SqRoot | BitLocation) * (SqRoot | BitLocation);
    if (Square <= Ratio)
      SqRoot |= BitLocation;
    BitLocation >>= 1;
  }
  while (BitLocation);

  if (k < 0) {
    *Exp = 0;
    return 255;
  }
  else {
    *Exp = k;
    return SqRoot;
  }
}


/*-------------------------------------------------------------------------*/
void ClipRadius(uinT8 *RxInv, uinT8 *RxExp, uinT8 *RyInv, uinT8 *RyExp) {
  register uinT8 AM, BM, AE, BE;
  register uinT8 BitN, LastCarry;
  int RxInvLarge, RyInvSmall;

  AM = classify_radius_gyr_min_man;
  AE = classify_radius_gyr_min_exp;
  BM = *RxInv;
  BE = *RxExp;
  LastCarry = 1;
  while ((AM != 0) || (BM != 0)) {
    if (AE > BE) {
      BitN = LastCarry + (AM & 1) + 1;
      AM >>= 1;
      AE--;
    }
    else if (AE < BE) {
      BitN = LastCarry + (!(BM & 1));
      BM >>= 1;
      BE--;
    }
    else {                       /* AE == BE */
      BitN = LastCarry + (AM & 1) + (!(BM & 1));
      AM >>= 1;
      BM >>= 1;
      AE--;
      BE--;
    }
    LastCarry = (BitN & 2) > 1;
    BitN = BitN & 1;
  }
  BitN = LastCarry + 1;
  LastCarry = (BitN & 2) > 1;
  BitN = BitN & 1;

  if (BitN == 1) {
    *RxInv = classify_radius_gyr_min_man;
    *RxExp = classify_radius_gyr_min_exp;
  }

  AM = classify_radius_gyr_min_man;
  AE = classify_radius_gyr_min_exp;
  BM = *RyInv;
  BE = *RyExp;
  LastCarry = 1;
  while ((AM != 0) || (BM != 0)) {
    if (AE > BE) {
      BitN = LastCarry + (AM & 1) + 1;
      AM >>= 1;
      AE--;
    }
    else if (AE < BE) {
      BitN = LastCarry + (!(BM & 1));
      BM >>= 1;
      BE--;
    }
    else {                       /* AE == BE */
      BitN = LastCarry + (AM & 1) + (!(BM & 1));
      AM >>= 1;
      BM >>= 1;
      AE--;
      BE--;
    }
    LastCarry = (BitN & 2) > 1;
    BitN = BitN & 1;
  }
  BitN = LastCarry + 1;
  LastCarry = (BitN & 2) > 1;
  BitN = BitN & 1;

  if (BitN == 1) {
    *RyInv = classify_radius_gyr_min_man;
    *RyExp = classify_radius_gyr_min_exp;
  }

  AM = classify_radius_gyr_max_man;
  AE = classify_radius_gyr_max_exp;
  BM = *RxInv;
  BE = *RxExp;
  LastCarry = 1;
  while ((AM != 0) || (BM != 0)) {
    if (AE > BE) {
      BitN = LastCarry + (AM & 1) + 1;
      AM >>= 1;
      AE--;
    }
    else if (AE < BE) {
      BitN = LastCarry + (!(BM & 1));
      BM >>= 1;
      BE--;
    }
    else {                       /* AE == BE */
      BitN = LastCarry + (AM & 1) + (!(BM & 1));
      AM >>= 1;
      BM >>= 1;
      AE--;
      BE--;
    }
    LastCarry = (BitN & 2) > 1;
    BitN = BitN & 1;
  }
  BitN = LastCarry + 1;
  LastCarry = (BitN & 2) > 1;
  BitN = BitN & 1;

  if (BitN == 1)
    RxInvLarge = 1;
  else
    RxInvLarge = 0;

  AM = *RyInv;
  AE = *RyExp;
  BM = classify_radius_gyr_max_man;
  BE = classify_radius_gyr_max_exp;
  LastCarry = 1;
  while ((AM != 0) || (BM != 0)) {
    if (AE > BE) {
      BitN = LastCarry + (AM & 1) + 1;
      AM >>= 1;
      AE--;
    }
    else if (AE < BE) {
      BitN = LastCarry + (!(BM & 1));
      BM >>= 1;
      BE--;
    }
    else {                       /* AE == BE */
      BitN = LastCarry + (AM & 1) + (!(BM & 1));
      AM >>= 1;
      BM >>= 1;
      AE--;
      BE--;
    }
    LastCarry = (BitN & 2) > 1;
    BitN = BitN & 1;
  }
  BitN = LastCarry + 1;
  LastCarry = (BitN & 2) > 1;
  BitN = BitN & 1;

  if (BitN == 1)
    RyInvSmall = 1;
  else
    RyInvSmall = 0;

  if (RxInvLarge && RyInvSmall) {
    *RyInv = classify_radius_gyr_max_man;
    *RyExp = classify_radius_gyr_max_exp;
  }

}
/////////////////////////////////////////////////////////////////intfx////////////////////////////////////////

/////////////////////////////////////////////////////////////////speckle////////////////////////////////////////
/*-----------------------------------------------------------------------------
        Global Data Definitions and Declarations
-----------------------------------------------------------------------------*/
/** define control knobs for adjusting definition of speckle*/
double_VAR(speckle_large_max_size, 0.30, "Max large speckle size");

double_VAR(speckle_small_penalty, 10.0, "Small speckle penalty");

double_VAR(speckle_large_penalty, 10.0, "Large speckle penalty");

double_VAR(speckle_small_certainty, -1.0, "Small speckle certainty");

/*-----------------------------------------------------------------------------
              Public Code
-----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/**
 * This routine adds a null choice to Choices with a
 * rating equal to the worst rating in Choices plus a pad.
 * The certainty of the new choice is the same as the
 * certainty of the worst choice in Choices.  The new choice
 * is added to the end of Choices.
 *
 * Globals:
 * - #speckle_small_penalty rating for a small speckle
 * - #speckle_large_penalty rating penalty for a large speckle
 * - #speckle_small_certainty certainty for a small speckle
 *
 * @param Choices choices to add a speckle choice to
 *
 * @return New Choices list with null choice added to end.
 *
 * Exceptions: none
 * History: Mon Mar 11 11:08:11 1991, DSJ, Created.
 */
void AddLargeSpeckleTo(BLOB_CHOICE_LIST *Choices) {
  assert(Choices != NULL);
  BLOB_CHOICE *blob_choice;
  BLOB_CHOICE_IT temp_it;
  temp_it.set_to_list(Choices);

  // If there are no other choices, use the small speckle penalty plus
  // the large speckle penalty.
  if (Choices->length() == 0) {
    blob_choice =
      new BLOB_CHOICE(0, speckle_small_certainty + speckle_large_penalty,
                      speckle_small_certainty, -1, 0);
    temp_it.add_to_end(blob_choice);
    return;
  }

  // If there are other choices,  add a null choice that is slightly worse
  // than the worst choice so far.
  temp_it.move_to_last();
  blob_choice = temp_it.data();  // pick the worst choice
  temp_it.add_to_end(
      new BLOB_CHOICE(0, blob_choice->rating() + speckle_large_penalty,
                      blob_choice->certainty(), -1, 0));
}                                /* AddLargeSpeckleTo */


/*---------------------------------------------------------------------------*/
/**
 * This routine returns TRUE if both the width of height
 * of Blob are less than the MaxLargeSpeckleSize.
 *
 * Globals:
 * - #speckle_large_max_size largest allowed speckle
 *
 * Exceptions: none
 * History: Mon Mar 11 10:06:49 1991, DSJ, Created.
 *
 * @param Blob blob to test against speckle criteria
 * @param Row text row that blob is in
 *
 * @return TRUE if Blob is speckle, FALSE otherwise.
 */
BOOL8 LargeSpeckle(TBLOB *Blob, TEXTROW *Row) {
  double speckle_size;
  TPOINT TopLeft;
  TPOINT BottomRight;

  speckle_size = RowHeight (Row) * speckle_large_max_size;
  blob_bounding_box(Blob, &TopLeft, &BottomRight);

  if (TopLeft.y - BottomRight.y < speckle_size &&
    BottomRight.x - TopLeft.x < speckle_size)
    return (TRUE);
  else
    return (FALSE);

}                                /* LargeSpeckle */
/////////////////////////////////////////////////////////////////speckle////////////////////////////////////////

/////////////////////////////////////////////////////////////////outfeat////////////////////////////////////////
/**----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
FEATURE_SET ExtractOutlineFeatures(TBLOB *Blob, LINE_STATS *LineStats) {
/*
 **	Parameters:
 **		Blob		blob to extract pico-features from
 **		LineStats	statistics on text row blob is in
 **	Globals: none
 **	Operation: Convert each segment in the outline to a feature
 **		and return the features.
 **	Return: Outline-features for Blob.
 **	Exceptions: none
 **	History: 11/13/90, DSJ, Created.
 **		05/24/91, DSJ, Updated for either char or baseline normalize.
 */
  LIST Outlines;
  LIST RemainingOutlines;
  MFOUTLINE Outline;
  FEATURE_SET FeatureSet;
  FLOAT32 XScale, YScale;

  FeatureSet = NewFeatureSet (MAX_OUTLINE_FEATURES);
  if (Blob == NULL)
    return (FeatureSet);

  Outlines = ConvertBlob (Blob);

  NormalizeOutlines(Outlines, LineStats, &XScale, &YScale);
  RemainingOutlines = Outlines;
  iterate(RemainingOutlines) {
    Outline = (MFOUTLINE) first_node (RemainingOutlines);
    ConvertToOutlineFeatures(Outline, FeatureSet);
  }
  if (classify_norm_method == baseline)
    NormalizeOutlineX(FeatureSet);
  FreeOutlines(Outlines);
  return (FeatureSet);
}                                /* ExtractOutlineFeatures */

/**----------------------------------------------------------------------------
              Private Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
void AddOutlineFeatureToSet(FPOINT *Start,
                            FPOINT *End,
                            FEATURE_SET FeatureSet) {
/*
 **	Parameters:
 **		Start		starting point of outline-feature
 **		End		ending point of outline-feature
 **		FeatureSet	set to add outline-feature to
 **	Globals: none
 **	Operation: This routine computes the midpoint between Start and
 **		End to obtain the x,y position of the outline-feature.  It
 **		also computes the direction from Start to End as the
 **		direction of the outline-feature and the distance from
 **		Start to End as the length of the outline-feature.
 **		This feature is then
 **		inserted into the next feature slot in FeatureSet.
 **	Return: none (results are placed in FeatureSet)
 **	Exceptions: none
 **	History: 11/13/90, DSJ, Created.
 */
  FEATURE Feature;

  Feature = NewFeature(&OutlineFeatDesc);
  Feature->Params[OutlineFeatDir] = NormalizedAngleFrom(Start, End, 1.0);
  Feature->Params[OutlineFeatX] = AverageOf(Start->x, End->x);
  Feature->Params[OutlineFeatY] = AverageOf(Start->y, End->y);
  Feature->Params[OutlineFeatLength] = DistanceBetween(*Start, *End);
  AddFeature(FeatureSet, Feature);

}                                /* AddOutlineFeatureToSet */


/*---------------------------------------------------------------------------*/
void ConvertToOutlineFeatures(MFOUTLINE Outline, FEATURE_SET FeatureSet) {
/*
 **	Parameters:
 **		Outline		outline to extract outline-features from
 **		FeatureSet	set of features to add outline-features to
 **	Globals: none
 **	Operation:
 **		This routine steps converts each section in the specified
 **		outline to a feature described by its x,y position, length
 **		and angle.
 **	Return: none (results are returned in FeatureSet)
 **	Exceptions: none
 **	History: 11/13/90, DSJ, Created.
 **			5/24/91, DSJ, Added hidden edge capability.
 */
  MFOUTLINE Next;
  MFOUTLINE First;
  FPOINT FeatureStart;
  FPOINT FeatureEnd;

  if (DegenerateOutline (Outline))
    return;

  First = Outline;
  Next = First;
  do {
    FeatureStart = PointAt(Next)->Point;
    Next = NextPointAfter(Next);

    /* note that an edge is hidden if the ending point of the edge is
       marked as hidden.  This situation happens because the order of
       the outlines is reversed when they are converted from the old
       format.  In the old format, a hidden edge is marked by the
       starting point for that edge. */
    if (!PointAt(Next)->Hidden) {
      FeatureEnd = PointAt(Next)->Point;
      AddOutlineFeatureToSet(&FeatureStart, &FeatureEnd, FeatureSet);
    }
  }
  while (Next != First);
}                                /* ConvertToOutlineFeatures */


/*---------------------------------------------------------------------------*/
void NormalizeOutlineX(FEATURE_SET FeatureSet) {
/*
 **	Parameters:
 **		FeatureSet	outline-features to be normalized
 **	Globals: none
 **	Operation: This routine computes the weighted average x position
 **		over all of the outline-features in FeatureSet and then
 **		renormalizes the outline-features to force this average
 **		to be the x origin (i.e. x=0).
 **	Return: none (FeatureSet is changed)
 **	Exceptions: none
 **	History: 11/13/90, DSJ, Created.
 */
  int i;
  FEATURE Feature;
  FLOAT32 Length;
  FLOAT32 TotalX = 0.0;
  FLOAT32 TotalWeight = 0.0;
  FLOAT32 Origin;

  if (FeatureSet->NumFeatures <= 0)
    return;

  for (i = 0; i < FeatureSet->NumFeatures; i++) {
    Feature = FeatureSet->Features[i];
    Length = Feature->Params[OutlineFeatLength];
    TotalX += Feature->Params[OutlineFeatX] * Length;
    TotalWeight += Length;
  }
  Origin = TotalX / TotalWeight;

  for (i = 0; i < FeatureSet->NumFeatures; i++) {
    Feature = FeatureSet->Features[i];
    Feature->Params[OutlineFeatX] -= Origin;
  }
}                                /* NormalizeOutlineX */
/////////////////////////////////////////////////////////////////outfeat////////////////////////////////////////

/////////////////////////////////////////////////////////////////normmatch////////////////////////////////////////
struct NORM_PROTOS
{
  int NumParams;
  PARAM_DESC *ParamDesc;
  LIST* Protos;
  int NumProtos;
};

/**----------------------------------------------------------------------------
          Private Function Prototypes
----------------------------------------------------------------------------**/
FLOAT32 NormEvidenceOf(register FLOAT32 NormAdj);

void PrintNormMatch(FILE *File,
                    int NumParams,
                    PROTOTYPE *Proto,
                    FEATURE Feature);

NORM_PROTOS *ReadNormProtos(FILE *File);

/**----------------------------------------------------------------------------
        Variables
----------------------------------------------------------------------------**/

/* control knobs used to control the normalization adjustment process */
double_VAR(classify_norm_adj_midpoint, 32.0, "Norm adjust midpoint ...");
double_VAR(classify_norm_adj_curl, 2.0, "Norm adjust curl ...");

/**----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
FLOAT32 Classify::ComputeNormMatch(CLASS_ID ClassId, FEATURE Feature,
                                   BOOL8 DebugMatch) {
/*
 **	Parameters:
 **		ClassId		id of class to match against
 **		Feature		character normalization feature
 **		DebugMatch	controls dump of debug info
 **	Globals:
 **		NormProtos	character normalization prototypes
 **	Operation: This routine compares Features against each character
 **		normalization proto for ClassId and returns the match
 **		rating of the best match.
 **	Return: Best match rating for Feature against protos of ClassId.
 **	Exceptions: none
 **	History: Wed Dec 19 16:56:12 1990, DSJ, Created.
 */
  LIST Protos;
  FLOAT32 BestMatch;
  FLOAT32 Match;
  FLOAT32 Delta;
  PROTOTYPE *Proto;
  int ProtoId;

  /* handle requests for classification as noise */
  if (ClassId == NO_CLASS) {
    /* kludge - clean up constants and make into control knobs later */
    Match = (Feature->Params[CharNormLength] *
      Feature->Params[CharNormLength] * 500.0 +
      Feature->Params[CharNormRx] *
      Feature->Params[CharNormRx] * 8000.0 +
      Feature->Params[CharNormRy] *
      Feature->Params[CharNormRy] * 8000.0);
    return (1.0 - NormEvidenceOf (Match));
  }

  BestMatch = MAX_FLOAT32;
  Protos = NormProtos->Protos[ClassId];

  if (DebugMatch) {
    cprintf ("\nFeature = ");
    WriteFeature(stdout, Feature);
  }

  ProtoId = 0;
  iterate(Protos) {
    Proto = (PROTOTYPE *) first_node (Protos);
    Delta = Feature->Params[CharNormY] - Proto->Mean[CharNormY];
    Match = Delta * Delta * Proto->Weight.Elliptical[CharNormY];
    Delta = Feature->Params[CharNormRx] - Proto->Mean[CharNormRx];
    Match += Delta * Delta * Proto->Weight.Elliptical[CharNormRx];

    if (Match < BestMatch)
      BestMatch = Match;

    if (DebugMatch) {
      cprintf ("Proto %1d = ", ProtoId);
      WriteNFloats (stdout, NormProtos->NumParams, Proto->Mean);
      cprintf ("      var = ");
      WriteNFloats (stdout, NormProtos->NumParams,
        Proto->Variance.Elliptical);
      cprintf ("    match = ");
      PrintNormMatch (stdout, NormProtos->NumParams, Proto, Feature);
    }
    ProtoId++;
  }
  return (1.0 - NormEvidenceOf (BestMatch));
}                                /* ComputeNormMatch */

void Classify::FreeNormProtos() {
  if (NormProtos != NULL) {
    for (int i = 0; i < NormProtos->NumProtos; i++)
      FreeProtoList(&NormProtos->Protos[i]);
    Efree(NormProtos->Protos);
    Efree(NormProtos->ParamDesc);
    Efree(NormProtos);
    NormProtos = NULL;
  }
}

/**----------------------------------------------------------------------------
              Private Code
----------------------------------------------------------------------------**/
/**********************************************************************
 * NormEvidenceOf
 *
 * Return the new type of evidence number corresponding to this
 * normalization adjustment.  The equation that represents the transform is:
 *       1 / (1 + (NormAdj / midpoint) ^ curl)
 **********************************************************************/
FLOAT32 NormEvidenceOf(register FLOAT32 NormAdj) {
  NormAdj /= classify_norm_adj_midpoint;

  if (classify_norm_adj_curl == 3)
    NormAdj = NormAdj * NormAdj * NormAdj;
  else if (classify_norm_adj_curl == 2)
    NormAdj = NormAdj * NormAdj;
  else
    NormAdj = pow(static_cast<double>(NormAdj), classify_norm_adj_curl);
  return (1.0 / (1.0 + NormAdj));
}


/*---------------------------------------------------------------------------*/
void PrintNormMatch(FILE *File,
                    int NumParams,
                    PROTOTYPE *Proto,
                    FEATURE Feature) {
/*
 **	Parameters:
 **		File		open text file to dump match debug info to
 **		NumParams	# of parameters in proto and feature
 **		Proto[]		array of prototype parameters
 **		Feature[]	array of feature parameters
 **	Globals: none
 **	Operation: This routine dumps out detailed normalization match info.
 **	Return: none
 **	Exceptions: none
 **	History: Wed Jan  2 09:49:35 1991, DSJ, Created.
 */
  int i;
  FLOAT32 ParamMatch;
  FLOAT32 TotalMatch;

  for (i = 0, TotalMatch = 0.0; i < NumParams; i++) {
    ParamMatch = (Feature->Params[i] - Mean(Proto, i)) /
      StandardDeviation(Proto, i);

    fprintf (File, " %6.1f", ParamMatch);

    if (i == CharNormY || i == CharNormRx)
      TotalMatch += ParamMatch * ParamMatch;
  }
  fprintf (File, " --> %6.1f (%4.2f)\n",
    TotalMatch, NormEvidenceOf (TotalMatch));

}                                /* PrintNormMatch */


/*---------------------------------------------------------------------------*/
NORM_PROTOS *Classify::ReadNormProtos(FILE *File, inT64 end_offset) {
/*
 **	Parameters:
 **		File	open text file to read normalization protos from
 **	Globals: none
 **	Operation: This routine allocates a new data structure to hold
 **		a set of character normalization protos.  It then fills in
 **		the data structure by reading from the specified File.
 **	Return: Character normalization protos.
 **	Exceptions: none
 **	History: Wed Dec 19 16:38:49 1990, DSJ, Created.
 */
  NORM_PROTOS *NormProtos;
  int i;
  char unichar[UNICHAR_LEN + 1];
  UNICHAR_ID unichar_id;
  LIST Protos;
  int NumProtos;

  /* allocate and initialization data structure */
  NormProtos = (NORM_PROTOS *) Emalloc (sizeof (NORM_PROTOS));
  NormProtos->NumProtos = unicharset.size();
  NormProtos->Protos = (LIST *) Emalloc (NormProtos->NumProtos * sizeof(LIST));
  for (i = 0; i < NormProtos->NumProtos; i++)
    NormProtos->Protos[i] = NIL;

  /* read file header and save in data structure */
  NormProtos->NumParams = ReadSampleSize (File);
  NormProtos->ParamDesc = ReadParamDesc (File, NormProtos->NumParams);

  /* read protos for each class into a separate list */
  while ((end_offset < 0 || ftell(File) < end_offset) &&
         fscanf(File, "%s %d", unichar, &NumProtos) == 2) {
    if (unicharset.contains_unichar(unichar)) {
      unichar_id = unicharset.unichar_to_id(unichar);
      Protos = NormProtos->Protos[unichar_id];
      for (i = 0; i < NumProtos; i++)
        Protos =
            push_last (Protos, ReadPrototype (File, NormProtos->NumParams));
      NormProtos->Protos[unichar_id] = Protos;
    } else
      cprintf("Error: unichar %s in normproto file is not in unichar set.\n");
    SkipNewline(File);
  }
  return (NormProtos);
}                                /* ReadNormProtos */
/////////////////////////////////////////////////////////////////normmatch////////////////////////////////////////

/////////////////////////////////////////////////////////////////float2int////////////////////////////////////////
#define MAX_INT_CHAR_NORM (INT_CHAR_NORM_RANGE - 1)

/*-----------------------------------------------------------------------------
              Public Code
-----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/**
 * For each class in Templates, clear the corresponding
 * entry in CharNormArray.  CharNormArray is indexed by class
 * indicies (as obtained from Templates) rather than class id's.
 *
 * Globals:
 * - none
 *
 * @param Templates specifies classes currently defined
 * @param CharNormArray array to be cleared
 *
 * @note Exceptions: none
 * @note History: Wed Feb 20 11:20:54 1991, DSJ, Created.
 */
void ClearCharNormArray(INT_TEMPLATES Templates,
                        CLASS_NORMALIZATION_ARRAY CharNormArray) {
  int i;

  for (i = 0; i < Templates->NumClasses; i++) {
    CharNormArray[i] = 0;
  }

}                                /* ClearCharNormArray */


/*---------------------------------------------------------------------------*/
/**
 * For each class in Templates, compute the match between
 * NormFeature and the normalization protos for that class.
 * Convert this number to the range from 0 - 255 and store it
 * into CharNormArray.  CharNormArray is indexed by class
 * indicies (as obtained from Templates) rather than class id's.
 *
 * Globals:
 * - none
 *
 * @param NormFeature character normalization feature
 * @param Templates specifies classes currently defined
 * @param[out] CharNormArray place to put results
 *
 * @note Exceptions: none
 * @note History: Wed Feb 20 11:20:54 1991, DSJ, Created.
 */
void Classify::ComputeIntCharNormArray(
  FEATURE NormFeature, INT_TEMPLATES Templates,
  CLASS_NORMALIZATION_ARRAY CharNormArray) {
  int i;
  int NormAdjust;

  for (i = 0; i < Templates->NumClasses; i++) {
    NormAdjust = (int) (INT_CHAR_NORM_RANGE *
      ComputeNormMatch (i, NormFeature, FALSE));
    if (NormAdjust < 0)
      NormAdjust = 0;
    else if (NormAdjust > MAX_INT_CHAR_NORM)
      NormAdjust = MAX_INT_CHAR_NORM;

    CharNormArray[i] = NormAdjust;
  }
}                                /* ComputeIntCharNormArray */

/*---------------------------------------------------------------------------*/
/**
 * This routine converts each floating point pico-feature
 * in Features into integer format and saves it into
 * IntFeatures.
 *
 * Globals:
 * - none
 *
 * @param Features floating point pico-features to be converted
 * @param[out] IntFeatures array to put converted features into
 *
 * @note Exceptions: none
 * @note History: Wed Feb 20 10:58:45 1991, DSJ, Created.
 */
void ComputeIntFeatures(FEATURE_SET Features, INT_FEATURE_ARRAY IntFeatures) {
  int Fid;
  FEATURE Feature;
  FLOAT32 YShift;

  if (classify_norm_method == baseline)
    YShift = BASELINE_Y_SHIFT;
  else
    YShift = Y_SHIFT;

  for (Fid = 0; Fid < Features->NumFeatures; Fid++) {
    Feature = Features->Features[Fid];

    IntFeatures[Fid].X = BucketFor (Feature->Params[PicoFeatX],
      X_SHIFT, INT_FEAT_RANGE);
    IntFeatures[Fid].Y = BucketFor (Feature->Params[PicoFeatY],
      YShift, INT_FEAT_RANGE);
    IntFeatures[Fid].Theta = CircBucketFor (Feature->Params[PicoFeatDir],
      ANGLE_SHIFT, INT_FEAT_RANGE);
    IntFeatures[Fid].CP_misses = 0;
  }
}                                /* ComputeIntFeatures */
/////////////////////////////////////////////////////////////////float2int////////////////////////////////////////

/////////////////////////////////////////////////////////////////normfeat////////////////////////////////////////
/**----------------------------------------------------------------------------
        Global Data Definitions and Declarations
----------------------------------------------------------------------------**/
/**----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
FLOAT32 ActualOutlineLength(FEATURE Feature) {
/*
 **	Parameters:
 **		Feature		normalization feature
 **	Globals: none
 **	Operation: This routine returns the length that the outline
 **		would have been if it were baseline normalized instead
 **		of character normalized.
 **	Return: Baseline normalized length of outline.
 **	Exceptions: none
 **	History: Thu Dec 20 14:50:57 1990, DSJ, Created.
 */
  return (Feature->Params[CharNormLength] * LENGTH_COMPRESSION);

}                                /* ActualOutlineLength */


/*---------------------------------------------------------------------------*/
FEATURE_SET ExtractCharNormFeatures(TBLOB *Blob, LINE_STATS *LineStats) {
/*
 **	Parameters:
 **		Blob		blob to extract char norm feature from
 **		LineStats	statistics on text row blob is in
 **	Globals: none
 **	Operation: Compute a feature whose parameters describe how a
 **		character will be affected by the character normalization
 **		algorithm.  The feature parameters are:
 **			y position of center of mass in baseline coordinates
 **			total length of outlines in baseline coordinates
 **				divided by a scale factor
 **			radii of gyration about the center of mass in
 **				baseline coordinates
 **	Return: Character normalization feature for Blob.
 **	Exceptions: none
 **	History: Wed May 23 18:06:38 1990, DSJ, Created.
 */
  FEATURE_SET FeatureSet;
  FEATURE Feature;
  FLOAT32 Scale;
  FLOAT32 Baseline;
  LIST Outlines;
  INT_FEATURE_ARRAY blfeatures;
  INT_FEATURE_ARRAY cnfeatures;
  INT_FX_RESULT_STRUCT FXInfo;

  /* allocate the feature and feature set - note that there is always one
     and only one char normalization feature for any blob */
  FeatureSet = NewFeatureSet (1);
  Feature = NewFeature (&CharNormDesc);
  AddFeature(FeatureSet, Feature);

  /* compute the normalization statistics for this blob */
  Outlines = ConvertBlob (Blob);
#ifdef DEBUG_NORMFEAT
  FILE* OFile;
  OFile = fopen ("nfOutline.logCPP", "r");
  if (OFile == NULL)
  {
    OFile = Efopen ("nfOutline.logCPP", "w");
    WriteOutlines(OFile, Outlines);
  }
  else
  {
    fclose (OFile);
    OFile = Efopen ("nfOutline.logCPP", "a");
  }
  WriteOutlines(OFile, Outlines);
  fclose (OFile);
#endif

  ExtractIntFeat(Blob, blfeatures, cnfeatures, &FXInfo);
  Baseline = BaselineAt (LineStats, FXInfo.Xmean);
  Scale = ComputeScaleFactor (LineStats);
  Feature->Params[CharNormY] = (FXInfo.Ymean - Baseline) * Scale;
  Feature->Params[CharNormLength] =
    FXInfo.Length * Scale / LENGTH_COMPRESSION;
  Feature->Params[CharNormRx] = FXInfo.Rx * Scale;
  Feature->Params[CharNormRy] = FXInfo.Ry * Scale;

#ifdef DEBUG_NORMFEAT
  FILE* File;
  File = fopen ("nfFeatSet.logCPP", "r");
  if (File == NULL)
  {
    File = Efopen ("nfFeatSet.logCPP", "w");
    WriteFeatureSet(File, FeatureSet);
  }
  else
  {
    fclose (File);
    File = Efopen ("nfFeatSet.logCPP", "a");
  }
  WriteFeatureSet(File, FeatureSet);
  fclose (File);
#endif
  FreeOutlines(Outlines);
  return (FeatureSet);
}                                /* ExtractCharNormFeatures */
/////////////////////////////////////////////////////////////////normfeat////////////////////////////////////////

/////////////////////////////////////////////////////////////////classify////////////////////////////////////////

#define REALLY_QUOTE_IT(x) QUOTE_IT(x)

#define MAX_CUTOFF      1000

/**----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
void Classify::ReadNewCutoffs(FILE *CutoffFile, inT64 end_offset,
                              CLASS_CUTOFF_ARRAY Cutoffs) {
/*
 **	Parameters:
 **		Filename	name of file containing cutoff definitions
 **		Cutoffs		array to put cutoffs into
 **	Globals: none
 **	Operation: Open Filename, read in all of the class-id/cutoff pairs
 **		and insert them into the Cutoffs array.  Cutoffs are
 **		indexed in the array by class id.  Unused entries in the
 **		array are set to an arbitrarily high cutoff value.
 **	Return: none
 **	Exceptions: none
 **	History: Wed Feb 20 09:38:26 1991, DSJ, Created.
 */
  char Class[UNICHAR_LEN + 1];
  CLASS_ID ClassId;
  int Cutoff;
  int i;

  for (i = 0; i < MAX_NUM_CLASSES; i++)
    Cutoffs[i] = MAX_CUTOFF;

  while ((end_offset < 0 || ftell(CutoffFile) < end_offset) &&
         fscanf(CutoffFile, "%" REALLY_QUOTE_IT(UNICHAR_LEN) "s %d",
                Class, &Cutoff) == 2) {
    if (strcmp(Class, "NULL") == 0) {
      ClassId = unicharset.unichar_to_id(" ");
    } else {
      ClassId = unicharset.unichar_to_id(Class);
    }
    Cutoffs[ClassId] = Cutoff;
    SkipNewline(CutoffFile);
  }
}                                /* ReadNewCutoffs */
/////////////////////////////////////////////////////////////////classify////////////////////////////////////////

/////////////////////////////////////////////////////////////////adaptmatch////////////////////////////////////////
#define ADAPT_TEMPLATE_SUFFIX ".a"

#define MAX_MATCHES         10
#define UNLIKELY_NUM_FEAT 200
#define NO_DEBUG      0
#define MAX_ADAPTABLE_WERD_SIZE 40

#define ADAPTABLE_WERD    (GOOD_WERD + 0.05)

#define Y_DIM_OFFSET (Y_SHIFT - BASELINE_Y_SHIFT)

#define WORST_POSSIBLE_RATING (1.0)

struct ADAPT_RESULTS
{
    inT32 BlobLength;
    int NumMatches;
    bool HasNonfragment;
    CLASS_ID Classes[MAX_NUM_CLASSES];
    FLOAT32 Ratings[MAX_CLASS_ID + 1];
    uinT8 Configs[MAX_CLASS_ID + 1];
    FLOAT32 BestRating;
    CLASS_ID BestClass;
    uinT8 BestConfig;
    CLASS_PRUNER_RESULTS CPResults;

    /// Initializes data members to the default values. Sets the initial
    /// rating of each class to be the worst possible rating (1.0).
    inline void Initialize()
    {
        BlobLength = MAX_INT32;
        NumMatches = 0;
        HasNonfragment = false;
        BestRating = WORST_POSSIBLE_RATING;
        BestClass = NO_CLASS;
        BestConfig = 0;

        for (int i = 0; i <= MAX_CLASS_ID; ++i)
        {
            Ratings[i] = WORST_POSSIBLE_RATING;
        }
    }
};



typedef struct
{
    ADAPT_TEMPLATES Templates;
    CLASS_ID ClassId;
    int ConfigId;
}PROTO_KEY;

/*-----------------------------------------------------------------------------
          Private Macros
-----------------------------------------------------------------------------*/
#define MarginalMatch(Rating)       \
    ((Rating) > matcher_great_threshold)

#define TempConfigReliable(Config)  \
    ((Config)->NumTimesSeen >= matcher_min_examples_for_prototyping)

#define InitIntFX() (FeaturesHaveBeenExtracted = FALSE)

/*-----------------------------------------------------------------------------
          Private Function Prototypes
-----------------------------------------------------------------------------*/
void AdaptToChar(TBLOB *Blob, LINE_STATS *LineStats, CLASS_ID ClassId, FLOAT32 Threshold);

void AdaptToPunc(TBLOB *Blob, LINE_STATS *LineStats, CLASS_ID ClassId, FLOAT32 Threshold);

void AmbigClassifier(TBLOB *Blob, LINE_STATS *LineStats, INT_TEMPLATES Templates, UNICHAR_ID *Ambiguities, ADAPT_RESULTS *Results);

UNICHAR_ID *BaselineClassifier(TBLOB *Blob, LINE_STATS *LineStats, ADAPT_TEMPLATES Templates, ADAPT_RESULTS *Results);

void make_config_pruner(INT_TEMPLATES templates, CONFIG_PRUNER *config_pruner);

void CharNormClassifier(TBLOB *Blob, LINE_STATS *LineStats, INT_TEMPLATES Templates, ADAPT_RESULTS *Results);

void ClassifyAsNoise(ADAPT_RESULTS *Results);

int CompareCurrentRatings(const void *arg1, const void *arg2);

void ConvertMatchesToChoices(ADAPT_RESULTS *Results, BLOB_CHOICE_LIST *Choices);

void DebugAdaptiveClassifier(TBLOB *Blob, LINE_STATS *LineStats, ADAPT_RESULTS *Results);

void DoAdaptiveMatch(TBLOB *Blob, LINE_STATS *LineStats, ADAPT_RESULTS *Results);

void GetAdaptThresholds(TWERD * Word,
                        LINE_STATS * LineStats,
                        const WERD_CHOICE& BestChoice,
                        const WERD_CHOICE& BestRawChoice, FLOAT32 Thresholds[]);

UNICHAR_ID *GetAmbiguities(TBLOB *Blob, LINE_STATS *LineStats, CLASS_ID CorrectClass);

int GetBaselineFeatures(TBLOB *Blob, LINE_STATS *LineStats, INT_TEMPLATES Templates,
                        INT_FEATURE_ARRAY IntFeatures, CLASS_NORMALIZATION_ARRAY CharNormArray, inT32 *BlobLength);


int GetIntBaselineFeatures(TBLOB *Blob, LINE_STATS *LineStats, INT_TEMPLATES Templates,
                           INT_FEATURE_ARRAY IntFeatures, CLASS_NORMALIZATION_ARRAY CharNormArray, inT32 *BlobLength);

void InitMatcherRatings(register FLOAT32 *Rating);

PROTO_ID MakeNewTempProtos(FEATURE_SET Features,
                           int NumBadFeat,
                           FEATURE_ID BadFeat[],
                           INT_CLASS IClass,
                           ADAPT_CLASS Class, BIT_VECTOR TempProtoMask);

void MakePermanent(ADAPT_TEMPLATES Templates, CLASS_ID ClassId, int ConfigId, TBLOB *Blob, LINE_STATS *LineStats);

int MakeTempProtoPerm(void *item1, void *item2);

int NumBlobsIn(TWERD *Word);

int NumOutlinesInBlob(TBLOB *Blob);

void PrintAdaptiveMatchResults(FILE *File, ADAPT_RESULTS *Results);

void RemoveBadMatches(ADAPT_RESULTS *Results);

void RemoveExtraPuncs(ADAPT_RESULTS *Results);

void SetAdaptiveThreshold(FLOAT32 Threshold);
void ShowBestMatchFor(TBLOB *Blob, LINE_STATS *LineStats, CLASS_ID ClassId, BOOL8 AdaptiveOn, BOOL8 PreTrainedOn);


/*-----------------------------------------------------------------------------
        Global Data Definitions and Declarations
-----------------------------------------------------------------------------*/
/* variables used to hold performance statistics */
static int AdaptiveMatcherCalls = 0;
static int BaselineClassifierCalls = 0;
static int CharNormClassifierCalls = 0;
static int AmbigClassifierCalls = 0;
static int NumWordsAdaptedTo = 0;
static int NumCharsAdaptedTo = 0;
static int NumBaselineClassesTried = 0;
static int NumCharNormClassesTried = 0;
static int NumAmbigClassesTried = 0;
static int NumClassesOutput = 0;
static int NumAdaptationsFailed = 0;

/* define globals used to hold onto extracted features.  This is used
to map from the old scheme in which baseline features and char norm
features are extracted separately, to the new scheme in which they
are extracted at the same time. */
static BOOL8 FeaturesHaveBeenExtracted = FALSE;
static BOOL8 FeaturesOK = TRUE;
static INT_FEATURE_ARRAY BaselineFeatures;
static INT_FEATURE_ARRAY CharNormFeatures;
static INT_FX_RESULT_STRUCT FXInfo;

/** use a global variable to hold onto the current ratings so that the
comparison function passes to qsort can get at them */
static FLOAT32 *CurrentRatings;

/* define globals to hold filename of training data */
static CLASS_CUTOFF_ARRAY CharNormCutoffs;
static CLASS_CUTOFF_ARRAY BaselineCutoffs;

/* define control knobs for adaptive matcher */
BOOL_VAR(classify_enable_adaptive_matcher, 1, "Enable adaptive classifier");

BOOL_VAR(classify_use_pre_adapted_templates, 0,
         "Use pre-adapted classifier templates");

BOOL_VAR(classify_save_adapted_templates, 0,
         "Save adapted templates to a file");

BOOL_VAR(classify_enable_adaptive_debugger, 0, "Enable match debugger");

INT_VAR(matcher_debug_level, 0, "Matcher Debug Level");
INT_VAR(matcher_debug_flags, 0, "Matcher Debug Flags");

INT_VAR(classify_learning_debug_level, 0, "Learning Debug Level: ");

double_VAR(matcher_good_threshold, 0.125, "Good Match (0-1)");
double_VAR(matcher_great_threshold, 0.0, "Great Match (0-1)");

double_VAR(matcher_perfect_threshold, 0.02, "Perfect Match (0-1)");
double_VAR(matcher_bad_match_pad, 0.15, "Bad Match Pad (0-1)");
double_VAR(matcher_rating_margin, 0.1, "New template margin (0-1)");
double_VAR(matcher_avg_noise_size, 12.0, "Avg. noise blob length: ");

INT_VAR(matcher_permanent_classes_min, 1, "Min # of permanent classes");

INT_VAR(matcher_min_examples_for_prototyping, 3, "Reliable Config Threshold");

double_VAR(matcher_clustering_max_angle_delta, 0.015,
           "Maximum angle delta for prototype clustering");

BOOL_VAR(classify_enable_int_fx, 1, "Enable integer fx");

BOOL_VAR(classify_enable_new_adapt_rules, 1, "Enable new adaptation rules");

double_VAR(rating_scale, 1.5, "Rating scaling factor");
extern double_VAR_H(certainty_scale, 20.0, "Certainty scaling factor");

INT_VAR(matcher_failed_adaptations_before_reset, 150,
        "Number of failed adaptions before adapted templates reset");

double_VAR(tessedit_class_miss_scale, 0.00390625,
           "Scale factor for features not used");

BOOL_VAR(tess_cn_matching, 0, "Character Normalized Matching");
BOOL_VAR(tess_bn_matching, 0, "Baseline Normalized Matching");

/*-----------------------------------------------------------------------------
              Public Code
-----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/**
 * This routine calls the adaptive matcher
 * which returns (in an array) the class id of each
 * class matched.
 *
 * It also returns the number of classes matched.
 * For each class matched it places the best rating
 * found for that class into the Ratings array.
 *
 * Bad matches are then removed so that they don't
 * need to be sorted.  The remaining good matches are
 * then sorted and converted to choices.
 *
 * This routine also performs some simple speckle
 * filtering.
 *
 * @note Exceptions: none
 * @note History: Mon Mar 11 10:00:58 1991, DSJ, Created.
 *
 * @param Blob    blob to be classified
 * @param DotBlob (obsolete)
 * @param Row     row of text that word appears in
 * @param[out] Choices    List of choices found by adaptive matcher.
 * @param[out] CPResults  Array of CPResultStruct of size MAX_NUM_CLASSES is
 * filled on return with the choices found by the
 * class pruner and the ratings therefrom. Also
 * contains the detailed results of the integer matcher.
 *
 * Globals:
 * - CurrentRatings  used by compare function for qsort
 */
void Classify::AdaptiveClassifier(TBLOB *Blob,  TBLOB *DotBlob, TEXTROW *Row, BLOB_CHOICE_LIST *Choices, CLASS_PRUNER_RESULTS CPResults)
{
    Q_UNUSED(DotBlob);
    assert(Choices != NULL);
    ADAPT_RESULTS *Results = new ADAPT_RESULTS();
    LINE_STATS LineStats;

    if (matcher_failed_adaptations_before_reset >= 0 && NumAdaptationsFailed >= matcher_failed_adaptations_before_reset)
    {
        NumAdaptationsFailed = 0;
        ResetAdaptiveClassifier();
    }

    if (AdaptedTemplates == NULL) AdaptedTemplates = NewAdaptedTemplates (true);

    EnterClassifyMode;

    Results->Initialize();
    GetLineStatsFromRow(Row, &LineStats);

    DoAdaptiveMatch(Blob, &LineStats, Results);
    if (CPResults != NULL) memcpy(CPResults, Results->CPResults, sizeof(CPResults[0]) * Results->NumMatches);
    RemoveBadMatches(Results);

    /* save ratings in a global so that CompareCurrentRatings() can see them */
    CurrentRatings = Results->Ratings;
    qsort ((void *) (Results->Classes), Results->NumMatches, sizeof (CLASS_ID), CompareCurrentRatings);

    RemoveExtraPuncs(Results);
    ConvertMatchesToChoices(Results, Choices);

    if (matcher_debug_level >= 1)
    {
        cprintf ("AD Matches =  ");
        PrintAdaptiveMatchResults(stdout, Results);
    }

    if (LargeSpeckle (Blob, Row))  AddLargeSpeckleTo(Choices);

#ifndef GRAPHICS_DISABLED
    if (classify_enable_adaptive_debugger) DebugAdaptiveClassifier(Blob, &LineStats, Results);
#endif

    NumClassesOutput += Choices->length();
    if (Choices->length() == 0)
    {
        if (!bln_numericmode) tprintf ("Empty classification!\n");  // Should never normally happen.
        Choices = new BLOB_CHOICE_LIST();
        BLOB_CHOICE_IT temp_it;
        temp_it.set_to_list(Choices);
        temp_it.add_to_end(new BLOB_CHOICE(0, 50.0f, -20.0f, -1, 0));
    }

    delete Results;
}                                /* AdaptiveClassifier */


/*---------------------------------------------------------------------------*/
/**
 * This routine implements a preliminary
 * version of the rules which are used to decide
 * which characters to adapt to.
 *
 * A word is adapted to if it is in the dictionary or
 * if it is a "good" number (no trailing units, etc.).
 * It cannot contain broken or merged characters.
 *
 * Within that word, only letters and digits are
 * adapted to (no punctuation).
 *
 * @param Word word to be adapted to
 * @param Row row of text that word is found in
 * @param BestChoice best choice for word found by system
 * @param BestRawChoice best choice for word found by classifier only
 * @param rejmap Reject map
 *
 * Globals:
 * - #EnableLearning TRUE if learning is enabled
 *
 * @note Exceptions: none
 * @note History: Thu Mar 14 07:40:36 1991, DSJ, Created.
*/
void Classify::AdaptToWord(TWERD *Word, TEXTROW *Row, const WERD_CHOICE& BestChoice, const WERD_CHOICE& BestRawChoice, const char *rejmap)
{
    TBLOB *Blob;
    LINE_STATS LineStats;
    FLOAT32 Thresholds[MAX_ADAPTABLE_WERD_SIZE];
    FLOAT32 *Threshold;
    const char *map = rejmap;
    char map_char = '1';
    const char* BestChoice_string = BestChoice.unichar_string().string();
    const char* BestChoice_lengths = BestChoice.unichar_lengths().string();

    if (strlen(BestChoice_lengths) > MAX_ADAPTABLE_WERD_SIZE) return;

    if (EnableLearning)
    {
        NumWordsAdaptedTo++;

#ifndef SECURE_NAMES
        if (classify_learning_debug_level >= 1) cprintf ("\n\nAdapting to word = %s\n", BestChoice.debug_string(unicharset).string());
#endif
        GetLineStatsFromRow(Row, &LineStats);

        GetAdaptThresholds(Word, &LineStats, BestChoice, BestRawChoice, Thresholds);

        for (Blob = Word->blobs, Threshold = Thresholds; Blob != NULL; Blob = Blob->next, BestChoice_string += *(BestChoice_lengths++), Threshold++)
        {
            InitIntFX();

            if (rejmap != NULL) map_char = *map++;

            assert (map_char == '1' || map_char == '0');

            if (map_char == '1')
            {

                //        if (unicharset.get_isalpha (BestChoice_string, *BestChoice_lengths) ||
                //            unicharset.get_isdigit (BestChoice_string, *BestChoice_lengths)) {
                /* SPECIAL RULE:  don't adapt to an 'i' which is the first char
             in a word because they are too ambiguous with 'I'.
             The new adaptation rules should account for this
             automatically, since they exclude ambiguous words from
             adaptation, but for safety's sake we'll leave the rule in.
             Also, don't adapt to i's that have only 1 blob in them
             because this creates too much ambiguity for broken
             characters. */
                if (*BestChoice_lengths == 1 && (*BestChoice_string == 'i'
                                                 || (il1_adaption_test && *BestChoice_string == 'I' &&
                                                     (Blob->next == NULL ||
                                                      unicharset.get_islower (BestChoice_string + *BestChoice_lengths,
                                                                              *(BestChoice_lengths + 1)))))
                        && (Blob == Word->blobs
                            || (!(unicharset.get_isalpha (BestChoice_string -
                                                          *(BestChoice_lengths - 1),
                                                          *(BestChoice_lengths - 1)) ||
                                  unicharset.get_isdigit (BestChoice_string -
                                                          *(BestChoice_lengths - 1),
                                                          *(BestChoice_lengths - 1))))

                            || (!il1_adaption_test && NumOutlinesInBlob(Blob) != 2)))
                {
                    if (classify_learning_debug_level >= 1)
                        cprintf ("Rejecting char = %s\n", unicharset.id_to_unichar( unicharset.unichar_to_id(BestChoice_string, *BestChoice_lengths)));
                }
                else
                {
#ifndef SECURE_NAMES
                    if (classify_learning_debug_level >= 1)
                        cprintf ("Adapting to char = %s, thr= %g\n", unicharset.id_to_unichar( unicharset.unichar_to_id(BestChoice_string, *BestChoice_lengths)), *Threshold);
#endif
                    AdaptToChar(Blob, &LineStats, unicharset.unichar_to_id(BestChoice_string, *BestChoice_lengths), *Threshold);
                }
                //        }
                //        else
                //          AdaptToPunc(Blob, &LineStats,
                //                      unicharset.unichar_to_id(BestChoice_string,
                //                                               *BestChoice_lengths),
                //                      *Threshold);
            }
        }
        if (classify_learning_debug_level >= 1) cprintf ("\n");
    }
}                                /* AdaptToWord */


/*---------------------------------------------------------------------------*/
/**
 * This routine performs cleanup operations
 * on the adaptive classifier.  It should be called
 * before the program is terminated.  Its main function
 * is to save the adapted templates to a file.
 *
 * Globals:
 * - #AdaptedTemplates current set of adapted templates
 * - #classify_save_adapted_templates TRUE if templates should be saved
 * - #classify_enable_adaptive_matcher TRUE if adaptive matcher is enabled
 *
 * @note Exceptions: none
 * @note History: Tue Mar 19 14:37:06 1991, DSJ, Created.
 */
void Classify::EndAdaptiveClassifier()
{
    STRING Filename;
    FILE *File;

#ifndef SECURE_NAMES
    if (AdaptedTemplates != NULL && classify_enable_adaptive_matcher && classify_save_adapted_templates)
    {
        Filename = imagefile + ADAPT_TEMPLATE_SUFFIX;
        File = fopen (Filename.string(), "wb");

        if (File == NULL)
            cprintf ("Unable to save adapted templates to %s!\n", Filename.string());
        else
        {
            cprintf ("\nSaving adapted templates to %s ...", Filename.string());
            fflush(stdout);
            WriteAdaptedTemplates(File, AdaptedTemplates);
            cprintf ("\n");
            fclose(File);
        }
    }
#endif

    if (AdaptedTemplates != NULL)
    {
        free_adapted_templates(AdaptedTemplates);
        AdaptedTemplates = NULL;
    }

    if (PreTrainedTemplates != NULL)
    {
        free_int_templates(PreTrainedTemplates);
        PreTrainedTemplates = NULL;
    }

    getDict().EndDangerousAmbigs();
    FreeNormProtos();
    if (AllProtosOn != NULL)
    {
        FreeBitVector(AllProtosOn);
        FreeBitVector(PrunedProtos);
        FreeBitVector(AllConfigsOn);
        FreeBitVector(AllProtosOff);
        FreeBitVector(AllConfigsOff);
        FreeBitVector(TempProtoMask);
        AllProtosOn = NULL;
        PrunedProtos = NULL;
        AllConfigsOn = NULL;
        AllProtosOff = NULL;
        AllConfigsOff = NULL;
        TempProtoMask = NULL;
    }
}                                /* EndAdaptiveClassifier */


/*---------------------------------------------------------------------------*/
/**
 * This routine reads in the training
 * information needed by the adaptive classifier
 * and saves it into global variables.
 *
 * Globals:
 * - BuiltInTemplatesFile file to get built-in temps from
 * - BuiltInCutoffsFile file to get avg. feat per class from
 * - #PreTrainedTemplates pre-trained configs and protos
 * - #AdaptedTemplates templates adapted to current page
 * - CharNormCutoffs avg # of features per class
 * - #AllProtosOn dummy proto mask with all bits 1
 * - #AllConfigsOn dummy config mask with all bits 1
 * - #classify_use_pre_adapted_templates enables use of pre-adapted templates
 *
 * @note Exceptions: none
 * @note History: Mon Mar 11 12:49:34 1991, DSJ, Created.
 */
void Classify::InitAdaptiveClassifier()
{
    if (!classify_enable_adaptive_matcher)
        return;
    if (AllProtosOn != NULL)
        EndAdaptiveClassifier();  // Don't leak with multiple inits.

    // If there is no language_data_path_prefix, the classifier will be
    // adaptive only.
    if (language_data_path_prefix.length() > 0)
    {
        if (!tessdata_manager.SeekToStart(TESSDATA_INTTEMP))
        {
            inttemp_loaded_ = false;
        }
        else
        {
            PreTrainedTemplates = ReadIntTemplates(tessdata_manager.GetDataFilePtr());
            if (global_tessdata_manager_debug_level) tprintf("Loaded inttemp\n");

            ASSERT_HOST(tessdata_manager.SeekToStart(TESSDATA_PFFMTABLE));
            ReadNewCutoffs(tessdata_manager.GetDataFilePtr(), tessdata_manager.GetEndOffset(TESSDATA_PFFMTABLE), CharNormCutoffs);
            if (global_tessdata_manager_debug_level) tprintf("Loaded pffmtable\n");

            ASSERT_HOST(tessdata_manager.SeekToStart(TESSDATA_NORMPROTO));
            NormProtos = ReadNormProtos(tessdata_manager.GetDataFilePtr(), tessdata_manager.GetEndOffset(TESSDATA_NORMPROTO));
            if (global_tessdata_manager_debug_level) tprintf("Loaded normproto\n");

            inttemp_loaded_ = true;
        }
    }

    InitIntegerMatcher();
    InitIntegerFX();

    AllProtosOn = NewBitVector(MAX_NUM_PROTOS);
    PrunedProtos = NewBitVector(MAX_NUM_PROTOS);
    AllConfigsOn = NewBitVector(MAX_NUM_CONFIGS);
    AllProtosOff = NewBitVector(MAX_NUM_PROTOS);
    AllConfigsOff = NewBitVector(MAX_NUM_CONFIGS);
    TempProtoMask = NewBitVector(MAX_NUM_PROTOS);
    set_all_bits(AllProtosOn, WordsInVectorOfSize(MAX_NUM_PROTOS));
    set_all_bits(PrunedProtos, WordsInVectorOfSize(MAX_NUM_PROTOS));
    set_all_bits(AllConfigsOn, WordsInVectorOfSize(MAX_NUM_CONFIGS));
    zero_all_bits(AllProtosOff, WordsInVectorOfSize(MAX_NUM_PROTOS));
    zero_all_bits(AllConfigsOff, WordsInVectorOfSize(MAX_NUM_CONFIGS));

    if (classify_use_pre_adapted_templates)
    {
        FILE *File;
        STRING Filename;

        Filename = imagefile;
        Filename += ADAPT_TEMPLATE_SUFFIX;
        File = fopen(Filename.string(), "rb");
        if (File == NULL)
        {
            AdaptedTemplates = NewAdaptedTemplates(true);
        }
        else
        {
#ifndef SECURE_NAMES
            cprintf("\nReading pre-adapted templates from %s ...\n",
                    Filename.string());
            fflush(stdout);
#endif
            AdaptedTemplates = ReadAdaptedTemplates(File);
            cprintf("\n");
            fclose(File);
            PrintAdaptedTemplates(stdout, AdaptedTemplates);

            for (int i = 0; i < AdaptedTemplates->Templates->NumClasses; i++)
            {
                BaselineCutoffs[i] = CharNormCutoffs[i];
            }
        }
    }
    else
    {
        if (AdaptedTemplates != NULL) free_adapted_templates(AdaptedTemplates);
        AdaptedTemplates = NewAdaptedTemplates(true);
    }
}                                /* InitAdaptiveClassifier */

void Classify::ResetAdaptiveClassifier()
{
    free_adapted_templates(AdaptedTemplates);
    AdaptedTemplates = NULL;
}

/*---------------------------------------------------------------------------*/
/**
 * Print to File the statistics which have
 * been gathered for the adaptive matcher.
 *
 * @param File open text file to print adaptive statistics to
 *
 * Globals: none
 *
 * @note Exceptions: none
 * @note History: Thu Apr 18 14:37:37 1991, DSJ, Created.
 */
void Classify::PrintAdaptiveStatistics(FILE *File)
{
#ifndef SECURE_NAMES

    fprintf (File, "\nADAPTIVE MATCHER STATISTICS:\n");
    fprintf (File, "\tNum blobs classified = %d\n", AdaptiveMatcherCalls);
    fprintf (File, "\tNum classes output   = %d (Avg = %4.2f)\n",
             NumClassesOutput,
             ((AdaptiveMatcherCalls == 0) ? (0.0) :
                                            ((float) NumClassesOutput / AdaptiveMatcherCalls)));
    fprintf (File, "\t\tBaseline Classifier: %4d calls (%4.2f classes/call)\n",
             BaselineClassifierCalls,
             ((BaselineClassifierCalls == 0) ? (0.0) :
                                               ((float) NumBaselineClassesTried / BaselineClassifierCalls)));
    fprintf (File, "\t\tCharNorm Classifier: %4d calls (%4.2f classes/call)\n",
             CharNormClassifierCalls,
             ((CharNormClassifierCalls == 0) ? (0.0) :
                                               ((float) NumCharNormClassesTried / CharNormClassifierCalls)));
    fprintf (File, "\t\tAmbig    Classifier: %4d calls (%4.2f classes/call)\n",
             AmbigClassifierCalls,
             ((AmbigClassifierCalls == 0) ? (0.0) :
                                            ((float) NumAmbigClassesTried / AmbigClassifierCalls)));

    fprintf (File, "\nADAPTIVE LEARNER STATISTICS:\n");
    fprintf (File, "\tNumber of words adapted to: %d\n", NumWordsAdaptedTo);
    fprintf (File, "\tNumber of chars adapted to: %d\n", NumCharsAdaptedTo);

    PrintAdaptedTemplates(File, AdaptedTemplates);
#endif
}                                /* PrintAdaptiveStatistics */


/*---------------------------------------------------------------------------*/
/**
 * This routine prepares the adaptive
 * matcher for the start
 * of the first pass.  Learning is enabled (unless it
 * is disabled for the whole program).
 *
 * @note this is somewhat redundant, it simply says that if learning is
 * enabled then it will remain enabled on the first pass.  If it is
 * disabled, then it will remain disabled.  This is only put here to
 * make it very clear that learning is controlled directly by the global
 * setting of EnableLearning.
 *
 * Globals:
 * - #EnableLearning
 * set to TRUE by this routine
 *
 * @note Exceptions: none
 * @note History: Mon Apr 15 16:39:29 1991, DSJ, Created.
 */
void Classify::SettupPass1()
{
    EnableLearning = classify_enable_learning;

    getDict().SettupStopperPass1();

}                                /* SettupPass1 */


/*---------------------------------------------------------------------------*/
/**
 * This routine prepares the adaptive
 * matcher for the start of the second pass.  Further
 * learning is disabled.
 *
 * Globals:
 * - #EnableLearning set to FALSE by this routine
 *
 * @note Exceptions: none
 * @note History: Mon Apr 15 16:39:29 1991, DSJ, Created.
 */
void Classify::SettupPass2()
{
    EnableLearning = FALSE;
    getDict().SettupStopperPass2();

}                                /* SettupPass2 */


/*---------------------------------------------------------------------------*/
/**
 * This routine creates a new adapted
 * class and uses Blob as the model for the first
 * config in that class.
 *
 * @param Blob blob to model new class after
 * @param LineStats statistics for text row blob is in
 * @param ClassId id of the class to be initialized
 * @param Class adapted class to be initialized
 * @param Templates adapted templates to add new class to
 *
 * Globals:
 * - #AllProtosOn dummy mask with all 1's
 * - BaselineCutoffs kludge needed to get cutoffs
 * - #PreTrainedTemplates kludge needed to get cutoffs
 *
 * @note Exceptions: none
 * @note History: Thu Mar 14 12:49:39 1991, DSJ, Created.
 */
void Classify::InitAdaptedClass(TBLOB *Blob, LINE_STATS *LineStats, CLASS_ID ClassId, ADAPT_CLASS Class, ADAPT_TEMPLATES Templates)
{
    FEATURE_SET Features;
    int Fid, Pid;
    FEATURE Feature;
    int NumFeatures;
    TEMP_PROTO TempProto;
    PROTO Proto;
    INT_CLASS IClass;
    TEMP_CONFIG Config;

    classify_norm_method.set_value(baseline);
    Features = ExtractOutlineFeatures(Blob, LineStats);
    NumFeatures = Features->NumFeatures;
    if (NumFeatures > UNLIKELY_NUM_FEAT || NumFeatures <= 0)
    {
        FreeFeatureSet(Features);
        return;
    }

    Config = NewTempConfig (NumFeatures - 1);
    TempConfigFor (Class, 0) = Config;

    /* this is a kludge to construct cutoffs for adapted templates */
    if (Templates == AdaptedTemplates) BaselineCutoffs[ClassId] = CharNormCutoffs[ClassId];

    IClass = ClassForClassId (Templates->Templates, ClassId);

    for (Fid = 0; Fid < Features->NumFeatures; Fid++)
    {
        Pid = AddIntProto (IClass);
        assert (Pid != NO_PROTO);

        Feature = Features->Features[Fid];
        TempProto = NewTempProto ();
        Proto = &(TempProto->Proto);

        /* compute proto params - NOTE that Y_DIM_OFFSET must be used because
       ConvertProto assumes that the Y dimension varies from -0.5 to 0.5
       instead of the -0.25 to 0.75 used in baseline normalization */
        Proto->Angle = Feature->Params[OutlineFeatDir];
        Proto->X = Feature->Params[OutlineFeatX];
        Proto->Y = Feature->Params[OutlineFeatY] - Y_DIM_OFFSET;
        Proto->Length = Feature->Params[OutlineFeatLength];
        FillABC(Proto);

        TempProto->ProtoId = Pid;
        SET_BIT (Config->Protos, Pid);

        ConvertProto(Proto, Pid, IClass);
        AddProtoToProtoPruner(Proto, Pid, IClass);

        Class->TempProtos = push (Class->TempProtos, TempProto);
    }
    FreeFeatureSet(Features);

    AddIntConfig(IClass);
    ConvertConfig (AllProtosOn, 0, IClass);

    if (classify_learning_debug_level >= 1)
    {
        cprintf ("Added new class '%s' with class id %d and %d protos.\n", unicharset.id_to_unichar(ClassId), ClassId, NumFeatures);
    }

    if (IsEmptyAdaptedClass(Class)) (Templates->NumNonEmptyClasses)++;
}                                /* InitAdaptedClass */

/*---------------------------------------------------------------------------*/
/**
 * This routine sets up the feature
 * extractor to extract baseline normalized
 * pico-features.
 *
 * The extracted pico-features are converted
 * to integer form and placed in IntFeatures. The
 * original floating-pt. features are returned in
 * FloatFeatures.
 *
 * Globals: none
 * @param Blob blob to extract features from
 * @param LineStats statistics about text row blob is in
 * @param[out] IntFeatures array to fill with integer features
 * @param[out] FloatFeatures place to return actual floating-pt features
 *
 * @return Number of pico-features returned (0 if
 * an error occurred)
 * @note Exceptions: none
 * @note History: Tue Mar 12 17:55:18 1991, DSJ, Created.
 */
int GetAdaptiveFeatures(TBLOB *Blob, LINE_STATS *LineStats, INT_FEATURE_ARRAY IntFeatures, FEATURE_SET *FloatFeatures)
{
    FEATURE_SET Features;
    int NumFeatures;

    classify_norm_method.set_value(baseline);
    Features = ExtractPicoFeatures (Blob, LineStats);

    NumFeatures = Features->NumFeatures;
    if (NumFeatures > UNLIKELY_NUM_FEAT)
    {
        FreeFeatureSet(Features);
        return (0);
    }

    ComputeIntFeatures(Features, IntFeatures);
    *FloatFeatures = Features;

    return (NumFeatures);

}                                /* GetAdaptiveFeatures */


/*-----------------------------------------------------------------------------
              Private Code
-----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/**
 * Return TRUE if the specified word is
 * acceptable for adaptation.
 *
 * Globals: none
 *
 * @param Word current word
 * @param BestChoiceWord best overall choice for word with context
 * @param RawChoiceWord best choice for word without context
 *
 * @return TRUE or FALSE
 * @note Exceptions: none
 * @note History: Thu May 30 14:25:06 1991, DSJ, Created.
 */
int Classify::AdaptableWord(TWERD *Word, const WERD_CHOICE &BestChoiceWord, const WERD_CHOICE &RawChoiceWord)
{
    int BestChoiceLength = BestChoiceWord.length();

    // rules that apply in general - simplest to compute first
    return (BestChoiceLength > 0 && BestChoiceLength == NumBlobsIn (Word) &&
            BestChoiceLength <= MAX_ADAPTABLE_WERD_SIZE &&
            ((classify_enable_new_adapt_rules && getDict().CurrentBestChoiceAdjustFactor() <= ADAPTABLE_WERD &&
              getDict().AlternativeChoicesWorseThan(ADAPTABLE_WERD) &&
              getDict().CurrentBestChoiceIs(BestChoiceWord)) ||
             (!classify_enable_new_adapt_rules &&  /*old rules*/
              BestChoiceLength == RawChoiceWord.length() &&
              ((getDict().valid_word_or_number(BestChoiceWord) &&
                Context::case_ok(BestChoiceWord, getDict().getUnicharset()))))));
}

/*---------------------------------------------------------------------------*/
/**
 * @param Blob blob to add to templates for ClassId
 * @param LineStats statistics about text line blob is in
 * @param ClassId class to add blob to
 * @param Threshold minimum match rating to existing template
 *
 * Globals:
 * - AdaptedTemplates current set of adapted templates
 * - AllProtosOn dummy mask to match against all protos
 * - AllConfigsOn dummy mask to match against all configs
 *
 * @return none
 * @note Exceptions: none
 * @note History: Thu Mar 14 09:36:03 1991, DSJ, Created.
 */
void Classify::AdaptToChar(TBLOB *Blob, LINE_STATS *LineStats, CLASS_ID ClassId, FLOAT32 Threshold)
{
    int NumFeatures;
    INT_FEATURE_ARRAY IntFeatures;
    INT_RESULT_STRUCT IntResult;
    INT_CLASS IClass;
    ADAPT_CLASS Class;
    TEMP_CONFIG TempConfig;
    FEATURE_SET FloatFeatures;
    int NewTempConfigId;

    NumCharsAdaptedTo++;
    if (!LegalClassId (ClassId)) return;

    Class = AdaptedTemplates->Class[ClassId];
    assert(Class != NULL);
    if (IsEmptyAdaptedClass(Class))
    {
        InitAdaptedClass(Blob, LineStats, ClassId, Class, AdaptedTemplates);
    }
    else
    {
        IClass = ClassForClassId (AdaptedTemplates->Templates, ClassId);

        NumFeatures = GetAdaptiveFeatures (Blob, LineStats, IntFeatures, &FloatFeatures);
        if (NumFeatures <= 0)  return;

        SetBaseLineMatch();
        IntegerMatcher (IClass, AllProtosOn, AllConfigsOn, NumFeatures, NumFeatures, IntFeatures, 0, &IntResult, NO_DEBUG);

        SetAdaptiveThreshold(Threshold);

        if (IntResult.Rating <= Threshold)
        {
            if (ConfigIsPermanent (Class, IntResult.Config))
            {
                if (classify_learning_debug_level >= 1) cprintf ("Found good match to perm config %d = %4.1f%%.\n", IntResult.Config, (1.0 - IntResult.Rating) * 100.0);
                FreeFeatureSet(FloatFeatures);
                return;
            }

            TempConfig = TempConfigFor (Class, IntResult.Config);
            IncreaseConfidence(TempConfig);
            if (classify_learning_debug_level >= 1)  cprintf ("Increasing reliability of temp config %d to %d.\n", IntResult.Config, TempConfig->NumTimesSeen);

            if (TempConfigReliable (TempConfig)) MakePermanent (AdaptedTemplates, ClassId, IntResult.Config, Blob, LineStats);
        }
        else
        {
            if (classify_learning_debug_level >= 1) cprintf ("Found poor match to temp config %d = %4.1f%%.\n", IntResult.Config, (1.0 - IntResult.Rating) * 100.0);
            NewTempConfigId = MakeNewTemporaryConfig(AdaptedTemplates,  ClassId,  NumFeatures,  IntFeatures, FloatFeatures);

            if (NewTempConfigId >= 0 && TempConfigReliable (TempConfigFor (Class, NewTempConfigId)))
                MakePermanent (AdaptedTemplates, ClassId, NewTempConfigId,  Blob, LineStats);

#ifndef GRAPHICS_DISABLED
            if (classify_learning_debug_level >= 1)
            {
                IntegerMatcher (IClass, AllProtosOn, AllConfigsOn,  NumFeatures, NumFeatures, IntFeatures, 0, &IntResult, NO_DEBUG);
                cprintf ("Best match to temp config %d = %4.1f%%.\n", IntResult.Config, (1.0 - IntResult.Rating) * 100.0);

                if (classify_learning_debug_level >= 2)
                {
                    uinT32 ConfigMask;
                    ConfigMask = 1 << IntResult.Config;
                    ShowMatchDisplay();
                    IntegerMatcher (IClass, AllProtosOn, (BIT_VECTOR)&ConfigMask, NumFeatures, NumFeatures, IntFeatures, 0,  &IntResult, 6 | 0x19);
                    UpdateMatchDisplay();
                    GetClassToDebug ("Adapting");
                }
            }
#endif
        }
        FreeFeatureSet(FloatFeatures);
    }
}                                /* AdaptToChar */


/*---------------------------------------------------------------------------*/
/**
 * @param Blob blob to add to templates for ClassId
 * @param LineStats statistics about text line blob is in
 * @param ClassId class to add blob to
 * @param Threshold minimum match rating to existing template
 *
 * Globals:
 * - PreTrainedTemplates current set of built-in templates
 *
 * @note Exceptions: none
 * @note History: Thu Mar 14 09:36:03 1991, DSJ, Created.
 */
void Classify::AdaptToPunc(TBLOB *Blob, LINE_STATS *LineStats, CLASS_ID ClassId, FLOAT32 Threshold)
{
    ADAPT_RESULTS *Results = new ADAPT_RESULTS();
    int i;

    Results->Initialize();
    CharNormClassifier(Blob, LineStats, PreTrainedTemplates, Results);
    RemoveBadMatches(Results);

    if (Results->NumMatches != 1)
    {
        if (classify_learning_debug_level >= 1)
        {
            cprintf ("Rejecting punc = %s (Alternatives = ", unicharset.id_to_unichar(ClassId));

            for (i = 0; i < Results->NumMatches; i++)
            {
                cprintf ("%s", unicharset.id_to_unichar(Results->Classes[i]));
            }

            cprintf (")\n");
        }
    }
    else
    {

#ifndef SECURE_NAMES
        if (classify_learning_debug_level >= 1)
            cprintf ("Adapting to punc = %s, thr= %g\n", unicharset.id_to_unichar(ClassId), Threshold);
#endif
        AdaptToChar(Blob, LineStats, ClassId, Threshold);
    }
    delete Results;
}                                /* AdaptToPunc */


/*---------------------------------------------------------------------------*/
/**
 * This routine adds the result of a classification into
 * Results.  If the new rating is much worse than the current
 * best rating, it is not entered into results because it
 * would end up being stripped later anyway.  If the new rating
 * is better than the old rating for the class, it replaces the
 * old rating.  If this is the first rating for the class, the
 * class is added to the list of matched classes in Results.
 * If the new rating is better than the best so far, it
 * becomes the best so far.
 *
 * Globals:
 * - #matcher_bad_match_pad defines limits of an acceptable match
 *
 * @param[out] Results results to add new result to
 * @param ClassId class of new result
 * @param Rating rating of new result
 * @param ConfigId config id of new result
 *
 * @note Exceptions: none
 * @note History: Tue Mar 12 18:19:29 1991, DSJ, Created.
 */
void Classify::AddNewResult(ADAPT_RESULTS *Results, CLASS_ID ClassId, FLOAT32 Rating, int ConfigId)
{
    FLOAT32 OldRating;
    INT_CLASS_STRUCT* CharClass = NULL;

    OldRating = Results->Ratings[ClassId];
    if (Rating <= Results->BestRating + matcher_bad_match_pad && Rating < OldRating)
    {
        if (!unicharset.get_fragment(ClassId))
        {
            Results->HasNonfragment = true;
        }

        Results->Ratings[ClassId] = Rating;
        if (ClassId != NO_CLASS)
        {
            CharClass = ClassForClassId(PreTrainedTemplates, ClassId);
        }

        if (CharClass != NULL)
        {
            Results->Configs[ClassId] = ConfigId;
        }
        else
        {
            Results->Configs[ClassId] = ~0;
        }

        // Ensure that fragments do not affect best rating, class and config.
        // This is needed so that at least one non-fragmented character is
        // always present in the Results.
        // TODO(daria): verify that this helps accuracy and does not
        // hurt performance.
        if (Rating < Results->BestRating && !unicharset.get_fragment(ClassId))
        {
            Results->BestRating = Rating;
            Results->BestClass = ClassId;
            Results->BestConfig = ConfigId;
        }

        /* if this is first rating for class, add to list of classes matched */
        if (OldRating == WORST_POSSIBLE_RATING)
        {
            Results->Classes[Results->NumMatches++] = ClassId;
        }
    }
}                                /* AddNewResult */


/*---------------------------------------------------------------------------*/
/**
 * This routine is identical to CharNormClassifier()
 * except that it does no class pruning.  It simply matches
 * the unknown blob against the classes listed in
 * Ambiguities.
 *
 * Globals:
 * - #AllProtosOn mask that enables all protos
 * - #AllConfigsOn mask that enables all configs
 *
 * @param Blob blob to be classified
 * @param LineStats statistics for text line Blob is in
 * @param Templates built-in templates to classify against
 * @param Ambiguities array of class id's to match against
 * @param[out] Results place to put match results
 *
 * @note Exceptions: none
 * @note History: Tue Mar 12 19:40:36 1991, DSJ, Created.
 */
void Classify::AmbigClassifier(TBLOB *Blob, LINE_STATS *LineStats, INT_TEMPLATES Templates, UNICHAR_ID *Ambiguities, ADAPT_RESULTS *Results)
{
    int NumFeatures;
    INT_FEATURE_ARRAY IntFeatures;
    CLASS_NORMALIZATION_ARRAY CharNormArray;
    INT_RESULT_STRUCT IntResult;
    CLASS_ID ClassId;

    AmbigClassifierCalls++;

    NumFeatures = GetCharNormFeatures (Blob, LineStats, Templates, IntFeatures, CharNormArray, &(Results->BlobLength));
    if (NumFeatures <= 0) return;

    if (matcher_debug_level >= 2) cprintf ("AM Matches =  ");

    while (*Ambiguities >= 0)
    {
        ClassId = *Ambiguities;

        SetCharNormMatch();
        IntegerMatcher(ClassForClassId (Templates, ClassId), AllProtosOn, AllConfigsOn, Results->BlobLength,
                       NumFeatures, IntFeatures, CharNormArray[ClassId], &IntResult, NO_DEBUG);

        if (matcher_debug_level >= 2)
        {
            cprintf ("%s-%-2d %2.0f  ", unicharset.id_to_unichar(ClassId), IntResult.Config, IntResult.Rating * 100.0);
        }

        AddNewResult (Results, ClassId, IntResult.Rating, IntResult.Config);

        Ambiguities++;

        NumAmbigClassesTried++;
    }

    if (matcher_debug_level >= 2) cprintf ("\n");

}                                /* AmbigClassifier */

/*---------------------------------------------------------------------------*/
/// Factored-out calls to IntegerMatcher based on class pruner results.
/// Returns integer matcher results inside CLASS_PRUNER_RESULTS structure.
void Classify::MasterMatcher(INT_TEMPLATES templates, inT16 num_features, INT_FEATURE_ARRAY features, CLASS_NORMALIZATION_ARRAY norm_factors,
                             ADAPT_CLASS* classes, int debug, int num_classes, CLASS_PRUNER_RESULTS results, ADAPT_RESULTS* final_results)
{
    for (int c = 0; c < num_classes; c++)
    {
        CLASS_ID class_id = results[c].Class;
        INT_RESULT_STRUCT& int_result = results[c].IMResult;
        BIT_VECTOR protos = classes != NULL ? classes[class_id]->PermProtos : AllProtosOn;
        BIT_VECTOR configs = classes != NULL ? classes[class_id]->PermConfigs : AllConfigsOn;

        IntegerMatcher(ClassForClassId(templates, class_id), protos, configs, final_results->BlobLength,
                       num_features, features, norm_factors[class_id], &int_result, debug);

        // Compute class feature corrections.
        double miss_penalty = tessedit_class_miss_scale * int_result.FeatureMisses;
        if (matcher_debug_level >= 2 || tord_display_ratings > 1)
        {
            cprintf("%s-%-2d %2.1f(CP%2.1f, IM%2.1f + MP%2.1f)  ", unicharset.id_to_unichar(class_id), int_result.Config, (int_result.Rating + miss_penalty) * 100.0,
                    results[c].Rating * 100.0, int_result.Rating * 100.0, miss_penalty * 100.0);
            if (c % 4 == 3) cprintf ("\n");
        }

        int_result.Rating += miss_penalty;
        if (int_result.Rating > WORST_POSSIBLE_RATING)
        {
            int_result.Rating = WORST_POSSIBLE_RATING;
        }

        AddNewResult(final_results, class_id, int_result.Rating, int_result.Config);

        // Add unichars ambiguous with class_id with the same rating as class_id.
        if (use_definite_ambigs_for_classifier)
        {
            const UnicharIdVector *definite_ambigs = getDict().getUnicharAmbigs().OneToOneDefiniteAmbigs(class_id);
            int ambigs_size = (definite_ambigs == NULL) ? 0 : definite_ambigs->size();

            for (int ambig = 0; ambig < ambigs_size; ++ambig)
            {
                UNICHAR_ID ambig_class_id = (*definite_ambigs)[ambig];

                if (matcher_debug_level >= 3)
                {
                    tprintf("class: %d definite ambig: %d rating: old %.4f new %.4f\n", class_id, ambig_class_id,
                            final_results->Ratings[ambig_class_id], int_result.Rating);
                }

                if (final_results->Ratings[ambig_class_id] < WORST_POSSIBLE_RATING)
                {
                    // ambig_class_id was already added to final_results,
                    // so just need to modify the rating.
                    if (int_result.Rating < final_results->Ratings[ambig_class_id])
                    {
                        final_results->Ratings[ambig_class_id] = int_result.Rating;
                    }
                }
                else
                {
                    AddNewResult(final_results, ambig_class_id, int_result.Rating, int_result.Config);
                }
            }
        }
    }

    if (matcher_debug_level >= 2 || tord_display_ratings > 1) cprintf("\n");
}

/*---------------------------------------------------------------------------*/
/**
 * This routine extracts baseline normalized features
 * from the unknown character and matches them against the
 * specified set of templates.  The classes which match
 * are added to Results.
 *
 * Globals:
 * - BaselineCutoffs expected num features for each class
 *
 * @param Blob blob to be classified
 * @param LineStats statistics for text line Blob is in
 * @param Templates current set of adapted templates
 * @param Results place to put match results
 *
 * @return Array of possible ambiguous chars that should be checked.
 * @note Exceptions: none
 * @note History: Tue Mar 12 19:38:03 1991, DSJ, Created.
 */
UNICHAR_ID *Classify::BaselineClassifier(TBLOB *Blob, LINE_STATS *LineStats, ADAPT_TEMPLATES Templates, ADAPT_RESULTS *Results)
{
    int NumFeatures;
    int NumClasses;
    INT_FEATURE_ARRAY IntFeatures;
    CLASS_NORMALIZATION_ARRAY CharNormArray;
    CLASS_ID ClassId;

    BaselineClassifierCalls++;

    NumFeatures = GetBaselineFeatures (Blob, LineStats, Templates->Templates, IntFeatures, CharNormArray, &(Results->BlobLength));
    if (NumFeatures <= 0) return NULL;

    NumClasses = ClassPruner (Templates->Templates, NumFeatures, IntFeatures, CharNormArray, BaselineCutoffs, Results->CPResults, matcher_debug_flags);

    NumBaselineClassesTried += NumClasses;

    if (matcher_debug_level >= 2 || tord_display_ratings > 1) cprintf ("BL Matches =  ");

    SetBaseLineMatch();
    MasterMatcher(Templates->Templates, NumFeatures, IntFeatures, CharNormArray, Templates->Class, matcher_debug_flags, NumClasses, Results->CPResults, Results);

    ClassId = Results->BestClass;
    if (ClassId == NO_CLASS) return (NULL);
    /* this is a bug - maybe should return "" */

    return (Templates->Class[ClassId]->Config[Results->BestConfig].Perm);
}                                /* BaselineClassifier */


/*---------------------------------------------------------------------------*/
/**
 * This routine extracts character normalized features
 * from the unknown character and matches them against the
 * specified set of templates.  The classes which match
 * are added to Results.
 *
 * @param Blob blob to be classified
 * @param LineStats statistics for text line Blob is in
 * @param Templates templates to classify unknown against
 * @param Results place to put match results
 *
 * Globals:
 * - CharNormCutoffs expected num features for each class
 * - AllProtosOn mask that enables all protos
 * - AllConfigsOn mask that enables all configs
 *
 * @note Exceptions: none
 * @note History: Tue Mar 12 16:02:52 1991, DSJ, Created.
 */
int Classify::CharNormClassifier(TBLOB *Blob, LINE_STATS *LineStats, INT_TEMPLATES Templates, ADAPT_RESULTS *Results)
{
    int NumFeatures;
    int NumClasses;
    INT_FEATURE_ARRAY IntFeatures;
    CLASS_NORMALIZATION_ARRAY CharNormArray;

    CharNormClassifierCalls++;

    NumFeatures = GetCharNormFeatures(Blob, LineStats, Templates, IntFeatures, CharNormArray, &(Results->BlobLength));
    if (NumFeatures <= 0) return 0;

    NumClasses = ClassPruner(Templates, NumFeatures, IntFeatures, CharNormArray, CharNormCutoffs, Results->CPResults, matcher_debug_flags);

    if (tessedit_single_match && NumClasses > 1) NumClasses = 1;
    NumCharNormClassesTried += NumClasses;

    SetCharNormMatch();
    MasterMatcher(Templates, NumFeatures, IntFeatures, CharNormArray, NULL, matcher_debug_flags, NumClasses, Results->CPResults, Results);

    return NumFeatures;
}                                /* CharNormClassifier */


/*---------------------------------------------------------------------------*/
/**
 * This routine computes a rating which reflects the
 * likelihood that the blob being classified is a noise
 * blob.  NOTE: assumes that the blob length has already been
 * computed and placed into Results.
 *
 * @param Results results to add noise classification to
 *
 * Globals:
 * - matcher_avg_noise_size avg. length of a noise blob
 *
 * @note Exceptions: none
 * @note History: Tue Mar 12 18:36:52 1991, DSJ, Created.
 */
void Classify::ClassifyAsNoise(ADAPT_RESULTS *Results)
{
    register FLOAT32 Rating;

    Rating = Results->BlobLength / matcher_avg_noise_size;
    Rating *= Rating;
    Rating /= 1.0 + Rating;

    AddNewResult (Results, NO_CLASS, Rating, 0);
}                                /* ClassifyAsNoise */

/*---------------------------------------------------------------------------*/
/**
 * This routine gets the ratings for the 2 specified classes
 * from a global variable (CurrentRatings) and returns:
 * - -1 if Rating1 < Rating2
 * - 0 if Rating1 = Rating2
 * - 1 if Rating1 > Rating2
 *
 * @param arg1
 * @param arg2 classes whose ratings are to be compared
 *
 * Globals:
 * - CurrentRatings contains actual ratings for each class
 *
 * @return Order of classes based on their ratings (see above).
 * @note Exceptions: none
 * @note History: Tue Mar 12 14:18:31 1991, DSJ, Created.
 */
int CompareCurrentRatings(const void *arg1, const void *arg2)
{
    FLOAT32 Rating1, Rating2;
    CLASS_ID *Class1 = (CLASS_ID *) arg1;
    CLASS_ID *Class2 = (CLASS_ID *) arg2;

    Rating1 = CurrentRatings[*Class1];
    Rating2 = CurrentRatings[*Class2];

    if (Rating1 < Rating2)
    {
        return (-1);
    }
    else if (Rating1 > Rating2)
    {
        return (1);
    }
    else
    {
        return (0);
    }
}                                /* CompareCurrentRatings */


/*---------------------------------------------------------------------------*/
/// The function converts the given match ratings to the list of blob
/// choices with ratings and certainties (used by the context checkers).
/// If character fragments are present in the results, this function also makes
/// sure that there is at least one non-fragmented classification included.
/// For each classification result check the unicharset for "definite"
/// ambiguities and modify the resulting Choices accordingly.
void Classify::ConvertMatchesToChoices(ADAPT_RESULTS *Results, BLOB_CHOICE_LIST *Choices)
{
    assert(Choices != NULL);
    int i;
    CLASS_ID NextMatch;
    FLOAT32 Rating;
    FLOAT32 Certainty;
    BLOB_CHOICE_IT temp_it;
    bool contains_nonfrag = false;
    temp_it.set_to_list(Choices);
    int choices_length = 0;

    for (i = 0; i < Results->NumMatches; i++)
    {
        NextMatch = Results->Classes[i];
        bool current_is_frag = (unicharset.get_fragment(NextMatch) != NULL);
        if (temp_it.length()+1 == MAX_MATCHES && !contains_nonfrag && current_is_frag)
        {
            continue;  // look for a non-fragmented character to fill the
            // last spot in Choices if only fragments are present
        }

        // BlobLength can never be legally 0, this means recognition failed.
        // But we must return a classification result because some invoking
        // functions (chopper/permuter) do not anticipate a null blob choice.
        // So we need to assign a poor, but not infinitely bad score.
        if (Results->BlobLength == 0)
        {
            Certainty = -20;
            Rating = 100;    // should be -certainty * real_blob_length
        }
        else
        {
            Rating = Certainty = Results->Ratings[NextMatch];
            Rating *= rating_scale * Results->BlobLength;
            Certainty *= -certainty_scale;
        }

        temp_it.add_to_end(new BLOB_CHOICE(NextMatch, Rating, Certainty, Results->Configs[NextMatch], unicharset.get_script(NextMatch)));
        contains_nonfrag |= !current_is_frag;  // update contains_nonfrag
        choices_length++;

        if (choices_length >= MAX_MATCHES) break;
    }

    Results->NumMatches = choices_length;
}  // ConvertMatchesToChoices


/*---------------------------------------------------------------------------*/
#ifndef GRAPHICS_DISABLED
/**
 *
 * @param Blob blob whose classification is being debugged
 * @param LineStats statistics for text line blob is in
 * @param Results results of match being debugged
 *
 * Globals: none
 *
 * @note Exceptions: none
 * @note History: Wed Mar 13 16:44:41 1991, DSJ, Created.
 */
void Classify::DebugAdaptiveClassifier(TBLOB *Blob, LINE_STATS *LineStats, ADAPT_RESULTS *Results)
{
    const char *Prompt = "Left-click in IntegerMatch Window to continue or right click to debug...";
    const char *DebugMode = "All Templates";
    CLASS_ID LastClass = Results->BestClass;
    CLASS_ID ClassId;
    BOOL8 AdaptiveOn = TRUE;
    BOOL8 PreTrainedOn = TRUE;

    ShowMatchDisplay();
    cprintf ("\nDebugging class = %s  (%s) ...\n", unicharset.id_to_unichar(LastClass), DebugMode);
    ShowBestMatchFor(Blob, LineStats, LastClass, AdaptiveOn, PreTrainedOn);
    UpdateMatchDisplay();

    while ((ClassId = GetClassToDebug (Prompt)) != 0)
    {
#if 0
        switch (ClassId)
        {
        case 'b':
            AdaptiveOn = TRUE;
            PreTrainedOn = FALSE;
            DebugMode = "Adaptive Templates Only";
            break;

        case 'c':
            AdaptiveOn = FALSE;
            PreTrainedOn = TRUE;
            DebugMode = "PreTrained Templates Only";
            break;

        case 'a':
            AdaptiveOn = TRUE;
            PreTrainedOn = TRUE;
            DebugMode = "All Templates";
            break;

        default:
            LastClass = ClassId;
            break;
        }
#endif
        LastClass = ClassId;

        ShowMatchDisplay();
        cprintf ("\nDebugging class = %d = %s  (%s) ...\n", LastClass, unicharset.id_to_unichar(LastClass), DebugMode);
        ShowBestMatchFor(Blob, LineStats, LastClass, AdaptiveOn, PreTrainedOn);
        UpdateMatchDisplay();
    }
}                                /* DebugAdaptiveClassifier */
#endif

/*---------------------------------------------------------------------------*/
/**
 * This routine performs an adaptive classification.
 * If we have not yet adapted to enough classes, a simple
 * classification to the pre-trained templates is performed.
 * Otherwise, we match the blob against the adapted templates.
 * If the adapted templates do not match well, we try a
 * match against the pre-trained templates.  If an adapted
 * template match is found, we do a match to any pre-trained
 * templates which could be ambiguous.  The results from all
 * of these classifications are merged together into Results.
 *
 * @param Blob blob to be classified
 * @param LineStats statistics for text line Blob is in
 * @param Results place to put match results
 *
 * Globals:
 * - PreTrainedTemplates built-in training templates
 * - AdaptedTemplates templates adapted for this page
 * - matcher_great_threshold rating limit for a great match
 *
 * @note Exceptions: none
 * @note History: Tue Mar 12 08:50:11 1991, DSJ, Created.
 */
void Classify::DoAdaptiveMatch(TBLOB *Blob, LINE_STATS *LineStats, ADAPT_RESULTS *Results)
{
    UNICHAR_ID *Ambiguities;

    AdaptiveMatcherCalls++;
    InitIntFX();

    if (AdaptedTemplates->NumPermClasses < matcher_permanent_classes_min || tess_cn_matching)
    {
        CharNormClassifier(Blob, LineStats, PreTrainedTemplates, Results);
    }
    else
    {
        Ambiguities = BaselineClassifier(Blob, LineStats, AdaptedTemplates, Results);
        if ((Results->NumMatches > 0 && MarginalMatch (Results->BestRating) && !tess_bn_matching) || Results->NumMatches == 0)
        {
            CharNormClassifier(Blob, LineStats, PreTrainedTemplates, Results);
        }
        else if (Ambiguities && *Ambiguities >= 0)
        {
            AmbigClassifier(Blob, LineStats, PreTrainedTemplates, Ambiguities, Results);
        }
    }

    // Force the blob to be classified as noise
    // if the results contain only fragments.
    // TODO(daria): verify that this is better than
    // just adding a NULL classificaiton.
    if (!Results->HasNonfragment)
    {
        Results->NumMatches = 0;
    }

    if (Results->NumMatches == 0) ClassifyAsNoise(Results);
}   /* DoAdaptiveMatch */

/*---------------------------------------------------------------------------*/
/**
 * This routine tries to estimate how tight the adaptation
 * threshold should be set for each character in the current
 * word.  In general, the routine tries to set tighter
 * thresholds for a character when the current set of templates
 * would have made an error on that character.  It tries
 * to set a threshold tight enough to eliminate the error.
 * Two different sets of rules can be used to determine the
 * desired thresholds.
 *
 * @param Word current word
 * @param LineStats line stats for row word is in
 * @param BestChoice best choice for current word with context
 * @param BestRawChoice best choice for current word without context
 * @param[out] Thresholds array of thresholds to be filled in
 *
 * Globals:
 * - classify_enable_new_adapt_rules
 * - matcher_good_threshold
 * - matcher_perfect_threshold
 * - matcher_rating_margin
 *
 * @return none (results are returned in Thresholds)
 * @note Exceptions: none
 * @note History: Fri May 31 09:22:08 1991, DSJ, Created.
 */
void Classify::GetAdaptThresholds (TWERD * Word, LINE_STATS * LineStats, const WERD_CHOICE& BestChoice, const WERD_CHOICE& BestRawChoice, FLOAT32 Thresholds[])
{
    TBLOB *Blob;
    const char* BestChoice_string = BestChoice.unichar_string().string();
    const char* BestChoice_lengths = BestChoice.unichar_lengths().string();
    const char* BestRawChoice_string = BestRawChoice.unichar_string().string();
    const char* BestRawChoice_lengths = BestRawChoice.unichar_lengths().string();

    if (classify_enable_new_adapt_rules &&   /* new rules */ getDict().CurrentBestChoiceIs(BestChoice))
    {
        getDict().FindClassifierErrors(matcher_perfect_threshold, matcher_good_threshold, matcher_rating_margin, Thresholds);
    }
    else
    {                       /* old rules */
        for (Blob = Word->blobs; Blob != NULL; Blob = Blob->next, BestChoice_string += *(BestChoice_lengths++), BestRawChoice_string += *(BestRawChoice_lengths++), Thresholds++)
        {
            if (*(BestChoice_lengths) == *(BestRawChoice_lengths) &&  strncmp(BestChoice_string, BestRawChoice_string,*(BestChoice_lengths)) == 0)
            {
                *Thresholds = matcher_good_threshold;
            }

            else
            {
                /* the blob was incorrectly classified - find the rating threshold
                   needed to create a template which will correct the error with
                   some margin.  However, don't waste time trying to make
                   templates which are too tight. */
                *Thresholds = GetBestRatingFor (Blob, LineStats, unicharset.unichar_to_id(BestChoice_string, *BestChoice_lengths));
                *Thresholds *= (1.0 - matcher_rating_margin);

                if (*Thresholds > matcher_good_threshold)
                {
                    *Thresholds = matcher_good_threshold;
                }
                if (*Thresholds < matcher_perfect_threshold)
                {
                    *Thresholds = matcher_perfect_threshold;
                }
            }
        }
    }
}                              /* GetAdaptThresholds */

/*---------------------------------------------------------------------------*/
/**
 * This routine matches blob to the built-in templates
 * to find out if there are any classes other than the correct
 * class which are potential ambiguities.
 *
 * @param Blob blob to get classification ambiguities for
 * @param LineStats statistics for text line blob is in
 * @param CorrectClass correct class for Blob
 *
 * Globals:
 * - CurrentRatings used by qsort compare routine
 * - PreTrainedTemplates built-in templates
 *
 * @return String containing all possible ambiguous classes.
 * @note Exceptions: none
 * @note History: Fri Mar 15 08:08:22 1991, DSJ, Created.
 */
UNICHAR_ID *Classify::GetAmbiguities(TBLOB *Blob, LINE_STATS *LineStats, CLASS_ID CorrectClass)
{
    ADAPT_RESULTS *Results = new ADAPT_RESULTS();
    UNICHAR_ID *Ambiguities;
    int i;

    EnterClassifyMode;

    Results->Initialize();

    CharNormClassifier(Blob, LineStats, PreTrainedTemplates, Results);
    RemoveBadMatches(Results);

    /* save ratings in a global so that CompareCurrentRatings() can see them */
    CurrentRatings = Results->Ratings;
    qsort ((void *) (Results->Classes), Results->NumMatches, sizeof (CLASS_ID), CompareCurrentRatings);

    /* copy the class id's into an string of ambiguities - don't copy if
     the correct class is the only class id matched */
    Ambiguities = (UNICHAR_ID *) Emalloc (sizeof (UNICHAR_ID) * (Results->NumMatches + 1));
    if (Results->NumMatches > 1 || (Results->NumMatches == 1 && Results->Classes[0] != CorrectClass))
    {
        for (i = 0; i < Results->NumMatches; i++)
        {
            Ambiguities[i] = Results->Classes[i];
        }

        Ambiguities[i] = -1;
    }
    else
    {
        Ambiguities[0] = -1;
    }

    delete Results;

    return (Ambiguities);
}                              /* GetAmbiguities */

/*---------------------------------------------------------------------------*/
/**
 * This routine sets up the feature extractor to extract
 * baseline normalized pico-features.
 *
 * The extracted pico-features are converted
 * to integer form and placed in IntFeatures.  CharNormArray
 * is filled with 0's to indicate to the matcher that no
 * character normalization adjustment needs to be done.
 *
 * The total length of all blob outlines
 * in baseline normalized units is also returned.
 *
 * @param Blob blob to extract features from
 * @param LineStats statistics about text row blob is in
 * @param Templates used to compute char norm adjustments
 * @param IntFeatures array to fill with integer features
 * @param CharNormArray array to fill with dummy char norm adjustments
 * @param BlobLength length of blob in baseline-normalized units
 *
 * Globals: none
 *
 * @return Number of pico-features returned (0 if an error occurred)
 * @note Exceptions: none
 * @note History: Tue Mar 12 17:55:18 1991, DSJ, Created.
 */
int GetBaselineFeatures(TBLOB *Blob, LINE_STATS *LineStats, INT_TEMPLATES Templates,
                        INT_FEATURE_ARRAY IntFeatures, CLASS_NORMALIZATION_ARRAY CharNormArray, inT32 *BlobLength)
{
    FEATURE_SET Features;
    int NumFeatures;

    if (classify_enable_int_fx)
    {
        return (GetIntBaselineFeatures (Blob, LineStats, Templates, IntFeatures, CharNormArray, BlobLength));
    }

    classify_norm_method.set_value(baseline);
    Features = ExtractPicoFeatures (Blob, LineStats);

    NumFeatures = Features->NumFeatures;
    *BlobLength = NumFeatures;
    if (NumFeatures > UNLIKELY_NUM_FEAT)
    {
        FreeFeatureSet(Features);
        return (0);
    }

    ComputeIntFeatures(Features, IntFeatures);
    ClearCharNormArray(Templates, CharNormArray);

    FreeFeatureSet(Features);
    return NumFeatures;
}                              /* GetBaselineFeatures */

/**
 * This routine classifies Blob against both sets of
 * templates for the specified class and returns the best
 * rating found.
 *
 * @param Blob blob to get best rating for
 * @param LineStats statistics about text line blob is in
 * @param ClassId class blob is to be compared to
 *
 * Globals:
 * - PreTrainedTemplates built-in templates
 * - AdaptedTemplates current set of adapted templates
 * - AllProtosOn dummy mask to enable all protos
 * - AllConfigsOn dummy mask to enable all configs
 *
 * @return Best rating for match of Blob to ClassId.
 * @note Exceptions: none
 * @note History: Tue Apr  9 09:01:24 1991, DSJ, Created.
 */
FLOAT32 Classify::GetBestRatingFor(TBLOB *Blob, LINE_STATS *LineStats, CLASS_ID ClassId)
{
    int NumCNFeatures, NumBLFeatures;
    INT_FEATURE_ARRAY CNFeatures, BLFeatures;
    INT_RESULT_STRUCT CNResult, BLResult;
    inT32 BlobLength;

    CNResult.Rating = BLResult.Rating = 1.0;

    if (!LegalClassId(ClassId)) return (1.0);

    uinT8 *CNAdjust = new uinT8[MAX_NUM_CLASSES];
    uinT8 *BLAdjust = new uinT8[MAX_NUM_CLASSES];

    if (!UnusedClassIdIn(PreTrainedTemplates, ClassId))
    {
        NumCNFeatures = GetCharNormFeatures(Blob, LineStats, PreTrainedTemplates, CNFeatures, CNAdjust, &BlobLength);
        if (NumCNFeatures > 0)
        {
            SetCharNormMatch();
            IntegerMatcher(ClassForClassId(PreTrainedTemplates, ClassId), AllProtosOn, AllConfigsOn,
                           BlobLength, NumCNFeatures, CNFeatures, CNAdjust[ClassId], &CNResult, NO_DEBUG);
        }
    }

    if (!UnusedClassIdIn(AdaptedTemplates->Templates, ClassId))
    {
        NumBLFeatures = GetBaselineFeatures(Blob, LineStats, AdaptedTemplates->Templates, BLFeatures, BLAdjust, &BlobLength);
        if (NumBLFeatures > 0)
        {
            SetBaseLineMatch();
            IntegerMatcher(ClassForClassId(AdaptedTemplates->Templates, ClassId), AdaptedTemplates->Class[ClassId]->PermProtos,
                           AdaptedTemplates->Class[ClassId]->PermConfigs, BlobLength, NumBLFeatures, BLFeatures, BLAdjust[ClassId], &BLResult, NO_DEBUG);
        }
    }

    // Clean up.
    delete[] CNAdjust;
    delete[] BLAdjust;

    return (MIN (BLResult.Rating, CNResult.Rating));
}                              /* GetBestRatingFor */

/*---------------------------------------------------------------------------*/
/**
 * This routine sets up the feature extractor to extract
 * character normalization features and character normalized
 * pico-features.  The extracted pico-features are converted
 * to integer form and placed in IntFeatures.  The character
 * normalization features are matched to each class in
 * templates and the resulting adjustment factors are returned
 * in CharNormArray.  The total length of all blob outlines
 * in baseline normalized units is also returned.
 *
 * @param Blob blob to extract features from
 * @param LineStats statistics about text row blob is in
 * @param Templates used to compute char norm adjustments
 * @param IntFeatures array to fill with integer features
 * @param CharNormArray array to fill with char norm adjustments
 * @param BlobLength length of blob in baseline-normalized units
 *
 * Globals: none
 *
 * @return Number of pico-features returned (0 if an error occurred)
 * @note Exceptions: none
 * @note History: Tue Mar 12 17:55:18 1991, DSJ, Created.
 */
int Classify::GetCharNormFeatures(TBLOB *Blob, LINE_STATS *LineStats, INT_TEMPLATES Templates, INT_FEATURE_ARRAY IntFeatures,
                                  CLASS_NORMALIZATION_ARRAY CharNormArray, inT32 *BlobLength)
{
    return (GetIntCharNormFeatures (Blob, LineStats, Templates, IntFeatures, CharNormArray, BlobLength));
}                              /* GetCharNormFeatures */

/*---------------------------------------------------------------------------*/
/**
 * This routine calls the integer (Hardware) feature
 * extractor if it has not been called before for this blob.
 * The results from the feature extractor are placed into
 * globals so that they can be used in other routines without
 * re-extracting the features.
 * It then copies the baseline features into the IntFeatures
 * array provided by the caller.
 *
 * @param Blob blob to extract features from
 * @param LineStats statistics about text row blob is in
 * @param Templates used to compute char norm adjustments
 * @param IntFeatures array to fill with integer features
 * @param CharNormArray array to fill with dummy char norm adjustments
 * @param BlobLength length of blob in baseline-normalized units
 *
 * Globals:
 * - FeaturesHaveBeenExtracted TRUE if fx has been done
 * - BaselineFeatures holds extracted baseline feat
 * - CharNormFeatures holds extracted char norm feat
 * - FXInfo holds misc. FX info
 *
 * @return Number of features extracted or 0 if an error occured.
 * @note Exceptions: none
 * @note History: Tue May 28 10:40:52 1991, DSJ, Created.
 */
int GetIntBaselineFeatures(TBLOB *Blob, LINE_STATS *LineStats, INT_TEMPLATES Templates, INT_FEATURE_ARRAY IntFeatures, CLASS_NORMALIZATION_ARRAY CharNormArray, inT32 *BlobLength)
{
    Q_UNUSED(LineStats);
    register INT_FEATURE Src, Dest, End;

    if (!FeaturesHaveBeenExtracted)
    {
        FeaturesOK = ExtractIntFeat (Blob, BaselineFeatures, CharNormFeatures, &FXInfo);
        FeaturesHaveBeenExtracted = TRUE;
    }

    if (!FeaturesOK)
    {
        *BlobLength = FXInfo.NumBL;
        return (0);
    }

    for (Src = BaselineFeatures, End = Src + FXInfo.NumBL, Dest = IntFeatures; Src < End; *Dest++ = *Src++);

    ClearCharNormArray(Templates, CharNormArray);
    *BlobLength = FXInfo.NumBL;

    return (FXInfo.NumBL);
}                              /* GetIntBaselineFeatures */

/*---------------------------------------------------------------------------*/
/**
 * This routine calls the integer (Hardware) feature
 * extractor if it has not been called before for this blob.
 *
 * The results from the feature extractor are placed into
 * globals so that they can be used in other routines without
 * re-extracting the features.
 *
 * It then copies the char norm features into the IntFeatures
 * array provided by the caller.
 *
 * @param Blob blob to extract features from
 * @param LineStats statistics about text row blob is in
 * @param Templates used to compute char norm adjustments
 * @param IntFeatures array to fill with integer features
 * @param CharNormArray array to fill with dummy char norm adjustments
 * @param BlobLength length of blob in baseline-normalized units
 *
 * Globals:
 * - FeaturesHaveBeenExtracted TRUE if fx has been done
 * - BaselineFeatures holds extracted baseline feat
 * - CharNormFeatures holds extracted char norm feat
 * - FXInfo holds misc. FX info
 *
 * @return Number of features extracted or 0 if an error occured.
 * @note Exceptions: none
 * @note History: Tue May 28 10:40:52 1991, DSJ, Created.
 */
int Classify::GetIntCharNormFeatures(TBLOB *Blob, LINE_STATS *LineStats, INT_TEMPLATES Templates,
                                     INT_FEATURE_ARRAY IntFeatures, CLASS_NORMALIZATION_ARRAY CharNormArray, inT32 *BlobLength)
{
    register INT_FEATURE Src, Dest, End;
    FEATURE NormFeature;
    FLOAT32 Baseline, Scale;

    if (!FeaturesHaveBeenExtracted)
    {
        FeaturesOK = ExtractIntFeat(Blob, BaselineFeatures, CharNormFeatures, &FXInfo);
        FeaturesHaveBeenExtracted = TRUE;
    }

    if (!FeaturesOK)
    {
        *BlobLength = FXInfo.NumBL;
        return (0);
    }

    for (Src = CharNormFeatures, End = Src + FXInfo.NumCN, Dest = IntFeatures; Src < End; *Dest++ = *Src++);

    NormFeature = NewFeature(&CharNormDesc);
    Baseline = BaselineAt(LineStats, FXInfo.Xmean);
    Scale = ComputeScaleFactor(LineStats);
    NormFeature->Params[CharNormY] = (FXInfo.Ymean - Baseline) * Scale;
    NormFeature->Params[CharNormLength] = FXInfo.Length * Scale / LENGTH_COMPRESSION;
    NormFeature->Params[CharNormRx] = FXInfo.Rx * Scale;
    NormFeature->Params[CharNormRy] = FXInfo.Ry * Scale;
    ComputeIntCharNormArray(NormFeature, Templates, CharNormArray);
    FreeFeature(NormFeature);

    *BlobLength = FXInfo.NumBL;

    return (FXInfo.NumCN);
}                              /* GetIntCharNormFeatures */

/*---------------------------------------------------------------------------*/
/**
 *
 * @param Templates adapted templates to add new config to
 * @param ClassId class id to associate with new config
 * @param NumFeatures number of features in IntFeatures
 * @param Features features describing model for new config
 * @param FloatFeatures floating-pt representation of features
 *
 * Globals:
 * - AllProtosOn mask to enable all protos
 * - AllConfigsOff mask to disable all configs
 * - TempProtoMask defines old protos matched in new config
 *
 * @return The id of the new config created, a negative integer in
 * case of error.
 * @note Exceptions: none
 * @note History: Fri Mar 15 08:49:46 1991, DSJ, Created.
 */
int Classify::MakeNewTemporaryConfig(ADAPT_TEMPLATES Templates, CLASS_ID ClassId, int NumFeatures, INT_FEATURE_ARRAY Features, FEATURE_SET FloatFeatures)
{
    INT_CLASS IClass;
    ADAPT_CLASS Class;
    PROTO_ID OldProtos[MAX_NUM_PROTOS];
    FEATURE_ID BadFeatures[MAX_NUM_INT_FEATURES];
    int NumOldProtos;
    int NumBadFeatures;
    int MaxProtoId, OldMaxProtoId;
    int BlobLength = 0;
    int MaskSize;
    int ConfigId;
    TEMP_CONFIG Config;
    int i;
    int debug_level = NO_DEBUG;

    if (classify_learning_debug_level >= 3)
        debug_level = PRINT_MATCH_SUMMARY | PRINT_FEATURE_MATCHES | PRINT_PROTO_MATCHES;

    IClass = ClassForClassId(Templates->Templates, ClassId);
    Class = Templates->Class[ClassId];

    if (IClass->NumConfigs >= MAX_NUM_CONFIGS)
    {
        ++NumAdaptationsFailed;
        if (classify_learning_debug_level >= 1)     cprintf("Cannot make new temporary config: maximum number exceeded.\n");

        return -1;
    }

    OldMaxProtoId = IClass->NumProtos - 1;

    NumOldProtos = FindGoodProtos(IClass, AllProtosOn, AllConfigsOff, BlobLength, NumFeatures, Features, OldProtos, debug_level);

    MaskSize = WordsInVectorOfSize(MAX_NUM_PROTOS);
    zero_all_bits(TempProtoMask, MaskSize);
    for (i = 0; i < NumOldProtos; i++)
    {
        SET_BIT(TempProtoMask, OldProtos[i]);
    }

    NumBadFeatures = FindBadFeatures(IClass, TempProtoMask, AllConfigsOn, BlobLength, NumFeatures, Features, BadFeatures, debug_level);

    MaxProtoId = MakeNewTempProtos(FloatFeatures, NumBadFeatures, BadFeatures, IClass, Class, TempProtoMask);
    if (MaxProtoId == NO_PROTO)
    {
        ++NumAdaptationsFailed;
        if (classify_learning_debug_level >= 1) cprintf("Cannot make new temp protos: maximum number exceeded.\n");

        return -1;
    }

    ConfigId = AddIntConfig(IClass);
    ConvertConfig(TempProtoMask, ConfigId, IClass);
    Config = NewTempConfig(MaxProtoId);
    TempConfigFor(Class, ConfigId) = Config;
    copy_all_bits(TempProtoMask, Config->Protos, Config->ProtoVectorSize);

    if (classify_learning_debug_level >= 1)
    {
        cprintf("Making new temp config %d using %d old and %d new protos.\n", ConfigId, NumOldProtos, MaxProtoId - OldMaxProtoId);
    }

    return ConfigId;
}                              /* MakeNewTemporaryConfig */

/*---------------------------------------------------------------------------*/
/**
 * This routine finds sets of sequential bad features
 * that all have the same angle and converts each set into
 * a new temporary proto.  The temp proto is added to the
 * proto pruner for IClass, pushed onto the list of temp
 * protos in Class, and added to TempProtoMask.
 *
 * @param Features floating-pt features describing new character
 * @param NumBadFeat number of bad features to turn into protos
 * @param BadFeat feature id's of bad features
 * @param IClass integer class templates to add new protos to
 * @param Class adapted class templates to add new protos to
 * @param TempProtoMask proto mask to add new protos to
 *
 * Globals: none
 *
 * @return Max proto id in class after all protos have been added.
 * Exceptions: none
 * History: Fri Mar 15 11:39:38 1991, DSJ, Created.
 */
PROTO_ID MakeNewTempProtos(FEATURE_SET Features, int NumBadFeat, FEATURE_ID BadFeat[], INT_CLASS IClass, ADAPT_CLASS Class, BIT_VECTOR TempProtoMask)
{
    FEATURE_ID *ProtoStart;
    FEATURE_ID *ProtoEnd;
    FEATURE_ID *LastBad;
    TEMP_PROTO TempProto;
    PROTO Proto;
    FEATURE F1, F2;
    FLOAT32 X1, X2, Y1, Y2;
    FLOAT32 A1, A2, AngleDelta;
    FLOAT32 SegmentLength;
    PROTO_ID Pid;

    for (ProtoStart = BadFeat, LastBad = ProtoStart + NumBadFeat; ProtoStart < LastBad; ProtoStart = ProtoEnd)
    {
        F1 = Features->Features[*ProtoStart];
        X1 = F1->Params[PicoFeatX];
        Y1 = F1->Params[PicoFeatY];
        A1 = F1->Params[PicoFeatDir];

        for (ProtoEnd = ProtoStart + 1, SegmentLength = GetPicoFeatureLength(); ProtoEnd < LastBad; ProtoEnd++, SegmentLength += GetPicoFeatureLength())
        {
            F2 = Features->Features[*ProtoEnd];
            X2 = F2->Params[PicoFeatX];
            Y2 = F2->Params[PicoFeatY];
            A2 = F2->Params[PicoFeatDir];

            AngleDelta = fabs(A1 - A2);
            if (AngleDelta > 0.5)
            {
                AngleDelta = 1.0 - AngleDelta;
            }

            if (AngleDelta > matcher_clustering_max_angle_delta || fabs(X1 - X2) > SegmentLength || fabs(Y1 - Y2) > SegmentLength) break;
        }

        F2 = Features->Features[*(ProtoEnd - 1)];
        X2 = F2->Params[PicoFeatX];
        Y2 = F2->Params[PicoFeatY];
        A2 = F2->Params[PicoFeatDir];

        Pid = AddIntProto(IClass);
        if (Pid == NO_PROTO) return (NO_PROTO);

        TempProto = NewTempProto();
        Proto = &(TempProto->Proto);

        /* compute proto params - NOTE that Y_DIM_OFFSET must be used because
       ConvertProto assumes that the Y dimension varies from -0.5 to 0.5
       instead of the -0.25 to 0.75 used in baseline normalization */
        Proto->Length = SegmentLength;
        Proto->Angle = A1;
        Proto->X = (X1 + X2) / 2.0;
        Proto->Y = (Y1 + Y2) / 2.0 - Y_DIM_OFFSET;
        FillABC(Proto);

        TempProto->ProtoId = Pid;
        SET_BIT(TempProtoMask, Pid);

        ConvertProto(Proto, Pid, IClass);
        AddProtoToProtoPruner(Proto, Pid, IClass);

        Class->TempProtos = push(Class->TempProtos, TempProto);
    }

    return IClass->NumProtos - 1;
}                              /* MakeNewTempProtos */

/*---------------------------------------------------------------------------*/
/**
 *
 * @param Templates current set of adaptive templates
 * @param ClassId class containing config to be made permanent
 * @param ConfigId config to be made permanent
 * @param Blob current blob being adapted to
 * @param LineStats statistics about text line Blob is in
 *
 * Globals: none
 *
 * @note Exceptions: none
 * @note History: Thu Mar 14 15:54:08 1991, DSJ, Created.
 */
void Classify::MakePermanent(ADAPT_TEMPLATES Templates, CLASS_ID ClassId, int ConfigId,TBLOB *Blob, LINE_STATS *LineStats)
{
    UNICHAR_ID *Ambigs;
    TEMP_CONFIG Config;
    ADAPT_CLASS Class;
    PROTO_KEY ProtoKey;

    Class = Templates->Class[ClassId];
    Config = TempConfigFor(Class, ConfigId);

    MakeConfigPermanent(Class, ConfigId);
    if (Class->NumPermConfigs == 0) Templates->NumPermClasses++;
    Class->NumPermConfigs++;

    ProtoKey.Templates = Templates;
    ProtoKey.ClassId = ClassId;
    ProtoKey.ConfigId = ConfigId;
    Class->TempProtos = delete_d(Class->TempProtos, &ProtoKey, MakeTempProtoPerm);
    FreeTempConfig(Config);

    Ambigs = GetAmbiguities(Blob, LineStats, ClassId);
    PermConfigFor(Class, ConfigId) = Ambigs;

    if (classify_learning_debug_level >= 1)
    {
        cprintf("Making config %d permanent with ambiguities '", ConfigId, Ambigs);
        for (UNICHAR_ID *AmbigsPointer = Ambigs; *AmbigsPointer >= 0; ++AmbigsPointer)
        {
            cprintf("%s", unicharset.id_to_unichar(*AmbigsPointer));
        }

        cprintf("'.\n");
    }
}                              /* MakePermanent */

/*---------------------------------------------------------------------------*/
/**
 * This routine converts TempProto to be permanent if
 * its proto id is used by the configuration specified in
 * ProtoKey.
 *
 * @param TempProto temporary proto to compare to key
 * @param ProtoKey defines which protos to make permanent
 *
 * Globals: none
 *
 * @return TRUE if TempProto is converted, FALSE otherwise
 * @note Exceptions: none
 * @note History: Thu Mar 14 18:49:54 1991, DSJ, Created.
 */
int MakeTempProtoPerm(void *item1, void *item2)
{
    ADAPT_CLASS Class;
    TEMP_CONFIG Config;
    TEMP_PROTO TempProto;
    PROTO_KEY *ProtoKey;

    TempProto = (TEMP_PROTO) item1;
    ProtoKey = (PROTO_KEY *) item2;

    Class = ProtoKey->Templates->Class[ProtoKey->ClassId];
    Config = TempConfigFor(Class, ProtoKey->ConfigId);

    if (TempProto->ProtoId > Config->MaxProtoId || !test_bit (Config->Protos, TempProto->ProtoId)) return FALSE;

    MakeProtoPermanent(Class, TempProto->ProtoId);
    AddProtoToClassPruner(&(TempProto->Proto), ProtoKey->ClassId, ProtoKey->Templates->Templates);
    FreeTempProto(TempProto);

    return TRUE;
}                              /* MakeTempProtoPerm */

/*---------------------------------------------------------------------------*/
/**
 * This routine returns the number of blobs in Word.
 *
 * @param Word word to count blobs in
 *
 * Globals: none
 *
 * @return Number of blobs in Word.
 * @note Exceptions: none
 * @note History: Thu Mar 14 08:30:27 1991, DSJ, Created.
 */
int NumBlobsIn(TWERD *Word)
{
    register TBLOB *Blob;
    register int NumBlobs;

    if (Word == NULL) return (0);

    for (Blob = Word->blobs, NumBlobs = 0; Blob != NULL; Blob = Blob->next, NumBlobs++);

    return (NumBlobs);
}                              /* NumBlobsIn */

/*---------------------------------------------------------------------------*/
/**
 * This routine returns the number of OUTER outlines
 * in Blob.
 *
 * @param Blob blob to count outlines in
 *
 * Globals: none
 * @return Number of outer outlines in Blob.
 * @note Exceptions: none
 * @note History: Mon Jun 10 15:46:20 1991, DSJ, Created.
 */
int NumOutlinesInBlob(TBLOB *Blob)
{
    register TESSLINE *Outline;
    register int NumOutlines;

    if (Blob == NULL) return (0);

    for (Outline = Blob->outlines, NumOutlines = 0; Outline != NULL; Outline = Outline->next, NumOutlines++);

    return (NumOutlines);
}                              /* NumOutlinesInBlob */

/*---------------------------------------------------------------------------*/
/**
 * This routine writes the matches in Results to File.
 *
 * @param File open text file to write Results to
 * @param Results match results to write to File
 *
 * Globals: none
 *
 * @note Exceptions: none
 * @note History: Mon Mar 18 09:24:53 1991, DSJ, Created.
 */
void Classify::PrintAdaptiveMatchResults(FILE *File, ADAPT_RESULTS *Results)
{
    Q_UNUSED(File);
    for (int i = 0; i < Results->NumMatches; ++i)
    {
        cprintf("%s(%d) %.2f  ", unicharset.debug_str(Results->Classes[i]).string(), Results->Classes[i], Results->Ratings[Results->Classes[i]] * 100.0);
    }

    printf("\n");
}                              /* PrintAdaptiveMatchResults */

/*---------------------------------------------------------------------------*/
/**
 * This routine steps thru each matching class in Results
 * and removes it from the match list if its rating
 * is worse than the BestRating plus a pad.  In other words,
 * all good matches get moved to the front of the classes
 * array.
 *
 * @param Results contains matches to be filtered
 *
 * Globals:
 * - matcher_bad_match_pad defines a "bad match"
 *
 * @note Exceptions: none
 * @note History: Tue Mar 12 13:51:03 1991, DSJ, Created.
 */
void Classify::RemoveBadMatches(ADAPT_RESULTS *Results)
{
    int Next, NextGood;
    FLOAT32 *Rating = Results->Ratings;
    CLASS_ID *Match = Results->Classes;
    FLOAT32 BadMatchThreshold;
    static const char* romans = "i v x I V X";
    BadMatchThreshold = Results->BestRating + matcher_bad_match_pad;

    if (bln_numericmode)
    {
        UNICHAR_ID unichar_id_one = unicharset.contains_unichar("1") ? unicharset.unichar_to_id("1") : -1;
        UNICHAR_ID unichar_id_zero = unicharset.contains_unichar("0") ? unicharset.unichar_to_id("0") : -1;

        for (Next = NextGood = 0; Next < Results->NumMatches; Next++)
        {
            if (Rating[Match[Next]] <= BadMatchThreshold)
            {
                if (!unicharset.get_isalpha(Match[Next]) || strstr(romans, unicharset.id_to_unichar(Match[Next])) != NULL)
                {
                    Match[NextGood++] = Match[Next];
                }
                else if (unichar_id_one >= 0 && unicharset.eq(Match[Next], "l") && Rating[unichar_id_one] >= BadMatchThreshold)
                {
                    Match[NextGood++] = unichar_id_one;
                    Rating[unichar_id_one] = Rating[unicharset.unichar_to_id("l")];
                }
                else if (unichar_id_zero >= 0 && unicharset.eq(Match[Next], "O") && Rating[unichar_id_zero] >= BadMatchThreshold)
                {
                    Match[NextGood++] = unichar_id_zero;
                    Rating[unichar_id_zero] = Rating[unicharset.unichar_to_id("O")];
                }
            }
        }
    }
    else
    {
        for (Next = NextGood = 0; Next < Results->NumMatches; Next++)
        {
            if (Rating[Match[Next]] <= BadMatchThreshold) Match[NextGood++] = Match[Next];
        }
    }

    Results->NumMatches = NextGood;
}                              /* RemoveBadMatches */

/*----------------------------------------------------------------------------*/
/**
 * This routine steps thru each matching class in Results
 * and removes it from the match list if its rating
 * is worse than the BestRating plus a pad.  In other words,
 * all good matches get moved to the front of the classes
 * array.
 *
 * @parm Results contains matches to be filtered
 *
 * Globals:
 * - matcher_bad_match_pad defines a "bad match"
 *
 * @note Exceptions: none
 * @note History: Tue Mar 12 13:51:03 1991, DSJ, Created.
 */
void Classify::RemoveExtraPuncs(ADAPT_RESULTS *Results)
{
    int Next, NextGood;
    int punc_count;              /*no of garbage characters */
    int digit_count;
    CLASS_ID *Match = Results->Classes;
    /*garbage characters */
    static char punc_chars[] = ". , ; : / ` ~ ' - = \\ | \" ! _ ^";
    static char digit_chars[] = "0 1 2 3 4 5 6 7 8 9";

    punc_count = 0;
    digit_count = 0;
    for (Next = NextGood = 0; Next < Results->NumMatches; Next++)
    {
        if (strstr (punc_chars, unicharset.id_to_unichar(Match[Next])) == NULL)
        {
            if (strstr (digit_chars, unicharset.id_to_unichar(Match[Next])) == NULL)
            {
                Match[NextGood++] = Match[Next];
            }
            else
            {
                if (digit_count < 1) Match[NextGood++] = Match[Next];

                digit_count++;
            }
        }
        else
        {
            if (punc_count < 2) Match[NextGood++] = Match[Next];
            punc_count++;            /*count them */
        }
    }
    Results->NumMatches = NextGood;
}                              /* RemoveExtraPuncs */

/*---------------------------------------------------------------------------*/
/**
 * This routine resets the internal thresholds inside
 * the integer matcher to correspond to the specified
 * threshold.
 *
 * @param Threshold threshold for creating new templates
 *
 * Globals:
 * - matcher_good_threshold default good match rating
 *
 * @note Exceptions: none
 * @note History: Tue Apr  9 08:33:13 1991, DSJ, Created.
 */
void SetAdaptiveThreshold(FLOAT32 Threshold)
{
    if (Threshold == matcher_good_threshold)
    {
        /* the blob was probably classified correctly - use the default rating
       threshold */
        SetProtoThresh (0.9);
        SetFeatureThresh (0.9);
    }
    else
    {
        /* the blob was probably incorrectly classified */
        SetProtoThresh (1.0 - Threshold);
        SetFeatureThresh (1.0 - Threshold);
    }
}                              /* SetAdaptiveThreshold */

/*---------------------------------------------------------------------------*/
/**
 * This routine compares Blob to both sets of templates
 * (adaptive and pre-trained) and then displays debug
 * information for the config which matched best.
 *
 * @param Blob blob to show best matching config for
 * @param LineStats statistics for text line Blob is in
 * @param ClassId class whose configs are to be searched
 * @param AdaptiveOn TRUE if adaptive configs are enabled
 * @param PreTrainedOn TRUE if pretrained configs are enabled
 *
 * Globals:
 * - PreTrainedTemplates built-in training
 * - AdaptedTemplates adaptive templates
 * - AllProtosOn dummy proto mask
 * - AllConfigsOn dummy config mask
 *
 * @note Exceptions: none
 * @note History: Fri Mar 22 08:43:52 1991, DSJ, Created.
 */
void Classify::ShowBestMatchFor(TBLOB *Blob, LINE_STATS *LineStats, CLASS_ID ClassId, BOOL8 AdaptiveOn, BOOL8 PreTrainedOn)
{
    int NumCNFeatures = 0, NumBLFeatures = 0;
    INT_FEATURE_ARRAY CNFeatures, BLFeatures;
    INT_RESULT_STRUCT CNResult, BLResult;
    inT32 BlobLength;
    uinT32 ConfigMask;
    static int next_config = -1;

    if (PreTrainedOn) next_config = -1;

    CNResult.Rating = BLResult.Rating = 2.0;

    if (!LegalClassId (ClassId))
    {
        cprintf ("%d is not a legal class id!!\n", ClassId);
        return;
    }

    uinT8 *CNAdjust = new uinT8[MAX_NUM_CLASSES];
    uinT8 *BLAdjust = new uinT8[MAX_NUM_CLASSES];

    if (PreTrainedOn)
    {
        if (UnusedClassIdIn (PreTrainedTemplates, ClassId))
            cprintf ("No built-in templates for class %d = %s\n", ClassId, unicharset.id_to_unichar(ClassId));
        else
        {
            NumCNFeatures = GetCharNormFeatures (Blob, LineStats, PreTrainedTemplates, CNFeatures, CNAdjust,&BlobLength);
            if (NumCNFeatures <= 0)
            {
                cprintf ("Illegal blob (char norm features)!\n");
            }
            else
            {
                SetCharNormMatch();
                IntegerMatcher (ClassForClassId (PreTrainedTemplates, ClassId), AllProtosOn, AllConfigsOn,
                                BlobLength, NumCNFeatures, CNFeatures, CNAdjust[ClassId], &CNResult, NO_DEBUG);

                cprintf ("Best built-in template match is config %2d (%4.1f) (cn=%d)\n", CNResult.Config, CNResult.Rating * 100.0, CNAdjust[ClassId]);
            }
        }
    }

    if (AdaptiveOn)
    {
        if (UnusedClassIdIn (AdaptedTemplates->Templates, ClassId))
        {
            cprintf ("No AD templates for class %d = %s\n", ClassId, unicharset.id_to_unichar(ClassId));
        }
        else
        {
            NumBLFeatures = GetBaselineFeatures (Blob, LineStats, AdaptedTemplates->Templates, BLFeatures, BLAdjust, &BlobLength);
            if (NumBLFeatures <= 0)
            {
                cprintf ("Illegal blob (baseline features)!\n");
            }
            else
            {
                SetBaseLineMatch();
                IntegerMatcher (ClassForClassId (AdaptedTemplates->Templates, ClassId), AllProtosOn, AllConfigsOn,
                                BlobLength, NumBLFeatures, BLFeatures, BLAdjust[ClassId], &BLResult, NO_DEBUG);
                // AdaptedTemplates->Class[ClassId]->PermProtos,
                // AdaptedTemplates->Class[ClassId]->PermConfigs,



#ifndef SECURE_NAMES
                ADAPT_CLASS Class = AdaptedTemplates->Class[ClassId];
                cprintf ("Best adaptive template match is config %2d (%4.1f) %s\n", BLResult.Config,
                         BLResult.Rating * 100.0, ConfigIsPermanent(Class, BLResult.Config) ? "Perm" : "Temp");
#endif
            }
        }
    }

    cprintf ("\n");
    if (BLResult.Rating < CNResult.Rating)
    {
        if (next_config < 0)
        {
            ConfigMask = 1 << BLResult.Config;
            next_config = 0;
        }
        else
        {
            ConfigMask = 1 << next_config;
            ++next_config;
        }
        classify_norm_method.set_value(baseline);

        SetBaseLineMatch();
        //        AdaptedTemplates->Class[ClassId]->PermProtos,
        IntegerMatcher (ClassForClassId (AdaptedTemplates->Templates, ClassId), AllProtosOn,
                        (BIT_VECTOR) & ConfigMask, BlobLength, NumBLFeatures, BLFeatures, BLAdjust[ClassId], &BLResult, matcher_debug_flags);
        cprintf ("Adaptive template match for config %2d is %4.1f\n", BLResult.Config, BLResult.Rating * 100.0);
    }
    else
    {
        ConfigMask = 1 << CNResult.Config;
        classify_norm_method.set_value(character);

        SetCharNormMatch();
        //xiaofan
        IntegerMatcher (ClassForClassId (PreTrainedTemplates, ClassId), AllProtosOn,
                        (BIT_VECTOR) & ConfigMask, BlobLength, NumCNFeatures, CNFeatures, CNAdjust[ClassId], &CNResult, matcher_debug_flags);
    }

    // Clean up.
    delete[] CNAdjust;
    delete[] BLAdjust;
}                              /* ShowBestMatchFor */
/////////////////////////////////////////////////////////////////adaptmatch////////////////////////////////////////

//////////////////////////////////////////////////////////////svmnode/////////////////////////////////////////////
// Create the empty root menu node. with just a caption. All other nodes should
// be added to this or one of the submenus.
SVMenuNode::SVMenuNode() {
  cmd_event_ = -1;
  text_ = NULL;
  child_ = NULL;
  next_ = NULL;
  parent_ = NULL;
  toggle_value_ = false;
  is_check_box_entry_ = false;
  value_ = NULL;
  description_ = NULL;
}

SVMenuNode::~SVMenuNode() {
  delete[] text_;
//  delete[] description_;
}

// Create a new sub menu node with just a caption.  This is used to create
// nodes which act as parent nodes to other nodes (e.g. submenus).
SVMenuNode* SVMenuNode::AddChild(const char* txt) {
  SVMenuNode* s = new SVMenuNode(-1, txt, false, false, NULL, NULL);
  this->AddChild(s);
  return s;
}

// Create a "normal" menu node which is associated with a command event.
void SVMenuNode::AddChild(const char* txt, int command_event) {
  this->AddChild(new SVMenuNode(command_event, txt, false, false, NULL, NULL));
}

// Create a menu node with an associated value (which might be changed
// through the gui).
void SVMenuNode::AddChild(const char* txt, int command_event,
                          const char* val) {
  this->AddChild(new SVMenuNode(command_event, txt, false, false, val, NULL));
}

// Create a menu node with an associated value and description_.
void SVMenuNode::AddChild(const char* txt, int command_event, const char* val,
                          const char* desc) {
  this->AddChild(new SVMenuNode(command_event, txt, false, false, val, desc));
}

// Create a flag menu node.
void SVMenuNode::AddChild(const char* txt, int command_event, int tv) {
  this->AddChild(new SVMenuNode(command_event, txt, tv, true, NULL, NULL));
}

// Convenience function called from the different constructors to initialize
// the different values of the menu node.
SVMenuNode::SVMenuNode(int command_event, const char* txt,
                       int tv, bool check_box_entry, const char* val,
                       const char* desc) {
  cmd_event_ = command_event;

  text_ = new char[strlen(txt) + 1];
  strncpy(text_, txt, strlen(txt));
  text_[strlen(txt)] = '\0';

  value_ = val;
  description_ = desc;

  child_ = NULL;
  next_ = NULL;
  parent_ = NULL;
  toggle_value_ = tv != 0;
  is_check_box_entry_ = check_box_entry;
}

// Add a child node to this menu node.
void SVMenuNode::AddChild(SVMenuNode* svmn) {
  svmn->parent_ = this;
  // No children yet.
  if (child_ == NULL) {
    child_ = svmn;
  } else {
    SVMenuNode* cur = child_;
    while (cur->next_ != NULL) { cur = cur->next_; }
    cur->next_ = svmn;
  }
}

// Build a menu structure for the server and send the necessary messages.
// Should be called on the root node. If menu_bar is true, a menu_bar menu
// is built (e.g. on top of the window), if it is false a popup menu is
// built which gets shown by right clicking on the window.
// Deletes itself afterwards.
void SVMenuNode::BuildMenu(ScrollView* sv, bool menu_bar) {
  if ((parent_ != NULL) && (menu_bar)) {
    if (is_check_box_entry_) {
      sv->MenuItem(parent_->text_, text_, cmd_event_, toggle_value_);
    } else { sv->MenuItem(parent_->text_, text_, cmd_event_); }
  } else if ((parent_ != NULL) && (!menu_bar)) {
    if (description_ != NULL) { sv->PopupItem(parent_->text_, text_,
                                             cmd_event_, value_, description_);
      } else { sv->PopupItem(parent_->text_, text_); }
  }
  if (child_ != NULL) { child_->BuildMenu(sv, menu_bar); delete child_; }
  if (next_ != NULL) { next_->BuildMenu(sv, menu_bar); delete next_; }
}
//////////////////////////////////////////////////////////////svmnode/////////////////////////////////////////////

/////////////////////////////////////////////////////////////////intproto////////////////////////////////////////
#ifdef __UNIX__
#endif

// Include automatically generated configuration file if running autoconf.
#ifdef HAVE_CONFIG_H
#endif

/* match debug display constants*/
#define DISPLAY_OFFSET  (0.5  * INT_CHAR_NORM_RANGE)
#define PROTO_PRUNER_SCALE  (4.0)

#define INT_DESCENDER (0.0  * INT_CHAR_NORM_RANGE - DISPLAY_OFFSET)
#define INT_BASELINE  (0.25 * INT_CHAR_NORM_RANGE - DISPLAY_OFFSET)
#define INT_XHEIGHT (0.75 * INT_CHAR_NORM_RANGE - DISPLAY_OFFSET)
#define INT_CAPHEIGHT (1.0  * INT_CHAR_NORM_RANGE - DISPLAY_OFFSET)

#define INT_XCENTER (0.5  * INT_CHAR_NORM_RANGE - DISPLAY_OFFSET)
#define INT_YCENTER (0.5  * INT_CHAR_NORM_RANGE - DISPLAY_OFFSET)
#define INT_XRADIUS (0.2  * INT_CHAR_NORM_RANGE)
#define INT_YRADIUS (0.2  * INT_CHAR_NORM_RANGE)
#define INT_MIN_X (- DISPLAY_OFFSET)
#define INT_MIN_Y (- DISPLAY_OFFSET)
#define INT_MAX_X (  DISPLAY_OFFSET)
#define INT_MAX_Y (  DISPLAY_OFFSET)
#define DOUBLE_OFFSET 0.095

/** define pad used to snap near horiz/vertical protos to horiz/vertical */
#define HV_TOLERANCE  (0.0025)   /* approx 0.9 degrees */

typedef enum
{ StartSwitch, EndSwitch, LastSwitch }
SWITCH_TYPE;
#define MAX_NUM_SWITCHES  3

typedef struct
{
  SWITCH_TYPE Type;
  inT8 X, Y;
  inT16 YInit;
  inT16 Delta;
}


FILL_SWITCH;

typedef struct
{
  uinT8 NextSwitch;
  uinT8 AngleStart, AngleEnd;
  inT8 X;
  inT16 YStart, YEnd;
  inT16 StartDelta, EndDelta;
  FILL_SWITCH Switch[MAX_NUM_SWITCHES];
}


TABLE_FILLER;

typedef struct
{
  inT8 X;
  inT8 YStart, YEnd;
  uinT8 AngleStart, AngleEnd;
}


FILL_SPEC;


/* constants for conversion from old inttemp format */
#define OLD_MAX_NUM_CONFIGS      32
#define OLD_WERDS_PER_CONFIG_VEC ((OLD_MAX_NUM_CONFIGS + BITS_PER_WERD - 1) /\
                                  BITS_PER_WERD)

/*-----------------------------------------------------------------------------
            Macros
-----------------------------------------------------------------------------*/
/** macro for performing circular increments of bucket indices */
#define CircularIncrement(i,r)  (((i) < (r) - 1)?((i)++):((i) = 0))

/** macro for mapping floats to ints without bounds checking */
#define MapParam(P,O,N)   (floor (((P) + (O)) * (N)))

/*---------------------------------------------------------------------------
            Private Function Prototypes
----------------------------------------------------------------------------*/
FLOAT32 BucketStart(int Bucket, FLOAT32 Offset, int NumBuckets);

FLOAT32 BucketEnd(int Bucket, FLOAT32 Offset, int NumBuckets);

void DoFill(FILL_SPEC *FillSpec,
            CLASS_PRUNER Pruner,
            register uinT32 ClassMask,
            register uinT32 ClassCount,
            register uinT32 WordIndex);

BOOL8 FillerDone(TABLE_FILLER *Filler);

void FillPPCircularBits (uinT32
                         ParamTable[NUM_PP_BUCKETS][WERDS_PER_PP_VECTOR],
                         int Bit, FLOAT32 Center, FLOAT32 Spread);

void FillPPLinearBits (uinT32 ParamTable[NUM_PP_BUCKETS][WERDS_PER_PP_VECTOR],
                       int Bit, FLOAT32 Center, FLOAT32 Spread);

#ifndef GRAPHICS_DISABLED
CLASS_ID GetClassToDebug(const char *Prompt);
#endif

void GetCPPadsForLevel(int Level,
                       FLOAT32 *EndPad,
                       FLOAT32 *SidePad,
                       FLOAT32 *AnglePad);

C_COL GetMatchColorFor(FLOAT32 Evidence);

void GetNextFill(TABLE_FILLER *Filler, FILL_SPEC *Fill);

void InitTableFiller(FLOAT32 EndPad,
                     FLOAT32 SidePad,
                     FLOAT32 AnglePad,
                     PROTO Proto,
                     TABLE_FILLER *Filler);

#ifndef GRAPHICS_DISABLED
void RenderIntFeature(void *window, INT_FEATURE Feature, C_COL Color);

void RenderIntProto(void *window,
                    INT_CLASS Class,
                    PROTO_ID ProtoId,
                    C_COL Color);
#endif

int TruncateParam(FLOAT32 Param, int Min, int Max, char *Id);

/*-----------------------------------------------------------------------------
        Global Data Definitions and Declarations
-----------------------------------------------------------------------------*/

/* global display lists used to display proto and feature match information*/
ScrollView *IntMatchWindow = NULL;
ScrollView *FeatureDisplayWindow = NULL;
ScrollView *ProtoDisplayWindow = NULL;

/*-----------------------------------------------------------------------------
        Variables
-----------------------------------------------------------------------------*/

/* control knobs */
INT_VAR(classify_num_cp_levels, 3, "Number of Class Pruner Levels");
double_VAR(classify_cp_angle_pad_loose, 45.0,
           "Class Pruner Angle Pad Loose");
double_VAR(classify_cp_angle_pad_medium, 20.0,
           "Class Pruner Angle Pad Medium");
double_VAR(classify_cp_angle_pad_tight, 10.0,
           "CLass Pruner Angle Pad Tight");
double_VAR(classify_cp_end_pad_loose, 0.5, "Class Pruner End Pad Loose");
double_VAR(classify_cp_end_pad_medium, 0.5, "Class Pruner End Pad Medium");
double_VAR(classify_cp_end_pad_tight, 0.5, "Class Pruner End Pad Tight");
double_VAR(classify_cp_side_pad_loose, 2.5, "Class Pruner Side Pad Loose");
double_VAR(classify_cp_side_pad_medium, 1.2, "Class Pruner Side Pad Medium");
double_VAR(classify_cp_side_pad_tight, 0.6, "Class Pruner Side Pad Tight");
double_VAR(classify_pp_angle_pad, 45.0, "Proto Pruner Angle Pad");
double_VAR(classify_pp_end_pad, 0.5, "Proto Prune End Pad");
double_VAR(classify_pp_side_pad, 2.5, "Proto Pruner Side Pad");

/*-----------------------------------------------------------------------------
              Public Code
-----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/**
 * This routine adds a new class structure to a set of
 * templates. Classes have to be added to Templates in
 * the order of increasing ClassIds.
 *
 * @param Templates templates to add new class to
 * @param ClassId   class id to associate new class with
 * @param Class   class data structure to add to templates
 *
 * Globals: none
 *
 * @note Exceptions: none
 * @note History: Mon Feb 11 11:52:08 1991, DSJ, Created.
 */
void AddIntClass(INT_TEMPLATES Templates, CLASS_ID ClassId, INT_CLASS Class) {
  int Pruner;
  uinT32 *Word;

  assert (LegalClassId (ClassId));
  if (ClassId != Templates->NumClasses) {
    fprintf(stderr, "Please make sure that classes are added to templates");
    fprintf(stderr, " in increasing order of ClassIds\n");
    exit(1);
  }
  ClassForClassId (Templates, ClassId) = Class;
  Templates->NumClasses++;

  if (Templates->NumClasses > MaxNumClassesIn (Templates)) {
    Pruner = Templates->NumClassPruners++;
    Templates->ClassPruner[Pruner] =
      (CLASS_PRUNER) Emalloc (sizeof (CLASS_PRUNER_STRUCT));

    for (Word = reinterpret_cast<uinT32*>(Templates->ClassPruner[Pruner]);
         Word < reinterpret_cast<uinT32*>(Templates->ClassPruner[Pruner]) +
                WERDS_PER_CP;
         *Word++ = 0);
  }
}                                /* AddIntClass */


/*---------------------------------------------------------------------------*/
/**
 * This routine returns the index of the next free config
 * in Class.
 *
 * @param Class class to add new configuration to
 *
 * Globals: none
 *
 * @return Index of next free config.
 * @note Exceptions: none
 * @note History: Mon Feb 11 14:44:40 1991, DSJ, Created.
 */
int AddIntConfig(INT_CLASS Class) {
  int Index;

  assert(Class->NumConfigs < MAX_NUM_CONFIGS);

  Index = Class->NumConfigs++;
  Class->ConfigLengths[Index] = 0;
  return Index;
}                                /* AddIntConfig */


/*---------------------------------------------------------------------------*/
/**
 * This routine allocates the next free proto in Class and
 * returns its index.
 *
 * @param Class class to add new proto to
 *
 * Globals: none
 *
 * @return Proto index of new proto.
 * @note Exceptions: none
 * @note History: Mon Feb 11 13:26:41 1991, DSJ, Created.
 */
int AddIntProto(INT_CLASS Class) {
  int Index;
  int ProtoSetId;
  PROTO_SET ProtoSet;
  INT_PROTO Proto;
  register uinT32 *Word;

  if (Class->NumProtos >= MAX_NUM_PROTOS)
    return (NO_PROTO);

  Index = Class->NumProtos++;

  if (Class->NumProtos > MaxNumIntProtosIn(Class)) {
    ProtoSetId = Class->NumProtoSets++;

    ProtoSet = (PROTO_SET) Emalloc(sizeof(PROTO_SET_STRUCT));
    Class->ProtoSets[ProtoSetId] = ProtoSet;
    for (Word = reinterpret_cast<uinT32*>(ProtoSet->ProtoPruner);
         Word < reinterpret_cast<uinT32*>(ProtoSet->ProtoPruner) + WERDS_PER_PP;
         *Word++ = 0);

    /* reallocate space for the proto lengths and install in class */
    Class->ProtoLengths =
      (uinT8 *)Erealloc(Class->ProtoLengths,
                        MaxNumIntProtosIn(Class) * sizeof(uinT8));
  }

  /* initialize proto so its length is zero and it isn't in any configs */
  Class->ProtoLengths[Index] = 0;
  Proto = ProtoForProtoId (Class, Index);
  for (Word = Proto->Configs;
       Word < Proto->Configs + WERDS_PER_CONFIG_VEC; *Word++ = 0);

  return (Index);

}                                /* AddIntProto */


/*---------------------------------------------------------------------------*/
void AddProtoToClassPruner (PROTO Proto, CLASS_ID ClassId,
                            INT_TEMPLATES Templates)
/*
 ** Parameters:
 **   Proto   floating-pt proto to add to class pruner
 **   ClassId   class id corresponding to Proto
 **   Templates set of templates containing class pruner
 ** Globals:
 **   classify_num_cp_levels number of levels used in the class pruner
 ** Operation: This routine adds Proto to the class pruning tables
 **   for the specified class in Templates.
 ** Return: none
 ** Exceptions: none
 ** History: Wed Feb 13 08:49:54 1991, DSJ, Created.
 */
#define MAX_LEVEL     2
{
  CLASS_PRUNER Pruner;
  uinT32 ClassMask;
  uinT32 ClassCount;
  uinT32 WordIndex;
  int Level;
  FLOAT32 EndPad, SidePad, AnglePad;
  TABLE_FILLER TableFiller;
  FILL_SPEC FillSpec;

  Pruner = CPrunerFor (Templates, ClassId);
  WordIndex = CPrunerWordIndexFor (ClassId);
  ClassMask = CPrunerMaskFor (MAX_LEVEL, ClassId);

  for (Level = classify_num_cp_levels - 1; Level >= 0; Level--) {
    GetCPPadsForLevel(Level, &EndPad, &SidePad, &AnglePad);
    ClassCount = CPrunerMaskFor (Level, ClassId);
    InitTableFiller(EndPad, SidePad, AnglePad, Proto, &TableFiller);

    while (!FillerDone (&TableFiller)) {
      GetNextFill(&TableFiller, &FillSpec);
      DoFill(&FillSpec, Pruner, ClassMask, ClassCount, WordIndex);
    }
  }
}                                /* AddProtoToClassPruner */


/*---------------------------------------------------------------------------*/
void AddProtoToProtoPruner(PROTO Proto, int ProtoId, INT_CLASS Class) {
/*
 ** Parameters:
 **   Proto floating-pt proto to be added to proto pruner
 **   ProtoId id of proto
 **   Class integer class that contains desired proto pruner
 ** Globals: none
 ** Operation: This routine updates the proto pruner lookup tables
 **   for Class to include a new proto identified by ProtoId
 **   and described by Proto.
 ** Return: none
 ** Exceptions: none
 ** History: Fri Feb  8 13:07:19 1991, DSJ, Created.
 */
  FLOAT32 Angle, X, Y, Length;
  FLOAT32 Pad;
  int Index;
  PROTO_SET ProtoSet;

  if (ProtoId >= Class->NumProtos)
    cprintf("AddProtoToProtoPruner:assert failed: %d < %d",
            ProtoId, Class->NumProtos);
  assert(ProtoId < Class->NumProtos);

  Index = IndexForProto (ProtoId);
  ProtoSet = Class->ProtoSets[SetForProto (ProtoId)];

  Angle = Proto->Angle;
#ifndef __MSW32__
  assert(!isnan(Angle));
#endif

  FillPPCircularBits (ProtoSet->ProtoPruner[PRUNER_ANGLE], Index,
                      Angle + ANGLE_SHIFT, classify_pp_angle_pad / 360.0);

  Angle *= 2.0 * PI;
  Length = Proto->Length;

  X = Proto->X + X_SHIFT;
  Pad = MAX (fabs (cos (Angle)) * (Length / 2.0 +
                                   classify_pp_end_pad *
                                   GetPicoFeatureLength()),
             fabs (sin (Angle)) * (classify_pp_side_pad *
                                   GetPicoFeatureLength ()));

  FillPPLinearBits (ProtoSet->ProtoPruner[PRUNER_X], Index, X, Pad);

  Y = Proto->Y + Y_SHIFT;
  Pad = MAX (fabs (sin (Angle)) * (Length / 2.0 +
                                   classify_pp_end_pad *
                                   GetPicoFeatureLength ()),
             fabs (cos (Angle)) * (classify_pp_side_pad *
                                   GetPicoFeatureLength ()));

  FillPPLinearBits(ProtoSet->ProtoPruner[PRUNER_Y], Index, Y, Pad);
}                                /* AddProtoToProtoPruner */


/*---------------------------------------------------------------------------*/
int BucketFor(FLOAT32 Param, FLOAT32 Offset, int NumBuckets) {
/*
 ** Parameters:
 **   Param   parameter value to map into a bucket number
 **   Offset    amount to shift param before mapping it
 **   NumBuckets  number of buckets to map param into
 ** Globals: none
 ** Operation: This routine maps a parameter value into a bucket between
 **   0 and NumBuckets-1.  Offset is added to the parameter
 **   before mapping it.  Values which map to buckets outside
 **   the range are truncated to fit within the range.  Mapping
 **   is done by truncating rather than rounding.
 ** Return: Bucket number corresponding to Param + Offset.
 ** Exceptions: none
 ** History: Thu Feb 14 13:24:33 1991, DSJ, Created.
 */
  return ClipToRange(static_cast<int>(MapParam(Param, Offset, NumBuckets)),
                     0, NumBuckets - 1);
}                                /* BucketFor */


/*---------------------------------------------------------------------------*/
int CircBucketFor(FLOAT32 Param, FLOAT32 Offset, int NumBuckets) {
/*
 ** Parameters:
 **   Param   parameter value to map into a circular bucket
 **   Offset    amount to shift param before mapping it
 **   NumBuckets  number of buckets to map param into
 ** Globals: none
 ** Operation: This routine maps a parameter value into a bucket between
 **   0 and NumBuckets-1.  Offset is added to the parameter
 **   before mapping it.  Values which map to buckets outside
 **   the range are wrapped to a new value in a circular fashion.
 **   Mapping is done by truncating rather than rounding.
 ** Return: Bucket number corresponding to Param + Offset.
 ** Exceptions: none
 ** History: Thu Feb 14 13:24:33 1991, DSJ, Created.
 */
  int Bucket;

  Bucket = static_cast<int>(MapParam(Param, Offset, NumBuckets));
  if (Bucket < 0)
    Bucket += NumBuckets;
  else if (Bucket >= NumBuckets)
    Bucket -= NumBuckets;
  return Bucket;
}                                /* CircBucketFor */


/*---------------------------------------------------------------------------*/
#ifndef GRAPHICS_DISABLED
void UpdateMatchDisplay() {
/*
 ** Parameters: none
 ** Globals:
 **   FeatureShapes display list for features
 **   ProtoShapes display list for protos
 ** Operation: This routine clears the global feature and proto
 **   display lists.
 ** Return: none
 ** Exceptions: none
 ** History: Thu Mar 21 15:40:19 1991, DSJ, Created.
 */
  if (IntMatchWindow != NULL)
    c_make_current(IntMatchWindow);
}                                /* ClearMatchDisplay */
#endif

/*---------------------------------------------------------------------------*/
void ConvertConfig(BIT_VECTOR Config, int ConfigId, INT_CLASS Class) {
/*
 ** Parameters:
 **   Config    config to be added to class
 **   ConfigId  id to be used for new config
 **   Class   class to add new config to
 ** Globals: none
 ** Operation: This operation updates the config vectors of all protos
 **   in Class to indicate that the protos with 1's in Config
 **   belong to a new configuration identified by ConfigId.
 **   It is assumed that the length of the Config bit vector is
 **   equal to the number of protos in Class.
 ** Return: none
 ** Exceptions: none
 ** History: Mon Feb 11 14:57:31 1991, DSJ, Created.
 */
  int ProtoId;
  INT_PROTO Proto;
  int TotalLength;

  for (ProtoId = 0, TotalLength = 0;
    ProtoId < Class->NumProtos; ProtoId++) {
    if (test_bit(Config, ProtoId)) {
      Proto = ProtoForProtoId(Class, ProtoId);
      SET_BIT(Proto->Configs, ConfigId);
      TotalLength += Class->ProtoLengths[ProtoId];
    }
  }
  Class->ConfigLengths[ConfigId] = TotalLength;
}                                /* ConvertConfig */


/*---------------------------------------------------------------------------*/
void ConvertProto(PROTO Proto, int ProtoId, INT_CLASS Class) {
/*
 ** Parameters:
 **   Proto floating-pt proto to be converted to integer format
 **   ProtoId id of proto
 **   Class integer class to add converted proto to
 ** Globals: none
 ** Operation: This routine converts Proto to integer format and
 **   installs it as ProtoId in Class.
 ** Return: none
 ** Exceptions: none
 ** History: Fri Feb  8 11:22:43 1991, DSJ, Created.
 */
  INT_PROTO P;
  FLOAT32 Param;

  assert(ProtoId < Class->NumProtos);

  P = ProtoForProtoId(Class, ProtoId);

  Param = Proto->A * 128;
  P->A = TruncateParam(Param, -128, 127, NULL);

  Param = -Proto->B * 256;
  P->B = TruncateParam(Param, 0, 255, NULL);

  Param = Proto->C * 128;
  P->C = TruncateParam(Param, -128, 127, NULL);

  Param = Proto->Angle * 256;
  if (Param < 0 || Param >= 256)
    P->Angle = 0;
  else
    P->Angle = (uinT8) Param;

  /* round proto length to nearest integer number of pico-features */
  Param = (Proto->Length / GetPicoFeatureLength()) + 0.5;
  Class->ProtoLengths[ProtoId] = TruncateParam(Param, 1, 255, NULL);
  if (classify_learning_debug_level >= 2)
    cprintf("Converted ffeat to (A=%d,B=%d,C=%d,L=%d)",
            P->A, P->B, P->C, Class->ProtoLengths[ProtoId]);
}                                /* ConvertProto */


/*---------------------------------------------------------------------------*/
INT_TEMPLATES Classify::CreateIntTemplates(CLASSES FloatProtos,
                                           const UNICHARSET&
                                           target_unicharset) {
/*
 ** Parameters:
 **   FloatProtos prototypes in old floating pt format
 ** Globals: none
 ** Operation: This routine converts from the old floating point format
 **   to the new integer format.
 ** Return: New set of training templates in integer format.
 ** Exceptions: none
 ** History: Thu Feb  7 14:40:42 1991, DSJ, Created.
 */
  INT_TEMPLATES IntTemplates;
  CLASS_TYPE FClass;
  INT_CLASS IClass;
  int ClassId;
  int ProtoId;
  int ConfigId;

  IntTemplates = NewIntTemplates();

  for (ClassId = 0; ClassId < target_unicharset.size(); ClassId++) {
    FClass = &(FloatProtos[ClassId]);
    if (FClass->NumProtos == 0 && FClass->NumConfigs == 0 &&
        strcmp(target_unicharset.id_to_unichar(ClassId), " ") != 0) {
      cprintf("Warning: no protos/configs for %s in CreateIntTemplates()\n",
              target_unicharset.id_to_unichar(ClassId));
    }
    assert(UnusedClassIdIn(IntTemplates, ClassId));
    IClass = NewIntClass(FClass->NumProtos, FClass->NumConfigs);
    FontSet fs;
    fs.size = FClass->font_set.size();
    fs.configs = new int[fs.size];
    for (int i = 0; i < fs.size; ++i) {
      fs.configs[i] = FClass->font_set.get(i);
    }
    if (this->fontset_table_.contains(fs)) {
      IClass->font_set_id = this->fontset_table_.get_id(fs);
      delete[] fs.configs;
    } else {
      IClass->font_set_id = this->fontset_table_.push_back(fs);
    }
    AddIntClass(IntTemplates, ClassId, IClass);

    for (ProtoId = 0; ProtoId < FClass->NumProtos; ProtoId++) {
      AddIntProto(IClass);
      ConvertProto(ProtoIn(FClass, ProtoId), ProtoId, IClass);
      AddProtoToProtoPruner(ProtoIn(FClass, ProtoId), ProtoId, IClass);
      AddProtoToClassPruner(ProtoIn(FClass, ProtoId), ClassId, IntTemplates);
    }

    for (ConfigId = 0; ConfigId < FClass->NumConfigs; ConfigId++) {
      AddIntConfig(IClass);
      ConvertConfig(FClass->Configurations[ConfigId], ConfigId, IClass);
    }
  }
  return (IntTemplates);
}                                /* CreateIntTemplates */


/*---------------------------------------------------------------------------*/
#ifndef GRAPHICS_DISABLED
void DisplayIntFeature(INT_FEATURE Feature, FLOAT32 Evidence) {
/*
 ** Parameters:
 **   Feature   pico-feature to be displayed
 **   Evidence  best evidence for this feature (0-1)
 ** Globals:
 **   FeatureShapes global display list for features
 ** Operation: This routine renders the specified feature into a
 **   global display list.
 ** Return: none
 ** Exceptions: none
 ** History: Thu Mar 21 14:45:04 1991, DSJ, Created.
 */
  C_COL Color;

  Color = GetMatchColorFor(Evidence);
  RenderIntFeature(IntMatchWindow, Feature, Color);
  if (FeatureDisplayWindow) {
    RenderIntFeature(FeatureDisplayWindow, Feature, Color);
  }
}                                /* DisplayIntFeature */


/*---------------------------------------------------------------------------*/
void DisplayIntProto(INT_CLASS Class, PROTO_ID ProtoId, FLOAT32 Evidence) {
/*
 ** Parameters:
 **   Class   class to take proto from
 **   ProtoId   id of proto in Class to be displayed
 **   Evidence  total evidence for proto (0-1)
 ** Globals:
 **   ProtoShapes global display list for protos
 ** Operation: This routine renders the specified proto into a
 **   global display list.
 ** Return: none
 ** Exceptions: none
 ** History: Thu Mar 21 14:45:04 1991, DSJ, Created.
 */
  C_COL Color;

  Color = GetMatchColorFor(Evidence);
  RenderIntProto(IntMatchWindow, Class, ProtoId, Color);
  if (ProtoDisplayWindow) {
    RenderIntProto(ProtoDisplayWindow, Class, ProtoId, Color);
  }
}                                /* DisplayIntProto */
#endif

/*---------------------------------------------------------------------------*/
INT_CLASS NewIntClass(int MaxNumProtos, int MaxNumConfigs) {
/*
 ** Parameters:
 **   MaxNumProtos  number of protos to allocate space for
 **   MaxNumConfigs number of configs to allocate space for
 ** Globals: none
 ** Operation: This routine creates a new integer class data structure
 **   and returns it.  Sufficient space is allocated
 **   to handle the specified number of protos and configs.
 ** Return: New class created.
 ** Exceptions: none
 ** History: Fri Feb  8 10:51:23 1991, DSJ, Created.
 */
  INT_CLASS Class;
  PROTO_SET ProtoSet;
  int i;
  register uinT32 *Word;

  assert(MaxNumConfigs <= MAX_NUM_CONFIGS);

  Class = (INT_CLASS) Emalloc(sizeof(INT_CLASS_STRUCT));
  Class->NumProtoSets = ((MaxNumProtos + PROTOS_PER_PROTO_SET - 1) /
                            PROTOS_PER_PROTO_SET);

  assert(Class->NumProtoSets <= MAX_NUM_PROTO_SETS);

  Class->NumProtos = 0;
  Class->NumConfigs = 0;

  for (i = 0; i < Class->NumProtoSets; i++) {
    /* allocate space for a proto set, install in class, and initialize */
    ProtoSet = (PROTO_SET) Emalloc(sizeof(PROTO_SET_STRUCT));
    Class->ProtoSets[i] = ProtoSet;
    for (Word = reinterpret_cast<uinT32*>(ProtoSet->ProtoPruner);
         Word < reinterpret_cast<uinT32*>(ProtoSet->ProtoPruner) + WERDS_PER_PP;
         *Word++ = 0);

    /* allocate space for the proto lengths and install in class */
  }
  if (MaxNumIntProtosIn (Class) > 0) {
    Class->ProtoLengths =
      (uinT8 *)Emalloc(MaxNumIntProtosIn (Class) * sizeof (uinT8));
  }

  return (Class);

}                                /* NewIntClass */


/*-------------------------------------------------------------------------*/
void free_int_class(INT_CLASS int_class) {
  int i;

  for (i = 0; i < int_class->NumProtoSets; i++) {
    Efree (int_class->ProtoSets[i]);
  }
  if (int_class->ProtoLengths != NULL) {
    Efree (int_class->ProtoLengths);
  }
  Efree(int_class);
}


/*---------------------------------------------------------------------------*/
INT_TEMPLATES NewIntTemplates() {
/*
 ** Parameters: none
 ** Globals: none
 ** Operation: This routine allocates a new set of integer templates
 **   initialized to hold 0 classes.
 ** Return: The integer templates created.
 ** Exceptions: none
 ** History: Fri Feb  8 08:38:51 1991, DSJ, Created.
 */
  INT_TEMPLATES T;
  int i;

  T = (INT_TEMPLATES) Emalloc (sizeof (INT_TEMPLATES_STRUCT));
  T->NumClasses = 0;
  T->NumClassPruners = 0;

  for (i = 0; i < MAX_NUM_CLASSES; i++)
    ClassForClassId (T, i) = NULL;

  return (T);
}                                /* NewIntTemplates */


/*---------------------------------------------------------------------------*/
void free_int_templates(INT_TEMPLATES templates) {
  int i;

  for (i = 0; i < templates->NumClasses; i++)
    free_int_class(templates->Class[i]);
  for (i = 0; i < templates->NumClassPruners; i++)
    Efree(templates->ClassPruner[i]);
  Efree(templates);
}


/*---------------------------------------------------------------------------*/
// Code to read/write Classify::font*table structures.
namespace {
bool read_info(FILE* f, FontInfo* fi, bool swap) {
  inT32 size;
  if (fread(&size, sizeof(size), 1, f) != 1) return false;
  if (swap)
    Reverse32(&size);
  char* font_name = new char[size + 1];
  fi->name = font_name;
  if (fread(font_name, sizeof(*font_name), size, f) != (size_t)size) return false;
  font_name[size] = '\0';
  if (fread(&fi->properties, sizeof(fi->properties), 1, f) != 1) return false;
  if (swap)
    Reverse32(&fi->properties);
  return true;
}

bool write_info(FILE* f, const FontInfo& fi) {
  inT32 size = strlen(fi.name);
  if (fwrite(&size, sizeof(size), 1, f) != 1) return false;
  if (fwrite(fi.name, sizeof(*fi.name), size, f) != (size_t)size) return false;
  if (fwrite(&fi.properties, sizeof(fi.properties), 1, f) != 1) return false;
  return true;
}

bool read_set(FILE* f, FontSet* fs, bool swap) {
  if (fread(&fs->size, sizeof(fs->size), 1, f) != 1) return false;
  if (swap)
    Reverse32(&fs->size);
  fs->configs = new int[fs->size];
  for (int i = 0; i < fs->size; ++i) {
    if (fread(&fs->configs[i], sizeof(fs->configs[i]), 1, f) != 1) return false;
    if (swap)
      Reverse32(&fs->configs[i]);
  }
  return true;
}

bool write_set(FILE* f, const FontSet& fs) {
  if (fwrite(&fs.size, sizeof(fs.size), 1, f) != 1) return false;
  for (int i = 0; i < fs.size; ++i) {
    if (fwrite(&fs.configs[i], sizeof(fs.configs[i]), 1, f) != 1) return false;
  }
  return true;
}

}  // namespace.

INT_TEMPLATES Classify::ReadIntTemplates(FILE *File) {
/*
 ** Parameters:
 **   File    open file to read templates from
 ** Globals: none
 ** Operation: This routine reads a set of integer templates from
 **   File.  File must already be open and must be in the
 **   correct binary format.
 ** Return: Pointer to integer templates read from File.
 ** Exceptions: none
 ** History: Wed Feb 27 11:48:46 1991, DSJ, Created.
 */
  int i, j, w, x, y, z;
  BOOL8 swap;
  int nread;
  int unicharset_size;
  int version_id = 0;
  INT_TEMPLATES Templates;
  CLASS_PRUNER Pruner;
  INT_CLASS Class;
  uinT8 *Lengths;
  PROTO_SET ProtoSet;

  /* variables for conversion from older inttemp formats */
  int b, bit_number, last_cp_bit_number, new_b, new_i, new_w;
  CLASS_ID class_id, max_class_id;
  inT16 *IndexFor = new inT16[MAX_NUM_CLASSES];
  CLASS_ID *ClassIdFor = new CLASS_ID[MAX_NUM_CLASSES];
  CLASS_PRUNER *TempClassPruner = new CLASS_PRUNER[MAX_NUM_CLASS_PRUNERS];
  uinT32 SetBitsForMask =           // word with NUM_BITS_PER_CLASS
    (1 << NUM_BITS_PER_CLASS) - 1;  // set starting at bit 0
  uinT32 Mask, NewMask, ClassBits;
  uinT32 *Word;
  int MaxNumConfigs = MAX_NUM_CONFIGS;
  int WerdsPerConfigVec = WERDS_PER_CONFIG_VEC;

  /* first read the high level template struct */
  Templates = NewIntTemplates();
  // Read Templates in parts for 64 bit compatibility.
  if (fread(&unicharset_size, sizeof(int), 1, File) != 1)
    cprintf("Bad read of inttemp!\n");
  if (fread(&Templates->NumClasses,
            sizeof(Templates->NumClasses), 1, File) != 1 ||
      fread(&Templates->NumClassPruners,
            sizeof(Templates->NumClassPruners), 1, File) != 1)
    cprintf("Bad read of inttemp!\n");
  // Swap status is determined automatically.
  swap = Templates->NumClassPruners < 0 ||
    Templates->NumClassPruners > MAX_NUM_CLASS_PRUNERS;
  if (swap) {
    Reverse32(&Templates->NumClassPruners);
    Reverse32(&Templates->NumClasses);
    Reverse32(&unicharset_size);
  }
  if (Templates->NumClasses < 0) {
    // This file has a version id!
    version_id = -Templates->NumClasses;
    if (fread(&Templates->NumClasses, sizeof(Templates->NumClasses),
              1, File) != 1)
      cprintf("Bad read of inttemp!\n");
    if (swap)
      Reverse32(&Templates->NumClasses);
  }

  if (version_id < 3) {
    MaxNumConfigs = OLD_MAX_NUM_CONFIGS;
    WerdsPerConfigVec = OLD_WERDS_PER_CONFIG_VEC;
  }

  if (version_id < 2) {
    for (i = 0; i < unicharset_size; ++i) {
      if (fread(&IndexFor[i], sizeof(inT16), 1, File) != 1)
        cprintf("Bad read of inttemp!\n");
    }
    for (i = 0; i < Templates->NumClasses; ++i) {
      if (fread(&ClassIdFor[i], sizeof(CLASS_ID), 1, File) != 1)
        cprintf("Bad read of inttemp!\n");
    }
    if (swap) {
      for (i = 0; i < Templates->NumClasses; i++)
        Reverse16(&IndexFor[i]);
      for (i = 0; i < Templates->NumClasses; i++)
        Reverse32(&ClassIdFor[i]);
    }
  }

  /* then read in the class pruners */
  for (i = 0; i < Templates->NumClassPruners; i++) {
    Pruner = (CLASS_PRUNER) Emalloc(sizeof(CLASS_PRUNER_STRUCT));
    if ((nread =
         fread((char *) Pruner, 1, sizeof(CLASS_PRUNER_STRUCT),
                File)) != sizeof(CLASS_PRUNER_STRUCT))
      cprintf("Bad read of inttemp!\n");
    if (swap) {
      for (x = 0; x < NUM_CP_BUCKETS; x++) {
        for (y = 0; y < NUM_CP_BUCKETS; y++) {
          for (z = 0; z < NUM_CP_BUCKETS; z++) {
            for (w = 0; w < (int)WERDS_PER_CP_VECTOR; w++) {
              Reverse32(&Pruner[x][y][z][w]);
            }
          }
        }
      }
    }
    if (version_id < 2) {
      TempClassPruner[i] = Pruner;
    } else {
      Templates->ClassPruner[i] = Pruner;
    }
  }

  /* fix class pruners if they came from an old version of inttemp */
  if (version_id < 2) {
    // Allocate enough class pruners to cover all the class ids.
    max_class_id = 0;
    for (i = 0; i < Templates->NumClasses; i++)
      if (ClassIdFor[i] > max_class_id)
        max_class_id = ClassIdFor[i];
    for (i = 0; i <= CPrunerIdFor(max_class_id); i++) {
      Templates->ClassPruner[i] =
        (CLASS_PRUNER) Emalloc(sizeof(CLASS_PRUNER_STRUCT));
      for (Word = (uinT32 *) (Templates->ClassPruner[i]);
           Word < (uinT32 *) (Templates->ClassPruner[i]) + WERDS_PER_CP;
           *Word++ = 0);
    }
    // Convert class pruners from the old format (indexed by class index)
    // to the new format (indexed by class id).
    last_cp_bit_number = NUM_BITS_PER_CLASS * Templates->NumClasses - 1;
    for (i = 0; i < Templates->NumClassPruners; i++) {
      for (x = 0; x < NUM_CP_BUCKETS; x++)
        for (y = 0; y < NUM_CP_BUCKETS; y++)
          for (z = 0; z < NUM_CP_BUCKETS; z++)
            for (w = 0; w < (int)WERDS_PER_CP_VECTOR; w++) {
              if (TempClassPruner[i][x][y][z][w] == 0)
                continue;
              for (b = 0; b < (int)BITS_PER_WERD; b += NUM_BITS_PER_CLASS) {
                bit_number = i * BITS_PER_CP_VECTOR + w * BITS_PER_WERD + b;
                if (bit_number > last_cp_bit_number)
                  break; // the rest of the bits in this word are not used
                class_id = ClassIdFor[bit_number / NUM_BITS_PER_CLASS];
                // Single out NUM_BITS_PER_CLASS bits relating to class_id.
                Mask = SetBitsForMask << b;
                ClassBits = TempClassPruner[i][x][y][z][w] & Mask;
                // Move these bits to the new position in which they should
                // appear (indexed corresponding to the class_id).
                new_i = CPrunerIdFor(class_id);
                new_w = CPrunerWordIndexFor(class_id);
                new_b = CPrunerBitIndexFor(class_id) * NUM_BITS_PER_CLASS;
                if (new_b > b) {
                  ClassBits <<= (new_b - b);
                } else {
                  ClassBits >>= (b - new_b);
                }
                // Copy bits relating to class_id to the correct position
                // in Templates->ClassPruner.
                NewMask = SetBitsForMask << new_b;
                Templates->ClassPruner[new_i][x][y][z][new_w] &= ~NewMask;
                Templates->ClassPruner[new_i][x][y][z][new_w] |= ClassBits;
              }
            }
    }
    for (i = 0; i < Templates->NumClassPruners; i++) {
      Efree (TempClassPruner[i]);
    }
  }

  /* then read in each class */
  for (i = 0; i < Templates->NumClasses; i++) {
    /* first read in the high level struct for the class */
    Class = (INT_CLASS) Emalloc (sizeof (INT_CLASS_STRUCT));
    if (fread(&Class->NumProtos, sizeof(Class->NumProtos), 1, File) != 1 ||
        fread(&Class->NumProtoSets, sizeof(Class->NumProtoSets), 1, File) != 1 ||
        fread(&Class->NumConfigs, sizeof(Class->NumConfigs), 1, File) != 1)
      cprintf ("Bad read of inttemp!\n");
    if (version_id == 0) {
      // Only version 0 writes 5 pointless pointers to the file.
      for (j = 0; j < 5; ++j) {
        int junk;
        if (fread(&junk, sizeof(junk), 1, File) != 1)
          cprintf ("Bad read of inttemp!\n");
      }
    }
    if (version_id < 4) {
      for (j = 0; j < MaxNumConfigs; ++j) {
        if (fread(&Class->ConfigLengths[j], sizeof(uinT16), 1, File) != 1)
          cprintf ("Bad read of inttemp!\n");
      }
      if (swap) {
        Reverse16(&Class->NumProtos);
        for (j = 0; j < MaxNumConfigs; j++)
          Reverse16(&Class->ConfigLengths[j]);
      }
    } else {
      ASSERT_HOST(Class->NumConfigs < MaxNumConfigs);
      for (j = 0; j < Class->NumConfigs; ++j) {
        if (fread(&Class->ConfigLengths[j], sizeof(uinT16), 1, File) != 1)
          cprintf ("Bad read of inttemp!\n");
      }
      if (swap) {
        Reverse16(&Class->NumProtos);
        for (j = 0; j < MaxNumConfigs; j++)
          Reverse16(&Class->ConfigLengths[j]);
      }
    }
    if (version_id < 2) {
      ClassForClassId (Templates, ClassIdFor[i]) = Class;
    } else {
      ClassForClassId (Templates, i) = Class;
    }

    /* then read in the proto lengths */
    Lengths = NULL;
    if (MaxNumIntProtosIn (Class) > 0) {
      Lengths = (uinT8 *)Emalloc(sizeof(uinT8) * MaxNumIntProtosIn(Class));
      if ((nread =
           fread((char *)Lengths, sizeof(uinT8),
                 MaxNumIntProtosIn(Class), File)) != MaxNumIntProtosIn (Class))
        cprintf ("Bad read of inttemp!\n");
    }
    Class->ProtoLengths = Lengths;

    /* then read in the proto sets */
    for (j = 0; j < Class->NumProtoSets; j++) {
      ProtoSet = (PROTO_SET)Emalloc(sizeof(PROTO_SET_STRUCT));
      if (version_id < 3) {
        if ((nread =
             fread((char *) &ProtoSet->ProtoPruner, 1,
                    sizeof(PROTO_PRUNER), File)) != sizeof(PROTO_PRUNER))
          cprintf("Bad read of inttemp!\n");
        for (x = 0; x < PROTOS_PER_PROTO_SET; x++) {
          if ((nread = fread((char *) &ProtoSet->Protos[x].A, 1,
                             sizeof(inT8), File)) != sizeof(inT8) ||
              (nread = fread((char *) &ProtoSet->Protos[x].B, 1,
                             sizeof(uinT8), File)) != sizeof(uinT8) ||
              (nread = fread((char *) &ProtoSet->Protos[x].C, 1,
                             sizeof(inT8), File)) != sizeof(inT8) ||
              (nread = fread((char *) &ProtoSet->Protos[x].Angle, 1,
                             sizeof(uinT8), File)) != sizeof(uinT8))
            cprintf("Bad read of inttemp!\n");
          for (y = 0; y < WerdsPerConfigVec; y++)
            if ((nread = fread((char *) &ProtoSet->Protos[x].Configs[y], 1,
                               sizeof(uinT32), File)) != sizeof(uinT32))
              cprintf("Bad read of inttemp!\n");
        }
      } else {
        if ((nread =
             fread((char *) ProtoSet, 1, sizeof(PROTO_SET_STRUCT),
                   File)) != sizeof(PROTO_SET_STRUCT))
          cprintf("Bad read of inttemp!\n");
      }
      if (swap) {
        for (x = 0; x < NUM_PP_PARAMS; x++)
          for (y = 0; y < NUM_PP_BUCKETS; y++)
            for (z = 0; z < (int)WERDS_PER_PP_VECTOR; z++)
              Reverse32(&ProtoSet->ProtoPruner[x][y][z]);
        for (x = 0; x < PROTOS_PER_PROTO_SET; x++)
          for (y = 0; y < WerdsPerConfigVec; y++)
            Reverse32(&ProtoSet->Protos[x].Configs[y]);
      }
      Class->ProtoSets[j] = ProtoSet;
    }
    if (version_id < 4)
      Class->font_set_id = -1;
    else {
      fread(&Class->font_set_id, sizeof(int), 1, File);
      if (swap)
        Reverse32(&Class->font_set_id);
    }
  }

  if (version_id < 2) {
    /* add an empty NULL class with class id 0 */
    assert(UnusedClassIdIn (Templates, 0));
    ClassForClassId (Templates, 0) = NewIntClass (1, 1);
    ClassForClassId (Templates, 0)->font_set_id = -1;
    Templates->NumClasses++;
    /* make sure the classes are contiguous */
    for (i = 0; i < MAX_NUM_CLASSES; i++) {
      if (i < Templates->NumClasses) {
        if (ClassForClassId (Templates, i) == NULL) {
          fprintf(stderr, "Non-contiguous class ids in inttemp\n");
          exit(1);
        }
      } else {
        if (ClassForClassId (Templates, i) != NULL) {
          fprintf(stderr, "Class id %d exceeds NumClassesIn (Templates) %d\n",
                  i, Templates->NumClasses);
          exit(1);
        }
      }
    }
  }
  if (version_id >= 4) {
    this->fontinfo_table_.read(File, NewPermanentCallback(read_info), swap);
    this->fontset_table_.read(File, NewPermanentCallback(read_set), swap);
  }

  // Clean up.
  delete[] IndexFor;
  delete[] ClassIdFor;
  delete[] TempClassPruner;

  return (Templates);
}                                /* ReadIntTemplates */

/*---------------------------------------------------------------------------*/
#ifndef GRAPHICS_DISABLED
void ShowMatchDisplay() {
/*
 ** Parameters: none
 ** Globals:
 **   FeatureShapes display list containing feature matches
 **   ProtoShapes display list containing proto matches
 ** Operation: This routine sends the shapes in the global display
 **   lists to the match debugger window.
 ** Return: none
 ** Exceptions: none
 ** History: Thu Mar 21 15:47:33 1991, DSJ, Created.
 */
  void *window;
  /* Size of drawable */
  InitIntMatchWindowIfReqd();
  c_clear_window(IntMatchWindow);
  if (ProtoDisplayWindow) {
    c_clear_window(ProtoDisplayWindow);
  }
  if (FeatureDisplayWindow) {
    c_clear_window(FeatureDisplayWindow);
  }

  window = IntMatchWindow;
  c_line_color_index(window, Grey);
  /* Default size of drawing */
  if (classify_norm_method == baseline) {
    c_move (window, -1000.0, INT_BASELINE);
    c_draw (window, 1000.0, INT_BASELINE);
    c_move (window, -1000.0, INT_DESCENDER);
    c_draw (window, 1000.0, INT_DESCENDER);
    c_move (window, -1000.0, INT_XHEIGHT);
    c_draw (window, 1000.0, INT_XHEIGHT);
    c_move (window, -1000.0, INT_CAPHEIGHT);
    c_draw (window, 1000.0, INT_CAPHEIGHT);
    c_move (window, INT_MIN_X, -1000.0);
    c_draw (window, INT_MIN_X, 1000.0);
    c_move (window, INT_MAX_X, -1000.0);
    c_draw (window, INT_MAX_X, 1000.0);
  }
  else {
    c_move (window, INT_XCENTER - INT_XRADIUS, INT_YCENTER - INT_YRADIUS);
    c_draw (window, INT_XCENTER + INT_XRADIUS, INT_YCENTER - INT_YRADIUS);
    c_move (window, INT_XCENTER - INT_XRADIUS, INT_YCENTER + INT_YRADIUS);
    c_draw (window, INT_XCENTER + INT_XRADIUS, INT_YCENTER + INT_YRADIUS);
    c_move (window, INT_XCENTER - INT_XRADIUS, INT_YCENTER - INT_YRADIUS);
    c_draw (window, INT_XCENTER - INT_XRADIUS, INT_YCENTER + INT_YRADIUS);
    c_move (window, INT_XCENTER + INT_XRADIUS, INT_YCENTER - INT_YRADIUS);
    c_draw (window, INT_XCENTER + INT_XRADIUS, INT_YCENTER + INT_YRADIUS);
    c_move(window, INT_MIN_X, INT_MIN_Y);
    c_draw(window, INT_MIN_X, INT_MAX_Y);
    c_move(window, INT_MIN_X, INT_MIN_Y);
    c_draw(window, INT_MAX_X, INT_MIN_Y);
    c_move(window, INT_MAX_X, INT_MAX_Y);
    c_draw(window, INT_MIN_X, INT_MAX_Y);
    c_move(window, INT_MAX_X, INT_MAX_Y);
    c_draw(window, INT_MAX_X, INT_MIN_Y);
  }
  IntMatchWindow->ZoomToRectangle(INT_MIN_X, INT_MIN_Y,
                                  INT_MAX_X, INT_MAX_Y);
  if (ProtoDisplayWindow) {
    ProtoDisplayWindow->ZoomToRectangle(INT_MIN_X, INT_MIN_Y,
                                        INT_MAX_X, INT_MAX_Y);
  }
  if (FeatureDisplayWindow) {
    FeatureDisplayWindow->ZoomToRectangle(INT_MIN_X, INT_MIN_Y,
                                          INT_MAX_X, INT_MAX_Y);
  }
}                                /* ShowMatchDisplay */
#endif

/*---------------------------------------------------------------------------*/
void Classify::WriteIntTemplates(FILE *File, INT_TEMPLATES Templates,
                                 const UNICHARSET& target_unicharset) {
/*
 ** Parameters:
 **   File    open file to write templates to
 **   Templates templates to save into File
 ** Globals: none
 ** Operation: This routine writes Templates to File.  The format
 **   is an efficient binary format.  File must already be open
 **   for writing.
 ** Return: none
 ** Exceptions: none
 ** History: Wed Feb 27 11:48:46 1991, DSJ, Created.
 */
  int i, j;
  INT_CLASS Class;
  int unicharset_size = target_unicharset.size();
  int version_id = -4;  // When negated by the reader -1 becomes +1 etc.

  if (Templates->NumClasses != unicharset_size) {
    cprintf("Warning: executing WriteIntTemplates() with %d classes in"
            " Templates, while target_unicharset size is %d\n",
            Templates->NumClasses, unicharset_size);
  }

  /* first write the high level template struct */
  fwrite(&unicharset_size, sizeof(unicharset_size), 1, File);
  fwrite(&version_id, sizeof(version_id), 1, File);
  fwrite(&Templates->NumClassPruners, sizeof(Templates->NumClassPruners),
         1, File);
  fwrite(&Templates->NumClasses, sizeof(Templates->NumClasses), 1, File);

  /* then write out the class pruners */
  for (i = 0; i < Templates->NumClassPruners; i++)
    fwrite(Templates->ClassPruner[i],
           sizeof(CLASS_PRUNER_STRUCT), 1, File);

  /* then write out each class */
  for (i = 0; i < Templates->NumClasses; i++) {
    Class = Templates->Class[i];

    /* first write out the high level struct for the class */
    fwrite(&Class->NumProtos, sizeof(Class->NumProtos), 1, File);
    fwrite(&Class->NumProtoSets, sizeof(Class->NumProtoSets), 1, File);
    ASSERT_HOST(Class->NumConfigs == this->fontset_table_.get(Class->font_set_id).size);
    fwrite(&Class->NumConfigs, sizeof(Class->NumConfigs), 1, File);
    for (j = 0; j < Class->NumConfigs; ++j) {
      fwrite(&Class->ConfigLengths[j], sizeof(uinT16), 1, File);
    }

    /* then write out the proto lengths */
    if (MaxNumIntProtosIn (Class) > 0) {
      fwrite ((char *) (Class->ProtoLengths), sizeof (uinT8),
              MaxNumIntProtosIn (Class), File);
    }

    /* then write out the proto sets */
    for (j = 0; j < Class->NumProtoSets; j++)
      fwrite ((char *) Class->ProtoSets[j],
              sizeof (PROTO_SET_STRUCT), 1, File);

    /* then write the fonts info */
    fwrite(&Class->font_set_id, sizeof(int), 1, File);
  }

  /* Write the fonts info tables */
  this->fontinfo_table_.write(File, NewPermanentCallback(write_info));
  this->fontset_table_.write(File, NewPermanentCallback(write_set));
}                                /* WriteIntTemplates */

/*-----------------------------------------------------------------------------
              Private Code
-----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
FLOAT32 BucketStart(int Bucket, FLOAT32 Offset, int NumBuckets) {
/*
 ** Parameters:
 **   Bucket    bucket whose start is to be computed
 **   Offset    offset used to map params to buckets
 **   NumBuckets  total number of buckets
 ** Globals: none
 ** Operation: This routine returns the parameter value which
 **   corresponds to the beginning of the specified bucket.
 **   The bucket number should have been generated using the
 **   BucketFor() function with parameters Offset and NumBuckets.
 ** Return: Param value corresponding to start position of Bucket.
 ** Exceptions: none
 ** History: Thu Feb 14 13:24:33 1991, DSJ, Created.
 */
  return (((FLOAT32) Bucket / NumBuckets) - Offset);

}                                /* BucketStart */


/*---------------------------------------------------------------------------*/
FLOAT32 BucketEnd(int Bucket, FLOAT32 Offset, int NumBuckets) {
/*
 ** Parameters:
 **   Bucket    bucket whose end is to be computed
 **   Offset    offset used to map params to buckets
 **   NumBuckets  total number of buckets
 ** Globals: none
 ** Operation: This routine returns the parameter value which
 **   corresponds to the end of the specified bucket.
 **   The bucket number should have been generated using the
 **   BucketFor() function with parameters Offset and NumBuckets.
 ** Return: Param value corresponding to end position of Bucket.
 ** Exceptions: none
 ** History: Thu Feb 14 13:24:33 1991, DSJ, Created.
 */
  return (((FLOAT32) (Bucket + 1) / NumBuckets) - Offset);
}                                /* BucketEnd */


/*---------------------------------------------------------------------------*/
void DoFill(FILL_SPEC *FillSpec,
            CLASS_PRUNER Pruner,
            register uinT32 ClassMask,
            register uinT32 ClassCount,
            register uinT32 WordIndex) {
/*
 ** Parameters:
 **   FillSpec  specifies which bits to fill in pruner
 **   Pruner    class pruner to be filled
 **   ClassMask indicates which bits to change in each word
 **   ClassCount  indicates what to change bits to
 **   WordIndex indicates which word to change
 ** Globals: none
 ** Operation: This routine fills in the section of a class pruner
 **   corresponding to a single x value for a single proto of
 **   a class.
 ** Return: none
 ** Exceptions: none
 ** History: Tue Feb 19 11:11:29 1991, DSJ, Created.
 */
  register int X, Y, Angle;
  register uinT32 OldWord;

  X = FillSpec->X;
  if (X < 0)
    X = 0;
  if (X >= NUM_CP_BUCKETS)
    X = NUM_CP_BUCKETS - 1;

  if (FillSpec->YStart < 0)
    FillSpec->YStart = 0;
  if (FillSpec->YEnd >= NUM_CP_BUCKETS)
    FillSpec->YEnd = NUM_CP_BUCKETS - 1;

  for (Y = FillSpec->YStart; Y <= FillSpec->YEnd; Y++)
    for (Angle = FillSpec->AngleStart;
         TRUE; CircularIncrement (Angle, NUM_CP_BUCKETS)) {
      OldWord = Pruner[X][Y][Angle][WordIndex];
      if (ClassCount > (OldWord & ClassMask)) {
        OldWord &= ~ClassMask;
        OldWord |= ClassCount;
        Pruner[X][Y][Angle][WordIndex] = OldWord;
      }
      if (Angle == FillSpec->AngleEnd)
        break;
    }
}                                /* DoFill */


/*---------------------------------------------------------------------------*/
BOOL8 FillerDone(TABLE_FILLER *Filler) {
/*
 ** Parameters:
 **   Filler    table filler to check if done
 ** Globals: none
 ** Operation: Return TRUE if the specified table filler is done, i.e.
 **   if it has no more lines to fill.
 ** Return: TRUE if no more lines to fill, FALSE otherwise.
 ** Exceptions: none
 ** History: Tue Feb 19 10:08:05 1991, DSJ, Created.
 */
  FILL_SWITCH *Next;

  Next = &(Filler->Switch[Filler->NextSwitch]);

  if (Filler->X > Next->X && Next->Type == LastSwitch)
    return (TRUE);
  else
    return (FALSE);

}                                /* FillerDone */


/*---------------------------------------------------------------------------*/
void
FillPPCircularBits (uinT32 ParamTable[NUM_PP_BUCKETS][WERDS_PER_PP_VECTOR],
                    int Bit, FLOAT32 Center, FLOAT32 Spread) {
/*
 ** Parameters:
 **   ParamTable  table of bit vectors, one per param bucket
 **   Bit   bit position in vectors to be filled
 **   Center    center of filled area
 **   Spread    spread of filled area
 ** Globals: none
 ** Operation: This routine sets Bit in each bit vector whose
 **   bucket lies within the range Center +- Spread.  The fill
 **   is done for a circular dimension, i.e. bucket 0 is adjacent
 **   to the last bucket.  It is assumed that Center and Spread
 **   are expressed in a circular coordinate system whose range
 **   is 0 to 1.
 ** Return: none
 ** Exceptions: none
 ** History: Tue Oct 16 09:26:54 1990, DSJ, Created.
 */
  int i, FirstBucket, LastBucket;

  if (Spread > 0.5)
    Spread = 0.5;

  FirstBucket = (int) floor ((Center - Spread) * NUM_PP_BUCKETS);
  if (FirstBucket < 0)
    FirstBucket += NUM_PP_BUCKETS;

  LastBucket = (int) floor ((Center + Spread) * NUM_PP_BUCKETS);
  if (LastBucket >= NUM_PP_BUCKETS)
    LastBucket -= NUM_PP_BUCKETS;
  if (classify_learning_debug_level >= 2)
    cprintf ("Circular fill from %d to %d", FirstBucket, LastBucket);
  for (i = FirstBucket; TRUE; CircularIncrement (i, NUM_PP_BUCKETS)) {
    SET_BIT (ParamTable[i], Bit);

    /* exit loop after we have set the bit for the last bucket */
    if (i == LastBucket)
      break;
  }

}                                /* FillPPCircularBits */


/*---------------------------------------------------------------------------*/
void
FillPPLinearBits (uinT32 ParamTable[NUM_PP_BUCKETS][WERDS_PER_PP_VECTOR],
                  int Bit, FLOAT32 Center, FLOAT32 Spread) {
/*
 ** Parameters:
 **   ParamTable  table of bit vectors, one per param bucket
 **   Bit   bit number being filled
 **   Center    center of filled area
 **   Spread    spread of filled area
 ** Globals: none
 ** Operation: This routine sets Bit in each bit vector whose
 **   bucket lies within the range Center +- Spread.  The fill
 **   is done for a linear dimension, i.e. there is no wrap-around
 **   for this dimension.  It is assumed that Center and Spread
 **   are expressed in a linear coordinate system whose range
 **   is approximately 0 to 1.  Values outside this range will
 **   be clipped.
 ** Return: none
 ** Exceptions: none
 ** History: Tue Oct 16 09:26:54 1990, DSJ, Created.
 */
  int i, FirstBucket, LastBucket;

  FirstBucket = (int) floor ((Center - Spread) * NUM_PP_BUCKETS);
  if (FirstBucket < 0)
    FirstBucket = 0;

  LastBucket = (int) floor ((Center + Spread) * NUM_PP_BUCKETS);
  if (LastBucket >= NUM_PP_BUCKETS)
    LastBucket = NUM_PP_BUCKETS - 1;

  if (classify_learning_debug_level >= 2)
    cprintf ("Linear fill from %d to %d", FirstBucket, LastBucket);
  for (i = FirstBucket; i <= LastBucket; i++)
    SET_BIT (ParamTable[i], Bit);

}                                /* FillPPLinearBits */


/*---------------------------------------------------------------------------*/
#ifndef GRAPHICS_DISABLED
CLASS_ID Classify::GetClassToDebug(const char *Prompt) {
/*
 ** Parameters:
 **   Prompt  prompt to print while waiting for input from window
 ** Globals: none
 ** Operation: This routine prompts the user with Prompt and waits
 **   for the user to enter something in the debug window.
 ** Return: Character entered in the debug window.
 ** Exceptions: none
 ** History: Thu Mar 21 16:55:13 1991, DSJ, Created.
 */
  tprintf("%s\n", Prompt);
  SVEvent* ev;
  SVEventType ev_type;
  // Wait until a click or popup event.
  do {
    ev = IntMatchWindow->AwaitEvent(SVET_ANY);
    ev_type = ev->type;
    if (ev_type == SVET_POPUP) {
      // TODO(rays) must return which menu item was selected, but
      // that can't be done in this CL without dragging in a lot of
      // other changes.
      if (unicharset.contains_unichar(ev->parameter))
        return unicharset.unichar_to_id(ev->parameter);
      tprintf("Char class '%s' not found in unicharset",
              ev->parameter);
    }
    delete ev;
  } while (ev_type != SVET_CLICK);
  return 0;
}                                /* GetClassToDebug */
#endif

/*---------------------------------------------------------------------------*/
void GetCPPadsForLevel(int Level,
                       FLOAT32 *EndPad,
                       FLOAT32 *SidePad,
                       FLOAT32 *AnglePad) {
/*
 ** Parameters:
 **   Level   "tightness" level to return pads for
 **   EndPad    place to put end pad for Level
 **   SidePad   place to put side pad for Level
 **   AnglePad  place to put angle pad for Level
 ** Globals: none
 ** Operation: This routine copies the appropriate global pad variables
 **   into EndPad, SidePad, and AnglePad.  This is a kludge used
 **   to get around the fact that global control variables cannot
 **   be arrays.  If the specified level is illegal, the tightest
 **   possible pads are returned.
 ** Return: none (results are returned in EndPad, SidePad, and AnglePad.
 ** Exceptions: none
 ** History: Thu Feb 14 08:26:49 1991, DSJ, Created.
 */
  switch (Level) {
    case 0:
      *EndPad = classify_cp_end_pad_loose * GetPicoFeatureLength ();
      *SidePad = classify_cp_side_pad_loose * GetPicoFeatureLength ();
      *AnglePad = classify_cp_angle_pad_loose / 360.0;
      break;

    case 1:
      *EndPad = classify_cp_end_pad_medium * GetPicoFeatureLength ();
      *SidePad = classify_cp_side_pad_medium * GetPicoFeatureLength ();
      *AnglePad = classify_cp_angle_pad_medium / 360.0;
      break;

    case 2:
      *EndPad = classify_cp_end_pad_tight * GetPicoFeatureLength ();
      *SidePad = classify_cp_side_pad_tight * GetPicoFeatureLength ();
      *AnglePad = classify_cp_angle_pad_tight / 360.0;
      break;

    default:
      *EndPad = classify_cp_end_pad_tight * GetPicoFeatureLength ();
      *SidePad = classify_cp_side_pad_tight * GetPicoFeatureLength ();
      *AnglePad = classify_cp_angle_pad_tight / 360.0;
      break;
  }
  if (*AnglePad > 0.5)
    *AnglePad = 0.5;

}                                /* GetCPPadsForLevel */


/*---------------------------------------------------------------------------*/
C_COL GetMatchColorFor(FLOAT32 Evidence) {
/*
 ** Parameters:
 **   Evidence  evidence value to return color for
 ** Globals: none
 ** Operation:
 ** Return: Color which corresponds to specified Evidence value.
 ** Exceptions: none
 ** History: Thu Mar 21 15:24:52 1991, DSJ, Created.
 */

  assert (Evidence >= 0.0);
  assert (Evidence <= 1.0);

  if (Evidence >= 0.90)
    return White;
  else if (Evidence >= 0.75)
    return Green;
  else if (Evidence >= 0.50)
    return Red;
  else
    return Blue;
}                                /* GetMatchColorFor */


/*---------------------------------------------------------------------------*/
void GetNextFill(TABLE_FILLER *Filler, FILL_SPEC *Fill) {
/*
 ** Parameters:
 **   Filler    filler to get next fill spec from
 **   Fill    place to put spec for next fill
 ** Globals: none
 ** Operation: This routine returns (in Fill) the specification of
 **   the next line to be filled from Filler.  FillerDone() should
 **   always be called before GetNextFill() to ensure that we
 **   do not run past the end of the fill table.
 ** Return: none (results are returned in Fill)
 ** Exceptions: none
 ** History: Tue Feb 19 10:17:42 1991, DSJ, Created.
 */
  FILL_SWITCH *Next;

  /* compute the fill assuming no switches will be encountered */
  Fill->AngleStart = Filler->AngleStart;
  Fill->AngleEnd = Filler->AngleEnd;
  Fill->X = Filler->X;
  Fill->YStart = Filler->YStart >> 8;
  Fill->YEnd = Filler->YEnd >> 8;

  /* update the fill info and the filler for ALL switches at this X value */
  Next = &(Filler->Switch[Filler->NextSwitch]);
  while (Filler->X >= Next->X) {
    Fill->X = Filler->X = Next->X;
    if (Next->Type == StartSwitch) {
      Fill->YStart = Next->Y;
      Filler->StartDelta = Next->Delta;
      Filler->YStart = Next->YInit;
    }
    else if (Next->Type == EndSwitch) {
      Fill->YEnd = Next->Y;
      Filler->EndDelta = Next->Delta;
      Filler->YEnd = Next->YInit;
    }
    else {                       /* Type must be LastSwitch */
      break;
    }
    Filler->NextSwitch++;
    Next = &(Filler->Switch[Filler->NextSwitch]);
  }

  /* prepare the filler for the next call to this routine */
  Filler->X++;
  Filler->YStart += Filler->StartDelta;
  Filler->YEnd += Filler->EndDelta;

}                                /* GetNextFill */


/*---------------------------------------------------------------------------*/
/**
 * This routine computes a data structure (Filler)
 * which can be used to fill in a rectangle surrounding
 * the specified Proto.
 *
 * @param EndPad, SidePad, AnglePad padding to add to proto
 * @param Proto       proto to create a filler for
 * @param Filler        place to put table filler
 *
 * Globals: none
 *
 * @return none (results are returned in Filler)
 * @note Exceptions: none
 * @note History: Thu Feb 14 09:27:05 1991, DSJ, Created.
 */
void InitTableFiller (FLOAT32 EndPad, FLOAT32 SidePad,
                      FLOAT32 AnglePad, PROTO Proto, TABLE_FILLER * Filler)
#define XS          X_SHIFT
#define YS          Y_SHIFT
#define AS          ANGLE_SHIFT
#define NB          NUM_CP_BUCKETS
{
  FLOAT32 Angle;
  FLOAT32 X, Y, HalfLength;
  FLOAT32 Cos, Sin;
  FLOAT32 XAdjust, YAdjust;
  FPOINT Start, Switch1, Switch2, End;
  int S1 = 0;
  int S2 = 1;

  Angle = Proto->Angle;
  X = Proto->X;
  Y = Proto->Y;
  HalfLength = Proto->Length / 2.0;

  Filler->AngleStart = CircBucketFor(Angle - AnglePad, AS, NB);
  Filler->AngleEnd = CircBucketFor(Angle + AnglePad, AS, NB);
  Filler->NextSwitch = 0;

  if (fabs (Angle - 0.0) < HV_TOLERANCE || fabs (Angle - 0.5) < HV_TOLERANCE) {
    /* horizontal proto - handle as special case */
    Filler->X = BucketFor(X - HalfLength - EndPad, XS, NB);
    Filler->YStart = BucketFor(Y - SidePad, YS, NB * 256);
    Filler->YEnd = BucketFor(Y + SidePad, YS, NB * 256);
    Filler->StartDelta = 0;
    Filler->EndDelta = 0;
    Filler->Switch[0].Type = LastSwitch;
    Filler->Switch[0].X = BucketFor(X + HalfLength + EndPad, XS, NB);
  } else if (fabs(Angle - 0.25) < HV_TOLERANCE ||
           fabs(Angle - 0.75) < HV_TOLERANCE) {
    /* vertical proto - handle as special case */
    Filler->X = BucketFor(X - SidePad, XS, NB);
    Filler->YStart = BucketFor(Y - HalfLength - EndPad, YS, NB * 256);
    Filler->YEnd = BucketFor(Y + HalfLength + EndPad, YS, NB * 256);
    Filler->StartDelta = 0;
    Filler->EndDelta = 0;
    Filler->Switch[0].Type = LastSwitch;
    Filler->Switch[0].X = BucketFor(X + SidePad, XS, NB);
  } else {
    /* diagonal proto */

    if ((Angle > 0.0 && Angle < 0.25) || (Angle > 0.5 && Angle < 0.75)) {
      /* rising diagonal proto */
      Angle *= 2.0 * PI;
      Cos = fabs(cos(Angle));
      Sin = fabs(sin(Angle));

      /* compute the positions of the corners of the acceptance region */
      Start.x = X - (HalfLength + EndPad) * Cos - SidePad * Sin;
      Start.y = Y - (HalfLength + EndPad) * Sin + SidePad * Cos;
      End.x = 2.0 * X - Start.x;
      End.y = 2.0 * Y - Start.y;
      Switch1.x = X - (HalfLength + EndPad) * Cos + SidePad * Sin;
      Switch1.y = Y - (HalfLength + EndPad) * Sin - SidePad * Cos;
      Switch2.x = 2.0 * X - Switch1.x;
      Switch2.y = 2.0 * Y - Switch1.y;

      if (Switch1.x > Switch2.x) {
        S1 = 1;
        S2 = 0;
      }

      /* translate into bucket positions and deltas */
      Filler->X = (inT8) MapParam(Start.x, XS, NB);
      Filler->StartDelta = -(inT16) ((Cos / Sin) * 256);
      Filler->EndDelta = (inT16) ((Sin / Cos) * 256);

      XAdjust = BucketEnd(Filler->X, XS, NB) - Start.x;
      YAdjust = XAdjust * Cos / Sin;
      Filler->YStart = (inT16) MapParam(Start.y - YAdjust, YS, NB * 256);
      YAdjust = XAdjust * Sin / Cos;
      Filler->YEnd = (inT16) MapParam(Start.y + YAdjust, YS, NB * 256);

      Filler->Switch[S1].Type = StartSwitch;
      Filler->Switch[S1].X = (inT8) MapParam(Switch1.x, XS, NB);
      Filler->Switch[S1].Y = (inT8) MapParam(Switch1.y, YS, NB);
      XAdjust = Switch1.x - BucketStart(Filler->Switch[S1].X, XS, NB);
      YAdjust = XAdjust * Sin / Cos;
      Filler->Switch[S1].YInit =
        (inT16) MapParam(Switch1.y - YAdjust, YS, NB * 256);
      Filler->Switch[S1].Delta = Filler->EndDelta;

      Filler->Switch[S2].Type = EndSwitch;
      Filler->Switch[S2].X = (inT8) MapParam(Switch2.x, XS, NB);
      Filler->Switch[S2].Y = (inT8) MapParam(Switch2.y, YS, NB);
      XAdjust = Switch2.x - BucketStart(Filler->Switch[S2].X, XS, NB);
      YAdjust = XAdjust * Cos / Sin;
      Filler->Switch[S2].YInit =
        (inT16) MapParam(Switch2.y + YAdjust, YS, NB * 256);
      Filler->Switch[S2].Delta = Filler->StartDelta;

      Filler->Switch[2].Type = LastSwitch;
      Filler->Switch[2].X = (inT8)MapParam(End.x, XS, NB);
    } else {
      /* falling diagonal proto */
      Angle *= 2.0 * PI;
      Cos = fabs(cos(Angle));
      Sin = fabs(sin(Angle));

      /* compute the positions of the corners of the acceptance region */
      Start.x = X - (HalfLength + EndPad) * Cos - SidePad * Sin;
      Start.y = Y + (HalfLength + EndPad) * Sin - SidePad * Cos;
      End.x = 2.0 * X - Start.x;
      End.y = 2.0 * Y - Start.y;
      Switch1.x = X - (HalfLength + EndPad) * Cos + SidePad * Sin;
      Switch1.y = Y + (HalfLength + EndPad) * Sin + SidePad * Cos;
      Switch2.x = 2.0 * X - Switch1.x;
      Switch2.y = 2.0 * Y - Switch1.y;

      if (Switch1.x > Switch2.x) {
        S1 = 1;
        S2 = 0;
      }

      /* translate into bucket positions and deltas */
      Filler->X = (inT8) MapParam(Start.x, XS, NB);
      Filler->StartDelta = -(inT16) ((Sin / Cos) * 256);
      Filler->EndDelta = (inT16) ((Cos / Sin) * 256);

      XAdjust = BucketEnd(Filler->X, XS, NB) - Start.x;
      YAdjust = XAdjust * Sin / Cos;
      Filler->YStart = (inT16) MapParam(Start.y - YAdjust, YS, NB * 256);
      YAdjust = XAdjust * Cos / Sin;
      Filler->YEnd = (inT16) MapParam(Start.y + YAdjust, YS, NB * 256);

      Filler->Switch[S1].Type = EndSwitch;
      Filler->Switch[S1].X = (inT8) MapParam(Switch1.x, XS, NB);
      Filler->Switch[S1].Y = (inT8) MapParam(Switch1.y, YS, NB);
      XAdjust = Switch1.x - BucketStart(Filler->Switch[S1].X, XS, NB);
      YAdjust = XAdjust * Sin / Cos;
      Filler->Switch[S1].YInit =
        (inT16) MapParam(Switch1.y + YAdjust, YS, NB * 256);
      Filler->Switch[S1].Delta = Filler->StartDelta;

      Filler->Switch[S2].Type = StartSwitch;
      Filler->Switch[S2].X = (inT8) MapParam(Switch2.x, XS, NB);
      Filler->Switch[S2].Y = (inT8) MapParam(Switch2.y, YS, NB);
      XAdjust = Switch2.x - BucketStart(Filler->Switch[S2].X, XS, NB);
      YAdjust = XAdjust * Cos / Sin;
      Filler->Switch[S2].YInit =
        (inT16) MapParam(Switch2.y - YAdjust, YS, NB * 256);
      Filler->Switch[S2].Delta = Filler->EndDelta;

      Filler->Switch[2].Type = LastSwitch;
      Filler->Switch[2].X = (inT8) MapParam(End.x, XS, NB);
    }
  }
}                                /* InitTableFiller */


/*---------------------------------------------------------------------------*/
#ifndef GRAPHICS_DISABLED
void RenderIntFeature(void *window, INT_FEATURE Feature, C_COL Color) {
/*
 ** Parameters:
 **   ShapeList shape list to add feature rendering to
 **   Feature   feature to be rendered
 **   Color   color to use for feature rendering
 ** Globals: none
 ** Operation: This routine renders the specified feature into ShapeList.
 ** Return: New shape list with rendering of Feature added.
 ** Exceptions: none
 ** History: Thu Mar 21 14:57:41 1991, DSJ, Created.
 */
  FLOAT32 X, Y, Dx, Dy, Length;

  c_line_color_index(window, Color);
  assert(Feature != NULL);
  assert(Color != 0);

  X = Feature->X - DISPLAY_OFFSET;
  Y = Feature->Y - DISPLAY_OFFSET;
  Length = GetPicoFeatureLength() * 0.7 * INT_CHAR_NORM_RANGE;
  Dx = (Length / 2.0) * cos((Feature->Theta / 256.0) * 2.0 * PI);
  Dy = (Length / 2.0) * sin((Feature->Theta / 256.0) * 2.0 * PI);

  c_move(window, X - Dx, Y - Dy);
  c_draw(window, X + Dx, Y + Dy);
  c_move(window, X - Dx - Dy * DOUBLE_OFFSET, Y - Dy + Dx * DOUBLE_OFFSET);
  c_draw(window, X + Dx - Dy * DOUBLE_OFFSET, Y + Dy + Dx * DOUBLE_OFFSET);
}                                /* RenderIntFeature */


/*---------------------------------------------------------------------------*/
/**
 * This routine extracts the parameters of the specified
 * proto from the class description and adds a rendering of
 * the proto onto the ShapeList.
 *
 * @param ShapeList shape list to append proto rendering onto
 * @param Class   class that proto is contained in
 * @param ProtoId   id of proto to be rendered
 * @param Color   color to render proto in
 *
 * Globals: none
 *
 * @return New shape list with a rendering of one proto added.
 * @note Exceptions: none
 * @note History: Thu Mar 21 10:21:09 1991, DSJ, Created.
 */
void RenderIntProto(void *window,
                    INT_CLASS Class,
                    PROTO_ID ProtoId,
                    C_COL Color) {
  PROTO_SET ProtoSet;
  INT_PROTO Proto;
  int ProtoSetIndex;
  int ProtoWordIndex;
  FLOAT32 Length;
  int Xmin, Xmax, Ymin, Ymax;
  FLOAT32 X, Y, Dx, Dy;
  uinT32 ProtoMask;
  int Bucket;

  assert(ProtoId >= 0);
  assert(Class != NULL);
  assert(ProtoId < Class->NumProtos);
  assert(Color != 0);
  c_line_color_index(window, Color);

  ProtoSet = Class->ProtoSets[SetForProto(ProtoId)];
  ProtoSetIndex = IndexForProto(ProtoId);
  Proto = &(ProtoSet->Protos[ProtoSetIndex]);
  Length = (Class->ProtoLengths[ProtoId] *
    GetPicoFeatureLength() * INT_CHAR_NORM_RANGE);
  ProtoMask = PPrunerMaskFor(ProtoId);
  ProtoWordIndex = PPrunerWordIndexFor(ProtoId);

  // find the x and y extent of the proto from the proto pruning table
  Xmin = Ymin = NUM_PP_BUCKETS;
  Xmax = Ymax = 0;
  for (Bucket = 0; Bucket < NUM_PP_BUCKETS; Bucket++) {
    if (ProtoMask & ProtoSet->ProtoPruner[PRUNER_X][Bucket][ProtoWordIndex]) {
      UpdateRange(Bucket, &Xmin, &Xmax);
    }

    if (ProtoMask & ProtoSet->ProtoPruner[PRUNER_Y][Bucket][ProtoWordIndex]) {
      UpdateRange(Bucket, &Ymin, &Ymax);
    }
  }
  X = (Xmin + Xmax + 1) / 2.0 * PROTO_PRUNER_SCALE - DISPLAY_OFFSET;
  Y = (Ymin + Ymax + 1) / 2.0 * PROTO_PRUNER_SCALE - DISPLAY_OFFSET;
  Dx = (Length / 2.0) * cos((Proto->Angle / 256.0) * 2.0 * PI);
  Dy = (Length / 2.0) * sin((Proto->Angle / 256.0) * 2.0 * PI);

  c_move(window, X - Dx, Y - Dy);
  c_draw(window, X + Dx, Y + Dy);
}                                /* RenderIntProto */
#endif

/*---------------------------------------------------------------------------*/
/**
 * This routine truncates Param to lie within the range
 * of Min-Max inclusive.  If a truncation is performed, and
 * Id is not null, an warning message is printed.
 *
 * @param Param   parameter value to be truncated
 * @param Min, Max  parameter limits (inclusive)
 * @param Id    string id of parameter for error messages
 *
 * Globals: none
 *
 * @return Truncated parameter.
 * @note Exceptions: none
 * @note History: Fri Feb  8 11:54:28 1991, DSJ, Created.
 */
int TruncateParam(FLOAT32 Param, int Min, int Max, char *Id) {
  if (Param < Min) {
    if (Id)
      cprintf("Warning: Param %s truncated from %f to %d!\n",
              Id, Param, Min);
    Param = Min;
  } else if (Param > Max) {
    if (Id)
      cprintf("Warning: Param %s truncated from %f to %d!\n",
              Id, Param, Max);
    Param = Max;
  }
  return static_cast<int>(floor(Param));
}                                /* TruncateParam */


/*---------------------------------------------------------------------------*/

/**
 * Initializes the int matcher window if it is not already
 * initialized.
 */
void InitIntMatchWindowIfReqd() {
  if (IntMatchWindow == NULL) {
    IntMatchWindow = c_create_window("IntMatchWindow", 50, 200,
                                     520, 520,
                                     -130.0, 130.0, -130.0, 130.0);
    SVMenuNode* popup_menu = new SVMenuNode();

    popup_menu->AddChild("Debug Adapted classes", IDA_ADAPTIVE,
                         "x", "Class to debug");
    popup_menu->AddChild("Debug Static classes", IDA_STATIC,
                         "x", "Class to debug");
    popup_menu->AddChild("Debug Both", IDA_BOTH,
                         "x", "Class to debug");
    popup_menu->BuildMenu(IntMatchWindow, false);
  }
}

/**
 * Initializes the proto display window if it is not already
 * initialized.
 */
void InitProtoDisplayWindowIfReqd() {
  if (ProtoDisplayWindow == NULL) {
    ProtoDisplayWindow = c_create_window("ProtoDisplayWindow", 50, 200,
                                         520, 520,
                                         -130.0, 130.0, -130.0, 130.0);
  }
}

/**
 * Initializes the feature display window if it is not already
 * initialized.
 */
void InitFeatureDisplayWindowIfReqd() {
  if (FeatureDisplayWindow == NULL) {
    FeatureDisplayWindow = c_create_window("FeatureDisplayWindow", 50, 200,
                                           520, 520,
                                           -130.0, 130.0, -130.0, 130.0);
  }
}
/////////////////////////////////////////////////////////////////intproto////////////////////////////////////////

/////////////////////////////////////////////////////////////////adaptive////////////////////////////////////////
/*----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/**
 * This routine adds a new adapted class to an existing
 * set of adapted templates.
 *
 * @param Templates set of templates to add new class to
 * @param Class new class to add to templates
 * @param ClassId class id to associate with new class
 *
 * @note Globals: none
 * @note Exceptions: none
 * @note History: Thu Mar 14 13:06:09 1991, DSJ, Created.
 */
void AddAdaptedClass(ADAPT_TEMPLATES Templates, ADAPT_CLASS Class, CLASS_ID ClassId)
{
    INT_CLASS IntClass;

    assert (Templates != NULL);
    assert (Class != NULL);
    assert (LegalClassId (ClassId));
    assert (UnusedClassIdIn (Templates->Templates, ClassId));
    assert (Class->NumPermConfigs == 0);

    IntClass = NewIntClass (1, 1);
    AddIntClass (Templates->Templates, ClassId, IntClass);

    assert (Templates->Class[ClassId] == NULL);
    Templates->Class[ClassId] = Class;

}                                /* AddAdaptedClass */


/*---------------------------------------------------------------------------*/
/**
 * This routine frees all memory consumed by a temporary
 * configuration.
 *
 * @param Config  config to be freed
 *
 * @note Globals: none
 * @note Exceptions: none
 * @note History: Thu Mar 14 13:34:23 1991, DSJ, Created.
 */
void FreeTempConfig(TEMP_CONFIG Config)
{
    assert (Config != NULL);

    destroy_nodes (Config->ContextsSeen, memfree);
    FreeBitVector (Config->Protos);
    free_struct (Config, sizeof (TEMP_CONFIG_STRUCT), "TEMP_CONFIG_STRUCT");

}                                /* FreeTempConfig */


/*---------------------------------------------------------------------------*/
void FreeTempProto(void *arg)
{
    PROTO proto = (PROTO) arg;

    free_struct (proto, sizeof (TEMP_PROTO_STRUCT), "TEMP_PROTO_STRUCT");
}


/*---------------------------------------------------------------------------*/
/**
 * This operation allocates and initializes a new adapted
 * class data structure and returns a ptr to it.
 *
 * @return Ptr to new class data structure.
 *
 * @note Globals: none
 * @note Exceptions: none
 * @note History: Thu Mar 14 12:58:13 1991, DSJ, Created.
 */
ADAPT_CLASS NewAdaptedClass()
{
    ADAPT_CLASS Class;
    int i;

    Class = (ADAPT_CLASS) Emalloc (sizeof (ADAPT_CLASS_STRUCT));
    Class->NumPermConfigs = 0;
    Class->TempProtos = NIL;

    Class->PermProtos = NewBitVector (MAX_NUM_PROTOS);
    Class->PermConfigs = NewBitVector (MAX_NUM_CONFIGS);
    zero_all_bits (Class->PermProtos, WordsInVectorOfSize (MAX_NUM_PROTOS));
    zero_all_bits (Class->PermConfigs, WordsInVectorOfSize (MAX_NUM_CONFIGS));

    for (i = 0; i < MAX_NUM_CONFIGS; i++) TempConfigFor (Class, i) = NULL;

    return (Class);
}                                /* NewAdaptedClass */


/*-------------------------------------------------------------------------*/
void free_adapted_class(ADAPT_CLASS adapt_class)
{
    for (int i = 0; i < MAX_NUM_CONFIGS; i++)
    {
        if (ConfigIsPermanent (adapt_class, i) && PermConfigFor (adapt_class, i) != NULL)
        {
            Efree (PermConfigFor (adapt_class, i));
        }
        else if (!ConfigIsPermanent (adapt_class, i) && TempConfigFor (adapt_class, i) != NULL)
        {
            FreeTempConfig (TempConfigFor (adapt_class, i));
        }
    }

    FreeBitVector (adapt_class->PermProtos);
    FreeBitVector (adapt_class->PermConfigs);
    destroy_nodes (adapt_class->TempProtos, FreeTempProto);
    Efree(adapt_class);
}


/*---------------------------------------------------------------------------*/
/**
     * Allocates memory for adapted tempates.
     * each char in unicharset to the newly created templates
     *
     * @param PopulateFromUnicharset if true, add an empty class for
     * @return Ptr to new adapted templates.
     *
     * @note Globals: none
     * @note Exceptions: none
     * @note History: Fri Mar  8 10:15:28 1991, DSJ, Created.
     */
ADAPT_TEMPLATES Classify::NewAdaptedTemplates(bool InitFromUnicharset)
{
    ADAPT_TEMPLATES Templates;
    int i;

    Templates = (ADAPT_TEMPLATES) Emalloc (sizeof (ADAPT_TEMPLATES_STRUCT));

    Templates->Templates = NewIntTemplates ();
    Templates->NumPermClasses = 0;
    Templates->NumNonEmptyClasses = 0;

    /* Insert an empty class for each unichar id in unicharset */
    for (i = 0; i < MAX_NUM_CLASSES; i++)
    {
        Templates->Class[i] = NULL;
        if (InitFromUnicharset && i < unicharset.size())
        {
            AddAdaptedClass(Templates, NewAdaptedClass(), i);
        }
    }

    return (Templates);
}                                /* NewAdaptedTemplates */

/*----------------------------------------------------------------------------*/
void free_adapted_templates(ADAPT_TEMPLATES templates)
{
    if (templates != NULL)
    {
        for (int i = 0; i < (templates->Templates)->NumClasses; i++) free_adapted_class (templates->Class[i]);
        {
            free_int_templates (templates->Templates);
        }

        Efree(templates);
    }
}


/*---------------------------------------------------------------------------*/
/**
 * This routine allocates and returns a new temporary config.
 *
 * @param MaxProtoId  max id of any proto in new config
 * @return Ptr to new temp config.
 *
 * @note Globals: none
 * @note Exceptions: none
 * @note History: Thu Mar 14 13:28:21 1991, DSJ, Created.
 */
TEMP_CONFIG NewTempConfig(int MaxProtoId)
{
    TEMP_CONFIG Config;
    int NumProtos = MaxProtoId + 1;

    Config = (TEMP_CONFIG) alloc_struct (sizeof (TEMP_CONFIG_STRUCT), "TEMP_CONFIG_STRUCT");
    Config->Protos = NewBitVector (NumProtos);

    Config->NumTimesSeen = 1;
    Config->MaxProtoId = MaxProtoId;
    Config->ProtoVectorSize = WordsInVectorOfSize (NumProtos);
    Config->ContextsSeen = NIL;
    zero_all_bits (Config->Protos, Config->ProtoVectorSize);

    return (Config);
}                                /* NewTempConfig */


/*---------------------------------------------------------------------------*/
/**
 * This routine allocates and returns a new temporary proto.
 *
 * @return Ptr to new temporary proto.
 *
 * @note Globals: none
 * @note Exceptions: none
 * @note History: Thu Mar 14 13:31:31 1991, DSJ, Created.
 */
TEMP_PROTO NewTempProto()
{
    return ((TEMP_PROTO) alloc_struct (sizeof (TEMP_PROTO_STRUCT), "TEMP_PROTO_STRUCT"));
}                                /* NewTempProto */


/*---------------------------------------------------------------------------*/
/**
     * This routine prints a summary of the adapted templates
     *  in Templates to File.
     *
     * @param File    open text file to print Templates to
     * @param Templates adapted templates to print to File
     *
     * @note Globals: none
     * @note Exceptions: none
     * @note History: Wed Mar 20 13:35:29 1991, DSJ, Created.
     */
void Classify::PrintAdaptedTemplates(FILE *File, ADAPT_TEMPLATES Templates)
{
    int i;
    INT_CLASS IClass;
    ADAPT_CLASS AClass;

#ifndef SECURE_NAMES
    fprintf (File, "\n\nSUMMARY OF ADAPTED TEMPLATES:\n\n");
    fprintf (File, "Num classes = %d;  Num permanent classes = %d\n\n", Templates->NumNonEmptyClasses, Templates->NumPermClasses);
    fprintf (File, "   Id  NC NPC  NP NPP\n");
    fprintf (File, "------------------------\n");

    for (i = 0; i < (Templates->Templates)->NumClasses; i++)
    {
        IClass = Templates->Templates->Class[i];
        AClass = Templates->Class[i];

        if (!IsEmptyAdaptedClass (AClass))
        {
            fprintf (File, "%5d  %s %3d %3d %3d %3d\n", i, unicharset.id_to_unichar(i),
                     IClass->NumConfigs, AClass->NumPermConfigs, IClass->NumProtos, IClass->NumProtos - myCount(AClass->TempProtos));
        }
    }
#endif
    fprintf (File, "\n");

}                                /* PrintAdaptedTemplates */


/*---------------------------------------------------------------------------*/
/**
 * Read an adapted class description from File and return
 * a ptr to the adapted class.
 *
 * @param File  open file to read adapted class from
 * @return Ptr to new adapted class.
 *
 * @note Globals: none
 * @note Exceptions: none
 * @note History: Tue Mar 19 14:11:01 1991, DSJ, Created.
 */
ADAPT_CLASS ReadAdaptedClass(FILE *File)
{
    int NumTempProtos;
    int NumConfigs;
    int i;
    ADAPT_CLASS Class;
    TEMP_PROTO TempProto;

    /* first read high level adapted class structure */
    Class = (ADAPT_CLASS) Emalloc (sizeof (ADAPT_CLASS_STRUCT));
    fread ((char *) Class, sizeof (ADAPT_CLASS_STRUCT), 1, File);

    /* then read in the definitions of the permanent protos and configs */
    Class->PermProtos = NewBitVector (MAX_NUM_PROTOS);
    Class->PermConfigs = NewBitVector (MAX_NUM_CONFIGS);
    fread ((char *) Class->PermProtos, sizeof (uinT32), WordsInVectorOfSize (MAX_NUM_PROTOS), File);
    fread ((char *) Class->PermConfigs, sizeof (uinT32), WordsInVectorOfSize (MAX_NUM_CONFIGS), File);

    /* then read in the list of temporary protos */
    fread ((char *) &NumTempProtos, sizeof (int), 1, File);
    Class->TempProtos = NIL;
    for (i = 0; i < NumTempProtos; i++)
    {
        TempProto = (TEMP_PROTO) alloc_struct (sizeof (TEMP_PROTO_STRUCT), "TEMP_PROTO_STRUCT");
        fread ((char *) TempProto, sizeof (TEMP_PROTO_STRUCT), 1, File);
        Class->TempProtos = push_last (Class->TempProtos, TempProto);
    }

    /* then read in the adapted configs */
    fread ((char *) &NumConfigs, sizeof (int), 1, File);
    for (i = 0; i < NumConfigs; i++)
    {
        if (test_bit (Class->PermConfigs, i))
        {
            Class->Config[i].Perm = ReadPermConfig (File);
        }
        else
        {
            Class->Config[i].Temp = ReadTempConfig (File);
        }
    }

    return (Class);
}                                /* ReadAdaptedClass */


/*---------------------------------------------------------------------------*/
/**
     * Read a set of adapted templates from File and return
     * a ptr to the templates.
     *
     * @param File  open text file to read adapted templates from
     * @return Ptr to adapted templates read from File.
     *
     * @note Globals: none
     * @note Exceptions: none
     * @note History: Mon Mar 18 15:18:10 1991, DSJ, Created.
     */
ADAPT_TEMPLATES Classify::ReadAdaptedTemplates(FILE *File)
{
    int i;
    ADAPT_TEMPLATES Templates;

    /* first read the high level adaptive template struct */
    Templates = (ADAPT_TEMPLATES) Emalloc (sizeof (ADAPT_TEMPLATES_STRUCT));
    fread ((char *) Templates, sizeof (ADAPT_TEMPLATES_STRUCT), 1, File);

    /* then read in the basic integer templates */
    Templates->Templates = ReadIntTemplates (File);

    /* then read in the adaptive info for each class */
    for (i = 0; i < (Templates->Templates)->NumClasses; i++)
    {
        Templates->Class[i] = ReadAdaptedClass (File);
    }

    return (Templates);

}                               /* ReadAdaptedTemplates */

/*---------------------------------------------------------------------------*/
/**
 * Read a permanent configuration description from File
 * and return a ptr to it.
 *
 * @param File  open file to read permanent config from
 * @return Ptr to new permanent configuration description.
 *
 * @note Globals: none
 * @note Exceptions: none
 * @note History: Tue Mar 19 14:25:26 1991, DSJ, Created.
 */
PERM_CONFIG ReadPermConfig(FILE *File)
{
    PERM_CONFIG Config;
    uinT8 NumAmbigs;

    fread ((char *) &NumAmbigs, sizeof (uinT8), 1, File);
    Config = (PERM_CONFIG) Emalloc (sizeof (UNICHAR_ID) * (NumAmbigs + 1));
    fread (Config, sizeof (UNICHAR_ID), NumAmbigs, File);
    Config[NumAmbigs] = -1;

    return (Config);

}                                /* ReadPermConfig */


/*---------------------------------------------------------------------------*/
/**
 * Read a temporary configuration description from File
 * and return a ptr to it.
 *
 * @param File  open file to read temporary config from
 * @return Ptr to new temporary configuration description.
 *
 * @note Globals: none
 * @note Exceptions: none
 * @note History: Tue Mar 19 14:29:59 1991, DSJ, Created.
 */
TEMP_CONFIG ReadTempConfig(FILE *File)
{
    TEMP_CONFIG Config;

    Config = (TEMP_CONFIG) alloc_struct (sizeof (TEMP_CONFIG_STRUCT), "TEMP_CONFIG_STRUCT");
    fread ((char *) Config, sizeof (TEMP_CONFIG_STRUCT), 1, File);

    Config->Protos = NewBitVector (Config->ProtoVectorSize * BITSINLONG);
    fread ((char *) Config->Protos, sizeof (uinT32), Config->ProtoVectorSize, File);

    return (Config);

}                                /* ReadTempConfig */


/*---------------------------------------------------------------------------*/
/**
 * This routine writes a binary representation of Class
 * to File.
 *
 * @param File    open file to write Class to
 * @param Class   adapted class to write to File
 * @param NumConfigs  number of configs in Class
 *
 * @note Globals: none
 * @note Exceptions: none
 * @note History: Tue Mar 19 13:33:51 1991, DSJ, Created.
 */
void WriteAdaptedClass(FILE *File, ADAPT_CLASS Class, int NumConfigs)
{
    int NumTempProtos;
    LIST TempProtos;
    int i;

    /* first write high level adapted class structure */
    fwrite ((char *) Class, sizeof (ADAPT_CLASS_STRUCT), 1, File);

    /* then write out the definitions of the permanent protos and configs */
    fwrite ((char *) Class->PermProtos, sizeof (uinT32), WordsInVectorOfSize (MAX_NUM_PROTOS), File);
    fwrite ((char *) Class->PermConfigs, sizeof (uinT32), WordsInVectorOfSize (MAX_NUM_CONFIGS), File);

    /* then write out the list of temporary protos */
    NumTempProtos = myCount(Class->TempProtos);
    fwrite ((char *) &NumTempProtos, sizeof (int), 1, File);
    TempProtos = Class->TempProtos;
    iterate (TempProtos)
    {
        void* proto = first_node(TempProtos);
        fwrite ((char *) proto, sizeof (TEMP_PROTO_STRUCT), 1, File);
    }

    /* then write out the adapted configs */
    fwrite ((char *) &NumConfigs, sizeof (int), 1, File);
    for (i = 0; i < NumConfigs; i++)
    {
        if (test_bit (Class->PermConfigs, i))
        {
            WritePermConfig (File, Class->Config[i].Perm);
        }
        else
        {
            WriteTempConfig (File, Class->Config[i].Temp);
        }
    }
}                                /* WriteAdaptedClass */


/*---------------------------------------------------------------------------*/

/**
     * This routine saves Templates to File in a binary format.
     *
     * @param File    open text file to write Templates to
     * @param Templates set of adapted templates to write to File
     *
     * @note Globals: none
     * @note Exceptions: none
     * @note History: Mon Mar 18 15:07:32 1991, DSJ, Created.
     */
void Classify::WriteAdaptedTemplates(FILE *File, ADAPT_TEMPLATES Templates)
{
    int i;

    /* first write the high level adaptive template struct */
    fwrite ((char *) Templates, sizeof (ADAPT_TEMPLATES_STRUCT), 1, File);

    /* then write out the basic integer templates */
    WriteIntTemplates (File, Templates->Templates, unicharset);

    /* then write out the adaptive info for each class */
    for (i = 0; i < (Templates->Templates)->NumClasses; i++)
    {
        WriteAdaptedClass (File, Templates->Class[i], Templates->Templates->Class[i]->NumConfigs);
    }
}                                /* WriteAdaptedTemplates */

/*---------------------------------------------------------------------------*/
/**
 * This routine writes a binary representation of a
 * permanent configuration to File.
 *
 * @param File  open file to write Config to
 * @param Config  permanent config to write to File
 *
 * @note Globals: none
 * @note Exceptions: none
 * @note History: Tue Mar 19 13:55:44 1991, DSJ, Created.
 */
void WritePermConfig(FILE *File, PERM_CONFIG Config)
{
    uinT8 NumAmbigs = 0;

    assert (Config != NULL);
    while (Config[NumAmbigs] > 0) ++NumAmbigs;

    fwrite ((char *) &NumAmbigs, sizeof (uinT8), 1, File);
    fwrite (Config, sizeof (UNICHAR_ID), NumAmbigs, File);
}                                /* WritePermConfig */


/*---------------------------------------------------------------------------*/
/**
 * This routine writes a binary representation of a
 * temporary configuration to File.
 *
 * @param File  open file to write Config to
 * @param Config  temporary config to write to File
 *
 * @note Globals: none
 * @note Exceptions: none
 * @note History: Tue Mar 19 14:00:28 1991, DSJ, Created.
 */
void WriteTempConfig(FILE *File, TEMP_CONFIG Config)
{
    assert (Config != NULL);
    /* contexts not yet implemented */
    assert (Config->ContextsSeen == NULL);

    fwrite ((char *) Config, sizeof (TEMP_CONFIG_STRUCT), 1, File);
    fwrite ((char *) Config->Protos, sizeof (uinT32), Config->ProtoVectorSize, File);

}                                /* WriteTempConfig */
/////////////////////////////////////////////////////////////////adaptive////////////////////////////////////////

/////////////////////////////////////////////////////////////////intmatcher////////////////////////////////////////
#define CLASS_MASK_SIZE ((MAX_NUM_CLASSES*NUM_BITS_PER_CLASS \
        +BITS_PER_WERD-1)/BITS_PER_WERD)

/*----------------------------------------------------------------------------
                    Global Data Definitions and Declarations
----------------------------------------------------------------------------*/
#define  SE_TABLE_BITS    9
#define  SE_TABLE_SIZE  512
#define TEMPLATE_CACHE 2
static uinT8 SimilarityEvidenceTable[SE_TABLE_SIZE];
static uinT8 offset_table[256] = {
  255, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0
};
static uinT8 next_table[256] = {
  0, 0, 0, 0x2, 0, 0x4, 0x4, 0x6, 0, 0x8, 0x8, 0x0a, 0x08, 0x0c, 0x0c, 0x0e,
  0, 0x10, 0x10, 0x12, 0x10, 0x14, 0x14, 0x16, 0x10, 0x18, 0x18, 0x1a, 0x18,
  0x1c, 0x1c, 0x1e,
  0, 0x20, 0x20, 0x22, 0x20, 0x24, 0x24, 0x26, 0x20, 0x28, 0x28, 0x2a, 0x28,
  0x2c, 0x2c, 0x2e,
  0x20, 0x30, 0x30, 0x32, 0x30, 0x34, 0x34, 0x36, 0x30, 0x38, 0x38, 0x3a,
  0x38, 0x3c, 0x3c, 0x3e,
  0, 0x40, 0x40, 0x42, 0x40, 0x44, 0x44, 0x46, 0x40, 0x48, 0x48, 0x4a, 0x48,
  0x4c, 0x4c, 0x4e,
  0x40, 0x50, 0x50, 0x52, 0x50, 0x54, 0x54, 0x56, 0x50, 0x58, 0x58, 0x5a,
  0x58, 0x5c, 0x5c, 0x5e,
  0x40, 0x60, 0x60, 0x62, 0x60, 0x64, 0x64, 0x66, 0x60, 0x68, 0x68, 0x6a,
  0x68, 0x6c, 0x6c, 0x6e,
  0x60, 0x70, 0x70, 0x72, 0x70, 0x74, 0x74, 0x76, 0x70, 0x78, 0x78, 0x7a,
  0x78, 0x7c, 0x7c, 0x7e,
  0, 0x80, 0x80, 0x82, 0x80, 0x84, 0x84, 0x86, 0x80, 0x88, 0x88, 0x8a, 0x88,
  0x8c, 0x8c, 0x8e,
  0x80, 0x90, 0x90, 0x92, 0x90, 0x94, 0x94, 0x96, 0x90, 0x98, 0x98, 0x9a,
  0x98, 0x9c, 0x9c, 0x9e,
  0x80, 0xa0, 0xa0, 0xa2, 0xa0, 0xa4, 0xa4, 0xa6, 0xa0, 0xa8, 0xa8, 0xaa,
  0xa8, 0xac, 0xac, 0xae,
  0xa0, 0xb0, 0xb0, 0xb2, 0xb0, 0xb4, 0xb4, 0xb6, 0xb0, 0xb8, 0xb8, 0xba,
  0xb8, 0xbc, 0xbc, 0xbe,
  0x80, 0xc0, 0xc0, 0xc2, 0xc0, 0xc4, 0xc4, 0xc6, 0xc0, 0xc8, 0xc8, 0xca,
  0xc8, 0xcc, 0xcc, 0xce,
  0xc0, 0xd0, 0xd0, 0xd2, 0xd0, 0xd4, 0xd4, 0xd6, 0xd0, 0xd8, 0xd8, 0xda,
  0xd8, 0xdc, 0xdc, 0xde,
  0xc0, 0xe0, 0xe0, 0xe2, 0xe0, 0xe4, 0xe4, 0xe6, 0xe0, 0xe8, 0xe8, 0xea,
  0xe8, 0xec, 0xec, 0xee,
  0xe0, 0xf0, 0xf0, 0xf2, 0xf0, 0xf4, 0xf4, 0xf6, 0xf0, 0xf8, 0xf8, 0xfa,
  0xf8, 0xfc, 0xfc, 0xfe
};

static uinT32 EvidenceTableMask;

static uinT32 MultTruncShiftBits;

static uinT32 TableTruncShiftBits;

uinT32 EvidenceMultMask;

static inT16 LocalMatcherMultiplier;

INT_VAR(classify_class_pruner_threshold, 229,
        "Class Pruner Threshold 0-255:        ");

INT_VAR(classify_class_pruner_multiplier, 30,
        "Class Pruner Multiplier 0-255:       ");

INT_VAR(classify_integer_matcher_multiplier, 14,
        "Integer Matcher Multiplier  0-255:   ");

INT_VAR(classify_int_theta_fudge, 128,
        "Integer Matcher Theta Fudge 0-255:   ");

INT_VAR(classify_cp_cutoff_strength, 7,
        "Class Pruner CutoffStrength:         ");

INT_VAR(classify_evidence_table_bits, 9,
        "Bits in Similarity to Evidence Lookup  8-9:   ");

INT_VAR(classify_int_evidence_trunc_bits, 14,
        "Integer Evidence Truncation Bits (Distance) 8-14:   ");

double_VAR(classify_se_exponential_multiplier, 0,
                "Similarity to Evidence Table Exponential Multiplier: ");

double_VAR(classify_similarity_center, 0.0075,
           "Center of Similarity Curve: ");

INT_VAR(classify_adapt_proto_thresh, 230,
        "Threshold for good protos during adaptive 0-255:   ");

INT_VAR(classify_adapt_feature_thresh, 230,
        "Threshold for good features during adaptive 0-255:   ");

BOOL_VAR(disable_character_fragments, FALSE,
         "Do not include character fragments in the"
         " results of the classifier");

BOOL_VAR(matcher_debug_separate_windows, FALSE,
         "Use two different windows for debugging the matching: "
         "One for the protos and one for the features.");

int protoword_lookups;
int zero_protowords;
int proto_shifts;
int set_proto_bits;
int config_shifts;
int set_config_bits;

/*----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
int Classify::ClassPruner(INT_TEMPLATES IntTemplates,
                          inT16 NumFeatures,
                          INT_FEATURE_ARRAY Features,
                          CLASS_NORMALIZATION_ARRAY NormalizationFactors,
                          CLASS_CUTOFF_ARRAY ExpectedNumFeatures,
                          CLASS_PRUNER_RESULTS Results,
                          int Debug) {
    Q_UNUSED(Debug);
/*
 **      Parameters:
 **              IntTemplates           Class pruner tables
 **              NumFeatures            Number of features in blob
 **              Features               Array of features
 **              NormalizationFactors   Array of fudge factors from blob
 **                                     normalization process
 **                                     (by CLASS_INDEX)
 **              ExpectedNumFeatures    Array of expected number of features
 **                                     for each class
 **                                     (by CLASS_INDEX)
 **              Results                Sorted Array of pruned classes
 **                                     (by CLASS_ID)
 **              Debug                  Debugger flag: 1=debugger on
 **      Globals:
 **              classify_class_pruner_threshold   Cutoff threshold
 **              classify_class_pruner_multiplier  Normalization factor multiplier
 **      Operation:
 **              Prune the classes using a modified fast match table.
 **              Return a sorted list of classes along with the number
 **              of pruned classes in that list.
 **      Return: Number of pruned classes.
 **      Exceptions: none
 **      History: Tue Feb 19 10:24:24 MST 1991, RWM, Created.
 */
  uinT32 PrunerWord;
  inT32 class_index;             //index to class
  int Word;
  uinT32 *BasePrunerAddress;
  uinT32 feature_address;        //current feature index
  INT_FEATURE feature;           //current feature
  CLASS_PRUNER *ClassPruner;
  int PrunerSet;
  int NumPruners;
  inT32 feature_index;           //current feature

  static int ClassCount[MAX_NUM_CLASSES];
  static int NormCount[MAX_NUM_CLASSES];
  static int SortKey[MAX_NUM_CLASSES + 1];
  static int SortIndex[MAX_NUM_CLASSES + 1];
  int out_class;
  int MaxNumClasses;
  int MaxCount;
  int NumClasses;
  int *ClassCountPtr;
  CLASS_ID class_id;

  MaxNumClasses = IntTemplates->NumClasses;

  /* Clear Class Counts */
  ClassCountPtr = &(ClassCount[0]);
  for (class_id = 0; class_id < MaxNumClasses; class_id++) {
    *ClassCountPtr++ = 0;
  }

  /* Update Class Counts */
  NumPruners = IntTemplates->NumClassPruners;
  for (feature_index = 0; feature_index < NumFeatures; feature_index++) {
    feature = &Features[feature_index];
    feature_address = (((feature->X * NUM_CP_BUCKETS >> 8) * NUM_CP_BUCKETS +
                        (feature->Y * NUM_CP_BUCKETS >> 8)) * NUM_CP_BUCKETS +
                       (feature->Theta * NUM_CP_BUCKETS >> 8)) << 1;
    ClassPruner = IntTemplates->ClassPruner;
    class_index = 0;

    for (PrunerSet = 0; PrunerSet < NumPruners; PrunerSet++, ClassPruner++) {
      BasePrunerAddress = (uinT32 *) (*ClassPruner) + feature_address;

      for (Word = 0; Word < (int)WERDS_PER_CP_VECTOR; Word++) {
        PrunerWord = *BasePrunerAddress++;
        // This inner loop is unrolled to speed up the ClassPruner.
        // Currently gcc would not unroll it unless it is set to O3
        // level of optimization or -funroll-loops is specified.
        /*
        uinT32 class_mask = (1 << NUM_BITS_PER_CLASS) - 1;
        for (int bit = 0; bit < BITS_PER_WERD/NUM_BITS_PER_CLASS; bit++) {
          ClassCount[class_index++] += PrunerWord & class_mask;
          PrunerWord >>= NUM_BITS_PER_CLASS;
        }
        */
        ClassCount[class_index++] += cp_maps[PrunerWord & 3];
        PrunerWord >>= 2;
        ClassCount[class_index++] += cp_maps[PrunerWord & 3];
        PrunerWord >>= 2;
        ClassCount[class_index++] += cp_maps[PrunerWord & 3];
        PrunerWord >>= 2;
        ClassCount[class_index++] += cp_maps[PrunerWord & 3];
        PrunerWord >>= 2;
        ClassCount[class_index++] += cp_maps[PrunerWord & 3];
        PrunerWord >>= 2;
        ClassCount[class_index++] += cp_maps[PrunerWord & 3];
        PrunerWord >>= 2;
        ClassCount[class_index++] += cp_maps[PrunerWord & 3];
        PrunerWord >>= 2;
        ClassCount[class_index++] += cp_maps[PrunerWord & 3];
        PrunerWord >>= 2;
        ClassCount[class_index++] += cp_maps[PrunerWord & 3];
        PrunerWord >>= 2;
        ClassCount[class_index++] += cp_maps[PrunerWord & 3];
        PrunerWord >>= 2;
        ClassCount[class_index++] += cp_maps[PrunerWord & 3];
        PrunerWord >>= 2;
        ClassCount[class_index++] += cp_maps[PrunerWord & 3];
        PrunerWord >>= 2;
        ClassCount[class_index++] += cp_maps[PrunerWord & 3];
        PrunerWord >>= 2;
        ClassCount[class_index++] += cp_maps[PrunerWord & 3];
        PrunerWord >>= 2;
        ClassCount[class_index++] += cp_maps[PrunerWord & 3];
        PrunerWord >>= 2;
        ClassCount[class_index++] += cp_maps[PrunerWord & 3];
      }
    }
  }

  /* Adjust Class Counts for Number of Expected Features */
  for (class_id = 0; class_id < MaxNumClasses; class_id++) {
    if (NumFeatures < ExpectedNumFeatures[class_id]) {
      int deficit = ExpectedNumFeatures[class_id] - NumFeatures;
      ClassCount[class_id] -= ClassCount[class_id] * deficit /
                           (NumFeatures*classify_cp_cutoff_strength + deficit);
    }
    if (!unicharset.get_enabled(class_id))
      ClassCount[class_id] = 0;  // This char is disabled!

    // Do not include character fragments in the class pruner
    // results if disable_character_fragments is true.
    if (disable_character_fragments && unicharset.get_fragment(class_id)) {
      ClassCount[class_id] = 0;
    }
  }

  /* Adjust Class Counts for Normalization Factors */
  MaxCount = 0;
  for (class_id = 0; class_id < MaxNumClasses; class_id++) {
    NormCount[class_id] = ClassCount[class_id]
      - ((classify_class_pruner_multiplier * NormalizationFactors[class_id]) >> 8)
      * cp_maps[3] / 3;
    if (NormCount[class_id] > MaxCount &&
        // This additional check is added in order to ensure that
        // the classifier will return at least one non-fragmented
        // character match.
        // TODO(daria): verify that this helps accuracy and does not
        // hurt performance.
        !unicharset.get_fragment(class_id)) {
      MaxCount = NormCount[class_id];
    }
  }

  /* Prune Classes */
  MaxCount *= classify_class_pruner_threshold;
  MaxCount >>= 8;
  /* Select Classes */
  if (MaxCount < 1)
    MaxCount = 1;
  NumClasses = 0;
  for (class_id = 0; class_id < MaxNumClasses; class_id++) {
    if (NormCount[class_id] >= MaxCount) {
      NumClasses++;
      SortIndex[NumClasses] = class_id;
      SortKey[NumClasses] = NormCount[class_id];
    }
  }

  /* Sort Classes using Heapsort Algorithm */
  if (NumClasses > 1)
    HeapSort(NumClasses, SortKey, SortIndex);

  if (tord_display_ratings > 1) {
    cprintf ("CP:%d classes, %d features:\n", NumClasses, NumFeatures);
    for (class_id = 0; class_id < NumClasses; class_id++) {
      cprintf ("%s:C=%d, E=%d, N=%d, Rat=%d\n",
               unicharset.debug_str(SortIndex[NumClasses - class_id]).string(),
               ClassCount[SortIndex[NumClasses - class_id]],
               ExpectedNumFeatures[SortIndex[NumClasses - class_id]],
               SortKey[NumClasses - class_id],
               1010 - 1000 * SortKey[NumClasses - class_id] /
                 (cp_maps[3] * NumFeatures));
    }
    if (tord_display_ratings > 2) {
      NumPruners = IntTemplates->NumClassPruners;
      for (feature_index = 0; feature_index < NumFeatures;
      feature_index++) {
        cprintf ("F=%3d,", feature_index);
        feature = &Features[feature_index];
        feature_address =
          (((feature->X * NUM_CP_BUCKETS >> 8) * NUM_CP_BUCKETS +
          (feature->Y * NUM_CP_BUCKETS >> 8)) * NUM_CP_BUCKETS +
          (feature->Theta * NUM_CP_BUCKETS >> 8)) << 1;
        ClassPruner = IntTemplates->ClassPruner;
        class_index = 0;
        for (PrunerSet = 0; PrunerSet < NumPruners;
        PrunerSet++, ClassPruner++) {
          BasePrunerAddress = (uinT32 *) (*ClassPruner)
            + feature_address;

          for (Word = 0; Word < (int)WERDS_PER_CP_VECTOR; Word++) {
            PrunerWord = *BasePrunerAddress++;
            for (class_id = 0; class_id < 16; class_id++, class_index++) {
              if (NormCount[class_index] >= MaxCount)
                cprintf (" %s=%d,",
                  unicharset.id_to_unichar(class_index),
                  PrunerWord & 3);
              PrunerWord >>= 2;
            }
          }
        }
        cprintf ("\n");
      }
      cprintf ("Adjustments:");
      for (class_id = 0; class_id < MaxNumClasses; class_id++) {
        if (NormCount[class_id] > MaxCount)
          cprintf (" %s=%d,",
            unicharset.id_to_unichar(class_id),
            -((classify_class_pruner_multiplier *
            NormalizationFactors[class_id]) >> 8) * cp_maps[3] / 3);
      }
      cprintf ("\n");
    }
  }

  /* Set Up Results */
  for (class_id = 0, out_class = 0; class_id < NumClasses; class_id++) {
    Results[out_class].Class = SortIndex[NumClasses - class_id];
    Results[out_class].Rating =
      1.0 - SortKey[NumClasses -
      class_id] / ((float) cp_maps[3] * NumFeatures);
    out_class++;
  }
  NumClasses = out_class;
  return NumClasses;

}

/*---------------------------------------------------------------------------*/
void IntegerMatcher(INT_CLASS ClassTemplate,
                    BIT_VECTOR ProtoMask,
                    BIT_VECTOR ConfigMask,
                    uinT16 BlobLength,
                    inT16 NumFeatures,
                    INT_FEATURE_ARRAY Features,
                    uinT8 NormalizationFactor,
                    INT_RESULT Result,
                    int Debug) {
/*
 **      Parameters:
 **              ClassTemplate             Prototypes & tables for a class
 **              BlobLength                Length of unormalized blob
 **              NumFeatures               Number of features in blob
 **              Features                  Array of features
 **              NormalizationFactor       Fudge factor from blob
 **                                        normalization process
 **              Result                    Class rating & configuration:
 **                                        (0.0 -> 1.0), 0=good, 1=bad
 **              Debug                     Debugger flag: 1=debugger on
 **      Globals:
 **              LocalMatcherMultiplier    Normalization factor multiplier
 **              classify_int_theta_fudge             Theta fudge factor used for
 **                                        evidence calculation
 **      Operation:
 **              IntegerMatcher returns the best configuration and rating
 **              for a single class.  The class matched against is determined
 **              by the uniqueness of the ClassTemplate parameter.  The
 **              best rating and its associated configuration are returned.
 **      Return:
 **      Exceptions: none
 **      History: Tue Feb 19 16:36:23 MST 1991, RWM, Created.
 */
  static uinT8 FeatureEvidence[MAX_NUM_CONFIGS];
  static int SumOfFeatureEvidence[MAX_NUM_CONFIGS];
  static uinT8 ProtoEvidence[MAX_NUM_PROTOS][MAX_PROTO_INDEX];
  int Feature;
  int BestMatch;

  if (MatchDebuggingOn (Debug))
    cprintf ("Integer Matcher -------------------------------------------\n");

  IMClearTables(ClassTemplate, SumOfFeatureEvidence, ProtoEvidence);
  Result->FeatureMisses = 0;

  for (Feature = 0; Feature < NumFeatures; Feature++) {
    int csum = IMUpdateTablesForFeature(ClassTemplate, ProtoMask, ConfigMask,
                                        Feature, &(Features[Feature]),
                                        FeatureEvidence, SumOfFeatureEvidence,
                                        ProtoEvidence, Debug);
    // Count features that were missed over all configs.
    if (csum == 0)
      Result->FeatureMisses++;
  }

#ifndef GRAPHICS_DISABLED
  if (PrintProtoMatchesOn (Debug) || PrintMatchSummaryOn (Debug))
    IMDebugFeatureProtoError(ClassTemplate,
                             ProtoMask,
                             ConfigMask,
                             SumOfFeatureEvidence,
                             ProtoEvidence,
                             NumFeatures,
                             Debug);

  if (DisplayProtoMatchesOn (Debug))
    IMDisplayProtoDebugInfo(ClassTemplate,
                            ProtoMask,
                            ConfigMask,
                            ProtoEvidence,
                            Debug);

  if (DisplayFeatureMatchesOn (Debug))
    IMDisplayFeatureDebugInfo(ClassTemplate,
                              ProtoMask,
                              ConfigMask,
                              NumFeatures,
                              Features,
                              Debug);
#endif

  IMUpdateSumOfProtoEvidences(ClassTemplate,
                              ConfigMask,
                              SumOfFeatureEvidence,
                              ProtoEvidence,
                              NumFeatures);

  IMNormalizeSumOfEvidences(ClassTemplate,
                            SumOfFeatureEvidence,
                            NumFeatures,
                            NumFeatures);

  BestMatch =
    IMFindBestMatch(ClassTemplate,
                    SumOfFeatureEvidence,
                    BlobLength,
                    NormalizationFactor,
                    Result);

#ifndef GRAPHICS_DISABLED
  if (PrintMatchSummaryOn (Debug))
    IMDebugBestMatch(BestMatch, Result, BlobLength, NormalizationFactor);

  if (MatchDebuggingOn (Debug))
    cprintf ("Match Complete --------------------------------------------\n");
#endif

}


/*---------------------------------------------------------------------------*/
int FindGoodProtos(INT_CLASS ClassTemplate,
                   BIT_VECTOR ProtoMask,
                   BIT_VECTOR ConfigMask,
                   uinT16 BlobLength,
                   inT16 NumFeatures,
                   INT_FEATURE_ARRAY Features,
                   PROTO_ID *ProtoArray,
                   int Debug) {
    Q_UNUSED(BlobLength);
/*
 **      Parameters:
 **              ClassTemplate             Prototypes & tables for a class
 **              ProtoMask                 AND Mask for proto word
 **              ConfigMask                AND Mask for config word
 **              BlobLength                Length of unormalized blob
 **              NumFeatures               Number of features in blob
 **              Features                  Array of features
 **              ProtoArray                Array of good protos
 **              Debug                     Debugger flag: 1=debugger on
 **      Globals:
 **              LocalMatcherMultiplier    Normalization factor multiplier
 **              classify_int_theta_fudge             Theta fudge factor used for
 **                                        evidence calculation
 **              classify_adapt_proto_thresh          Threshold for good protos
 **      Operation:
 **              FindGoodProtos finds all protos whose normalized proto-evidence
 **              exceed classify_adapt_proto_thresh.  The list is ordered by increasing
 **              proto id number.
 **      Return:
 **              Number of good protos in ProtoArray.
 **      Exceptions: none
 **      History: Tue Mar 12 17:09:26 MST 1991, RWM, Created
 */
  static uinT8 FeatureEvidence[MAX_NUM_CONFIGS];
  static int SumOfFeatureEvidence[MAX_NUM_CONFIGS];
  static uinT8 ProtoEvidence[MAX_NUM_PROTOS][MAX_PROTO_INDEX];
  int Feature;
  register uinT8 *UINT8Pointer;
  register int ProtoIndex;
  int NumProtos;
  int NumGoodProtos;
  uinT16 ActualProtoNum;
  register int Temp;

  /* DEBUG opening heading */
  if (MatchDebuggingOn (Debug))
    cprintf
      ("Find Good Protos -------------------------------------------\n");

  IMClearTables(ClassTemplate, SumOfFeatureEvidence, ProtoEvidence);

  for (Feature = 0; Feature < NumFeatures; Feature++)
    IMUpdateTablesForFeature (ClassTemplate, ProtoMask, ConfigMask, Feature,
      &(Features[Feature]), FeatureEvidence,
      SumOfFeatureEvidence, ProtoEvidence, Debug);

#ifndef GRAPHICS_DISABLED
  if (PrintProtoMatchesOn (Debug) || PrintMatchSummaryOn (Debug))
    IMDebugFeatureProtoError(ClassTemplate,
                             ProtoMask,
                             ConfigMask,
                             SumOfFeatureEvidence,
                             ProtoEvidence,
                             NumFeatures,
                             Debug);
#endif

  /* Average Proto Evidences & Find Good Protos */
  NumProtos = ClassTemplate->NumProtos;
  NumGoodProtos = 0;
  for (ActualProtoNum = 0; ActualProtoNum < NumProtos; ActualProtoNum++) {
    /* Compute Average for Actual Proto */
    Temp = 0;
    UINT8Pointer = &(ProtoEvidence[ActualProtoNum][0]);
    for (ProtoIndex = ClassTemplate->ProtoLengths[ActualProtoNum];
      ProtoIndex > 0; ProtoIndex--, UINT8Pointer++)
    Temp += *UINT8Pointer;

    Temp /= ClassTemplate->ProtoLengths[ActualProtoNum];

    /* Find Good Protos */
    if (Temp >= classify_adapt_proto_thresh) {
      *ProtoArray = ActualProtoNum;
      ProtoArray++;
      NumGoodProtos++;
    }
  }

  if (MatchDebuggingOn (Debug))
    cprintf ("Match Complete --------------------------------------------\n");
  return NumGoodProtos;

}


/*---------------------------------------------------------------------------*/
int FindBadFeatures(INT_CLASS ClassTemplate,
                    BIT_VECTOR ProtoMask,
                    BIT_VECTOR ConfigMask,
                    uinT16 BlobLength,
                    inT16 NumFeatures,
                    INT_FEATURE_ARRAY Features,
                    FEATURE_ID *FeatureArray,
                    int Debug) {
    Q_UNUSED(BlobLength);
/*
 **      Parameters:
 **              ClassTemplate             Prototypes & tables for a class
 **              ProtoMask                 AND Mask for proto word
 **              ConfigMask                AND Mask for config word
 **              BlobLength                Length of unormalized blob
 **              NumFeatures               Number of features in blob
 **              Features                  Array of features
 **              FeatureArray              Array of bad features
 **              Debug                     Debugger flag: 1=debugger on
 **      Globals:
 **              LocalMatcherMultiplier    Normalization factor multiplier
 **              classify_int_theta_fudge             Theta fudge factor used for
 **                                        evidence calculation
 **              classify_adapt_feature_thresh        Threshold for bad features
 **      Operation:
 **              FindBadFeatures finds all features whose maximum feature-evidence
 **              was less than classify_adapt_feature_thresh.  The list is ordered by increasing
 **              feature number.
 **      Return:
 **              Number of bad features in FeatureArray.
 **      Exceptions: none
 **      History: Tue Mar 12 17:09:26 MST 1991, RWM, Created
 */
  static uinT8 FeatureEvidence[MAX_NUM_CONFIGS];
  static int SumOfFeatureEvidence[MAX_NUM_CONFIGS];
  static uinT8 ProtoEvidence[MAX_NUM_PROTOS][MAX_PROTO_INDEX];
  int Feature;
  register uinT8 *UINT8Pointer;
  register int ConfigNum;
  int NumConfigs;
  int NumBadFeatures;
  register int Temp;

  /* DEBUG opening heading */
  if (MatchDebuggingOn (Debug))
    cprintf
      ("Find Bad Features -------------------------------------------\n");

  IMClearTables(ClassTemplate, SumOfFeatureEvidence, ProtoEvidence);

  NumBadFeatures = 0;
  NumConfigs = ClassTemplate->NumConfigs;
  for (Feature = 0; Feature < NumFeatures; Feature++) {
    IMUpdateTablesForFeature (ClassTemplate, ProtoMask, ConfigMask, Feature,
      &(Features[Feature]), FeatureEvidence,
      SumOfFeatureEvidence, ProtoEvidence, Debug);

    /* Find Best Evidence for Current Feature */
    Temp = 0;
    UINT8Pointer = FeatureEvidence;
    for (ConfigNum = 0; ConfigNum < NumConfigs; ConfigNum++, UINT8Pointer++)
      if (*UINT8Pointer > Temp)
        Temp = *UINT8Pointer;

    /* Find Bad Features */
    if (Temp < classify_adapt_feature_thresh) {
      *FeatureArray = Feature;
      FeatureArray++;
      NumBadFeatures++;
    }
  }

#ifndef GRAPHICS_DISABLED
  if (PrintProtoMatchesOn (Debug) || PrintMatchSummaryOn (Debug))
    IMDebugFeatureProtoError(ClassTemplate,
                             ProtoMask,
                             ConfigMask,
                             SumOfFeatureEvidence,
                             ProtoEvidence,
                             NumFeatures,
                             Debug);
#endif

  if (MatchDebuggingOn (Debug))
    cprintf ("Match Complete --------------------------------------------\n");

  return NumBadFeatures;

}


/*---------------------------------------------------------------------------*/
void InitIntegerMatcher() {
  int i;
  uinT32 IntSimilarity;
  double Similarity;
  double Evidence;
  double ScaleFactor;

  /* Set default mode of operation of IntegerMatcher */
  SetCharNormMatch();

  /* Initialize table for evidence to similarity lookup */
  for (i = 0; i < SE_TABLE_SIZE; i++) {
    IntSimilarity = i << (27 - SE_TABLE_BITS);
    Similarity = ((double) IntSimilarity) / 65536.0 / 65536.0;
    Evidence = Similarity / classify_similarity_center;
    Evidence *= Evidence;
    Evidence += 1.0;
    Evidence = 1.0 / Evidence;
    Evidence *= 255.0;

    if (classify_se_exponential_multiplier > 0.0) {
      ScaleFactor = 1.0 - exp (-classify_se_exponential_multiplier) *
        exp (classify_se_exponential_multiplier * ((double) i / SE_TABLE_SIZE));
      if (ScaleFactor > 1.0)
        ScaleFactor = 1.0;
      if (ScaleFactor < 0.0)
        ScaleFactor = 0.0;
      Evidence *= ScaleFactor;
    }

    SimilarityEvidenceTable[i] = (uinT8) (Evidence + 0.5);
  }

  /* Initialize evidence computation variables */
  EvidenceTableMask =
    ((1 << classify_evidence_table_bits) - 1) << (9 - classify_evidence_table_bits);
  MultTruncShiftBits = (14 - classify_int_evidence_trunc_bits);
  TableTruncShiftBits = (27 - SE_TABLE_BITS - (MultTruncShiftBits << 1));
  EvidenceMultMask = ((1 << classify_int_evidence_trunc_bits) - 1);

}

/*-------------------------------------------------------------------------*/
void PrintIntMatcherStats(FILE *f) {
  fprintf (f, "protoword_lookups=%d, zero_protowords=%d, proto_shifts=%d\n",
    protoword_lookups, zero_protowords, proto_shifts);
  fprintf (f, "set_proto_bits=%d, config_shifts=%d, set_config_bits=%d\n",
    set_proto_bits, config_shifts, set_config_bits);
}


/*-------------------------------------------------------------------------*/
void SetProtoThresh(FLOAT32 Threshold) {
  classify_adapt_proto_thresh.set_value(255 * Threshold);
  if (classify_adapt_proto_thresh < 0)
    classify_adapt_proto_thresh.set_value(0);
  if (classify_adapt_proto_thresh > 255)
    classify_adapt_proto_thresh.set_value(255);
}


/*---------------------------------------------------------------------------*/
void SetFeatureThresh(FLOAT32 Threshold) {
  classify_adapt_feature_thresh.set_value(255 * Threshold);
  if (classify_adapt_feature_thresh < 0)
    classify_adapt_feature_thresh.set_value(0);
  if (classify_adapt_feature_thresh > 255)
    classify_adapt_feature_thresh.set_value(255);
}


/*--------------------------------------------------------------------------*/
void SetBaseLineMatch() {
  LocalMatcherMultiplier = 0;
}


/*--------------------------------------------------------------------------*/
void SetCharNormMatch() {
  LocalMatcherMultiplier = classify_integer_matcher_multiplier;
}


/**----------------------------------------------------------------------------
              Private Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
void
IMClearTables (INT_CLASS ClassTemplate,
int SumOfFeatureEvidence[MAX_NUM_CONFIGS],
uinT8 ProtoEvidence[MAX_NUM_PROTOS][MAX_PROTO_INDEX]) {
/*
 **      Parameters:
 **              SumOfFeatureEvidence  Sum of Feature Evidence Table
 **              NumConfigs            Number of Configurations
 **              ProtoEvidence         Prototype Evidence Table
 **              NumProtos             Number of Prototypes
 **      Globals:
 **      Operation:
 **              Clear SumOfFeatureEvidence and ProtoEvidence tables.
 **      Return:
 **      Exceptions: none
 **      History: Wed Feb 27 14:12:28 MST 1991, RWM, Created.
 */
  int NumProtos = ClassTemplate->NumProtos;
  int NumConfigs = ClassTemplate->NumConfigs;

  memset(SumOfFeatureEvidence, 0,
         NumConfigs * sizeof(SumOfFeatureEvidence[0]));
  memset(ProtoEvidence, 0,
         NumProtos * sizeof(ProtoEvidence[0]));
}


/*---------------------------------------------------------------------------*/
void
IMClearFeatureEvidenceTable (uinT8 FeatureEvidence[MAX_NUM_CONFIGS],
int NumConfigs) {
/*
 **      Parameters:
 **              FeatureEvidence  Feature Evidence Table
 **              NumConfigs       Number of Configurations
 **      Globals:
 **      Operation:
 **              Clear FeatureEvidence table.
 **      Return:
 **      Exceptions: none
 **      History: Wed Feb 27 14:12:28 MST 1991, RWM, Created.
 */
  memset(FeatureEvidence, 0, NumConfigs * sizeof(*FeatureEvidence));
}


/*---------------------------------------------------------------------------*/
void IMDebugConfiguration(int FeatureNum,
                          uinT16 ActualProtoNum,
                          uinT8 Evidence,
                          BIT_VECTOR ConfigMask,
                          uinT32 ConfigWord) {
    Q_UNUSED(ConfigMask);
/*
 **      Parameters:
 **      Globals:
 **      Operation:
 **              Print debugging information for Configuations
 **      Return:
 **      Exceptions: none
 **      History: Wed Feb 27 14:12:28 MST 1991, RWM, Created.
 */
  cprintf ("F = %3d, P = %3d, E = %3d, Configs = ",
    FeatureNum, (int) ActualProtoNum, (int) Evidence);
  while (ConfigWord) {
    if (ConfigWord & 1)
      cprintf ("1");
    else
      cprintf ("0");
    ConfigWord >>= 1;
  }
  cprintf ("\n");
}


/*---------------------------------------------------------------------------*/
void IMDebugConfigurationSum(int FeatureNum,
                             uinT8 *FeatureEvidence,
                             inT32 ConfigCount) {
/*
 **      Parameters:
 **      Globals:
 **      Operation:
 **              Print debugging information for Configuations
 **      Return:
 **      Exceptions: none
 **      History: Wed Feb 27 14:12:28 MST 1991, RWM, Created.
 */
  int ConfigNum;

  cprintf ("F=%3d, C=", (int) FeatureNum);

  for (ConfigNum = 0; ConfigNum < ConfigCount; ConfigNum++) {
    cprintf ("%4d", FeatureEvidence[ConfigNum]);
  }
  cprintf ("\n");

}



/*---------------------------------------------------------------------------*/
int
IMUpdateTablesForFeature (INT_CLASS ClassTemplate,
BIT_VECTOR ProtoMask,
BIT_VECTOR ConfigMask,
int FeatureNum,
INT_FEATURE Feature,
uinT8 FeatureEvidence[MAX_NUM_CONFIGS],
int SumOfFeatureEvidence[MAX_NUM_CONFIGS],
uinT8
ProtoEvidence[MAX_NUM_PROTOS][MAX_PROTO_INDEX],
int Debug) {
/*
 **      Parameters:
 **              ClassTemplate         Prototypes & tables for a class
 **              FeatureNum            Current feature number (for DEBUG only)
 **              Feature               Pointer to a feature struct
 **              FeatureEvidence       Feature Evidence Table
 **              SumOfFeatureEvidence  Sum of Feature Evidence Table
 **              ProtoEvidence         Prototype Evidence Table
 **              Debug                 Debugger flag: 1=debugger on
 **      Globals:
 **      Operation:
 **              For the given feature: prune protos, compute evidence, update Feature Evidence,
 **              Proto Evidence, and Sum of Feature Evidence tables.
 **      Return:
 **      Exceptions: none
 **      History: Wed Feb 27 14:12:28 MST 1991, RWM, Created.
 */
  register uinT32 ConfigWord;
  register uinT32 ProtoWord;
  register uinT32 ProtoNum;
  register uinT32 ActualProtoNum;
  uinT8 proto_byte;
  inT32 proto_word_offset;
  inT32 proto_offset;
  uinT8 config_byte;
  inT32 config_offset;
  PROTO_SET ProtoSet;
  uinT32 *ProtoPrunerPtr;
  INT_PROTO Proto;
  int ProtoSetIndex;
  uinT8 Evidence;
  uinT32 XFeatureAddress;
  uinT32 YFeatureAddress;
  uinT32 ThetaFeatureAddress;
  register uinT8 *UINT8Pointer;
  register int ProtoIndex;
  uinT8 Temp;
  register int *IntPointer;
  int ConfigNum;
  register inT32 M3;
  register inT32 A3;
  register uinT32 A4;

  IMClearFeatureEvidenceTable(FeatureEvidence, ClassTemplate->NumConfigs);

  /* Precompute Feature Address offset for Proto Pruning */
  XFeatureAddress = ((Feature->X >> 2) << 1);
  YFeatureAddress = (NUM_PP_BUCKETS << 1) + ((Feature->Y >> 2) << 1);
  ThetaFeatureAddress = (NUM_PP_BUCKETS << 2) + ((Feature->Theta >> 2) << 1);

  for (ProtoSetIndex = 0, ActualProtoNum = 0;
  ProtoSetIndex < ClassTemplate->NumProtoSets; ProtoSetIndex++) {
    ProtoSet = ClassTemplate->ProtoSets[ProtoSetIndex];
    ProtoPrunerPtr = (uinT32 *) ((*ProtoSet).ProtoPruner);
    for (ProtoNum = 0; ProtoNum < PROTOS_PER_PROTO_SET;
      ProtoNum += (PROTOS_PER_PROTO_SET >> 1), ActualProtoNum +=
    (PROTOS_PER_PROTO_SET >> 1), ProtoMask++, ProtoPrunerPtr++) {
      /* Prune Protos of current Proto Set */
      ProtoWord = *(ProtoPrunerPtr + XFeatureAddress);
      ProtoWord &= *(ProtoPrunerPtr + YFeatureAddress);
      ProtoWord &= *(ProtoPrunerPtr + ThetaFeatureAddress);
      ProtoWord &= *ProtoMask;

      if (ProtoWord != 0) {
        proto_byte = ProtoWord & 0xff;
        ProtoWord >>= 8;
        proto_word_offset = 0;
        while (ProtoWord != 0 || proto_byte != 0) {
          while (proto_byte == 0) {
            proto_byte = ProtoWord & 0xff;
            ProtoWord >>= 8;
            proto_word_offset += 8;
          }
          proto_offset = offset_table[proto_byte] + proto_word_offset;
          proto_byte = next_table[proto_byte];
          Proto = &(ProtoSet->Protos[ProtoNum + proto_offset]);
          ConfigWord = Proto->Configs[0];
          A3 = (((Proto->A * (Feature->X - 128)) << 1)
            - (Proto->B * (Feature->Y - 128)) + (Proto->C << 9));
          M3 =
            (((inT8) (Feature->Theta - Proto->Angle)) *
            classify_int_theta_fudge) << 1;

          if (A3 < 0)
            A3 = ~A3;
          if (M3 < 0)
            M3 = ~M3;
          A3 >>= MultTruncShiftBits;
          M3 >>= MultTruncShiftBits;
          if (A3 > (inT32)EvidenceMultMask)
            A3 = EvidenceMultMask;
          if (M3 > (inT32)EvidenceMultMask)
            M3 = EvidenceMultMask;

          A4 = (A3 * A3) + (M3 * M3);
          A4 >>= TableTruncShiftBits;
          if (A4 > EvidenceTableMask)
            Evidence = 0;
          else
            Evidence = SimilarityEvidenceTable[A4];

          if (PrintFeatureMatchesOn (Debug))
            IMDebugConfiguration (FeatureNum,
              ActualProtoNum + proto_offset,
              Evidence, ConfigMask, ConfigWord);

          ConfigWord &= *ConfigMask;

          UINT8Pointer = FeatureEvidence - 8;
          config_byte = 0;
          while (ConfigWord != 0 || config_byte != 0) {
            while (config_byte == 0) {
              config_byte = ConfigWord & 0xff;
              ConfigWord >>= 8;
              UINT8Pointer += 8;
              //                                              config_shifts++;
            }
            config_offset = offset_table[config_byte];
            config_byte = next_table[config_byte];
            if (Evidence > UINT8Pointer[config_offset])
              UINT8Pointer[config_offset] = Evidence;
          }

          UINT8Pointer =
            &(ProtoEvidence[ActualProtoNum + proto_offset][0]);
          for (ProtoIndex =
            ClassTemplate->ProtoLengths[ActualProtoNum + proto_offset];
          ProtoIndex > 0; ProtoIndex--, UINT8Pointer++) {
            if (Evidence > *UINT8Pointer) {
              Temp = *UINT8Pointer;
              *UINT8Pointer = Evidence;
              Evidence = Temp;
            }
            else if (Evidence == 0)
              break;
          }
        }
      }
    }
  }

  if (PrintFeatureMatchesOn (Debug))
    IMDebugConfigurationSum (FeatureNum, FeatureEvidence,
      ClassTemplate->NumConfigs);
  IntPointer = SumOfFeatureEvidence;
  UINT8Pointer = FeatureEvidence;
  int SumOverConfigs = 0;
  for (ConfigNum = ClassTemplate->NumConfigs; ConfigNum > 0; ConfigNum--) {
    int evidence = *UINT8Pointer++;
    SumOverConfigs += evidence;
    *IntPointer++ += evidence;
  }
  return SumOverConfigs;
}


/*---------------------------------------------------------------------------*/
#ifndef GRAPHICS_DISABLED
void
IMDebugFeatureProtoError (INT_CLASS ClassTemplate,
BIT_VECTOR ProtoMask,
BIT_VECTOR ConfigMask,
int SumOfFeatureEvidence[MAX_NUM_CONFIGS],
uinT8
ProtoEvidence[MAX_NUM_PROTOS][MAX_PROTO_INDEX],
inT16 NumFeatures, int Debug) {
/*
 **      Parameters:
 **      Globals:
 **      Operation:
 **              Print debugging information for Configuations
 **      Return:
 **      Exceptions: none
 **      History: Wed Feb 27 14:12:28 MST 1991, RWM, Created.
 */
  uinT8 *UINT8Pointer;
  int *IntPointer;
  FLOAT32 ProtoConfigs[MAX_NUM_CONFIGS];
  int ConfigNum;
  uinT32 ConfigWord;
  int ProtoSetIndex;
  uinT16 ProtoNum;
  uinT8 ProtoWordNum;
  PROTO_SET ProtoSet;
  int ProtoIndex;
  int NumProtos;
  uinT16 ActualProtoNum;
  int Temp;
  int NumConfigs;

  NumProtos = ClassTemplate->NumProtos;
  NumConfigs = ClassTemplate->NumConfigs;

  if (PrintMatchSummaryOn (Debug)) {
    cprintf ("Configuration Mask:\n");
    for (ConfigNum = 0; ConfigNum < NumConfigs; ConfigNum++)
      cprintf ("%1d", (((*ConfigMask) >> ConfigNum) & 1));
    cprintf ("\n");

    cprintf ("Feature Error for Configurations:\n");
    for (ConfigNum = 0; ConfigNum < NumConfigs; ConfigNum++)
      cprintf (" %5.1f",
        100.0 * (1.0 -
        (FLOAT32) SumOfFeatureEvidence[ConfigNum] /
        NumFeatures / 256.0));
    cprintf ("\n\n\n");
  }

  if (PrintMatchSummaryOn (Debug)) {
    cprintf ("Proto Mask:\n");
    for (ProtoSetIndex = 0; ProtoSetIndex < ClassTemplate->NumProtoSets;
    ProtoSetIndex++) {
      ActualProtoNum = (ProtoSetIndex * PROTOS_PER_PROTO_SET);
      for (ProtoWordNum = 0; ProtoWordNum < 2;
      ProtoWordNum++, ProtoMask++) {
        ActualProtoNum = (ProtoSetIndex * PROTOS_PER_PROTO_SET);
        for (ProtoNum = 0;
          ((ProtoNum < (PROTOS_PER_PROTO_SET >> 1))
          && (ActualProtoNum < NumProtos));
          ProtoNum++, ActualProtoNum++)
        cprintf ("%1d", (((*ProtoMask) >> ProtoNum) & 1));
        cprintf ("\n");
      }
    }
    cprintf ("\n");
  }

  for (ConfigNum = 0; ConfigNum < NumConfigs; ConfigNum++)
    ProtoConfigs[ConfigNum] = 0;

  if (PrintProtoMatchesOn (Debug)) {
    cprintf ("Proto Evidence:\n");
    for (ProtoSetIndex = 0; ProtoSetIndex < ClassTemplate->NumProtoSets;
    ProtoSetIndex++) {
      ProtoSet = ClassTemplate->ProtoSets[ProtoSetIndex];
      ActualProtoNum = (ProtoSetIndex * PROTOS_PER_PROTO_SET);
      for (ProtoNum = 0;
        ((ProtoNum < PROTOS_PER_PROTO_SET)
        && (ActualProtoNum < NumProtos));
      ProtoNum++, ActualProtoNum++) {
        cprintf ("P %3d =", ActualProtoNum);
        Temp = 0;
        UINT8Pointer = &(ProtoEvidence[ActualProtoNum][0]);
        for (ProtoIndex = 0;
          ProtoIndex < ClassTemplate->ProtoLengths[ActualProtoNum];
        ProtoIndex++, UINT8Pointer++) {
          cprintf (" %d", *UINT8Pointer);
          Temp += *UINT8Pointer;
        }

        cprintf (" = %6.4f%%\n", Temp /
          256.0 / ClassTemplate->ProtoLengths[ActualProtoNum]);

        ConfigWord = (ProtoSet->Protos[ProtoNum]).Configs[0];
        IntPointer = SumOfFeatureEvidence;
        ConfigNum = 0;
        while (ConfigWord) {
          cprintf ("%5d", ConfigWord & 1 ? Temp : 0);
          if (ConfigWord & 1)
            ProtoConfigs[ConfigNum] += Temp;
          IntPointer++;
          ConfigNum++;
          ConfigWord >>= 1;
        }
        cprintf ("\n");
      }
    }
  }

  if (PrintMatchSummaryOn (Debug)) {
    cprintf ("Proto Error for Configurations:\n");
    for (ConfigNum = 0; ConfigNum < NumConfigs; ConfigNum++)
      cprintf (" %5.1f",
        100.0 * (1.0 -
        ProtoConfigs[ConfigNum] /
        ClassTemplate->ConfigLengths[ConfigNum] / 256.0));
    cprintf ("\n\n");
  }

  if (PrintProtoMatchesOn (Debug)) {
    cprintf ("Proto Sum for Configurations:\n");
    for (ConfigNum = 0; ConfigNum < NumConfigs; ConfigNum++)
      cprintf (" %4.1f", ProtoConfigs[ConfigNum] / 256.0);
    cprintf ("\n\n");

    cprintf ("Proto Length for Configurations:\n");
    for (ConfigNum = 0; ConfigNum < NumConfigs; ConfigNum++)
      cprintf (" %4.1f",
        (float) ClassTemplate->ConfigLengths[ConfigNum]);
    cprintf ("\n\n");
  }

}


/*---------------------------------------------------------------------------*/
void
IMDisplayProtoDebugInfo (INT_CLASS ClassTemplate,
BIT_VECTOR ProtoMask,
BIT_VECTOR ConfigMask,
uinT8 ProtoEvidence[MAX_NUM_PROTOS][MAX_PROTO_INDEX],
int Debug) {
    Q_UNUSED(ProtoMask);
  register uinT8 *UINT8Pointer;
  register uinT32 ConfigWord;
  register uinT16 ProtoNum;
  register uinT16 ActualProtoNum;
  PROTO_SET ProtoSet;
  int ProtoSetIndex;
  int ProtoIndex;
  int NumProtos;
  register int Temp;

  InitIntMatchWindowIfReqd();
  if (matcher_debug_separate_windows) {
    InitFeatureDisplayWindowIfReqd();
    InitProtoDisplayWindowIfReqd();
  }

  NumProtos = ClassTemplate->NumProtos;

  for (ProtoSetIndex = 0; ProtoSetIndex < ClassTemplate->NumProtoSets;
  ProtoSetIndex++) {
    ProtoSet = ClassTemplate->ProtoSets[ProtoSetIndex];
    ActualProtoNum = (ProtoSetIndex * PROTOS_PER_PROTO_SET);
    for (ProtoNum = 0;
      ((ProtoNum < PROTOS_PER_PROTO_SET)
    && (ActualProtoNum < NumProtos)); ProtoNum++, ActualProtoNum++) {
      /* Compute Average for Actual Proto */
      Temp = 0;
      UINT8Pointer = &(ProtoEvidence[ActualProtoNum][0]);
      for (ProtoIndex = ClassTemplate->ProtoLengths[ActualProtoNum];
        ProtoIndex > 0; ProtoIndex--, UINT8Pointer++)
      Temp += *UINT8Pointer;

      Temp /= ClassTemplate->ProtoLengths[ActualProtoNum];

      ConfigWord = (ProtoSet->Protos[ProtoNum]).Configs[0];
      ConfigWord &= *ConfigMask;
      if (ConfigWord) {
        /* Update display for current proto */
        if (ClipMatchEvidenceOn (Debug)) {
          if (Temp < classify_adapt_proto_thresh)
            DisplayIntProto (ClassTemplate, ActualProtoNum,
              (Temp / 255.0));
          else
            DisplayIntProto (ClassTemplate, ActualProtoNum,
              (Temp / 255.0));
        }
        else {
          DisplayIntProto (ClassTemplate, ActualProtoNum,
            (Temp / 255.0));
        }
      }
    }
  }
}


/*---------------------------------------------------------------------------*/
void IMDisplayFeatureDebugInfo(INT_CLASS ClassTemplate,
                               BIT_VECTOR ProtoMask,
                               BIT_VECTOR ConfigMask,
                               inT16 NumFeatures,
                               INT_FEATURE_ARRAY Features,
                               int Debug) {
  static uinT8 FeatureEvidence[MAX_NUM_CONFIGS];
  static int SumOfFeatureEvidence[MAX_NUM_CONFIGS];
  static uinT8 ProtoEvidence[MAX_NUM_PROTOS][MAX_PROTO_INDEX];
  int Feature;
  register uinT8 *UINT8Pointer;
  register int ConfigNum;
  int NumConfigs;
  register int Temp;

  IMClearTables(ClassTemplate, SumOfFeatureEvidence, ProtoEvidence);

  InitIntMatchWindowIfReqd();
  if (matcher_debug_separate_windows) {
    InitFeatureDisplayWindowIfReqd();
    InitProtoDisplayWindowIfReqd();
  }

  NumConfigs = ClassTemplate->NumConfigs;
  for (Feature = 0; Feature < NumFeatures; Feature++) {
    IMUpdateTablesForFeature (ClassTemplate, ProtoMask, ConfigMask, Feature,
      &(Features[Feature]), FeatureEvidence,
      SumOfFeatureEvidence, ProtoEvidence, 0);

    /* Find Best Evidence for Current Feature */
    Temp = 0;
    UINT8Pointer = FeatureEvidence;
    for (ConfigNum = 0; ConfigNum < NumConfigs; ConfigNum++, UINT8Pointer++)
      if (*UINT8Pointer > Temp)
        Temp = *UINT8Pointer;

    /* Update display for current feature */
    if (ClipMatchEvidenceOn (Debug)) {
      if (Temp < classify_adapt_feature_thresh)
        DisplayIntFeature (&(Features[Feature]), 0.0);
      else
        DisplayIntFeature (&(Features[Feature]), 1.0);
    }
    else {
      DisplayIntFeature (&(Features[Feature]), (Temp / 255.0));
    }
  }
}
#endif

/*---------------------------------------------------------------------------*/
void
IMUpdateSumOfProtoEvidences (INT_CLASS ClassTemplate,
BIT_VECTOR ConfigMask,
int SumOfFeatureEvidence[MAX_NUM_CONFIGS],
uinT8
ProtoEvidence[MAX_NUM_PROTOS][MAX_PROTO_INDEX],
inT16 NumFeatures) {
/*
 **      Parameters:
 **      Globals:
 **      Operation:
 **              Add sum of Proto Evidences into Sum Of Feature Evidence Array
 **      Return:
 **      Exceptions: none
 **      History: Wed Feb 27 14:12:28 MST 1991, RWM, Created.
 */
    Q_UNUSED(NumFeatures);
  register uinT8 *UINT8Pointer;
  register int *IntPointer;
  register uinT32 ConfigWord;
  int ProtoSetIndex;
  register uinT16 ProtoNum;
  PROTO_SET ProtoSet;
  register int ProtoIndex;
  int NumProtos;
  uinT16 ActualProtoNum;
  int Temp;

  NumProtos = ClassTemplate->NumProtos;

  for (ProtoSetIndex = 0; ProtoSetIndex < ClassTemplate->NumProtoSets;
  ProtoSetIndex++) {
    ProtoSet = ClassTemplate->ProtoSets[ProtoSetIndex];
    ActualProtoNum = (ProtoSetIndex * PROTOS_PER_PROTO_SET);
    for (ProtoNum = 0;
      ((ProtoNum < PROTOS_PER_PROTO_SET)
    && (ActualProtoNum < NumProtos)); ProtoNum++, ActualProtoNum++) {
      Temp = 0;
      UINT8Pointer = &(ProtoEvidence[ActualProtoNum][0]);
      for (ProtoIndex = ClassTemplate->ProtoLengths[ActualProtoNum];
        ProtoIndex > 0; ProtoIndex--, UINT8Pointer++)
      Temp += *UINT8Pointer;

      ConfigWord = (ProtoSet->Protos[ProtoNum]).Configs[0];
      ConfigWord &= *ConfigMask;
      IntPointer = SumOfFeatureEvidence;
      while (ConfigWord) {
        if (ConfigWord & 1)
          *IntPointer += Temp;
        IntPointer++;
        ConfigWord >>= 1;
      }
    }
  }
}



/*---------------------------------------------------------------------------*/
void
IMNormalizeSumOfEvidences (INT_CLASS ClassTemplate,
int SumOfFeatureEvidence[MAX_NUM_CONFIGS],
inT16 NumFeatures, inT32 used_features) {
/*
 **      Parameters:
 **      Globals:
 **      Operation:
 **              Normalize Sum of Proto and Feature Evidence by dividing by
 **              the sum of the Feature Lengths and the Proto Lengths for each
 **              configuration.
 **      Return:
 **      Exceptions: none
 **      History: Wed Feb 27 14:12:28 MST 1991, RWM, Created.
 */
  Q_UNUSED(used_features);
  register int *IntPointer;
  register int ConfigNum;
  int NumConfigs;

  NumConfigs = ClassTemplate->NumConfigs;

  IntPointer = SumOfFeatureEvidence;
  for (ConfigNum = 0; ConfigNum < NumConfigs; ConfigNum++, IntPointer++)
    *IntPointer = (*IntPointer << 8) /
      (NumFeatures + ClassTemplate->ConfigLengths[ConfigNum]);
}


/*---------------------------------------------------------------------------*/
int
IMFindBestMatch (INT_CLASS ClassTemplate,
int SumOfFeatureEvidence[MAX_NUM_CONFIGS],
uinT16 BlobLength,
uinT8 NormalizationFactor, INT_RESULT Result) {
/*
 **      Parameters:
 **      Globals:
 **      Operation:
 **              Find the best match for the current class and update the Result
 **              with the configuration and match rating.
 **      Return:
 **              The best normalized sum of evidences
 **      Exceptions: none
 **      History: Wed Feb 27 14:12:28 MST 1991, RWM, Created.
 */
  register int *IntPointer;
  register int ConfigNum;
  register int NumConfigs;
  register int BestMatch;
  register int Best2Match;

  NumConfigs = ClassTemplate->NumConfigs;

  /* Find best match */
  BestMatch = 0;
  Best2Match = 0;
  IntPointer = SumOfFeatureEvidence;
  for (ConfigNum = 0; ConfigNum < NumConfigs; ConfigNum++, IntPointer++) {
    if (tord_display_ratings > 1)
      cprintf ("Config %d, rating=%d\n", ConfigNum, *IntPointer);
    if (*IntPointer > BestMatch) {
      if (BestMatch > 0) {
        Result->Config2 = Result->Config;
        Best2Match = BestMatch;
      }
      else
        Result->Config2 = ConfigNum;
      Result->Config = ConfigNum;
      BestMatch = *IntPointer;
    }
    else if (*IntPointer > Best2Match) {
      Result->Config2 = ConfigNum;
      Best2Match = *IntPointer;
    }
  }

  /* Compute Certainty Rating */
  (*Result).Rating = ((65536.0 - BestMatch) / 65536.0 * BlobLength +
    LocalMatcherMultiplier * NormalizationFactor / 256.0) /
    (BlobLength + LocalMatcherMultiplier);

  return BestMatch;
}


/*---------------------------------------------------------------------------*/
#ifndef GRAPHICS_DISABLED
void IMDebugBestMatch(int BestMatch,
                      INT_RESULT Result,
                      uinT16 BlobLength,
                      uinT8 NormalizationFactor) {
/*
 **      Parameters:
 **      Globals:
 **      Operation:
 **              Find the best match for the current class and update the Result
 **      Return:
 **      Exceptions: none
 **      History: Wed Feb 27 14:12:28 MST 1991, RWM, Created.
 */
  cprintf ("Rating          = %5.1f%%     Best Config   = %3d\n",
    100.0 * ((*Result).Rating), (int) ((*Result).Config));
  cprintf
    ("Matcher Error   = %5.1f%%     Blob Length   = %3d     Weight = %4.1f%%\n",
    100.0 * (65536.0 - BestMatch) / 65536.0, (int) BlobLength,
    100.0 * BlobLength / (BlobLength + LocalMatcherMultiplier));
  cprintf
    ("Char Norm Error = %5.1f%%     Norm Strength = %3d     Weight = %4.1f%%\n",
    100.0 * NormalizationFactor / 256.0, LocalMatcherMultiplier,
    100.0 * LocalMatcherMultiplier / (BlobLength + LocalMatcherMultiplier));
}
#endif

/*---------------------------------------------------------------------------*/
void
HeapSort (int n, register int ra[], register int rb[]) {
/*
 **      Parameters:
 **              n      Number of elements to sort
 **              ra     Key array [1..n]
 **              rb     Index array [1..n]
 **      Globals:
 **      Operation:
 **              Sort Key array in ascending order using heap sort
 **              algorithm.  Also sort Index array that is tied to
 **              the key array.
 **      Return:
 **      Exceptions: none
 **      History: Tue Feb 19 10:24:24 MST 1991, RWM, Created.
 */
  register int i, rra, rrb;
  int l, j, ir;

  l = (n >> 1) + 1;
  ir = n;
  for (;;) {
    if (l > 1) {
      rra = ra[--l];
      rrb = rb[l];
    }
    else {
      rra = ra[ir];
      rrb = rb[ir];
      ra[ir] = ra[1];
      rb[ir] = rb[1];
      if (--ir == 1) {
        ra[1] = rra;
        rb[1] = rrb;
        return;
      }
    }
    i = l;
    j = l << 1;
    while (j <= ir) {
      if (j < ir && ra[j] < ra[j + 1])
        ++j;
      if (rra < ra[j]) {
        ra[i] = ra[j];
        rb[i] = rb[j];
        j += (i = j);
      }
      else
        j = ir + 1;
    }
    ra[i] = rra;
    rb[i] = rrb;
  }
}
/////////////////////////////////////////////////////////////////intmatcher////////////////////////////////////////

/////////////////////////////////////////////////////////////////mfdefs////////////////////////////////////////
/**----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
MICROFEATURE NewMicroFeature() {
/*
 **	Parameters: none
 **	Globals: none
 **	Operation:
 **		This routine allocates and returns a new micro-feature
 **		data structure.
 **	Return: New micro-feature.
 **	Exceptions: none
 **	History: 7/27/89, DSJ, Created.
 */
  return ((MICROFEATURE) Emalloc (sizeof (MFBLOCK)));
}                                /* NewMicroFeature */


/*---------------------------------------------------------------------------*/
void FreeMicroFeatures(MICROFEATURES MicroFeatures) {
/*
 **	Parameters:
 **		MicroFeatures	list of micro-features to be freed
 **	Globals: none
 **	Operation:
 **		This routine deallocates all of the memory consumed by
 **		a list of micro-features.
 **	Return: none
 **	Exceptions: none
 **	History: 7/27/89, DSJ, Created.
 */
  destroy_nodes(MicroFeatures, Efree);
}                                /* FreeMicroFeatures */
/////////////////////////////////////////////////////////////////mfdefs////////////////////////////////////////

/////////////////////////////////////////////////////////////////xform2d////////////////////////////////////////
/**----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------**/

void InitMatrix(MATRIX_2D *M) {
  M->a = 1;
  M->b = 0;
  M->c = 0;
  M->d = 1;
  M->tx = 0;
  M->ty = 0;
}

void CopyMatrix(MATRIX_2D *A, MATRIX_2D *B) {
  B->a = A->a;
  B->b = A->b;
  B->c = A->c;
  B->d = A->d;
  B->tx = A->tx;
  B->ty = A->ty;
}

void TranslateMatrix(MATRIX_2D *M, FLOAT32 X, FLOAT32 Y) {
  M->tx += M->a * X + M->c * Y;
  M->ty += M->b * X + M->d * Y;
}

void ScaleMatrix(MATRIX_2D *M, FLOAT32 X, FLOAT32 Y) {
  M->a *= X;
  M->b *= X;
  M->c *= Y;
  M->d *= Y;
}

void MirrorMatrixInX(MATRIX_2D *M)  {ScaleMatrix(M, -1, 1);}
void MirrorMatrixInY(MATRIX_2D *M)  {ScaleMatrix(M, 1, -1);}
void MirrorMatrixInXY(MATRIX_2D *M) {ScaleMatrix(M, -1, -1);}

FLOAT32 MapX(MATRIX_2D *M, FLOAT32 X, FLOAT32 Y) {
  return M->a * (X) + (M)->c * (Y) + (M)->tx;
}

FLOAT32 MapY(MATRIX_2D *M, FLOAT32 X, FLOAT32 Y) {
  return M->b * X + M->d * Y + M->ty;
}

void MapPoint(MATRIX_2D *M, const FPOINT &A, FPOINT* B) {
  B->x = MapX(M, A.x, A.y);
  B->y = MapY(M, A.x, A.y);
}

FLOAT32 MapDx(MATRIX_2D *M, FLOAT32 DX, FLOAT32 DY) {
  return M->a * DX + M->c * DY;
}

FLOAT32 MapDy(MATRIX_2D *M, FLOAT32 DX, FLOAT32 DY) {
  return M->b * DX + M->d * DY;
}


/*---------------------------------------------------------------------------*/
void RotateMatrix(MATRIX_2D_PTR Matrix, FLOAT32 Angle) {
/*
 ** Parameters:
 **   Matrix    transformation matrix to rotate
 **   Angle   angle to rotate matrix
 ** Globals: none
 ** Operation:
 **   Rotate the coordinate system (as specified by Matrix) about
 **   its origin by Angle radians.  In matrix notation the
 **   effect is as follows:
 **
 **     Matrix = R X Matrix
 **
 **   where R is the following matrix
 **
 **     cos Angle sin Angle 0
 **     -sin Angle  cos Angle 0
 **     0   0   1
 ** Return: none
 ** Exceptions: none
 ** History: 7/27/89, DSJ, Create.
 */
  FLOAT32 Cos, Sin;
  FLOAT32 NewA, NewB;

  Cos = cos ((double) Angle);
  Sin = sin ((double) Angle);

  NewA = Matrix->a * Cos + Matrix->c * Sin;
  NewB = Matrix->b * Cos + Matrix->d * Sin;
  Matrix->c = Matrix->a * -Sin + Matrix->c * Cos;
  Matrix->d = Matrix->b * -Sin + Matrix->d * Cos;
  Matrix->a = NewA;
  Matrix->b = NewB;

}                                /* RotateMatrix */
/////////////////////////////////////////////////////////////////xform2d////////////////////////////////////////

/////////////////////////////////////////////////////////////////mfx////////////////////////////////////////
/* old numbers corresponded to 10.0 degrees and 80.0 degrees */
double_VAR(classify_min_slope, 0.414213562,
           "Slope below which lines are called horizontal");
double_VAR(classify_max_slope, 2.414213562,
           "Slope above which lines are called vertical");
double_VAR(classify_noise_segment_length, 0.00,
           "Length below which outline segments are treated as noise");

/**----------------------------------------------------------------------------
          Macros
----------------------------------------------------------------------------**/
/* miscellaneous macros */
#define NormalizeAngle(A)       ( (((A)<0)?((A)+2*PI):(A)) / (2*PI) )

/*----------------------------------------------------------------------------
          Private Function Prototypes
-----------------------------------------------------------------------------*/
void ComputeBulges(MFOUTLINE Start, MFOUTLINE End, MICROFEATURE MicroFeature);

FLOAT32 ComputeOrientation(MFEDGEPT *Start, MFEDGEPT *End);

MICROFEATURES ConvertToMicroFeatures(MFOUTLINE Outline,
                                     MICROFEATURES MicroFeatures);

MICROFEATURE ExtractMicroFeature(MFOUTLINE Start, MFOUTLINE End);

void SmearBulges(MICROFEATURES MicroFeatures, FLOAT32 XScale, FLOAT32 YScale);

/**----------------------------------------------------------------------------
            Public Code
----------------------------------------------------------------------------**/

/*---------------------------------------------------------------------------*/
CHAR_FEATURES BlobMicroFeatures(TBLOB *Blob, LINE_STATS *LineStats) {
/*
 **      Parameters:
 **              Blob            blob to extract micro-features from
 **              LineStats       statistics for text line normalization
 **      Operation:
 **              This routine extracts micro-features from the specified
 **              blob and returns a list of the micro-features.  All
 **              micro-features are normalized according to the specified
 **              line statistics.
 **      Return: List of micro-features extracted from the blob.
 **      Exceptions: none
 **      History: 7/21/89, DSJ, Created.
 */
  Q_UNUSED(LineStats);
  MICROFEATURES MicroFeatures = NIL;
  FLOAT32 XScale, YScale;
  LIST Outlines;
  LIST RemainingOutlines;
  MFOUTLINE Outline;
  INT_FEATURE_ARRAY blfeatures;
  INT_FEATURE_ARRAY cnfeatures;
  INT_FX_RESULT_STRUCT results;

  if (Blob != NULL) {
    Outlines = ConvertBlob (Blob);
//    NormalizeOutlines(Outlines, LineStats, &XScale, &YScale);
    if (!ExtractIntFeat(Blob, blfeatures, cnfeatures, &results))
      return NULL;
    XScale = 0.2f / results.Ry;
    YScale = 0.2f / results.Rx;

    RemainingOutlines = Outlines;
    iterate(RemainingOutlines) {
      Outline = (MFOUTLINE) first_node (RemainingOutlines);
      CharNormalizeOutline (Outline,
        results.Xmean, results.Ymean,
        XScale, YScale);
    }

    RemainingOutlines = Outlines;
    iterate(RemainingOutlines) {
      Outline = (MFOUTLINE) first_node (RemainingOutlines);
      FindDirectionChanges(Outline, classify_min_slope, classify_max_slope);
      FilterEdgeNoise(Outline, classify_noise_segment_length);
      MarkDirectionChanges(Outline);
      SmearExtremities(Outline, XScale, YScale);
      MicroFeatures = ConvertToMicroFeatures (Outline, MicroFeatures);
    }
    SmearBulges(MicroFeatures, XScale, YScale);
    FreeOutlines(Outlines);
  }
  return ((CHAR_FEATURES) MicroFeatures);
}                                /* BlobMicroFeatures */


/**----------------------------------------------------------------------------
              Private Macros
----------------------------------------------------------------------------**/
/**********************************************************************
 * angle_of
 *
 * Return the angle of the line between two points.
 **********************************************************************/
#define angle_of(x1,y1,x2,y2)                   \
((x2-x1) ?                                    \
  (atan2 (y2-y1, x2-x1)) :                     \
  ((y2<y1) ? (- PI / 2.0) : (PI / 2.0)))   \


/**********************************************************************
 * scale_angle
 *
 * Make sure that the angle is non-negative.  Scale it to the right
 * amount.
 **********************************************************************/

#define scale_angle(x)                             \
(((x<0) ? (2.0 * PI + x) : (x)) * 0.5 / PI)  \

/*---------------------------------------------------------------------------
            Private Code
---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
void ComputeBulges(MFOUTLINE Start, MFOUTLINE End, MICROFEATURE MicroFeature) {
/*
 **      Parameters:
 **              Start           starting point of micro-feature
 **              End             ending point of micro-feature
 **              MicroFeature    micro-feature whose bulges are to be computed
 **      Globals: none
 **      Operation:
 **              This routine computes the size of the "bulges" of the
 **              specified micro-feature.  The bulges are the deviations
 **              of the micro-features from a straight line at the 1/3
 **              and 2/3 points along the straight line approximation of
 **              the micro-feature.  The size of each bulge is normalized
 **              to the range -0.5 to 0.5.  A positive bulge indicates a
 **              deviation in the counterclockwise direction and vice versa.
 **              A size of 0.5 (+ or -) corresponds to the largest bulge that
 **              could ever occur for the given feature independent of
 **              orientation.  This routine assumes that Start
 **              and End are not the same point.  It also assumes that the
 **              orientation and length parameters of the micro-feature
 **              have already been computed.
 **      Return: none
 **      Exceptions: none
 **      History: 7/27/89, DSJ, Created.
 */
  MATRIX_2D Matrix;
  MFEDGEPT *Origin;
  MFOUTLINE SegmentStart, SegmentEnd;
  FPOINT CurrentPoint, LastPoint;
  FLOAT32 BulgePosition;

  /* check for simple case */
  if (End == NextPointAfter (Start))
    MicroFeature[FIRSTBULGE] = MicroFeature[SECONDBULGE] = 0;
  else {
    Origin = PointAt (Start);

    InitMatrix(&Matrix);
    RotateMatrix (&Matrix, MicroFeature[ORIENTATION] * -2.0 * PI);
    TranslateMatrix (&Matrix, -Origin->Point.x, -Origin->Point.y);

    SegmentEnd = Start;
    CurrentPoint.x = 0.0f;
    CurrentPoint.y =  0.0f;
    BulgePosition = MicroFeature[MFLENGTH] / 3;
    LastPoint = CurrentPoint;
    while (CurrentPoint.x < BulgePosition) {
      SegmentStart = SegmentEnd;
      SegmentEnd = NextPointAfter (SegmentStart);
      LastPoint = CurrentPoint;

      MapPoint(&Matrix, PointAt(SegmentEnd)->Point, &CurrentPoint);
    }
    MicroFeature[FIRSTBULGE] =
      XIntersectionOf(LastPoint, CurrentPoint, BulgePosition);

    BulgePosition *= 2;

    // Prevents from copying the points before computing the bulge if
    // CurrentPoint will not change. (Which would cause to output nan
    // for the SecondBulge.)
    if (CurrentPoint.x < BulgePosition)
      LastPoint = CurrentPoint;
    while (CurrentPoint.x < BulgePosition) {
      SegmentStart = SegmentEnd;
      SegmentEnd = NextPointAfter (SegmentStart);
      LastPoint = CurrentPoint;
      MapPoint(&Matrix, PointAt(SegmentEnd)->Point, &CurrentPoint);
    }
    MicroFeature[SECONDBULGE] =
      XIntersectionOf(LastPoint, CurrentPoint, BulgePosition);

    MicroFeature[FIRSTBULGE] /= BULGENORMALIZER * MicroFeature[MFLENGTH];
    MicroFeature[SECONDBULGE] /= BULGENORMALIZER * MicroFeature[MFLENGTH];
  }
}                                /* ComputeBulges */


/*---------------------------------------------------------------------------*/
FLOAT32 ComputeOrientation(MFEDGEPT *Start, MFEDGEPT *End) {
/*
 **      Parameters:
 **              Start           starting edge point of micro-feature
 **              End             ending edge point of micro-feature
 **      Globals: none
 **      Operation:
 **              This routine computes the orientation parameter of the
 **              specified micro-feature.  The orientation is the angle of
 **              the vector from Start to End.  It is normalized to a number
 **              between 0 and 1 where 0 corresponds to 0 degrees and 1
 **              corresponds to 360 degrees.  The actual range is [0,1), i.e.
 **              1 is excluded from the range (since it is actual the
 **              same orientation as 0).  This routine assumes that Start
 **              and End are not the same point.
 **      Return: Orientation parameter for the specified micro-feature.
 **      Exceptions: none
 **      History: 7/27/89, DSJ, Created.
 */
  FLOAT32 Orientation;

  Orientation = NormalizeAngle (AngleFrom (Start->Point, End->Point));

  /* ensure that round-off errors do not put circular param out of range */
  if ((Orientation < 0) || (Orientation >= 1))
    Orientation = 0;
  return (Orientation);
}                                /* ComputeOrientation */


/*---------------------------------------------------------------------------*/
MICROFEATURES ConvertToMicroFeatures(MFOUTLINE Outline,
                                     MICROFEATURES MicroFeatures) {
/*
 **      Parameters:
 **              Outline         outline to extract micro-features from
 **              MicroFeatures   list of micro-features to add to
 **      Globals: none
 **      Operation:
 **              This routine
 **      Return: List of micro-features with new features added to front.
 **      Exceptions: none
 **      History: 7/26/89, DSJ, Created.
 */
  MFOUTLINE Current;
  MFOUTLINE Last;
  MFOUTLINE First;
  MICROFEATURE NewFeature;

  if (DegenerateOutline (Outline))
    return (MicroFeatures);

  First = NextExtremity (Outline);
  Last = First;
  do {
    Current = NextExtremity (Last);
    NewFeature = ExtractMicroFeature (Last, Current);
    if (NewFeature != NULL)
      MicroFeatures = push (MicroFeatures, NewFeature);
    Last = Current;
  }
  while (Last != First);

  return (MicroFeatures);
}                                /* ConvertToMicroFeatures */


/*---------------------------------------------------------------------------*/
MICROFEATURE ExtractMicroFeature(MFOUTLINE Start, MFOUTLINE End) {
/*
 **      Parameters:
 **              Start           starting point of micro-feature
 **              End             ending point of micro-feature
 **      Globals: none
 **      Operation:
 **              This routine computes the feature parameters which describe
 **              the micro-feature that starts and Start and ends at End.
 **              A new micro-feature is allocated, filled with the feature
 **              parameters, and returned.  The routine assumes that
 **              Start and End are not the same point.  If they are the
 **              same point, NULL is returned, a warning message is
 **              printed, and the current outline is dumped to stdout.
 **      Return: New micro-feature or NULL if the feature was rejected.
 **      Exceptions: none
 **      History: 7/26/89, DSJ, Created.
 **              11/17/89, DSJ, Added handling for Start and End same point.
 */
  MICROFEATURE NewFeature;
  MFEDGEPT *P1, *P2;

  P1 = PointAt (Start);
  P2 = PointAt (End);

  NewFeature = NewMicroFeature ();
  NewFeature[XPOSITION] = AverageOf (P1->Point.x, P2->Point.x);
  NewFeature[YPOSITION] = AverageOf (P1->Point.y, P2->Point.y);
  NewFeature[MFLENGTH] = DistanceBetween (P1->Point, P2->Point);
  NewFeature[ORIENTATION] = NormalizedAngleFrom(&P1->Point, &P2->Point, 1.0);
  ComputeBulges(Start, End, NewFeature);
  return (NewFeature);
}                                /* ExtractMicroFeature */


/*---------------------------------------------------------------------------*/
void SmearBulges(MICROFEATURES MicroFeatures, FLOAT32 XScale, FLOAT32 YScale) {
/*
 **      Parameters:
 **              MicroFeatures   features to be smeared
 **   XScale    # of normalized units per pixel in x dir
 **   YScale    # of normalized units per pixel in y dir
 **      Globals: none
 **      Operation: Add a random amount to each bulge parameter of each
 **              feature.  The amount added is between -0.5 pixels and
 **              0.5 pixels.  This is done to prevent the prototypes
 **              generated in training from being unrealistically tight.
 **      Return: none
 **      Exceptions: none
 **      History: Thu Jun 28 18:03:38 1990, DSJ, Created.
 */
  MICROFEATURE MicroFeature;
  FLOAT32 MinSmear;
  FLOAT32 MaxSmear;
  FLOAT32 Cos, Sin;
  FLOAT32 Scale;

  iterate(MicroFeatures) {
    MicroFeature = NextFeatureOf (MicroFeatures);

    Cos = fabs(cos(2.0 * PI * MicroFeature[ORIENTATION]));
    Sin = fabs(sin(2.0 * PI * MicroFeature[ORIENTATION]));
    Scale = YScale * Cos + XScale * Sin;

    MinSmear = -0.5 * Scale / (BULGENORMALIZER * MicroFeature[MFLENGTH]);
    MaxSmear = 0.5 * Scale / (BULGENORMALIZER * MicroFeature[MFLENGTH]);

    MicroFeature[FIRSTBULGE] += UniformRandomNumber (MinSmear, MaxSmear);
    MicroFeature[SECONDBULGE] += UniformRandomNumber (MinSmear, MaxSmear);
  }
}                                /* SmearBulges */
/////////////////////////////////////////////////////////////////mfx////////////////////////////////////////

/////////////////////////////////////////////////////////////////mf////////////////////////////////////////
/**----------------------------------------------------------------------------
        Global Data Definitions and Declarations
----------------------------------------------------------------------------**/
/**----------------------------------------------------------------------------
              Private Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
FEATURE_SET ExtractMicros(TBLOB *Blob, LINE_STATS *LineStats) {
/*
 **	Parameters:
 **		Blob		blob to extract micro-features from
 **		LineStats	statistics on text row blob is in
 **	Globals: none
 **	Operation: Call the old micro-feature extractor and then copy
 **		the features into the new format.  Then deallocate the
 **		old micro-features.
 **	Return: Micro-features for Blob.
 **	Exceptions: none
 **	History: Wed May 23 18:06:38 1990, DSJ, Created.
 */
  int NumFeatures;
  MICROFEATURES Features, OldFeatures;
  FEATURE_SET FeatureSet;
  FEATURE Feature;
  MICROFEATURE OldFeature;

  OldFeatures = (MICROFEATURES)BlobMicroFeatures(Blob, LineStats);
  if (OldFeatures == NULL)
    return NULL;
  NumFeatures = myCount(OldFeatures);
  FeatureSet = NewFeatureSet (NumFeatures);

  Features = OldFeatures;
  iterate(Features) {
    OldFeature = (MICROFEATURE) first_node (Features);
    Feature = NewFeature (&MicroFeatureDesc);
    Feature->Params[MFDirection] = OldFeature[ORIENTATION];
    Feature->Params[MFXPosition] = OldFeature[XPOSITION];
    Feature->Params[MFYPosition] = OldFeature[YPOSITION];
    Feature->Params[MFLength] = OldFeature[MFLENGTH];

    // Bulge features should not be used
    // anymore and are therefore set to 0.
//     ParamOf (Feature, MFBulge1) = FirstBulgeOf (OldFeature);
//     ParamOf (Feature, MFBulge2) = SecondBulgeOf (OldFeature);
    Feature->Params[MFBulge1] = 0.0f;
    Feature->Params[MFBulge2] = 0.0f;
#ifndef __MSW32__
    // Assert that feature parameters are well defined.
    int i;
    for (i = 0; i < Feature->Type->NumParams; i++) {
      assert(!isnan(Feature->Params[i]));
    }
#endif
    AddFeature(FeatureSet, Feature);
  }
  FreeMicroFeatures(OldFeatures);
  return (FeatureSet);

}                                /* ExtractMicros */
/////////////////////////////////////////////////////////////////mf////////////////////////////////////////

/////////////////////////////////////////////////////////////////featdefs////////////////////////////////////////
/** define errors triggered by this module */
#define ILLEGAL_NUM_SETS  3001

#define PICO_FEATURE_LENGTH 0.05
//#define MAX_OUTLINE_FEATURES  100

/*-----------------------------------------------------------------------------
        Global Data Definitions and Declarations
-----------------------------------------------------------------------------*/
/* define all of the parameters for the MicroFeature type*/
StartParamDesc (MicroFeatureParams)
DefineParam (0, 0, -0.5, 0.5)
DefineParam (0, 0, -0.25, 0.75)
DefineParam (0, 1, 0.0, 1.0)
DefineParam (1, 0, 0.0, 1.0)
DefineParam (0, 1, -0.5, 0.5)
DefineParam (0, 1, -0.5, 0.5)
EndParamDesc
/* now define the feature type itself (see features.h for info about each
  parameter).*/
DefineFeature (MicroFeatureDesc, 5, 1, 4, 50, "Micro", "mf", MicroFeatureParams)

// define all of the parameters for the PicoFeature type
/* define knob that can be used to adjust pico-feature length */
FLOAT32 PicoFeatureLength = PICO_FEATURE_LENGTH;
StartParamDesc (PicoFeatParams)
DefineParam (0, 0, -0.25, 0.75)
DefineParam (1, 0, 0.0, 1.0)
DefineParam (0, 0, -0.5, 0.5)
EndParamDesc
/* now define the feature type itself (see features.h for info about each
  parameter).*/
DefineFeature (PicoFeatDesc, 2, 1, 1, MAX_UINT8, "Pico", "pf", PicoFeatParams)

/* define all of the parameters for the NormFeat type*/
StartParamDesc (CharNormParams)
DefineParam (0, 0, -0.25, 0.75)
DefineParam (0, 1, 0.0, 1.0)
DefineParam (0, 1, 0.0, 1.0)
DefineParam (0, 1, 0.0, 1.0)
EndParamDesc
/* now define the feature type itself (see features.h for info about each
  parameter).*/
DefineFeature (CharNormDesc, 4, 0, 1, 1, "CharNorm", "cn", CharNormParams)

// define all of the parameters for the OutlineFeature type
StartParamDesc (OutlineFeatParams)
DefineParam (0, 0, -0.5, 0.5)
DefineParam (0, 0, -0.25, 0.75)
DefineParam (0, 0, 0.0, 1.0)
DefineParam (1, 0, 0.0, 1.0)
EndParamDesc
/* now define the feature type itself (see features.h for info about each
  parameter).*/
DefineFeature (OutlineFeatDesc, 3, 1, 1, MAX_OUTLINE_FEATURES, "Outline",
               "of", OutlineFeatParams)

/*-----------------------------------------------------------------------------
        Global Data Definitions and Declarations
-----------------------------------------------------------------------------*/
FEATURE_DEFS_STRUCT FeatureDefs =
{
  NUM_FEATURE_TYPES,
  {
    &MicroFeatureDesc,
      &PicoFeatDesc,
      &OutlineFeatDesc,
      &CharNormDesc
  },{0}, {0}
};

/*-----------------------------------------------------------------------------
              Public Code
-----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/**
 * Release the memory consumed by the specified character
 * description and all of the features in that description.
 *
 * @param CharDesc character description to be deallocated
 *
 * Globals:
 * - none
 *
 * @note Exceptions: none
 * @note History: Wed May 23 13:52:19 1990, DSJ, Created.
 */
void FreeCharDescription(CHAR_DESC CharDesc) {
  int i;

  if (CharDesc) {
    for (i = 0; i < (int)CharDesc->NumFeatureSets; i++)
      FreeFeatureSet (CharDesc->FeatureSets[i]);
    Efree(CharDesc);
  }
}                                /* FreeCharDescription */


/*---------------------------------------------------------------------------*/
/**
 * Allocate a new character description, initialize its
 * feature sets to be empty, and return it.
 *
 * Globals:
 * - none
 *
 * @return New character description structure.
 * @note Exceptions: none
 * @note History: Wed May 23 15:27:10 1990, DSJ, Created.
 */
CHAR_DESC NewCharDescription() {
  CHAR_DESC CharDesc;
  int i;

  CharDesc = (CHAR_DESC) Emalloc (sizeof (CHAR_DESC_STRUCT));
  CharDesc->NumFeatureSets = FeatureDefs.NumFeatureTypes;

  for (i = 0; i < (int)CharDesc->NumFeatureSets; i++)
    CharDesc->FeatureSets[i] = NULL;

  return (CharDesc);

}                                /* NewCharDescription */


/*---------------------------------------------------------------------------*/
/**
 * Write a textual representation of CharDesc to File.
 * The format used is to write out the number of feature
 * sets which will be written followed by a representation of
 * each feature set.
 *
 * Each set starts with the short name for that feature followed
 * by a description of the feature set.  Feature sets which are
 * not present are not written.
 *
 * Globals:
 * - none
 *
 * @param File		open text file to write CharDesc to
 * @param CharDesc	character description to write to File
 *
 * @note Exceptions: none
 * @note History: Wed May 23 17:21:18 1990, DSJ, Created.
 */
void WriteCharDescription(FILE *File, CHAR_DESC CharDesc) {
  int Type;
  int NumSetsToWrite = 0;

  for (Type = 0; Type < (int)CharDesc->NumFeatureSets; Type++)
    if (CharDesc->FeatureSets[Type])
      NumSetsToWrite++;

  fprintf (File, " %d\n", NumSetsToWrite);
  for (Type = 0; Type < (int)CharDesc->NumFeatureSets; Type++)
  if (CharDesc->FeatureSets[Type]) {
    fprintf (File, "%s ", (FeatureDefs.FeatureDesc[Type])->ShortName);
    WriteFeatureSet (File, CharDesc->FeatureSets[Type]);
  }
}                                /* WriteCharDescription */


/*---------------------------------------------------------------------------*/
/**
 * Read a character description from File, and return
 * a data structure containing this information.  The data
 * is formatted as follows:
 * @verbatim
     NumberOfSets
             ShortNameForSet1 Set1
             ShortNameForSet2 Set2
             ...
   @endverbatim
 *
 * Globals:
 * - none
 *
 * @param File open text file to read character description from
 * @return Character description read from File.
 * @note Exceptions:
 * - ILLEGAL_NUM_SETS
 * @note History: Wed May 23 17:32:48 1990, DSJ, Created.
 */
CHAR_DESC ReadCharDescription(FILE *File) {
  int NumSetsToRead;
  char ShortName[FEAT_NAME_SIZE];
  CHAR_DESC CharDesc;
  int Type;

  if (fscanf (File, "%d", &NumSetsToRead) != 1 ||
    NumSetsToRead < 0 || NumSetsToRead > (int)FeatureDefs.NumFeatureTypes)
    DoError (ILLEGAL_NUM_SETS, "Illegal number of feature sets");

  CharDesc = NewCharDescription ();
  for (; NumSetsToRead > 0; NumSetsToRead--) {
    fscanf (File, "%s", ShortName);
    Type = ShortNameToFeatureType (ShortName);
    CharDesc->FeatureSets[Type] =
      ReadFeatureSet (File, FeatureDefs.FeatureDesc[Type]);
  }
  return (CharDesc);

}                                // ReadCharDescription


/*---------------------------------------------------------------------------*/
int ShortNameToFeatureType(const char *ShortName) {
/**
 * Search thru all features currently defined and return
 * the feature type for the feature with the specified short
 * name.  Trap an error if the specified name is not found.
 *
 * Globals:
 * - none
 *
 * @param ShortName short name of a feature type
 * @return Feature type which corresponds to ShortName.
 * @note Exceptions:
 * - ILLEGAL_SHORT_NAME
 * @note History: Wed May 23 15:36:05 1990, DSJ, Created.
 */
  int i;

  for (i = 0; i < (int)FeatureDefs.NumFeatureTypes; i++)
    if (!strcmp ((FeatureDefs.FeatureDesc[i]->ShortName), ShortName))
      return (i);
  DoError (ILLEGAL_SHORT_NAME, "Illegal short name for a feature");
  return 0;

}                                // ShortNameToFeatureType
/////////////////////////////////////////////////////////////////featdefs////////////////////////////////////////

/////////////////////////////////////////////////////////////////fxdefs////////////////////////////////////////
/*-----------------------------------------------------------------------------
        Global Data Definitions and Declarations
-----------------------------------------------------------------------------*/
/** flag to control learn mode vs. classify mode */
int ExtractMode;

// Definitions of extractors separated from feature definitions.
DefineFeatureExt(MicroFeatureExt, ExtractMicros)
DefineFeatureExt(PicoFeatExt, NULL)
DefineFeatureExt(CharNormExt, ExtractCharNormFeatures)
DefineFeatureExt(OutlineFeatExt, NULL)

FEATURE_EXT_STRUCT* ExtractorDefs[NUM_FEATURE_TYPES] = {
  &MicroFeatureExt,
  &PicoFeatExt,
  &OutlineFeatExt,
  &CharNormExt
};


/*-----------------------------------------------------------------------------
              Public Code
-----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
void SetupExtractors() {
  for (int i = 0; i < NUM_FEATURE_TYPES; ++i)
    FeatureDefs.FeatureExtractors[i] = ExtractorDefs[i];
}

/**
 * This routine copies the relavent fields from the
 * Row struct to the LineStats struct.
 *
 * Globals:
 * - none
 *
 * @param Row text row to get line statistics from
 * @param[out] LineStats place to put line statistics
 *
 * @note History: Mon Mar 11 10:38:43 1991, DSJ, Created.
 */
void GetLineStatsFromRow(TEXTROW *Row, LINE_STATS *LineStats) {
  LineStats->Baseline = &(Row->baseline);
  LineStats->XHeightLine = &(Row->xheight);
  LineStats->xheight = Row->lineheight;
  LineStats->AscRise = Row->ascrise;
  LineStats->DescDrop = Row->descdrop;
  LineStats->TextRow = Row;      /* kludge - only needed by fx for */
  /* fast matcher - remove later */

}                                /* GetLineStatsFromRow */
/////////////////////////////////////////////////////////////////fxdefs////////////////////////////////////////

/////////////////////////////////////////////////////////////////ocrfeatures////////////////////////////////////////
/**----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
BOOL8 AddFeature(FEATURE_SET FeatureSet, FEATURE Feature) {
/*
 **	Parameters:
 **		FeatureSet	set of features to add Feature to
 **		Feature		feature to be added to FeatureSet
 **	Globals: none
 **	Operation: Add a feature to a feature set.  If the feature set is
 **		already full, FALSE is returned to indicate that the
 **		feature could not be added to the set; otherwise, TRUE is
 **		returned.
 **	Return: TRUE if feature added to set, FALSE if set is already full.
 **	Exceptions: none
 **	History: Tue May 22 17:22:23 1990, DSJ, Created.
 */
  if (FeatureSet->NumFeatures >= FeatureSet->MaxNumFeatures) {
    FreeFeature(Feature);
    return FALSE;
  }

  FeatureSet->Features[FeatureSet->NumFeatures++] = Feature;
  return TRUE;
}                                /* AddFeature */

/*---------------------------------------------------------------------------*/
void FreeFeature(FEATURE Feature) {
/*
 **	Parameters:
 **		Feature		feature to be deallocated.
 **	Globals: none
 **	Operation: Release the memory consumed by the specified feature.
 **	Return: none
 **	Exceptions: none
 **	History: Mon May 21 13:33:27 1990, DSJ, Created.
 */
  if (Feature) {
    free_struct (Feature, sizeof (FEATURE_STRUCT)
      + sizeof (FLOAT32) * (Feature->Type->NumParams - 1),
      "sizeof(FEATURE_STRUCT)+sizeof(FLOAT32)*(NumParamsIn(Feature)-1)");
  }

}                                /* FreeFeature */


/*---------------------------------------------------------------------------*/
void FreeFeatureSet(FEATURE_SET FeatureSet) {
/*
 **	Parameters:
 **		FeatureSet	set of features to be freed
 **	Globals: none
 **	Operation: Release the memory consumed by the specified feature
 **		set.  This routine also frees the memory consumed by the
 **		features contained in the set.
 **	Return: none
 **	Exceptions: none
 **	History: Mon May 21 13:59:46 1990, DSJ, Created.
 */
  int i;

  if (FeatureSet) {
    for (i = 0; i < FeatureSet->NumFeatures; i++)
      FreeFeature(FeatureSet->Features[i]);
    memfree(FeatureSet);
  }
}                                /* FreeFeatureSet */


/*---------------------------------------------------------------------------*/
FEATURE NewFeature(FEATURE_DESC FeatureDesc) {
/*
 **	Parameters:
 **		FeatureDesc	description of feature to be created.
 **	Globals: none
 **	Operation: Allocate and return a new feature of the specified
 **		type.
 **	Return: New feature.
 **	Exceptions: none
 **	History: Mon May 21 14:06:42 1990, DSJ, Created.
 */
  FEATURE Feature;

  Feature = (FEATURE) alloc_struct (sizeof (FEATURE_STRUCT) +
    (FeatureDesc->NumParams - 1) *
    sizeof (FLOAT32),
    "sizeof(FEATURE_STRUCT)+sizeof(FLOAT32)*(NumParamsIn(Feature)-1)");
  Feature->Type = FeatureDesc;
  return (Feature);

}                                /* NewFeature */


/*---------------------------------------------------------------------------*/
FEATURE_SET NewFeatureSet(int NumFeatures) {
/*
 **	Parameters:
 **		NumFeatures	maximum # of features to be put in feature set
 **	Globals: none
 **	Operation: Allocate and return a new feature set large enough to
 **		hold the specified number of features.
 **	Return: New feature set.
 **	Exceptions: none
 **	History: Mon May 21 14:22:40 1990, DSJ, Created.
 */
  FEATURE_SET FeatureSet;

  FeatureSet = (FEATURE_SET) Emalloc (sizeof (FEATURE_SET_STRUCT) +
    (NumFeatures - 1) * sizeof (FEATURE));
  FeatureSet->MaxNumFeatures = NumFeatures;
  FeatureSet->NumFeatures = 0;
  return (FeatureSet);

}                                /* NewFeatureSet */


/*---------------------------------------------------------------------------*/
FEATURE ReadFeature(FILE *File, FEATURE_DESC FeatureDesc) {
/*
 **	Parameters:
 **		File		open text file to read feature from
 **		FeatureDesc	specifies type of feature to read from File
 **	Globals: none
 **	Operation: Create a new feature of the specified type and read in
 **		the value of its parameters from File.  The extra penalty
 **		for the feature is also computed by calling the appropriate
 **		function for the specified feature type.  The correct text
 **		representation for a feature is a list of N floats where
 **		N is the number of parameters in the feature.
 **	Return: New feature read from File.
 **	Exceptions: ILLEGAL_FEATURE_PARAM if text file doesn't match expected format
 **	History: Wed May 23 08:53:16 1990, DSJ, Created.
 */
  FEATURE Feature;
  int i;

  Feature = NewFeature (FeatureDesc);
  for (i = 0; i < Feature->Type->NumParams; i++) {
#ifndef _MSC_VER
    if (tess_fscanf (File, "%f", &(Feature->Params[i])) != 1)
#else
    if (fscanf (File, "%f", &(Feature->Params[i])) != 1)
#endif
      DoError (ILLEGAL_FEATURE_PARAM, "Illegal feature parameter spec");
#ifndef __MSW32__
    assert (!isnan(Feature->Params[i]));
#endif
  }
  return (Feature);

}                                /* ReadFeature */


/*---------------------------------------------------------------------------*/
FEATURE_SET ReadFeatureSet(FILE *File, FEATURE_DESC FeatureDesc) {
/*
 **	Parameters:
 **		File		open text file to read new feature set from
 **		FeatureDesc	specifies type of feature to read from File
 **	Globals: none
 **	Operation: Create a new feature set of the specified type and read in
 **		the features from File.  The correct text representation
 **		for a feature set is an integer which specifies the number (N)
 **		of features in a set followed by a list of N feature
 **		descriptions.
 **	Return: New feature set read from File.
 **	Exceptions: none
 **	History: Wed May 23 09:17:31 1990, DSJ, Created.
 */
  FEATURE_SET FeatureSet;
  int NumFeatures;
  int i;

  if (fscanf (File, "%d", &NumFeatures) != 1 || NumFeatures < 0)
    DoError (ILLEGAL_NUM_FEATURES, "Illegal number of features in set");

  FeatureSet = NewFeatureSet (NumFeatures);
  for (i = 0; i < NumFeatures; i++)
    AddFeature (FeatureSet, ReadFeature (File, FeatureDesc));

  return (FeatureSet);

}                                /* ReadFeatureSet */


/*---------------------------------------------------------------------------*/
void WriteFeature(FILE *File, FEATURE Feature) {
/*
 **	Parameters:
 **		File		open text file to write Feature to
 **		Feature		feature to write out to File
 **	Globals: none
 **	Operation: Write a textual representation of Feature to File.
 **		This representation is simply a list of the N parameters
 **		of the feature, terminated with a newline.  It is assumed
 **		that the ExtraPenalty field can be reconstructed from the
 **		parameters of the feature.  It is also assumed that the
 **		feature type information is specified or assumed elsewhere.
 **	Return: none
 **	Exceptions: none
 **	History: Wed May 23 09:28:18 1990, DSJ, Created.
 */
  int i;

  for (i = 0; i < Feature->Type->NumParams; i++) {
#ifndef __MSW32__
    assert (!isnan(Feature->Params[i]));
#endif
    fprintf (File, " %12g", Feature->Params[i]);
  }
  fprintf (File, "\n");

}                                /* WriteFeature */


/*---------------------------------------------------------------------------*/
void WriteFeatureSet(FILE *File, FEATURE_SET FeatureSet) {
/*
 **	Parameters:
 **		File		open text file to write FeatureSet to
 **		FeatureSet	feature set to write to File
 **	Globals: none
 **	Operation: Write a textual representation of FeatureSet to File.
 **		This representation is an integer specifying the number of
 **		features in the set, followed by a newline, followed by
 **		text representations for each feature in the set.
 **	Return: none
 **	Exceptions: none
 **	History: Wed May 23 10:06:03 1990, DSJ, Created.
 */
  int i;

  if (FeatureSet) {
    fprintf (File, "%d\n", FeatureSet->NumFeatures);
    for (i = 0; i < FeatureSet->NumFeatures; i++)
      WriteFeature (File, FeatureSet->Features[i]);
  }
}                                /* WriteFeatureSet */


/*---------------------------------------------------------------------------*/
void WriteOldParamDesc(FILE *File, FEATURE_DESC FeatureDesc) {
/*
 **	Parameters:
 **		File		open text file to write FeatureDesc to
 **		FeatureDesc	feature descriptor to write to File
 **	Globals: none
 **	Operation: Write a textual representation of FeatureDesc to File
 **		in the old format (i.e. the format used by the clusterer).
 **		This format is:
 **			Number of Params
 **			Description of Param 1
 **			...
 **	Return: none
 **	Exceptions: none
 **	History: Fri May 25 15:27:18 1990, DSJ, Created.
 */
  int i;

  fprintf (File, "%d\n", FeatureDesc->NumParams);
  for (i = 0; i < FeatureDesc->NumParams; i++) {
    if (FeatureDesc->ParamDesc[i].Circular)
      fprintf (File, "circular ");
    else
      fprintf (File, "linear   ");

    if (FeatureDesc->ParamDesc[i].NonEssential)
      fprintf (File, "non-essential  ");
    else
      fprintf (File, "essential      ");

    fprintf (File, "%f  %f\n",
      FeatureDesc->ParamDesc[i].Min, FeatureDesc->ParamDesc[i].Max);
  }
}                                /* WriteOldParamDesc */
/////////////////////////////////////////////////////////////////ocrfeatures////////////////////////////////////////

/////////////////////////////////////////////////////////////////classify////////////////////////////////////////
namespace {

// Compare FontInfo structures.
bool compare_fontinfo(const FontInfo& fi1, const FontInfo& fi2) {
  // The font properties are required to be the same for two font with the same
  // name, so there is no need to test them.
  // Consequently, querying the table with only its font name as information is
  // enough to retrieve its properties.
  return strcmp(fi1.name, fi2.name) == 0;
}
// Compare FontSet structures.
bool compare_font_set(const FontSet& fs1, const FontSet& fs2) {
  if (fs1.size != fs2.size)
    return false;
  for (int i = 0; i < fs1.size; ++i) {
    if (fs1.configs[i] != fs2.configs[i])
      return false;
  }
  return true;
}

void delete_callback(FontInfo f) {
  delete[] f.name;
}
void delete_callback_fs(FontSet fs) {
  delete[] fs.configs;
}

}

Classify::Classify()
  : INT_MEMBER(tessedit_single_match, FALSE, "Top choice only from CP"),
    BOOL_MEMBER(classify_enable_learning, true, "Enable adaptive classifier"),
    BOOL_MEMBER(classify_recog_devanagari, false,
                "Whether recognizing a language with devanagari script."),
    EnableLearning(true),
    dict_(&image_) {
  fontinfo_table_.set_compare_callback(
      NewPermanentCallback(compare_fontinfo));
  fontinfo_table_.set_clear_callback(
      NewPermanentCallback(delete_callback));
  fontset_table_.set_compare_callback(
      NewPermanentCallback(compare_font_set));
  fontset_table_.set_clear_callback(
      NewPermanentCallback(delete_callback_fs));
  AdaptedTemplates = NULL;
  PreTrainedTemplates = NULL;
  inttemp_loaded_ = false;
  AllProtosOn = NULL;
  PrunedProtos = NULL;
  AllConfigsOn = NULL;
  AllProtosOff = NULL;
  AllConfigsOff = NULL;
  TempProtoMask = NULL;
  NormProtos = NULL;
}

Classify::~Classify() {
  EndAdaptiveClassifier();
}
/////////////////////////////////////////////////////////////////classify////////////////////////////////////////

/////////////////////////////////////////////////////////////////split////////////////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
BOOL_VAR(wordrec_display_splits, 0, "Display splits");

#define SPLITBLOCK 100           /* Cells per block */
makestructure (newsplit, free_split, printsplit, SPLIT, freesplit, SPLITBLOCK, "SPLIT", splitcount)

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/

/**********************************************************************
 * delete_split
 *
 * Remove this split from existance.  Take if off the display list and
 * deallocate its memory.
 **********************************************************************/
void delete_split(SPLIT *split) {
  if (split) {
    free_split(split);
  }
}


/**********************************************************************
 * make_edgept
 *
 * Create an EDGEPT and hook it into an existing list of edge points.
 **********************************************************************/
EDGEPT *make_edgept(int x, int y, EDGEPT *next, EDGEPT *prev) {
  EDGEPT *this_edgept;
  /* Create point */
  this_edgept = newedgept ();
  this_edgept->pos.x = x;
  this_edgept->pos.y = y;
  /* Hook it up */
  this_edgept->next = next;
  this_edgept->prev = prev;
  prev->next = this_edgept;
  next->prev = this_edgept;
  /* Set up vec entries */
  this_edgept->vec.x = this_edgept->next->pos.x - x;
  this_edgept->vec.y = this_edgept->next->pos.y - y;
  this_edgept->prev->vec.x = x - this_edgept->prev->pos.x;
  this_edgept->prev->vec.y = y - this_edgept->prev->pos.y;

  reveal_edge(this_edgept);
  this_edgept->flags[1] = 0;

  return (this_edgept);
}


/**********************************************************************
 * new_split
 *
 * Create a new split record and initialize it.  Put it on the display
 * list.
 **********************************************************************/
SPLIT *new_split(EDGEPT *point1, EDGEPT *point2) {
  SPLIT *s;
  s = (SPLIT *) newsplit ();
  s->point1 = point1;
  s->point2 = point2;
  return (s);
}


/**********************************************************************
 * print_split
 *
 * Print a list of splits.  Show the coordinates of both points in
 * each split.
 **********************************************************************/
void print_split(SPLIT *split) {
  if (split) {
    cprintf ("(%d,%d)--(%d,%d)",
      split->point1->pos.x, split->point1->pos.y,
      split->point2->pos.x, split->point2->pos.y);
  }
}


/**********************************************************************
 * split_outline
 *
 * Split between these two edge points. Apply a split and return a
 * pointer to the other side of the split.
 **********************************************************************/
void split_outline(EDGEPT *join_point1, EDGEPT *join_point2) {
  EDGEPT *temp2;
  EDGEPT *temp1;

  assert (join_point1 != join_point2);

  temp2 = join_point2->next;
  temp1 = join_point1->next;
  /* Create two new points */
  make_edgept(join_point1->pos.x, join_point1->pos.y, temp1, join_point2);
  make_edgept(join_point2->pos.x, join_point2->pos.y, temp2, join_point1);
}


/**********************************************************************
 * unsplit_outlines
 *
 * Remove the split that was put between these two points.
 **********************************************************************/
void unsplit_outlines(EDGEPT *p1, EDGEPT *p2) {
  EDGEPT *tmp1 = p1->next;
  EDGEPT *tmp2 = p2->next;

  assert (p1 != p2);

  tmp1->next->prev = p2;
  tmp2->next->prev = p1;

  p1->next = tmp2->next;
  p2->next = tmp1->next;

  oldedgept(tmp1);
  oldedgept(tmp2);

  p1->vec.x = p1->next->pos.x - p1->pos.x;
  p1->vec.y = p1->next->pos.y - p1->pos.y;

  p2->vec.x = p2->next->pos.x - p2->pos.x;
  p2->vec.y = p2->next->pos.y - p2->pos.y;
}
/////////////////////////////////////////////////////////////////split////////////////////////////////////////

/////////////////////////////////////////////////////////////////olutil////////////////////////////////////////
/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**********************************************************************
 * check_outline_mem
 *
 * Check the memory allocator for outlines.
 **********************************************************************/
void check_outline_mem() {
  TESSLINE *outline;

  outline = newoutline ();
  outline->next = newoutline ();
  oldoutline (outline->next);
  oldoutline(outline);

  outline = newoutline ();
  outline->next = newoutline ();
  oldoutline (outline->next);
  oldoutline(outline);
}


/**********************************************************************
 * correct_blob_order
 *
 * Check to see if the blobs are in the correct order.  If they are not
 * then swap which outlines are attached to which blobs.
 **********************************************************************/
void correct_blob_order(TBLOB *blob1, TBLOB *blob2) {
  TPOINT origin1;
  TPOINT origin2;
  TESSLINE *temp;

  blob_origin(blob1, &origin1);
  blob_origin(blob2, &origin2);

  if (origin1.x > origin2.x) {
    temp = blob2->outlines;
    blob2->outlines = blob1->outlines;
    blob1->outlines = temp;
  }
}


/**********************************************************************
 * eliminate_duplicate_outlines
 *
 * Find and delete any duplicate outline records in this blob.
 **********************************************************************/
void eliminate_duplicate_outlines(TBLOB *blob) {
  TESSLINE *outline;
  TESSLINE *other_outline;
  TESSLINE *last_outline;

  for (outline = blob->outlines; outline; outline = outline->next) {

    for (last_outline = outline, other_outline = outline->next;
      other_outline;
    last_outline = other_outline, other_outline = other_outline->next) {

      if (same_outline_bounds (outline, other_outline)) {
        last_outline->next = other_outline->next;
        oldoutline(other_outline);
        other_outline = last_outline;
      }
    }
  }
}


/**********************************************************************
 * setup_outline
 *
 * Create a new outline structure from this
 **********************************************************************/
void setup_outline(TESSLINE *outline) {
  register EDGEPT *this_edge;
  register int minx = MAX_INT32;
  register int miny = MAX_INT32;
  register int maxx = -MAX_INT32;
  register int maxy = -MAX_INT32;

  /* Find boundaries */
  this_edge = outline->loop;
  do {
    if (this_edge->pos.x < minx)
      minx = this_edge->pos.x;
    if (this_edge->pos.y < miny)
      miny = this_edge->pos.y;
    if (this_edge->pos.x > maxx)
      maxx = this_edge->pos.x;
    if (this_edge->pos.y > maxy)
      maxy = this_edge->pos.y;
    this_edge = this_edge->next;
  }
  while (this_edge != outline->loop);
  /* Reset bounds */
  outline->topleft.x = minx;
  outline->topleft.y = maxy;
  outline->botright.x = maxx;
  outline->botright.y = miny;
}


/**********************************************************************
 * setup_blob_outlines
 *
 * Set up each of the outlines in this blob.
 **********************************************************************/
void setup_blob_outlines(TBLOB *blob) {
  TESSLINE *outline;

  for (outline = blob->outlines; outline; outline = outline->next) {
    setup_outline(outline);
  }
}
/////////////////////////////////////////////////////////////////olutil////////////////////////////////////////

/////////////////////////////////////////////////////////////////seam////////////////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
#define NUM_STARTING_SEAMS  20

#define SEAMBLOCK 100            /* Cells per block */
makestructure (newseam, free_seam, printseam, SEAM, freeseam, SEAMBLOCK, "SEAM", seamcount)

/*----------------------------------------------------------------------
        Public Function Code
----------------------------------------------------------------------*/
/**
 * @name point_in_split
 *
 * Check to see if either of these points are present in the current
 * split.
 * @returns TRUE if one of them is split.
 */
bool point_in_split(SPLIT *split, EDGEPT *point1, EDGEPT *point2) {
  return ((split) ?
    ((exact_point (split->point1, point1) ||
    exact_point (split->point1, point2) ||
    exact_point (split->point2, point1) ||
    exact_point (split->point2, point2)) ? TRUE : FALSE) : FALSE);
}


/**
 * @name point_in_seam
 *
 * Check to see if either of these points are present in the current
 * seam.
 * @returns TRUE if one of them is.
 */
bool point_in_seam(SEAM *seam, SPLIT *split) {
  return (point_in_split (seam->split1, split->point1, split->point2) ||
    point_in_split (seam->split2, split->point1, split->point2) ||
    point_in_split (seam->split3, split->point1, split->point2));
}


/**
 * @name add_seam
 *
 * Add another seam to a collection of seams.
 */
SEAMS add_seam(SEAMS seam_list, SEAM *seam) {
  return (array_push (seam_list, seam));
}


/**
 * @name combine_seam
 *
 * Combine two seam records into a single seam.  Move the split
 * references from the second seam to the first one.  The argument
 * convention is patterned after strcpy.
 */
void combine_seams(SEAM *dest_seam, SEAM *source_seam) {
  dest_seam->priority += source_seam->priority;
  dest_seam->location += source_seam->location;
  dest_seam->location /= 2;

  if (source_seam->split1) {
    if (!dest_seam->split1)
      dest_seam->split1 = source_seam->split1;
    else if (!dest_seam->split2)
      dest_seam->split2 = source_seam->split1;
    else if (!dest_seam->split3)
      dest_seam->split3 = source_seam->split1;
    else
      cprintf ("combine_seam: Seam is too crowded, can't be combined !\n");
  }
  if (source_seam->split2) {
    if (!dest_seam->split2)
      dest_seam->split2 = source_seam->split2;
    else if (!dest_seam->split3)
      dest_seam->split3 = source_seam->split2;
    else
      cprintf ("combine_seam: Seam is too crowded, can't be combined !\n");
  }
  if (source_seam->split3) {
    if (!dest_seam->split3)
      dest_seam->split3 = source_seam->split3;
    else
      cprintf ("combine_seam: Seam is too crowded, can't be combined !\n");
  }
  free_seam(source_seam);
}


/**
 * @name delete_seam
 *
 * Free this seam record and the splits that are attached to it.
 */
void delete_seam(void *arg) {  //SEAM  *seam)
  SEAM *seam = (SEAM *) arg;

  if (seam) {
    if (seam->split1)
      delete_split (seam->split1);
    if (seam->split2)
      delete_split (seam->split2);
    if (seam->split3)
      delete_split (seam->split3);
    free_seam(seam);
  }
}


/**
 * @name free_seam_list
 *
 * Free all the seams that have been allocated in this list.  Reclaim
 * the memory for each of the splits as well.
 */
void free_seam_list(SEAMS seam_list) {
  int x;

  array_loop (seam_list, x) delete_seam (array_value (seam_list, x));
  array_free(seam_list);
}


/**
 * @name test_insert_seam
 *
 * @returns true if insert_seam will succeed.
 */
bool test_insert_seam(SEAMS seam_list,
                      int index,
                      TBLOB *left_blob,
                      TBLOB *first_blob) {
  SEAM *test_seam;
  TBLOB *blob;
  int test_index;
  int list_length;

  list_length = array_count (seam_list);
  for (test_index = 0, blob = first_blob->next;
  test_index < index; test_index++, blob = blob->next) {
    test_seam = (SEAM *) array_value (seam_list, test_index);
    if (test_index + test_seam->widthp < index &&
        test_seam->widthp + test_index == index - 1 &&
        account_splits_right(test_seam, blob) < 0)
      return false;
  }
  for (test_index = index, blob = left_blob->next;
  test_index < list_length; test_index++, blob = blob->next) {
    test_seam = (SEAM *) array_value (seam_list, test_index);
    if (test_index - test_seam->widthn >= index &&
        test_index - test_seam->widthn == index &&
        account_splits_left(test_seam, first_blob, blob) < 0)
      return false;
  }
  return true;
}

/**
 * @name insert_seam
 *
 * Add another seam to a collection of seams at a particular location
 * in the seam array.
 */
SEAMS insert_seam(SEAMS seam_list,
                  int index,
                  SEAM *seam,
                  TBLOB *left_blob,
                  TBLOB *first_blob) {
  SEAM *test_seam;
  TBLOB *blob;
  int test_index;
  int list_length;

  list_length = array_count (seam_list);
  for (test_index = 0, blob = first_blob->next;
  test_index < index; test_index++, blob = blob->next) {
    test_seam = (SEAM *) array_value (seam_list, test_index);
    if (test_index + test_seam->widthp >= index) {
      test_seam->widthp++;       /*got in the way */
    }
    else if (test_seam->widthp + test_index == index - 1) {
      test_seam->widthp = account_splits_right(test_seam, blob);
      if (test_seam->widthp < 0) {
        cprintf ("Failed to find any right blob for a split!\n");
        print_seam("New dud seam", seam);
        print_seam("Failed seam", test_seam);
      }
    }
  }
  for (test_index = index, blob = left_blob->next;
  test_index < list_length; test_index++, blob = blob->next) {
    test_seam = (SEAM *) array_value (seam_list, test_index);
    if (test_index - test_seam->widthn < index) {
      test_seam->widthn++;       /*got in the way */
    }
    else if (test_index - test_seam->widthn == index) {
      test_seam->widthn = account_splits_left(test_seam, first_blob, blob);
      if (test_seam->widthn < 0) {
        cprintf ("Failed to find any left blob for a split!\n");
        print_seam("New dud seam", seam);
        print_seam("Failed seam", test_seam);
      }
    }
  }
  return (array_insert (seam_list, index, seam));
}


/**
 * @name account_splits_right
 *
 * Account for all the splits by looking to the right.
 * in the blob list.
 */
int account_splits_right(SEAM *seam, TBLOB *blob) {
  inT8 found_em[3];
  inT8 width;

  found_em[0] = seam->split1 == NULL;
  found_em[1] = seam->split2 == NULL;
  found_em[2] = seam->split3 == NULL;
  if (found_em[0] && found_em[1] && found_em[2])
    return 0;
  width = 0;
  do {
    if (!found_em[0])
      found_em[0] = find_split_in_blob (seam->split1, blob);
    if (!found_em[1])
      found_em[1] = find_split_in_blob (seam->split2, blob);
    if (!found_em[2])
      found_em[2] = find_split_in_blob (seam->split3, blob);
    if (found_em[0] && found_em[1] && found_em[2]) {
      return width;
    }
    width++;
    blob = blob->next;
  }
  while (blob != NULL);
  return -1;
}


/**
 * @name account_splits_left
 *
 * Account for all the splits by looking to the left.
 * in the blob list.
 */
int account_splits_left(SEAM *seam, TBLOB *blob, TBLOB *end_blob) {
  static inT32 depth = 0;
  static inT8 width;
  static inT8 found_em[3];

  if (blob != end_blob) {
    depth++;
    account_splits_left (seam, blob->next, end_blob);
    depth--;
  }
  else {
    found_em[0] = seam->split1 == NULL;
    found_em[1] = seam->split2 == NULL;
    found_em[2] = seam->split3 == NULL;
    width = 0;
  }
  if (!found_em[0])
    found_em[0] = find_split_in_blob (seam->split1, blob);
  if (!found_em[1])
    found_em[1] = find_split_in_blob (seam->split2, blob);
  if (!found_em[2])
    found_em[2] = find_split_in_blob (seam->split3, blob);
  if (!found_em[0] || !found_em[1] || !found_em[2]) {
    width++;
    if (depth == 0) {
      width = -1;
    }
  }
  return width;
}


/**
 * @name find_split_in_blob
 *
 * @returns TRUE if the split is somewhere in this blob.
 */
bool find_split_in_blob(SPLIT *split, TBLOB *blob) {
  TESSLINE *outline;

#if 0
  for (outline = blob->outlines; outline != NULL; outline = outline->next)
    if (is_split_outline (outline, split))
      return TRUE;
  return FALSE;
#endif
  for (outline = blob->outlines; outline != NULL; outline = outline->next)
    if (point_in_outline(split->point1, outline))
      break;
  if (outline == NULL)
    return FALSE;
  for (outline = blob->outlines; outline != NULL; outline = outline->next)
    if (point_in_outline(split->point2, outline))
      return TRUE;
  return FALSE;
}


/**
 * @name join_two_seams
 *
 * Merge these two seams into a new seam.  Duplicate the split records
 * in both of the input seams.  Return the resultant seam.
 */
SEAM *join_two_seams(SEAM *seam1, SEAM *seam2) {
  SEAM *result = NULL;
  SEAM *temp;

  assert(seam1 &&seam2);

  if (((seam1->split3 == NULL && seam2->split2 == NULL) ||
    (seam1->split2 == NULL && seam2->split3 == NULL) ||
    seam1->split1 == NULL ||
  seam2->split1 == NULL) && (!shared_split_points (seam1, seam2))) {
    clone_seam(result, seam1);
    clone_seam(temp, seam2);
    combine_seams(result, temp);
  }
  return (result);
}


/**
 * @name new_seam
 *
 * Create a structure for a "seam" between two blobs.  This data
 * structure may actually hold up to three different splits.
 * Initailization of this record is done by this routine.
 */
SEAM *new_seam(PRIORITY priority,
               int x_location,
               SPLIT *split1,
               SPLIT *split2,
               SPLIT *split3) {
  SEAM *seam;

  seam = newseam ();

  seam->priority = priority;
  seam->location = x_location;
  seam->widthp = 0;
  seam->widthn = 0;
  seam->split1 = split1;
  seam->split2 = split2;
  seam->split3 = split3;

  return (seam);
}


/**
 * @name new_seam_list
 *
 * Create a collection of seam records in an array.
 */
SEAMS new_seam_list() {
  return (array_new (NUM_STARTING_SEAMS));
}


/**
 * @name print_seam
 *
 * Print a list of splits.  Show the coordinates of both points in
 * each split.
 */
void print_seam(const char *label, SEAM *seam) {
  if (seam) {
    cprintf(label);
    cprintf (" %6.2f @ %5d, p=%d, n=%d ",
      seam->priority, seam->location, seam->widthp, seam->widthn);

    print_split (seam->split1);

    if (seam->split2) {
      cprintf (",   ");
      print_split (seam->split2);

      if (seam->split3) {
        cprintf (",   ");
        print_split (seam->split3);
      }
    }
    cprintf ("\n");
  }
}


/**
 * @name print_seams
 *
 * Print a list of splits.  Show the coordinates of both points in
 * each split.
 */
void print_seams(const char *label, SEAMS seams) {
  int x;
  char number[CHARS_PER_LINE];

  if (seams) {
    cprintf ("%s\n", label);
    array_loop(seams, x) {
      sprintf (number, "%2d:   ", x);
      print_seam (number, (SEAM *) array_value (seams, x));
    }
    cprintf ("\n");
  }
}


/**
 * @name shared_split_points
 *
 * Check these two seams to make sure that neither of them have two
 * points in common. Return TRUE if any of the same points are present
 * in any of the splits of both seams.
 */
int shared_split_points(SEAM *seam1, SEAM *seam2) {
  if (seam1 == NULL || seam2 == NULL)
    return (FALSE);

  if (seam2->split1 == NULL)
    return (FALSE);
  if (point_in_seam (seam1, seam2->split1))
    return (TRUE);

  if (seam2->split2 == NULL)
    return (FALSE);
  if (point_in_seam (seam1, seam2->split2))
    return (TRUE);

  if (seam2->split3 == NULL)
    return (FALSE);
  if (point_in_seam (seam1, seam2->split3))
    return (TRUE);

  return (FALSE);
}
/////////////////////////////////////////////////////////////////seam////////////////////////////////////////

/////////////////////////////////////////////////////////////////svshowim////////////////////////////////////////
// Override of a tesseract function to display an image in a window.
// This function redirects the display to ScrollView instead of the
// stubbed-out functions in tesseract.

void sv_show_sub_image(IMAGE*    source,         // Image to show.
                       inT32     xstart,         // Start image coords.
                       inT32     ystart,
                       inT32     xext,           // Size of rectangle to show.
                       inT32     yext,
                       ScrollView*    window,         // Window to draw in.
                       inT32     xpos,           // Place to show bottom-left.
                       inT32     ypos) {         // Y position.
#ifdef HAVE_LIBLEPT
  Pix* pix;
  if (xstart != 0 || ystart != 0 ||
      xext != source->get_xsize() || yext != source->get_ysize()) {
    IMAGE sub_im;
    sub_im.create(xext, yext, source->get_bpp());
    copy_sub_image(source, xstart, ystart, xext, yext, &sub_im, 0, 0, false);
    pix = sub_im.ToPix();
  } else {
    pix = source->ToPix();
  }
  window->Image(pix, xpos, window->TranslateYCoordinate(yext) + ypos);
  pixDestroy(&pix);
#endif
  Q_UNUSED(source);
  Q_UNUSED(xstart);
  Q_UNUSED(ystart);
  Q_UNUSED(xext);
  Q_UNUSED(yext);
  Q_UNUSED(window);
  Q_UNUSED(xpos);
  Q_UNUSED(ypos);
}
/////////////////////////////////////////////////////////////////svshowim////////////////////////////////////////

/////////////////////////////////////////////////////////////////matrix////////////////////////////////////////
// Print the best guesses out of the match rating matrix.
void MATRIX::print(const UNICHARSET &current_unicharset) {
  cprintf("Ratings Matrix (top choices)\n");

  /* Do each diagonal */
  for (int spread = 0; spread < this->dimension(); spread++) {
    /* For each spot */
    for (int x = 0; x < this->dimension() - spread; x++) {
      /* Process one square */
      BLOB_CHOICE_LIST *rating = this->get(x, x + spread);
      if (rating != NOT_CLASSIFIED) {
        cprintf("\t[%d,%d] : ", x, x + spread);
        // Print first 3 BLOB_CHOICES from ratings.
        BLOB_CHOICE_IT rating_it;
        rating_it.set_to_list(rating);
        int count = 0;
        for (rating_it.mark_cycle_pt();
             count < 3 && !rating_it.cycled_list();
             ++count, rating_it.forward()) {
          UNICHAR_ID unichar_id = rating_it.data()->unichar_id();
          cprintf("%-10s%4.0f%s", current_unicharset.id_to_unichar(unichar_id),
                  rating_it.data()->rating(),
                  (!rating_it.at_last() && count+1 < 3) ? "\t|\t" : "\n");
        }
      }
    }
  }
}
/////////////////////////////////////////////////////////////////matrix////////////////////////////////////////

/////////////////////////////////////////////////////////////////badwords////////////////////////////////////////
#define MAX_NUM_BAD_WERDS 1000

/*----------------------------------------------------------------------------
        Global Data Definitions and Declarations
-----------------------------------------------------------------------------*/
/** heap that bad words are stored in */
static HEAP *BadWords = NULL;
BOOL_VAR (tessedit_save_stats, FALSE, "Save final recognition statistics");

/*----------------------------------------------------------------------------
              Public Code
-----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/**
 * This routine prints the bad words stored in BadWords
 * to file ordered by certainty (worst certainty first).
 *
 * @param File open text file to print bad words to
 *
 * Globals:
 * - BadWords heap that bad words are stored in
 *
 * @note Exceptions: none
 * @note History: Thu Apr 25 08:57:08 1991, DSJ, Created.
 */
void PrintBadWords(FILE *File)
{
    HEAPENTRY NextWord;

    if (BadWords == NULL) return;

    fprintf (File, "\n");
    fprintf (File, "Bad Word         Certainty\n");
    fprintf (File, "---------------- ---------\n");

    while (GetTopOfHeap (BadWords, &NextWord) != EMPTY)
    {
        fprintf (File, "%16s %6.2f\n", (const char *) NextWord.Data, NextWord.Key);
        free_string ((char *) NextWord.Data);
    }

    fprintf (File, "\n");
}                                /* PrintBadWords */


/*---------------------------------------------------------------------------*/
/**
 * This routine saves all words flagged as bad in a heap
 * with the worst word on the top of the heap.  The contents
 * of this heap can be printed to a file by calling
 * PrintBadWords (File).
 *
 * @param Word bad word to be saved
 * @param Certainty certainty of word
 *
 * Globals:
 * - BadWords heap to keep bad words in
 *
 * History: Thu Apr 25 08:41:00 1991, DSJ, Created.
 */
void SaveBadWord(const char *Word, FLOAT32 Certainty)
{
    HEAPENTRY NewWord;
    assert (Word != NULL);

    if (BadWords == NULL)
    {
        BadWords = MakeHeap (MAX_NUM_BAD_WERDS);
        InitHeap(BadWords);
    }
    else if (HeapFull(BadWords))
    {
        return;
    }

    NewWord.Key = Certainty;
    NewWord.Data = alloc_string (strlen (Word) + 1);
    strcpy ((char *) NewWord.Data, Word);
    HeapStore(BadWords, &NewWord);  /* SaveBadWord */
}
/////////////////////////////////////////////////////////////////badwords////////////////////////////////////////

/////////////////////////////////////////////////////////////////wordrec////////////////////////////////////////
Wordrec::Wordrec() {}
Wordrec::~Wordrec() {}
/////////////////////////////////////////////////////////////////wordrec////////////////////////////////////////

/////////////////////////////////////////////////////////////////tessvars////////////////////////////////////////
#define EXTERN
EXTERN INT_VAR (tessedit_adapt_kludge, 0,
"Use acceptable result or dangambigs");
EXTERN BOOL_VAR (interactive_mode, FALSE, "Run interactively?");
EXTERN BOOL_VAR (edit_variables, FALSE, "Variables Editor Window?");
// xiaofan EXTERN STRING_VAR(file_type,".bl","Filename extension");
EXTERN STRING_VAR (file_type, ".tif", "Filename extension");
INT_VAR (testedit_match_debug, 0, "Integer match debug ctrl");
EXTERN INT_VAR (tessedit_dangambigs_chop, FALSE,
"Use UnicharAmbigs to direct chop");
EXTERN INT_VAR (tessedit_dangambigs_assoc, FALSE,
"Use UnicharAmbigs to direct assoc");

EXTERN IMAGE page_image;         //image of page
EXTERN FILE *debug_fp = stderr;           //write debug stuff here
/////////////////////////////////////////////////////////////////tessvars////////////////////////////////////////

/////////////////////////////////////////////////////////////////imgscale////////////////////////////////////////
#define f(xc, yc) ((xc - factor*yc)*(xc - factor*yc))
#define g(oldyc, yc, oldxc, xc) (factor*factor*(oldyc - yc)*(oldyc - yc)/(abs(oldxc - xc) + 1))

void
dyn_exit (const char s[]) {
  fprintf (stderr, "%s", s);
  err_exit();
}


void dyn_prog(  //The clever bit
              int n,
              int *x,
              int *y,
              int ymax,
              int *oldx,
              int *oldy,
              int oldn,
              float factor) {
  int i, z, j, matchflag;
  int **ymin;
  float **F, fz;

  /* F[i][z] gives minimum over y <= z */

  F = (float **) calloc (n, sizeof (float *));
  ymin = (int **) calloc (n, sizeof (int *));
  if ((F == NULL) || (ymin == NULL))
    dyn_exit ("Error in calloc\n");

  for (i = 0; i < n; i++) {
    F[i] = (float *) calloc (ymax - n + i + 1, sizeof (float));
    ymin[i] = (int *) calloc (ymax - n + i + 1, sizeof (int));
    if ((F[i] == NULL) || (ymin[i] == NULL))
      dyn_exit ("Error in calloc\n");
  }

  F[0][0] = f (x[0], 0);
  /* find nearest transition of same sign (white to black) */
  j = 0;
  while ((j < oldn) && (oldx[j] < x[0]))
    j += 2;
  if (j >= oldn)
    j -= 2;
  else if ((j - 2 >= 0) && ((x[0] - oldx[j - 2]) < (oldx[j] - x[0])))
    j -= 2;
  if (abs (oldx[j] - x[0]) < factor) {
    matchflag = 1;
    F[0][0] += g (oldy[j], 0, oldx[j], x[0]);
  }
  else
    matchflag = 0;
  ymin[0][0] = 0;

  for (z = 1; z < ymax - n + 1; z++) {
    fz = f (x[0], z);
    /* add penalty for deviating from previous row if necessary */

    if (matchflag)
      fz += g (oldy[j], z, oldx[j], x[0]);
    if (fz < F[0][z - 1]) {
      F[0][z] = fz;
      ymin[0][z] = z;
    }
    else {
      F[0][z] = F[0][z - 1];
      ymin[0][z] = ymin[0][z - 1];
    }
  }

  for (i = 1; i < n; i++) {
    F[i][i] = f (x[i], i) + F[i - 1][i - 1];
    /* add penalty for deviating from previous row if necessary */
    if (j > 0)
      j--;
    else
      j++;
    while ((j < oldn) && (oldx[j] < x[i]))
      j += 2;
    if (j >= oldn)
      j -= 2;
    else if ((j - 2 >= 0) && ((x[i] - oldx[j - 2]) < (oldx[j] - x[i])))
      j -= 2;
    if (abs (oldx[j] - x[i]) < factor) {
      matchflag = 1;
      F[i][i] += g (oldy[j], i, oldx[j], x[i]);
    }
    else
      matchflag = 0;
    ymin[i][i] = i;
    for (z = i + 1; z < ymax - n + i + 1; z++) {
      fz = f (x[i], z) + F[i - 1][z - 1];
      /* add penalty for deviating from previous row if necessary */
      if (matchflag)
        fz += g (oldy[j], z, oldx[j], x[i]);
      if (fz < F[i][z - 1]) {
        F[i][z] = fz;
        ymin[i][z] = z;
      }
      else {
        F[i][z] = F[i][z - 1];
        ymin[i][z] = ymin[i][z - 1];
      }
    }
  }

  y[n - 1] = ymin[n - 1][ymax - 1];
  for (i = n - 2; i >= 0; i--)
    y[i] = ymin[i][y[i + 1] - 1];

  for (i = 0; i < n; i++) {
    free (F[i]);
    free (ymin[i]);
  }
  free(F);
  free(ymin);

  return;
}
/////////////////////////////////////////////////////////////////imgscale////////////////////////////////////////

/////////////////////////////////////////////////////////////////scaleimg////////////////////////////////////////
void scale_image(                     //scale an image
                 IMAGE &image,        //source image
                 IMAGE &target_image  //target image
                ) {
  inT32 xsize, ysize, new_xsize, new_ysize;
  IMAGELINE line, new_line;
  int *hires, *lores, *oldhires, *oldlores;
  int i, j, n, oldn, row, col;
  int offset = 0;                //not used here
  float factor;
  uinT8 curr_colour, new_colour;
  int dummy = -1;
  IMAGE image2;                  //horiz scaled image

  xsize = image.get_xsize ();
  ysize = image.get_ysize ();
  new_xsize = target_image.get_xsize ();
  new_ysize = target_image.get_ysize ();
  if (new_ysize > new_xsize)
    new_line.init (new_ysize);
  else
    new_line.init (new_xsize);

  factor = (float) xsize / (float) new_xsize;

  hires = (int *) calloc (xsize, sizeof (int));
  lores = (int *) calloc (new_xsize, sizeof (int));
  oldhires = (int *) calloc (xsize, sizeof (int));
  oldlores = (int *) calloc (new_xsize, sizeof (int));
  if ((hires == NULL) || (lores == NULL) || (oldhires == NULL)
  || (oldlores == NULL)) {
    fprintf (stderr, "Calloc error in scale_image\n");
    err_exit();
  }

  image2.create (new_xsize, ysize, image.get_bpp ());

  oldn = 0;
  /* do first row separately because hires[col-1] doesn't make sense here */
  image.fast_get_line (0, 0, xsize, &line);
  /* each line nominally begins with white */
  curr_colour = 1;
  n = 0;
  for (i = 0; i < xsize; i++) {
    new_colour = *(line.pixels + i);
    if (new_colour != curr_colour) {
      hires[n] = i;
      n++;
      curr_colour = new_colour;
    }
  }
  if (offset != 0)
    for (i = 0; i < n; i++)
      hires[i] += offset;

  if (n > new_xsize) {
    tprintf ("Too many transitions (%d) on line 0\n", n);
    scale_image_cop_out(image,
                        target_image,
                        factor,
                        hires,
                        lores,
                        oldhires,
                        oldlores);
    return;
  }
  else if (n > 0)
    dyn_prog (n, hires, lores, new_xsize, &dummy, &dummy, 0, factor);
  else
    lores[0] = new_xsize;

  curr_colour = 1;
  j = 0;
  for (i = 0; i < new_xsize; i++) {
    if (lores[j] == i) {
      curr_colour = 1 - curr_colour;
      j++;
    }
    *(new_line.pixels + i) = curr_colour;
  }
  image2.put_line (0, 0, new_xsize, &new_line, 0);

  for (i = 0; i < n; i++) {
    oldhires[i] = hires[i];
    oldlores[i] = lores[i];
  }

  for (i = n; i < oldn; i++) {
    oldhires[i] = 0;
    oldlores[i] = 0;
  }
  oldn = n;

  for (row = 1; row < ysize; row++) {
    image.fast_get_line (0, row, xsize, &line);
    /* each line nominally begins with white */
    curr_colour = 1;
    n = 0;
    for (i = 0; i < xsize; i++) {
      new_colour = *(line.pixels + i);
      if (new_colour != curr_colour) {
        hires[n] = i;
        n++;
        curr_colour = new_colour;
      }
    }
    for (i = n; i < oldn; i++) {
      hires[i] = 0;
      lores[i] = 0;
    }
    if (offset != 0)
      for (i = 0; i < n; i++)
        hires[i] += offset;

    if (n > new_xsize) {
      tprintf ("Too many transitions (%d) on line %d\n", n, row);
      scale_image_cop_out(image,
                          target_image,
                          factor,
                          hires,
                          lores,
                          oldhires,
                          oldlores);
      return;
    }
    else if (n > 0)
      dyn_prog(n, hires, lores, new_xsize, oldhires, oldlores, oldn, factor);
    else
      lores[0] = new_xsize;

    curr_colour = 1;
    j = 0;
    for (i = 0; i < new_xsize; i++) {
      if (lores[j] == i) {
        curr_colour = 1 - curr_colour;
        j++;
      }
      *(new_line.pixels + i) = curr_colour;
    }
    image2.put_line (0, row, new_xsize, &new_line, 0);

    for (i = 0; i < n; i++) {
      oldhires[i] = hires[i];
      oldlores[i] = lores[i];
    }
    for (i = n; i < oldn; i++) {
      oldhires[i] = 0;
      oldlores[i] = 0;
    }
    oldn = n;
  }

  free(hires);
  free(lores);
  free(oldhires);
  free(oldlores);

  /* NOW DO THE VERTICAL SCALING from image2 to target_image*/

  xsize = new_xsize;
  factor = (float) ysize / (float) new_ysize;
  offset = 0;

  hires = (int *) calloc (ysize, sizeof (int));
  lores = (int *) calloc (new_ysize, sizeof (int));
  oldhires = (int *) calloc (ysize, sizeof (int));
  oldlores = (int *) calloc (new_ysize, sizeof (int));
  if ((hires == NULL) || (lores == NULL) || (oldhires == NULL)
  || (oldlores == NULL)) {
    fprintf (stderr, "Calloc error in scale_image (vert)\n");
    err_exit();
  }

  oldn = 0;
  /* do first col separately because hires[col-1] doesn't make sense here */
  image2.get_column (0, 0, ysize, &line, 0);
  /* each line nominally begins with white */
  curr_colour = 1;
  n = 0;
  for (i = 0; i < ysize; i++) {
    new_colour = *(line.pixels + i);
    if (new_colour != curr_colour) {
      hires[n] = i;
      n++;
      curr_colour = new_colour;
    }
  }

  if (offset != 0)
    for (i = 0; i < n; i++)
      hires[i] += offset;

  if (n > new_ysize) {
    tprintf ("Too many transitions (%d) on column 0\n", n);
    scale_image_cop_out(image,
                        target_image,
                        factor,
                        hires,
                        lores,
                        oldhires,
                        oldlores);
    return;
  }
  else if (n > 0)
    dyn_prog (n, hires, lores, new_ysize, &dummy, &dummy, 0, factor);
  else
    lores[0] = new_ysize;

  curr_colour = 1;
  j = 0;
  for (i = 0; i < new_ysize; i++) {
    if (lores[j] == i) {
      curr_colour = 1 - curr_colour;
      j++;
    }
    *(new_line.pixels + i) = curr_colour;
  }
  target_image.put_column (0, 0, new_ysize, &new_line, 0);

  for (i = 0; i < n; i++) {
    oldhires[i] = hires[i];
    oldlores[i] = lores[i];
  }
  for (i = n; i < oldn; i++) {
    oldhires[i] = 0;
    oldlores[i] = 0;
  }
  oldn = n;

  for (col = 1; col < xsize; col++) {
    image2.get_column (col, 0, ysize, &line, 0);
    /* each line nominally begins with white */
    curr_colour = 1;
    n = 0;
    for (i = 0; i < ysize; i++) {
      new_colour = *(line.pixels + i);
      if (new_colour != curr_colour) {
        hires[n] = i;
        n++;
        curr_colour = new_colour;
      }
    }
    for (i = n; i < oldn; i++) {
      hires[i] = 0;
      lores[i] = 0;
    }

    if (offset != 0)
      for (i = 0; i < n; i++)
        hires[i] += offset;

    if (n > new_ysize) {
      tprintf ("Too many transitions (%d) on column %d\n", n, col);
      scale_image_cop_out(image,
                          target_image,
                          factor,
                          hires,
                          lores,
                          oldhires,
                          oldlores);
      return;
    }
    else if (n > 0)
      dyn_prog(n, hires, lores, new_ysize, oldhires, oldlores, oldn, factor);
    else
      lores[0] = new_ysize;

    curr_colour = 1;
    j = 0;
    for (i = 0; i < new_ysize; i++) {
      if (lores[j] == i) {
        curr_colour = 1 - curr_colour;
        j++;
      }
      *(new_line.pixels + i) = curr_colour;
    }
    target_image.put_column (col, 0, new_ysize, &new_line, 0);

    for (i = 0; i < n; i++) {
      oldhires[i] = hires[i];
      oldlores[i] = lores[i];
    }
    for (i = n; i < oldn; i++) {
      oldhires[i] = 0;
      oldlores[i] = 0;
    }
    oldn = n;
  }
  free(hires);
  free(lores);
  free(oldhires);
  free(oldlores);
}


/**********************************************************************
 * scale_image_cop_out
 *
 * Cop-out of scale_image by doing it the easy way and free the data.
 **********************************************************************/

void scale_image_cop_out(                      //scale an image
                         IMAGE &image,         //source image
                         IMAGE &target_image,  //target image
                         float factor,         //scale factor
                         int *hires,
                         int *lores,
                         int *oldhires,
                         int *oldlores) {
  inT32 xsize, ysize, new_xsize, new_ysize;

  xsize = image.get_xsize ();
  ysize = image.get_ysize ();
  new_xsize = target_image.get_xsize ();
  new_ysize = target_image.get_ysize ();

  if (factor <= 0.5)
    reduce_sub_image (&image, 0, 0, xsize, ysize,
      &target_image, 0, 0, (inT32) (1.0 / factor), FALSE);
  else if (factor >= 2)
    enlarge_sub_image (&image, 0, 0, &target_image,
        0, 0, new_xsize, new_ysize, (inT32) factor, FALSE);
  else
    copy_sub_image (&image, 0, 0, xsize, ysize, &target_image, 0, 0, FALSE);
  free(hires);
  free(lores);
  free(oldhires);
  free(oldlores);
}
/////////////////////////////////////////////////////////////////scaleimg////////////////////////////////////////

/////////////////////////////////////////////////////////////////callnet////////////////////////////////////////
#define OUTPUT_NODES 94
const ERRCODE NETINIT = "NN init error";

//extern "C"
//{
//extern char*                          demodir;                                        /* where program lives */

void init_net() {  /* Initialise net */
#ifdef ASPIRIN_INCLUDED
  char wts_filename[256];

  if (nmatch_init_network () != 0) {
    NETINIT.error ("Init_net", EXIT, "Errcode %s", nmatch_error_string ());
  }
  strcpy(wts_filename, demodir);
  strcat (wts_filename, "tessdata/netwts");

  if (nmatch_load_network (wts_filename) != 0) {
    NETINIT.error ("Init_net", EXIT, "Weights failed, Errcode %s",
      nmatch_error_string ());
  }
#endif
}


void callnet(  /* Apply image to net */
             float *input_vector,
             char *top,
             float *top_score,
             char *next,
             float *next_score) {
#ifdef ASPIRIN_INCLUDED
  float *output_vector;
  int i;
  int max_out_i = 0;
  int next_max_out_i = 0;
  float max_out = -9;
  float next_max_out = -9;

  nmatch_set_input(input_vector);
  nmatch_propagate_forward();
  output_vector = nmatch_get_output ();

  /* Now find top two choices */

  for (i = 0; i < OUTPUT_NODES; i++) {
    if (output_vector[i] > max_out) {
      next_max_out = max_out;
      max_out = output_vector[i];
      next_max_out_i = max_out_i;
      max_out_i = i;
    }
    else {
      if (output_vector[i] > next_max_out) {
        next_max_out = output_vector[i];
        next_max_out_i = i;
      }
    }
  }
  *top = max_out_i + '!';
  *next = next_max_out_i + '!';
  *top_score = max_out;
  *next_score = next_max_out;
#endif
  Q_UNUSED(input_vector);
  Q_UNUSED(top);
  Q_UNUSED(top_score);
  Q_UNUSED(next);
  Q_UNUSED(next_score);
}
/////////////////////////////////////////////////////////////////callnet////////////////////////////////////////

/////////////////////////////////////////////////////////////////reject////////////////////////////////////////
CLISTIZEH (STRING) CLISTIZE (STRING)
#define EXTERN
EXTERN
INT_VAR (tessedit_reject_mode, 0, "Rejection algorithm");
EXTERN
INT_VAR (tessedit_ok_mode, 5, "Acceptance decision algorithm");
EXTERN
BOOL_VAR (tessedit_use_nn, FALSE, "");
EXTERN
BOOL_VAR (tessedit_rejection_debug, FALSE, "Adaption debug");
EXTERN
BOOL_VAR (tessedit_rejection_stats, FALSE, "Show NN stats");
EXTERN
BOOL_VAR (tessedit_flip_0O, TRUE, "Contextual 0O O0 flips");
EXTERN
double_VAR (tessedit_lower_flip_hyphen, 1.5,
"Aspect ratio dot/hyphen test");
EXTERN
double_VAR (tessedit_upper_flip_hyphen, 1.8,
"Aspect ratio dot/hyphen test");

EXTERN
BOOL_VAR (rej_trust_doc_dawg, FALSE,
"Use DOC dawg in 11l conf. detector");
EXTERN
BOOL_VAR (rej_1Il_use_dict_word, FALSE, "Use dictword test");
EXTERN
BOOL_VAR (rej_1Il_trust_permuter_type, TRUE, "Dont double check");

EXTERN
BOOL_VAR (one_ell_conflict_default, TRUE, "one_ell_conflict default");
EXTERN
BOOL_VAR (show_char_clipping, FALSE, "Show clip image window?");
EXTERN
BOOL_VAR (nn_debug, FALSE, "NN DEBUGGING?");
EXTERN
BOOL_VAR (nn_reject_debug, FALSE, "NN DEBUG each char?");
EXTERN
BOOL_VAR (nn_lax, FALSE, "Use 2nd rate matches");
EXTERN
BOOL_VAR (nn_double_check_dict, FALSE, "Double check");
EXTERN
BOOL_VAR (nn_conf_double_check_dict, TRUE,
"Double check for confusions");
EXTERN
BOOL_VAR (nn_conf_1Il, TRUE, "NN use 1Il conflicts");
EXTERN
BOOL_VAR (nn_conf_Ss, TRUE, "NN use Ss conflicts");
EXTERN
BOOL_VAR (nn_conf_hyphen, TRUE, "NN hyphen conflicts");
EXTERN
BOOL_VAR (nn_conf_test_good_qual, FALSE, "NN dodgy 1Il cross check");
EXTERN
BOOL_VAR (nn_conf_test_dict, TRUE, "NN dodgy 1Il cross check");
EXTERN
BOOL_VAR (nn_conf_test_sensible, TRUE, "NN dodgy 1Il cross check");
EXTERN
BOOL_VAR (nn_conf_strict_on_dodgy_chs, TRUE,
"Require stronger NN match");
EXTERN
double_VAR (nn_dodgy_char_threshold, 0.99, "min accept score");
EXTERN
INT_VAR (nn_conf_accept_level, 4, "NN accept dodgy 1Il matches? ");
EXTERN
INT_VAR (nn_conf_initial_i_level, 3,
"NN accept initial Ii match level ");

EXTERN
BOOL_VAR (no_unrej_dubious_chars, TRUE, "Dubious chars next to reject?");
EXTERN
BOOL_VAR (no_unrej_no_alphanum_wds, TRUE, "Stop unrej of non A/N wds?");
EXTERN
BOOL_VAR (no_unrej_1Il, FALSE, "Stop unrej of 1Ilchars?");
EXTERN
BOOL_VAR (rej_use_tess_accepted, TRUE, "Individual rejection control");
EXTERN
BOOL_VAR (rej_use_tess_blanks, TRUE, "Individual rejection control");
EXTERN
BOOL_VAR (rej_use_good_perm, TRUE, "Individual rejection control");
EXTERN
BOOL_VAR (rej_use_sensible_wd, FALSE, "Extend permuter check");
EXTERN
BOOL_VAR (rej_alphas_in_number_perm, FALSE, "Extend permuter check");

EXTERN
double_VAR (rej_whole_of_mostly_reject_word_fract, 0.85,
"if >this fract");
EXTERN
INT_VAR (rej_mostly_reject_mode, 1,
"0-never, 1-afterNN, 2-after new xht");
EXTERN
double_VAR (tessed_fullstop_aspect_ratio, 1.2,
"if >this fract then reject");

EXTERN
INT_VAR (net_image_width, 40, "NN input image width");
EXTERN
INT_VAR (net_image_height, 36, "NN input image height");
EXTERN
INT_VAR (net_image_x_height, 22, "NN input image x_height");
EXTERN
INT_VAR (tessedit_image_border, 2, "Rej blbs near image edge limit");

/*
  Net input is assumed to have (net_image_width * net_image_height) input
  units of image pixels, followed by 0, 1, or N units representing the
  baseline position. 0 implies no baseline information. 1 implies a floating
  point value. N implies a "guage" of N units. For any char an initial set
  of these are ON, the remainder OFF to indicate the "level" of the
  baseline.

  HOWEVER!!!  NOTE THAT EACH NEW INPUT LAYER FORMAT EXPECTS TO BE RUN WITH A
  DIFFERENT tessed/netmatch/nmatch.c MODULE. - These are classic C modules
  generated by aspirin with HARD CODED CONSTANTS
*/

EXTERN
INT_VAR (net_bl_nodes, 20, "Number of baseline nodes");

EXTERN
double_VAR (nn_reject_threshold, 0.5, "NN min accept score");
EXTERN
double_VAR (nn_reject_head_and_shoulders, 0.6, "top scores sep factor");

/* NOTE - ctoh doesn't handle "=" properly, hence \075 */
EXTERN
STRING_VAR (ok_single_ch_non_alphanum_wds, "-?\075",
"Allow NN to unrej");
EXTERN
STRING_VAR (ok_repeated_ch_non_alphanum_wds, "-?*\075",
"Allow NN to unrej");
EXTERN
STRING_VAR (conflict_set_I_l_1, "Il1[]", "Il1 conflict set");
EXTERN
STRING_VAR (conflict_set_S_s, "Ss$", "Ss conflict set");
EXTERN
STRING_VAR (conflict_set_hyphen, "-_~", "hyphen conflict set");
EXTERN
STRING_VAR (dubious_chars_left_of_reject, "!'+`()-./\\<>;:^_,~\"",
"Unreliable chars");
EXTERN
STRING_VAR (dubious_chars_right_of_reject, "!'+`()-./\\<>;:^_,~\"",
"Unreliable chars");

EXTERN
INT_VAR (min_sane_x_ht_pixels, 8, "Reject any x-ht lt or eq than this");

/*************************************************************************
 * set_done()
 *
 * Set the done flag based on the word acceptability criteria
 *************************************************************************/
void Tesseract::set_done(  //set done flag
                         WERD_RES *word,
                         inT16 pass) {
  /*
  0: Original heuristic used in Tesseract and Ray's prototype Resaljet
  */
  if (tessedit_ok_mode == 0) {
    /* NOTE - done even if word contains some or all spaces !!! */
    word->done = word->tess_accepted;
  }
  /*
  1: Reject words containing blanks and on pass 1 reject I/l/1 conflicts
  */
  else if (tessedit_ok_mode == 1) {
    word->done = word->tess_accepted &&
      (strchr (word->best_choice->unichar_string().string (), ' ') == NULL);

    if (word->done && (pass == 1) && one_ell_conflict (word, FALSE))
      word->done = FALSE;
  }
  /*
  2: as 1 + only accept dict words or numerics in pass 1
  */
  else if (tessedit_ok_mode == 2) {
    word->done = word->tess_accepted &&
      (strchr (word->best_choice->unichar_string().string (), ' ') == NULL);

    if (word->done && (pass == 1) && one_ell_conflict (word, FALSE))
      word->done = FALSE;

    if (word->done &&
      (pass == 1) &&
      (word->best_choice->permuter () != SYSTEM_DAWG_PERM) &&
      (word->best_choice->permuter () != FREQ_DAWG_PERM) &&
      (word->best_choice->permuter () != USER_DAWG_PERM) &&
    (word->best_choice->permuter () != NUMBER_PERM)) {
      #ifndef SECURE_NAMES
      if (tessedit_rejection_debug)
        tprintf ("\nVETO Tess accepting poor word \"%s\"\n",
          word->best_choice->unichar_string().string ());
      #endif
      word->done = FALSE;
    }
  }
  /*
  3: as 2 + only accept dict words or numerics in pass 2 as well
  */
  else if (tessedit_ok_mode == 3) {
    word->done = word->tess_accepted &&
      (strchr (word->best_choice->unichar_string().string (), ' ') == NULL);

    if (word->done && (pass == 1) && one_ell_conflict (word, FALSE))
      word->done = FALSE;

    if (word->done &&
      (word->best_choice->permuter () != SYSTEM_DAWG_PERM) &&
      (word->best_choice->permuter () != FREQ_DAWG_PERM) &&
      (word->best_choice->permuter () != USER_DAWG_PERM) &&
    (word->best_choice->permuter () != NUMBER_PERM)) {
      #ifndef SECURE_NAMES
      if (tessedit_rejection_debug)
        tprintf ("\nVETO Tess accepting poor word \"%s\"\n",
          word->best_choice->unichar_string().string ());
      #endif
      word->done = FALSE;
    }
  }
  /*
  4: as 2 + reject dict ambigs in pass 1
  */
  else if (tessedit_ok_mode == 4) {
    word->done = word->tess_accepted &&
      (strchr (word->best_choice->unichar_string().string (), ' ') == NULL);

    if (word->done && (pass == 1) && one_ell_conflict (word, FALSE))
      word->done = FALSE;

    if (word->done &&
      (pass == 1) &&
      (((word->best_choice->permuter () != SYSTEM_DAWG_PERM) &&
      (word->best_choice->permuter () != FREQ_DAWG_PERM) &&
      (word->best_choice->permuter () != USER_DAWG_PERM) &&
      (word->best_choice->permuter () != NUMBER_PERM)) ||
    (test_ambig_word (word)))) {
      #ifndef SECURE_NAMES
      if (tessedit_rejection_debug)
        tprintf ("\nVETO Tess accepting poor word \"%s\"\n",
          word->best_choice->unichar_string().string ());
      #endif
      word->done = FALSE;
    }
  }
  /*
  5: as 3 + reject dict ambigs in both passes
  */
  else if (tessedit_ok_mode == 5) {
    word->done = word->tess_accepted &&
      (strchr (word->best_choice->unichar_string().string (), ' ') == NULL);

    if (word->done && (pass == 1) && one_ell_conflict (word, FALSE))
      word->done = FALSE;

    if (word->done &&
      (((word->best_choice->permuter () != SYSTEM_DAWG_PERM) &&
      (word->best_choice->permuter () != FREQ_DAWG_PERM) &&
      (word->best_choice->permuter () != USER_DAWG_PERM) &&
      (word->best_choice->permuter () != NUMBER_PERM)) ||
    (test_ambig_word (word)))) {
      #ifndef SECURE_NAMES
      if (tessedit_rejection_debug)
        tprintf ("\nVETO Tess accepting poor word \"%s\"\n",
          word->best_choice->unichar_string().string ());
      #endif
      word->done = FALSE;
    }
  }

  else {
    tprintf ("BAD tessedit_ok_mode\n");
    err_exit();
  }
}


/*************************************************************************
 * make_reject_map()
 *
 * Sets the done flag to indicate whether the resylt is acceptable.
 *
 * Sets a reject map for the word.
 *************************************************************************/
void Tesseract::make_reject_map(      //make rej map for wd //detailed results
                                WERD_RES *word,
                                BLOB_CHOICE_LIST_CLIST *blob_choices,
                                ROW *row,
                                inT16 pass  //1st or 2nd?
                               ) {
  int i;
  int offset;

  flip_0O(word);
  check_debug_pt (word, -1);     //For trap only
  set_done(word, pass);  //Set acceptance
  word->reject_map.initialise (word->best_choice->unichar_lengths().length ());
  reject_blanks(word);
  /*
  0: Rays original heuristic - the baseline
  */
  if (tessedit_reject_mode == 0) {
    if (!word->done)
      reject_poor_matches(word, blob_choices);
  }
  /*
  5: Reject I/1/l from words where there is no strong contextual confirmation;
    the whole of any unacceptable words (incl PERM rej of dubious 1/I/ls);
    and the whole of any words which are very small
  */
  else if (tessedit_reject_mode == 5) {
    if (bln_x_height / word->denorm.scale () <= min_sane_x_ht_pixels)
      word->reject_map.rej_word_small_xht ();
    else {
      one_ell_conflict(word, TRUE);
      /*
        Originally the code here just used the done flag. Now I have duplicated
        and unpacked the conditions for setting the done flag so that each
        mechanism can be turned on or off independently. This works WITHOUT
        affecting the done flag setting.
      */
      if (rej_use_tess_accepted && !word->tess_accepted)
        word->reject_map.rej_word_not_tess_accepted ();

      if (rej_use_tess_blanks &&
        (strchr (word->best_choice->unichar_string().string (), ' ') != NULL))
        word->reject_map.rej_word_contains_blanks ();

      if (rej_use_good_perm) {
        if (((word->best_choice->permuter () == SYSTEM_DAWG_PERM) ||
          (word->best_choice->permuter () == FREQ_DAWG_PERM) ||
          (word->best_choice->permuter () == USER_DAWG_PERM)) &&
          (!rej_use_sensible_wd ||
          (acceptable_word_string
          (word->best_choice->unichar_string().string (),
           word->best_choice->unichar_lengths().string ()) !=
        AC_UNACCEPTABLE))) {
          //PASSED TEST
        }
        else if (word->best_choice->permuter () == NUMBER_PERM) {
          if (rej_alphas_in_number_perm) {
            for (i = 0, offset = 0;
                 word->best_choice->unichar_string()[offset] != '\0';
                 offset += word->best_choice->unichar_lengths()[i++]) {
              if (word->reject_map[i].accepted () &&
                  unicharset.get_isalpha(
                      word->best_choice->unichar_string().string() + offset,
                      word->best_choice->unichar_lengths()[i]))
                word->reject_map[i].setrej_bad_permuter ();
              //rej alpha
            }
          }
        }
        else {
          word->reject_map.rej_word_bad_permuter ();
        }
      }

      /* Ambig word rejection was here once !!*/

    }
  }
  else {
    tprintf ("BAD tessedit_reject_mode\n");
    err_exit();
  }

  if (tessedit_image_border > -1)
    reject_edge_blobs(word);

  check_debug_pt (word, 10);
  if (tessedit_rejection_debug) {
    tprintf ("Permuter Type = %d\n", word->best_choice->permuter ());
    tprintf ("Certainty: %f     Rating: %f\n",
      word->best_choice->certainty (), word->best_choice->rating ());
    tprintf("Dict word: %d\n", dict_word(*(word->best_choice)));
  }

  /* Un-reject any rejected characters if NN permits */

  if (tessedit_use_nn && (pass == 2) &&
    word->reject_map.recoverable_rejects ())
    nn_recover_rejects(word, row);
  flip_hyphens(word);
  check_debug_pt (word, 20);
}

void reject_blanks(WERD_RES *word) {
  inT16 i;
  inT16 offset;

  for (i = 0, offset = 0; word->best_choice->unichar_string()[offset] != '\0';
       offset += word->best_choice->unichar_lengths()[i], i += 1) {
    if (word->best_choice->unichar_string()[offset] == ' ')
                                 //rej unrecognised blobs
      word->reject_map[i].setrej_tess_failure ();
  }
}


void reject_I_1_L(WERD_RES *word) {
  inT16 i;
  inT16 offset;

  for (i = 0, offset = 0; word->best_choice->unichar_string()[offset] != '\0';
       offset += word->best_choice->unichar_lengths()[i], i += 1) {
    if (STRING (conflict_set_I_l_1).
    contains (word->best_choice->unichar_string()[offset])) {
                                 //rej 1Il conflict
      word->reject_map[i].setrej_1Il_conflict ();
    }
  }
}


void reject_poor_matches(  //detailed results
                         WERD_RES *word,
                         BLOB_CHOICE_LIST_CLIST *blob_choices) {
  float threshold;
  inT16 i = 0;
  inT16 offset = 0;
                                 //super iterator
  BLOB_CHOICE_LIST_C_IT list_it = blob_choices;
  BLOB_CHOICE_IT choice_it;      //real iterator

  #ifndef SECURE_NAMES
  if (strlen(word->best_choice->unichar_lengths().string()) != (size_t)list_it.length()) {
    tprintf
      ("ASSERT FAIL string:\"%s\"; strlen=%d; choices len=%d; blob len=%d\n",
      word->best_choice->unichar_string().string(),
      strlen (word->best_choice->unichar_lengths().string()), list_it.length(),
      word->outword->blob_list()->length());
  }
  #endif
  ASSERT_HOST (strlen (word->best_choice->unichar_lengths().string ()) == (size_t)list_it.length ());
  ASSERT_HOST (word->outword->blob_list ()->length () == list_it.length ());
  threshold = compute_reject_threshold (blob_choices);

  for (list_it.mark_cycle_pt ();
  !list_it.cycled_list (); list_it.forward (), i++,
           offset += word->best_choice->unichar_lengths()[i]) {
    /* NB - only compares the threshold against the TOP choice char in the
      choices list for a blob !! - the selected one may be below the threshold
    */
    choice_it.set_to_list (list_it.data ());
    if ((word->best_choice->unichar_string()[offset] == ' ') ||
      (choice_it.length () == 0))
                                 //rej unrecognised blobs
      word->reject_map[i].setrej_tess_failure ();
    else if (choice_it.data ()->certainty () < threshold)
                                 //rej poor score blob
      word->reject_map[i].setrej_poor_match ();
  }
}


/**********************************************************************
 * compute_reject_threshold
 *
 * Set a rejection threshold for this word.
 * Initially this is a trivial function which looks for the largest
 * gap in the certainty value.
 **********************************************************************/

float compute_reject_threshold(  //compute threshold //detailed results
                               BLOB_CHOICE_LIST_CLIST *blob_choices) {
  inT16 index;                   //to ratings
  inT16 blob_count;              //no of blobs in word
  inT16 ok_blob_count = 0;       //non TESS rej blobs in word
  float *ratings;                //array of confidences
  float threshold;               //rejection threshold
  float bestgap;                 //biggest gap
  float gapstart;                //bottom of gap
                                 //super iterator
  BLOB_CHOICE_LIST_C_IT list_it = blob_choices;
  BLOB_CHOICE_IT choice_it;      //real iterator

  blob_count = blob_choices->length ();
  ratings = (float *) alloc_mem (blob_count * sizeof (float));
  for (list_it.mark_cycle_pt (), index = 0;
  !list_it.cycled_list (); list_it.forward (), index++) {
    choice_it.set_to_list (list_it.data ());
    if (choice_it.length () > 0) {
      ratings[ok_blob_count] = choice_it.data ()->certainty ();
      //get in an array
      //                 tprintf("Rating[%d]=%c %g %g\n",
      //                         index,choice_it.data()->char_class(),
      //                         choice_it.data()->rating(),choice_it.data()->certainty());
      ok_blob_count++;
    }
  }
  ASSERT_HOST (index == blob_count);
  qsort (ratings, ok_blob_count, sizeof (float), sort_floats);
  //sort them
  bestgap = 0;
  gapstart = ratings[0] - 1;     //all reject if none better
  if (ok_blob_count >= 3) {
    for (index = 0; index < ok_blob_count - 1; index++) {
      if (ratings[index + 1] - ratings[index] > bestgap) {
        bestgap = ratings[index + 1] - ratings[index];
        //find biggest
        gapstart = ratings[index];
      }
    }
  }
  threshold = gapstart + bestgap / 2;
  //      tprintf("First=%g, last=%g, gap=%g, threshold=%g\n",
  //              ratings[0],ratings[index],bestgap,threshold);

  free_mem(ratings);
  return threshold;
}


/*************************************************************************
 * reject_edge_blobs()
 *
 * If the word is perilously close to the edge of the image, reject those blobs
 * in the word which are too close to the edge as they could be clipped.
 *************************************************************************/

void reject_edge_blobs(WERD_RES *word) {
  TBOX word_box = word->word->bounding_box ();
  TBOX blob_box;
  PBLOB_IT blob_it = word->outword->blob_list ();
  //blobs
  int blobindex = 0;
  float centre;

  if ((word_box.left () < tessedit_image_border) ||
    (word_box.bottom () < tessedit_image_border) ||
    (word_box.right () + tessedit_image_border >
    page_image.get_xsize () - 1) ||
  (word_box.top () + tessedit_image_border > page_image.get_ysize () - 1)) {
    ASSERT_HOST (word->reject_map.length () == blob_it.length ());
    for (blobindex = 0, blob_it.mark_cycle_pt ();
    !blob_it.cycled_list (); blobindex++, blob_it.forward ()) {
      blob_box = blob_it.data ()->bounding_box ();
      centre = (blob_box.left () + blob_box.right ()) / 2.0;
      if ((word->denorm.x (blob_box.left ()) < tessedit_image_border) ||
        (word->denorm.y (blob_box.bottom (), centre) <
        tessedit_image_border) ||
        (word->denorm.x (blob_box.right ()) + tessedit_image_border >
        page_image.get_xsize () - 1) ||
        (word->denorm.y (blob_box.top (), centre)
      + tessedit_image_border > page_image.get_ysize () - 1)) {
        word->reject_map[blobindex].setrej_edge_char ();
        //close to edge
      }
    }
  }
}


/**********************************************************************
 * one_ell_conflict()
 *
 * Identify words where there is a potential I/l/1 error.
 * - A bundle of contextual heuristics!
 **********************************************************************/
BOOL8 Tesseract::one_ell_conflict(WERD_RES *word_res, BOOL8 update_map) {
  const char *word;
  const char *lengths;
  inT16 word_len;                //its length
  inT16 first_alphanum_index_;
  inT16 first_alphanum_offset_;
  inT16 i;
  inT16 offset;
  BOOL8 non_conflict_set_char;   //non conf set a/n?
  BOOL8 conflict = FALSE;
  BOOL8 allow_1s;
  ACCEPTABLE_WERD_TYPE word_type;
  BOOL8 dict_perm_type;
  BOOL8 dict_word_ok;
  int dict_word_type;

  word = word_res->best_choice->unichar_string().string ();
  lengths = word_res->best_choice->unichar_lengths().string();
  word_len = strlen (lengths);
  /*
    If there are no occurrences of the conflict set characters then the word
    is OK.
  */
  if (strpbrk (word, conflict_set_I_l_1.string ()) == NULL)
    return FALSE;

  /*
    There is a conflict if there are NO other (confirmed) alphanumerics apart
    from those in the conflict set.
  */

  for (i = 0, offset = 0, non_conflict_set_char = FALSE;
       (i < word_len) && !non_conflict_set_char; offset += lengths[i++])
    non_conflict_set_char =
        (unicharset.get_isalpha(word + offset, lengths[i]) ||
         unicharset.get_isdigit(word + offset, lengths[i])) &&
        !STRING (conflict_set_I_l_1).contains (word[offset]);
  if (!non_conflict_set_char) {
    if (update_map)
      reject_I_1_L(word_res);
    return TRUE;
  }

  /*
    If the word is accepted by a dawg permuter, and the first alpha character
    is "I" or "l", check to see if the alternative is also a dawg word. If it
    is, then there is a potential error otherwise the word is ok.
  */

  dict_perm_type = (word_res->best_choice->permuter () == SYSTEM_DAWG_PERM) ||
    (word_res->best_choice->permuter () == USER_DAWG_PERM) ||
    (rej_trust_doc_dawg &&
    (word_res->best_choice->permuter () == DOC_DAWG_PERM)) ||
    (word_res->best_choice->permuter () == FREQ_DAWG_PERM);
  dict_word_type = dict_word(*(word_res->best_choice));
  dict_word_ok = (dict_word_type > 0) &&
    (rej_trust_doc_dawg || (dict_word_type != DOC_DAWG_PERM));

  if ((rej_1Il_use_dict_word && dict_word_ok) ||
    (rej_1Il_trust_permuter_type && dict_perm_type) ||
  (dict_perm_type && dict_word_ok)) {
    first_alphanum_index_ = first_alphanum_index (word, lengths);
    first_alphanum_offset_ = first_alphanum_offset (word, lengths);
    if (lengths[first_alphanum_index_] == 1 &&
        word[first_alphanum_offset_] == 'I') {
      word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'l';
      if (safe_dict_word(*(word_res->best_choice)) > 0) {
        word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'I';
        if (update_map)
          word_res->reject_map[first_alphanum_index_].
            setrej_1Il_conflict();
        return TRUE;
      }
      else {
        word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'I';
        return FALSE;
      }
    }

    if (lengths[first_alphanum_index_] == 1 &&
        word[first_alphanum_offset_] == 'l') {
      word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'I';
      if (safe_dict_word(*(word_res->best_choice)) > 0) {
        word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'l';
        if (update_map)
          word_res->reject_map[first_alphanum_index_].
            setrej_1Il_conflict();
        return TRUE;
      }
      else {
        word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'l';
        return FALSE;
      }
    }
    return FALSE;
  }

  /*
    NEW 1Il code. The old code relied on permuter types too much. In fact,
    tess will use TOP_CHOICE permute for good things like "palette".
    In this code the string is examined independently to see if it looks like
    a well formed word.
  */

  /*
    REGARDLESS OF PERMUTER, see if flipping a leading I/l generates a
    dictionary word.
  */
  first_alphanum_index_ = first_alphanum_index (word, lengths);
  first_alphanum_offset_ = first_alphanum_offset (word, lengths);
  if (lengths[first_alphanum_index_] == 1 &&
      word[first_alphanum_offset_] == 'l') {
    word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'I';
    if (safe_dict_word(*(word_res->best_choice)) > 0)
      return FALSE;
    else
      word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'l';
  }
  else if (lengths[first_alphanum_index_] == 1 &&
           word[first_alphanum_offset_] == 'I') {
    word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'l';
    if (safe_dict_word(*(word_res->best_choice)) > 0)
      return FALSE;
    else
      word_res->best_choice->unichar_string()[first_alphanum_offset_] = 'I';
  }
  /*
    For strings containing digits:
      If there are no alphas OR the numeric permuter liked the word,
        reject any non 1 conflict chs
      Else reject all conflict chs
  */
  if (word_contains_non_1_digit (word, lengths)) {
    allow_1s = (alpha_count (word, lengths) == 0) ||
      (word_res->best_choice->permuter () == NUMBER_PERM);

    inT16 offset;
    conflict = FALSE;
    for (i = 0, offset = 0; word[offset] != '\0';
         offset += word_res->best_choice->unichar_lengths()[i++]) {
      if ((!allow_1s || (word[offset] != '1')) &&
      STRING (conflict_set_I_l_1).contains (word[offset])) {
        if (update_map)
          word_res->reject_map[i].setrej_1Il_conflict ();
        conflict = TRUE;
      }
    }
    return conflict;
  }
  /*
    For anything else. See if it conforms to an acceptable word type. If so,
    treat accordingly.
  */
  word_type = acceptable_word_string (word, lengths);
  if ((word_type == AC_LOWER_CASE) || (word_type == AC_INITIAL_CAP)) {
    first_alphanum_index_ = first_alphanum_index (word, lengths);
    first_alphanum_offset_ = first_alphanum_offset (word, lengths);
    if (STRING (conflict_set_I_l_1).contains (word[first_alphanum_offset_])) {
      if (update_map)
        word_res->reject_map[first_alphanum_index_].
            setrej_1Il_conflict ();
      return TRUE;
    }
    else
      return FALSE;
  }
  else if (word_type == AC_UPPER_CASE) {
    return FALSE;
  }
  else {
    if (update_map)
      reject_I_1_L(word_res);
    return TRUE;
  }
}


inT16 Tesseract::first_alphanum_index(const char *word,
                                      const char *word_lengths) {
  inT16 i;
  inT16 offset;

  for (i = 0, offset = 0; word[offset] != '\0'; offset += word_lengths[i++]) {
    if (unicharset.get_isalpha(word + offset, word_lengths[i]) ||
        unicharset.get_isdigit(word + offset, word_lengths[i]))
      return i;
  }
  return -1;
}

inT16 Tesseract::first_alphanum_offset(const char *word,
                                       const char *word_lengths) {
  inT16 i;
  inT16 offset;

  for (i = 0, offset = 0; word[offset] != '\0'; offset += word_lengths[i++]) {
    if (unicharset.get_isalpha(word + offset, word_lengths[i]) ||
        unicharset.get_isdigit(word + offset, word_lengths[i]))
      return offset;
  }
  return -1;
}

inT16 Tesseract::alpha_count(const char *word,
                             const char *word_lengths) {
  inT16 i;
  inT16 offset;
  inT16 count = 0;

  for (i = 0, offset = 0; word[offset] != '\0'; offset += word_lengths[i++]) {
    if (unicharset.get_isalpha (word + offset, word_lengths[i]))
      count++;
  }
  return count;
}


BOOL8 Tesseract::word_contains_non_1_digit(const char *word,
                                           const char *word_lengths) {
  inT16 i;
  inT16 offset;

  for (i = 0, offset = 0; word[offset] != '\0'; offset += word_lengths[i++]) {
    if (unicharset.get_isdigit (word + offset, word_lengths[i]) &&
        (word_lengths[i] != 1 || word[offset] != '1'))
      return TRUE;
  }
  return FALSE;
}


BOOL8 Tesseract::test_ambig_word(  //test for ambiguity
                                 WERD_RES *word) {
    BOOL8 ambig = FALSE;

    if ((word->best_choice->permuter () == SYSTEM_DAWG_PERM) ||
      (word->best_choice->permuter () == FREQ_DAWG_PERM) ||
    (word->best_choice->permuter () == USER_DAWG_PERM)) {
      ambig = !getDict().NoDangerousAmbig(
          word->best_choice, NULL, false, NULL, NULL);
  }
  return ambig;
}

/*************************************************************************
 * char_ambiguities()
 *
 * Return a pointer to a string containing the full conflict set of characters
 * which includes the specified character, if there is one. If the specified
 * character is not a member of a conflict set, return NULL.
 * (NOTE that a character is assumed to be a member of only ONE conflict set.)
 *************************************************************************/
const char *Tesseract::char_ambiguities(char c) {
  static STRING_CLIST conflict_sets;
  static BOOL8 read_conflict_sets = FALSE;
  STRING_C_IT cs_it(&conflict_sets);
  const char *cs;
  STRING cs_file_name;
  FILE *cs_file;
  char buff[1024];

  if (!read_conflict_sets) {
    cs_file_name = datadir + "confsets";
    if (!(cs_file = fopen (cs_file_name.string (), "r"))) {
      CANTOPENFILE.error ("char_ambiguities", EXIT, "%s %d",
        cs_file_name.string (), errno);
    }
    while (fscanf (cs_file, "%s", buff) == 1) {
      cs_it.add_after_then_move (new STRING (buff));
    }
    fclose (cs_file);
    read_conflict_sets = TRUE;
    cs_it.move_to_first ();
    if (tessedit_rejection_debug) {
      for (cs_it.mark_cycle_pt ();
      !cs_it.cycled_list (); cs_it.forward ()) {
        tprintf ("\"%s\"\n", cs_it.data ()->string ());
      }
    }
  }

  cs_it.move_to_first ();
  for (cs_it.mark_cycle_pt (); !cs_it.cycled_list (); cs_it.forward ()) {
    cs = cs_it.data ()->string ();
    if (strchr (cs, c) != NULL)
      return cs;
  }
  return NULL;
}

/*************************************************************************
 * nn_recover_rejects()
 * Generate the nn_reject_map - a copy of the current reject map, but dont
 * reject previously rejected chars if the NN matcher agrees with the best
 * choice.
 *************************************************************************/

void Tesseract::nn_recover_rejects(WERD_RES *word, ROW *row) {
                                 //copy for debug
  REJMAP old_map = word->reject_map;
  /*
    NOTE THAT THIS IS RELATIVELY INEFFICIENT AS THE WHOLE OF THE WERD IS
    MATCHED BY THE NN MATCHER. IF COULD EASILY BE RESTRICTED TO JUST THE
    REJECT CHARACTERS  (Though initial use is when words are total rejects
    anyway).
  */

  set_global_subsubloc_code(SUBSUBLOC_NN);
  nn_match_word(word, row);

  if (no_unrej_1Il)
    dont_allow_1Il(word);
  if (no_unrej_dubious_chars)
    dont_allow_dubious_chars(word);

  if (rej_mostly_reject_mode == 1)
    reject_mostly_rejects(word);
  /*
    IF there are no unrejected alphanumerics AND
      The word is not an acceptable single non alphanum char word  AND
      The word is not an acceptable repeated non alphanum char word
    THEN Reject whole word
  */
  if (no_unrej_no_alphanum_wds &&
    (count_alphanums (word) < 1) &&
    !((word->best_choice->unichar_lengths().length () == 1) &&
      STRING(ok_single_ch_non_alphanum_wds).contains(
          word->best_choice->unichar_string()[0]))
    && !repeated_nonalphanum_wd (word, row))

    word->reject_map.rej_word_no_alphanums ();

  #ifndef SECURE_NAMES

  if (nn_debug) {
    tprintf ("\nTess: \"%s\" MAP ",
             word->best_choice->unichar_string().string());
    old_map.print (stdout);
    tprintf ("->");
    word->reject_map.print (stdout);
    tprintf ("\n");
  }
  #endif
  set_global_subsubloc_code(SUBSUBLOC_OTHER);
}

void Tesseract::nn_match_word(  //Match a word
                              WERD_RES *word,
                              ROW *row) {
  PIXROW_LIST *pixrow_list;
  PIXROW_IT pixrow_it;
  IMAGELINE *imlines;            //lines of the image
  TBOX pix_box;                   //box of imlines extent
#ifndef GRAPHICS_DISABLED
  ScrollView* win = NULL;
#endif
  IMAGE clip_image;
  IMAGE scaled_image;
  float baseline_pos;
  inT16 net_image_size;
  inT16 clip_image_size;
  WERD copy_outword;             // copy to denorm
  inT16 i;

  const char *word_string;
  const char *word_string_lengths;
  BOOL8 word_in_dict;            //Tess wd in dict
  BOOL8 checked_dict_word;       //Tess wd definitely in dict
  BOOL8 sensible_word;           //OK char string
  BOOL8 centre;                  //Not at word end       chs
  BOOL8 good_quality_word;
  inT16 char_quality;
  inT16 accepted_char_quality;

  inT16 conf_level;              //0:REJECT
  //1:DODGY ACCEPT
  //2:DICT ACCEPT
  //3:CLEAR ACCEPT
  inT16 first_alphanum_index_;
  inT16 first_alphanum_offset_;

  word_string = word->best_choice->unichar_string().string();
  word_string_lengths = word->best_choice->unichar_lengths().string();
  first_alphanum_index_ = first_alphanum_index (word_string,
                                                word_string_lengths);
  first_alphanum_offset_ = first_alphanum_offset (word_string,
                                                  word_string_lengths);
  word_in_dict = ((word->best_choice->permuter () == SYSTEM_DAWG_PERM) ||
    (word->best_choice->permuter () == FREQ_DAWG_PERM) ||
    (word->best_choice->permuter () == USER_DAWG_PERM));
  checked_dict_word = word_in_dict &&
    (safe_dict_word(*(word->best_choice)) > 0);
  sensible_word = acceptable_word_string (word_string, word_string_lengths) !=
      AC_UNACCEPTABLE;

  word_char_quality(word, row, &char_quality, &accepted_char_quality);
  good_quality_word =
      word->best_choice->unichar_lengths().length () == char_quality;

  #ifndef SECURE_NAMES
  if (nn_reject_debug) {
    tprintf ("Dict: %c   Checked Dict: %c   Sensible: %c   Quality: %c\n",
      word_in_dict ? 'T' : 'F',
      checked_dict_word ? 'T' : 'F',
      sensible_word ? 'T' : 'F', good_quality_word ? 'T' : 'F');
  }
  #endif

  if (word->best_choice->unichar_lengths().length () !=
  word->outword->blob_list ()->length ()) {
    #ifndef SECURE_NAMES
    tprintf ("nn_match_word ASSERT FAIL String:\"%s\";  #Blobs=%d\n",
      word->best_choice->unichar_string().string (),
      word->outword->blob_list ()->length ());
    #endif
    err_exit();
  }

  copy_outword = *(word->outword);
  copy_outword.baseline_denormalise (&word->denorm);
  /*
    For each character, generate and match a new image, containing JUST the
    character we have clipped, centered in the image, on a white background.
    Note that we MUST have a square image so that we can scale it uniformly in
    x and y.  We base the size on x_height as this can be found fairly reliably.
  */
  net_image_size = (net_image_width > net_image_height) ?
    net_image_width : net_image_height;
  clip_image_size = (inT16) floor (0.5 +
    net_image_size * word->x_height /
    net_image_x_height);
  if ((clip_image_size <= 1) || (net_image_size <= 1)) {
    return;
  }

  /*
    Get the image of the word and the pix positions of each char
  */
  char_clip_word(&copy_outword, page_image, pixrow_list, imlines, pix_box);
#ifndef GRAPHICS_DISABLED
  if (show_char_clipping) {
    win = display_clip_image (&copy_outword, page_image,
      pixrow_list, pix_box);
  }
#endif
  pixrow_it.set_to_list (pixrow_list);
  pixrow_it.move_to_first ();
  for (pixrow_it.mark_cycle_pt (), i = 0;
  !pixrow_it.cycled_list (); pixrow_it.forward (), i++) {
    if (pixrow_it.data ()->
      bad_box (page_image.get_xsize (), page_image.get_ysize ()))
      continue;
    clip_image.create (clip_image_size, clip_image_size, 1);
    //make bin imge
    if (!copy_outword.flag (W_INVERSE))
      invert_image(&clip_image);  //white background for black on white
    pixrow_it.data ()->char_clip_image (imlines, pix_box, row,
      clip_image, baseline_pos);
    if (copy_outword.flag (W_INVERSE))
      invert_image(&clip_image);  //invert white on black for scaling &

    scaled_image.create (net_image_size, net_image_size, 1);

    scale_image(clip_image, scaled_image);

    baseline_pos *= net_image_size / clip_image_size;
    //scale with im
    centre = !pixrow_it.at_first () && !pixrow_it.at_last ();

    conf_level = nn_match_char (scaled_image, baseline_pos,
      word_in_dict, checked_dict_word,
      sensible_word, centre,
      good_quality_word, word_string[i]);
    if (word->reject_map[i].recoverable ()) {
      if ((i == first_alphanum_index_) &&
          word_string_lengths[first_alphanum_index_] == 1 &&
      ((word_string[first_alphanum_offset_] == 'I') ||
       (word_string[first_alphanum_offset_] == 'i'))) {
        if (conf_level >= nn_conf_initial_i_level)
          word->reject_map[i].setrej_nn_accept ();
        //un-reject char
      }
      else if (conf_level > 0)
                                 //un-reject char
        word->reject_map[i].setrej_nn_accept ();
    }
#ifndef GRAPHICS_DISABLED
    if (show_char_clipping)
      display_images(clip_image, scaled_image);
#endif
   clip_image.destroy();
   scaled_image.destroy();
  }

  delete[]imlines;               // Free array of imlines
  delete pixrow_list;

#ifndef GRAPHICS_DISABLED
  if (show_char_clipping) {
//    destroy_window(win);
//   win->Destroy();
    delete win;
  }
#endif
}


/*************************************************************************
 * nn_match_char()
 * Call Neural Net matcher to match a single character, given a scaled,
 * square image
 *************************************************************************/

inT16 nn_match_char(                          //of character
                    IMAGE &scaled_image,
                    float baseline_pos,       //rel to scaled_image
                    BOOL8 dict_word,          //part of dict wd?
                    BOOL8 checked_dict_word,  //part of dict wd?
                    BOOL8 sensible_word,      //part acceptable str?
                    BOOL8 centre,             //not at word ends?
                    BOOL8 good_quality_word,  //initial segmentation
                    char tess_ch              //confirm this?
                   ) {
  inT16 conf_level;              //0..2
  inT32 row;
  inT32 col;
  inT32 y_size = scaled_image.get_ysize ();
  inT32 start_y = y_size - (y_size - net_image_height) / 2 - 1;
  inT32 end_y = start_y - net_image_height + 1;
  IMAGELINE imline;
  float *input_vector;
  float *input_vec_ptr;
  char top = 0;
  float top_score = 0;
  char next = 0;
  float next_score = 0;
  inT16 input_nodes = (net_image_height * net_image_width) + net_bl_nodes;
  inT16 j;

  input_vector = (float *) alloc_mem (input_nodes * sizeof (float));
  input_vec_ptr = input_vector;

  invert_image(&scaled_image);  //cos nns work better
  for (row = start_y; row >= end_y; row--) {
    scaled_image.fast_get_line (0, row, net_image_width, &imline);
    for (col = 0; col < net_image_width; col++)
      *input_vec_ptr++ = imline.pixels[col];
  }
  /*
    The bit map presented to the net may be shorter than the image, so shift
    the coord to be relative to the bitmap portion.
  */
  baseline_pos -= (y_size - net_image_height) / 2.0;
  /*
    Baseline pos is 0 if below bitmap, 1 if above and in proportion otherwise.
    This is represented to the net as a set of bl_nodes, an initial proportion
    of which are set to 1.0, indicating the level of the baseline. The
    remainder are 0.0
  */

  if (baseline_pos < 0)
    baseline_pos = 0;
  else if (baseline_pos >= net_image_height)
    baseline_pos = net_image_height + 1;
  else
    baseline_pos = baseline_pos + 1;
  baseline_pos = baseline_pos / (net_image_height + 1);

  if (net_bl_nodes > 0) {
    baseline_pos *= 1.7;         //Use a wider range
    if (net_bl_nodes > 1) {
      /* Multi-node baseline representation */
      for (j = 0; j < net_bl_nodes; j++) {
        if (baseline_pos > ((float) j / net_bl_nodes))
          *input_vec_ptr++ = 1.0;
        else
          *input_vec_ptr++ = 0.0;
      }
    }
    else {
      /* Single node baseline */
      *input_vec_ptr++ = baseline_pos;
    }
  }

  callnet(input_vector, &top, &top_score, &next, &next_score);
  conf_level = evaluate_net_match (top, top_score, next, next_score,
    tess_ch, dict_word, checked_dict_word,
    sensible_word, centre, good_quality_word);
  #ifndef SECURE_NAMES
  if (nn_reject_debug) {
    tprintf ("top:\"%c\" %4.2f   next:\"%c\" %4.2f  TESS:\"%c\" Conf: %d\n",
      top, top_score, next, next_score, tess_ch, conf_level);
  }
  #endif
  free_mem(input_vector);
  return conf_level;
}


inT16 evaluate_net_match(char top,
                         float top_score,
                         char next,
                         float next_score,
                         char tess_ch,
                         BOOL8 dict_word,
                         BOOL8 checked_dict_word,
                         BOOL8 sensible_word,
                         BOOL8 centre,
                         BOOL8 good_quality_word) {
  Q_UNUSED(centre);
  inT16 accept_level;            //0 Very clearly matched
  //1 Clearly top
  //2 Top but poor match
  //3 Next & poor top match
  //4 Next but good top match
  //5 No chance
  BOOL8 good_top_choice;
  BOOL8 excellent_top_choice;
  BOOL8 confusion_match = FALSE;
  BOOL8 dodgy_char = !isalnum (tess_ch);

  good_top_choice = (top_score > nn_reject_threshold) &&
    (nn_reject_head_and_shoulders * top_score > next_score);

  excellent_top_choice = good_top_choice &&
    (top_score > nn_dodgy_char_threshold);

  if (top == tess_ch) {
    if (excellent_top_choice)
      accept_level = 0;
    else if (good_top_choice)
      accept_level = 1;          //Top correct and well matched
    else
      accept_level = 2;          //Top correct but poor match
  }
  else if ((nn_conf_1Il &&
    STRING (conflict_set_I_l_1).contains (tess_ch) &&
    STRING (conflict_set_I_l_1).contains (top)) ||
    (nn_conf_hyphen &&
    STRING (conflict_set_hyphen).contains (tess_ch) &&
    STRING (conflict_set_hyphen).contains (top)) ||
    (nn_conf_Ss &&
    STRING (conflict_set_S_s).contains (tess_ch) &&
  STRING (conflict_set_S_s).contains (top))) {
    confusion_match = TRUE;
    if (good_top_choice)
      accept_level = 1;          //Good top confusion
    else
      accept_level = 2;          //Poor top confusion
  }
  else if ((nn_conf_1Il &&
    STRING (conflict_set_I_l_1).contains (tess_ch) &&
    STRING (conflict_set_I_l_1).contains (next)) ||
    (nn_conf_hyphen &&
    STRING (conflict_set_hyphen).contains (tess_ch) &&
    STRING (conflict_set_hyphen).contains (next)) ||
    (nn_conf_Ss &&
    STRING (conflict_set_S_s).contains (tess_ch) &&
  STRING (conflict_set_S_s).contains (next))) {
    confusion_match = TRUE;
    if (!good_top_choice)
      accept_level = 3;          //Next confusion and top match dodgy
    else
      accept_level = 4;          //Next confusion and good top match
  }
  else if (next == tess_ch) {
    if (!good_top_choice)
      accept_level = 3;          //Next match and top match dodgy
    else
      accept_level = 4;          //Next match and good top match
  }
  else
    accept_level = 5;

  /* Could allow some match flexibility here sS$ etc */

  /* Now set confirmation level according to how much we can believe the tess
    char. */

  if ((accept_level == 0) && !confusion_match)
    return 3;

  if ((accept_level <= 1) &&
    (!nn_conf_strict_on_dodgy_chs || !dodgy_char) && !confusion_match)
    return 3;

  if ((accept_level == 2) &&
    !confusion_match && !dodgy_char &&
    good_quality_word &&
    dict_word &&
    (checked_dict_word || !nn_double_check_dict) && sensible_word)
    return 2;

  if (confusion_match &&
    (accept_level <= nn_conf_accept_level) &&
    (good_quality_word ||
    (!nn_conf_test_good_qual &&
    !STRING (conflict_set_I_l_1).contains (tess_ch))) &&
    (dict_word || !nn_conf_test_dict) &&
    (checked_dict_word || !nn_conf_double_check_dict) &&
    (sensible_word || !nn_conf_test_sensible))
    return 1;

  if (!confusion_match &&
    nn_lax &&
    (accept_level == 3) &&
    (good_quality_word || !nn_conf_test_good_qual) &&
    (dict_word || !nn_conf_test_dict) &&
    (sensible_word || !nn_conf_test_sensible))
    return 1;
  else
    return 0;
}


/*************************************************************************
 * dont_allow_dubious_chars()
 * Let Rejects "eat" into adjacent "dubious" chars. I.e those prone to be wrong
 * if adjacent to a reject.
 *************************************************************************/
void dont_allow_dubious_chars(WERD_RES *word) {
  int i = 0;
  int offset = 0;
  int rej_pos;
  int word_len = word->reject_map.length ();

  while (i < word_len) {
    /* Find next reject */

    while ((i < word_len) && (word->reject_map[i].accepted ()))
    {
      offset += word->best_choice->unichar_lengths()[i];
      i++;
    }

    if (i < word_len) {
      rej_pos = i;

      /* Reject dubious chars to the left */
      i--;
      offset -= word->best_choice->unichar_lengths()[i];
      while ((i >= 0) &&
        STRING(dubious_chars_left_of_reject).contains(
            word->best_choice->unichar_string()[offset])) {
        word->reject_map[i--].setrej_dubious ();
        offset -= word->best_choice->unichar_lengths()[i];
      }

      /* Skip adjacent rejects */

      for (i = rej_pos;
        (i < word_len) && (word->reject_map[i].rejected ());
           offset += word->best_choice->unichar_lengths()[i++]);

      /* Reject dubious chars to the right */

      while ((i < word_len) &&
        STRING(dubious_chars_right_of_reject).contains(
            word->best_choice->unichar_string()[offset])) {
        offset += word->best_choice->unichar_lengths()[i];
        word->reject_map[i++].setrej_dubious ();
      }
    }
  }
}


/*************************************************************************
 * dont_allow_1Il()
 * Dont unreject LONE accepted 1Il conflict set chars
 *************************************************************************/
void Tesseract::dont_allow_1Il(WERD_RES *word) {
  int i = 0;
  int offset;
  int word_len = word->reject_map.length ();
  const char *s = word->best_choice->unichar_string().string ();
  const char *lengths = word->best_choice->unichar_lengths().string ();
  BOOL8 accepted_1Il = FALSE;

  for (i = 0, offset = 0; i < word_len;
       offset += word->best_choice->unichar_lengths()[i++]) {
    if (word->reject_map[i].accepted ()) {
      if (STRING (conflict_set_I_l_1).contains (s[offset]))
        accepted_1Il = TRUE;
      else {
        if (unicharset.get_isalpha (s + offset, lengths[i]) ||
            unicharset.get_isdigit (s + offset, lengths[i]))
          return;                // >=1 non 1Il ch accepted
      }
    }
  }
  if (!accepted_1Il)
    return;                      //Nothing to worry about

  for (i = 0, offset = 0; i < word_len;
       offset += word->best_choice->unichar_lengths()[i++]) {
    if (STRING (conflict_set_I_l_1).contains (s[offset]) &&
      word->reject_map[i].accepted ())
      word->reject_map[i].setrej_postNN_1Il ();
  }
}


inT16 Tesseract::count_alphanums(  //how many alphanums
                                 WERD_RES *word_res) {
  int count = 0;
  const WERD_CHOICE *best_choice = word_res->best_choice;
  for (int i = 0; i < word_res->reject_map.length(); ++i) {
    if ((word_res->reject_map[i].accepted()) &&
        (unicharset.get_isalpha(best_choice->unichar_id(i)) ||
         unicharset.get_isdigit(best_choice->unichar_id(i)))) {
      count++;
    }
  }
  return count;
}


void reject_mostly_rejects(  //rej all if most rejectd
                           WERD_RES *word) {
  /* Reject the whole of the word if the fraction of rejects exceeds a limit */

  if ((float) word->reject_map.reject_count () / word->reject_map.length () >=
    rej_whole_of_mostly_reject_word_fract)
    word->reject_map.rej_word_mostly_rej ();
}

BOOL8 Tesseract::repeated_nonalphanum_wd(WERD_RES *word, ROW *row) {
  inT16 char_quality;
  inT16 accepted_char_quality;

  if (word->best_choice->unichar_lengths().length () <= 1)
    return FALSE;

  if (!STRING (ok_repeated_ch_non_alphanum_wds).
    contains (word->best_choice->unichar_string()[0]))
    return FALSE;

  if (!repeated_ch_string (word->best_choice->unichar_string().string (),
                           word->best_choice->unichar_lengths().string ()))
    return FALSE;

  word_char_quality(word, row, &char_quality, &accepted_char_quality);

  if ((word->best_choice->unichar_lengths().length () == char_quality) &&
    (char_quality == accepted_char_quality))
    return TRUE;
  else
    return FALSE;
}

BOOL8 Tesseract::repeated_ch_string(const char *rep_ch_str,
                                    const char *lengths) {
  UNICHAR_ID c;

  if ((rep_ch_str == NULL) || (*rep_ch_str == '\0')) {
    return FALSE;
  }

  c = unicharset.unichar_to_id(rep_ch_str, *lengths);
  rep_ch_str += *(lengths++);
  while (*rep_ch_str != '\0' &&
         unicharset.unichar_to_id(rep_ch_str, *lengths) == c) {
    rep_ch_str++;
  }
  if (*rep_ch_str == '\0')
    return TRUE;
  return FALSE;
}


inT16 Tesseract::safe_dict_word(const WERD_CHOICE &word) {
  int dict_word_type = dict_word(word);
  return dict_word_type == DOC_DAWG_PERM ? 0 : dict_word_type;
}


void Tesseract::flip_hyphens(WERD_RES *word_res) {
  WERD_CHOICE *best_choice = word_res->best_choice;
  int i;
  PBLOB_IT outword_it;
  int prev_right = -9999;
  int next_left;
  TBOX out_box;
  float aspect_ratio;

  if (tessedit_lower_flip_hyphen <= 1)
    return;

  outword_it.set_to_list(word_res->outword->blob_list());
  UNICHAR_ID unichar_dash = unicharset.unichar_to_id("-");
  bool modified = false;
  for (i = 0, outword_it.mark_cycle_pt();
       i < best_choice->length() && !outword_it.cycled_list();
       ++i, outword_it.forward()) {
    out_box = outword_it.data()->bounding_box();
    if (outword_it.at_last())
      next_left = 9999;
    else
      next_left = outword_it.data_relative(1)->bounding_box().left();
    // Dont touch small or touching blobs - it is too dangerous.
    if ((out_box.width() > 8 * word_res->denorm.scale()) &&
        (out_box.left() > prev_right) && (out_box.right() < next_left)) {
      aspect_ratio = out_box.width() / (float) out_box.height();
      if (unicharset.eq(best_choice->unichar_id(i), ".")) {
        if (aspect_ratio >= tessedit_upper_flip_hyphen &&
            unicharset.contains_unichar_id(unichar_dash) &&
            unicharset.get_enabled(unichar_dash)) {
          /* Certain HYPHEN */
          best_choice->set_unichar_id(unichar_dash, i);
          modified = true;
          if (word_res->reject_map[i].rejected())
            word_res->reject_map[i].setrej_hyphen_accept();
        }
        if ((aspect_ratio > tessedit_lower_flip_hyphen) &&
          word_res->reject_map[i].accepted())
                                 //Suspected HYPHEN
          word_res->reject_map[i].setrej_hyphen ();
      }
      else if (best_choice->unichar_id(i) == unichar_dash) {
        if ((aspect_ratio >= tessedit_upper_flip_hyphen) &&
          (word_res->reject_map[i].rejected()))
          word_res->reject_map[i].setrej_hyphen_accept();
        //Certain HYPHEN

        if ((aspect_ratio <= tessedit_lower_flip_hyphen) &&
          (word_res->reject_map[i].accepted()))
                                 //Suspected HYPHEN
          word_res->reject_map[i].setrej_hyphen();
      }
    }
    prev_right = out_box.right();
  }
  if (modified) {
    best_choice->populate_unichars(unicharset);
  }
}

void Tesseract::flip_0O(WERD_RES *word_res) {
  WERD_CHOICE *best_choice = word_res->best_choice;
  int i;
  PBLOB_IT outword_it;
  TBOX out_box;

  if (!tessedit_flip_0O)
    return;

  outword_it.set_to_list(word_res->outword->blob_list ());

  for (i = 0, outword_it.mark_cycle_pt ();
       i < best_choice->length() && !outword_it.cycled_list ();
       ++i, outword_it.forward ()) {
    if (unicharset.get_isupper(best_choice->unichar_id(i)) ||
        unicharset.get_isdigit(best_choice->unichar_id(i))) {
      out_box = outword_it.data()->bounding_box ();
      if ((out_box.top() < bln_baseline_offset + bln_x_height) ||
        (out_box.bottom() > bln_baseline_offset + bln_x_height / 4))
        return;                  //Beware words with sub/superscripts
    }
  }
  UNICHAR_ID unichar_0 = unicharset.unichar_to_id("0");
  UNICHAR_ID unichar_O = unicharset.unichar_to_id("O");
  if (unichar_0 == INVALID_UNICHAR_ID || !unicharset.get_enabled(unichar_0) ||
      unichar_O == INVALID_UNICHAR_ID || !unicharset.get_enabled(unichar_O)) {
    return;  // 0 or O are not present/enabled in unicharset
  }
  bool modified = false;
  for (i = 1; i < best_choice->length(); ++i, outword_it.forward ()) {
    if (best_choice->unichar_id(i) == unichar_0 ||
        best_choice->unichar_id(i) == unichar_O) {
      /* A0A */
      if ((i+1) < best_choice->length() &&
          non_O_upper(best_choice->unichar_id(i-1)) &&
          non_O_upper(best_choice->unichar_id(i+1))) {
        best_choice->set_unichar_id(unichar_O, i);
        modified = true;
      }
      /* A00A */
      if (non_O_upper(best_choice->unichar_id(i-1)) &&
          (i+1) < best_choice->length() &&
          (best_choice->unichar_id(i+1) == unichar_0 ||
           best_choice->unichar_id(i+1) == unichar_O) &&
          (i+2) < best_choice->length() &&
          non_O_upper(best_choice->unichar_id(i+2))) {
        best_choice->set_unichar_id(unichar_O, i);
        modified = true;
        i++;
      }
      /* AA0<non digit or end of word> */
      if ((i > 1) &&
          non_O_upper(best_choice->unichar_id(i-2)) &&
          non_O_upper(best_choice->unichar_id(i-1)) &&
          (((i+1) < best_choice->length() &&
            !unicharset.get_isdigit(best_choice->unichar_id(i+1)) &&
            !unicharset.eq(best_choice->unichar_id(i+1), "l") &&
            !unicharset.eq(best_choice->unichar_id(i+1), "I")) ||
           (i == best_choice->length() - 1))) {
        best_choice->set_unichar_id(unichar_O, i);
        modified = true;
      }
      /* 9O9 */
      if (non_0_digit(best_choice->unichar_id(i-1)) &&
          (i+1) < best_choice->length() &&
          non_0_digit(best_choice->unichar_id(i+1))) {
        best_choice->set_unichar_id(unichar_0, i);
        modified = true;
      }
      /* 9OOO */
      if (non_0_digit(best_choice->unichar_id(i-1)) &&
          (i+2) < best_choice->length() &&
          (best_choice->unichar_id(i+1) == unichar_0 ||
           best_choice->unichar_id(i+1) == unichar_O) &&
          (best_choice->unichar_id(i+2) == unichar_0 ||
           best_choice->unichar_id(i+2) == unichar_O)) {
        best_choice->set_unichar_id(unichar_0, i);
        best_choice->set_unichar_id(unichar_0, i+1);
        best_choice->set_unichar_id(unichar_0, i+2);
        modified = true;
        i += 2;
      }
      /* 9OO<non upper> */
      if (non_0_digit(best_choice->unichar_id(i-1)) &&
          (i+2) < best_choice->length() &&
          (best_choice->unichar_id(i+1) == unichar_0 ||
          best_choice->unichar_id(i+1) == unichar_O) &&
          !unicharset.get_isupper(best_choice->unichar_id(i+2))) {
        best_choice->set_unichar_id(unichar_0, i);
        best_choice->set_unichar_id(unichar_0, i+1);
        modified = true;
        i++;
      }
      /* 9O<non upper> */
      if (non_0_digit(best_choice->unichar_id(i-1)) &&
          (i+1) < best_choice->length() &&
          !unicharset.get_isupper(best_choice->unichar_id(i+1))) {
        best_choice->set_unichar_id(unichar_0, i);
      }
      /* 9[.,]OOO.. */
      if ((i > 1) &&
          (unicharset.eq(best_choice->unichar_id(i-1), ".") ||
           unicharset.eq(best_choice->unichar_id(i-1), ",")) &&
          (unicharset.get_isdigit(best_choice->unichar_id(i-2)) ||
           best_choice->unichar_id(i-2) == unichar_O)) {
        if (best_choice->unichar_id(i-2) == unichar_O) {
          best_choice->set_unichar_id(unichar_0, i-2);
          modified = true;
        }
        while (i < best_choice->length() &&
               (best_choice->unichar_id(i) == unichar_O ||
                best_choice->unichar_id(i) == unichar_0)) {
          best_choice->set_unichar_id(unichar_0, i);
          modified = true;
          i++;
        }
        i--;
      }
    }
  }
  if (modified) {
    best_choice->populate_unichars(unicharset);
  }
}

BOOL8 Tesseract::non_O_upper(UNICHAR_ID unichar_id) {
  return (unicharset.get_isupper(unichar_id) &&
          (!unicharset.eq(unichar_id, "O")));
}

BOOL8 Tesseract::non_0_digit(UNICHAR_ID unichar_id) {
  return (unicharset.get_isdigit(unichar_id) &&
          (!unicharset.eq(unichar_id, "0")));
}
/////////////////////////////////////////////////////////////////reject////////////////////////////////////////

/////////////////////////////////////////////////////////////////adaptions////////////////////////////////////////
inT32 demo_word = 0;

#define WINDOWNAMESIZE    13     /*max size of name */

#define EXTERN

EXTERN BOOL_VAR (tessedit_reject_ems, FALSE, "Reject all m's");
EXTERN BOOL_VAR (tessedit_reject_suspect_ems, FALSE, "Reject suspect m's");

EXTERN double_VAR (tessedit_cluster_t1, 0.20,
                   "t1 threshold for clustering samples");
EXTERN double_VAR (tessedit_cluster_t2, 0.40,
                   "t2 threshold for clustering samples");
EXTERN double_VAR (tessedit_cluster_t3, 0.12,
                   "Extra threshold for clustering samples, only keep a new sample if best score greater than this value");
EXTERN double_VAR (tessedit_cluster_accept_fraction, 0.80,
                   "Largest fraction of characters in cluster for it to be used for adaption");
EXTERN INT_VAR (tessedit_cluster_min_size, 3,
                "Smallest number of samples in a cluster for it to be used for adaption");
EXTERN BOOL_VAR (tessedit_cluster_debug, FALSE,
                 "Generate and print debug information for adaption by clustering");
EXTERN BOOL_VAR (tessedit_use_best_sample, FALSE,
                 "Use best sample from cluster when adapting");
EXTERN BOOL_VAR (tessedit_test_cluster_input, FALSE,
                 "Set reject map to enable cluster input to be measured");

EXTERN BOOL_VAR (tessedit_matrix_match, TRUE, "Use matrix matcher");
EXTERN BOOL_VAR (tessedit_mm_use_non_adaption_set, FALSE,
                 "Don't try to adapt to characters on this list");
EXTERN STRING_VAR (tessedit_non_adaption_set, ",.;:'~@*",
                   "Characters to be avoided when adapting");
EXTERN BOOL_VAR (tessedit_mm_adapt_using_prototypes, TRUE,
                 "Use prototypes when adapting");
EXTERN BOOL_VAR (tessedit_mm_use_prototypes, TRUE,
                 "Use prototypes as clusters are built");
EXTERN BOOL_VAR (tessedit_mm_use_rejmap, FALSE,
                 "Adapt to characters using reject map");
EXTERN BOOL_VAR (tessedit_mm_all_rejects, FALSE,
                 "Adapt to all characters using, matrix matcher");
EXTERN BOOL_VAR (tessedit_mm_only_match_same_char, FALSE,
                 "Only match samples against clusters for the same character");
EXTERN BOOL_VAR (tessedit_process_rns, FALSE, "Handle m - rn ambigs");

EXTERN BOOL_VAR (tessedit_demo_adaption, FALSE,
                 "Display cut images and matrix match for demo purposes");
EXTERN INT_VAR (tessedit_demo_word1, 62,
                "Word number of first word to display");
EXTERN INT_VAR (tessedit_demo_word2, 64,
                "Word number of second word to display");
EXTERN STRING_VAR (tessedit_demo_file, "academe",
                   "Name of document containing demo words");
EXTERN BOOL_VAR(tessedit_adapt_to_char_fragments, TRUE,
                "Adapt to words that contain "
                " a character composed form fragments");

//should we adapt?
BOOL8 Tesseract::word_adaptable(WERD_RES *word, uinT16 mode)
{
    if (tessedit_adaption_debug)
    {
        tprintf("Running word_adaptable() for %s rating %.4f certainty %.4f\n",
                word->best_choice == NULL ? "" : word->best_choice->unichar_string().string(), word->best_choice->rating(), word->best_choice->certainty());
    }

    BOOL8 status = FALSE;
    BITS16 flags(mode);

    enum MODES
    {
//        ADAPTABLE_WERD,
        aa = 1,
        ACCEPTABLE_WERD,
        CHECK_DAWGS,
        CHECK_SPACES,
        CHECK_ONE_ELL_CONFLICT,
        CHECK_AMBIG_WERD
    };

    /*
  0: NO adaption
  */
    if (mode == 0)
    {
        if (tessedit_adaption_debug) tprintf("adaption disabled\n");

        return FALSE;
    }

    if (flags.bit (ADAPTABLE_WERD))
    {
        status |= word->tess_would_adapt;  // result of Classify::AdaptableWord()
        if (tessedit_adaption_debug && !status)
        {
            tprintf("tess_would_adapt bit is false\n");
        }
    }

    if (flags.bit(ACCEPTABLE_WERD))
    {
        status |= word->tess_accepted;
        if (tessedit_adaption_debug && !status)
        {
            tprintf("tess_accepted bit is false\n");
        }
    }

    if (!status)
    {                  // If not set then
        return FALSE;                // ignore other checks
    }

    if (flags.bit (CHECK_DAWGS) && (word->best_choice->permuter () != SYSTEM_DAWG_PERM) && (word->best_choice->permuter () != FREQ_DAWG_PERM) &&
            (word->best_choice->permuter () != USER_DAWG_PERM) && (word->best_choice->permuter () != NUMBER_PERM))
    {
        if (tessedit_adaption_debug) tprintf("word not in dawgs\n");
        return FALSE;
    }

    if (flags.bit (CHECK_ONE_ELL_CONFLICT) && one_ell_conflict (word, FALSE))
    {
        if (tessedit_adaption_debug) tprintf("word has ell conflict\n");

        return FALSE;
    }

    if (flags.bit (CHECK_SPACES) && (strchr(word->best_choice->unichar_string().string(), ' ') != NULL))
    {
        if (tessedit_adaption_debug) tprintf("word contains spaces\n");

        return FALSE;
    }

    //  if (flags.bit (CHECK_AMBIG_WERD) && test_ambig_word (word))
    if (flags.bit (CHECK_AMBIG_WERD) && !getDict().NoDangerousAmbig(word->best_choice, NULL, false, NULL, NULL))
    {
        if (tessedit_adaption_debug) tprintf("word is ambiguous\n");
        return FALSE;
    }

    // Do not adapt to words that are composed from fragments if
    // tessedit_adapt_to_char_fragments is false.
    if (!tessedit_adapt_to_char_fragments)
    {
        const char *fragment_lengths = word->best_choice->fragment_lengths();

        if (fragment_lengths != NULL && *fragment_lengths != '\0')
        {
            for (int i = 0; i < word->best_choice->length(); ++i)
            {
                if (fragment_lengths[i] > 1)
                {
                    if (tessedit_adaption_debug) tprintf("won't adapt to fragments\n");

                    return false;  // found a character composed from fragments
                }
            }
        }
    }

    if (tessedit_adaption_debug)
    {
        tprintf("returning status %d\n", status);
    }

    return status;
}


void Tesseract::collect_ems_for_adaption(WERD_RES *word, CHAR_SAMPLES_LIST *char_clusters, CHAR_SAMPLE_LIST *chars_waiting)
{
    PBLOB_LIST *blobs = word->outword->blob_list ();

    PBLOB_IT blob_it(blobs);
    inT16 i;
    CHAR_SAMPLE *sample;
    PIXROW_LIST *pixrow_list;
    PIXROW_IT pixrow_it;
    IMAGELINE *imlines;            // lines of the image
    TBOX pix_box;                   // box of imlines

    // extent
    WERD copy_outword;             // copy to denorm
    PBLOB_IT copy_blob_it;
    OUTLINE_IT copy_outline_it;
    inT32 resolution = page_image.get_res ();

    if (tessedit_reject_ems || tessedit_reject_suspect_ems) return; // Do nothing

    if (word->word->bounding_box ().height () > resolution / 3) return;

    // Make sure not set
    if (tessedit_demo_adaption) tessedit_display_mm.set_value (FALSE);

    if (word_adaptable (word, tessedit_em_adaption_mode) && word->reject_map.reject_count () == 0 &&
            (strchr (word->best_choice->unichar_string().string (), 'm') != NULL ||
             (tessedit_process_rns && strstr (word->best_choice->unichar_string().string (), "rn") != NULL)))
    {
        if (tessedit_process_rns && strstr (word->best_choice->unichar_string().string (), "rn") != NULL)
        {
            copy_outword = *(word->outword);
            copy_blob_it.set_to_list (copy_outword.blob_list ());

            i = 0;
            while (word->best_choice->unichar_string()[i] != '\0')
            {
                if (word->best_choice->unichar_string()[i] == 'r' && word->best_choice->unichar_string()[i + 1] == 'n')
                {
                    copy_outline_it.set_to_list (copy_blob_it.data ()-> out_list ());
                    copy_outline_it.add_list_after (copy_blob_it.data_relative (1)->out_list ());
                    copy_blob_it.forward ();
                    delete (copy_blob_it.extract ());
                    i++;
                }

                copy_blob_it.forward ();
                i++;
            }
        }
        else
        {
            copy_outword = *(word->outword);
        }

        copy_outword.baseline_denormalise (&word->denorm);
        char_clip_word(&copy_outword, page_image, pixrow_list, imlines, pix_box);
        pixrow_it.set_to_list (pixrow_list);
        pixrow_it.move_to_first ();

        blob_it.move_to_first ();
        for (i = 0; word->best_choice->unichar_string()[i] != '\0'; i++, pixrow_it.forward (), blob_it.forward ())
        {

            if (word->best_choice->unichar_string()[i] == 'm' || (word->best_choice->unichar_string()[i] == 'r' && word->best_choice->unichar_string()[i + 1] == 'n'))
            {
#ifndef SECURE_NAMES
                if (tessedit_cluster_debug) tprintf ("Sample %c for adaption found in %s, index %d\n", word->best_choice->unichar_string()[i], word->best_choice->unichar_string().string (), i);
#endif
                if (tessedit_matrix_match)
                {
                    sample = clip_sample (pixrow_it.data (), imlines, pix_box, copy_outword.flag (W_INVERSE), word->best_choice->unichar_string()[i]);

                    if (sample == NULL)
                    {  //Clip failed
#ifndef SECURE_NAMES
                        tprintf ("Unable to clip sample from %s, index %d\n", word->best_choice->unichar_string().string (), i);
#endif
                        if (word->best_choice->unichar_string()[i] == 'r') i++;

                        continue;
                    }
                }
                else
                {
                    sample = new CHAR_SAMPLE(blob_it.data (), &word->denorm, word->best_choice->unichar_string()[i]);
                }

                cluster_sample(sample, char_clusters, chars_waiting);

                if (word->best_choice->unichar_string()[i] == 'r')  i++;                   // Skip next character
            }
        }

        delete[]imlines;             // Free array of imlines
        delete pixrow_list;
    }
}


void Tesseract::collect_characters_for_adaption(WERD_RES *word, CHAR_SAMPLES_LIST *char_clusters, CHAR_SAMPLE_LIST *chars_waiting)
{
    PBLOB_LIST *blobs = word->outword->blob_list ();
    PBLOB_IT blob_it(blobs);
    inT16 i;
    CHAR_SAMPLE *sample;
    PIXROW_LIST *pixrow_list;
    PIXROW_IT pixrow_it;
    IMAGELINE *imlines;            // lines of the image
    TBOX pix_box;                   // box of imlines

    // extent
    WERD copy_outword;             // copy to denorm
    inT32 resolution = page_image.get_res ();

    if (word->word->bounding_box ().height () > resolution / 3) return;

    // Make sure not set
    if (tessedit_demo_adaption)
    {
        if ((word_adaptable (word, tessedit_cluster_adaption_mode) && word->reject_map.reject_count () == 0) || tessedit_mm_use_rejmap)
        {
            if (tessedit_test_cluster_input && !tessedit_mm_use_rejmap) return;                    // Reject map set to acceptable

            /* Collect information about good matches */
            copy_outword = *(word->outword);
            copy_outword.baseline_denormalise (&word->denorm);
            char_clip_word(&copy_outword, page_image, pixrow_list, imlines, pix_box);
            pixrow_it.set_to_list (pixrow_list);
            pixrow_it.move_to_first ();

            blob_it.move_to_first ();
            for (i = 0; word->best_choice->unichar_string()[i] != '\0'; i++, pixrow_it.forward (), blob_it.forward ())
            {

                if (!(tessedit_mm_use_non_adaption_set && STRING(tessedit_non_adaption_set).contains( word->best_choice->unichar_string()[i])) ||
                        (tessedit_mm_use_rejmap && word->reject_map[i].accepted ()))
                {
#ifndef SECURE_NAMES
                    if (tessedit_cluster_debug)
                        tprintf ("Sample %c for adaption found in %s, index %d\n",
                                 word->best_choice->unichar_string()[i],
                                 word->best_choice->unichar_string().string (), i);
#endif
                    sample = clip_sample (pixrow_it.data (), imlines, pix_box, copy_outword.flag (W_INVERSE), word->best_choice->unichar_string()[i]);

                    if (sample == NULL)
                    {    //Clip failed
#ifndef SECURE_NAMES
                        tprintf ("Unable to clip sample from %s, index %d\n", word->best_choice->unichar_string().string (), i);
#endif
                        continue;
                    }
                    cluster_sample(sample, char_clusters, chars_waiting);
                }
            }

            delete[]imlines;             // Free array of imlines
            delete pixrow_list;
        }
        else if (tessedit_test_cluster_input && !tessedit_mm_use_rejmap)
        {
            // Set word to all rejects
            word->reject_map.rej_word_tess_failure ();
        }
    }
}


void Tesseract::cluster_sample(CHAR_SAMPLE *sample, CHAR_SAMPLES_LIST *char_clusters, CHAR_SAMPLE_LIST *chars_waiting)
{
    CHAR_SAMPLES *best_cluster = NULL;
    CHAR_SAMPLES_IT c_it = char_clusters;
    CHAR_SAMPLE_IT cw_it = chars_waiting;
    float score;
    float best_score = MAX_INT32;

    if (c_it.empty ())
    {
        c_it.add_to_end (new CHAR_SAMPLES (sample));
    }
    else
    {
        for (c_it.mark_cycle_pt (); !c_it.cycled_list (); c_it.forward ())
        {
            score = c_it.data ()->match_score (sample, this);
            if (score < best_score)
            {
                best_score = score;
                best_cluster = c_it.data ();
            }
        }

        if (tessedit_cluster_debug) tprintf ("Sample's best score %f\n", best_score);

        if (best_score < tessedit_cluster_t1)
        {
            if (best_score > tessedit_cluster_t3 || tessedit_mm_use_prototypes)
            {
                best_cluster->add_sample (sample, this);
                check_wait_list(chars_waiting, sample, best_cluster);
#ifndef SECURE_NAMES
                if (tessedit_cluster_debug) tprintf ("Sample added to an existing cluster\n");
#endif
            }
            else
            {
#ifndef SECURE_NAMES
                if (tessedit_cluster_debug) tprintf("Sample dropped, good match to an existing cluster\n");
#endif
            }
        }
        else if (best_score > tessedit_cluster_t2)
        {
            c_it.add_to_end (new CHAR_SAMPLES (sample));
#ifndef SECURE_NAMES
            if (tessedit_cluster_debug)
                tprintf ("New cluster created for this sample\n");
#endif
        }
        else
        {
            cw_it.add_to_end (sample);
            if (tessedit_cluster_debug) tprintf ("Sample added to the wait list\n");
        }
    }
}

void Tesseract::check_wait_list(CHAR_SAMPLE_LIST *chars_waiting, CHAR_SAMPLE *sample, CHAR_SAMPLES *best_cluster)
{
    CHAR_SAMPLE *wait_sample;
    CHAR_SAMPLE *test_sample = sample;
    CHAR_SAMPLE_IT cw_it = chars_waiting;
    CHAR_SAMPLE_LIST add_list;     //Samples added to best cluster
    CHAR_SAMPLE_IT add_it = &add_list;
    float score;

    add_list.clear ();

    if (!cw_it.empty ())
    {
        do
        {
            if (!add_list.empty ())
            {
                add_it.forward ();
                test_sample = add_it.extract ();
                best_cluster->add_sample (test_sample, this);
            }

            for (cw_it.mark_cycle_pt ();
                 !cw_it.cycled_list (); cw_it.forward ())
            {
                wait_sample = cw_it.data ();
                if (tessedit_mm_use_prototypes)
                {
                    score = best_cluster->match_score (wait_sample, this);
                }
                else
                {
                    score = sample->match_sample (wait_sample, FALSE, this);
                }

                if (score < tessedit_cluster_t1)
                {
                    if (score > tessedit_cluster_t3 || tessedit_mm_use_prototypes)
                    {
                        add_it.add_after_stay_put (cw_it.extract ());
#ifndef SECURE_NAMES
                        if (tessedit_cluster_debug) tprintf ("Wait sample added to an existing cluster\n");
#endif
                    }
                    else
                    {
#ifndef SECURE_NAMES
                        if (tessedit_cluster_debug) tprintf ("Wait sample dropped, good match to an existing cluster\n");
#endif
                    }
                }
            }
        }
        while (!add_list.empty ());
    }
}


void Tesseract::complete_clustering(CHAR_SAMPLES_LIST *char_clusters, CHAR_SAMPLE_LIST *chars_waiting)
{
    CHAR_SAMPLES *best_cluster;
    CHAR_SAMPLES_IT c_it = char_clusters;
    CHAR_SAMPLE_IT cw_it = chars_waiting;
    CHAR_SAMPLE *sample;
    inT32 total_sample_count = 0;

    while (!cw_it.empty ())
    {
        cw_it.move_to_first ();
        sample = cw_it.extract ();
        best_cluster = new CHAR_SAMPLES (sample);
        c_it.add_to_end (best_cluster);
        check_wait_list(chars_waiting, sample, best_cluster);
    }

    for (c_it.mark_cycle_pt (); !c_it.cycled_list (); c_it.forward ())
    {
        c_it.data ()->assign_to_char ();
        if (tessedit_use_best_sample)
        {
            c_it.data ()->find_best_sample ();
        }
        else if (tessedit_mm_adapt_using_prototypes)
        {
            c_it.data ()->build_prototype ();
        }

        if (tessedit_cluster_debug) total_sample_count += c_it.data ()->n_samples ();
    }
#ifndef SECURE_NAMES
    if (tessedit_cluster_debug) tprintf ("Clustering completed, %d samples in all\n", total_sample_count);
#endif

#ifndef GRAPHICS_DISABLED
    if (tessedit_demo_adaption)
        display_cluster_prototypes(char_clusters);
#endif
}

void Tesseract::adapt_to_good_ems(WERD_RES *word, CHAR_SAMPLES_LIST *char_clusters, CHAR_SAMPLE_LIST *chars_waiting)
{
    PBLOB_LIST *blobs = word->outword->blob_list ();
    PBLOB_IT blob_it(blobs);
    inT16 i;
    CHAR_SAMPLE *sample;
    CHAR_SAMPLES_IT c_it = char_clusters;
    CHAR_SAMPLE_IT cw_it = chars_waiting;
    float score;
    float best_score;
    char best_char;
    CHAR_SAMPLES *best_cluster;
    PIXROW_LIST *pixrow_list;
    PIXROW_IT pixrow_it;
    IMAGELINE *imlines;            // lines of the image
    TBOX pix_box;                   // box of imlines

    // extent
    WERD copy_outword;             // copy to denorm
    TBOX b_box;
    PBLOB_IT copy_blob_it;
    OUTLINE_IT copy_outline_it;

    static inT32 word_number = 0;

    inT32 resolution = page_image.get_res ();

    if (word->word->bounding_box ().height () > resolution / 3) return;
    word_number++;

    if (strchr (word->best_choice->unichar_string().string (), 'm') == NULL &&
            (tessedit_process_rns && strstr (word->best_choice->unichar_string().string (), "rn") == NULL)) return;

    if (tessedit_reject_ems)
    {
        reject_all_ems(word);
    }
    else if (tessedit_reject_suspect_ems)
    {
        reject_suspect_ems(word);
    }
    else
    {
        if (char_clusters->length () == 0)
        {
#ifndef SECURE_NAMES
            if (tessedit_cluster_debug) tprintf ("No clusters to use for em adaption\n");
#endif
            return;
        }

        if (!cw_it.empty ())
        {
            complete_clustering(char_clusters, chars_waiting);
            print_em_stats(char_clusters, chars_waiting);
        }

        if ((!word_adaptable(word, tessedit_em_adaption_mode) || word->reject_map.reject_count () != 0) &&
                (strchr (word->best_choice->unichar_string().string (), 'm') != NULL ||
                 (tessedit_process_rns && strstr (word->best_choice->unichar_string().string (), "rn") != NULL)))
        {
            if (tessedit_process_rns && strstr (word->best_choice->unichar_string().string (), "rn") != NULL)
            {
                copy_outword = *(word->outword);
                copy_blob_it.set_to_list (copy_outword.blob_list ());

                i = 0;
                while (word->best_choice->unichar_string()[i] != '\0')
                {
                    if (word->best_choice->unichar_string()[i] == 'r' && word->best_choice->unichar_string()[i + 1] == 'n')
                    {
                        copy_outline_it.set_to_list (copy_blob_it.data ()->out_list ());
                        copy_outline_it.add_list_after (copy_blob_it.data_relative (1)->out_list ());
                        copy_blob_it.forward ();
                        delete (copy_blob_it.extract ());
                        i++;
                    }
                    copy_blob_it.forward ();
                    i++;
                }
            }
            else
            {
                copy_outword = *(word->outword);
            }

            copy_outword.baseline_denormalise (&word->denorm);
            copy_blob_it.set_to_list (copy_outword.blob_list ());
            char_clip_word(&copy_outword, page_image, pixrow_list, imlines, pix_box);
            pixrow_it.set_to_list (pixrow_list);
            pixrow_it.move_to_first ();

            // For debugging only
            b_box = copy_outword.bounding_box ();

            blob_it.move_to_first ();
            copy_blob_it.move_to_first ();

            for (i = 0; word->best_choice->unichar_string()[i] != '\0'; i++, pixrow_it.forward (), blob_it.forward (), copy_blob_it.forward ())
            {
                if ((word->best_choice->unichar_string()[i] == 'm' ||
                     (word->best_choice->unichar_string()[i] == 'r' && word->best_choice->unichar_string()[i + 1] == 'n')) &&
                        !word->reject_map[i].perm_rejected ())
                {
                    if (tessedit_cluster_debug) tprintf ("Sample %c to check found in %s, index %d\n",  word->best_choice->unichar_string()[i],  word->best_choice->unichar_string().string (), i);

                    if (tessedit_demo_adaption) tprintf("Sample %c to check found in %s (%d), index %d\n",
                                                        word->best_choice->unichar_string()[i], word->best_choice->unichar_string().string (), word_number, i);

                    if (tessedit_matrix_match)
                    {
                        TBOX copy_box = copy_blob_it.data ()->bounding_box ();

                        sample = clip_sample (pixrow_it.data (), imlines, pix_box, copy_outword.flag (W_INVERSE), word->best_choice->unichar_string()[i]);

                        //Clip failed
                        if (sample == NULL)
                        {
                            tprintf("Unable to clip sample from %s, index %d\n", word->best_choice->unichar_string().string (), i);
#ifndef SECURE_NAMES
                            if (tessedit_cluster_debug) tprintf ("Sample rejected (no sample)\n");
#endif
                            word->reject_map[i].setrej_mm_reject ();
                            if (word->best_choice->unichar_string()[i] == 'r')
                            {
                                word->reject_map[i + 1].setrej_mm_reject ();
                                i++;
                            }

                            continue;
                        }
                    }
                    else
                    {
                        sample = new CHAR_SAMPLE(blob_it.data(), &word->denorm, word->best_choice->unichar_string()[i]);
                    }

                    best_score = MAX_INT32;
                    best_char = '\0';
                    best_cluster = NULL;

                    for (c_it.mark_cycle_pt (); !c_it.cycled_list (); c_it.forward ())
                    {
                        if (c_it.data ()->character () != '\0')
                        {
                            score = c_it.data ()->match_score (sample, this);

                            if (score < best_score)
                            {
                                best_cluster = c_it.data ();
                                best_score = score;
                                best_char = c_it.data ()->character ();
                            }
                        }
                    }

                    if (best_score > tessedit_cluster_t1)
                    {
#ifndef SECURE_NAMES
                        if (tessedit_cluster_debug) tprintf ("Sample rejected (score %f)\n", best_score);
                        if (tessedit_demo_adaption) tprintf ("Sample rejected (score %f)\n", best_score);
#endif
                        word->reject_map[i].setrej_mm_reject ();
                        if (word->best_choice->unichar_string()[i] == 'r') word->reject_map[i + 1].setrej_mm_reject ();
                    }
                    else
                    {
                        if (word->best_choice->unichar_string()[i] == best_char)
                        {
#ifndef SECURE_NAMES
                            if (tessedit_cluster_debug) tprintf ("Sample accepted (score %f)\n", best_score);
                            if (tessedit_demo_adaption) tprintf ("Sample accepted (score %f)\n", best_score);
#endif
                            word->reject_map[i].setrej_mm_accept ();
                            if (word->best_choice->unichar_string()[i] == 'r') word->reject_map[i + 1].setrej_mm_accept ();
                        }
                        else
                        {
#ifndef SECURE_NAMES
                            if (tessedit_cluster_debug) tprintf ("Sample rejected (char %c, score %f)\n", best_char, best_score);
                            if (tessedit_demo_adaption) tprintf ("Sample rejected (char %c, score %f)\n", best_char, best_score);
#endif
                            word->reject_map[i].setrej_mm_reject ();
                            if (word->best_choice->unichar_string()[i] == 'r') word->reject_map[i + 1].setrej_mm_reject ();
                        }
                    }

                    if (tessedit_demo_adaption)
                    {
                        if (strcmp (imagebasename.string (), tessedit_demo_file.string ()) != 0 || word_number == tessedit_demo_word1 || word_number == tessedit_demo_word2)
                        {
                            #ifndef GRAPHICS_DISABLED
                            display_clip_image(&copy_outword, page_image, pixrow_list, pix_box);
                            #endif
                            demo_word = word_number;
                            best_cluster->match_score (sample, this);
                            demo_word = 0;
                        }
                    }
                    if (word->best_choice->unichar_string()[i] == 'r') i++;                 // Skip next character
                }
            }

            delete[]imlines;           // Free array of imlines
            delete pixrow_list;
        }
    }
}



void Tesseract::adapt_to_good_samples(WERD_RES *word, CHAR_SAMPLES_LIST *char_clusters, CHAR_SAMPLE_LIST *chars_waiting)
{
    PBLOB_LIST *blobs = word->outword->blob_list ();
    PBLOB_IT blob_it(blobs);
    inT16 i;
    CHAR_SAMPLE *sample;
    CHAR_SAMPLES_IT c_it = char_clusters;
    CHAR_SAMPLE_IT cw_it = chars_waiting;
    float score;
    float best_score;
    char best_char;
    CHAR_SAMPLES *best_cluster;
    PIXROW_LIST *pixrow_list;
    PIXROW_IT pixrow_it;
    IMAGELINE *imlines;            // lines of the image
    TBOX pix_box;                   // box of imlines

    // extent
    WERD copy_outword;             // copy to denorm
    TBOX b_box;
    PBLOB_IT copy_blob_it;

    static inT32 word_number = 0;

    inT32 resolution = page_image.get_res ();
    word_number++;

    if (tessedit_test_cluster_input) return;

    if (word->word->bounding_box ().height () > resolution / 3) return;

    if (char_clusters->length () == 0)
    {
#ifndef SECURE_NAMES
        if (tessedit_cluster_debug)
            tprintf ("No clusters to use for adaption\n");
#endif
        return;
    }

    if (!cw_it.empty ())
    {
        complete_clustering(char_clusters, chars_waiting);
        print_em_stats(char_clusters, chars_waiting);
    }

    if ((!word_adaptable (word, tessedit_cluster_adaption_mode) && word->reject_map.reject_count () != 0) || tessedit_mm_use_rejmap)
    {
        if (tessedit_cluster_debug)
        {
            tprintf ("\nChecking: \"%s\"  MAP ", word->best_choice->unichar_string().string ()); word->reject_map.print (debug_fp); tprintf ("\n");
        }

        copy_outword = *(word->outword);
        copy_outword.baseline_denormalise (&word->denorm);
        copy_blob_it.set_to_list (copy_outword.blob_list ());
        char_clip_word(&copy_outword, page_image, pixrow_list, imlines, pix_box);
        pixrow_it.set_to_list (pixrow_list);
        pixrow_it.move_to_first ();

        b_box = copy_outword.bounding_box ();
        blob_it.move_to_first ();
        copy_blob_it.move_to_first ();

        for (i = 0; word->best_choice->unichar_string()[i] != '\0'; i++, pixrow_it.forward (), blob_it.forward (), copy_blob_it.forward ())
        {
            if (word->reject_map[i].recoverable () || (tessedit_mm_all_rejects && word->reject_map[i].rejected ()))
            {
                TBOX copy_box = copy_blob_it.data ()->bounding_box ();

                if (tessedit_cluster_debug)
                {
                    tprintf ("Sample %c to check found in %s, index %d\n", word->best_choice->unichar_string()[i], word->best_choice->unichar_string().string (), i);
                }

                if (tessedit_demo_adaption)
                {
                    tprintf ("Sample %c to check found in %s (%d), index %d\n", word->best_choice->unichar_string()[i], word->best_choice->unichar_string().string (), word_number, i);
                }

                sample = clip_sample (pixrow_it.data (), imlines, pix_box, copy_outword.flag (W_INVERSE), word->best_choice->unichar_string()[i]);

                if (sample == NULL)
                {    //Clip failed
                    tprintf ("Unable to clip sample from %s, index %d\n", word->best_choice->unichar_string().string (), i);
#ifndef SECURE_NAMES
                    if (tessedit_cluster_debug) tprintf ("Sample rejected (no sample)\n");
#endif
                    word->reject_map[i].setrej_mm_reject ();
                    continue;
                }

                best_score = MAX_INT32;
                best_char = '\0';
                best_cluster = NULL;

                for (c_it.mark_cycle_pt (); !c_it.cycled_list (); c_it.forward ())
                {
                    if (c_it.data ()->character () != '\0')
                    {
                        score = c_it.data ()->match_score (sample, this);
                        if (score < best_score)
                        {
                            best_cluster = c_it.data ();
                            best_score = score;
                            best_char = c_it.data ()->character ();
                        }
                    }
                }

                if (best_score > tessedit_cluster_t1)
                {
#ifndef SECURE_NAMES
                    if (tessedit_cluster_debug) tprintf ("Sample rejected (score %f)\n", best_score);
                    if (tessedit_demo_adaption) tprintf ("Sample rejected (score %f)\n", best_score);
#endif
                    word->reject_map[i].setrej_mm_reject ();
                }
                else
                {
                    if (word->best_choice->unichar_string()[i] == best_char)
                    {
#ifndef SECURE_NAMES
                        if (tessedit_cluster_debug) tprintf ("Sample accepted (score %f)\n", best_score);
                        if (tessedit_demo_adaption) tprintf ("Sample accepted (score %f)\n", best_score);
#endif
                        if (tessedit_test_adaption)
                        {
                            word->reject_map[i].setrej_minimal_rej_accept ();
                        }
                        else
                        {
                            word->reject_map[i].setrej_mm_accept ();
                        }
                    }
                    else
                    {
#ifndef SECURE_NAMES
                        if (tessedit_cluster_debug) tprintf ("Sample rejected (char %c, score %f)\n", best_char, best_score);
                        if (tessedit_demo_adaption) tprintf ("Sample rejected (char %c, score %f)\n", best_char, best_score);
#endif
                        word->reject_map[i].setrej_mm_reject ();
                    }
                }

                if (tessedit_demo_adaption)
                {
                    if (strcmp (imagebasename.string (), tessedit_demo_file.string ()) != 0 || word_number == tessedit_demo_word1 || word_number == tessedit_demo_word2)
                    {
                        #ifndef GRAPHICS_DISABLED
                        display_clip_image(&copy_outword, page_image, pixrow_list, pix_box);
                        #endif
                        demo_word = word_number;
                        best_cluster->match_score (sample, this);
                        demo_word = 0;
                    }
                }
            }
        }
        delete[]imlines;             // Free array of imlines
        delete pixrow_list;

        if (tessedit_cluster_debug)
        {
            tprintf ("\nFinal: \"%s\"  MAP ", word->best_choice->unichar_string().string ()); word->reject_map.print (debug_fp); tprintf ("\n");
        }
    }
}

void print_em_stats(CHAR_SAMPLES_LIST *char_clusters,  CHAR_SAMPLE_LIST *chars_waiting)
{
    CHAR_SAMPLES_IT c_it = char_clusters;

    if (!tessedit_cluster_debug) return;
#ifndef SECURE_NAMES
    tprintf ("There are %d clusters and %d samples waiting\n", char_clusters->length (), chars_waiting->length ());

    for (c_it.mark_cycle_pt (); !c_it.cycled_list (); c_it.forward ()) c_it.data ()->print (debug_fp);
#endif
    tprintf ("\n");
}


CHAR_SAMPLE *clip_sample(PIXROW *pixrow, IMAGELINE *imlines, TBOX pix_box, BOOL8 white_on_black, char c)
{
    TBOX b_box = pixrow->bounding_box ();
    float baseline_pos = 0;
    inT32 resolution = page_image.get_res ();

    if (!b_box.null_box ())
    {
        ASSERT_HOST (b_box.width () < page_image.get_xsize () && b_box.height () < page_image.get_ysize ());

        if (b_box.width () > resolution || b_box.height () > resolution)
        {
            tprintf ("clip sample: sample too big (%d x %d)\n", b_box.width (), b_box.height ());
            return NULL;
        }

        IMAGE *image = new (IMAGE);
        if (image->create (b_box.width (), b_box.height (), 1) == -1)
        {
            tprintf ("clip sample: create image failed (%d x %d)\n", b_box.width (), b_box.height ());

            delete image;
            return NULL;
        }

        if (!white_on_black) invert_image(image);  // Set background to white
        pixrow->char_clip_image (imlines, pix_box, NULL, *image, baseline_pos);

        if (white_on_black) invert_image(image);  //invert white on black for scaling &NN
        return new CHAR_SAMPLE (image, c);
    }
    else
    {
        return NULL;
    }
}


#ifndef GRAPHICS_DISABLED
void display_cluster_prototypes(CHAR_SAMPLES_LIST *char_clusters)
{
    inT16 proto_number = 0;
    CHAR_SAMPLES_IT c_it = char_clusters;
    char title[WINDOWNAMESIZE];

    for (c_it.mark_cycle_pt (); !c_it.cycled_list (); c_it.forward ())
    {
        proto_number++;

#ifndef SECURE_NAMES
        tprintf ("Displaying proto number %d\n", proto_number);
#endif

        if (c_it.data ()->prototype () != NULL)
        {
            sprintf (title, "Proto - %d", proto_number);
            display_image(c_it.data ()->prototype ()->make_image (), title, (proto_number - 1) * 400, 0, FALSE);
        }
    }
}
#endif

// *********************************************************************
// Simplistic routines to test the effect of rejecting ems and fullstops
// *********************************************************************

void reject_all_ems(WERD_RES *word)
{
    inT16 i;

    for (i = 0; word->best_choice->unichar_string()[i] != '\0'; i++)
    {
        if (word->best_choice->unichar_string()[i] == 'm')
        {
            word->reject_map[i].setrej_mm_reject (); // reject all ems
        }
    }
}


void reject_all_fullstops(WERD_RES *word)
{
    inT16 i;

    for (i = 0; word->best_choice->unichar_string()[i] != '\0'; i++)
    {
        if (word->best_choice->unichar_string()[i] == '.')
        {
            word->reject_map[i].setrej_mm_reject ();// reject all fullstops
        }
    }
}

void Tesseract::reject_suspect_ems(WERD_RES *word)
{
    inT16 i;

    if (!word_adaptable (word, tessedit_cluster_adaption_mode))
    {
        for (i = 0; word->best_choice->unichar_string()[i] != '\0'; i++)
        {
            if (word->best_choice->unichar_string()[i] == 'm' && suspect_em (word, i))
            {
                word->reject_map[i].setrej_mm_reject ();// reject all ems
            }
        }
    }
}


void reject_suspect_fullstops(WERD_RES *word)
{
    inT16 i;

    for (i = 0; word->best_choice->unichar_string()[i] != '\0'; i++)
    {
        if (word->best_choice->unichar_string()[i] == '.' && suspect_fullstop (word, i))
        {
            word->reject_map[i].setrej_mm_reject ();// reject all commas
        }
    }
}


BOOL8 suspect_em(WERD_RES *word, inT16 index)
{
    PBLOB_LIST *blobs = word->outword->blob_list ();
    PBLOB_IT blob_it(blobs);
    inT16 j;

    for (j = 0; j < index; j++) blob_it.forward ();

    return (blob_it.data ()->out_list ()->length () != 1);
}


BOOL8 suspect_fullstop(WERD_RES *word, inT16 i)
{
    float aspect_ratio;
    PBLOB_LIST *blobs = word->outword->blob_list ();
    PBLOB_IT blob_it(blobs);
    inT16 j;
    TBOX box;
    inT16 width;
    inT16 height;

    for (j = 0; j < i; j++) blob_it.forward ();
    box = blob_it.data ()->bounding_box ();

    width = box.width ();
    height = box.height ();

    aspect_ratio = ((width > height) ? ((float) width) / height :
                                       ((float) height) / width);

    return (aspect_ratio > tessed_fullstop_aspect_ratio);
}
/////////////////////////////////////////////////////////////////adaptions////////////////////////////////////////

/////////////////////////////////////////////////////////////////matmatch////////////////////////////////////////
#define EXTERN
EXTERN BOOL_VAR (tessedit_display_mm, FALSE, "Display matrix matches");
EXTERN BOOL_VAR (tessedit_mm_debug, FALSE,
"Print debug information for matrix matcher");
EXTERN INT_VAR (tessedit_mm_prototype_min_size, 3,
"Smallest number of samples in a cluster for a prototype to be used");

// Colours for displaying the match
#define BB_COLOUR 0
#define BW_COLOUR 1
#define WB_COLOUR 3
#define UB_COLOUR 5
#define BU_COLOUR 7
#define UU_COLOUR 9
#define WU_COLOUR 11
#define UW_COLOUR 13
#define WW_COLOUR 15

#define BINIM_BLACK 0
#define BINIM_WHITE 1

float matrix_match(  // returns match score
                   IMAGE *image1,
                   IMAGE *image2) {
  ASSERT_HOST (image1->get_bpp () == 1 && image2->get_bpp () == 1);

  if (image1->get_xsize () >= image2->get_xsize ())
    return match1 (image1, image2);
  else
    return match1 (image2, image1);
}


float match1(  /* returns match score */
             IMAGE *image_w,
             IMAGE *image_n) {
  inT32 x_offset;
  inT32 y_offset;
  inT32 x_size = image_w->get_xsize ();
  inT32 y_size;
  inT32 x_size2 = image_n->get_xsize ();
  inT32 y_size2;
  IMAGE match_image;
  IMAGELINE imline_w;
  IMAGELINE imline_n;
  IMAGELINE match_imline;
  inT32 x;
  inT32 y;
  float sum = 0.0;

  x_offset = (image_w->get_xsize () - image_n->get_xsize ()) / 2;

  ASSERT_HOST (x_offset >= 0);
  match_imline.init (x_size);

  sum = 0;

  if (image_w->get_ysize () < image_n->get_ysize ()) {
    y_size = image_n->get_ysize ();
    y_size2 = image_w->get_ysize ();
    y_offset = (y_size - y_size2) / 2;

    if (tessedit_display_mm && !tessedit_mm_use_prototypes)
      tprintf ("I1 (%d, %d), I2 (%d, %d), MI (%d, %d)\n", x_size,
        image_w->get_ysize (), x_size2, image_n->get_ysize (),
        x_size, y_size);

    match_image.create (x_size, y_size, 4);

    for (y = 0; y < y_offset; y++) {
      image_n->fast_get_line (0, y, x_size2, &imline_n);
      for (x = 0; x < x_size2; x++) {
        if (imline_n.pixels[x] == BINIM_BLACK) {
          sum += -1;
          match_imline.pixels[x] = UB_COLOUR;
        }
        else {
          match_imline.pixels[x] = UW_COLOUR;
        }
      }
      match_image.fast_put_line (x_offset, y, x_size2, &match_imline);
    }

    for (y = y_offset + y_size2; y < y_size; y++) {
      image_n->fast_get_line (0, y, x_size2, &imline_n);
      for (x = 0; x < x_size2; x++) {
        if (imline_n.pixels[x] == BINIM_BLACK) {
          sum += -1.0;
          match_imline.pixels[x] = UB_COLOUR;
        }
        else {
          match_imline.pixels[x] = UW_COLOUR;
        }
      }
      match_image.fast_put_line (x_offset, y, x_size2, &match_imline);
    }

    for (y = y_offset; y < y_offset + y_size2; y++) {
      image_w->fast_get_line (0, y - y_offset, x_size, &imline_w);
      image_n->fast_get_line (0, y, x_size2, &imline_n);
      for (x = 0; x < x_offset; x++) {
        if (imline_w.pixels[x] == BINIM_BLACK) {
          sum += -1.0;
          match_imline.pixels[x] = BU_COLOUR;
        }
        else {
          match_imline.pixels[x] = WU_COLOUR;
        }
      }

      for (x = x_offset + x_size2; x < x_size; x++) {
        if (imline_w.pixels[x] == BINIM_BLACK) {
          sum += -1.0;
          match_imline.pixels[x] = BU_COLOUR;
        }
        else {
          match_imline.pixels[x] = WU_COLOUR;
        }
      }

      for (x = x_offset; x < x_offset + x_size2; x++) {
        if (imline_n.pixels[x - x_offset] == imline_w.pixels[x]) {
          sum += 1.0;
          if (imline_w.pixels[x] == BINIM_BLACK)
            match_imline.pixels[x] = BB_COLOUR;
          else
            match_imline.pixels[x] = WW_COLOUR;
        }
        else {
          sum += -1.0;
          if (imline_w.pixels[x] == BINIM_BLACK)
            match_imline.pixels[x] = BW_COLOUR;
          else
            match_imline.pixels[x] = WB_COLOUR;
        }
      }

      match_image.fast_put_line (0, y, x_size, &match_imline);
    }
  }
  else {
    y_size = image_w->get_ysize ();
    y_size2 = image_n->get_ysize ();
    y_offset = (y_size - y_size2) / 2;

    if (tessedit_display_mm && !tessedit_mm_use_prototypes)
      tprintf ("I1 (%d, %d), I2 (%d, %d), MI (%d, %d)\n", x_size,
        image_w->get_ysize (), x_size2, image_n->get_ysize (),
        x_size, y_size);

    match_image.create (x_size, y_size, 4);

    for (y = 0; y < y_offset; y++) {
      image_w->fast_get_line (0, y, x_size, &imline_w);
      for (x = 0; x < x_size; x++) {
        if (imline_w.pixels[x] == BINIM_BLACK) {
          sum += -1;
          match_imline.pixels[x] = BU_COLOUR;
        }
        else {
          match_imline.pixels[x] = WU_COLOUR;
        }
      }
      match_image.fast_put_line (0, y, x_size, &match_imline);
    }

    for (y = y_offset + y_size2; y < y_size; y++) {
      image_w->fast_get_line (0, y, x_size, &imline_w);
      for (x = 0; x < x_size; x++) {
        if (imline_w.pixels[x] == BINIM_BLACK) {
          sum += -1;
          match_imline.pixels[x] = BU_COLOUR;
        }
        else {
          match_imline.pixels[x] = WU_COLOUR;
        }
      }
      match_image.fast_put_line (0, y, x_size, &match_imline);
    }

    for (y = y_offset; y < y_offset + y_size2; y++) {
      image_w->fast_get_line (0, y, x_size, &imline_w);
      image_n->fast_get_line (0, y - y_offset, x_size2, &imline_n);
      for (x = 0; x < x_offset; x++) {
        if (imline_w.pixels[x] == BINIM_BLACK) {
          sum += -1.0;
          match_imline.pixels[x] = BU_COLOUR;
        }
        else {
          match_imline.pixels[x] = WU_COLOUR;
        }
      }

      for (x = x_offset + x_size2; x < x_size; x++) {
        if (imline_w.pixels[x] == BINIM_BLACK) {
          sum += -1.0;
          match_imline.pixels[x] = BU_COLOUR;
        }
        else {
          match_imline.pixels[x] = WU_COLOUR;
        }
      }

      for (x = x_offset; x < x_offset + x_size2; x++) {
        if (imline_n.pixels[x - x_offset] == imline_w.pixels[x]) {
          sum += 1.0;
          if (imline_w.pixels[x] == BINIM_BLACK)
            match_imline.pixels[x] = BB_COLOUR;
          else
            match_imline.pixels[x] = WW_COLOUR;
        }
        else {
          sum += -1.0;
          if (imline_w.pixels[x] == BINIM_BLACK)
            match_imline.pixels[x] = BW_COLOUR;
          else
            match_imline.pixels[x] = WB_COLOUR;
        }
      }

      match_image.fast_put_line (0, y, x_size, &match_imline);
    }
  }

#ifndef GRAPHICS_DISABLED
  if (tessedit_display_mm && !tessedit_mm_use_prototypes) {
    tprintf ("Match score %f\n", 1.0 - sum / (x_size * y_size));
    display_images(image_w, image_n, &match_image);
  }
#endif

  if (tessedit_mm_debug)
    tprintf ("Match score %f\n", 1.0 - sum / (x_size * y_size));

  return (1.0 - sum / (x_size * y_size));
}


/*************************************************************************
 * display_images()
 *
 * Show a pair of images, plus the match image
 *
 *************************************************************************/
#ifndef GRAPHICS_DISABLED
void display_images(IMAGE *image_w, IMAGE *image_n, IMAGE *match_image) {
  ScrollView* w_im_window;
  ScrollView* n_im_window;
  ScrollView* match_window;
  inT16 i;

  w_im_window = new ScrollView("Image 1", 20, 100,
      10 * image_w->get_xsize (), 10 * image_w->get_ysize (),
      image_w->get_xsize (), image_w->get_ysize ());

  sv_show_sub_image(image_w, 0, 0, image_w->get_xsize (), image_w->get_ysize (), w_im_window, 0, 0);

  w_im_window->Pen(255,0,0);
  for (i = 1; i < image_w->get_xsize (); i++) {
     w_im_window->Line(i, 0, i, image_w->get_ysize ());
  }
  for (i = 1; i < image_w->get_ysize (); i++) {
    w_im_window->Line(0, i, image_w->get_xsize (), i);
  }

  n_im_window = new ScrollView ("Image 2", 240, 100,
      10 * image_n->get_xsize (), 10 * image_n->get_ysize (),
      image_n->get_xsize (), image_n->get_ysize ());

  sv_show_sub_image (image_n,
    0, 0,
    image_n->get_xsize (), image_n->get_ysize (),
    n_im_window, 0, 0);

  n_im_window->Pen(255,0,0);
  for (i = 1; i < image_n->get_xsize (); i++) {
     n_im_window->Line(i, 0, i, image_n->get_ysize ());
  }
  for (i = 1; i < image_n->get_ysize (); i++) {
    n_im_window->Line(0, i, image_n->get_xsize (), i);
  }

  match_window = new ScrollView ("Match Result", 460, 100,
       10 * match_image->get_xsize (), 10 * match_image->get_ysize (),
       match_image->get_xsize (), match_image->get_ysize ());

  match_window->Clear();
  sv_show_sub_image (match_image,
    0, 0,
    match_image->get_xsize (), match_image->get_ysize (),
    match_window, 0, 0);

  match_window->Pen(255,0,0);
  for (i = 1; i < match_image->get_xsize (); i++) {
     match_window->Line(i, 0, i, match_image->get_ysize ());
  }
  for (i = 1; i < match_image->get_ysize (); i++) {
     match_window->Line(0, i, match_image->get_xsize (), i);
  }
  SVEvent* sve = match_window->AwaitEvent(SVET_DESTROY);
  delete sve;

  delete w_im_window;
  delete n_im_window;
  delete match_window;
}


/*************************************************************************
 * display_image()
 *
 * Show a single image
 *
 *************************************************************************/

ScrollView* display_image(IMAGE *image,
                     const char *title,
                     inT32 x,
                     inT32 y,
                     BOOL8 wait) {
  ScrollView* im_window;
  inT16 i;

  im_window = new ScrollView (title, x, y,
      10 * image->get_xsize (), 10 * image->get_ysize (),
      image->get_xsize (),  image->get_ysize ());

  sv_show_sub_image (image,
    0, 0,
    image->get_xsize (), image->get_ysize (), im_window, 0, 0);

  im_window->Pen(255,0,0);
  for (i = 1; i < image->get_xsize (); i++) {
    im_window->SetCursor(i, 0);
    im_window->DrawTo(i, image->get_ysize());
  }
  for (i = 1; i < image->get_ysize (); i++) {
    im_window->SetCursor(0, i);
    im_window->DrawTo(image->get_xsize(),i);
  }

  if (wait) { delete im_window->AwaitEvent(SVET_CLICK); }

  return im_window;
}
#endif
/////////////////////////////////////////////////////////////////matmatch////////////////////////////////////////

/////////////////////////////////////////////////////////////////blobcmp////////////////////////////////////////
#define CMP_CLASS       0
/**********************************************************************
 * compare_tess_blobs
 *
 * Match 2 blobs using the adaptive classifier.
 **********************************************************************/
float Tesseract::compare_tess_blobs(TBLOB *blob1,
                                    TEXTROW *row1,
                                    TBLOB *blob2,
                                    TEXTROW *row2) {
  int fcount;                    /*number of features */
  ADAPT_CLASS adapted_class;
  ADAPT_TEMPLATES ad_templates;
  LINE_STATS line_stats1, line_stats2;
  INT_FEATURE_ARRAY int_features;
  FEATURE_SET float_features;
  INT_RESULT_STRUCT int_result;  /*output */

  BIT_VECTOR AllProtosOn = NewBitVector (MAX_NUM_PROTOS);
  BIT_VECTOR AllConfigsOn = NewBitVector (MAX_NUM_CONFIGS);
  set_all_bits (AllProtosOn, WordsInVectorOfSize (MAX_NUM_PROTOS));
  set_all_bits (AllConfigsOn, WordsInVectorOfSize (MAX_NUM_CONFIGS));

  EnterClassifyMode;
  ad_templates = NewAdaptedTemplates (false);
  GetLineStatsFromRow(row1, &line_stats1);
                                 /*copy baseline stuff */
  GetLineStatsFromRow(row2, &line_stats2);
  adapted_class = NewAdaptedClass ();
  AddAdaptedClass (ad_templates, adapted_class, CMP_CLASS);
  InitAdaptedClass(blob1, &line_stats1, CMP_CLASS, adapted_class, ad_templates);
  fcount = GetAdaptiveFeatures (blob2, &line_stats2,
    int_features, &float_features);
  if (fcount > 0) {
    SetBaseLineMatch();
    IntegerMatcher (ClassForClassId (ad_templates->Templates, CMP_CLASS),
      AllProtosOn, AllConfigsOn, fcount, fcount,
      int_features, 0, &int_result, testedit_match_debug);
    FreeFeatureSet(float_features);
    if (int_result.Rating < 0)
      int_result.Rating = MAX_FLOAT32;
  }

  free_adapted_templates(ad_templates);
  FreeBitVector(AllConfigsOn);
  FreeBitVector(AllProtosOn);

  return fcount > 0 ? int_result.Rating * fcount : MAX_FLOAT32;
}
/////////////////////////////////////////////////////////////////blobcmp////////////////////////////////////////

/////////////////////////////////////////////////////////////////paircmp////////////////////////////////////////
#define EXTERN
/**********************************************************************
 * compare_blob_pairs
 *
 * A blob processor to compare pairs of selected blobs.
 **********************************************************************/
BOOL8 Tesseract::compare_blob_pairs(             //blob processor
                                    BLOCK *,
                                    ROW *row,    //row it came from
                                    WERD *,
                                    PBLOB *blob  //blob to compare
                                   ) {
  static ROW *prev_row = NULL;   //other in pair
  static PBLOB *prev_blob = NULL;
  float rating;                  //from matcher

  if (prev_row == NULL || prev_blob == NULL) {
    prev_row = row;
    prev_blob = blob;
  }
  else {
    rating = compare_blobs (prev_blob, prev_row, blob, row);
    tprintf ("Rating=%g\n", rating);
    prev_row = NULL;
    prev_blob = NULL;
  }
  return TRUE;
}


/**********************************************************************
 * compare_blobs
 *
 * Compare 2 blobs and return the rating.
 **********************************************************************/

float Tesseract::compare_blobs(               //match 2 blobs
                               PBLOB *blob1,  //first blob
                               ROW *row1,     //row it came from
                               PBLOB *blob2,  //other blob
                               ROW *row2) {
  PBLOB *bn_blob1;               //baseline norm
  PBLOB *bn_blob2;
  DENORM denorm1, denorm2;
  float rating;                  //match result

  bn_blob1 = blob1->baseline_normalise (row1, &denorm1);
  bn_blob2 = blob2->baseline_normalise (row2, &denorm2);
  rating = compare_bln_blobs (bn_blob1, &denorm1, bn_blob2, &denorm2);
  delete bn_blob1;
  delete bn_blob2;
  return rating;
}


/**********************************************************************
 * compare_bln_blobs
 *
 * Compare 2 baseline normalised blobs and return the rating.
 **********************************************************************/
float Tesseract::compare_bln_blobs(               //match 2 blobs
                                   PBLOB *blob1,  //first blob
                                   DENORM *denorm1,
                                   PBLOB *blob2,  //other blob
                                   DENORM *denorm2) {
  TBLOB *tblob1;                 //tessblobs
  TBLOB *tblob2;
  TEXTROW tessrow1, tessrow2;    //tess rows
  float rating;                  //match result

  tblob1 = make_tess_blob (blob1, TRUE);
  make_tess_row(denorm1, &tessrow1);
  tblob2 = make_tess_blob (blob2, TRUE);
  make_tess_row(denorm2, &tessrow2);
  rating = compare_tess_blobs(tblob1, &tessrow1, tblob2, &tessrow2);
  free_blob(tblob1);
  free_blob(tblob2);

  return rating;
}
/////////////////////////////////////////////////////////////////paircmp////////////////////////////////////////

/////////////////////////////////////////////////////////////////charsample////////////////////////////////////////
extern inT32 demo_word;          // Hack for demos

ELISTIZE (CHAR_SAMPLE) ELISTIZE (CHAR_SAMPLES) CHAR_SAMPLE::CHAR_SAMPLE () {
  sample_blob = NULL;
  sample_denorm = NULL;
  sample_image = NULL;
  ch = '\0';
  n_samples_matched = 0;
  total_match_scores = 0.0;
  sumsq_match_scores = 0.0;
}


CHAR_SAMPLE::CHAR_SAMPLE(PBLOB *blob, DENORM *denorm, char c) {
  sample_blob = blob;
  sample_denorm = denorm;
  sample_image = NULL;
  ch = c;
  n_samples_matched = 0;
  total_match_scores = 0.0;
  sumsq_match_scores = 0.0;
}


CHAR_SAMPLE::CHAR_SAMPLE(IMAGE *image, char c) {
  sample_blob = NULL;
  sample_denorm = NULL;
  sample_image = image;
  ch = c;
  n_samples_matched = 0;
  total_match_scores = 0.0;
  sumsq_match_scores = 0.0;
}


float CHAR_SAMPLE::match_sample(  // Update match scores
                                CHAR_SAMPLE *test_sample,
                                BOOL8 updating,
                                Tesseract* tess) {
  float score1;
  float score2;
  IMAGE *image = test_sample->image ();

  if (sample_blob != NULL && test_sample->blob () != NULL) {
    PBLOB *blob = test_sample->blob ();
    DENORM *denorm = test_sample->denorm ();

    score1 = tess->compare_bln_blobs (sample_blob, sample_denorm, blob, denorm);
    score2 = tess->compare_bln_blobs (blob, denorm, sample_blob, sample_denorm);

    score1 = (score1 > score2) ? score1 : score2;
  }
  else if (sample_image != NULL && image != NULL) {
    CHAR_PROTO *sample = new CHAR_PROTO (this);

    score1 = matrix_match(sample_image, image);
    delete sample;
  }
  else
    return BAD_SCORE;

  if ((tessedit_use_best_sample || tessedit_cluster_debug) && updating) {
    n_samples_matched++;
    total_match_scores += score1;
    sumsq_match_scores += score1 * score1;
  }
  return score1;
}


double CHAR_SAMPLE::mean_score() {
  if (n_samples_matched > 0)
    return (total_match_scores / n_samples_matched);
  else
    return BAD_SCORE;
}


double CHAR_SAMPLE::variance() {
  double mean = mean_score ();

  if (n_samples_matched > 0) {
    return (sumsq_match_scores / n_samples_matched) - mean * mean;
  }
  else
    return BAD_SCORE;
}


void CHAR_SAMPLE::print(FILE *f) {
  if (!tessedit_cluster_debug)
    return;

  if (n_samples_matched > 0)
    fprintf (f,
      "%c - sample matched against " INT32FORMAT
      " blobs, mean: %f, var: %f\n", ch, n_samples_matched,
      mean_score (), variance ());
  else
    fprintf (f, "No matches for this sample (%c)\n", ch);
}


void CHAR_SAMPLE::reset_match_statistics() {
  n_samples_matched = 0;
  total_match_scores = 0.0;
  sumsq_match_scores = 0.0;
}


CHAR_SAMPLES::CHAR_SAMPLES() {
  type = UNKNOWN;
  samples.clear ();
  ch = '\0';
  best_sample = NULL;
  proto = NULL;
}


CHAR_SAMPLES::CHAR_SAMPLES(CHAR_SAMPLE *sample) {
  CHAR_SAMPLE_IT sample_it = &samples;

  ASSERT_HOST (sample->image () != NULL || sample->blob () != NULL);

  if (sample->image () != NULL)
    type = IMAGE_CLUSTER;
  else if (sample->blob () != NULL)
    type = BLOB_CLUSTER;

  samples.clear ();
  sample_it.add_to_end (sample);
  if (tessedit_mm_only_match_same_char)
    ch = sample->character ();
  else
    ch = '\0';
  best_sample = NULL;
  proto = NULL;
}


void CHAR_SAMPLES::add_sample(CHAR_SAMPLE *sample, Tesseract* tess) {
  CHAR_SAMPLE_IT sample_it = &samples;

  if (tessedit_use_best_sample || tessedit_cluster_debug)
    for (sample_it.mark_cycle_pt ();
  !sample_it.cycled_list (); sample_it.forward ()) {
    sample_it.data ()->match_sample (sample, TRUE, tess);
    sample->match_sample (sample_it.data (), TRUE, tess);
  }

  sample_it.add_to_end (sample);

  if (tessedit_mm_use_prototypes && type == IMAGE_CLUSTER) {
    if (samples.length () == tessedit_mm_prototype_min_size)
      this->build_prototype ();
    else if (samples.length () > tessedit_mm_prototype_min_size)
      this->add_sample_to_prototype (sample);
  }
}


void CHAR_SAMPLES::add_sample_to_prototype(CHAR_SAMPLE *sample) {
  BOOL8 rebuild = FALSE;
  inT32 new_xsize = proto->x_size ();
  inT32 new_ysize = proto->y_size ();
  inT32 sample_xsize = sample->image ()->get_xsize ();
  inT32 sample_ysize = sample->image ()->get_ysize ();

  if (sample_xsize > new_xsize) {
    new_xsize = sample_xsize;
    rebuild = TRUE;
  }
  if (sample_ysize > new_ysize) {
    new_ysize = sample_ysize;
    rebuild = TRUE;
  }

  if (rebuild)
    proto->enlarge_prototype (new_xsize, new_ysize);

  proto->add_sample (sample);
}


void CHAR_SAMPLES::build_prototype() {
  CHAR_SAMPLE_IT sample_it = &samples;
  CHAR_SAMPLE *sample;
  inT32 proto_xsize = 0;
  inT32 proto_ysize = 0;

  if (type != IMAGE_CLUSTER
    || samples.length () < tessedit_mm_prototype_min_size)
    return;

  for (sample_it.mark_cycle_pt ();
  !sample_it.cycled_list (); sample_it.forward ()) {
    sample = sample_it.data ();
    if (sample->image ()->get_xsize () > proto_xsize)
      proto_xsize = sample->image ()->get_xsize ();
    if (sample->image ()->get_ysize () > proto_ysize)
      proto_ysize = sample->image ()->get_ysize ();
  }

  proto = new CHAR_PROTO (proto_xsize, proto_ysize, 0, 0, '\0');

  for (sample_it.mark_cycle_pt ();
    !sample_it.cycled_list (); sample_it.forward ())
  this->add_sample_to_prototype (sample_it.data ());

}


void CHAR_SAMPLES::find_best_sample() {
  CHAR_SAMPLE_IT sample_it = &samples;
  double score;
  double best_score = MAX_INT32;

  if (ch == '\0' || samples.length () < tessedit_mm_prototype_min_size)
    return;

  for (sample_it.mark_cycle_pt ();
  !sample_it.cycled_list (); sample_it.forward ()) {
    score = sample_it.data ()->mean_score ();
    if (score < best_score) {
      best_score = score;
      best_sample = sample_it.data ();
    }
  }
  #ifndef SECURE_NAMES
  if (tessedit_cluster_debug) {
    tprintf ("Best sample for this %c cluster:\n", ch);
    best_sample->print (debug_fp);
  }
  #endif
}


float CHAR_SAMPLES::match_score(CHAR_SAMPLE *sample,
                                Tesseract* tess) {
  if (tessedit_mm_only_match_same_char && sample->character () != ch)
    return BAD_SCORE;

  if (tessedit_use_best_sample && best_sample != NULL)
    return best_sample->match_sample (sample, FALSE, tess);
  else if ((tessedit_mm_use_prototypes
    || tessedit_mm_adapt_using_prototypes) && proto != NULL)
    return proto->match_sample (sample);
  else
    return this->nn_match_score (sample, tess);
}


float CHAR_SAMPLES::nn_match_score(CHAR_SAMPLE *sample,
                                   Tesseract* tess) {
  CHAR_SAMPLE_IT sample_it = &samples;
  float score;
  float min_score = MAX_INT32;

  for (sample_it.mark_cycle_pt ();
  !sample_it.cycled_list (); sample_it.forward ()) {
    score = sample_it.data ()->match_sample (sample, FALSE, tess);
    if (score < min_score)
      min_score = score;
  }

  return min_score;
}


void CHAR_SAMPLES::assign_to_char() {
  STATS char_frequency(FIRST_CHAR, LAST_CHAR);
  CHAR_SAMPLE_IT sample_it = &samples;
  inT32 i;
  inT32 max_index = 0;
  inT32 max_freq = 0;

  if (samples.length () == 0 || tessedit_mm_only_match_same_char)
    return;

  for (sample_it.mark_cycle_pt ();
    !sample_it.cycled_list (); sample_it.forward ())
  char_frequency.add ((inT32) sample_it.data ()->character (), 1);

  for (i = FIRST_CHAR; i <= LAST_CHAR; i++)
  if (char_frequency.pile_count (i) > max_freq) {
    max_index = i;
    max_freq = char_frequency.pile_count (i);
  }

  if (samples.length () >= tessedit_cluster_min_size
    && max_freq > samples.length () * tessedit_cluster_accept_fraction)
    ch = (char) max_index;
}


void CHAR_SAMPLES::print(FILE *f) {
  CHAR_SAMPLE_IT sample_it = &samples;

  fprintf (f, "Collected " INT32FORMAT " samples\n", samples.length ());

  #ifndef SECURE_NAMES
  if (tessedit_cluster_debug)
    for (sample_it.mark_cycle_pt ();
    !sample_it.cycled_list (); sample_it.forward ())
  sample_it.data ()->print (f);

  if (ch == '\0')
    fprintf (f, "\nCluster not used for adaption\n");
  else
    fprintf (f, "\nCluster used to adapt to '%c's\n", ch);
  #endif
}


CHAR_PROTO::CHAR_PROTO() {
  xsize = 0;
  ysize = 0;
  ch = '\0';
  nsamples = 0;
  proto_data = NULL;
  proto = NULL;
}


CHAR_PROTO::CHAR_PROTO(inT32 x_size,
                       inT32 y_size,
                       inT32 n_samples,
                       float initial_value,
                       char c) {
  inT32 x;
  inT32 y;

  xsize = x_size;
  ysize = y_size;
  ch = c;
  nsamples = n_samples;

  ALLOC_2D_ARRAY(xsize, ysize, proto_data, proto, float);

  for (y = 0; y < ysize; y++)
    for (x = 0; x < xsize; x++)
      proto[x][y] = initial_value;
}


CHAR_PROTO::CHAR_PROTO(CHAR_SAMPLE *sample) {
  inT32 x;
  inT32 y;
  IMAGELINE imline_s;

  if (sample->image () == NULL) {
    xsize = 0;
    ysize = 0;
    ch = '\0';
    nsamples = 0;
    proto_data = NULL;
    proto = NULL;
  }
  else {
    ch = sample->character ();
    xsize = sample->image ()->get_xsize ();
    ysize = sample->image ()->get_ysize ();
    nsamples = 1;

    ALLOC_2D_ARRAY(xsize, ysize, proto_data, proto, float);

    for (y = 0; y < ysize; y++) {
      sample->image ()->fast_get_line (0, y, xsize, &imline_s);
      for (x = 0; x < xsize; x++)
        if (imline_s.pixels[x] == BINIM_WHITE)
          proto[x][y] = 1.0;
      else
        proto[x][y] = -1.0;
    }
  }
}


CHAR_PROTO::~CHAR_PROTO () {
  if (proto_data != NULL)
    FREE_2D_ARRAY(proto_data, proto);
}


float CHAR_PROTO::match_sample(CHAR_SAMPLE *test_sample) {
  CHAR_PROTO *test_proto;
  float score;

  if (test_sample->image () != NULL) {
    test_proto = new CHAR_PROTO (test_sample);
    if (xsize > test_proto->x_size ())
      score = this->match (test_proto);
    else {
      demo_word = -demo_word;    // Flag different call
      score = test_proto->match (this);
    }
  }
  else
    return BAD_SCORE;

  delete test_proto;

  return score;
}


float CHAR_PROTO::match(CHAR_PROTO *test_proto) {
  inT32 xsize2 = test_proto->x_size ();
  inT32 y_size;
  inT32 y_size2;
  inT32 x_offset;
  inT32 y_offset;
  inT32 x;
  inT32 y;
  CHAR_PROTO *match_proto;
  float score;
  float sum = 0.0;

  ASSERT_HOST (xsize >= xsize2);

  x_offset = (xsize - xsize2) / 2;

  if (ysize < test_proto->y_size ()) {
    y_size = test_proto->y_size ();
    y_size2 = ysize;
    y_offset = (y_size - y_size2) / 2;

    match_proto = new CHAR_PROTO (xsize,
      y_size,
      nsamples * test_proto->n_samples (),
      0, '\0');

    for (y = 0; y < y_offset; y++) {
      for (x = 0; x < xsize2; x++) {
        match_proto->data ()[x + x_offset][y] =
          test_proto->data ()[x][y] * nsamples;
        sum += match_proto->data ()[x + x_offset][y];
      }
    }

    for (y = y_offset + y_size2; y < y_size; y++) {
      for (x = 0; x < xsize2; x++) {
        match_proto->data ()[x + x_offset][y] =
          test_proto->data ()[x][y] * nsamples;
        sum += match_proto->data ()[x + x_offset][y];
      }
    }

    for (y = y_offset; y < y_offset + y_size2; y++) {
      for (x = 0; x < x_offset; x++) {
        match_proto->data ()[x][y] = proto[x][y - y_offset] *
          test_proto->n_samples ();
        sum += match_proto->data ()[x][y];
      }

      for (x = x_offset + xsize2; x < xsize; x++) {
        match_proto->data ()[x][y] = proto[x][y - y_offset] *
          test_proto->n_samples ();
        sum += match_proto->data ()[x][y];
      }

      for (x = x_offset; x < x_offset + xsize2; x++) {
        match_proto->data ()[x][y] =
          proto[x][y - y_offset] * test_proto->data ()[x - x_offset][y];
        sum += match_proto->data ()[x][y];
      }
    }
  }
  else {
    y_size = ysize;
    y_size2 = test_proto->y_size ();
    y_offset = (y_size - y_size2) / 2;

    match_proto = new CHAR_PROTO (xsize,
      y_size,
      nsamples * test_proto->n_samples (),
      0, '\0');

    for (y = 0; y < y_offset; y++)
    for (x = 0; x < xsize; x++) {
      match_proto->data ()[x][y] =
        proto[x][y] * test_proto->n_samples ();
      sum += match_proto->data ()[x][y];
    }

    for (y = y_offset + y_size2; y < y_size; y++)
    for (x = 0; x < xsize; x++) {
      match_proto->data ()[x][y] =
        proto[x][y] * test_proto->n_samples ();
      sum += match_proto->data ()[x][y];
    }

    for (y = y_offset; y < y_offset + y_size2; y++) {
      for (x = 0; x < x_offset; x++) {
        match_proto->data ()[x][y] =
          proto[x][y] * test_proto->n_samples ();
        sum += match_proto->data ()[x][y];
      }

      for (x = x_offset + xsize2; x < xsize; x++) {
        match_proto->data ()[x][y] =
          proto[x][y] * test_proto->n_samples ();
        sum += match_proto->data ()[x][y];
      }

      for (x = x_offset; x < x_offset + xsize2; x++) {
        match_proto->data ()[x][y] = proto[x][y] *
          test_proto->data ()[x - x_offset][y - y_offset];
        sum += match_proto->data ()[x][y];
      }
    }
  }

  score = (1.0 - sum /
    (xsize * y_size * nsamples * test_proto->n_samples ()));

  if (tessedit_mm_debug) {
    if (score < 0) {
      tprintf ("Match score %f\n", score);
      tprintf ("x: %d, y: %d, ns: %d, nt: %d, dx %d, dy: %d\n",
        xsize, y_size, nsamples, test_proto->n_samples (),
        x_offset, y_offset);
      for (y = 0; y < y_size; y++) {
        tprintf ("\n%d", y);
        for (x = 0; x < xsize; x++)
          tprintf ("\t%d", match_proto->data ()[x][y]);

      }
      tprintf ("\n");
      fflush(debug_fp);
    }
  }

#ifndef GRAPHICS_DISABLED
  if (tessedit_display_mm) {
    tprintf ("Match score %f\n", score);
    display_images (this->make_image (),
      test_proto->make_image (), match_proto->make_image ());
  }
  else if (demo_word != 0) {
    if (demo_word > 0)
      display_image (test_proto->make_image (), "Test sample",
        300, 400, FALSE);
    else
      display_image (this->make_image (), "Test sample", 300, 400, FALSE);

    display_image (match_proto->make_image (), "Best match",
      700, 400, TRUE);
  }
#endif

  delete match_proto;

  return score;
}


void CHAR_PROTO::enlarge_prototype(inT32 new_xsize, inT32 new_ysize) {
  float *old_proto_data = proto_data;
  float **old_proto = proto;
  inT32 old_xsize = xsize;
  inT32 old_ysize = ysize;
  inT32 x_offset;
  inT32 y_offset;
  inT32 x;
  inT32 y;

  ASSERT_HOST (new_xsize >= xsize && new_ysize >= ysize);

  xsize = new_xsize;
  ysize = new_ysize;
  ALLOC_2D_ARRAY(xsize, ysize, proto_data, proto, float);
  x_offset = (xsize - old_xsize) / 2;
  y_offset = (ysize - old_ysize) / 2;

  for (y = 0; y < y_offset; y++)
    for (x = 0; x < xsize; x++)
      proto[x][y] = nsamples;

  for (y = y_offset + old_ysize; y < ysize; y++)
    for (x = 0; x < xsize; x++)
      proto[x][y] = nsamples;

  for (y = y_offset; y < y_offset + old_ysize; y++) {
    for (x = 0; x < x_offset; x++)
      proto[x][y] = nsamples;

    for (x = x_offset + old_xsize; x < xsize; x++)
      proto[x][y] = nsamples;

    for (x = x_offset; x < x_offset + old_xsize; x++)
      proto[x][y] = old_proto[x - x_offset][y - y_offset];
  }

  FREE_2D_ARRAY(old_proto_data, old_proto);
}


void CHAR_PROTO::add_sample(CHAR_SAMPLE *sample) {
  inT32 x_offset;
  inT32 y_offset;
  inT32 x;
  inT32 y;
  IMAGELINE imline_s;
  inT32 sample_xsize = sample->image ()->get_xsize ();
  inT32 sample_ysize = sample->image ()->get_ysize ();

  x_offset = (xsize - sample_xsize) / 2;
  y_offset = (ysize - sample_ysize) / 2;

  ASSERT_HOST (x_offset >= 0 && y_offset >= 0);

  for (y = 0; y < y_offset; y++)
    for (x = 0; x < xsize; x++)
      proto[x][y]++;             // Treat pixels outside the
  // range as white
  for (y = y_offset + sample_ysize; y < ysize; y++)
    for (x = 0; x < xsize; x++)
      proto[x][y]++;

  for (y = y_offset; y < y_offset + sample_ysize; y++) {
    sample->image ()->fast_get_line (0,
      y - y_offset, sample_xsize, &imline_s);
    for (x = x_offset; x < x_offset + sample_xsize; x++) {
      if (imline_s.pixels[x - x_offset] == BINIM_WHITE)
        proto[x][y]++;
      else
        proto[x][y]--;
    }

    for (x = 0; x < x_offset; x++)
      proto[x][y]++;

    for (x = x_offset + sample_xsize; x < xsize; x++)
      proto[x][y]++;
  }

  nsamples++;
}


IMAGE *CHAR_PROTO::make_image() {
  IMAGE *image;
  IMAGELINE imline_p;
  inT32 x;
  inT32 y;

  ASSERT_HOST (nsamples != 0);

  image = new (IMAGE);
  image->create (xsize, ysize, 8);

  for (y = 0; y < ysize; y++) {
    image->fast_get_line (0, y, xsize, &imline_p);

    for (x = 0; x < xsize; x++) {
      imline_p.pixels[x] = 128 +
        (uinT8) ((proto[x][y] * 128.0) / (0.00001 + nsamples));
    }

    image->fast_put_line (0, y, xsize, &imline_p);
  }
  return image;
}
/////////////////////////////////////////////////////////////////charsample////////////////////////////////////////

/////////////////////////////////////////////////////////////////pagewalk////////////////////////////////////////
#define EXTERN
EXTERN BOOL_VAR (current_word_quit, FALSE, "Stop processing this word");
BOOL_VAR (selection_quit, FALSE, "Stop processing this selection");

/**
 *  block_list_bounding_box()
 *
 *  Scan block list to find the bounding box of all blocks.
 *  @param block_list the block list to find the bounding box of
 */

TBOX block_list_bounding_box(BLOCK_LIST *block_list)
{
  BLOCK_IT block_it(block_list);
  TBOX enclosing_box;

  for (block_it.mark_cycle_pt (); !block_it.cycled_list ();
    block_it.forward ())
  enclosing_box += block_it.data ()->bounding_box ();
  return enclosing_box;
}


/**
 *  block_list_compress()
 *
 *  Pack a block list to occupy a smaller space by compressing each block and
 *  moving the compressed blocks one above the other.
 *  The compressed block list has the same top left point as the uncompressed
 *  first.  Blocks are reordered so that the source names are in alphabetic
 *  order. (This gathers together, but does not combine, blocks from the same
 *  file.)
 *
 *  The enclosing box of the compressed block list is returned.
 */

const TBOX block_list_compress(BLOCK_LIST *block_list)
{
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ICOORD initial_top_left;
  ICOORD block_spacing (0, BLOCK_SPACING);
  TBOX enclosing_box;             //for full display

  initial_top_left = block_it.data()->bounding_box().topleft();
                                 //group srcfile blks
  block_it.sort (block_name_order);

  /* Compress the target block list into an area starting from the top left of
    the first block on the list */

  enclosing_box = TBOX (initial_top_left, initial_top_left);
  enclosing_box.move_bottom_edge (BLOCK_SPACING);

  for (block_it.mark_cycle_pt ();
  !block_it.cycled_list (); block_it.forward ()) {
    block = block_it.data ();
    block->compress (enclosing_box.botleft () - block_spacing -
      block->bounding_box ().topleft ());
    enclosing_box += block->bounding_box ();
  }
  return enclosing_box;
}


/**
 * block_list_move()
 *
 * Move all the blocks in the list by a vector
 *
 * @param block_list the block list to move
 * @param vec the vector to move it by
 */

void block_list_move(BLOCK_LIST *block_list,
                     ICOORD vec)
{
  BLOCK_IT block_it(block_list);

  for (block_it.mark_cycle_pt (); !block_it.cycled_list ();
       block_it.forward ())
    block_it.data ()->move (vec);
}


/**
 *  block_name_order()
 *
 *  Block comparator used to sort a block list so that blocks from the same
 *  filename are located together, and blocks from the same file are ordered
 *  by vertical position.
 */

int block_name_order(const void *block1p,
                     const void *block2p)
{
  int result;
  BLOCK *block1 = *(BLOCK **) block1p;
  BLOCK *block2 = *(BLOCK **) block2p;

  result = strcmp (block1->name (), block2->name ());
  if (result == 0)
    result = block2->bounding_box ().top () - block1->bounding_box ().top ();
  return result;
}


/**
 * process_all_blobs()
 *
 * Walk the current block list applying the specified blob processor function
 * to all blobs
 * @param block_list the blocks to check
 * @param blob_processor function to call
 * @param c_blob_processor function to call
 */

void
process_all_blobs (BLOCK_LIST * block_list,
                   BOOL8 blob_processor (BLOCK *, ROW *, WERD *, PBLOB *),
                   BOOL8 c_blob_processor (BLOCK *, ROW *, WERD *, C_BLOB *))
{
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ROW_IT row_it;
  ROW *row;
  WERD_IT word_it;
  WERD *word;
  PBLOB_IT blob_it;
  PBLOB *blob;
  C_BLOB_IT c_blob_it;
  C_BLOB *c_blob;

  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ()) {
    block = block_it.data ();
    row_it.set_to_list (block->row_list ());
    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ()) {
      row = row_it.data ();
      word_it.set_to_list (row->word_list ());
      for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ()) {
        word = word_it.data ();
        if (word->flag (W_POLYGON)) {
          if (blob_processor != NULL) {
            blob_it.set_to_list (word->blob_list ());
            for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ()) {
              blob = blob_it.data ();
              if (!blob_processor (block, row, word, blob) || selection_quit)
                return;
            }
          }
        }
        else {
          if (c_blob_processor != NULL) {
            c_blob_it.set_to_list (word->cblob_list ());
            for (c_blob_it.mark_cycle_pt (); !c_blob_it.cycled_list (); c_blob_it.forward ()) {
              c_blob = c_blob_it.data ();
              if (!c_blob_processor (block, row, word, c_blob) || selection_quit)
                return;
            }
          }
        }
      }
    }
  }
}


/**
 * process_selected_blobs()
 *
 * Walk the current block list applying the specified blob processor function
 * to each selected blob
 * @param block_list the blocks to check
 * @param selection_box within this box(?)
 * @param blob_processor function to call
 * @param c_blob_processor function to call
 */

void
process_selected_blobs (BLOCK_LIST * block_list,
                        TBOX & selection_box,
                        BOOL8 blob_processor (BLOCK *, ROW *, WERD *, PBLOB *),
                        BOOL8 c_blob_processor (BLOCK *, ROW *, WERD *, C_BLOB *))
{
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ROW_IT row_it;
  ROW *row;
  WERD_IT word_it;
  WERD *word;
  PBLOB_IT blob_it;
  PBLOB *blob;
  C_BLOB_IT c_blob_it;
  C_BLOB *c_blob;

  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ()) {
    block = block_it.data ();
    if (block->bounding_box ().overlap (selection_box)) {
      row_it.set_to_list (block->row_list ());
      for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ()) {
        row = row_it.data ();
        if (row->bounding_box ().overlap (selection_box)) {
          word_it.set_to_list (row->word_list ());
          for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ()) {
            word = word_it.data ();
            if (word->bounding_box ().overlap (selection_box)) {
              if (word->flag (W_POLYGON)) {
                if (blob_processor != NULL) {
                  blob_it.set_to_list (word->blob_list ());
                  for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ()) {
                    blob = blob_it.data ();
                    if (blob->bounding_box().overlap (selection_box)) {
                      if (!blob_processor(block, row, word, blob) || selection_quit)
                        return;
                    }
                  }
                }
              }
              else {
                if (c_blob_processor != NULL) {
                  c_blob_it.set_to_list (word->cblob_list ());
                  for (c_blob_it.mark_cycle_pt (); !c_blob_it.cycled_list (); c_blob_it.forward ()) {
                    c_blob = c_blob_it.data ();
                    if (c_blob->bounding_box ().overlap (selection_box)) {
                      if (!c_blob_processor(block, row, word, c_blob) || selection_quit)
                        return;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


/**
 * process_all_words()
 *
 * Walk the current block list applying the specified word processor function
 * to all words
 */
void
process_all_words (BLOCK_LIST * block_list,
                   BOOL8 word_processor (BLOCK *, ROW *, WERD *))
{
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ROW_IT row_it;
  ROW *row;
  WERD_IT word_it;
  WERD *word;

  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ()) {
    block = block_it.data ();
    row_it.set_to_list (block->row_list ());
    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ()) {
      row = row_it.data ();
      word_it.set_to_list (row->word_list ());
      for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ()) {
        word = word_it.data ();
        if (!word_processor (block, row, word) || selection_quit)
          return;
      }
    }
  }
}


/**
 * process_selected_words()
 *
 * Walk the current block list applying the specified word processor function
 * to each word selected.
 */

void
process_selected_words (BLOCK_LIST * block_list,
                        TBOX & selection_box,
                        BOOL8 word_processor (BLOCK *, ROW *, WERD *))
{
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ROW_IT row_it;
  ROW *row;
  WERD_IT word_it;
  WERD *word;

  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ()) {
    block = block_it.data ();
    if (block->bounding_box ().overlap (selection_box)) {
      row_it.set_to_list (block->row_list ());
      for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ()) {
        row = row_it.data ();
        if (row->bounding_box ().overlap (selection_box)) {
          word_it.set_to_list (row->word_list ());
          for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ()) {
            word = word_it.data ();
            if (word->bounding_box ().overlap (selection_box)) {
              if (!word_processor (block, row, word) || selection_quit)
                return;
            }
          }
        }
      }
    }
  }
}

void Tesseract::process_selected_words (BLOCK_LIST * block_list,
                                   TBOX & selection_box,
                                   BOOL8 (Tesseract::*word_processor) (BLOCK *, ROW *, WERD *))
{
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ROW_IT row_it;
  ROW *row;
  WERD_IT word_it;
  WERD *word;

  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ()) {
    block = block_it.data ();
    if (block->bounding_box ().overlap (selection_box)) {
      row_it.set_to_list (block->row_list ());
      for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ()) {
        row = row_it.data ();
        if (row->bounding_box ().overlap (selection_box)) {
          word_it.set_to_list (row->word_list ());
          for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ()) {
            word = word_it.data ();
            if (word->bounding_box ().overlap (selection_box)) {
              if (!((this->*word_processor) (block, row, word)) || selection_quit)
                return;
            }
          }
        }
      }
    }
  }
}

/**
 * process_all_words_it()   PASS ITERATORS
 *
 * Walk the current block list applying the specified word processor function
 * to all words
 */

void
process_all_words_it (BLOCK_LIST * block_list,
                      BOOL8 word_processor (BLOCK *, ROW *, WERD *, BLOCK_IT &, ROW_IT &, WERD_IT &))
{
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ROW_IT row_it;
  ROW *row;
  WERD_IT word_it;
  WERD *word;

  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ()) {
    block = block_it.data ();
    row_it.set_to_list (block->row_list ());
    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ()) {
      row = row_it.data ();
      word_it.set_to_list (row->word_list ());
      for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ()) {
        word = word_it.data ();
        if (!word_processor (block, row, word, block_it, row_it, word_it) || selection_quit)
          return;
      }
    }
  }
}


/**
 * process_selected_words_it()   PASS ITERATORS
 *
 * Walk the current block list applying the specified word processor function
 * to each word selected.
 */

void
process_selected_words_it (BLOCK_LIST * block_list,
                           TBOX & selection_box,
                           BOOL8 word_processor (BLOCK *, ROW *, WERD *, BLOCK_IT &, ROW_IT &, WERD_IT &))
{
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ROW_IT row_it;
  ROW *row;
  WERD_IT word_it;
  WERD *word;

  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ()) {
    block = block_it.data ();
    if (block->bounding_box ().overlap (selection_box)) {
      row_it.set_to_list (block->row_list ());
      for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ()) {
        row = row_it.data ();
        if (row->bounding_box ().overlap (selection_box)) {
          word_it.set_to_list (row->word_list ());
          for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ()) {
            word = word_it.data ();
            if (word->bounding_box ().overlap (selection_box)) {
              if (!word_processor (block, row, word, block_it, row_it, word_it) || selection_quit)
                return;
            }
          }
        }
      }
    }
  }
}


/**
 * process_all_blocks()
 *
 * Walk the current block list applying the specified block processor function
 * to each block.
 */

void
process_all_blocks (BLOCK_LIST * block_list,
                    BOOL8 block_processor (BLOCK *))
{
  BLOCK_IT block_it(block_list);
  BLOCK *block;

  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ()) {
    block = block_it.data ();
    if (!block_processor (block) || selection_quit)
      return;
  }
}


/**
 * process_selected_blocks()
 *
 * Walk the current block list applying the specified block processor function
 * to each block selected.
 */

void
process_selected_blocks (BLOCK_LIST * block_list,
                         TBOX & selection_box,
                         BOOL8 block_processor (BLOCK *))
{
  BLOCK_IT block_it(block_list);
  BLOCK *block;

  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ()) {
    block = block_it.data ();
    if (block->bounding_box ().overlap (selection_box)) {
      if (!block_processor (block) || selection_quit)
        return;
    }
  }
}


/**
 * process_all_rows()
 *
 * Walk the current block list applying the specified row processor function
 * to all rows
 */

void
process_all_rows (BLOCK_LIST * block_list,
                  BOOL8 row_processor (BLOCK *, ROW *))
{
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ROW_IT row_it;
  ROW *row;

  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ()) {
    block = block_it.data ();
    row_it.set_to_list (block->row_list ());
    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ()) {
      row = row_it.data ();
      if (!row_processor (block, row) || selection_quit)
        return;
    }
  }
}


/**
 * process_selected_rows()
 *
 * Walk the current block list applying the specified row processor function
 * to each row selected.
 */

void
process_selected_rows (BLOCK_LIST * block_list,
                       TBOX & selection_box,
                       BOOL8 row_processor (BLOCK *, ROW *))
{
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ROW_IT row_it;
  ROW *row;

  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ()) {
    block = block_it.data ();
    if (block->bounding_box ().overlap (selection_box)) {
      row_it.set_to_list (block->row_list ());
      for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ()) {
        row = row_it.data ();
        if (row->bounding_box ().overlap (selection_box)) {
          if (!row_processor (block, row) || selection_quit)
            return;
        }
      }
    }
  }
}


/**
 * process_all_rows_it()   PASS ITERATORS
 *
 * Walk the current block list applying the specified row processor function
 * to all rows
 */

void
process_all_rows_it (BLOCK_LIST * block_list,
                     BOOL8 row_processor (BLOCK *, ROW *, BLOCK_IT &, ROW_IT &))
{
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ROW_IT row_it;
  ROW *row;

  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ()) {
    block = block_it.data ();
    row_it.set_to_list (block->row_list ());
    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ()) {
      row = row_it.data ();
      if (!row_processor (block, row, block_it, row_it) || selection_quit)
        return;
    }
  }
}


/**
 * process_selected_rows_it()   PASS ITERATORS
 *
 * Walk the current block list applying the specified row processor function
 * to each row selected.
 */

void
process_selected_rows_it (BLOCK_LIST * block_list,
                          TBOX & selection_box,
                          BOOL8 row_processor (BLOCK *, ROW *, BLOCK_IT &, ROW_IT &))
{
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ROW_IT row_it;
  ROW *row;

  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ()) {
    block = block_it.data ();
    if (block->bounding_box ().overlap (selection_box)) {
      row_it.set_to_list (block->row_list ());
      for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ()) {
        row = row_it.data ();
        if (row->bounding_box ().overlap (selection_box)) {
          if (!row_processor (block, row, block_it, row_it) || selection_quit)
            return;
        }
      }
    }
  }
}
/////////////////////////////////////////////////////////////////pagewalk////////////////////////////////////////

/////////////////////////////////////////////////////////////////blread////////////////////////////////////////
#define UNLV_EXT  ".uzn"  // unlv zone file

/**********************************************************************
 * read_unlv_file
 *
 * Read a whole unlv zone file to make a list of blocks.
 **********************************************************************/

bool read_unlv_file(                    //print list of sides
                     STRING name,        //basename of file
                     inT32 xsize,        //image size
                     inT32 ysize,        //image size
                     BLOCK_LIST *blocks  //output list
                    ) {
  Q_UNUSED(xsize);
  FILE *pdfp;                    //file pointer
  BLOCK *block;                  //current block
  int x;                         //current top-down coords
  int y;
  int width;                     //of current block
  int height;
  BLOCK_IT block_it = blocks;    //block iterator

  name += UNLV_EXT;              //add extension
  if ((pdfp = fopen (name.string (), "r")) == NULL) {
    return false;                //didn't read one
  }
  else {
    while (fscanf (pdfp, "%d %d %d %d %*s", &x, &y, &width, &height) >= 4) {
                                 //make rect block
      block = new BLOCK (name.string (), TRUE, 0, 0,
                         (inT16) x, (inT16) (ysize - y - height),
                         (inT16) (x + width), (inT16) (ysize - y));
                                 //on end of list
      block_it.add_to_end (block);
    }
    fclose(pdfp);
  }
  return true;
}

void FullPageBlock(int width, int height, BLOCK_LIST *blocks) {
  BLOCK_IT block_it(blocks);
  BLOCK* block = new BLOCK("", TRUE, 0, 0, 0, 0, width, height);
  block_it.add_to_end(block);
}
/////////////////////////////////////////////////////////////////blread////////////////////////////////////////

/////////////////////////////////////////////////////////////////blobbox////////////////////////////////////////
#define PROJECTION_MARGIN 10     //arbitrary
#define EXTERN

EXTERN double_VAR (textord_error_weight, 3, "Weighting for error in believability");
EXTERN BOOL_VAR (pitsync_projection_fix, TRUE, "Fix bug in projection profile");

ELISTIZE (BLOBNBOX) ELIST2IZE (TO_ROW) ELISTIZE (TO_BLOCK)
/**********************************************************************
 * BLOBNBOX::merge
 *
 * Merge this blob with the given blob, which should be after this.
 **********************************************************************/
//merge blobs        //blob to join with
void BLOBNBOX::merge(BLOBNBOX *nextblob)
{
  box += nextblob->box;          //merge boxes
  nextblob->joined = TRUE;
}


/**********************************************************************
 * BLOBNBOX::chop
 *
 * Chop this blob into equal sized pieces using the x height as a guide.
 * The blob is not actually chopped. Instead, fake blobs are inserted
 * with the relevant bounding boxes.
 **********************************************************************/

void BLOBNBOX::chop(                        //chop blobs
                    BLOBNBOX_IT *start_it,  //location of this
                    BLOBNBOX_IT *end_it,    //iterator
                    FCOORD rotation,        //for landscape
                    float xheight           //of line
                   )
{
  inT16 blobcount;               //no of blobs
  BLOBNBOX *newblob;             //fake blob
  BLOBNBOX *blob;                //current blob
  inT16 blobindex;               //number of chop
  inT16 leftx;                   //left edge of blob
  float blobwidth;               //width of each
  float rightx;                  //right edge to scan
  float ymin, ymax;              //limits of new blob
  float test_ymin, test_ymax;    //limits of part blob
  ICOORD bl, tr;                 //corners of box
  BLOBNBOX_IT blob_it;           //blob iterator

  //get no of chops
  blobcount = (inT16) floor (box.width () / xheight);
  if (blobcount > 1 && (blob_ptr != NULL || cblob_ptr != NULL))
  {
    //width of each
    blobwidth = (float) (box.width () + 1) / blobcount;

    for (blobindex = blobcount - 1, rightx = box.right ();
    blobindex >= 0; blobindex--, rightx -= blobwidth)
    {
      ymin = (float) MAX_INT32;
      ymax = (float) -MAX_INT32;
      blob_it = *start_it;

      do
      {
        blob = blob_it.data();
        if (blob->blob_ptr != NULL)
        {
          find_blob_limits(blob->blob_ptr, rightx - blobwidth, rightx, rotation, test_ymin, test_ymax);
        }
        else
        {
          find_cblob_vlimits(blob->cblob_ptr, rightx - blobwidth, rightx, /*rotation, */ test_ymin, test_ymax);
        }
        blob_it.forward ();

        if (test_ymin < ymin)
        {
          ymin = test_ymin;
        }

        if (test_ymax > ymax)
        {
          ymax = test_ymax;
        }
      }
      while (blob != end_it->data ());

      if (ymin < ymax)
      {
        leftx = (inT16) floor (rightx - blobwidth);

        if (leftx < box.left ())
        {
          leftx = box.left ();   //clip to real box
        }

        bl = ICOORD (leftx, (inT16) floor (ymin));
        tr = ICOORD ((inT16) ceil (rightx), (inT16) ceil (ymax));

        if (blobindex == 0)
        {
          box = TBOX (bl, tr);    //change box
        }
        else
        {
          newblob = new BLOBNBOX;

          //box is all it has
          newblob->box = TBOX (bl, tr);

          //stay on current
          end_it->add_after_stay_put (newblob);
        }
      }
    }
  }
}


/**********************************************************************
 * find_blob_limits
 *
 * Scan the outlines of the blob to locate the y min and max
 * between the given x limits.
 **********************************************************************/

void find_blob_limits(                  //get y limits
                      PBLOB *blob,      //blob to search
                      float leftx,      //x limits
                      float rightx,
                      FCOORD rotation,  //for landscape
                      float &ymin,      //output y limits
                      float &ymax)\
{
  float testy;                   //y intercept
  FCOORD pos;                    //rotated
  FCOORD vec;
  POLYPT *polypt;                //current point

  //outlines
  OUTLINE_IT out_it = blob->out_list ();
  POLYPT_IT poly_it;             //outline pts

  ymin = (float) MAX_INT32;
  ymax = (float) -MAX_INT32;

  for (out_it.mark_cycle_pt (); !out_it.cycled_list (); out_it.forward ())
  {
    //get points
    poly_it.set_to_list (out_it.data ()->polypts ());

    for (poly_it.mark_cycle_pt (); !poly_it.cycled_list (); poly_it.forward ())
    {
      polypt = poly_it.data ();
      pos = polypt->pos;
      pos.rotate (rotation);
      vec = polypt->vec;
      vec.rotate (rotation);

      if ((pos.x () < leftx && pos.x () + vec.x () > leftx) || (pos.x () > leftx && pos.x () + vec.x () < leftx))
      {
        testy = pos.y () + vec.y () * (leftx - pos.x ()) / vec.x ();

        //intercept of boundary
        if (testy < ymin)
        {
          ymin = testy;
        }

        if (testy > ymax)
        {
          ymax = testy;
        }
      }

      if (pos.x () >= leftx && pos.x () <= rightx)
      {
        if (pos.y () > ymax)
        {
          ymax = pos.y ();
        }

        if (pos.y () < ymin)
        {
          ymin = pos.y ();
        }
      }

      if ((pos.x () > rightx && pos.x () + vec.x () < rightx) || (pos.x () < rightx && pos.x () + vec.x () > rightx))
      {
        testy = pos.y () + vec.y () * (rightx - pos.x ()) / vec.x ();

        //intercept of boundary
        if (testy < ymin)
        {
          ymin = testy;
        }

        if (testy > ymax)
        {
          ymax = testy;
        }
      }
    }
  }
}


/**********************************************************************
 * find_cblob_limits
 *
 * Scan the outlines of the cblob to locate the y min and max
 * between the given x limits.
 **********************************************************************/

void find_cblob_limits(                  //get y limits
                       C_BLOB *blob,     //blob to search
                       float leftx,      //x limits
                       float rightx,
                       FCOORD rotation,  //for landscape
                       float &ymin,      //output y limits
                       float &ymax)
{
  inT16 stepindex;               //current point
  ICOORD pos;                    //current coords
  ICOORD vec;                    //rotated step
  C_OUTLINE *outline;            //current outline

  //outlines
  C_OUTLINE_IT out_it = blob->out_list ();

  ymin = (float) MAX_INT32;
  ymax = (float) -MAX_INT32;

  for (out_it.mark_cycle_pt (); !out_it.cycled_list (); out_it.forward ())
  {
    outline = out_it.data ();
    pos = outline->start_pos (); //get coords
    pos.rotate (rotation);

    for (stepindex = 0; stepindex < outline->pathlength (); stepindex++)
    {
      //inside
      if (pos.x () >= leftx && pos.x () <= rightx)
      {
        if (pos.y () > ymax)
        {
          ymax = pos.y ();
        }

        if (pos.y () < ymin)
        {
          ymin = pos.y ();
        }
      }

      vec = outline->step (stepindex);
      vec.rotate (rotation);
      pos += vec;                //move to next
    }
  }
}


/**********************************************************************
 * find_cblob_vlimits
 *
 * Scan the outlines of the cblob to locate the y min and max
 * between the given x limits.
 **********************************************************************/

void find_cblob_vlimits(               //get y limits
                        C_BLOB *blob,  //blob to search
                        float leftx,   //x limits
                        float rightx,
                        float &ymin,   //output y limits
                        float &ymax)
{
  inT16 stepindex;               //current point
  ICOORD pos;                    //current coords
  ICOORD vec;                    //rotated step
  C_OUTLINE *outline;            //current outline

  //outlines
  C_OUTLINE_IT out_it = blob->out_list ();

  ymin = (float) MAX_INT32;
  ymax = (float) -MAX_INT32;

  for (out_it.mark_cycle_pt (); !out_it.cycled_list (); out_it.forward ())
  {
    outline = out_it.data ();
    pos = outline->start_pos (); //get coords
    for (stepindex = 0; stepindex < outline->pathlength (); stepindex++)
    {
      //inside
      if (pos.x () >= leftx && pos.x () <= rightx)
      {
        if (pos.y () > ymax)
        {
          ymax = pos.y ();
        }

        if (pos.y () < ymin)
        {
          ymin = pos.y ();
        }
      }

      vec = outline->step (stepindex);
      pos += vec;                //move to next
    }
  }
}


/**********************************************************************
 * find_cblob_hlimits
 *
 * Scan the outlines of the cblob to locate the x min and max
 * between the given y limits.
 **********************************************************************/

void find_cblob_hlimits(                //get x limits
                        C_BLOB *blob,   //blob to search
                        float bottomy,  //y limits
                        float topy,
                        float &xmin,    //output x limits
                        float &xmax)
{
  inT16 stepindex;               //current point
  ICOORD pos;                    //current coords
  ICOORD vec;                    //rotated step
  C_OUTLINE *outline;            //current outline

  //outlines
  C_OUTLINE_IT out_it = blob->out_list ();

  xmin = (float) MAX_INT32;
  xmax = (float) -MAX_INT32;

  for (out_it.mark_cycle_pt (); !out_it.cycled_list (); out_it.forward ())
  {
    outline = out_it.data ();
    pos = outline->start_pos (); //get coords

    for (stepindex = 0; stepindex < outline->pathlength (); stepindex++)
    {
      //inside
      if (pos.y () >= bottomy && pos.y () <= topy)
      {
        if (pos.x () > xmax)
        {
          xmax = pos.x ();
        }

        if (pos.x () < xmin)
        {
          xmin = pos.x ();
        }
      }

      vec = outline->step (stepindex);
      pos += vec;                //move to next
    }
  }
}


/**********************************************************************
 * rotate_blob
 *
 * Poly copy the blob and rotate the copy by the given vector.
 **********************************************************************/

PBLOB *rotate_blob(                 //get y limits
                   PBLOB *blob,     //blob to search
                   FCOORD rotation  //vector to rotate by
                  )
{
  PBLOB *copy;                   //copy of blob
  POLYPT *polypt;                //current point
  OUTLINE_IT out_it;
  POLYPT_IT poly_it;             //outline pts

  copy = new PBLOB;
  *copy = *blob;                 //deep copy
  out_it.set_to_list (copy->out_list ());

  for (out_it.mark_cycle_pt (); !out_it.cycled_list (); out_it.forward ())
  {
    //get points
    poly_it.set_to_list (out_it.data ()->polypts ());
    for (poly_it.mark_cycle_pt (); !poly_it.cycled_list (); poly_it.forward ())
    {
      polypt = poly_it.data ();

      //rotate it
      polypt->pos.rotate (rotation);
      polypt->vec.rotate (rotation);
    }
    out_it.data ()->compute_bb ();
  }
  return copy;
}


/**********************************************************************
 * rotate_cblob
 *
 * Poly copy the blob and rotate the copy by the given vector.
 **********************************************************************/

PBLOB *rotate_cblob(                 //rotate it
                    C_BLOB *blob,    //blob to search
                    float xheight,   //for poly approx
                    FCOORD rotation  //for landscape
                   )
{
  PBLOB *copy;                   //copy of blob
  POLYPT *polypt;                //current point
  OUTLINE_IT out_it;
  POLYPT_IT poly_it;             //outline pts

  copy = new PBLOB (blob, xheight);
  out_it.set_to_list (copy->out_list ());
  for (out_it.mark_cycle_pt (); !out_it.cycled_list (); out_it.forward ())
  {
    //get points
    poly_it.set_to_list (out_it.data ()->polypts ());

    for (poly_it.mark_cycle_pt (); !poly_it.cycled_list ();poly_it.forward ())
    {
      polypt = poly_it.data ();

      //rotate it
      polypt->pos.rotate (rotation);
      polypt->vec.rotate (rotation);
    }
    out_it.data ()->compute_bb ();
  }
  return copy;
}


/**********************************************************************
 * crotate_cblob
 *
 * Rotate the copy by the given vector and return a C_BLOB.
 **********************************************************************/

C_BLOB *crotate_cblob(                 //rotate it
                      C_BLOB *blob,    //blob to search
                      FCOORD rotation  //for landscape
                     )
{
  C_OUTLINE_LIST out_list;       //output outlines

  //input outlines
  C_OUTLINE_IT in_it = blob->out_list ();

  //output outlines
  C_OUTLINE_IT out_it = &out_list;

  for (in_it.mark_cycle_pt (); !in_it.cycled_list (); in_it.forward ())
  {
    out_it.add_after_then_move (new C_OUTLINE (in_it.data (), rotation));
  }

  return new C_BLOB (&out_list);
}


/**********************************************************************
 * box_next
 *
 * Compute the bounding box of this blob with merging of x overlaps
 * but no pre-chopping.
 * Then move the iterator on to the start of the next blob.
 **********************************************************************/

TBOX box_next(                 //get bounding box
             BLOBNBOX_IT *it  //iterator to blobds
            )
{
  BLOBNBOX *blob;                //current blob
  TBOX result;                    //total box

  blob = it->data ();
  result = blob->bounding_box ();

  do
  {
    it->forward ();
    blob = it->data ();
    if (blob->blob () == NULL && blob->cblob () == NULL)
    {
      //was pre-chopped
      result += blob->bounding_box ();
    }
  }

  //until next real blob
  while ((blob->blob () == NULL && blob->cblob () == NULL) || blob->joined_to_prev ());

  return result;
}


/**********************************************************************
 * box_next_pre_chopped
 *
 * Compute the bounding box of this blob with merging of x overlaps
 * but WITH pre-chopping.
 * Then move the iterator on to the start of the next pre-chopped blob.
 **********************************************************************/

TBOX box_next_pre_chopped(                 //get bounding box
                         BLOBNBOX_IT *it  //iterator to blobds
                        )
{
  BLOBNBOX *blob;                //current blob
  TBOX result;                    //total box

  blob = it->data ();
  result = blob->bounding_box ();
  do
  {
    it->forward ();
    blob = it->data ();
  }

  //until next real blob
  while (blob->joined_to_prev ());

  return result;
}


/**********************************************************************
 * TO_ROW::TO_ROW
 *
 * Constructor to make a row from a blob.
 **********************************************************************/

TO_ROW::TO_ROW (                 //constructor
BLOBNBOX * blob,                 //first blob
float top,                       //corrected top
float bottom,                    //of row
float row_size                   //ideal
): y_min(bottom), y_max(top), initial_y_min(bottom), num_repeated_sets_(-1)
{
  float diff;                    //in size
  BLOBNBOX_IT it = &blobs;       //list of blobs

  it.add_to_end (blob);
  diff = top - bottom - row_size;
  if (diff > 0)
  {
    y_max -= diff / 2;
    y_min += diff / 2;
  }
  else if ((top - bottom) * 3 < row_size) //very small object
  {
    diff = row_size / 3 + bottom - top;
    y_max += diff / 2;
    y_min -= diff / 2;
  }
}


/**********************************************************************
 * TO_ROW:add_blob
 *
 * Add the blob to the end of the row.
 **********************************************************************/

void TO_ROW::add_blob(                 //constructor
                      BLOBNBOX *blob,  //first blob
                      float top,       //corrected top
                      float bottom,    //of row
                      float row_size   //ideal
                     )
{
  float allowed;                 //allowed expansion
  float available;               //expansion
  BLOBNBOX_IT it = &blobs;       //list of blobs

  it.add_to_end (blob);
  allowed = row_size + y_min - y_max;

  if (allowed > 0)
  {
    available = top > y_max ? top - y_max : 0;
    if (bottom < y_min)
    {
        //total available
        available += y_min - bottom;
    }

    if (available > 0)
    {
      available += available;    //do it gradually

      if (available < allowed)
      {
        available = allowed;
      }

      if (bottom < y_min)
      {
        y_min -= (y_min - bottom) * allowed / available;
      }

      if (top > y_max)
      {
        y_max += (top - y_max) * allowed / available;
      }
    }
  }
}


/**********************************************************************
 * TO_ROW:insert_blob
 *
 * Add the blob to the row in the correct position.
 **********************************************************************/

void TO_ROW::insert_blob(                //constructor
                         BLOBNBOX *blob  //first blob
                        )
{
  BLOBNBOX_IT it = &blobs;       //list of blobs

  if (it.empty ())
  {
    it.add_before_then_move (blob);
  }
  else
  {
    it.mark_cycle_pt ();

    while (!it.cycled_list()&& it.data()->bounding_box().left() <= blob->bounding_box().left())
    {
      it.forward ();
    }

    if (it.cycled_list ())
    {
      it.add_to_end (blob);
    }
    else
    {
      it.add_before_stay_put (blob);
    }
  }
}


/**********************************************************************
 * TO_ROW::compute_vertical_projection
 *
 * Compute the vertical projection of a TO_ROW from its blobs.
 **********************************************************************/

void TO_ROW::compute_vertical_projection()
{
  //project whole row
  TBOX row_box;                   //bound of row
  BLOBNBOX *blob;                //current blob
  TBOX blob_box;                  //bounding box
  BLOBNBOX_IT blob_it = blob_list ();

  if (blob_it.empty ()) return;

  row_box = blob_it.data ()->bounding_box ();

  for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ())
  {
    row_box += blob_it.data ()->bounding_box ();
  }

  projection.set_range(row_box.left() - PROJECTION_MARGIN, row_box.right() + PROJECTION_MARGIN);
  projection_left = row_box.left() - PROJECTION_MARGIN;
  projection_right = row_box.right() + PROJECTION_MARGIN;

  for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward())
  {
    blob = blob_it.data();

    if (blob->blob() != NULL)
    {
      vertical_blob_projection (blob->blob(), &projection);
    }
    else if (blob->cblob() != NULL)
    {
      vertical_cblob_projection(blob->cblob(), &projection);
    }
  }
}


/**********************************************************************
 * vertical_blob_projection
 *
 * Compute the vertical projection of a blob from its outlines
 * and add to the given STATS.
 **********************************************************************/

void vertical_blob_projection(              //project outlines
                              PBLOB *blob,  //blob to project
                              STATS *stats  //output
                             )
{
  //outlines of blob
  OUTLINE_IT out_it = blob->out_list ();

  for (out_it.mark_cycle_pt (); !out_it.cycled_list (); out_it.forward ())
  {
    vertical_outline_projection (out_it.data (), stats);
  }
}


/**********************************************************************
 * vertical_outline_projection
 *
 * Compute the vertical projection of a outline from its outlines
 * and add to the given STATS.
 **********************************************************************/

void vertical_outline_projection(                   //project outlines
                                 OUTLINE *outline,  //outline to project
                                 STATS *stats       //output
                                )
{
  POLYPT *polypt;                //current point
  inT32 xcoord;                  //current pixel coord
  float end_x;                   //end of vec
  POLYPT_IT poly_it = outline->polypts ();
  OUTLINE_IT out_it = outline->child ();
  float ymean;                   //amount to add
  float width;                   //amount of x

  for (poly_it.mark_cycle_pt (); !poly_it.cycled_list (); poly_it.forward ())
  {
    polypt = poly_it.data ();
    end_x = polypt->pos.x () + polypt->vec.x ();

    if (polypt->vec.x () > 0)
    {
      for (xcoord = (inT32) floor (polypt->pos.x ()); xcoord < end_x; xcoord++)
      {
        if (polypt->pos.x () < xcoord)
        {
          width = (float) xcoord;
          ymean = polypt->vec.y() * (xcoord - polypt->pos.x()) / polypt->vec.x() + polypt->pos.y();
        }
        else
        {
          width = polypt->pos.x ();
          ymean = polypt->pos.y ();
        }

        if (end_x > xcoord + 1)
        {
          width -= xcoord + 1;
          ymean += polypt->vec.y() * (xcoord + 1 - polypt->pos.x()) / polypt->vec.x() + polypt->pos.y();
        }
        else
        {
          width -= end_x;
          ymean += polypt->pos.y () + polypt->vec.y ();
        }

        ymean = ymean * width / 2;
        stats->add(xcoord, (inT32)floor (ymean + 0.5));
      }
    }
    else if (polypt->vec.x () < 0)
    {
      for (xcoord = (inT32)floor(end_x); xcoord < polypt->pos.x(); xcoord++)
      {
        if (polypt->pos.x () > xcoord + 1)
        {
          width = xcoord + 1.0f;
          ymean = polypt->vec.y() * (xcoord + 1 - polypt->pos.x()) / polypt->vec.x() + polypt->pos.y();
        }
        else
        {
          width = polypt->pos.x();
          ymean = polypt->pos.y();
        }

        if (end_x < xcoord)
        {
          width -= xcoord;
          ymean += polypt->vec.y() * (xcoord - polypt->pos.x()) / polypt->vec.x() + polypt->pos.y();
        }
        else
        {
          width -= end_x;
          ymean += polypt->pos.y() + polypt->vec.y();
        }

        ymean = ymean * width / 2;
        stats->add (xcoord, (inT32) floor (ymean + 0.5));
      }
    }
  }

  for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward())
  {
    vertical_outline_projection (out_it.data (), stats);
  }
}


/**********************************************************************
 * vertical_cblob_projection
 *
 * Compute the vertical projection of a cblob from its outlines
 * and add to the given STATS.
 **********************************************************************/

void vertical_cblob_projection(               //project outlines
                               C_BLOB *blob,  //blob to project
                               STATS *stats   //output
                              )
{
                                 //outlines of blob
  C_OUTLINE_IT out_it = blob->out_list();

  for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward())
  {
    vertical_coutline_projection (out_it.data (), stats);
  }
}


/**********************************************************************
 * vertical_coutline_projection
 *
 * Compute the vertical projection of a outline from its outlines
 * and add to the given STATS.
 **********************************************************************/

void vertical_coutline_projection(                     //project outlines
                                  C_OUTLINE *outline,  //outline to project
                                  STATS *stats         //output
                                 )
{
  ICOORD pos;                    //current point
  ICOORD step;                   //edge step
  inT32 length;                  //of outline
  inT16 stepindex;               //current step
  C_OUTLINE_IT out_it = outline->child();

  pos = outline->start_pos();
  length = outline->pathlength();

  for (stepindex = 0; stepindex < length; stepindex++)
  {
    step = outline->step(stepindex);

    if (step.x() > 0)
    {
      if (pitsync_projection_fix)
      {
        stats->add(pos.x(), -pos.y());
      }
      else
      {
        stats->add(pos.x(), pos.y());
      }
    }
    else if (step.x() < 0)
    {
      if (pitsync_projection_fix)
      {
        stats->add(pos.x() - 1, pos.y());
      }
      else
      {
        stats->add(pos.x() - 1, -pos.y());
      }
    }

    pos += step;
  }

  for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward())
  {
    vertical_coutline_projection(out_it.data(), stats);
  }
}


/**********************************************************************
 * TO_BLOCK::TO_BLOCK
 *
 * Constructor to make a TO_BLOCK from a real block.
 **********************************************************************/

TO_BLOCK::TO_BLOCK(                  //make a block
                   BLOCK *src_block  //real block
                  )
{
  block = src_block;
}

static void clear_blobnboxes(BLOBNBOX_LIST* boxes)
{
  BLOBNBOX_IT it = boxes;

  // A BLOBNBOX generally doesn't own its blobs, so if they do, you
  // have to delete them explicitly.
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
  {
    BLOBNBOX* box = it.data();

    if (box->blob() != NULL)
    {
      delete box->blob();
    }

    if (box->cblob() != NULL)
    {
      delete box->cblob();
    }
  }
}

TO_BLOCK::~TO_BLOCK()
{
  // Any residual BLOBNBOXes at this stage own their blobs, so delete them.
  clear_blobnboxes(&blobs);
  clear_blobnboxes(&underlines);
  clear_blobnboxes(&noise_blobs);
  clear_blobnboxes(&small_blobs);
  clear_blobnboxes(&large_blobs);
}

#ifndef GRAPHICS_DISABLED
// Draw the blobs on the various lists in the block in different colors.
void TO_BLOCK::plot_graded_blobs(ScrollView* to_win)
{
  plot_blob_list(to_win, &noise_blobs, ScrollView::CORAL, ScrollView::BLUE);
  plot_blob_list(to_win, &small_blobs, ScrollView::GOLDENROD, ScrollView::YELLOW);
  plot_blob_list(to_win, &large_blobs, ScrollView::DARK_GREEN, ScrollView::YELLOW);
  plot_blob_list(to_win, &blobs, ScrollView::WHITE, ScrollView::BROWN);
}

/**********************************************************************
 * plot_blob_list
 *
 * Draw a list of blobs.
 **********************************************************************/

void plot_blob_list(ScrollView* win,                   // window to draw in
                    BLOBNBOX_LIST *list,               // blob list
                    ScrollView::Color body_colour,     // colour to draw
                    ScrollView::Color child_colour)
{
  // colour of child
  BLOBNBOX_IT it = list;

  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
  {
    it.data()->plot(win, body_colour, child_colour);
  }
}

#endif //GRAPHICS_DISABLED
/////////////////////////////////////////////////////////////////blobbox////////////////////////////////////////

/////////////////////////////////////////////////////////////////lmedsq////////////////////////////////////////
#define EXTERN
EXTERN INT_VAR (lms_line_trials, 12, "Number of linew fits to do");
#define SEED1       0x1234       //default seeds
#define SEED2       0x5678
#define SEED3       0x9abc
#define LMS_MAX_FAILURES  3

#ifndef __UNIX1__
//get random number  //seeds to use
uinT32 _nrand48(uinT16 *seeds)
{
  static uinT32 seed = 0;        //only seed

  if (seed == 0)
  {
    seed = seeds[0] ^ (seeds[1] << 8) ^ (seeds[2] << 16);

    srand(seed);
  }
                                 //make 32 bit one
  return rand () | (rand () << 16);
}
#endif

/**********************************************************************
 * LMS::LMS
 *
 * Construct a LMS class, given the max no of samples to be given
 **********************************************************************/
         //samplesize
LMS::LMS(inT32 size):samplesize (size)
{
  samplecount = 0;
  a = 0;
  m = 0.0f;
  c = 0.0f;

  samples = (FCOORD *) alloc_mem (size * sizeof (FCOORD));
  errors = (float *) alloc_mem (size * sizeof (float));

  line_error = 0.0f;
  fitted = FALSE;
}


/**********************************************************************
 * LMS::~LMS
 *
 * Destruct a LMS class.
 **********************************************************************/
//constructor
LMS::~LMS ()
{
  free_mem(samples);
  free_mem(errors);
}


/**********************************************************************
 * LMS::clear
 *
 * Clear samples from array.
 **********************************************************************/
void LMS::clear()
{
  //clear sample
  samplecount = 0;
  fitted = FALSE;
}


/**********************************************************************
 * LMS::add
 *
 * Add another sample. More than the constructed number will be ignored.
 **********************************************************************/
//add sample  //sample coords
void LMS::add(FCOORD sample)
{
  if (samplecount < samplesize)
  {
    //save it
    samples[samplecount++] = sample;
  }

  fitted = FALSE;
}


/**********************************************************************
 * LMS::fit
 *
 * Fit a line to the given sample points.
 **********************************************************************/
//fit sample  //output line
void LMS::fit(float &out_m,float &out_c)
{
  inT32 index;                   //of median
  inT32 trials;                  //no of medians
  float test_m, test_c;          //candidate line
  float test_error;              //error of test line

  switch (samplecount)
  {
    case 0:
      m = 0.0f;                  //no info
      c = 0.0f;
      line_error = 0.0f;
      break;
    case 1:
      m = 0.0f;
      c = samples[0].y();       //horiz thru pt
      line_error = 0.0f;
      break;
    case 2:
      if (samples[0].x() != samples[1].x())
      {
        m = (samples[1].y() - samples[0].y()) / (samples[1].x() - samples[0].x());
        c = samples[0].y() - m * samples[0].x();
      }
      else
      {
        m = 0.0f;
        c = (samples[0].y() + samples[1].y()) / 2;
      }
      line_error = 0.0f;
      break;
    default:
      pick_line(m, c);  //use pts at random
      compute_errors(m, c);  //from given line
      index = choose_nth_item(samplecount / 2, errors, samplecount);
      line_error = errors[index];

      for (trials = 1; trials < lms_line_trials; trials++)
      {
        //random again
        pick_line(test_m, test_c);
        compute_errors(test_m, test_c);
        index = choose_nth_item (samplecount / 2, errors, samplecount);
        test_error = errors[index];

        if (test_error < line_error)
        {
          //find least median
          line_error = test_error;
          m = test_m;
          c = test_c;
        }
      }
  }
  fitted = TRUE;
  out_m = m;
  out_c = c;
  a = 0;
}


/**********************************************************************
 * LMS::fit_quadratic
 *
 * Fit a quadratic to the given sample points.
 **********************************************************************/

void LMS::fit_quadratic(                          //fit sample
                        float outlier_threshold,  //min outlier size
                        double &out_a,            //x squared
                        float &out_b,             //output line
                        float &out_c)
{
  inT32 trials;                  //no of medians
  double test_a;
  float test_b, test_c;          //candidate line
  float test_error;              //error of test line

  if (samplecount < 3)
  {
    out_a = 0;
    fit(out_b, out_c);

    return;
  }
  pick_quadratic(a, m, c);
  line_error = compute_quadratic_errors (outlier_threshold, a, m, c);

  for (trials = 1; trials < lms_line_trials * 2; trials++)
  {
    pick_quadratic(test_a, test_b, test_c);
    test_error = compute_quadratic_errors (outlier_threshold, test_a, test_b, test_c);

    if (test_error < line_error)
    {
      line_error = test_error;   //find least median
      a = test_a;
      m = test_b;
      c = test_c;
    }
  }

  fitted = TRUE;
  out_a = a;
  out_b = m;
  out_c = c;
}


/**********************************************************************
 * LMS::constrained_fit
 *
 * Fit a line to the given sample points.
 * The line must have the given gradient.
 **********************************************************************/

void LMS::constrained_fit(                //fit sample
                          float fixed_m,  //forced gradient
                          float &out_c)
{
  inT32 index;                   //of median
  inT32 trials;                  //no of medians
  float test_c;                  //candidate line
  static uinT16 seeds[3] = { SEED1, SEED2, SEED3 };
  //for nrand
  float test_error;              //error of test line

  m = fixed_m;
  switch (samplecount)
  {
    case 0:
      c = 0.0f;
      line_error = 0.0f;
      break;
    case 1:
      //horiz thru pt
      c = samples[0].y () - m * samples[0].x ();
      line_error = 0.0f;
      break;
    case 2:
      c = (samples[0].y () + samples[1].y () - m * (samples[0].x () + samples[1].x ())) / 2;
      line_error = m * samples[0].x () + c - samples[0].y ();
      line_error *= line_error;
      break;
    default:
      index = (inT32)nrand48(seeds) % samplecount;

      //compute line
      c = samples[index].y () - m * samples[index].x ();
      compute_errors(m, c);  //from given line
      index = choose_nth_item (samplecount / 2, errors, samplecount);
      line_error = errors[index];

      for (trials = 1; trials < lms_line_trials; trials++)
      {
        index = (inT32) nrand48 (seeds) % samplecount;
        test_c = samples[index].y () - m * samples[index].x ();

        //compute line
        compute_errors(m, test_c);
        index = choose_nth_item (samplecount / 2, errors, samplecount);
        test_error = errors[index];

        if (test_error < line_error)
        {
          //find least median
          line_error = test_error;
          c = test_c;
        }
      }
  }
  fitted = TRUE;
  out_c = c;
  a = 0;
}


/**********************************************************************
 * LMS::pick_line
 *
 * Fit a line to a random pair of sample points.
 **********************************************************************/

void LMS::pick_line(                //fit sample
                    float &line_m,  //output gradient
                    float &line_c)
{
  inT16 trial_count;             //no of attempts
  static uinT16 seeds[3] = {SEED1, SEED2, SEED3};

  //for nrand
  inT32 index1;                  //picked point
  inT32 index2;                  //picked point

  trial_count = 0;
  do
  {
    index1 = (inT32)nrand48(seeds) % samplecount;
    index2 = (inT32)nrand48(seeds) % samplecount;
    line_m = samples[index2].x () - samples[index1].x ();
    trial_count++;
  }
  while (line_m == 0 && trial_count < LMS_MAX_FAILURES);

  if (line_m == 0)
  {
    line_c = (samples[index2].y () + samples[index1].y ()) / 2;
  }
  else
  {
    line_m = (samples[index2].y () - samples[index1].y ()) / line_m;
    line_c = samples[index1].y () - samples[index1].x () * line_m;
  }
}


/**********************************************************************
 * LMS::pick_quadratic
 *
 * Fit a quadratic to a random triplet of sample points.
 **********************************************************************/

void LMS::pick_quadratic(                 //fit sample
                         double &line_a,  //x suaread
                         float &line_m,   //output gradient
                         float &line_c)
{
  inT16 trial_count;             //no of attempts
  static uinT16 seeds[3] = { SEED1, SEED2, SEED3 };

  //for nrand
  inT32 index1;                  //picked point
  inT32 index2;                  //picked point
  inT32 index3;
  FCOORD x1x2;                   //vector
  FCOORD x1x3;
  FCOORD x3x2;
  double bottom;                 //of a

  trial_count = 0;

  do
  {
    if (trial_count >= LMS_MAX_FAILURES - 1)
    {
      index1 = 0;
      index2 = samplecount / 2;
      index3 = samplecount - 1;
    }
    else
    {
      index1 = (inT32) nrand48 (seeds) % samplecount;
      index2 = (inT32) nrand48 (seeds) % samplecount;
      index3 = (inT32) nrand48 (seeds) % samplecount;
    }

    x1x2 = samples[index2] - samples[index1];
    x1x3 = samples[index3] - samples[index1];
    x3x2 = samples[index2] - samples[index3];
    bottom = x1x2.x () * x1x3.x () * x3x2.x ();
    trial_count++;
  }
  while (bottom == 0 && trial_count < LMS_MAX_FAILURES);

  if (bottom == 0)
  {
    line_a = 0;
    pick_line(line_m, line_c);
  }
  else
  {
    line_a = x1x3 * x1x2 / bottom;
    line_m = x1x2.y () - line_a * x1x2.x () * (samples[index2].x () + samples[index1].x ());
    line_m /= x1x2.x ();
    line_c = samples[index1].y () - samples[index1].x () * (samples[index1].x () * line_a + line_m);
  }
}


/**********************************************************************
 * LMS::compute_errors
 *
 * Compute the squared error from all the points.
 **********************************************************************/
//fit sample             //input gradient
void LMS::compute_errors(float line_m, float line_c)
{
  inT32 index;                   //picked point

  for (index = 0; index < samplecount; index++)
  {
    errors[index] = line_m * samples[index].x() + line_c - samples[index].y();
    errors[index] *= errors[index];
  }
}


/**********************************************************************
 * LMS::compute_quadratic_errors
 *
 * Compute the squared error from all the points.
 **********************************************************************/

float LMS::compute_quadratic_errors(                          //fit sample
                                    float outlier_threshold,  //min outlier
                                    double line_a,
                                    float line_m,             //input gradient
                                    float line_c)
{
  inT32 outlier_count;           //total outliers
  inT32 index;                   //picked point
  inT32 error_count;             //no in total
  double total_error;            //summed squares

  total_error = 0;
  outlier_count = 0;
  error_count = 0;

  for (index = 0; index < samplecount; index++)
  {
    errors[error_count] = line_c + samples[index].x () * (line_m + samples[index].x () * line_a) - samples[index].y ();
    errors[error_count] *= errors[error_count];
    if (errors[error_count] > outlier_threshold)
    {
      outlier_count++;
      errors[samplecount - outlier_count] = errors[error_count];
    }
    else
    {
      total_error += errors[error_count++];
    }
  }

  if (outlier_count * 3 < error_count)
  {
    return total_error / error_count;
  }
  else {

    index = choose_nth_item (outlier_count / 2, errors + samplecount - outlier_count, outlier_count);

    //median outlier
    return errors[samplecount - outlier_count + index];
  }
}


/**********************************************************************
 * LMS::plot
 *
 * Plot the fitted line of a LMS.
 **********************************************************************/

#ifndef GRAPHICS_DISABLED
//plot fit     //window         //colour to draw in
void LMS::plot(ScrollView* win, ScrollView::Color colour)
{
  if (fitted)
  {
    win->Pen(colour);
    win->SetCursor(samples[0].x (), c + samples[0].x () * (m + samples[0].x () * a));
    win->DrawTo(samples[samplecount - 1].x (), c + samples[samplecount - 1].x () * (m + samples[samplecount -1].x () * a));
  }
}
#endif
/////////////////////////////////////////////////////////////////lmedsq////////////////////////////////////////

/////////////////////////////////////////////////////////////////fpchop////////////////////////////////////////
#define EXTERN
EXTERN INT_VAR (textord_fp_chop_error, 2,
"Max allowed bending of chop cells");
EXTERN double_VAR (textord_fp_chop_snap, 0.5,
"Max distance of chop pt from vertex");

ELISTIZE (OUTLINE_FRAG) ELISTIZE (C_OUTLINE_FRAG)
//#undef ASSERT_HOST
//#define ASSERT_HOST(x) if (!(x)) AfxMessageBox(#x);
/**********************************************************************
 * fixed_pitch_words
 *
 * Make a ROW from a fixed pitch TO_ROW.
 **********************************************************************/
ROW *fixed_pitch_words(                 //find lines
                       TO_ROW *row,     //row to do
                       FCOORD rotation  //for drawing
                      ) {
  Q_UNUSED(rotation);
  BOOL8 bol;                     //start of line
  uinT8 blanks;                  //in front of word
  uinT8 new_blanks;              //blanks in empty cell
  inT16 chop_coord;              //chop boundary
  inT16 prev_chop_coord;         //start of cell
  inT16 rep_left;                //left edge of rep word
  ROW *real_row;                 //output row
  OUTLINE_LIST left_outlines;    //in current blob
  OUTLINE_LIST right_outlines;   //for next blob
  C_OUTLINE_LIST left_coutlines;
  C_OUTLINE_LIST right_coutlines;
  PBLOB_LIST blobs;              //blobs in word
  C_BLOB_LIST cblobs;
  PBLOB_IT blob_it = &blobs;     //iterator
  C_BLOB_IT cblob_it = &cblobs;
  WERD_LIST words;
  WERD_IT word_it = &words;      //new words
                                 //repeated blobs
  WERD_IT rep_it = &row->rep_words;
  WERD *word;                    //new word
  inT32 xstarts[2];              //row ends
  inT32 prev_x;                  //end of prev blob
                                 //iterator
  BLOBNBOX_IT box_it = row->blob_list ();
                                 //boundaries
  ICOORDELT_IT cell_it = &row->char_cells;

#ifndef GRAPHICS_DISABLED
  if (textord_show_page_cuts && to_win != NULL) {
    plot_row_cells (to_win, ScrollView::RED, row, 0, &row->char_cells);
  }
#endif

  prev_x = -MAX_INT16;
  bol = TRUE;
  blanks = 0;
  if (rep_it.empty ())
    rep_left = MAX_INT16;
  else
    rep_left = rep_it.data ()->bounding_box ().left ();
  if (box_it.empty ())
    return NULL;                 //empty row
  xstarts[0] = box_it.data ()->bounding_box ().left ();
  if (rep_left < xstarts[0]) {
    xstarts[0] = rep_left;
  }
  if (cell_it.empty () || row->char_cells.singleton ()) {
    tprintf ("Row without enough char cells!\n");
    tprintf ("Leftmost blob is at (%d,%d)\n",
      box_it.data ()->bounding_box ().left (),
      box_it.data ()->bounding_box ().bottom ());
    return NULL;
  }
  ASSERT_HOST (!cell_it.empty () && !row->char_cells.singleton ());
  prev_chop_coord = cell_it.data ()->x ();
  word = NULL;
  while (rep_left < cell_it.data ()->x ()) {
    word = add_repeated_word (&rep_it, rep_left, prev_chop_coord,
      blanks, row->fixed_pitch, &word_it);
  }
  cell_it.mark_cycle_pt ();
  if (prev_chop_coord >= cell_it.data ()->x ())
    cell_it.forward ();
  for (; !cell_it.cycled_list (); cell_it.forward ()) {
    chop_coord = cell_it.data ()->x ();
    while (!box_it.empty ()
    && box_it.data ()->bounding_box ().left () <= chop_coord) {
      if (box_it.data ()->bounding_box ().right () > prev_x)
        prev_x = box_it.data ()->bounding_box ().right ();
      split_to_blob (box_it.extract (), chop_coord,
        textord_fp_chop_error + 0.5f,
        &left_outlines, &left_coutlines,
        &right_outlines, &right_coutlines);
      box_it.forward ();
      while (!box_it.empty ()
        && box_it.data ()->blob () == NULL
      && box_it.data ()->cblob () == NULL) {
        delete box_it.extract ();
        box_it.forward ();
      }
    }
    if ((!right_outlines.empty () || !right_coutlines.empty ())
      && left_outlines.empty () && left_coutlines.empty ())
      split_to_blob (NULL, chop_coord,
        textord_fp_chop_error + 0.5f,
        &left_outlines, &left_coutlines,
        &right_outlines, &right_coutlines);
    if (!left_outlines.empty ())
      blob_it.add_after_then_move (new PBLOB (&left_outlines));
    else if (!left_coutlines.empty ())
      cblob_it.add_after_then_move (new C_BLOB (&left_coutlines));
    else {
      if (rep_left < chop_coord) {
        if (rep_left > prev_chop_coord)
          new_blanks = (uinT8) floor ((rep_left - prev_chop_coord)
            / row->fixed_pitch + 0.5);
        else
          new_blanks = 0;
      }
      else {
        if (chop_coord > prev_chop_coord)
          new_blanks = (uinT8) floor ((chop_coord - prev_chop_coord)
            / row->fixed_pitch + 0.5);
        else
          new_blanks = 0;
      }
      if (!blob_it.empty () || !cblob_it.empty ()) {
        if (blanks < 1 && word != NULL && !word->flag (W_REP_CHAR))
          blanks = 1;
        if (!blob_it.empty ()) {
                                 //make real word
          word = new WERD (&blobs, blanks, NULL);
          blob_it.set_to_list (&blobs);
        }
        else {
          word = new WERD (&cblobs, blanks, NULL);
          cblob_it.set_to_list (&cblobs);
        }
        word->set_flag (W_DONT_CHOP, TRUE);
        word_it.add_after_then_move (word);
        if (bol) {
          word->set_flag (W_BOL, TRUE);
          bol = FALSE;
        }
        blanks = new_blanks;
      }
      else
        blanks += new_blanks;
      while (rep_left < chop_coord) {
        word = add_repeated_word (&rep_it, rep_left, prev_chop_coord,
          blanks, row->fixed_pitch, &word_it);
      }
    }
    if (prev_chop_coord < chop_coord)
      prev_chop_coord = chop_coord;
  }
  if (!blob_it.empty () || !cblob_it.empty ()) {
    if (!blob_it.empty ())
                                 //last word on line
      word = new WERD (&blobs, blanks, NULL);
    else
      word = new WERD (&cblobs, blanks, NULL);
    word->set_flag (W_DONT_CHOP, TRUE);
    word_it.add_after_then_move (word);
    if (bol)
      word->set_flag (W_BOL, TRUE);
  }
  ASSERT_HOST (word != NULL);
  while (!rep_it.empty ()) {
    add_repeated_word (&rep_it, rep_left, prev_chop_coord,
      blanks, row->fixed_pitch, &word_it);
  }
                                 //at end of line
  word_it.data ()->set_flag (W_EOL, TRUE);
  if (prev_chop_coord > prev_x)
    prev_x = prev_chop_coord;
  xstarts[1] = prev_x + 1;
  real_row = new ROW (row, (inT16) row->kern_size, (inT16) row->space_size);
  word_it.set_to_list (real_row->word_list ());
                                 //put words in row
  word_it.add_list_after (&words);
  real_row->recalc_bounding_box ();
  return real_row;
}


/**********************************************************************
 * add_repeated_word
 *
 * Add repeated word into the row at the given point.
 **********************************************************************/

WERD *add_repeated_word(                         //move repeated word
                        WERD_IT *rep_it,         //repeated words
                        inT16 &rep_left,         //left edge of word
                        inT16 &prev_chop_coord,  //previous word end
                        uinT8 &blanks,           //no of blanks
                        float pitch,             //char cell size
                        WERD_IT *word_it         //list of words
                       ) {
  WERD *word;                    //word to move
  inT16 new_blanks;              //extra blanks

  if (rep_left > prev_chop_coord) {
    new_blanks = (uinT8) floor ((rep_left - prev_chop_coord) / pitch + 0.5);
    blanks += new_blanks;
  }
  word = rep_it->extract ();
  prev_chop_coord = word->bounding_box ().right ();
  word_it->add_after_then_move (word);
  word->set_blanks (blanks);
  rep_it->forward ();
  if (rep_it->empty ())
    rep_left = MAX_INT16;
  else
    rep_left = rep_it->data ()->bounding_box ().left ();
  blanks = 0;
  return word;
}


/**********************************************************************
 * split_to_blob
 *
 * Split a BLOBNBOX across a vertical chop line and put the pieces
 * into a left outline list and a right outline list.
 **********************************************************************/

void split_to_blob(                                 //split the blob
                   BLOBNBOX *blob,                  //blob to split
                   inT16 chop_coord,                //place to chop
                   float pitch_error,               //allowed deviation
                   OUTLINE_LIST *left_outlines,     //left half of chop
                   C_OUTLINE_LIST *left_coutlines,  //for cblobs
                   OUTLINE_LIST *right_outlines,    //right half of chop
                   C_OUTLINE_LIST *right_coutlines) {
  PBLOB *real_blob;              //blob to chop
  C_BLOB *real_cblob;            //cblob to chop

  if (blob != NULL) {
    real_blob = blob->blob ();
    real_cblob = blob->cblob ();
  }
  else {
    real_blob = NULL;
    real_cblob = NULL;
  }
  if (!right_outlines->empty () || real_blob != NULL)
    fixed_chop_blob(real_blob,
                    chop_coord,
                    pitch_error,
                    left_outlines,
                    right_outlines);
  else if (!right_coutlines->empty () || real_cblob != NULL)
    fixed_chop_cblob(real_cblob,
                     chop_coord,
                     pitch_error,
                     left_coutlines,
                     right_coutlines);
  if (blob != NULL)
    delete blob;                 //free it
}


/**********************************************************************
 * fixed_chop_blob
 *
 * Chop the given blob (if any) and the existing right outlines to
 * produce a list of outlines left of the chop point and more to the right.
 **********************************************************************/

void fixed_chop_blob(                              //split the blob
                     PBLOB *blob,                  //blob to split
                     inT16 chop_coord,             //place to chop
                     float pitch_error,            //allowed deviation
                     OUTLINE_LIST *left_outlines,  //left half of chop
                     OUTLINE_LIST *right_outlines  //right half of chop
                    ) {
  OUTLINE *old_right;            //already there
  OUTLINE_LIST new_outlines;     //new right ones
                                 //ouput iterator
  OUTLINE_IT left_it = left_outlines;
                                 //in/out iterator
  OUTLINE_IT right_it = right_outlines;
  OUTLINE_IT new_it = &new_outlines;
  OUTLINE_IT blob_it;            //outlines in blob

  if (!right_it.empty ()) {
    while (!right_it.empty ()) {
      old_right = right_it.extract ();
      right_it.forward ();
      fixed_split_outline(old_right,
                          chop_coord,
                          pitch_error,
                          &left_it,
                          &new_it);
    }
    right_it.add_list_before (&new_outlines);
  }
  if (blob != NULL) {
    blob_it.set_to_list (blob->out_list ());
    for (blob_it.mark_cycle_pt (); !blob_it.cycled_list ();
      blob_it.forward ())
    fixed_split_outline (blob_it.extract (), chop_coord, pitch_error,
        &left_it, &right_it);
    delete blob;
  }
}


/**********************************************************************
 * fixed_split_outline
 *
 * Chop the given outline (if necessary) placing the fragments which
 * fall either side of the chop line into the appropriate list.
 **********************************************************************/

void fixed_split_outline(                      //chop the outline
                         OUTLINE *srcline,     //source outline
                         inT16 chop_coord,     //place to chop
                         float pitch_error,    //allowed deviation
                         OUTLINE_IT *left_it,  //left half of chop
                         OUTLINE_IT *right_it  //right half of chop
                        ) {
  OUTLINE *child;                //child outline
  TBOX srcbox;                    //box of outline
  OUTLINE_LIST left_ch;          //left children
  OUTLINE_LIST right_ch;         //right children
  OUTLINE_FRAG_LIST left_frags;  //chopped fragments
  OUTLINE_FRAG_LIST right_frags;;
  OUTLINE_IT left_ch_it = &left_ch;
                                 //for whole children
  OUTLINE_IT right_ch_it = &right_ch;
                                 //for holes
  OUTLINE_IT child_it = srcline->child ();

  srcbox = srcline->bounding_box ();
                                 //left of line
  if (srcbox.left () + srcbox.right () <= chop_coord * 2
                                 //and not far over
    && srcbox.right () < chop_coord + pitch_error)
                                 //stick whole in left
    left_it->add_after_then_move (srcline);
  else if (srcbox.left () + srcbox.right () > chop_coord * 2
    && srcbox.left () > chop_coord - pitch_error)
                                 //stick whole in right
    right_it->add_before_stay_put (srcline);
  else {
                                 //needs real chopping
    if (fixed_chop_outline (srcline, chop_coord, pitch_error,
    &left_frags, &right_frags)) {
      for (child_it.mark_cycle_pt (); !child_it.cycled_list ();
      child_it.forward ()) {
        child = child_it.extract ();
        srcbox = child->bounding_box ();
        if (srcbox.right () < chop_coord)
          left_ch_it.add_after_then_move (child);
        else if (srcbox.left () > chop_coord)
          right_ch_it.add_after_then_move (child);
        else {
          if (fixed_chop_outline (child, chop_coord, pitch_error,
            &left_frags, &right_frags))
            delete child;
          else {
            if (srcbox.left () + srcbox.right () <= chop_coord * 2)
              left_ch_it.add_after_then_move (child);
            else
              right_ch_it.add_after_then_move (child);
          }
        }
      }
      close_chopped_fragments(&left_frags, &left_ch, left_it);
      close_chopped_fragments(&right_frags, &right_ch, right_it);
      ASSERT_HOST (left_ch.empty () && right_ch.empty ());
      //no children left
      delete srcline;            //smashed up
    }
    else {
      if (srcbox.left () + srcbox.right () <= chop_coord * 2)
                                 //stick whole in left
        left_it->add_after_then_move (srcline);
      else
        right_it->add_before_stay_put (srcline);
    }
  }
}


/**********************************************************************
 * fixed_chop_outline
 *
 * Chop the given outline (if necessary) placing the fragments which
 * fall either side of the chop line into the appropriate list.
 * If the outline lies too heavily to one side to chop, FALSE is returned.
 **********************************************************************/

BOOL8 fixed_chop_outline(                                //chop the outline
                         OUTLINE *srcline,               //source outline
                         inT16 chop_coord,               //place to chop
                         float pitch_error,              //allowed deviation
                         OUTLINE_FRAG_LIST *left_frags,  //left half of chop
                         OUTLINE_FRAG_LIST *right_frags  //right half of chop
                        ) {
  BOOL8 not_first;               //fragment
  BOOL8 test_valid;              //test pt valid
  float left_edge;               //of outline
  FCOORD chop_pos;               //coords of chop
  float chop_starty;             //test chop pt
  POLYPT *startpt;               //in first fragment
                                 //general iterator
  POLYPT_IT poly_it = srcline->polypts ();
  POLYPT_IT head_it;             //head of fragment
  POLYPT_IT tail_it;             //tail of fragment
  POLYPT_IT test_tail;           //possible chop pt

  left_edge = poly_it.data ()->pos.x ();
  tail_it = poly_it;
  for (poly_it.mark_cycle_pt (); !poly_it.cycled_list (); poly_it.forward ()) {
    if (poly_it.data ()->pos.x () < left_edge) {
      left_edge = poly_it.data ()->pos.x ();
      tail_it = poly_it;         //find leftmost pt
    }
  }
  if (left_edge >= chop_coord - pitch_error)
    return FALSE;                //not worth it

  startpt = tail_it.data ();
  not_first = FALSE;
  head_it = tail_it;
  chop_starty = tail_it.data ()->pos.y ();
  do {
    test_valid = FALSE;
    do {
      tail_it.forward ();
      if (test_valid
        && tail_it.data ()->pos.x () >= chop_coord
        && tail_it.data ()->pos.x () + tail_it.data ()->vec.x () <=
      chop_coord) {
        chop_pos = find_chop_coords (&tail_it, chop_coord);
        if (chop_pos.y () >= chop_starty)
          test_valid = FALSE;
        else {
          tail_it = test_tail;
          break;                 //must chop there
        }
      }
      if (tail_it.data ()->pos.x () <= chop_coord
        && tail_it.data ()->pos.x () + tail_it.data ()->vec.x () >=
      chop_coord) {
        chop_pos = find_chop_coords (&tail_it, chop_coord);
        chop_starty = chop_pos.y ();
        test_tail = tail_it;     //save possible chop pt
        test_valid = TRUE;
        if (tail_it.data ()->vec.x () == 0
          && tail_it.data ()->vec.y () < 0)
          break;                 //must chop here
      }
    }
    while (tail_it.data () != startpt
      && tail_it.data ()->pos.x () < chop_coord + pitch_error);
                                 //back to start
    if (tail_it.data () == startpt) {
      if (not_first)
        break;
      else
        return FALSE;            //doesn't cross line
    }
    while (tail_it.data ()->pos.x () > chop_coord)
      tail_it.backward ();
    if (head_it.data () == tail_it.data ())
      insert_extra_pt(&tail_it);
    insert_chop_pt(&tail_it, chop_coord);
    if (not_first) {
      save_chop_fragment(&head_it, &tail_it, left_frags);
    }
    else {
      tail_it.forward ();
      head_it = tail_it;
    }
    test_valid = FALSE;
    do {
      tail_it.forward ();
      if (test_valid
        && tail_it.data ()->pos.x () <= chop_coord
        && tail_it.data ()->pos.x () + tail_it.data ()->vec.x () >=
      chop_coord) {
        chop_pos = find_chop_coords (&tail_it, chop_coord);
        if (chop_pos.y () <= chop_starty)
          test_valid = FALSE;
        else {
          tail_it = test_tail;
          break;                 //must chop there
        }
      }
      if (tail_it.data ()->pos.x () >= chop_coord
        && tail_it.data ()->pos.x () + tail_it.data ()->vec.x () <=
      chop_coord) {
        chop_pos = find_chop_coords (&tail_it, chop_coord);
        chop_starty = chop_pos.y ();
        test_tail = tail_it;
        test_valid = TRUE;       //save possible chop pt
        if (tail_it.data ()->vec.x () == 0
          && tail_it.data ()->vec.y () > 0)
          break;                 //must chop here
      }
    }
    while (tail_it.data () != startpt
      && tail_it.data ()->pos.x () > chop_coord - pitch_error);
    while (tail_it.data ()->pos.x () < chop_coord)
      tail_it.backward ();
    if (head_it.data () == tail_it.data ())
      insert_extra_pt(&tail_it);
    insert_chop_pt(&tail_it, chop_coord);
    save_chop_fragment(&head_it, &tail_it, right_frags);
    not_first = TRUE;
  }
  while (tail_it.data () != startpt);
  startpt = head_it.data_relative (-1);
  while (tail_it.data () != startpt)
    tail_it.forward ();
  save_chop_fragment(&head_it, &tail_it, left_frags);
  return TRUE;                   //did some chopping
}


/**********************************************************************
 * save_chop_fragment
 *
 * Store the given fragment in the given fragment list.
 **********************************************************************/

void save_chop_fragment(                          //chop the outline
                        POLYPT_IT *head_it,       //head of fragment
                        POLYPT_IT *tail_it,       //tail of fragment
                        OUTLINE_FRAG_LIST *frags  //fragment list
                       ) {
  OUTLINE_FRAG *head;            //head of fragment
  OUTLINE_FRAG *tail;            //tail of fragment
  float tail_y;                  //ycoord of tail

  tail_y = tail_it->data ()->pos.y ();
  head = new OUTLINE_FRAG (head_it, tail_it);
  tail = new OUTLINE_FRAG (head, tail_y);
  head->other_end = tail;
  add_frag_to_list(head, frags);
  add_frag_to_list(tail, frags);
  head_it->forward ();
  tail_it->forward ();
}


/**********************************************************************
 * OUTLINE_FRAG::OUTLINE_FRAG
 *
 * Constructors for OUTLINE_FRAG.
 **********************************************************************/

OUTLINE_FRAG::OUTLINE_FRAG(                     //record fragment
                           POLYPT_IT *head_it,  //head of fragment
                           POLYPT_IT *tail_it   //tail of fragment
                          ) {
  ycoord = head_it->data ()->pos.y ();
  other_end = NULL;
  polypts.assign_to_sublist (head_it, tail_it);
}


OUTLINE_FRAG::OUTLINE_FRAG(                     //record fragment
                           OUTLINE_FRAG *head,  //other end
                           float tail_y) {
  ycoord = tail_y;
  other_end = head;
}


/**********************************************************************
 * add_frag_to_list
 *
 * Insert the fragment in the list at the appropriate place to keep
 * them in ascending ycoord order.
 **********************************************************************/

void add_frag_to_list(                          //ordered add
                      OUTLINE_FRAG *frag,       //fragment to add
                      OUTLINE_FRAG_LIST *frags  //fragment list
                     ) {
                                 //output list
  OUTLINE_FRAG_IT frag_it = frags;

  if (!frags->empty ()) {
    for (frag_it.mark_cycle_pt (); !frag_it.cycled_list ();
    frag_it.forward ()) {
      if (frag_it.data ()->ycoord >= frag->ycoord) {
        frag_it.add_before_then_move (frag);
        return;
      }
    }
  }
  frag_it.add_to_end (frag);
}


/**********************************************************************
 * insert_chop_pt
 *
 * Decide whether or not to use the actual point as chop coord.
 * Insert either a duplicate of the current point or 2 copies
 * of the new chop point. Position the iterator at the first.
 **********************************************************************/

void insert_chop_pt(                  //make chop
                    POLYPT_IT *it,    //iterator
                    inT16 chop_coord  //required chop pt
                   ) {
  POLYPT *prev_pt;               //point befor chop
  POLYPT *chop_pt;               //new vertex
  FCOORD chop_pos;               //coords of chop
  FCOORD chop_vec;               //vector to next

  prev_pt = it->data ();
  if (prev_pt->pos.x () + textord_fp_chop_snap >= chop_coord
  && prev_pt->pos.x () - textord_fp_chop_snap <= chop_coord) {
    chop_pt = new POLYPT (prev_pt->pos, prev_pt->vec);
  }
  else {
    chop_pos = FCOORD (chop_coord, prev_pt->pos.y ()
      + prev_pt->vec.y () * (chop_coord -
      prev_pt->pos.x ()) /
      prev_pt->vec.x ());
    chop_vec = it->data_relative (1)->pos - chop_pos;
    chop_pt = new POLYPT (chop_pos, chop_vec);
    it->add_after_then_move (chop_pt);
    chop_pt = new POLYPT (chop_pos, chop_vec);
  }
  it->add_after_stay_put (chop_pt);
}


/**********************************************************************
 * find_chop_coords
 *
 * Decide whether or not to use the actual point as chop coord.
 * Return the coords of the chop point.
 **********************************************************************/

FCOORD find_chop_coords(                  //make chop
                        POLYPT_IT *it,    //iterator
                        inT16 chop_coord  //required chop pt
                       ) {
  POLYPT *prev_pt;               //point befor chop
  FCOORD chop_pos;               //coords of chop

  prev_pt = it->data ();
  if (prev_pt->pos.x () + textord_fp_chop_snap >= chop_coord
  && prev_pt->pos.x () - textord_fp_chop_snap <= chop_coord) {
    chop_pos = prev_pt->pos;
  }
  else {
    chop_pos = FCOORD (chop_coord, prev_pt->pos.y ()
      + prev_pt->vec.y () * (chop_coord -
      prev_pt->pos.x ()) /
      prev_pt->vec.x ());
  }
  return chop_pos;
}


/**********************************************************************
 * insert_extra_pt
 *
 * Add an extra pt to prevent single point fragments being made.
 **********************************************************************/

void insert_extra_pt(               //make extra
                     POLYPT_IT *it  //iterator
                    ) {
  POLYPT *prev_pt;               //point befor chop
  POLYPT *chop_pt;               //new vertex
  FCOORD chop_pos;               //coords of chop
  FCOORD chop_vec;               //vector to next

  prev_pt = it->data ();
  if (it->data_relative (1)->pos.y () > it->data_relative (-1)->pos.y ()) {
    chop_pos = prev_pt->pos + FCOORD (0.0f,
                                      static_cast<float>(textord_fp_chop_snap));
  }
  else {
    chop_pos = prev_pt->pos - FCOORD (0.0f,
                                      static_cast<float>(textord_fp_chop_snap));
  }
  chop_vec = it->data_relative (1)->pos - chop_pos;
  prev_pt->vec = chop_pos - prev_pt->pos;
  chop_pt = new POLYPT (chop_pos, chop_vec);
  it->add_after_then_move (chop_pt);
}


/**********************************************************************
 * close_chopped_fragments
 *
 * Clear the given list of fragments joining them up into outlines.
 * Each outline made soaks up any of the child outlines which it encloses.
 **********************************************************************/

void close_chopped_fragments(                           //chop the outline
                             OUTLINE_FRAG_LIST *frags,  //list to clear
                             OUTLINE_LIST *children,    //potential children
                             OUTLINE_IT *dest_it        //output list
                            ) {
                                 //iterator
  OUTLINE_FRAG_IT frag_it = frags;
  OUTLINE_FRAG *bottom_frag;     //bottom of cut
  OUTLINE_FRAG *top_frag;        //top of cut
  OUTLINE *outline;              //new outline
  OUTLINE *child;                //current child
  OUTLINE_IT child_it = children;
  OUTLINE_IT olchild_it;         //children of outline
  POLYPT_IT poly_it;             //iterator for constr

  while (!frag_it.empty ()) {
    frag_it.move_to_first ();
                                 //get bottom one
    bottom_frag = frag_it.extract ();
    frag_it.forward ();
                                 //and one above it
    top_frag = frag_it.extract ();
    while (top_frag->other_end != bottom_frag) {
      do {
        frag_it.forward ();
      }
                                 //find other end
      while (frag_it.data () != top_frag->other_end);
      join_chopped_fragments(bottom_frag, top_frag);
      delete top_frag;
      delete frag_it.extract (); //remove middle section
      frag_it.forward ();
      top_frag = frag_it.extract ();
    }
    join_chopped_fragments(bottom_frag, top_frag);
    if (bottom_frag->polypts.empty ())
      poly_it.set_to_list (&top_frag->polypts);
    else
      poly_it.set_to_list (&bottom_frag->polypts);
    outline = new OUTLINE (&poly_it);
    olchild_it.set_to_list (outline->child ());
    for (child_it.mark_cycle_pt (); !child_it.cycled_list ();
    child_it.forward ()) {
      child = child_it.data ();
      if (*child < *outline)
        olchild_it.add_to_end (child_it.extract ());
    }
    dest_it->add_after_then_move (outline);
  }
  while (!child_it.empty ()) {
    dest_it->add_after_then_move (child_it.extract ());
    child_it.forward ();
  }
}


/**********************************************************************
 * join_chopped_fragments
 *
 * Join the two lists of POLYPTs such that the first OUTLINE_FRAG
 * operand keeps responsibility for the fragment.
 **********************************************************************/

void join_chopped_fragments(                       //join pieces
                            OUTLINE_FRAG *bottom,  //bottom of cut
                            OUTLINE_FRAG *top      //top of cut
                           ) {
  POLYPT_IT master_it;           //dest list
  POLYPT_IT slave_it;            //src list
  POLYPT *cutpt;                 //vectors to change
  POLYPT *nextpt;                //other end of cut

  if (bottom->polypts.empty ()) {
    master_it.set_to_list (&bottom->other_end->polypts);
    cutpt = master_it.data_relative (-1);
    ASSERT_HOST (!top->polypts.empty ());
    slave_it.set_to_list (&top->polypts);
    nextpt = slave_it.data ();
    if (bottom->other_end != top) {
      master_it.move_to_last ();
      master_it.add_list_after (&top->polypts);
    }
  }
  else {
    master_it.set_to_list (&bottom->polypts);
    ASSERT_HOST (top->polypts.empty ());
    slave_it.set_to_list (&top->other_end->polypts);
    cutpt = slave_it.data_relative (-1);
    nextpt = master_it.data ();
    if (bottom->other_end != top)
      master_it.add_list_before (&top->other_end->polypts);
  }
  cutpt->vec = nextpt->pos - cutpt->pos;
}


/**********************************************************************
 * fixed_chop_cblob
 *
 * Chop the given cblob (if any) and the existing right outlines to
 * produce a list of outlines left of the chop point and more to the right.
 **********************************************************************/

void fixed_chop_cblob(                                //split the blob
                      C_BLOB *blob,                   //blob to split
                      inT16 chop_coord,               //place to chop
                      float pitch_error,              //allowed deviation
                      C_OUTLINE_LIST *left_outlines,  //left half of chop
                      C_OUTLINE_LIST *right_outlines  //right half of chop
                     ) {
  C_OUTLINE *old_right;          //already there
  C_OUTLINE_LIST new_outlines;   //new right ones
                                 //ouput iterator
  C_OUTLINE_IT left_it = left_outlines;
                                 //in/out iterator
  C_OUTLINE_IT right_it = right_outlines;
  C_OUTLINE_IT new_it = &new_outlines;
  C_OUTLINE_IT blob_it;          //outlines in blob

  if (!right_it.empty ()) {
    while (!right_it.empty ()) {
      old_right = right_it.extract ();
      right_it.forward ();
      fixed_split_coutline(old_right,
                           chop_coord,
                           pitch_error,
                           &left_it,
                           &new_it);
    }
    right_it.add_list_before (&new_outlines);
  }
  if (blob != NULL) {
    blob_it.set_to_list (blob->out_list ());
    for (blob_it.mark_cycle_pt (); !blob_it.cycled_list ();
      blob_it.forward ())
    fixed_split_coutline (blob_it.extract (), chop_coord, pitch_error,
        &left_it, &right_it);
    delete blob;
  }
}


/**********************************************************************
 * fixed_split_outline
 *
 * Chop the given outline (if necessary) placing the fragments which
 * fall either side of the chop line into the appropriate list.
 **********************************************************************/

void fixed_split_coutline(                        //chop the outline
                          C_OUTLINE *srcline,     //source outline
                          inT16 chop_coord,       //place to chop
                          float pitch_error,      //allowed deviation
                          C_OUTLINE_IT *left_it,  //left half of chop
                          C_OUTLINE_IT *right_it  //right half of chop
                         ) {
  C_OUTLINE *child;              //child outline
  TBOX srcbox;                    //box of outline
  C_OUTLINE_LIST left_ch;        //left children
  C_OUTLINE_LIST right_ch;       //right children
  C_OUTLINE_FRAG_LIST left_frags;//chopped fragments
  C_OUTLINE_FRAG_LIST right_frags;;
  C_OUTLINE_IT left_ch_it = &left_ch;
                                 //for whole children
  C_OUTLINE_IT right_ch_it = &right_ch;
                                 //for holes
  C_OUTLINE_IT child_it = srcline->child ();

  srcbox = srcline->bounding_box ();
                                 //left of line
  if (srcbox.left () + srcbox.right () <= chop_coord * 2
                                 //and not far over
    && srcbox.right () < chop_coord + pitch_error)
                                 //stick whole in left
    left_it->add_after_then_move (srcline);
  else if (srcbox.left () + srcbox.right () > chop_coord * 2
    && srcbox.left () > chop_coord - pitch_error)
                                 //stick whole in right
    right_it->add_before_stay_put (srcline);
  else {
                                 //needs real chopping
    if (fixed_chop_coutline (srcline, chop_coord, pitch_error,
    &left_frags, &right_frags)) {
      for (child_it.mark_cycle_pt (); !child_it.cycled_list ();
      child_it.forward ()) {
        child = child_it.extract ();
        srcbox = child->bounding_box ();
        if (srcbox.right () < chop_coord)
          left_ch_it.add_after_then_move (child);
        else if (srcbox.left () > chop_coord)
          right_ch_it.add_after_then_move (child);
        else {
          if (fixed_chop_coutline (child, chop_coord, pitch_error,
            &left_frags, &right_frags))
            delete child;
          else {
            if (srcbox.left () + srcbox.right () <= chop_coord * 2)
              left_ch_it.add_after_then_move (child);
            else
              right_ch_it.add_after_then_move (child);
          }
        }
      }
      close_chopped_cfragments(&left_frags, &left_ch, pitch_error, left_it);
      close_chopped_cfragments(&right_frags, &right_ch, pitch_error, right_it);
      ASSERT_HOST (left_ch.empty () && right_ch.empty ());
      //no children left
      delete srcline;            //smashed up
    }
    else {
      if (srcbox.left () + srcbox.right () <= chop_coord * 2)
                                 //stick whole in left
        left_it->add_after_then_move (srcline);
      else
        right_it->add_before_stay_put (srcline);
    }
  }
}


/**********************************************************************
 * fixed_chop_coutline
 *
 * Chop the given coutline (if necessary) placing the fragments which
 * fall either side of the chop line into the appropriate list.
 * If the coutline lies too heavily to one side to chop, FALSE is returned.
 **********************************************************************/

BOOL8 fixed_chop_coutline(                                  //chop the outline
                          C_OUTLINE *srcline,               //source outline
                          inT16 chop_coord,                 //place to chop
                          float pitch_error,                //allowed deviation
                          C_OUTLINE_FRAG_LIST *left_frags,  //left half of chop
                          C_OUTLINE_FRAG_LIST *right_frags  //right half of chop
                         ) {
  BOOL8 first_frag;              //fragment
  inT16 left_edge;               //of outline
  inT16 startindex;              //in first fragment
  inT32 length;                  //of outline
  inT16 stepindex;               //into outline
  inT16 head_index;              //start of fragment
  ICOORD head_pos;               //start of fragment
  inT16 tail_index;              //end of fragment
  ICOORD tail_pos;               //end of fragment
  ICOORD pos;                    //current point
  inT16 first_index = 0;         //first tail
  ICOORD first_pos;              //first tail

  length = srcline->pathlength ();
  pos = srcline->start_pos ();
  left_edge = pos.x ();
  tail_index = 0;
  tail_pos = pos;
  for (stepindex = 0; stepindex < length; stepindex++) {
    if (pos.x () < left_edge) {
      left_edge = pos.x ();
      tail_index = stepindex;
      tail_pos = pos;
    }
    pos += srcline->step (stepindex);
  }
  if (left_edge >= chop_coord - pitch_error)
    return FALSE;                //not worth it

  startindex = tail_index;
  first_frag = TRUE;
  head_index = tail_index;
  head_pos = tail_pos;
  do {
    do {
      tail_pos += srcline->step (tail_index);
      tail_index++;
      if (tail_index == length)
        tail_index = 0;
    }
    while (tail_pos.x () != chop_coord && tail_index != startindex);
    if (tail_index == startindex) {
      if (first_frag)
        return FALSE;            //doesn't cross line
      else
        break;
    }
    //#ifdef __UNIX__
    ASSERT_HOST (head_index != tail_index);
    //#endif
    if (!first_frag) {
      save_chop_cfragment(head_index,
                          head_pos,
                          tail_index,
                          tail_pos,
                          srcline,
                          left_frags);
    }
    else {
      first_index = tail_index;
      first_pos = tail_pos;
      first_frag = FALSE;
    }
    while (srcline->step (tail_index).x () == 0) {
      tail_pos += srcline->step (tail_index);
      tail_index++;
      if (tail_index == length)
        tail_index = 0;
    }
    head_index = tail_index;
    head_pos = tail_pos;
    while (srcline->step (tail_index).x () > 0) {
      do {
        tail_pos += srcline->step (tail_index);
        tail_index++;
        if (tail_index == length)
          tail_index = 0;
      }
      while (tail_pos.x () != chop_coord);
      //#ifdef __UNIX__
      ASSERT_HOST (head_index != tail_index);
      //#endif
      save_chop_cfragment(head_index,
                          head_pos,
                          tail_index,
                          tail_pos,
                          srcline,
                          right_frags);
      while (srcline->step (tail_index).x () == 0) {
        tail_pos += srcline->step (tail_index);
        tail_index++;
        if (tail_index == length)
          tail_index = 0;
      }
      head_index = tail_index;
      head_pos = tail_pos;
    }
  }
  while (tail_index != startindex);
  save_chop_cfragment(head_index,
                      head_pos,
                      first_index,
                      first_pos,
                      srcline,
                      left_frags);
  return TRUE;                   //did some chopping
}


/**********************************************************************
 * next_anti_left_seg
 *
 * Search the outline for a suitable point at which it crosses the
 * chop_coord from left to right.
 **********************************************************************/

inT16 next_anti_left_seg(                     //chop the outline
                         C_OUTLINE *srcline,  //source outline
                         inT16 tail_index,    //of tailpos
                         inT16 startindex,    //end of search
                         inT32 length,        //of outline
                         inT16 chop_coord,    //place to chop
                         float pitch_error,   //allowed deviation
                         ICOORD *tail_pos     //current position
                        ) {
  BOOL8 test_valid;              //test pt valid
  inT16 chop_starty;             //test chop pt
  inT16 test_index;              //possible chop pt
  ICOORD test_pos;               //possible chop pt
  ICOORD prev_step;              //in x to tail pos

  test_valid = FALSE;
  chop_starty = -MAX_INT16;
  test_index = tail_index;       //stop warnings
  do {
    *tail_pos += srcline->step (tail_index);
    prev_step = srcline->step (tail_index);
    tail_index++;
    if (tail_index >= length)
      tail_index = 0;
    if (test_valid && tail_pos->x () == chop_coord && prev_step.x () < 0) {
      if (tail_pos->y () >= chop_starty) {
        chop_starty = -MAX_INT16;
        test_valid = FALSE;
      }
      else {
        *tail_pos = test_pos;
        tail_index = test_index;
        break;                   //must chop there
      }
    }
    if (tail_pos->x () == chop_coord
      && srcline->step (tail_index).x () > 0
    && tail_pos->y () > chop_starty) {
      chop_starty = tail_pos->y ();
      test_index = tail_index;
      test_pos = *tail_pos;
      test_valid = TRUE;
    }
    else if (tail_pos->x () == chop_coord
      && srcline->step (tail_index).y () < 0
      && prev_step.x () > 0 && tail_pos->y () > chop_starty)
      break;                     //must chop here
  }
  while (tail_index != startindex
    && tail_pos->x () < chop_coord + pitch_error);
  return tail_index;
}


/**********************************************************************
 * next_anti_right_seg
 *
 * Search the outline for a suitable point at which it crosses the
 * chop_coord from right to left.
 **********************************************************************/

inT16 next_anti_right_seg(                     //chop the outline
                          C_OUTLINE *srcline,  //source outline
                          inT16 tail_index,    //of tailpos
                          inT16 startindex,    //end of search
                          inT32 length,        //of outline
                          inT16 chop_coord,    //place to chop
                          float pitch_error,   //allowed deviation
                          ICOORD *tail_pos     //current position
                         ) {
  BOOL8 test_valid;              //test pt valid
  inT16 chop_starty;             //test chop pt
  inT16 test_index;              //possible chop pt
  ICOORD test_pos;               //possible chop pt
  ICOORD prev_step;              //in x to tail pos

  test_valid = FALSE;
  chop_starty = MAX_INT16;
  test_index = tail_index;       //stop warnings
  do {
                                 //move forward
    *tail_pos += srcline->step (tail_index);
    prev_step = srcline->step (tail_index);
    tail_index++;
    if (tail_index >= length)
      tail_index = 0;
    if (test_valid && tail_pos->x () == chop_coord && prev_step.x () > 0) {
      if (tail_pos->y () <= chop_starty) {
        chop_starty = MAX_INT16;
        test_valid = FALSE;
      }
      else {
        *tail_pos = test_pos;
        tail_index = test_index;
        break;                   //must chop there
      }
    }
    if (tail_pos->x () == chop_coord
      && srcline->step (tail_index).x () < 0
    && tail_pos->y () < chop_starty) {
      chop_starty = tail_pos->y ();
      test_index = tail_index;
      test_pos = *tail_pos;
      test_valid = TRUE;         //save possible chop pt
    }
    else if (tail_pos->x () == chop_coord
      && srcline->step (tail_index).y () > 0
      && prev_step.x () < 0 && tail_pos->y () < chop_starty)
      break;                     //must chop here
  }
  while (tail_index != startindex
    && tail_pos->x () > chop_coord - pitch_error);
  return tail_index;
}


/**********************************************************************
 * next_clock_left_seg
 *
 * Search the outline for a suitable point at which it crosses the
 * chop_coord from left to right.
 **********************************************************************/

inT16 next_clock_left_seg(                     //chop the outline
                          C_OUTLINE *srcline,  //source outline
                          inT16 tail_index,    //of tailpos
                          inT16 startindex,    //end of search
                          inT32 length,        //of outline
                          inT16 chop_coord,    //place to chop
                          float pitch_error,   //allowed deviation
                          ICOORD *tail_pos     //current position
                         ) {
  BOOL8 test_valid;              //test pt valid
  inT16 chop_starty;             //test chop pt
  inT16 test_index;              //possible chop pt
  ICOORD test_pos;               //possible chop pt
  ICOORD prev_step;              //in x to tail pos

  test_valid = FALSE;
  chop_starty = MAX_INT16;
  test_index = tail_index;       //stop warnings
  do {
    *tail_pos += srcline->step (tail_index);
    prev_step = srcline->step (tail_index);
    tail_index++;
    if (tail_index >= length)
      tail_index = 0;
    if (test_valid && tail_pos->x () == chop_coord && prev_step.x () < 0) {
      if (tail_pos->y () <= chop_starty) {
        chop_starty = MAX_INT16;
        test_valid = FALSE;
      }
      else {
        *tail_pos = test_pos;
        tail_index = test_index;
        break;                   //must chop there
      }
    }
    if (tail_pos->x () == chop_coord
      && srcline->step (tail_index).x () > 0
    && tail_pos->y () < chop_starty) {
      chop_starty = tail_pos->y ();
      test_index = tail_index;
      test_pos = *tail_pos;
      test_valid = TRUE;
    }
    else if (tail_pos->x () == chop_coord
      && srcline->step (tail_index).y () > 0
      && prev_step.x () > 0 && tail_pos->y () < chop_starty)
      break;                     //must chop here
  }
  while (tail_index != startindex
    && tail_pos->x () < chop_coord + pitch_error);
  return tail_index;
}


/**********************************************************************
 * next_clock_right_seg
 *
 * Search the outline for a suitable point at which it crosses the
 * chop_coord from right to left.
 **********************************************************************/

inT16 next_clock_right_seg(                     //chop the outline
                           C_OUTLINE *srcline,  //source outline
                           inT16 tail_index,    //of tailpos
                           inT16 startindex,    //end of search
                           inT32 length,        //of outline
                           inT16 chop_coord,    //place to chop
                           float pitch_error,   //allowed deviation
                           ICOORD *tail_pos     //current position
                          ) {
  BOOL8 test_valid;              //test pt valid
  inT16 chop_starty;             //test chop pt
  inT16 test_index;              //possible chop pt
  ICOORD test_pos;               //possible chop pt
  ICOORD prev_step;              //in x to tail pos

  test_valid = FALSE;
  chop_starty = MAX_INT16;
  test_index = tail_index;       //stop warnings
  do {
                                 //move forward
    *tail_pos += srcline->step (tail_index);
    prev_step = srcline->step (tail_index);
    tail_index++;
    if (tail_index >= length)
      tail_index = 0;
    if (test_valid && tail_pos->x () == chop_coord && prev_step.x () > 0) {
      if (tail_pos->y () >= chop_starty) {
        chop_starty = MAX_INT16;
        test_valid = FALSE;
      }
      else {
        *tail_pos = test_pos;
        tail_index = test_index;
        break;                   //must chop there
      }
    }
    if (tail_pos->x () == chop_coord
      && srcline->step (tail_index).x () < 0
    && tail_pos->y () > chop_starty) {
      chop_starty = tail_pos->y ();
      test_index = tail_index;
      test_pos = *tail_pos;
      test_valid = TRUE;         //save possible chop pt
    }
    else if (tail_pos->x () == chop_coord
      && srcline->step (tail_index).y () < 0
      && prev_step.x () < 0 && tail_pos->y () > chop_starty)
      break;                     //must chop here
  }
  while (tail_index != startindex
    && tail_pos->x () > chop_coord - pitch_error);
  return tail_index;
}


/**********************************************************************
 * save_chop_cfragment
 *
 * Store the given fragment in the given fragment list.
 **********************************************************************/

void save_chop_cfragment(                            //chop the outline
                         inT16 head_index,           //head of fragment
                         ICOORD head_pos,            //head of fragment
                         inT16 tail_index,           //tail of fragment
                         ICOORD tail_pos,            //tail of fragment
                         C_OUTLINE *srcline,         //source of edgesteps
                         C_OUTLINE_FRAG_LIST *frags  //fragment list
                        ) {
  inT16 jump;                    //gap across end
  inT16 stepcount;               //total steps
  C_OUTLINE_FRAG *head;          //head of fragment
  C_OUTLINE_FRAG *tail;          //tail of fragment
  inT16 tail_y;                  //ycoord of tail

  ASSERT_HOST (tail_pos.x () == head_pos.x ());
  ASSERT_HOST (tail_index != head_index);
  stepcount = tail_index - head_index;
  if (stepcount < 0)
    stepcount += srcline->pathlength ();
  jump = tail_pos.y () - head_pos.y ();
  if (jump < 0)
    jump = -jump;
  if (jump == stepcount)
    return;                      //its a nop
  tail_y = tail_pos.y ();
  head = new C_OUTLINE_FRAG (head_pos, tail_pos, srcline,
    head_index, tail_index);
  tail = new C_OUTLINE_FRAG (head, tail_y);
  head->other_end = tail;
  add_frag_to_list(head, frags);
  add_frag_to_list(tail, frags);
}


/**********************************************************************
 * C_OUTLINE_FRAG::C_OUTLINE_FRAG
 *
 * Constructors for C_OUTLINE_FRAG.
 **********************************************************************/

C_OUTLINE_FRAG::C_OUTLINE_FRAG(                     //record fragment
                               ICOORD start_pt,     //start coord
                               ICOORD end_pt,       //end coord
                               C_OUTLINE *outline,  //source of steps
                               inT16 start_index,
                               inT16 end_index) {
  start = start_pt;
  end = end_pt;
  ycoord = start_pt.y ();
  stepcount = end_index - start_index;
  if (stepcount < 0)
    stepcount += outline->pathlength ();
  ASSERT_HOST (stepcount > 0);
  steps = new DIR128[stepcount];
  if (end_index > start_index) {
    for (int i = start_index; i < end_index; ++i)
      steps[i - start_index] = outline->step_dir(i);
  }
  else {
    int len = outline->pathlength();
    int i = start_index;
    for (; i < len; ++i)
      steps[i - start_index] = outline->step_dir(i);
    if (end_index > 0)
      for (; i < end_index + len; ++i)
        steps[i - start_index] = outline->step_dir(i - len);
  }
  other_end = NULL;
  delete close();
}


C_OUTLINE_FRAG::C_OUTLINE_FRAG(                       //record fragment
                               C_OUTLINE_FRAG *head,  //other end
                               inT16 tail_y) {
  ycoord = tail_y;
  other_end = head;
  start = head->start;
  end = head->end;
  steps = NULL;
  stepcount = 0;
}


/**********************************************************************
 * add_frag_to_list
 *
 * Insert the fragment in the list at the appropriate place to keep
 * them in ascending ycoord order.
 **********************************************************************/

void add_frag_to_list(                            //ordered add
                      C_OUTLINE_FRAG *frag,       //fragment to add
                      C_OUTLINE_FRAG_LIST *frags  //fragment list
                     ) {
                                 //output list
  C_OUTLINE_FRAG_IT frag_it = frags;

  if (!frags->empty ()) {
    for (frag_it.mark_cycle_pt (); !frag_it.cycled_list ();
    frag_it.forward ()) {
      if (frag_it.data ()->ycoord > frag->ycoord
        || (frag_it.data ()->ycoord == frag->ycoord
         && frag->other_end->ycoord < frag->ycoord)) {
        frag_it.add_before_then_move (frag);
        return;
      }
    }
  }
  frag_it.add_to_end (frag);
}


/**********************************************************************
 * close_chopped_cfragments
 *
 * Clear the given list of fragments joining them up into outlines.
 * Each outline made soaks up any of the child outlines which it encloses.
 **********************************************************************/

void close_chopped_cfragments(                             //chop the outline
                              C_OUTLINE_FRAG_LIST *frags,  //list to clear
                              C_OUTLINE_LIST *children,    //potential children
                              float pitch_error,           //allowed shrinkage
                              C_OUTLINE_IT *dest_it        //output list
                             ) {
                                 //iterator
  C_OUTLINE_FRAG_IT frag_it = frags;
  C_OUTLINE_FRAG *bottom_frag;   //bottom of cut
  C_OUTLINE_FRAG *top_frag;      //top of cut
  C_OUTLINE *outline;            //new outline
  C_OUTLINE *child;              //current child
  C_OUTLINE_IT child_it = children;
  C_OUTLINE_IT olchild_it;       //children of outline

  while (!frag_it.empty ()) {
    frag_it.move_to_first ();
                                 //get bottom one
    bottom_frag = frag_it.extract ();
    frag_it.forward ();
    top_frag = frag_it.data ();  //look at next
    if ((bottom_frag->steps == 0 && top_frag->steps == 0)
    || (bottom_frag->steps != 0 && top_frag->steps != 0)) {
      if (frag_it.data_relative (1)->ycoord == top_frag->ycoord)
        frag_it.forward ();
    }
    top_frag = frag_it.extract ();
    if (top_frag->other_end != bottom_frag) {
      outline = join_chopped_fragments (bottom_frag, top_frag);
      ASSERT_HOST (outline == NULL);
    }
    else {
      outline = join_chopped_fragments (bottom_frag, top_frag);
      ASSERT_HOST (outline != NULL);
      olchild_it.set_to_list (outline->child ());
      for (child_it.mark_cycle_pt (); !child_it.cycled_list ();
      child_it.forward ()) {
        child = child_it.data ();
        if (*child < *outline)
          olchild_it.add_to_end (child_it.extract ());
      }
      if (outline->bounding_box ().width () > pitch_error)
        dest_it->add_after_then_move (outline);
      else
        delete outline;          //make it disappear
    }
  }
  while (!child_it.empty ()) {
    dest_it->add_after_then_move (child_it.extract ());
    child_it.forward ();
  }
}


/**********************************************************************
 * join_chopped_fragments
 *
 * Join the two lists of POLYPTs such that neither OUTLINE_FRAG
 * operand keeps responsibility for the fragment.
 **********************************************************************/

C_OUTLINE *join_chopped_fragments(                         //join pieces
                                  C_OUTLINE_FRAG *bottom,  //bottom of cut
                                  C_OUTLINE_FRAG *top      //top of cut
                                 ) {
  C_OUTLINE *outline;            //closed loop

  if (bottom->other_end == top) {
    if (bottom->steps == 0)
      outline = top->close ();   //turn to outline
    else
      outline = bottom->close ();
    delete top;
    delete bottom;
    return outline;
  }
  if (bottom->steps == 0) {
    ASSERT_HOST (top->steps != 0);
    join_segments (bottom->other_end, top);
  }
  else {
    ASSERT_HOST (top->steps == 0);
    join_segments (top->other_end, bottom);
  }
  top->other_end->other_end = bottom->other_end;
  bottom->other_end->other_end = top->other_end;
  delete bottom;
  delete top;
  return NULL;
}


/**********************************************************************
 * join_segments
 *
 * Join the two edgestep fragments such that the second comes after
 * the first and the gap beween them is closed.
 **********************************************************************/

void join_segments(                         //join pieces
                   C_OUTLINE_FRAG *bottom,  //bottom of cut
                   C_OUTLINE_FRAG *top      //top of cut
                  ) {
  DIR128 *steps;                  //new steps
  inT32 stepcount;               //no of steps
  inT16 fake_count;              //fake steps
  DIR128 fake_step;               //step entry

  ASSERT_HOST (bottom->end.x () == top->start.x ());
  fake_count = top->start.y () - bottom->end.y ();
  if (fake_count < 0) {
    fake_count = -fake_count;
    fake_step = 32;
  }
  else
    fake_step = 96;

  stepcount = bottom->stepcount + fake_count + top->stepcount;
  steps = new DIR128[stepcount];
  memmove (steps, bottom->steps, bottom->stepcount);
  memset (steps + bottom->stepcount, fake_step.get_dir(), fake_count);
  memmove (steps + bottom->stepcount + fake_count, top->steps,
    top->stepcount);
  delete [] bottom->steps;
  bottom->steps = steps;
  bottom->stepcount = stepcount;
  bottom->end = top->end;
  bottom->other_end->end = top->end;
}


/**********************************************************************
 * C_OUTLINE_FRAG::close
 *
 * Join the ends of this fragment and turn it into an outline.
 **********************************************************************/

C_OUTLINE *C_OUTLINE_FRAG::close() {  //join pieces
  DIR128 *new_steps;              //new steps
  inT32 new_stepcount;           //no of steps
  inT16 fake_count;              //fake steps
  DIR128 fake_step;               //step entry

  ASSERT_HOST (start.x () == end.x ());
  fake_count = start.y () - end.y ();
  if (fake_count < 0) {
    fake_count = -fake_count;
    fake_step = 32;
  }
  else
    fake_step = 96;

  new_stepcount = stepcount + fake_count;
  new_steps = new DIR128[new_stepcount];
  memmove(new_steps, steps, stepcount);
  memset (new_steps + stepcount, fake_step.get_dir(), fake_count);
  C_OUTLINE* result = new C_OUTLINE (start, new_steps, new_stepcount);
  delete [] new_steps;
  return result;
}


/**********************************************************************
 * C_OUTLINE_FRAG::operator=
 *
 * Copy this fragment.
 **********************************************************************/

                                 //join pieces
C_OUTLINE_FRAG & C_OUTLINE_FRAG::operator= (
const C_OUTLINE_FRAG & src       //fragment to copy
) {
  if (steps != NULL)
    delete [] steps;

  stepcount = src.stepcount;
  steps = new DIR128[stepcount];
  memmove (steps, src.steps, stepcount);
  start = src.start;
  end = src.end;
  ycoord = src.ycoord;
  return *this;
}
/////////////////////////////////////////////////////////////////fpchop////////////////////////////////////////

/////////////////////////////////////////////////////////////////underlin////////////////////////////////////////
#define PROJECTION_MARGIN 10     //arbitrary
#define EXTERN

EXTERN double_VAR (textord_underline_offset, 0.1, "Fraction of x to ignore");
EXTERN BOOL_VAR (textord_restore_underlines, TRUE, "Chop underlines & put back");

/**********************************************************************
 * restore_underlined_blobs
 *
 * Find underlined blobs and put them back in the row.
 **********************************************************************/
//get chop points             //block to do
void restore_underlined_blobs(TO_BLOCK *block)
{
  inT16 chop_coord;              //chop boundary
  TBOX blob_box;                  //of underline
  BLOBNBOX *u_line;              //underline bit
  TO_ROW *row;                   //best row for blob
  ICOORDELT_LIST chop_cells;     //blobs to cut out

  //real underlines
  BLOBNBOX_LIST residual_underlines;
  OUTLINE_LIST left_outlines;    //in current blob
  OUTLINE_LIST right_outlines;   //for next blob
  C_OUTLINE_LIST left_coutlines;
  C_OUTLINE_LIST right_coutlines;
  ICOORDELT_IT cell_it = &chop_cells;

  //under lines
  BLOBNBOX_IT under_it = &block->underlines;
  BLOBNBOX_IT ru_it = &residual_underlines;

  if (block->get_rows()->empty())
  {
    return;  // Don't crash if there are no rows.
  }

  for (under_it.mark_cycle_pt(); !under_it.cycled_list(); under_it.forward())
  {
    u_line = under_it.extract();
    blob_box = u_line->bounding_box();
    row = most_overlapping_row(block->get_rows(), u_line);
    find_underlined_blobs(u_line, &row->baseline, row->xheight, row->xheight * textord_underline_offset, &chop_cells);
    cell_it.set_to_list(&chop_cells);

    for (cell_it.mark_cycle_pt(); !cell_it.cycled_list(); cell_it.forward())
    {
      chop_coord = cell_it.data()->x();
      if (cell_it.data()->y() - chop_coord > textord_fp_chop_error + 1)
      {
        split_to_blob (u_line, chop_coord, textord_fp_chop_error + 0.5, &left_outlines, &left_coutlines, &right_outlines, &right_coutlines);

        if (!left_outlines.empty())
        {
          ru_it.add_after_then_move(new BLOBNBOX (new PBLOB(&left_outlines)));
        }
        else if (!left_coutlines.empty())
        {
          ru_it.add_after_then_move (new BLOBNBOX(new C_BLOB (&left_coutlines)));
        }

        //right edge of lbob
        chop_coord = cell_it.data()->y();
        split_to_blob (NULL, chop_coord, textord_fp_chop_error + 0.5, &left_outlines, &left_coutlines, &right_outlines, &right_coutlines);

        if (!left_outlines.empty ())
        {
          row->insert_blob (new BLOBNBOX (new PBLOB (&left_outlines)));
        }
        else if (!left_coutlines.empty ())
        {
          row->insert_blob (new BLOBNBOX (new C_BLOB (&left_coutlines)));
        }
        else
        {
          ASSERT_HOST(FALSE);
          fprintf(stderr, "Error:no outlines after chopping from %d to %d from (%d,%d)->(%d,%d)\n", cell_it.data()->x(), cell_it.data ()->y(),
                  blob_box.left(), blob_box.bottom(), blob_box.right(), blob_box.top());
        }
        u_line = NULL;           //no more blobs to add
      }

      delete cell_it.extract();
    }

    if (!right_outlines.empty() || !right_coutlines.empty())
    {
      split_to_blob (NULL, blob_box.right(), textord_fp_chop_error + 0.5, &left_outlines, &left_coutlines, &right_outlines, &right_coutlines);

      if (!left_outlines.empty())
      {
          ru_it.add_after_then_move(new BLOBNBOX (new PBLOB(&left_outlines)));
      }
      else if (!left_coutlines.empty())
      {
        ru_it.add_after_then_move (new BLOBNBOX (new C_BLOB(&left_coutlines)));
      }
    }

    if (u_line != NULL)
    {
      if (u_line->blob() != NULL)
      {
        delete u_line->blob();
      }

      if (u_line->cblob() != NULL)
      {
        delete u_line->cblob();
      }

      delete u_line;
    }
  }

  if (!ru_it.empty())
  {
    ru_it.move_to_first();
    for (ru_it.mark_cycle_pt(); !ru_it.cycled_list(); ru_it.forward())
    {
      under_it.add_after_then_move(ru_it.extract());
    }
  }
}


/**********************************************************************
 * most_overlapping_row
 *
 * Return the row which most overlaps the blob.
 **********************************************************************/
//find best row
TO_ROW *most_overlapping_row(TO_ROW_LIST *rows,  //list of rows
                             BLOBNBOX *blob      //blob to place
                            )
{
  inT16 x = (blob->bounding_box().left() + blob->bounding_box().right()) / 2;
  TO_ROW_IT row_it = rows;       //row iterator
  TO_ROW *row;                   //current row
  TO_ROW *best_row;              //output row
  float overlap;                 //of blob & row
  float bestover;                //best overlap

  best_row = NULL;
  bestover = (float) -MAX_INT32;

  if (row_it.empty())
  {
    return NULL;
  }

  row = row_it.data();
  row_it.mark_cycle_pt();
  while (row->baseline.y(x) + row->descdrop > blob->bounding_box().top () && !row_it.cycled_list ())
  {
    best_row = row;
    bestover = blob->bounding_box ().top () - row->baseline.y (x) + row->descdrop;
    row_it.forward();
    row = row_it.data();
  }

  while (row->baseline.y(x) + row->xheight + row->ascrise >= blob->bounding_box().bottom() && !row_it.cycled_list())
  {
    overlap = row->baseline.y (x) + row->xheight + row->ascrise;
    if (blob->bounding_box ().top () < overlap)
    {
      overlap = blob->bounding_box ().top ();
    }

    if (blob->bounding_box().bottom() > row->baseline.y(x) + row->descdrop)
    {
        overlap -= blob->bounding_box().bottom();
    }
    else
    {
      overlap -= row->baseline.y(x) + row->descdrop;
    }

    if (overlap > bestover)
    {
      bestover = overlap;
      best_row = row;
    }
    row_it.forward();
    row = row_it.data();
  }

  if (bestover < 0 && row->baseline.y(x) + row->xheight + row->ascrise - blob->bounding_box().bottom() > bestover)
  {
    best_row = row;
  }

  return best_row;
}


/**********************************************************************
 * find_underlined_blobs
 *
 * Find the start and end coords of blobs in the underline.
 **********************************************************************/
//get chop points
void find_underlined_blobs(BLOBNBOX *u_line,           //underlined unit
                           QSPLINE *baseline,          //actual baseline
                           float xheight,              //height of line
                           float baseline_offset,      //amount to shrinke it
                           ICOORDELT_LIST *chop_cells  //places to chop
                          )
{
  inT16 x, y;                    //sides of blob
  ICOORD blob_chop;              //sides of blob
  TBOX blob_box = u_line->bounding_box ();

  //cell iterator
  ICOORDELT_IT cell_it = chop_cells;
  STATS upper_proj (blob_box.left (), blob_box.right () + 1);
  STATS middle_proj (blob_box.left (), blob_box.right () + 1);
  STATS lower_proj (blob_box.left (), blob_box.right () + 1);
  C_OUTLINE_IT out_it;           //outlines of blob

  ASSERT_HOST (u_line->cblob () != NULL);

  out_it.set_to_list (u_line->cblob ()->out_list ());
  for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward())
  {
    vertical_cunderline_projection (out_it.data(), baseline, xheight, baseline_offset, &lower_proj, &middle_proj, &upper_proj);
  }

  for (x = blob_box.left(); x < blob_box.right(); x++)
  {
    if (middle_proj.pile_count(x) > 0)
    {
      for (y = x + 1; y < blob_box.right() && middle_proj.pile_count(y) > 0; y++);
      blob_chop = ICOORD(x, y);
      cell_it.add_after_then_move(new ICOORDELT (blob_chop));
      x = y;
    }
  }
}


/**********************************************************************
 * vertical_cunderline_projection
 *
 * Compute the vertical projection of a outline from its outlines
 * and add to the given STATS.
 **********************************************************************/
//project outlines
void vertical_cunderline_projection(C_OUTLINE *outline,     //outline to project
                                    QSPLINE *baseline,      //actual baseline
                                    float xheight,          //height of line
                                    float baseline_offset,  //amount to shrinke it
                                    STATS *lower_proj,      //below baseline
                                    STATS *middle_proj,     //centre region
                                    STATS *upper_proj       //top region
                                   )
{
  ICOORD pos;                    //current point
  ICOORD step;                   //edge step
  inT16 lower_y, upper_y;        //region limits
  inT32 length;                  //of outline
  inT16 stepindex;               //current step
  C_OUTLINE_IT out_it = outline->child ();

  pos = outline->start_pos ();
  length = outline->pathlength ();
  for (stepindex = 0; stepindex < length; stepindex++)
  {
    step = outline->step (stepindex);
    if (step.x() > 0)
    {
      lower_y = (inT16) floor (baseline->y (pos.x ()) + baseline_offset + 0.5);
      upper_y = (inT16) floor (baseline->y (pos.x ()) + baseline_offset + xheight + 0.5);

      if (pos.y() >= lower_y)
      {
        lower_proj->add (pos.x(), -lower_y);

        if (pos.y() >= upper_y)
        {
          middle_proj->add(pos.x(), lower_y - upper_y);
          upper_proj->add(pos.x(), upper_y - pos.y());
        }
        else
        {
          middle_proj->add(pos.x(), lower_y - pos.y());
        }
      }
      else
      {
        lower_proj->add(pos.x(), -pos.y());
      }
    }
    else if (step.x() < 0)
    {
      lower_y = (inT16)floor(baseline->y (pos.x() - 1) + baseline_offset + 0.5);
      upper_y = (inT16)floor(baseline->y(pos.x() - 1) + baseline_offset + xheight + 0.5);

      if (pos.y() >= lower_y)
      {
        lower_proj->add(pos.x() - 1, lower_y);

        if (pos.y () >= upper_y)
        {
          middle_proj->add(pos.x() - 1, upper_y - lower_y);
          upper_proj->add(pos.x() - 1, pos.y () - upper_y);
        }
        else
        {
          middle_proj->add (pos.x () - 1, pos.y () - lower_y);
        }
      }
      else
      {
        lower_proj->add (pos.x() - 1, pos.y());
      }
    }
    pos += step;
  }

  for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward())
  {
    vertical_cunderline_projection(out_it.data(), baseline, xheight, baseline_offset, lower_proj, middle_proj, upper_proj);
  }
}
/////////////////////////////////////////////////////////////////underlin////////////////////////////////////////

/////////////////////////////////////////////////////////////////blkocc////////////////////////////////////////
const ERRCODE BLOCKOCC = "BlockOcc";
ELISTIZE (REGION_OCC)
#define EXTERN
EXTERN BOOL_VAR (blockocc_show_result, FALSE,
                 "Show intermediate results");

/* The values given here should reflect the values of bln_x_height and
 * bln_baseline_offset. These are defined as part of the word class
 * definition                                                             */

EXTERN INT_VAR (blockocc_desc_height, 0,
                "Descender height after normalisation");
EXTERN INT_VAR (blockocc_asc_height, 255,
                "Ascender height after normalisation");

EXTERN INT_VAR (blockocc_band_count, 4, "Number of bands used");

EXTERN double_VAR (textord_underline_threshold, 0.5,
                   "Fraction of width occupied");

// Forward declarations of static functions

//project outlines                      //blob to project  //output
static void horizontal_cblob_projection(C_BLOB *blob,      STATS *stats);

//project outlines                         //outline to project  //output
static void horizontal_coutline_projection(C_OUTLINE *outline,   STATS *stats);

//init from varibles  //top of bottom band  //height of split band
static void set_bands(float baseline,       float xheight);

//blob to do
static void find_transitions(PBLOB *blob, REGION_OCC_LIST *region_occ_list);

//add region on list
static void record_region(inT16 band, float new_min, float new_max, inT16 region_type,REGION_OCC_LIST *region_occ_list);

//find range's band
static inT16 find_containing_maximal_band(float y1, float y2,BOOL8 *doubly_contained);
static void find_significant_line(POLYPT_IT it, inT16 *band);

//find range's band
static inT16 find_overlapping_minimal_band(float y1, float y2);
static inT16 find_region_type(inT16 entry_band, inT16 current_band, inT16 exit_band, float entry_x, float exit_x);
static void find_trans_point(POLYPT_IT *pt_it, inT16 current_band, inT16 next_band, FCOORD *transition_pt);
static void next_region(POLYPT_IT *start_pt_it, inT16 start_band, inT16 *to_band, float *min_x, float *max_x, inT16 *increment, FCOORD *exit_pt);

// find POINT's band
static inT16 find_band(float y);

// join open regions
static void compress_region_list(REGION_OCC_LIST *region_occ_list);
static void find_fbox(OUTLINE_IT *out_it, float *min_x, float *min_y, float *max_x, float *max_y);
static void maintain_limits(float *min_x, float *max_x, float x);


/**
A note on transitions.

We want to record occupancy in various bands. In general we need to consider
7 situations:

@verbatim
(1)     (2)  (3)             (4)
 \       /   \           /   \           /
__\_____/_____\_________/_____\_________/______ Upper Limit
   \   /       \       /       \       /
   /   \        \-->--/         \--<--/     /-----\
  v     ^                                  /       \(7)
  \      \                                 \       /
   \      \      /--<--\      /-->--\       \-----/
____\______\____/_______\____/_______\_________ Lower Limit
     \      \  /         \  /         \
             (5)          (6)
@endverbatim

We know that following "next" pointers around an outline keeps the black area
on the LEFT. We only need be concerned with situations 1,2,3,5 and 7.
4 and 6 can be ignored as they represent small incursions into a large black
region which will be recorded elsewhere.  Situations 3 and 5 define encloseed
areas bounded by the upper and lower limits respectively.  Situation 1 is open
to the right, awaiting a closure by a situation 2 which is open to the right.
Situation 7 is entirely enclosed within the band.

The situations are refered to as region types and are determined by
find_region_type.

An empty region type is used to denote entry to an adjacent band and return
to the original band at the same x location.
***********************************************************************/

#define REGION_TYPE_EMPTY 0
#define REGION_TYPE_OPEN_RIGHT 1
#define REGION_TYPE_OPEN_LEFT 2
#define REGION_TYPE_UPPER_BOUND 3
#define REGION_TYPE_UPPER_UNBOUND 4
#define REGION_TYPE_LOWER_BOUND 5
#define REGION_TYPE_LOWER_UNBOUND 6
#define REGION_TYPE_ENCLOSED 7

BAND bands[MAX_NUM_BANDS + 1];   // band defns

/**
 * test_underline
 *
 * Check to see if the blob is an underline.
 * Return TRUE if it is.
 */

BOOL8 test_underline(                   //look for underlines
                                        BOOL8 testing_on,  //< drawing blob
                                        PBLOB *blob,       //< blob to test
                                        float baseline,    //< coords of baseline
                                        float xheight      //< height of line
                                        )
{
    inT16 occ;
    inT16 blob_width;              //width of blob
    TBOX blob_box;                  //bounding box
    float occs[MAX_NUM_BANDS + 1]; //total occupancy

    blob_box = blob->bounding_box ();
    set_bands(baseline, xheight);  //setup block occ
    blob_width = blob->bounding_box ().width ();
    if (testing_on)
    {
        //              blob->plot(to_win,GOLDENROD,GOLDENROD);
        //              line_color_index(to_win,GOLDENROD);
        //              move2d(to_win,blob_box.left(),baseline);
        //              draw2d(to_win,blob_box.right(),baseline);
        //              move2d(to_win,blob_box.left(),baseline+xheight);
        //              draw2d(to_win,blob_box.right(),baseline+xheight);
        tprintf
                ("Testing underline on blob at (%d,%d)->(%d,%d), base=%g\nOccs:",
                 blob->bounding_box ().left (), blob->bounding_box ().bottom (),
                 blob->bounding_box ().right (), blob->bounding_box ().top (),
                 baseline);
    }

    block_occ(blob, occs);
    if (testing_on)
    {
        for (occ = 0; occ <= MAX_NUM_BANDS; occ++)
        {
            tprintf ("%g ", occs[occ]);
        }

        tprintf ("\n");
    }

    if (occs[1] > occs[2] + occs[2] && occs[1] > occs[3] + occs[3] && occs[1] > blob_width * textord_underline_threshold)
    {
        return TRUE;                 //real underline
    }

    if (occs[4] > occs[2] + occs[2] && occs[4] > blob_width * textord_underline_threshold)
    {
        return TRUE;                 //overline
    }

    return FALSE;                  //neither
}


/**
 * test_underline
 *
 * Check to see if the blob is an underline.
 * Return TRUE if it is.
 */

BOOL8 test_underline(                   //look for underlines
                                        BOOL8 testing_on,  //< drawing blob
                                        C_BLOB *blob,      //< blob to test
                                        inT16 baseline,    //< coords of baseline
                                        inT16 xheight      //< height of line
                                        )
{
    inT16 occ;
    inT16 blob_width;              //width of blob
    TBOX blob_box;                  //bounding box
    inT32 desc_occ;
    inT32 x_occ;
    inT32 asc_occ;
    STATS projection;

    blob_box = blob->bounding_box ();
    blob_width = blob->bounding_box ().width ();
    projection.set_range (blob_box.bottom (), blob_box.top () + 1);
    if (testing_on)
    {
        //              blob->plot(to_win,GOLDENROD,GOLDENROD);
        //              line_color_index(to_win,GOLDENROD);
        //              move2d(to_win,blob_box.left(),baseline);
        //              draw2d(to_win,blob_box.right(),baseline);
        //              move2d(to_win,blob_box.left(),baseline+xheight);
        //              draw2d(to_win,blob_box.right(),baseline+xheight);
        tprintf
                ("Testing underline on blob at (%d,%d)->(%d,%d), base=%d\nOccs:",
                 blob->bounding_box ().left (), blob->bounding_box ().bottom (),
                 blob->bounding_box ().right (), blob->bounding_box ().top (),
                 baseline);
    }
    horizontal_cblob_projection(blob, &projection);
    desc_occ = 0;

    for (occ = blob_box.bottom (); occ < baseline; occ++)
        if (occ <= blob_box.top () && projection.pile_count (occ) > desc_occ)
            //max in region
            desc_occ = projection.pile_count (occ);
    x_occ = 0;

    for (occ = baseline; occ <= baseline + xheight; occ++)
        if (occ >= blob_box.bottom () && occ <= blob_box.top () && projection.pile_count (occ) > x_occ)
            //max in region
            x_occ = projection.pile_count (occ);

    asc_occ = 0;
    for (occ = baseline + xheight + 1; occ <= blob_box.top (); occ++)
        if (occ >= blob_box.bottom () && projection.pile_count (occ) > asc_occ) asc_occ = projection.pile_count (occ);

    if (testing_on)
    {
        tprintf ("%d %d %d\n", desc_occ, x_occ, asc_occ);
    }

    if (desc_occ == 0 && x_occ == 0 && asc_occ == 0)
    {
        tprintf ("Bottom=%d, top=%d, base=%d, x=%d\n",
                 blob_box.bottom (), blob_box.top (), baseline, xheight);
        projection.print (stdout, TRUE);
    }

    if (desc_occ > x_occ + x_occ && desc_occ > blob_width * textord_underline_threshold) return TRUE;                 //real underline
    if (asc_occ > x_occ + x_occ && asc_occ > blob_width * textord_underline_threshold) return TRUE;                 //overline

    return FALSE;                  //neither
}


/**
 * horizontal_cblob_projection
 *
 * Compute the horizontal projection of a cblob from its outlines
 * and add to the given STATS.
 */

static void horizontal_cblob_projection(               //project outlines
                                                       C_BLOB *blob,  //< blob to project
                                                       STATS *stats   //< output
                                                       ) {
    //outlines of blob
    C_OUTLINE_IT out_it = blob->out_list ();

    for (out_it.mark_cycle_pt (); !out_it.cycled_list (); out_it.forward ())
    {
        horizontal_coutline_projection (out_it.data (), stats);
    }
}


/**
 * horizontal_coutline_projection
 *
 * Compute the horizontal projection of a outline from its outlines
 * and add to the given STATS.
 */

static void horizontal_coutline_projection(                     //project outlines
                                                                C_OUTLINE *outline,  //< outline to project
                                                                STATS *stats         //< output
                                                                )
{
    ICOORD pos;                    //current point
    ICOORD step;                   //edge step
    inT32 length;                  //of outline
    inT16 stepindex;               //current step
    C_OUTLINE_IT out_it = outline->child ();

    pos = outline->start_pos ();
    length = outline->pathlength ();
    for (stepindex = 0; stepindex < length; stepindex++)
    {
        step = outline->step (stepindex);
        if (step.y () > 0)
        {
            stats->add (pos.y (), pos.x ());
        }
        else if (step.y () < 0)
        {
            stats->add (pos.y () - 1, -pos.x ());
        }
        pos += step;
    }

    for (out_it.mark_cycle_pt (); !out_it.cycled_list (); out_it.forward ())
    {
        horizontal_coutline_projection (out_it.data (), stats);
    }
}


static void set_bands(                 //init from varibles
                                       float baseline,  //top of bottom band
                                       float xheight    //height of split band
                                       )
{
    inT16 int_bl, int_xh;          //for band.set

    bands[DOT_BAND].set (0, 0, 0, 0, 0, 0);

    int_bl = (inT16) baseline;
    int_xh = (inT16) xheight;
    bands[1].set (int_bl, int_bl, int_bl, NO_LOWER_LIMIT, NO_LOWER_LIMIT, NO_LOWER_LIMIT);

    bands[2].set (int_bl + int_xh / 2, int_bl + int_xh / 2, int_bl + int_xh / 2, int_bl, int_bl, int_bl);

    bands[3].set (int_bl + int_xh, int_bl + int_xh, int_bl + int_xh, int_bl + int_xh / 2, int_bl + int_xh / 2, int_bl + int_xh / 2);

    bands[4].set (NO_UPPER_LIMIT, NO_UPPER_LIMIT, NO_UPPER_LIMIT, int_bl + int_xh, int_bl + int_xh, int_bl + int_xh);
}


void block_occ (PBLOB * blob,         //blob to do
                float occs[]                     //output histogram
                )
{
    int band_index;                //current band
    REGION_OCC *region;            //current segment
    REGION_OCC_LIST region_occ_list[MAX_NUM_BANDS + 1];
    REGION_OCC_IT region_it;       //region iterator

    find_transitions(blob, region_occ_list);
    compress_region_list(region_occ_list);

    for (band_index = 0; band_index <= MAX_NUM_BANDS; band_index++)
    {
        occs[band_index] = 0.0f;
        region_it.set_to_list (&region_occ_list[band_index]);

        for (region_it.mark_cycle_pt (); !region_it.cycled_list (); region_it.forward ())
        {
            region = region_it.data ();
            occs[band_index] += region->max_x - region->min_x;
        }
    }
}


void find_transitions(PBLOB *blob,  //blob to do
                      REGION_OCC_LIST *region_occ_list)
{
    OUTLINE_IT outline_it;
    TBOX box;
    POLYPT_IT pt_it;
    FCOORD point1;
    FCOORD point2;
    FCOORD *entry_pt = &point1;
    FCOORD *exit_pt = &point2;
    FCOORD *temp_pt;
    inT16 increment;
    inT16 prev_band;
    inT16 band;
    inT16 next_band;
    float min_x;
    float max_x;
    float min_y;
    float max_y;
    BOOL8 doubly_contained;

    outline_it = blob->out_list ();
    for (outline_it.mark_cycle_pt (); !outline_it.cycled_list ();
         outline_it.forward ())
    {
        find_fbox(&outline_it, &min_x, &min_y, &max_x, &max_y);

        if (bands[DOT_BAND].range_in_nominal (max_y, min_y))
        {
            record_region(DOT_BAND, min_x, max_x, REGION_TYPE_ENCLOSED, region_occ_list);
        }
        else
        {
            band = find_containing_maximal_band (max_y, min_y, &doubly_contained);
            if (band != UNDEFINED_BAND)
            {
                //No transitions
                if (!doubly_contained) record_region(band, min_x, max_x, REGION_TYPE_ENCLOSED, region_occ_list);
                else
                {
                    //                                      if (wordocc_debug_on && blockocc_show_result)
                    //                                      {
                    //                                              fprintf( db_win,
                    //                                                "Ignoring doubly contained outline (%d, %d) (%d, %d)\n",
                    //                                                box.left(), box.top(),
                    //                                                box.right(), box.bottom());
                    //                                              fprintf( db_win, "\tContained in bands %d and %d\n",
                    //                                                                      band, band + 1 );
                    //                                      }
                }
            }
            else
            {
                //There are transitns
                /*
        Determining a good start point for recognising transitions between bands
        is complicated by error limits on bands.  We need to find a line which
        significantly occupies a band.

        Having found such a point, we need to find a significant transition out of
        its band and start the walk around the outline from there.

        Note that we are relying on having recognised and dealt with elsewhere,
        outlines which do not significantly occupy more than one region. A
        particularly nasty case of this are outlines which do not significantly
        occupy ANY band. I.e. they lie entirely within the error limits.
        Given this condition, all remaining outlines must contain at least one
        significant line.  */

                pt_it = outline_it.data ()->polypts ();

                find_significant_line(pt_it, &band);
                *entry_pt = pt_it.data ()->pos;
                next_region(&pt_it, band, &next_band, &min_x, &max_x, &increment, exit_pt);
                pt_it.mark_cycle_pt ();

                // Found the first real transition, so start walking the outline from here.

                do
                {
                    prev_band = band;
                    band = band + increment;

                    while (band != next_band)
                    {
                        temp_pt = entry_pt;
                        entry_pt = exit_pt;
                        exit_pt = temp_pt;
                        min_x = max_x = entry_pt->x ();

                        find_trans_point(&pt_it, band, band + increment, exit_pt);
                        maintain_limits(&min_x, &max_x, exit_pt->x ());

                        record_region(band, min_x, max_x, find_region_type (prev_band, band, band + increment, entry_pt->x (), exit_pt->x ()), region_occ_list);
                        prev_band = band;
                        band = band + increment;
                    }

                    temp_pt = entry_pt;
                    entry_pt = exit_pt;
                    exit_pt = temp_pt;
                    min_x = max_x = entry_pt->x ();
                    next_region(&pt_it, band, &next_band, &min_x, &max_x, &increment, exit_pt);

                    record_region(band, min_x, max_x, find_region_type(prev_band, band, band + increment, entry_pt->x(), exit_pt->x()), region_occ_list);
                }
                while (!pt_it.cycled_list ());
            }
        }
    }
}

//add region on list
static void record_region(inT16 band, float new_min, float new_max, inT16 region_type, REGION_OCC_LIST *region_occ_list)
{
    REGION_OCC_IT it (&(region_occ_list[band]));

    //   if (wordocc_debug_on && blockocc_show_result)
    //         fprintf( db_win, "\nBand %d, region type %d, from %f to %f",
    //                                 band, region_type, new_min, new_max );

    if ((region_type == REGION_TYPE_UPPER_UNBOUND) || (region_type == REGION_TYPE_LOWER_UNBOUND) || (region_type == REGION_TYPE_EMPTY)) return;

    if (it.empty ())
    {
        it.add_after_stay_put (new REGION_OCC (new_min, new_max, region_type));
    }
    else
    {
        /* Insert in sorted order of average limit */

        while ((new_min + new_max > it.data ()->min_x + it.data ()->max_x) && (!it.at_last ())) it.forward ();

        //at the end
        if ((it.at_last ()) && (new_min + new_max > it.data ()->min_x + it.data ()->max_x))
        {
            //new range > current
            it.add_after_stay_put (new REGION_OCC (new_min, new_max, region_type));
        }
        else
        {
            it.add_before_stay_put (new REGION_OCC (new_min, new_max, region_type));
        }
    }
}

//find range's band
static inT16 find_containing_maximal_band(float y1, float y2, BOOL8 *doubly_contained)
{
    inT16 band;
    *doubly_contained = FALSE;

    for (band = 1; band <= blockocc_band_count; band++)
    {
        if (bands[band].range_in_maximal (y1, y2))
        {
            if ((band < blockocc_band_count) && (bands[band + 1].range_in_maximal (y1, y2)))
            {
                *doubly_contained = TRUE;
            }

            return band;
        }
    }

    return UNDEFINED_BAND;
}


static void find_significant_line(POLYPT_IT it, inT16 *band)
{
    /* Look for a line which significantly occupies at least one band. I.e. part
  of the line is in the non-margin part of the band. */
    *band = find_overlapping_minimal_band(it.data ()->pos.y (), it.data ()->pos.y () + it.data ()->vec.y ());

    while (*band == UNDEFINED_BAND)
    {
        it.forward ();
        *band = find_overlapping_minimal_band (it.data ()->pos.y (), it.data ()->pos.y () + it.data ()->vec.y ());
    }
}

//find range's band
static inT16 find_overlapping_minimal_band(float y1, float y2)
{
    inT16 band;

    for (band = 1; band <= blockocc_band_count; band++)
    {
        if (bands[band].range_overlaps_minimal (y1, y2)) return band;
    }

    return UNDEFINED_BAND;
}


static inT16 find_region_type(inT16 entry_band, inT16 current_band, inT16 exit_band, float entry_x, float exit_x)
{
    if (entry_band > exit_band)
    {
        return REGION_TYPE_OPEN_RIGHT;
    }

    if (entry_band < exit_band)
    {
        return REGION_TYPE_OPEN_LEFT;
    }

    if (entry_x == exit_x)
    {
        return REGION_TYPE_EMPTY;
    }

    if (entry_band > current_band)
    {
        if (entry_x < exit_x)
        {
            return REGION_TYPE_UPPER_BOUND;
        }
        else
        {
            return REGION_TYPE_UPPER_UNBOUND;
        }
    }
    else
    {
        if (entry_x > exit_x)
        {
            return REGION_TYPE_LOWER_BOUND;
        }
        else
        {
            return REGION_TYPE_LOWER_UNBOUND;
        }
    }
}


static void find_trans_point(POLYPT_IT *pt_it, inT16 current_band, inT16 next_band, FCOORD *transition_pt)
{
    float x1, x2, y1, y2;          // points of edge
    float gradient;                // m in y = mx + c
    float offset;                  // c in y = mx + c

    if (current_band < next_band)
    {
        transition_pt->set_y (bands[current_band].max);
    }
    else  //going up
    {
        transition_pt->set_y (bands[current_band].min);
    }
    //going down

    x1 = pt_it->data ()->pos.x ();
    x2 = x1 + pt_it->data ()->vec.x ();
    y1 = pt_it->data ()->pos.y ();
    y2 = y1 + pt_it->data ()->vec.y ();

    if (x1 == x2)
    {
        transition_pt->set_x (x1);   //avoid div by 0
    }
    else
    {
        if (y1 == y2)                //avoid div by 0
        {
            transition_pt->set_x ((x1 + x2) / 2.0);
        }
        else
        {
            gradient = (y1 - y2) / (float) (x1 - x2);
            offset = y1 - x1 * gradient;
            transition_pt->set_x ((transition_pt->y () - offset) / gradient);
        }
    }
}

static void next_region(POLYPT_IT *start_pt_it, inT16 start_band, inT16 *to_band, float *min_x, float *max_x, inT16 *increment, FCOORD *exit_pt)
{
    /*
  Given an edge and a band which the edge significantly occupies, find the
  significant end of the region containing the band. I.e. find an edge which
  points to another band such that the outline subsequetly moves significantly
  out of the starting band.

  Note that we can assume that we are significantly inside the current band to
  start with because the edges passed will be from previous calls to this
  routine apart from the first - the result of which is only used to establish
  the start of the first region.
  */

    inT16 band;                    //band of current edge
    inT16 prev_band = start_band;  //band of prev edge
    //edge crossing out
    POLYPT_IT last_transition_out_it;
    //band it pts to
    inT16 last_trans_out_to_band = 0;
    float ext_min_x = 0.0f;
    float ext_max_x = 0.0f;

    start_pt_it->forward ();
    band = find_band (start_pt_it->data ()->pos.y ());

    while ((band == start_band) || bands[start_band].in_maximal (start_pt_it->data ()->pos.y ()))
    {
        if (band == start_band)
        {
            //Return to start band
            if (prev_band != start_band)
            {
                *min_x = ext_min_x;
                *max_x = ext_max_x;
            }

            maintain_limits (min_x, max_x, start_pt_it->data ()->pos.x ());
        }
        else
        {
            if (prev_band == start_band)
            {
                //Exit from start band
                //so remember edge
                last_transition_out_it = *start_pt_it;
                //before we left
                last_transition_out_it.backward ();
                //and band it pts to
                last_trans_out_to_band = band;
                ext_min_x = *min_x;
                ext_max_x = *max_x;
            }

            maintain_limits (&ext_min_x, &ext_max_x, start_pt_it->data ()->pos.x ());
        }

        prev_band = band;
        start_pt_it->forward ();
        band = find_band (start_pt_it->data ()->pos.y ());
    }

    if (prev_band == start_band)
    { //exit from start band
        *to_band = band;
        //so remember edge
        last_transition_out_it = *start_pt_it;
        //before we left
        last_transition_out_it.backward ();
    }
    else
    {
        *to_band = last_trans_out_to_band;
    }

    if (*to_band > start_band)
    {
        *increment = 1;
    }
    else
    {
        *increment = -1;
    }

    find_trans_point (&last_transition_out_it, start_band,
                      start_band + *increment, exit_pt);
    maintain_limits (min_x, max_x, exit_pt->x ());
    *start_pt_it = last_transition_out_it;
}

// find POINT's band
static inT16 find_band(float y)
{
    inT16 band;

    for (band = 1; band <= blockocc_band_count; band++)
    {
        if (bands[band].in_nominal (y)) return band;
    }

    BLOCKOCC.error ("find_band", ABORT, "Cant find band for %d", y);

    return 0;
}

// join open regions
static void compress_region_list(REGION_OCC_LIST *region_occ_list)
{
    REGION_OCC_IT it (&(region_occ_list[0]));
    REGION_OCC *open_right = NULL;

    inT16 i = 0;
    for (i = 0; i <= blockocc_band_count; i++)
    {
        it.set_to_list (&(region_occ_list[i]));
        if (!it.empty ())
        {
            /* First check for left right pairs. Merge them into the open right and delete
      the open left. */
            open_right = NULL;
            for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
            {
                switch (it.data ()->region_type)
                {
                case REGION_TYPE_OPEN_RIGHT:
                {
                    if (open_right != NULL)
                    {
                        BLOCKOCC.error ("compress_region_list", ABORT, "unmatched right");
                    }
                    else
                    {
                        open_right = it.data ();
                    }
                    break;
                }
                case REGION_TYPE_OPEN_LEFT:
                {
                    if (open_right == NULL)
                    {
                        BLOCKOCC.error ("compress_region_list", ABORT, "unmatched left");
                    }
                    else
                    {
                        open_right->max_x = it.data ()->max_x;
                        open_right = NULL;
                        delete it.extract ();
                    }
                    break;
                }
                default: break;
                }
            }

            if (open_right != NULL) BLOCKOCC.error ("compress_region_list", ABORT, "unmatched right remaining");

            /* Now cycle the list again, merging and deleting any redundant regions */
            it.move_to_first ();
            open_right = it.data ();
            while (!it.at_last ())
            {
                it.forward ();
                if (it.data ()->min_x <= open_right->max_x)
                {
                    // Overlaps
                    if (it.data ()->max_x > open_right->max_x) open_right->max_x = it.data ()->max_x;

                    // Extend
                    delete it.extract ();
                }
                else
                {
                    open_right = it.data ();
                }
            }
        }
    }
}


static void find_fbox(OUTLINE_IT *out_it, float *min_x, float *min_y, float *max_x, float *max_y)
{
    POLYPT_IT pt_it = out_it->data ()->polypts ();
    FCOORD pt;
    *min_x = 9999.0f;
    *min_y = 9999.0f;
    *max_x = 0.0f;
    *max_y = 0.0f;

    for (pt_it.mark_cycle_pt (); !pt_it.cycled_list (); pt_it.forward ())
    {
        pt = pt_it.data ()->pos;
        maintain_limits (min_x, max_x, pt.x ());
        maintain_limits (min_y, max_y, pt.y ());
    }
}


static void maintain_limits(float *min_x, float *max_x, float x)
{
    if (x > *max_x)
    {
        *max_x = x;
    }

    if (x < *min_x)
    {
        *min_x = x;
    }
}
/////////////////////////////////////////////////////////////////blkocc////////////////////////////////////////

/////////////////////////////////////////////////////////////////quadlsq////////////////////////////////////////
const ERRCODE EMPTY_QLSQ = "Can't delete from an empty QLSQ";
#define EXTERN

/**********************************************************************
 * QLSQ::clear
 *
 * Function to initialize a QLSQ.
 **********************************************************************/

void QLSQ::clear() {  //initialize
  a = 0;
  b = 0;
  c = 0;
  n = 0;                         //no elements
  sigx = 0;                      //update accumulators
  sigy = 0;
  sigxx = 0;
  sigxy = 0;
  sigyy = 0;
  sigxxx = 0;
  sigxxy = 0;
  sigxxxx = 0;
}


/**********************************************************************
 * QLSQ::add
 *
 * Add an element to the accumulator.
 **********************************************************************/

void QLSQ::add(           //add an element
               double x,  //xcoord
               double y   //ycoord
              ) {
  n++;                           //count elements
  sigx += x;                     //update accumulators
  sigy += y;
  sigxx += x * x;
  sigxy += x * y;
  sigyy += y * y;
  sigxxx += (long double) x *x * x;
  sigxxy += (long double) x *x * y;
  sigxxxx += (long double) x *x * x * x;
}


/**********************************************************************
 * QLSQ::remove
 *
 * Delete an element from the acculuator.
 **********************************************************************/

void QLSQ::remove(           //delete an element
                  double x,  //xcoord
                  double y   //ycoord
                 ) {
  if (n <= 0)
                                 //illegal
    EMPTY_QLSQ.error ("QLSQ::remove", ABORT, NULL);
  n--;                           //count elements
  sigx -= x;                     //update accumulators
  sigy -= y;
  sigxx -= x * x;
  sigxy -= x * y;
  sigyy -= y * y;
  sigxxx -= (long double) x *x * x;
  sigxxy -= (long double) x *x * y;
  sigxxxx -= (long double) x *x * x * x;
}


/**********************************************************************
 * QLSQ::fit
 *
 * Fit the given degree of polynomial and store the result.
 **********************************************************************/

void QLSQ::fit(            //fit polynomial
               int degree  //degree to fit
              ) {
  long double cubetemp;          //intermediates
  long double squaretemp;
  long double top96, bottom96;   /*accurate top & bottom */

  if (n >= 4 && degree >= 2) {
    cubetemp = sigxxx * n - (long double) sigxx *sigx;

    top96 =
      cubetemp * ((long double) sigxy * n - (long double) sigx * sigy);

    squaretemp = (long double) sigxx *n - (long double) sigx *sigx;

    top96 += squaretemp * ((long double) sigxx * sigy - sigxxy * n);

    bottom96 = cubetemp * cubetemp;

    bottom96 -= squaretemp * (sigxxxx * n - (long double) sigxx * sigxx);

    a = top96 / bottom96;

    top96 = ((long double) sigxx * sigx - sigxxx * n) * a
      + (long double) sigxy *n - (long double) sigx *sigy;
    bottom96 = (long double) sigxx *n - (long double) sigx *sigx;
    b = top96 / bottom96;

    c = (sigy - a * sigxx - b * sigx) / n;
  }
  else if (n == 0 || degree < 0) {
    a = b = c = 0;
  }
  else {
    a = 0;
    if (n > 1 && degree > 0) {
      b = (sigxy * n - sigx * sigy) / (sigxx * n - sigx * sigx);
    }
    else
      b = 0;
    c = (sigy - b * sigx) / n;
  }
}
/////////////////////////////////////////////////////////////////quadlsq////////////////////////////////////////

/////////////////////////////////////////////////////////////////oldbasel////////////////////////////////////////
#define EXTERN
EXTERN BOOL_VAR (textord_really_old_xheight, FALSE,
"Use original wiseowl xheight");
EXTERN BOOL_VAR (textord_oldbl_debug, FALSE, "Debug old baseline generation");
EXTERN BOOL_VAR (textord_debug_baselines, FALSE, "Debug baseline generation");
EXTERN BOOL_VAR (textord_oldbl_paradef, TRUE, "Use para default mechanism");
EXTERN BOOL_VAR (textord_oldbl_split_splines, TRUE, "Split stepped splines");
EXTERN BOOL_VAR (textord_oldbl_merge_parts, TRUE, "Merge suspect partitions");
EXTERN BOOL_VAR (oldbl_corrfix, TRUE, "Improve correlation of heights");
EXTERN BOOL_VAR (oldbl_xhfix, FALSE,
"Fix bug in modes threshold for xheights");
EXTERN BOOL_VAR(textord_ocropus_mode, FALSE, "Make baselines for ocropus");
EXTERN double_VAR (oldbl_xhfract, 0.4, "Fraction of est allowed in calc");
EXTERN INT_VAR (oldbl_holed_losscount, 10,
"Max lost before fallback line used");
EXTERN double_VAR (oldbl_dot_error_size, 1.26, "Max aspect ratio of a dot");
EXTERN double_VAR (textord_oldbl_jumplimit, 0.15,
"X fraction for new partition");

#define TURNLIMIT          1     /*min size for turning point */
#define X_HEIGHT_FRACTION  0.7   /*x-height/caps height */
#define DESCENDER_FRACTION 0.5   /*descender/x-height */
#define MIN_ASC_FRACTION   0.20  /*min size of ascenders */
#define MIN_DESC_FRACTION  0.25  /*min size of descenders */
#define MINASCRISE         2.0   /*min ascender/desc step */
#define MAXHEIGHTVARIANCE  0.15  /*accepted variation in x-height */
#define MAXHEIGHT          300   /*max blob height */
#define MAXOVERLAP         0.1   /*max 10% missed overlap */
#define MAXBADRUN          2     /*max non best for failed */
#define HEIGHTBUCKETS      200   /* Num of buckets */
#define DELTAHEIGHT        5.0   /* Small amount of diff */
#define GOODHEIGHT         5
#define MAXLOOPS           10
#define MODENUM            10
#define MAXPARTS      6
#define SPLINESIZE      23

#define ABS(x) ((x)<0 ? (-(x)) : (x))

/**********************************************************************
 * make_old_baselines
 *
 * Top level function to make baselines the old way.
 **********************************************************************/
//make splines
void make_old_baselines(TO_BLOCK *block,  //block to do
                        BOOL8 testing_on, //correct orientation
                        float gradient,
                        Tesseract* tess
                       )
{
  Q_UNUSED(testing_on);
  QSPLINE *prev_baseline;        //baseline of previous row
  TO_ROW *row;                   //current row
  TO_ROW_IT row_it = block->get_rows ();
  BLOBNBOX_IT blob_it;

  prev_baseline = NULL;          //nothing yet

  for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
  {
    row = row_it.data ();
    find_textlines(block, row, 2, NULL, tess);

    if (row->xheight <= 0 && prev_baseline != NULL)
    {
      find_textlines(block, row, 2, prev_baseline, tess);
    }

    if (row->xheight > 0)  // was a good one
    {
      prev_baseline = &row->baseline;
    }
    else
    {
      prev_baseline = NULL;
      blob_it.set_to_list (row->blob_list ());

      if (textord_debug_baselines)
      {
        tprintf("Row baseline generation failed on row at (%d,%d)\n", blob_it.data()->bounding_box().left(), blob_it.data()->bounding_box().bottom());
      }
    }
  }

  correlate_lines(block, gradient, tess);
}


/**********************************************************************
 * correlate_lines
 *
 * Correlate the x-heights and ascender heights of a block to fill-in
 * the ascender height and descender height for rows without one.
 * Also fix baselines of rows without a decent fit.
 **********************************************************************/
//cleanup lines
void correlate_lines(TO_BLOCK *block, //block to do
                     float gradient,
                     Tesseract* tess
                    )
{
  TO_ROW **rows;                 //array of ptrs
  int rowcount;                  /*no of rows to do */
  register int rowindex;         /*no of row */

  //iterator
  TO_ROW_IT row_it = block->get_rows ();

  rowcount = row_it.length ();
  if (rowcount == 0)
  {
    //default value
    block->xheight = block->line_size;
    return;                      /*none to do */
  }
  rows = (TO_ROW **) alloc_mem (rowcount * sizeof (TO_ROW *));
  rowindex = 0;

  for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
  {
    //make array
    rows[rowindex++] = row_it.data ();
  }


  /*try to fix bad lines */
  correlate_neighbours(block, rows, rowcount, tess);

  if (textord_really_old_xheight || textord_old_xheight)
  {
    block->xheight = (float) correlate_with_stats(rows, rowcount, block);

    if (block->xheight <= 0)
    {
      block->xheight = block->line_size * textord_merge_x;
    }

    if (block->xheight < textord_min_xheight)
    {
      block->xheight = (float) textord_min_xheight;
    }
  }
  else
  {
    compute_block_xheight(block, gradient, tess);
  }

  free_mem(rows);
}


/**********************************************************************
 * correlate_neighbours
 *
 * Try to fix rows that had a bad spline fit by using neighbours.
 **********************************************************************/
//fix bad rows
void correlate_neighbours(TO_BLOCK *block,  /*block rows are in */
                          TO_ROW **rows,    /*rows of block */
                          int rowcount,     /*no of rows to do */
                          Tesseract* tess
                         )
{
  TO_ROW *row;                   /*current row */
  register int rowindex;         /*no of row */
  register int otherrow;         /*second row */
  int upperrow;                  /*row above to use */
  int lowerrow;                  /*row below to use */
  float biggest;

  for (rowindex = 0; rowindex < rowcount; rowindex++)
  {
    row = rows[rowindex];        /*current row */
    if (row->xheight < 0)
    {
     /*quadratic failed */
      for (otherrow = rowindex - 2; otherrow >= 0 && (rows[otherrow]->xheight < 0.0 || !row->baseline.overlap (&rows[otherrow]->baseline, MAXOVERLAP)); otherrow--);


      upperrow = otherrow;       /*decent row above */
      for (otherrow = rowindex + 1; otherrow < rowcount && (rows[otherrow]->xheight < 0.0 || !row->baseline.overlap (&rows[otherrow]->baseline, MAXOVERLAP)); otherrow++);

      lowerrow = otherrow;       /*decent row below */

      if (upperrow >= 0)
      {
        find_textlines(block, row, 2, &rows[upperrow]->baseline, tess);
      }

      if (row->xheight < 0 && lowerrow < rowcount)
      {
        find_textlines(block, row, 2, &rows[lowerrow]->baseline, tess);
      }

      if (row->xheight < 0)
      {
        if (upperrow >= 0)
        {
          find_textlines(block, row, 1, &rows[upperrow]->baseline, tess);
        }
        else if (lowerrow < rowcount)
        {
          find_textlines(block, row, 1, &rows[lowerrow]->baseline, tess);
        }
      }
    }
  }

  for (biggest = 0.0f, rowindex = 0; rowindex < rowcount; rowindex++)
  {
    row = rows[rowindex];        /*current row */
    if (row->xheight < 0)        /*linear failed */
    {
        /*make do */
        row->xheight = -row->xheight;
    }
    biggest = MAX (biggest, row->xheight);
  }
}


/**********************************************************************
 * correlate_with_stats
 *
 * correlate the x-heights and ascender heights of a block to fill-in
 * the ascender height and descender height for rows without one.
 **********************************************************************/
//fix xheights
int correlate_with_stats(TO_ROW **rows,  /*rows of block */
                         int rowcount,   /*no of rows to do */
                         TO_BLOCK* block
                        )
{
  TO_ROW *row;                   /*current row */
  register int rowindex;         /*no of row */
  float lineheight;              /*mean x-height */
  float ascheight;               /*average ascenders */
  float minascheight;            /*min allowed ascheight */
  int xcount;                    /*no of samples for xheight */
  float fullheight;              /*mean top height */
  int fullcount;                 /*no of samples */
  float descheight;              /*mean descender drop */
  float mindescheight;           /*min allowed descheight */
  int desccount;                 /*no of samples */

  /*no samples */
  xcount = fullcount = desccount = 0;
  lineheight = ascheight = fullheight = descheight = 0.0;

  for (rowindex = 0; rowindex < rowcount; rowindex++)
  {
    row = rows[rowindex];        /*current row */
    if (row->ascrise > 0.0)
    {    /*got ascenders? */
      lineheight += row->xheight;/*average x-heights */
      ascheight += row->ascrise; /*average ascenders */
      xcount++;
    }
    else
    {
      fullheight += row->xheight;/*assume full height */
      fullcount++;
    }

    if (row->descdrop < 0.0)
    {
      /*got descenders? */

      /*average descenders */
      descheight += row->descdrop;
      desccount++;
    }
  }

  if (xcount > 0 && (!oldbl_corrfix || xcount >= fullcount))
  {
    lineheight /= xcount;        /*average x-height */

    /*average caps height */
    fullheight = lineheight + ascheight / xcount;

    /*must be decent size */
    if (fullheight < lineheight * (1 + MIN_ASC_FRACTION))
    {
        fullheight = lineheight * (1 + MIN_ASC_FRACTION);
    }
  }
  else
  {
    fullheight /= fullcount;     /*average max height */

    /*guess x-height */
    lineheight = fullheight * X_HEIGHT_FRACTION;
  }

  if (desccount > 0 && (!oldbl_corrfix || desccount >= rowcount / 2))
  {
    descheight /= desccount;     /*average descenders */
  }
  else
  {
    /*guess descenders */
    descheight = -lineheight * DESCENDER_FRACTION;
  }

  if (lineheight > 0.0f)
  {
    block->block->set_cell_over_xheight((fullheight - descheight) / lineheight);
  }

  minascheight = lineheight * MIN_ASC_FRACTION;
  mindescheight = -lineheight * MIN_DESC_FRACTION;
  for (rowindex = 0; rowindex < rowcount; rowindex++)
  {
    row = rows[rowindex];        /*do each row */
    row->all_caps = FALSE;

    if (row->ascrise / row->xheight < MIN_ASC_FRACTION)
    {
      /*no ascenders */
      if (row->xheight >= lineheight * (1 - MAXHEIGHTVARIANCE) && row->xheight <= lineheight * (1 + MAXHEIGHTVARIANCE))
      {
        row->ascrise = fullheight - lineheight;

        /*set to average */
        row->xheight = lineheight;
      }
      else if (row->xheight >= fullheight * (1 - MAXHEIGHTVARIANCE) && row->xheight <= fullheight * (1 + MAXHEIGHTVARIANCE))
      {
        row->ascrise = row->xheight - lineheight;

        /*set to average */
        row->xheight = lineheight;
        row->all_caps = TRUE;
      }
      else
      {
        row->ascrise = (fullheight - lineheight) * row->xheight / fullheight;

        /*scale it */
        row->xheight -= row->ascrise;
        row->all_caps = TRUE;
      }

      if (row->ascrise < minascheight)
      {
        row->ascrise = row->xheight * ((1.0 - X_HEIGHT_FRACTION) / X_HEIGHT_FRACTION);
      }
    }

    if (row->descdrop > mindescheight)
    {
      if (row->xheight >= lineheight * (1 - MAXHEIGHTVARIANCE) && row->xheight <= lineheight * (1 + MAXHEIGHTVARIANCE))
      {
          /*set to average */
          row->descdrop = descheight;
      }
      else
      {
        row->descdrop = -row->xheight * DESCENDER_FRACTION;
      }
    }
  }

  return (int) lineheight;       //block xheight
}


/**********************************************************************
 * find_textlines
 *
 * Compute the baseline for the given row.
 **********************************************************************/
//get baseline
void find_textlines(TO_BLOCK *block,  //block row is in
                    TO_ROW *row,      //row to do
                    int degree,       //required approximation
                    QSPLINE *spline,  //starting spline
                    Tesseract* tess
                   )
{
  int partcount;                 /*no of partitions of */
  BOOL8 holed_line;              //lost too many blobs
  int bestpart;                  /*biggest partition */
  char *partids;                 /*partition no of each blob */
  int partsizes[MAXPARTS];       /*no in each partition */
  int lineheight;                /*guessed x-height */
  float jumplimit;               /*allowed delta change */
  int *xcoords;                  /*useful sample points */
  int *ycoords;                  /*useful sample points */
  TBOX *blobcoords;               /*edges of blob rectangles */
  int blobcount;                 /*no of blobs on line */
  float *ydiffs;                 /*diffs from 1st approx */
  int pointcount;                /*no of coords */
  int xstarts[SPLINESIZE + 1];   //segment boundaries
  int segments;                  //no of segments

                                 //no of blobs in row
  blobcount = row->blob_list ()->length ();
  partids = (char *) alloc_mem (blobcount * sizeof (char));
  xcoords = (int *) alloc_mem (blobcount * sizeof (int));
  ycoords = (int *) alloc_mem (blobcount * sizeof (int));
  blobcoords = (TBOX *) alloc_mem (blobcount * sizeof (TBOX));
  ydiffs = (float *) alloc_mem (blobcount * sizeof (float));

  lineheight = get_blob_coords (row, (int) block->line_size, blobcoords, holed_line, blobcount);

  /*limit for line change */
  jumplimit = lineheight * textord_oldbl_jumplimit;

  if (jumplimit < MINASCRISE)
  {
    jumplimit = MINASCRISE;
  }

  if (textord_oldbl_debug)
  {
    tprintf("\nInput height=%g, Estimate x-height=%d pixels, jumplimit=%.2f\n", block->line_size, lineheight, jumplimit);
  }

  if (holed_line)
  {
    make_holed_baseline (blobcoords, blobcount, spline, &row->baseline, row->line_m ());
  }
  else
  {
    make_first_baseline (blobcoords, blobcount, xcoords, ycoords, spline, &row->baseline, jumplimit);
  }
#ifndef GRAPHICS_DISABLED
  if (textord_show_final_rows)
  {
    row->baseline.plot (to_win, ScrollView::GOLDENROD);
  }
#endif
  if (blobcount > 1)
  {
    bestpart = partition_line (blobcoords, blobcount, &partcount, partids, partsizes, &row->baseline, jumplimit, ydiffs);
    pointcount = partition_coords (blobcoords, blobcount, partids, bestpart, xcoords, ycoords);
    segments = segment_spline (blobcoords, blobcount, xcoords, ycoords, degree, pointcount, xstarts);

    if (!holed_line)
    {
      do
      {
        row->baseline = QSPLINE (xstarts, segments,xcoords, ycoords, pointcount, degree);
      }
      while (textord_oldbl_split_splines && split_stepped_spline (&row->baseline, jumplimit / 2, xcoords, xstarts, segments));
    }

    find_lesser_parts(row, blobcoords, blobcount, partids, partsizes, partcount, bestpart);

  }
  else
  {
    row->xheight = -1.0f;        /*failed */
    row->descdrop = 0.0f;
    row->ascrise = 0.0f;
  }

  row->baseline.extrapolate (row->line_m (), block->block->bounding_box ().left (), block->block->bounding_box ().right ());

  if (textord_really_old_xheight)
  {
    old_first_xheight (row, blobcoords, lineheight, blobcount, &row->baseline, jumplimit);
  }
  else if (textord_old_xheight)
  {
    make_first_xheight(row, blobcoords, lineheight, (int) block->line_size, blobcount, &row->baseline, jumplimit);
  }
  else
  {
    compute_row_xheight(row, row->line_m(), block->line_size, tess);
  }

  free_mem(partids);
  free_mem(xcoords);
  free_mem(ycoords);
  free_mem(blobcoords);
  free_mem(ydiffs);
}


/**********************************************************************
 * get_blob_coords
 *
 * Fill the blobcoords array with the coordinates of the blobs
 * in the row. The return value is the first guess at the line height.
 **********************************************************************/
//get boxes
int get_blob_coords(TO_ROW *row,        //row to use
                    inT32 lineheight,   //block level
                    TBOX *blobcoords,    //ouput boxes
                    BOOL8 &holed_line,  //lost a lot of blobs
                    int &outcount       //no of real blobs
                   )
{
  //blobs
  BLOBNBOX_IT blob_it = row->blob_list ();
  register int blobindex;        /*no along text line */
  int losscount;                 //lost blobs
  int maxlosscount;              //greatest lost blobs
                                 /*height stat collection */
  STATS heightstat (0, MAXHEIGHT);

  if (blob_it.empty ())
  {
    return 0;                    //none
  }

  maxlosscount = 0;
  losscount = 0;
  blob_it.mark_cycle_pt ();
  blobindex = 0;

  do
  {
    blobcoords[blobindex] = box_next_pre_chopped (&blob_it);

    if (blobcoords[blobindex].height () > lineheight * 0.25)
    {
      heightstat.add (blobcoords[blobindex].height (), 1);
    }

    if (blobindex == 0 || blobcoords[blobindex].height () > lineheight * 0.25 || blob_it.cycled_list ())
    {
      blobindex++;               /*no of merged blobs */
      losscount = 0;
    }
    else
    {
      if (blobcoords[blobindex].height () < blobcoords[blobindex].width () * oldbl_dot_error_size && blobcoords[blobindex].width () <
              blobcoords[blobindex].height () * oldbl_dot_error_size)
      {
       //counts as dot
        blobindex++;
        losscount = 0;
      }
      else
      {
        losscount++;             //lost it

        if (losscount > maxlosscount)
        {
            //remember max
            maxlosscount = losscount;
        }
      }
    }
  }
  while (!blob_it.cycled_list ());

  holed_line = maxlosscount > oldbl_holed_losscount;
  outcount = blobindex;          /*total blobs */

  if (heightstat.get_total () > 1)
  {
    /*guess x-height */
    return (int) heightstat.ile (0.25);
  }
  else
  {
    return blobcoords[0].height ();
  }
}


/**********************************************************************
 * make_first_baseline
 *
 * Make the first estimate at a baseline, either by shifting
 * a supplied previous spline, or by doing a piecewise linear
 * approximation using all the blobs.
 **********************************************************************/
//initial approximation
void make_first_baseline(TBOX blobcoords[],                /*blob bounding boxes */
                         int blobcount,                   /*no of blobcoords */
                         int xcoords[],                   /*coords for spline */
                         int ycoords[],                   /*approximator */
                         QSPLINE * spline,                /*initial spline */
                         QSPLINE * baseline,              /*output spline */
                         float jumplimit                  /*guess half descenders */
                        )
{
  int leftedge;                  /*left edge of line */
  int rightedge;                 /*right edge of line */
  int blobindex;                 /*current blob */
  int segment;                   /*current segment */
  float prevy, thisy, nexty;     /*3 y coords */
  float y1, y2, y3;              /*3 smooth blobs */
  float maxmax, minmin;          /*absolute limits */
  int x2 = 0;                    /*right edge of old y3 */
  int ycount;                    /*no of ycoords in use */
  float yturns[SPLINESIZE];      /*y coords of turn pts */
  int xturns[SPLINESIZE];        /*xcoords of turn pts */
  int xstarts[SPLINESIZE + 1];
  int segments;                  //no of segments
  ICOORD shift;                  //shift of spline

  prevy = 0;

  /*left edge of row */
  leftedge = blobcoords[0].left ();

  /*right edge of line */
  rightedge = blobcoords[blobcount - 1].right ();

  if (spline == NULL             /*no given spline */
    || spline->segments < 3      /*or trivial */
    || spline->xcoords[1] > leftedge + MAXOVERLAP * (rightedge - leftedge) /*or too non-overlap */
    || spline->xcoords[spline->segments - 1] < rightedge - MAXOVERLAP * (rightedge - leftedge))
  {
    if (textord_oldbl_paradef)
    {
      return;                    //use default
    }

    xstarts[0] = blobcoords[0].left () - 1;
    for (blobindex = 0; blobindex < blobcount; blobindex++)
    {
      xcoords[blobindex] = (blobcoords[blobindex].left() + blobcoords[blobindex].right ()) / 2;
      ycoords[blobindex] = blobcoords[blobindex].bottom ();
    }

    xstarts[1] = blobcoords[blobcount - 1].right () + 1;
    segments = 1;                /*no of segments */


    /*linear */
    *baseline = QSPLINE (xstarts, segments, xcoords, ycoords, blobcount, 1);

    if (blobcount >= 3)
    {
      y1 = y2 = y3 = 0.0f;
      ycount = 0;
      segment = 0;               /*no of segments */
      maxmax = minmin = 0.0f;
      thisy = ycoords[0] - baseline->y (xcoords[0]);
      nexty = ycoords[1] - baseline->y (xcoords[1]);

      for (blobindex = 2; blobindex < blobcount; blobindex++)
      {
        prevy = thisy;           /*shift ycoords */
        thisy = nexty;
        nexty = ycoords[blobindex] - baseline->y (xcoords[blobindex]);

        /*middle of smooth y */
        if (ABS (thisy - prevy) < jumplimit && ABS (thisy - nexty) < jumplimit)
        {
          y1 = y2;               /*shift window */
          y2 = y3;
          y3 = thisy;            /*middle point */
          ycount++;
                                 /*local max */
          if (ycount >= 3 && ((y1 < y2 && y2 >= y3) || (y1 > y2 && y2 <= y3))) /*local min */
          {
            if (segment < SPLINESIZE - 2)
            {
              /*turning pt */
              xturns[segment] = x2;
              yturns[segment] = y2;
              segment++;         /*no of spline segs */
            }
          }

          if (ycount == 1)
          {
            maxmax = minmin = y3;/*initialise limits */
          }
          else
          {
            if (y3 > maxmax)
            {
              maxmax = y3;       /*biggest max */
            }

            if (y3 < minmin)
            {
              minmin = y3;       /*smallest min */
            }
          }

          /*possible turning pt */
          x2 = blobcoords[blobindex - 1].right ();
        }
      }

      jumplimit *= 1.2;

      /*must be wavy */
      if (maxmax - minmin > jumplimit)
      {
        ycount = segment;        /*no of segments */
        for (blobindex = 0, segment = 1; blobindex < ycount; blobindex++)
        {
          if (yturns[blobindex] > minmin + jumplimit || yturns[blobindex] < maxmax - jumplimit)
          {
            /*significant peak */
            if (segment == 1 || yturns[blobindex] > prevy + jumplimit || yturns[blobindex] < prevy - jumplimit)
            {
              /*different to previous */
              xstarts[segment] = xturns[blobindex];
              segment++;
              prevy = yturns[blobindex];
            }                                  /*bigger max */                                        /*smaller min */
            else if ((prevy > minmin + jumplimit && yturns[blobindex] > prevy) || (prevy < maxmax - jumplimit && yturns[blobindex] < prevy))
            {
              xstarts[segment - 1] = xturns[blobindex];

              /*improved previous */
              prevy = yturns[blobindex];
            }
          }
        }
        xstarts[segment] = blobcoords[blobcount - 1].right () + 1;
        segments = segment;      /*no of segments */

        /*linear */
        *baseline = QSPLINE (xstarts, segments, xcoords, ycoords, blobcount, 1);
      }
    }
  }
  else
  {
    *baseline = *spline;         /*copy it */
    shift = ICOORD (0, (inT16) (blobcoords[0].bottom () - spline->y (blobcoords[0].right ())));
    baseline->move (shift);
  }
}


/**********************************************************************
 * make_holed_baseline
 *
 * Make the first estimate at a baseline, either by shifting
 * a supplied previous spline, or by doing a piecewise linear
 * approximation using all the blobs.
 **********************************************************************/
//initial approximation
void make_holed_baseline(
                        TBOX blobcoords[],                /*blob bounding boxes */
                        int blobcount,                   /*no of blobcoords */
                        QSPLINE * spline,                /*initial spline */
                        QSPLINE * baseline,              /*output spline */
                        float gradient                   //of line
                       )
{
  int leftedge;                  /*left edge of line */
  int rightedge;                 /*right edge of line */
  int blobindex;                 /*current blob */
  float x;                       //centre of row
  ICOORD shift;                  //shift of spline

  LMS lms(blobcount);  //straight baseline
  inT32 xstarts[2];              //straight line
  double coeffs[3];
  float c;                       //line parameter


  /*left edge of row */
  leftedge = blobcoords[0].left ();

  /*right edge of line */
  rightedge = blobcoords[blobcount - 1].right ();

  for (blobindex = 0; blobindex < blobcount; blobindex++)
  {
    lms.add (FCOORD ((blobcoords[blobindex].left () + blobcoords[blobindex].right ()) / 2.0, blobcoords[blobindex].bottom ()));
  }
  lms.constrained_fit (gradient, c);
  xstarts[0] = leftedge;
  xstarts[1] = rightedge;
  coeffs[0] = 0;
  coeffs[1] = gradient;
  coeffs[2] = c;
  *baseline = QSPLINE (1, xstarts, coeffs);

  if (spline != NULL             /*no given spline */
    && spline->segments >= 3     /*or trivial */
    && spline->xcoords[1] <= leftedge + MAXOVERLAP * (rightedge - leftedge) /*or too non-overlap */
    && spline->xcoords[spline->segments - 1] >= rightedge - MAXOVERLAP * (rightedge - leftedge))
  {
    *baseline = *spline;         /*copy it */
    x = (leftedge + rightedge) / 2.0;
    shift = ICOORD (0, (inT16) (gradient * x + c - spline->y (x)));
    baseline->move (shift);
  }
}


/**********************************************************************
 * partition_line
 *
 * Partition a row of blobs into different groups of continuous
 * y position. jumplimit specifies the max allowable limit on a jump
 * before a new partition is started.
 * The return value is the biggest partition
 **********************************************************************/

int partition_line (                 //partition blobs
                    TBOX blobcoords[],                //bounding boxes
                    int blobcount,                   /*no of blobs on row */
                    int *numparts,                   /*number of partitions */
                    char partids[],                  /*partition no of each blob */
                    int partsizes[],                 /*no in each partition */
                    QSPLINE * spline,                /*curve to fit to */
                    float jumplimit,                 /*allowed delta change */
                    float ydiffs[]                   /*diff from spline */
                    )
{
  register int blobindex;        /*no along text line */
  int bestpart;                  /*best new partition */
  int biggestpart;               /*part with most members */
  float diff;                    /*difference from line */
  int startx;                    /*index of start blob */
  float partdiffs[MAXPARTS];     /*step between parts */

  for (bestpart = 0; bestpart < MAXPARTS; bestpart++)
  {
    partsizes[bestpart] = 0;     /*zero them all */
  }

  startx = get_ydiffs (blobcoords, blobcount, spline, ydiffs);
  *numparts = 1;                 /*1 partition */
  bestpart = -1;                 /*first point */
  for (blobindex = startx; blobindex < blobcount; blobindex++)
  {
  /*do each blob in row */
    diff = ydiffs[blobindex];    /*diff from line */

    if (textord_oldbl_debug)
    {
      tprintf ("%d(%d,%d), ", blobindex, blobcoords[blobindex].left (), blobcoords[blobindex].bottom ());
    }
    bestpart = choose_partition(diff, partdiffs, bestpart, jumplimit, numparts);

    /*record partition */
    partids[blobindex] = bestpart;
    partsizes[bestpart]++;       /*another in it */
  }

  bestpart = -1;                 /*first point */
  partsizes[0]--;                /*doing 1st pt again */

  /*do each blob in row */
  for (blobindex = startx; blobindex >= 0; blobindex--)
  {
    diff = ydiffs[blobindex];    /*diff from line */
    if (textord_oldbl_debug)
    {
      tprintf ("%d(%d,%d), ", blobindex, blobcoords[blobindex].left (), blobcoords[blobindex].bottom ());
    }
    bestpart = choose_partition(diff, partdiffs, bestpart, jumplimit, numparts);
                                 /*record partition */
    partids[blobindex] = bestpart;
    partsizes[bestpart]++;       /*another in it */
  }

  for (biggestpart = 0, bestpart = 1; bestpart < *numparts; bestpart++)
  {
    if (partsizes[bestpart] >= partsizes[biggestpart])
    {
      biggestpart = bestpart;    /*new biggest */
    }
  }

  if (textord_oldbl_merge_parts)
  {
    merge_oldbl_parts(blobcoords, blobcount, partids, partsizes, biggestpart,jumplimit);
  }

  return biggestpart;            /*biggest partition */
}


/**********************************************************************
 * merge_oldbl_parts
 *
 * For any adjacent group of blobs in a different part, put them in the
 * main part if they fit closely to neighbours in the main part.
 **********************************************************************/
//partition blobs
void merge_oldbl_parts(
                    TBOX blobcoords[],                //bounding boxes
                    int blobcount,                   /*no of blobs on row */
                    char partids[],                  /*partition no of each blob */
                    int partsizes[],                 /*no in each partition */
                    int biggestpart,                 //major partition
                    float jumplimit                  /*allowed delta change */
                    )
{
  BOOL8 found_one;               //found a bestpart blob
  BOOL8 close_one;               //found was close enough
  register int blobindex;        /*no along text line */
  int prevpart;                  //previous iteration
  int runlength;                 //no in this part
  float diff;                    /*difference from line */
  int startx;                    /*index of start blob */
  int test_blob;                 //another index
  FCOORD coord;                  //blob coordinate
  float m, c;                    //fitted line
  QLSQ stats;                    //line stuff

  prevpart = biggestpart;
  runlength = 0;
  startx = 0;

  for (blobindex = 0; blobindex < blobcount; blobindex++)
  {
    if (partids[blobindex] != prevpart)
    {
      //                      tprintf("Partition change at (%d,%d) from %d to %d after run of %d\n",
      //                              blobcoords[blobindex].left(),blobcoords[blobindex].bottom(),
      //                              prevpart,partids[blobindex],runlength);
      if (prevpart != biggestpart && runlength > MAXBADRUN)
      {
        stats.clear ();
        for (test_blob = startx; test_blob < blobindex; test_blob++)
        {
          coord = FCOORD ((blobcoords[test_blob].left () + blobcoords[test_blob].right ()) / 2.0, blobcoords[test_blob].bottom ());
          stats.add (coord.x (), coord.y ());
        }

        stats.fit (1);
        m = stats.get_b ();
        c = stats.get_c ();
        if (textord_oldbl_debug)
        {
          tprintf ("Fitted line y=%g x + %g\n", m, c);
        }

        found_one = FALSE;
        close_one = FALSE;

        for (test_blob = 1; !found_one && (startx - test_blob >= 0 || blobindex + test_blob <= blobcount); test_blob++)
        {
          if (startx - test_blob >= 0 && partids[startx - test_blob] == biggestpart)
          {
            found_one = TRUE;
            coord = FCOORD((blobcoords[startx - test_blob].left() + blobcoords[startx - test_blob].right()) / 2.0, blobcoords[startx - test_blob].bottom());
            diff = m * coord.x () + c - coord.y ();

            if (textord_oldbl_debug)
            {
              tprintf("Diff of common blob to suspect part=%g at (%g,%g)\n", diff, coord.x(), coord.y());
            }

            if (diff < jumplimit && -diff < jumplimit)
            {
              close_one = TRUE;
            }
          }

          if (blobindex + test_blob <= blobcount && partids[blobindex + test_blob - 1] == biggestpart)
          {
            found_one = TRUE;
            coord = FCOORD((blobcoords[blobindex + test_blob - 1].left() + blobcoords[blobindex + test_blob - 1].right()) / 2.0,
                    blobcoords[blobindex + test_blob - 1].bottom ());

            diff = m * coord.x () + c - coord.y ();
            if (textord_oldbl_debug)
            {
              tprintf("Diff of common blob to suspect part=%g at (%g,%g)\n", diff, coord.x (), coord.y ());
            }

            if (diff < jumplimit && -diff < jumplimit)
            {
              close_one = TRUE;
            }
          }
        }

        if (close_one)
        {
          if (textord_oldbl_debug)
          {
            tprintf("Merged %d blobs back into part %d from %d starting at (%d,%d)\n",
                    runlength, biggestpart, prevpart, blobcoords[startx].left (), blobcoords[startx].bottom ());
          }

          //switch sides
          partsizes[prevpart] -= runlength;

          for (test_blob = startx; test_blob < blobindex; test_blob++)
          {
            partids[test_blob] = biggestpart;
          }
        }
      }

      prevpart = partids[blobindex];
      runlength = 1;
      startx = blobindex;
    }
    else
    {
      runlength++;
    }
  }
}


/**********************************************************************
 * get_ydiffs
 *
 * Get the differences between the blobs and the spline,
 * putting them in ydiffs.  The return value is the index
 * of the blob in the middle of the "best behaved" region
 **********************************************************************/
//evaluate differences
int get_ydiffs(
            TBOX blobcoords[],                //bounding boxes
            int blobcount,                   /*no of blobs */
            QSPLINE * spline,                /*approximating spline */
            float ydiffs[]                   /*output */
            )
{
  register int blobindex;        /*current blob */
  int xcentre;                   /*xcoord */
  int lastx;                     /*last xcentre */
  float diffsum;                 /*sum of diffs */
  float diff;                    /*current difference */
  float drift;                   /*sum of spline steps */
  float bestsum;                 /*smallest diffsum */
  int bestindex;                 /*index of bestsum */

  diffsum = 0.0f;
  bestindex = 0;
  bestsum = (float) MAX_INT32;
  drift = 0.0f;
  lastx = blobcoords[0].left ();

  /*do each blob in row */
  for (blobindex = 0; blobindex < blobcount; blobindex++)
  {
    /*centre of blob */
    xcentre = (blobcoords[blobindex].left () + blobcoords[blobindex].right ()) >> 1;

    //step functions in spline
    drift += spline->step (lastx, xcentre);
    lastx = xcentre;
    diff = blobcoords[blobindex].bottom ();
    diff -= spline->y (xcentre);
    diff += drift;
    ydiffs[blobindex] = diff;    /*store difference */

    if (blobindex > 2)
    {
      /*remove old one */
      diffsum -= ABS (ydiffs[blobindex - 3]);
    }
    diffsum += ABS (diff);       /*add new one */

    if (blobindex >= 2 && diffsum < bestsum)
    {
      bestsum = diffsum;         /*find min sum */
      bestindex = blobindex - 1; /*middle of set */
    }
  }

  return bestindex;
}


/**********************************************************************
 * choose_partition
 *
 * Choose a partition for the point and return the index.
 **********************************************************************/
//select partition
int choose_partition(
                    register float diff,             /*diff from spline */
                    float partdiffs[],               /*diff on all parts */
                    int lastpart,                    /*last assigned partition */
                    float jumplimit,                 /*new part threshold */
                    int *partcount                   /*no of partitions */
                    )
{
  register int partition;        /*partition no */
  int bestpart;                  /*best new partition */
  float bestdelta;               /*best gap from a part */
  static float drift;            /*drift from spline */
  float delta;                   /*diff from part */
  static float lastdelta;        /*previous delta */

  if (lastpart < 0)
  {
    partdiffs[0] = diff;
    lastpart = 0;                /*first point */
    drift = 0.0f;
    lastdelta = 0.0f;
  }

  /*adjusted diff from part */
  delta = diff - partdiffs[lastpart] - drift;
  if (textord_oldbl_debug)
  {
    tprintf ("Diff=%.2f, Delta=%.3f, Drift=%.3f, ", diff, delta, drift);
  }
  if (ABS (delta) > jumplimit / 2)
  {
    /*delta on part 0 */
    bestdelta = diff - partdiffs[0] - drift;
    bestpart = 0;                /*0 best so far */

    for (partition = 1; partition < *partcount; partition++)
    {
      delta = diff - partdiffs[partition] - drift;
      if (ABS (delta) < ABS (bestdelta))
      {
        bestdelta = delta;
        bestpart = partition;    /*part with nearest jump */
      }
    }
    delta = bestdelta;

    /*too far away */
    if (ABS (bestdelta) > jumplimit && *partcount < MAXPARTS)
    {
      /*and spare part left */
      bestpart = (*partcount)++; /*best was new one */

      /*start new one */
      partdiffs[bestpart] = diff - drift;
      delta = 0.0f;
    }
  }
  else
  {
    bestpart = lastpart;         /*best was last one */
  }

  if (bestpart == lastpart && (ABS (delta - lastdelta) < jumplimit / 2 || ABS (delta) < jumplimit / 2))
  {
    /*smooth the drift */
    drift = (3 * drift + delta) / 3;
  }
  lastdelta = delta;

  if (textord_oldbl_debug)
  {
    tprintf ("P=%d\n", bestpart);
  }

  return bestpart;
}

/**********************************************************************
 * partition_coords
 *
 * Get the x,y coordinates of all points in the bestpart and put them
 * in xcoords,ycoords. Return the number of points found.
 **********************************************************************/
//find relevant coords
int partition_coords(TBOX blobcoords[],                //bounding boxes
                    int blobcount,                   /*no of blobs in row */
                    char partids[],                  /*partition no of each blob */
                    int bestpart,                    /*best new partition */
                    int xcoords[],                   /*points to work on */
                    int ycoords[]                    /*points to work on */
                    )
{
  register int blobindex;        /*no along text line */
  int pointcount;                /*no of points */

  pointcount = 0;
  for (blobindex = 0; blobindex < blobcount; blobindex++)
  {
    if (partids[blobindex] == bestpart)
    {
      /*centre of blob */
      xcoords[pointcount] = (blobcoords[blobindex].left () + blobcoords[blobindex].right ()) >> 1;
      ycoords[pointcount++] = blobcoords[blobindex].bottom ();
    }
  }

  return pointcount;             /*no of points found */
}


/**********************************************************************
 * segment_spline
 *
 * Segment the row at midpoints between maxima and minima of the x,y pairs.
 * The xstarts of the segments are returned and the number found.
 **********************************************************************/
//make xstarts
int segment_spline(TBOX blobcoords[],                //boundign boxes
                    int blobcount,                   /*no of blobs in row */
                    int xcoords[],                   /*points to work on */
                    int ycoords[],                   /*points to work on */
                    int degree, int pointcount,      /*no of points */
                    int xstarts[]                    //result
                    )
{
  Q_UNUSED(blobcoords);
  Q_UNUSED(blobcount);
  register int ptindex;          /*no along text line */
  register int segment;          /*partition no */
  int lastmin, lastmax;          /*possible turn points */
  int turnpoints[SPLINESIZE];    /*good turning points */
  int turncount;                 /*no of turning points */
  int max_x;                     //max specified coord

  xstarts[0] = xcoords[0] - 1;   //leftmost defined pt
  max_x = xcoords[pointcount - 1] + 1;
  if (degree < 2)
  {
    pointcount = 0;
  }

  turncount = 0;                 /*no turning points yet */
  if (pointcount > 3)
  {
    ptindex = 1;
    lastmax = lastmin = 0;       /*start with first one */

    while (ptindex < pointcount - 1 && turncount < SPLINESIZE - 1)
    {
      /*minimum */
      if (ycoords[ptindex - 1] > ycoords[ptindex] && ycoords[ptindex] <= ycoords[ptindex + 1])
      {
        if (ycoords[ptindex] < ycoords[lastmax] - TURNLIMIT)
        {
          if (turncount == 0 || turnpoints[turncount - 1] != lastmax)
          {
            /*new max point */
            turnpoints[turncount++] = lastmax;
          }

          lastmin = ptindex;     /*latest minimum */
        }
        else if (ycoords[ptindex] < ycoords[lastmin])
        {
          lastmin = ptindex;     /*lower minimum */
        }
      }

                                 /*maximum */
      if (ycoords[ptindex - 1] < ycoords[ptindex] && ycoords[ptindex] >= ycoords[ptindex + 1])
      {
        if (ycoords[ptindex] > ycoords[lastmin] + TURNLIMIT)
        {
          if (turncount == 0 || turnpoints[turncount - 1] != lastmin)
          {
            /*new min point */
            turnpoints[turncount++] = lastmin;
          }

          lastmax = ptindex;     /*latest maximum */
        }
        else if (ycoords[ptindex] > ycoords[lastmax])
        {
          lastmax = ptindex;     /*higher maximum */
        }
      }

      ptindex++;
    }

    /*possible global min */
    if (ycoords[ptindex] < ycoords[lastmax] - TURNLIMIT && (turncount == 0 || turnpoints[turncount - 1] != lastmax))
    {
      if (turncount < SPLINESIZE - 1)
      {
         /*2 more turns */
        turnpoints[turncount++] = lastmax;
      }

      if (turncount < SPLINESIZE - 1)
      {
        turnpoints[turncount++] = ptindex;
      }
    }                           /*possible global max */
    else if (ycoords[ptindex] > ycoords[lastmin] + TURNLIMIT && (turncount == 0 || turnpoints[turncount - 1] != lastmin))
    {
      if (turncount < SPLINESIZE - 1)
      {
        /*2 more turns */
        turnpoints[turncount++] = lastmin;
      }

      if (turncount < SPLINESIZE - 1)
      {
        turnpoints[turncount++] = ptindex;
      }
    }
    else if (turncount > 0 && turnpoints[turncount - 1] == lastmin && turncount < SPLINESIZE - 1)
    {
      if (ycoords[ptindex] > ycoords[lastmax])
      {
        turnpoints[turncount++] = ptindex;
      }
      else
      {
        turnpoints[turncount++] = lastmax;
      }
    }
    else if (turncount > 0 && turnpoints[turncount - 1] == lastmax && turncount < SPLINESIZE - 1)
    {
      if (ycoords[ptindex] < ycoords[lastmin])
      {
        turnpoints[turncount++] = ptindex;
      }
      else
      {
        turnpoints[turncount++] = lastmin;
      }
    }
  }

  if (textord_oldbl_debug && turncount > 0)
  {
    tprintf ("First turn is %d at (%d,%d)\n", turnpoints[0], xcoords[turnpoints[0]], ycoords[turnpoints[0]]);
  }

  for (segment = 1; segment < turncount; segment++)
  {
    /*centre y coord */
    lastmax = (ycoords[turnpoints[segment - 1]] + ycoords[turnpoints[segment]]) / 2;

    /* fix alg so that it works with both rising and falling sections */
    if (ycoords[turnpoints[segment - 1]] < ycoords[turnpoints[segment]])
    {
      /*find rising y centre */
      for (ptindex = turnpoints[segment - 1] + 1; ptindex < turnpoints[segment] && ycoords[ptindex + 1] <= lastmax; ptindex++);
    }
    else
    {
      /*find falling y centre */
      for (ptindex = turnpoints[segment - 1] + 1; ptindex < turnpoints[segment] && ycoords[ptindex + 1] >= lastmax; ptindex++);
    }


    /*centre x */
    xstarts[segment] = (xcoords[ptindex - 1] + xcoords[ptindex] + xcoords[turnpoints[segment - 1]] + xcoords[turnpoints[segment]] + 2) / 4;

    /*halfway between turns */
    if (textord_oldbl_debug)
    {
      tprintf ("Turn %d is %d at (%d,%d), mid pt is %d@%d, final @%d\n",
               segment, turnpoints[segment], xcoords[turnpoints[segment]], ycoords[turnpoints[segment]], ptindex - 1, xcoords[ptindex - 1], xstarts[segment]);
    }
  }

  xstarts[segment] = max_x;

  return segment;                /*no of splines */
}


/**********************************************************************
 * split_stepped_spline
 *
 * Re-segment the spline in cases where there is a big step function.
 * Return TRUE if any were done.
 **********************************************************************/
//make xstarts
BOOL8 split_stepped_spline(QSPLINE * baseline,              //current shot
                           float jumplimit,                 //max step fuction
                           int xcoords[],                   /*points to work on */
                           int xstarts[],                   //result
                           int &segments                    //no of segments
                           )
{
  BOOL8 doneany;                 //return value
  register int segment;          /*partition no */
  int startindex, centreindex, endindex;
  float leftcoord, rightcoord;
  int leftindex, rightindex;
  float step;                    //spline step

  doneany = FALSE;
  startindex = 0;

  for (segment = 1; segment < segments - 1; segment++)
  {
    step = baseline->step ((xstarts[segment - 1] + xstarts[segment]) / 2.0, (xstarts[segment] + xstarts[segment + 1]) / 2.0);

    if (step < 0)
    {
      step = -step;
    }

    if (step > jumplimit)
    {
      while (xcoords[startindex] < xstarts[segment - 1])
      {
        startindex++;
      }
      centreindex = startindex;

      while (xcoords[centreindex] < xstarts[segment])
      {
        centreindex++;
      }
      endindex = centreindex;

      while (xcoords[endindex] < xstarts[segment + 1])
      {
        endindex++;
      }

      if (segments >= SPLINESIZE)
      {
        if (textord_debug_baselines)
        {
          tprintf ("Too many segments to resegment spline!!\n");
        }
      }
      else if (endindex - startindex >= textord_spline_medianwin * 3)
      {
        while (centreindex - startindex < textord_spline_medianwin * 3 / 2)
        {
          centreindex++;
        }

        while (endindex - centreindex < textord_spline_medianwin * 3 / 2)
        {
          centreindex--;
        }
        leftindex = (startindex + startindex + centreindex) / 3;
        rightindex = (centreindex + endindex + endindex) / 3;
        leftcoord = (xcoords[startindex] * 2 + xcoords[centreindex]) / 3.0;
        rightcoord = (xcoords[centreindex] + xcoords[endindex] * 2) / 3.0;

        while (xcoords[leftindex] > leftcoord && leftindex - startindex > textord_spline_medianwin)
        {
          leftindex--;
        }

        while (xcoords[leftindex] < leftcoord && centreindex - leftindex > textord_spline_medianwin / 2)
        {
          leftindex++;
        }

        if (xcoords[leftindex] - leftcoord > leftcoord - xcoords[leftindex - 1])
        {
          leftindex--;
        }

        while (xcoords[rightindex] > rightcoord && rightindex - centreindex > textord_spline_medianwin / 2)
        {
          rightindex--;
        }

        while (xcoords[rightindex] < rightcoord && endindex - rightindex > textord_spline_medianwin)
        {
          rightindex++;
        }

        if (xcoords[rightindex] - rightcoord > rightcoord - xcoords[rightindex - 1])
        {
          rightindex--;
        }

        if (textord_debug_baselines)
        {
          tprintf ("Splitting spline at %d with step %g at (%d,%d)\n", xstarts[segment], baseline-> step ((xstarts[segment - 1] + xstarts[segment]) / 2.0,
            (xstarts[segment] + xstarts[segment + 1]) / 2.0), (xcoords[leftindex - 1] + xcoords[leftindex]) / 2, (xcoords[rightindex - 1] + xcoords[rightindex]) / 2);
        }

        insert_spline_point (xstarts, segment, (xcoords[leftindex - 1] + xcoords[leftindex]) / 2, (xcoords[rightindex - 1] + xcoords[rightindex]) / 2, segments);
        doneany = TRUE;
      }
      else if (textord_debug_baselines)
      {
        tprintf("Resegmenting spline failed - insufficient pts (%d,%d,%d,%d)\n", startindex, centreindex, endindex, (inT32) textord_spline_medianwin);
      }
    }
  }

  return doneany;
}


/**********************************************************************
 * insert_spline_point
 *
 * Insert a new spline point and shuffle up the others.
 **********************************************************************/
//get descenders
void insert_spline_point(int xstarts[],                   //starts to shuffle
                        int segment,                     //insertion pt
                        int coord1,                      //coords to add
                        int coord2, int &segments        //total segments
                        )
{
  int index;                     //for shuffling

  for (index = segments; index > segment; index--)
  {
    xstarts[index + 1] = xstarts[index];
  }

  segments++;
  xstarts[segment] = coord1;
  xstarts[segment + 1] = coord2;
}


/**********************************************************************
 * find_lesser_parts
 *
 * Average the step from the spline for the other partitions
 * and find the commonest partition which has a descender.
 **********************************************************************/
//get descenders
void find_lesser_parts(TO_ROW * row,                    //row to process
                    TBOX blobcoords[],                //bounding boxes
                    int blobcount,                   /*no of blobs */
                    char partids[],                  /*partition of each blob */
                    int partsizes[],                 /*size of each part */
                    int partcount,                   /*no of partitions */
                    int bestpart                     /*biggest partition */
                    )
{
  register int blobindex;        /*index of blob */
  register int partition;        /*current partition */
  int xcentre;                   /*centre of blob */
  int poscount;                  /*count of best up step */
  int negcount;                  /*count of best down step */
  float partsteps[MAXPARTS];     /*average step to part */
  float bestneg = 0;                 /*best down step */
  int runlength;                 /*length of bad run */
  int biggestrun;                /*biggest bad run */

  biggestrun = 0;
  for (partition = 0; partition < partcount; partition++)
  {
    partsteps[partition] = 0.0;  /*zero accumulators */
  }

  for (runlength = 0, blobindex = 0; blobindex < blobcount; blobindex++)
  {
    xcentre = (blobcoords[blobindex].left() + blobcoords[blobindex].right()) >> 1;

    /*in other parts */
    if (partids[blobindex] != bestpart)
    {
      runlength++;               /*run of non bests */
      if (runlength > biggestrun)
      {
        biggestrun = runlength;
      }
      partsteps[(int)partids[blobindex]] += blobcoords[blobindex].bottom() - row->baseline.y(xcentre);
    }
    else
    {
      runlength = 0;
    }
  }

  if (biggestrun > MAXBADRUN)
  {
    row->xheight = -1.0f;        /*failed */
  }
  else
  {
    row->xheight = 1.0f;         /*success */
  }
  poscount = negcount = 0;

  for (partition = 0; partition < partcount; partition++)
  {
    if (partition != bestpart)
    {

    //by jetsoft divide by zero possible
        if (partsizes[partition]==0)
        {
            partsteps[partition]=0;
        }
        else
        {
            partsteps[partition] /= partsizes[partition];
        }
    //


      if (partsteps[partition] >= MINASCRISE && partsizes[partition] > poscount)
      {
        /*2nd most popular */
        poscount = partsizes[partition];
      }

      if (partsteps[partition] <= -MINASCRISE && partsizes[partition] > negcount)
      {
        /*ascender rise */
        bestneg = partsteps[partition];

        /*2nd most popular */
        negcount = partsizes[partition];
      }
    }
  }

  /*average x-height */
  partsteps[bestpart] /= blobcount;
  row->descdrop = bestneg;
}


/**********************************************************************
 * old_first_xheight
 *
 * Makes an x-height spline by copying the baseline and shifting it.
 * It estimates the x-height across the line to use as the shift.
 * It also finds the ascender height if it can.
 **********************************************************************/
//the wiseowl way
void old_first_xheight(TO_ROW * row,                    /*current row */
                        TBOX blobcoords[],                /*blob bounding boxes */
                        int initialheight,               //initial guess
                        int blobcount,                   /*blobs in blobcoords */
                        QSPLINE * baseline,              /*established */
                        float jumplimit                  /*min ascender height */
                        )
{
  register int blobindex;        /*current blob */

  /*height statistics */
  STATS heightstat (0, MAXHEIGHT);
  int height;                    /*height of blob */
  int xcentre;                   /*centre of blob */
  int lineheight;                /*approx xheight */
  float ascenders;               /*ascender sum */
  int asccount;                  /*no of ascenders */
  float xsum;                    /*xheight sum */
  int xcount;                    /*xheight count */
  register float diff;           /*height difference */

  if (blobcount > 1)
  {
    for (blobindex = 0; blobindex < blobcount; blobindex++)
    {
      xcentre = (blobcoords[blobindex].left () + blobcoords[blobindex].right ()) / 2;

      /*height of blob */
      height = (int) (blobcoords[blobindex].top () - baseline->y (xcentre) + 0.5);

      if (height > initialheight * oldbl_xhfract && height > textord_min_xheight)
      {
        heightstat.add (height, 1);
      }
    }

    if (heightstat.get_total () > 3)
    {
      lineheight = (int) heightstat.ile (0.25);

      if (lineheight <= 0)
      {
        lineheight = (int) heightstat.ile (0.5);
      }
    }
    else
    {
      lineheight = initialheight;
    }
  }
  else
  {
    lineheight = (int)(blobcoords[0].top() - baseline->y((blobcoords[0].left() + blobcoords[0].right()) / 2) + 0.5);
  }

  xsum = 0.0f;
  xcount = 0;
  for (ascenders = 0.0f, asccount = 0, blobindex = 0; blobindex < blobcount; blobindex++)
  {
    xcentre = (blobcoords[blobindex].left () + blobcoords[blobindex].right ()) / 2;
    diff = blobcoords[blobindex].top () - baseline->y (xcentre);

    /*is it ascender */
    if (diff > lineheight + jumplimit)
    {
      ascenders += diff;
      asccount++;                /*count ascenders */
    }
    else if (diff > lineheight - jumplimit)
    {
      xsum += diff;              /*mean xheight */
      xcount++;
    }
  }

  if (xcount > 0)
  {
    xsum /= xcount;              /*average xheight */
  }
  else
  {
    xsum = (float) lineheight;   /*guess it */
  }
  row->xheight *= xsum;

  if (asccount > 0)
  {
    row->ascrise = ascenders / asccount - xsum;
  }
  else
  {
    row->ascrise = 0.0f;         /*had none */
  }

  if (row->xheight == 0)
  {
    row->xheight = -1.0f;
  }
}


/**********************************************************************
 * make_first_xheight
 *
 * Makes an x-height spline by copying the baseline and shifting it.
 * It estimates the x-height across the line to use as the shift.
 * It also finds the ascender height if it can.
 **********************************************************************/
//find xheight
void make_first_xheight(TO_ROW * row,                    /*current row */
                        TBOX blobcoords[],                /*blob bounding boxes */
                        int lineheight,                  //initial guess
                        int init_lineheight,             //block level guess
                        int blobcount,                   /*blobs in blobcoords */
                        QSPLINE * baseline,              /*established */
                        float jumplimit                  /*min ascender height */
                        )
{
  Q_UNUSED(jumplimit);
  STATS heightstat (0, HEIGHTBUCKETS);
  int lefts[HEIGHTBUCKETS];
  int rights[HEIGHTBUCKETS];
  int modelist[MODENUM];
  int blobindex;
  int mode_count;                //blobs to count in thr
  int sign_bit;
  int mode_threshold;
  const int kBaselineTouch = 2;  // This really should change with resolution.
  const int kGoodStrength = 8;  // Strength of baseline-touching heights.
  const float kMinHeight = 0.25;  // Min fraction of lineheight to use.

  sign_bit = row->xheight > 0 ? 1 : -1;

  memset(lefts, 0, HEIGHTBUCKETS * sizeof(lefts[0]));
  memset(rights, 0, HEIGHTBUCKETS * sizeof(rights[0]));
  mode_count = 0;

  for (blobindex = 0; blobindex < blobcount; blobindex++)
  {
    int xcenter = (blobcoords[blobindex].left () + blobcoords[blobindex].right ()) / 2;
    float base = baseline->y(xcenter);
    float bottomdiff = fabs(base - blobcoords[blobindex].bottom());
    int strength = textord_ocropus_mode && bottomdiff <= kBaselineTouch ? kGoodStrength : 1;
    int height = static_cast<int>(blobcoords[blobindex].top () - base + 0.5);

    if (blobcoords[blobindex].height () > init_lineheight * kMinHeight)
    {
      if (height > lineheight * oldbl_xhfract && height > textord_min_xheight)
      {
        heightstat.add (height, strength);

        if (height < HEIGHTBUCKETS)
        {
          if (xcenter > rights[height])
          {
            rights[height] = xcenter;
          }

          if (xcenter > 0 && (lefts[height] == 0 || xcenter < lefts[height]))
          {
            lefts[height] = xcenter;
          }
        }
      }
      mode_count += strength;
    }
  }

  mode_threshold = (int) (blobcount * 0.1);
  if (oldbl_dot_error_size > 1 || oldbl_xhfix)
  {
    mode_threshold = (int) (mode_count * 0.1);
  }

  if (textord_oldbl_debug)
  {
    tprintf ("blobcount=%d, mode_count=%d, mode_t=%d\n", blobcount, mode_count, mode_threshold);
  }
  find_top_modes(&heightstat, HEIGHTBUCKETS, modelist, MODENUM);

  if (textord_oldbl_debug)
  {
    for (blobindex = 0; blobindex < MODENUM; blobindex++)
    {
      tprintf("mode[%d]=%d ", blobindex, modelist[blobindex]);
    }
    tprintf ("\n");
  }
  pick_x_height(row, modelist, lefts, rights, &heightstat, mode_threshold);

  if (textord_oldbl_debug)
  {
    tprintf("Output xheight=%g\n", row->xheight);
  }

  if (row->xheight < 0 && textord_oldbl_debug)
  {
    tprintf ("warning: Row Line height < 0; %4.2f\n", row->xheight);
  }

  if (sign_bit < 0)
  {
    row->xheight = -row->xheight;
  }
}

/**********************************************************************
 * find_top_modes
 *
 * Fill the input array with the indices of the top ten modes of the
 * input distribution.
 **********************************************************************/

const int kMinModeFactorOcropus = 32;
const int kMinModeFactor = 12;

//get modes
void find_top_modes(STATS * stats,                   //stats to hack
                    int statnum,                     //no of piles
                    int modelist[], int modenum      //no of modes to get
                    )
{
  int mode_count;
  int last_i = 0;
  int last_max = MAX_INT32;
  int i;
  int mode;
  int total_max = 0;
  int mode_factor = textord_ocropus_mode ? kMinModeFactorOcropus : kMinModeFactor;

  for (mode_count = 0; mode_count < modenum; mode_count++)
  {
    mode = 0;
    for (i = 0; i < statnum; i++)
    {
      if (stats->pile_count (i) > stats->pile_count (mode))
      {
        if ((stats->pile_count (i) < last_max) || ((stats->pile_count (i) == last_max) && (i > last_i)))
        {
          mode = i;
        }
      }
    }

    last_i = mode;
    last_max = stats->pile_count (last_i);
    total_max += last_max;
    if (last_max <= total_max / mode_factor)
    {
      mode = 0;
    }

    modelist[mode_count] = mode;
  }
}


/**********************************************************************
 * pick_x_height
 *
 * Choose based on the height modes the best x height value.
 **********************************************************************/

void pick_x_height(TO_ROW * row,                    //row to do
                   int modelist[],
                   int lefts[], int rights[],
                   STATS * heightstat,
                   int mode_threshold)
{
  int x;
  int y;
  int z;
  float ratio;
  int found_one_bigger = FALSE;
  int best_x_height = 0;
  int best_asc = 0;
  int num_in_best;

  for (x = 0; x < MODENUM; x++)
  {
    for (y = 0; y < MODENUM; y++)
    {
      /* Check for two modes */
      if (modelist[x] && modelist[y] && heightstat->pile_count (modelist[x]) > mode_threshold && (!textord_ocropus_mode ||
           MIN(rights[modelist[x]], rights[modelist[y]]) >
           MAX(lefts[modelist[x]], lefts[modelist[y]])))
      {
        ratio = (float) modelist[y] / (float) modelist[x];
        if (1.2 < ratio && ratio < 1.8)
        {
          /* Two modes found */
          best_x_height = modelist[x];
          num_in_best = heightstat->pile_count (modelist[x]);

          /* Try to get one higher */
          do
          {
            found_one_bigger = FALSE;
            for (z = 0; z < MODENUM; z++)
            {
              if (modelist[z] == best_x_height + 1 &&
                  (!textord_ocropus_mode || MIN(rights[modelist[x]], rights[modelist[y]]) >
                    MAX(lefts[modelist[x]], lefts[modelist[y]])))
              {
                ratio = (float) modelist[y] / (float) modelist[z];

                /* Should be half of best */
                if ((1.2 < ratio && ratio < 1.8) &&heightstat->pile_count (modelist[z]) > num_in_best * 0.5)
                {
                  best_x_height++;
                  found_one_bigger = TRUE;
                  break;
                }
              }
            }
          }
          while (found_one_bigger);

          /* try to get a higher ascender */

          best_asc = modelist[y];
          num_in_best = heightstat->pile_count (modelist[y]);

          /* Try to get one higher */
          do
          {
            found_one_bigger = FALSE;
            for (z = 0; z < MODENUM; z++)
            {
              if (modelist[z] > best_asc && (!textord_ocropus_mode || MIN(rights[modelist[x]], rights[modelist[y]]) >
                    MAX(lefts[modelist[x]], lefts[modelist[y]])))
              {
                ratio = (float) modelist[z] / (float) best_x_height;

                /* Should be half of best */
                if ((1.2 < ratio && ratio < 1.8) && heightstat->pile_count (modelist[z]) > num_in_best * 0.5)
                {
                  best_asc = modelist[z];
                  found_one_bigger = TRUE;
                  break;
                }
              }
            }
          }
          while (found_one_bigger);

          row->xheight = (float) best_x_height;
          row->ascrise = (float) best_asc - best_x_height;
          return;
        }
      }
    }
  }

  best_x_height = modelist[0];   /* Single Mode found */
  num_in_best = heightstat->pile_count (best_x_height);
  do
  {
    /* Try to get one higher */
    found_one_bigger = FALSE;
    for (z = 1; z < MODENUM; z++)
    {
      /* Should be half of best */
      if ((modelist[z] == best_x_height + 1) && (heightstat->pile_count (modelist[z]) > num_in_best * 0.5))
      {
        best_x_height++;
        found_one_bigger = TRUE;
        break;
      }
    }
  }
  while (found_one_bigger);

  row->ascrise = 0.0f;
  row->xheight = (float) best_x_height;

  if (row->xheight == 0)
  {
    row->xheight = -1.0f;
  }
}
/////////////////////////////////////////////////////////////////oldbasel////////////////////////////////////////

/////////////////////////////////////////////////////////////////sortflts////////////////////////////////////////
ELISTIZE (SORTED_FLOAT)
/**
 * @name SORTED_FLOATS::add
 *
 * Add a new entry to the sorted lsit of floats.
 */
void SORTED_FLOATS::add(  //add new entry
                        float value,
                        inT32 key) {
  SORTED_FLOAT *new_float = new SORTED_FLOAT (value, key);

  if (list.empty ())
    it.add_after_stay_put (new_float);
  else {
    it.move_to_first ();
    while (!it.at_last () && it.data ()->entry < value)
      it.forward ();
    if (it.data ()->entry < value)
      it.add_after_stay_put (new_float);
    else
      it.add_before_stay_put (new_float);
  }
}


/**
 * @name SORTED_FLOATS::remove
 *
 * Remove an entry from the sorted lsit of floats.
 */

void SORTED_FLOATS::remove(  //remove the entry
                           inT32 key) {
  if (!list.empty ()) {
    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
      if (it.data ()->address == key) {
        delete it.extract ();
        return;
      }
    }
  }
}


/**
 * @name SORTED_FLOATS::operator[]
 *
 * Return the floating point value of the given index into the list.
 */

float
SORTED_FLOATS::operator[] (      //get an entry
inT32 index                      //to list
) {
  it.move_to_first ();
  return it.data_relative (index)->entry;
}
/////////////////////////////////////////////////////////////////sortflts////////////////////////////////////////

/////////////////////////////////////////////////////////////////makerow////////////////////////////////////////
BOOL_VAR(textord_heavy_nr, FALSE, "Vigorously remove noise");
BOOL_VAR(textord_show_initial_rows, FALSE, "Display row accumulation");
BOOL_VAR(textord_show_parallel_rows, FALSE, "Display page correlated rows");
BOOL_VAR(textord_show_expanded_rows, FALSE, "Display rows after expanding");
BOOL_VAR(textord_show_final_rows, FALSE, "Display rows after final fitting");
BOOL_VAR(textord_show_final_blobs, FALSE, "Display blob bounds after pre-ass");
BOOL_VAR(textord_test_landscape, FALSE, "Tests refer to land/port");
BOOL_VAR(textord_parallel_baselines, TRUE, "Force parallel baselines");
BOOL_VAR(textord_straight_baselines, FALSE, "Force straight baselines");
BOOL_VAR(textord_quadratic_baselines, FALSE, "Use quadratic splines");
BOOL_VAR(textord_old_baselines, TRUE, "Use old baseline algorithm");
BOOL_VAR(textord_old_xheight, FALSE, "Use old xheight algorithm");
BOOL_VAR(textord_fix_xheight_bug, TRUE, "Use spline baseline");
BOOL_VAR(textord_fix_makerow_bug, TRUE, "Prevent multiple baselines");
BOOL_VAR(textord_cblob_blockocc, TRUE, "Use new projection for underlines");
BOOL_VAR(textord_debug_xheights, FALSE, "Test xheight algorithms");
BOOL_VAR(textord_biased_skewcalc, TRUE, "Bias skew estimates with line length");
BOOL_VAR(textord_interpolating_skew, TRUE, "Interpolate across gaps");
INT_VAR(textord_skewsmooth_offset, 2, "For smooth factor");
INT_VAR(textord_skewsmooth_offset2, 1, "For smooth factor");
INT_VAR(textord_test_x, -1, "coord of test pt");
INT_VAR(textord_test_y, -1, "coord of test pt");
INT_VAR(textord_min_blobs_in_row, 4, "Min blobs before gradient counted");
INT_VAR(textord_spline_minblobs, 8, "Min blobs in each spline segment");
INT_VAR(textord_spline_medianwin, 6, "Size of window for spline segmentation");
INT_VAR(textord_max_blob_overlaps, 4, "Max number of blobs a big blob can overlap");
INT_VAR(textord_min_xheight, 10, "Min credible pixel xheight");
double_VAR(textord_spline_shift_fraction, 0.02, "Fraction of line spacing for quad");
double_VAR(textord_spline_outlier_fraction, 0.1, "Fraction of line spacing for outlier");
double_VAR(textord_skew_ile, 0.5, "Ile of gradients for page skew");
double_VAR(textord_skew_lag, 0.01, "Lag for skew on row accumulation");
double_VAR(textord_linespace_iqrlimit, 0.2, "Max iqr/median for linespace");
double_VAR(textord_width_limit, 8, "Max width of blobs to make rows");
double_VAR(textord_chop_width, 1.5, "Max width before chopping");
double_VAR(textord_expansion_factor, 1.0, "Factor to expand rows by in expand_rows");
double_VAR(textord_overlap_x, 0.5, "Fraction of linespace for good overlap");
double_VAR(textord_merge_desc, 0.25, "Fraction of linespace for desc drop");
double_VAR(textord_merge_x, 0.5, "Fraction of linespace for x height");
double_VAR(textord_merge_asc, 0.25, "Fraction of linespace for asc height");
double_VAR(textord_minxh, 0.25, "fraction of linesize for min xheight");
double_VAR(textord_min_linesize, 1.25, "* blob height for initial linesize");
double_VAR(textord_excess_blobsize, 1.3, "New row made if blob makes row this big");
double_VAR(textord_occupancy_threshold, 0.4, "Fraction of neighbourhood");
double_VAR(textord_underline_width, 2.0, "Multiple of line_size for underline");
double_VAR(textord_min_blob_height_fraction, 0.75, "Min blob height/top to include blob top into xheight stats");
double_VAR(textord_xheight_mode_fraction, 0.4, "Min pile height to make xheight");
double_VAR(textord_ascheight_mode_fraction, 0.08, "Min pile height to make ascheight");
double_VAR(textord_descheight_mode_fraction, 0.08, "Min pile height to make descheight");
double_VAR(textord_ascx_ratio_min, 1.3, "Min cap/xheight");
double_VAR(textord_ascx_ratio_max, 1.8, "Max cap/xheight");
double_VAR(textord_descx_ratio_min, 0.25, "Min desc/xheight");
double_VAR(textord_descx_ratio_max, 0.6, "Max desc/xheight");
double_VAR(textord_xheight_error_margin, 0.1, "Accepted variation");

#define MAX_HEIGHT_MODES  12

/**
 * @name make_single_row
 *
 * Arrange the blobs into a single row.
 */
float make_single_row(ICOORD page_tr, TO_BLOCK* block, TO_BLOCK_LIST* blocks, Tesseract* tess)
{
    BLOBNBOX_IT blob_it = &block->blobs;
    TO_ROW_IT row_it = block->get_rows();

    // Include all the small blobs and large blobs.
    blob_it.add_list_after(&block->small_blobs);
    blob_it.add_list_after(&block->noise_blobs);
    blob_it.add_list_after(&block->large_blobs);
    blob_it.sort(blob_x_order);
    blob_it.move_to_first();
    TO_ROW* row = NULL;

    // Add all the blobs to a single TO_ROW.
    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward())
    {
        BLOBNBOX* blob = blob_it.extract();
        int top = blob->bounding_box().top();
        int bottom = blob->bounding_box().bottom();

        if (row == NULL)
        {
            row = new TO_ROW(blob, top, bottom, block->line_size);
            row_it.add_before_then_move(row);
        }
        else
        {
            row->add_blob(blob, top, bottom, block->line_size);
        }
    }

    // Fit an LMS line to the row.
    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
    {
        fit_lms_line(row_it.data());
    }

    float gradient;
    float fit_error;

    // Compute the skew based on the fitted line.
    compute_page_skew(blocks, gradient, fit_error);
    FCOORD rotation(1.0f, 0.0f);

    // Associate i dots and other diacriticals with the appropriate blobs.
    pre_associate_blobs(page_tr, block, rotation, false);
    int block_edge = block->block->bounding_box().left();
    fit_parallel_rows(block, gradient, rotation, block_edge, false);

    // Make the curved baselines and setup some key block members.
    make_spline_rows(block, gradient, rotation, block_edge, false, tess);

    return gradient;
}

/**
 * @name make_rows
 *
 * Arrange the blobs into rows.
 */
float make_rows(//make rows
                ICOORD page_tr,              //top right
                BLOCK_LIST *blocks,          //block list
                TO_BLOCK_LIST *land_blocks,  //rotated for landscape
                TO_BLOCK_LIST *port_blocks,  //output list
                Tesseract* tess
                )
{
    Q_UNUSED(blocks);
    float port_m;                  //global skew
    float port_err;                //global noise

    TO_BLOCK_IT block_it;          //iterator
    block_it.set_to_list(port_blocks);

    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward())
    {
        make_initial_textrows(page_tr, block_it.data(), FCOORD(1.0f, 0.0f), !(BOOL8)textord_test_landscape);
    }

    //compute globally
    compute_page_skew(port_blocks, port_m, port_err);

    block_it.set_to_list(port_blocks);
    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward())
    {
        cleanup_rows(page_tr, block_it.data(), port_m, FCOORD(1.0f, 0.0f), block_it.data()->block->bounding_box().left(), !(BOOL8)textord_test_landscape, tess);
    }
    block_it.set_to_list(land_blocks);

    return port_m;                 //global skew
}


/**
 * @name make_initial_textrows
 *
 * Arrange the good blobs into rows of text.
 */
//find lines
void make_initial_textrows(ICOORD page_tr,
                           TO_BLOCK *block,  //block to do
                           FCOORD rotation,  //for drawing
                           BOOL8 testing_on  //correct orientation
                           )
{
    TO_ROW_IT row_it = block->get_rows();

    #ifndef GRAPHICS_DISABLED
    ScrollView::Color colour;                 //of row

    if (textord_show_initial_rows && testing_on)
    {
        if (to_win == NULL)
        {
            create_to_win(page_tr);
        }
    }
    #endif
    //guess skew
    assign_blobs_to_rows(block, NULL, 0, TRUE, TRUE, textord_show_initial_rows && testing_on);
    row_it.move_to_first();
    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
    {
        fit_lms_line(row_it.data());
    }
    #ifndef GRAPHICS_DISABLED
    if (textord_show_initial_rows && testing_on)
    {
        colour = ScrollView::RED;
        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
        {
            plot_to_row(row_it.data(), colour, rotation);
            colour = (ScrollView::Color)(colour + 1);

            if (colour > ScrollView::MAGENTA) colour = ScrollView::RED;
        }
    }
    #endif
}


/**
 * @name fit_lms_line
 *
 * Fit an LMS line to a row.
 */
void fit_lms_line(//sort function
                  TO_ROW *row  //row to fit
                  )
{
    float m, c;                    //fitted line
    TBOX box;                       //blob box
    LMS lms(row->blob_list()->length());

    //blobs
    BLOBNBOX_IT blob_it = row->blob_list();

    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward())
    {
        box = blob_it.data()->bounding_box();
        lms.add(FCOORD((box.left() + box.right()) / 2.0, box.bottom()));
    }

    lms.fit(m, c);
    row->set_line(m, c, lms.error());
}


/**
 * @name compute_page_skew
 *
 * Compute the skew over a full page by averaging the gradients over
 * all the lines. Get the error of the same row.
 */
void compute_page_skew(//get average gradient
                       TO_BLOCK_LIST *blocks,  //list of blocks
                       float &page_m,          //average gradient
                       float &page_err         //average error
                       )
{
    inT32 row_count;               //total rows
    inT32 blob_count;              //total_blobs
    inT32 row_err;                 //integer error
    float *gradients;              //of rows
    float *errors;                 //of rows
    inT32 row_index;               //of total
    TO_ROW *row;                   //current row
    TO_BLOCK_IT block_it = blocks; //iterator
    TO_ROW_IT row_it;

    row_count = 0;
    blob_count = 0;
    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward())
    {
        row_count += block_it.data()->get_rows()->length();

        //count up rows
        row_it.set_to_list(block_it.data()->get_rows());
        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
        {
            blob_count += row_it.data()->blob_list()->length();
        }
    }

    if (row_count == 0)
    {
        page_m = 0.0f;
        page_err = 0.0f;
        return;
    }

    gradients = (float *)alloc_mem(blob_count * sizeof(float));

    //get mem
    errors = (float *)alloc_mem(blob_count * sizeof(float));

    if (gradients == NULL || errors == NULL)
    {
        MEMORY_OUT.error("compute_page_skew", ABORT, NULL);
    }

    row_index = 0;
    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward())
    {
        row_it.set_to_list(block_it.data()->get_rows());
        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
        {
            row = row_it.data();
            blob_count = row->blob_list ()->length();
            row_err = (inT32)ceil(row->line_error());

            if (row_err <= 0)
            {
                row_err = 1;
            }

            if (textord_biased_skewcalc)
            {
                blob_count /= row_err;

                for (blob_count /= row_err; blob_count > 0; blob_count--)
                {
                    gradients[row_index] = row->line_m();
                    errors[row_index] = row->line_error();
                    row_index++;
                }
            }
            else if (blob_count >= textord_min_blobs_in_row)
            {
                //get gradient
                gradients[row_index] = row->line_m();
                errors[row_index] = row->line_error();
                row_index++;
            }
        }
    }

    if (row_index == 0)
    {
        //desperate
        for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward())
        {
            row_it.set_to_list(block_it.data()->get_rows());
            for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
            {
                row = row_it.data();
                gradients[row_index] = row->line_m();
                errors[row_index] = row->line_error();
                row_index++;
            }
        }
    }

    row_count = row_index;
    row_index = choose_nth_item((inT32)(row_count * textord_skew_ile), gradients, row_count);
    page_m = gradients[row_index];

    row_index = choose_nth_item((inT32)(row_count * textord_skew_ile), errors, row_count);
    page_err = errors[row_index];
    free_mem(gradients);
    free_mem(errors);
}

const double kNoiseSize = 0.5;  // Fraction of xheight.
const int kMinSize = 8;  // Min pixels to be xheight.

/**
 * Return true if the dot looks like it is part of the i.
 * Doesn't work for any other diacritical.
 */
static bool dot_of_i(BLOBNBOX* dot, BLOBNBOX* i, TO_ROW* row)
{
    const TBOX& ibox = i->bounding_box();
    const TBOX& dotbox = dot->bounding_box();

    // Must overlap horizontally by enough and be high enough.
    int overlap = MIN(dotbox.right(), ibox.right()) - MAX(dotbox.left(), ibox.left());

    if (ibox.height() <= 2 * dotbox.height() || (overlap * 2 < ibox.width() && overlap < dotbox.width()))
    {
        return false;
    }

    // If the i is tall and thin then it is good.
    if (ibox.height() > ibox.width() * 2)
    {
        return true;  // The i or ! must be tall and thin.
    }

    // It might still be tall and thin, but it might be joined to something.
    // So search the outline for a piece of large height close to the edges
    // of the dot.
    const double kHeightFraction = 0.6;
    double target_height = MIN(dotbox.bottom(), ibox.top());
    target_height -= row->line_m()*dotbox.left() + row->line_c();
    target_height *= kHeightFraction;
    int left_min = dotbox.left() - dotbox.width();
    int middle = (dotbox.left() + dotbox.right())/2;
    int right_max = dotbox.right() + dotbox.width();
    int left_miny = 0;
    int left_maxy = 0;
    int right_miny = 0;
    int right_maxy = 0;
    bool found_left = false;
    bool found_right = false;
    bool in_left = false;
    bool in_right = false;
    C_BLOB* blob = i->cblob();
    C_OUTLINE_IT o_it = blob->out_list();

    for (o_it.mark_cycle_pt(); !o_it.cycled_list(); o_it.forward())
    {
        C_OUTLINE* outline = o_it.data();
        int length = outline->pathlength();
        ICOORD pos = outline->start_pos();

        for (int step = 0; step < length; pos += outline->step(step++))
        {
            int x = pos.x();
            int y = pos.y();

            if (x >= left_min && x < middle && !found_left)
            {
                // We are in the left part so find min and max y.
                if (in_left)
                {
                    if (y > left_maxy) left_maxy = y;
                    if (y < left_miny) left_miny = y;
                }
                else
                {
                    left_maxy = left_miny = y;
                    in_left = true;
                }
            }
            else if (in_left)
            {
                // We just left the left so look for size.
                if (left_maxy - left_miny > target_height)
                {
                    if (found_right)
                    {
                        return true;
                    }

                    found_left = true;
                }

                in_left = false;
            }

            if (x <= right_max && x > middle && !found_right)
            {
                // We are in the right part so find min and max y.
                if (in_right)
                {
                    if (y > right_maxy) right_maxy = y;
                    if (y < right_miny) right_miny = y;
                }
                else
                {
                    right_maxy = right_miny = y;
                    in_right = true;
                }
            }
            else if (in_right)
            {
                // We just left the right so look for size.
                if (right_maxy - right_miny > target_height)
                {
                    if (found_left)
                    {
                        return true;
                    }

                    found_right = true;
                }

                in_right = false;
            }
        }
    }

    return false;
}

static void vigorous_noise_removal(TO_BLOCK* block)
{
    TO_ROW_IT row_it = block->get_rows ();

    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
        TO_ROW* row = row_it.data();
        BLOBNBOX_IT b_it = row->blob_list();

        // Estimate the xheight on the row.
        int max_height = 0;
        for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward())
        {
            BLOBNBOX* blob = b_it.data();
            if (blob->bounding_box().height() > max_height)
            {
                max_height = blob->bounding_box().height();
            }
        }

        STATS hstats(0, max_height + 1);

        for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward())
        {
            BLOBNBOX* blob = b_it.data();
            int height = blob->bounding_box().height();

            if (height >= kMinSize)
            {
                hstats.add(blob->bounding_box().height(), 1);
            }
        }

        float xheight = hstats.median();

        // Delete small objects.
        BLOBNBOX* prev = NULL;
        for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward())
        {
            BLOBNBOX* blob = b_it.data();
            const TBOX& box = blob->bounding_box();
            if (box.height() < kNoiseSize * xheight)
            {
                // Small so delete unless it looks like an i dot.
                if (prev != NULL)
                {
                    if (dot_of_i(blob, prev, row))
                    {
                        continue;  // Looks OK.
                    }
                }

                if (!b_it.at_last())
                {
                    BLOBNBOX* next = b_it.data_relative(1);
                    if (dot_of_i(blob, next, row))
                    {
                        continue;  // Looks OK.
                    }
                }

                // It might be noise so get rid of it.
                if (blob->blob() != NULL)
                {
                    delete blob->blob();
                }

                if (blob->cblob() != NULL)
                {
                    delete blob->cblob();
                }

                delete b_it.extract();
            }
            else
            {
                prev = blob;
            }
        }
    }
}

/**
 * cleanup_rows
 *
 * Remove overlapping rows and fit all the blobs to what's left.
 */
void cleanup_rows(                   //find lines
                                     ICOORD page_tr,    //top right
                                     TO_BLOCK *block,   //block to do
                                     float gradient,    //gradient to fit
                                     FCOORD rotation,   //for drawing
                                     inT32 block_edge,  //edge of block
                                     BOOL8 testing_on,  //correct orientation
                                     Tesseract* tess
                                     )
{
    //iterators
    BLOBNBOX_IT blob_it = &block->blobs;
    TO_ROW_IT row_it = block->get_rows();

#ifndef GRAPHICS_DISABLED
    if (textord_show_parallel_rows && testing_on)
    {
        if (to_win == NULL)
            create_to_win(page_tr);
    }
#endif
    //get row coords
    fit_parallel_rows(block, gradient, rotation, block_edge, textord_show_parallel_rows &&testing_on);
    delete_non_dropout_rows(block, gradient, rotation, block_edge, textord_show_parallel_rows &&testing_on);
    expand_rows(page_tr, block, gradient, rotation, block_edge, testing_on);
    blob_it.set_to_list(&block->blobs);
    row_it.set_to_list(block->get_rows());

    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
    {
        blob_it.add_list_after(row_it.data()->blob_list());
    }

    //give blobs back
    assign_blobs_to_rows(block, &gradient, 1, FALSE, FALSE, FALSE);

    //now new rows must be genuine
    blob_it.set_to_list(&block->blobs);
    blob_it.add_list_after(&block->large_blobs);
    assign_blobs_to_rows(block, &gradient, 2, TRUE, TRUE, FALSE);

    //safe to use big ones now
    blob_it.set_to_list(&block->blobs);

    //throw all blobs in
    blob_it.add_list_after(&block->noise_blobs);
    blob_it.add_list_after(&block->small_blobs);
    assign_blobs_to_rows(block, &gradient, 3, FALSE, FALSE, FALSE);

    //no rows for noise
    row_it.set_to_list(block->get_rows());
    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
    {
        row_it.data()->blob_list()->sort(blob_x_order);
    }

    fit_parallel_rows(block, gradient, rotation, block_edge, FALSE);
    if (textord_heavy_nr)
    {
        vigorous_noise_removal(block);
    }

    separate_underlines(block, gradient, rotation, testing_on);
    pre_associate_blobs(page_tr, block, rotation, testing_on);

#ifndef GRAPHICS_DISABLED
    if (textord_show_final_rows && testing_on)
    {
        if (to_win == NULL)
        {
            create_to_win(page_tr);
        }
    }
#endif

    fit_parallel_rows(block, gradient, rotation, block_edge, FALSE);

    //textord_show_final_rows && testing_on);
    make_spline_rows(block, gradient, rotation, block_edge, textord_show_final_rows && testing_on, tess);

    // We only want to call compute_block_xheight() if
    // both textord_old_xheight and textord_old_baselines are false.
    // No need to call compute_block_xheight() if textord_old_baselines
    // is true, since all appropriate xheight computation functions
    // would be called from make_old_baselines().
    // Note: it can not be the case that textord_old_baselines is
    // false, and textord_old_xheight is true.

    if (!textord_old_xheight && !textord_old_baselines)
    {
        compute_block_xheight(block, gradient, tess);
    }

    if (textord_restore_underlines)  // fix underlines
    {
        restore_underlined_blobs(block);
    }

#ifndef GRAPHICS_DISABLED
    if (textord_show_final_rows && testing_on)
    {
        plot_blob_list (to_win, &block->blobs, ScrollView::MAGENTA, ScrollView::WHITE);

        //show discarded blobs
        plot_blob_list (to_win, &block->underlines, ScrollView::YELLOW, ScrollView::CORAL);
    }

    if (textord_show_final_rows && testing_on && block->blobs.length () > 0)
    {
        tprintf ("%d blobs discarded as noise\n", block->blobs.length ());
    }

    if (textord_show_final_rows && testing_on)
    {
        draw_meanlines(block, gradient, block_edge, ScrollView::WHITE, rotation);
    }
#endif
}


/**
 * delete_non_dropout_rows
 *
 * Compute the linespacing and offset.
 */
void delete_non_dropout_rows(//find lines
                             TO_BLOCK *block,   //block to do
                             float gradient,    //global skew
                             FCOORD rotation,   //deskew vector
                             inT32 block_edge,  //left edge
                             BOOL8 testing_on   //correct orientation
                             )
{
    TBOX block_box;                 //deskewed block
    inT32 *deltas;                 //change in occupation
    inT32 *occupation;             //of pixel coords
    inT32 max_y;                   //in block
    inT32 min_y;
    inT32 line_index;              //of scan line
    inT32 line_count;              //no of scan lines
    inT32 distance;                //to drop-out
    inT32 xleft;                   //of block
    inT32 ybottom;                 //of block
    TO_ROW *row;                   //current row
    TO_ROW_IT row_it = block->get_rows();
    BLOBNBOX_IT blob_it = &block->blobs;

    if (row_it.length () == 0) return;                      //empty block

    block_box = deskew_block_coords(block, gradient);
    xleft = block->block->bounding_box().left();
    ybottom = block->block->bounding_box().bottom();
    min_y = block_box.bottom() - 1;
    max_y = block_box.top() + 1;

    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
    {
        line_index = (inT32)floor(row_it.data()->intercept());
        if (line_index <= min_y)
        {
            min_y = line_index - 1;
        }

        if (line_index >= max_y)
        {
            max_y = line_index + 1;
        }
    }
    line_count = max_y - min_y + 1;

    if (line_count <= 0) return;                      //empty block
    deltas = (inT32 *) alloc_mem (line_count * sizeof (inT32));
    occupation = (inT32 *) alloc_mem (line_count * sizeof (inT32));

    if (deltas == NULL || occupation == NULL)
    {
        MEMORY_OUT.error ("compute_line_spacing", ABORT, NULL);
    }

    compute_line_occupation(block, gradient, min_y, max_y, occupation, deltas);
    compute_occupation_threshold((inT32)ceil(block->line_spacing * (textord_merge_desc + textord_merge_asc)),
                                 (inT32) ceil(block->line_spacing * (textord_merge_x + textord_merge_asc)), max_y - min_y + 1, occupation, deltas);
#ifndef GRAPHICS_DISABLED
    if (testing_on)
    {
        draw_occupation(xleft, ybottom, min_y, max_y, occupation, deltas);
    }
#endif
    compute_dropout_distances(occupation, deltas, line_count);

    for (row_it.mark_cycle_pt(); !row_it.cycled_list (); row_it.forward ())
    {
        row = row_it.data();
        line_index = (inT32)floor(row->intercept());
        distance = deltas[line_index - min_y];
        if (find_best_dropout_row(row, distance, block->line_spacing / 2, line_index, &row_it, testing_on))
        {
#ifndef GRAPHICS_DISABLED
            if (testing_on)
            {
                plot_parallel_row(row, gradient, block_edge, ScrollView::WHITE, rotation);
            }
#endif
            blob_it.add_list_after(row_it.data()->blob_list());
            delete row_it.extract();  //too far away
        }
    }

    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
    {
        blob_it.add_list_after(row_it.data ()->blob_list());
    }

    free_mem(deltas);
    free_mem(occupation);
}


/**
 * @name find_best_dropout_row
 *
 * Delete this row if it has a neighbour with better dropout characteristics.
 * TRUE is returned if the row should be deleted.
 */
BOOL8 find_best_dropout_row(                    //find neighbours
                                                TO_ROW *row,        //row to test
                                                inT32 distance,     //dropout dist
                                                float dist_limit,   //threshold distance
                                                inT32 line_index,   //index of row
                                                TO_ROW_IT *row_it,  //current position
                                                BOOL8 testing_on    //correct orientation
                                                )
{
    inT32 next_index;              //of neigbouring row
    inT32 row_offset;              //from current row
    inT32 abs_dist;                //absolute distance
    inT8 row_inc;                  //increment to row_index
    TO_ROW *next_row;              //nextious row

    if (testing_on)
    {
        tprintf ("Row at %g(%g), dropout dist=%d,", row->intercept (), row->parallel_c (), distance);
    }

    if (distance < 0)
    {
        row_inc = 1;
        abs_dist = -distance;
    }
    else
    {
        row_inc = -1;
        abs_dist = distance;
    }

    if (abs_dist > dist_limit)
    {
        if (testing_on)
        {
            tprintf (" too far - deleting\n");
        }

        return TRUE;
    }

    if ((distance < 0 && !row_it->at_last ()) || (distance >= 0 && !row_it->at_first ()))
    {class SORTED_FLOAT:public ELIST_LINK
        {
          friend class SORTED_FLOATS;

          public:
            SORTED_FLOAT() {
            }                            //empty constructor
            SORTED_FLOAT(              //create one
                         float value,  //value of entry
                         inT32 key) {  //reference
              entry = value;
              address = key;
            }
          private:
            float entry;                 //value of float
            inT32 address;               //key
        };

        ELISTIZEH (SORTED_FLOAT)
        class SORTED_FLOATS
        {
          public:
            /** empty constructor */
            SORTED_FLOATS() {
              it.set_to_list (&list);
            }
            /**
             * add sample
             * @param value sample float
             * @param key retrieval key
             */
            void add(float value,
                     inT32 key);
            /**
             * delete sample
             * @param key key to delete
             */
            void remove(inT32 key);
            /**
             * index to list
             * @param index item to get
             */
            float operator[] (inT32 index);

          private:
            SORTED_FLOAT_LIST list;      //list of floats
            SORTED_FLOAT_IT it;          //iterator built-in
        };
        row_offset = row_inc;
        do
        {
            next_row = row_it->data_relative (row_offset);
            next_index = (inT32) floor (next_row->intercept ());

            if ((distance < 0 && next_index < line_index && next_index > line_index + distance + distance) ||
                    (distance >= 0 && next_index > line_index && next_index < line_index + distance + distance))
            {
                if (testing_on)
                {
                    tprintf (" nearer neighbour (%d) at %g\n", line_index + distance - next_index, next_row->intercept ());
                }

                return TRUE;             //other is nearer
            }
            else if (next_index == line_index || next_index == line_index + distance + distance)
            {
                if (row->believability () <= next_row->believability ())
                {
                    if (testing_on)
                    {
                        tprintf (" equal but more believable at %g (%g/%g)\n", next_row->intercept (), row->believability (), next_row->believability ());
                    }
                    return TRUE;           //other is more believable
                }
            }
            row_offset += row_inc;
        }

        while ((next_index == line_index || next_index == line_index + distance + distance) && row_offset < row_it->length ());
        if (testing_on)
        {
            tprintf (" keeping\n");
        }
    }

    return FALSE;
}


/**
 * @name deskew_block_coords
 *
 * Compute the bounding box of all the blobs in the block
 * if they were deskewed without actually doing it.
 */
TBOX deskew_block_coords(                  //block box
                                           TO_BLOCK *block,  //block to do
                                           float gradient    //global skew
                                           )
{
    TBOX result;                    //block bounds
    TBOX blob_box;                  //of block
    FCOORD rotation;               //deskew vector
    float length;                  //of gradient vector
    TO_ROW_IT row_it = block->get_rows ();
    TO_ROW *row;                   //current row
    BLOBNBOX *blob;                //current blob
    BLOBNBOX_IT blob_it;           //iterator

    length = sqrt (gradient * gradient + 1);
    rotation = FCOORD (1 / length, -gradient / length);

    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
        row = row_it.data ();
        blob_it.set_to_list (row->blob_list());
        for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward ())
        {
            blob = blob_it.data ();
            blob_box = blob->bounding_box ();
            blob_box.rotate (rotation);//de-skew it
            result += blob_box;
        }
    }

    return result;
}


/**
 * @name compute_line_occupation
 *
 * Compute the pixel projection back on the y axis given the global
 * skew. Also compute the 1st derivative.
 */
void compute_line_occupation(                    //project blobs
                                                 TO_BLOCK *block,    //block to do
                                                 float gradient,     //global skew
                                                 inT32 min_y,        //min coord in block
                                                 inT32 max_y,        //in block
                                                 inT32 *occupation,  //output projection
                                                 inT32 *deltas       //derivative
                                                 )
{
    inT32 line_count;              //maxy-miny+1
    inT32 line_index;              //of scan line
    int index;                     //array index for daft compilers
    float top, bottom;             //coords of blob
    inT32 width;                   //of blob
    TO_ROW *row;                   //current row
    TO_ROW_IT row_it = block->get_rows ();
    BLOBNBOX *blob;                //current blob
    BLOBNBOX_IT blob_it;           //iterator
    float length;                  //of skew vector
    TBOX blob_box;                  //bounding box
    FCOORD rotation;               //inverse of skew

    line_count = max_y - min_y + 1;
    length = sqrt (gradient * gradient + 1);
    rotation = FCOORD (1 / length, -gradient / length);

    for (line_index = 0; line_index < line_count; line_index++)
    {
        deltas[line_index] = 0;
    }

    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
        row = row_it.data ();
        blob_it.set_to_list (row->blob_list ());

        for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ())
        {
            blob = blob_it.data ();
            blob_box = blob->bounding_box ();
            blob_box.rotate (rotation);//de-skew it
            top = blob_box.top ();
            bottom = blob_box.bottom ();
            width = (inT32) floor ((FLOAT32) (blob_box.right () - blob_box.left ()));

            if ((inT32) floor (bottom) < min_y || (inT32) floor (bottom) - min_y >= line_count)
            {
                fprintf (stderr, "Bad y coord of bottom, " INT32FORMAT "(" INT32FORMAT "," INT32FORMAT ")\n", (inT32) floor (bottom), min_y, max_y);
            }

            //count transitions
            index = (inT32) floor (bottom) - min_y;
            deltas[index] += width;

            if ((inT32) floor (top) < min_y || (inT32) floor (top) - min_y >= line_count)
            {
                fprintf(stderr, "Bad y coord of top, " INT32FORMAT "(" INT32FORMAT "," INT32FORMAT ")\n", (inT32) floor (top), min_y, max_y);
            }

            index = (inT32) floor (top) - min_y;
            deltas[index] -= width;
        }
    }
    occupation[0] = deltas[0];

    for (line_index = 1; line_index < line_count; line_index++)
    {
        occupation[line_index] = occupation[line_index - 1] + deltas[line_index];
    }
}


/**
 * compute_occupation_threshold
 *
 * Compute thresholds for textline or not for the occupation array.
 */
void compute_occupation_threshold(                    //project blobs
                                                      inT32 low_window,   //below result point
                                                      inT32 high_window,  //above result point
                                                      inT32 line_count,   //array sizes
                                                      inT32 *occupation,  //input projection
                                                      inT32 *thresholds   //output thresholds
                                                      )
{
    inT32 line_index;              //of thresholds line
    inT32 low_index;               //in occupation
    inT32 high_index;              //in occupation
    inT32 sum;                     //current average
    inT32 divisor;                 //to get thresholds
    inT32 min_index;               //of min occ
    inT32 min_occ;                 //min in locality
    inT32 test_index;              //for finding min

    divisor = (inT32) ceil ((low_window + high_window) / textord_occupancy_threshold);

    if (low_window + high_window < line_count)
    {
        for (sum = 0, high_index = 0; high_index < low_window; high_index++)
        {
            sum += occupation[high_index];
        }

        for (low_index = 0; low_index < high_window; low_index++, high_index++)
        {
            sum += occupation[high_index];
        }

        min_occ = occupation[0];
        min_index = 0;
        for (test_index = 1; test_index < high_index; test_index++)
        {
            if (occupation[test_index] <= min_occ)
            {
                min_occ = occupation[test_index];
                min_index = test_index;  //find min in region
            }
        }

        for (line_index = 0; line_index < low_window; line_index++)
        {
            thresholds[line_index] = (sum - min_occ) / divisor + min_occ;
        }

        //same out to end
        for (low_index = 0; high_index < line_count; low_index++, high_index++)
        {
            sum -= occupation[low_index];
            sum += occupation[high_index];
            if (occupation[high_index] <= min_occ)
            {
                //find min in region
                min_occ = occupation[high_index];
                min_index = high_index;
            }

            //lost min from region
            if (min_index <= low_index)
            {
                min_occ = occupation[low_index + 1];
                min_index = low_index + 1;

                for (test_index = low_index + 2; test_index <= high_index; test_index++)
                {
                    if (occupation[test_index] <= min_occ)
                    {
                        min_occ = occupation[test_index];

                        //find min in region
                        min_index = test_index;
                    }
                }
            }

            thresholds[line_index++] = (sum - min_occ) / divisor + min_occ;
        }
    }
    else
    {
        min_occ = occupation[0];
        min_index = 0;

        for (sum = 0, low_index = 0; low_index < line_count; low_index++)
        {
            if (occupation[low_index] < min_occ)
            {
                min_occ = occupation[low_index];
                min_index = low_index;
            }

            sum += occupation[low_index];
        }

        line_index = 0;
    }

    for (; line_index < line_count; line_index++)
    {
        thresholds[line_index] = (sum - min_occ) / divisor + min_occ;
        //same out to end
    }
}


/**
 * @name compute_dropout_distances
 *
 * Compute the distance from each coordinate to the nearest dropout.
 */
void compute_dropout_distances(                    //project blobs
                                                   inT32 *occupation,  //input projection
                                                   inT32 *thresholds,  //output thresholds
                                                   inT32 line_count    //array sizes
                                                   )
{
    inT32 line_index;              //of thresholds line
    inT32 distance;                //from prev dropout
    inT32 next_dist;               //to next dropout
    inT32 back_index;              //for back filling
    inT32 prev_threshold;          //before overwrite

    distance = -line_count;
    line_index = 0;
    do
    {
        do
        {
            distance--;
            prev_threshold = thresholds[line_index];
            //distance from prev
            thresholds[line_index] = distance;
            line_index++;
        }
        while (line_index < line_count && (occupation[line_index] < thresholds[line_index] || occupation[line_index - 1] >= prev_threshold));

        if (line_index < line_count)
        {
            back_index = line_index - 1;
            next_dist = 1;

            while (next_dist < -distance && back_index >= 0)
            {
                thresholds[back_index] = next_dist;
                back_index--;
                next_dist++;
                distance++;
            }
            distance = 1;
        }
    }
    while (line_index < line_count);
}


/**
 * @name expand_rows
 *
 * Expand each row to the least of its allowed size and touching its
 * neighbours. If the expansion would entirely swallow a neighbouring row
 * then do so.
 */
void expand_rows(                   //find lines
                                    ICOORD page_tr,    //top right
                                    TO_BLOCK *block,   //block to do
                                    float gradient,    //gradient to fit
                                    FCOORD rotation,   //for drawing
                                    inT32 block_edge,  //edge of block
                                    BOOL8 testing_on   //correct orientation
                                    )
{
    BOOL8 swallowed_row;           //eaten a neighbour
    float y_max, y_min;            //new row limits
    float y_bottom, y_top;         //allowed limits
    TO_ROW *test_row;              //next row
    TO_ROW *row;                   //current row
    //iterators
    BLOBNBOX_IT blob_it = &block->blobs;
    TO_ROW_IT row_it = block->get_rows();

#ifndef GRAPHICS_DISABLED
    if (textord_show_expanded_rows && testing_on)
    {
        if (to_win == NULL)
        {
            create_to_win(page_tr);
        }
    }
#endif

    adjust_row_limits(block);  //shift min,max.
    if (textord_new_initial_xheight)
    {
        if (block->get_rows()->length() == 0) return;

        compute_row_stats(block, textord_show_expanded_rows &&testing_on);
    }
    assign_blobs_to_rows(block, &gradient, 4, TRUE, FALSE, FALSE);

    //get real membership
    if (block->get_rows()->length () == 0) return;

    fit_parallel_rows(block, gradient, rotation, block_edge, textord_show_expanded_rows &&testing_on);

    if (!textord_new_initial_xheight)
    {
        compute_row_stats(block, textord_show_expanded_rows &&testing_on);
    }
    row_it.move_to_last();

    do
    {
        row = row_it.data();
        y_max = row->max_y();       //get current limits
        y_min = row->min_y();
        y_bottom = row->intercept() - block->line_size * textord_expansion_factor * textord_merge_desc;
        y_top = row->intercept() + block->line_size * textord_expansion_factor * (textord_merge_x + textord_merge_asc);

        if (y_min > y_bottom)
        {
            //expansion allowed
            if (textord_show_expanded_rows && testing_on) tprintf("Expanding bottom of row at %f from %f to %f\n", row->intercept(), y_min, y_bottom);


            //expandable
            swallowed_row = TRUE;
            while (swallowed_row && !row_it.at_last())
            {
                swallowed_row = FALSE;

                //get next one
                test_row = row_it.data_relative(1);

                //overlaps space
                if (test_row->max_y() > y_bottom)
                {
                    if (test_row->min_y() > y_bottom)
                    {
                        if (textord_show_expanded_rows && testing_on)
                        {
                            tprintf("Eating row below at %f\n", test_row->intercept());
                        }
                        row_it.forward ();
#ifndef GRAPHICS_DISABLED
                        if (textord_show_expanded_rows && testing_on)
                        {
                            plot_parallel_row(test_row, gradient, block_edge, ScrollView::WHITE, rotation);
                        }
#endif
                        blob_it.set_to_list (row->blob_list());
                        blob_it.add_list_after (test_row->blob_list());

                        //swallow complete row
                        delete row_it.extract();
                        row_it.backward();
                        swallowed_row = TRUE;
                    }
                    else if (test_row->max_y() < y_min)
                    {
                        //shorter limit
                        y_bottom = test_row->max_y();

                        if (textord_show_expanded_rows && testing_on)
                        {
                            tprintf("Truncating limit to %f due to touching row at %f\n", y_bottom, test_row->intercept());
                        }
                    }
                    else
                    {
                        y_bottom = y_min;    //can't expand it

                        if (textord_show_expanded_rows && testing_on)
                        {
                            tprintf("Not expanding limit beyond %f due to touching row at %f\n", y_bottom, test_row->intercept());
                        }
                    }
                }
            }
            y_min = y_bottom;          //expand it
        }

        if (y_max < y_top)
        {         //expansion allowed
            if (textord_show_expanded_rows && testing_on)
            {
                tprintf("Expanding top of row at %f from %f to %f\n", row->intercept(), y_max, y_top);
            }
            swallowed_row = TRUE;

            while (swallowed_row && !row_it.at_first())
            {
                swallowed_row = FALSE;

                //get one above
                test_row = row_it.data_relative (-1);
                if (test_row->min_y() < y_top)
                {
                    if (test_row->max_y() < y_top)
                    {
                        if (textord_show_expanded_rows && testing_on)
                        {
                            tprintf("Eating row above at %f\n", test_row->intercept());
                        }

                        row_it.backward();
                        blob_it.set_to_list (row->blob_list());
                        #ifndef GRAPHICS_DISABLED
                        if (textord_show_expanded_rows && testing_on)
                        {
                            plot_parallel_row(test_row, gradient, block_edge, ScrollView::WHITE, rotation);
                        }
                        #endif
                        blob_it.add_list_after (test_row->blob_list());

                        //swallow complete row
                        delete row_it.extract();
                        row_it.forward();
                        swallowed_row = TRUE;
                    }
                    else if (test_row->min_y() < y_max)
                    {
                        //shorter limit
                        y_top = test_row->min_y();
                        if (textord_show_expanded_rows && testing_on)
                        {
                            tprintf("Truncating limit to %f due to touching row at %f\n", y_top, test_row->intercept());
                        }
                    }
                    else
                    {
                        y_top = y_max;       //can't expand it
                        if (textord_show_expanded_rows && testing_on)
                        {
                            tprintf("Not expanding limit beyond %f due to touching row at %f\n", y_top, test_row->intercept());
                        }
                    }
                }
            }
            y_max = y_top;
        }
        //new limits
        row->set_limits(y_min, y_max);
        row_it.backward();
    }
    while (!row_it.at_last());
}


/**
 * adjust_row_limits
 *
 * Change the limits of rows to suit the default fractions.
 */
void adjust_row_limits(                 //tidy limits
                                        TO_BLOCK *block  //block to do
                                        )
{
    TO_ROW *row;                   //current row
    float size;                    //size of row
    float ymax;                    //top of row
    float ymin;                    //bottom of row
    TO_ROW_IT row_it = block->get_rows ();

    if (textord_show_expanded_rows)
    {
        tprintf("Adjusting row limits for block(%d,%d)\n", block->block->bounding_box().left(), block->block->bounding_box().top());
    }

    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
        row = row_it.data ();
        size = row->max_y () - row->min_y ();

        if (textord_show_expanded_rows)
        {
            tprintf("Row at %f has min %f, max %f, size %f\n", row->intercept(), row->min_y(), row->max_y(), size);
        }

        size /= textord_merge_x + textord_merge_asc + textord_merge_desc;
        ymax = size * (textord_merge_x + textord_merge_asc);
        ymin = -size * textord_merge_desc;
        row->set_limits (row->intercept () + ymin, row->intercept () + ymax);
        row->merged = FALSE;
    }
}


/**
 * @name compute_row_stats
 *
 * Compute the linespacing and offset.
 */
void compute_row_stats(                  //find lines
                                         TO_BLOCK *block,  //block to do
                                         BOOL8 testing_on  //correct orientation
                                         )
{
    inT32 row_index;               //of median
    TO_ROW *row;                   //current row
    TO_ROW *prev_row;              //previous row
    float iqr;                     //inter quartile range
    TO_ROW_IT row_it = block->get_rows ();

    //number of rows
    inT16 rowcount = row_it.length ();
    TO_ROW **rows;                 //for choose nth

    rows = (TO_ROW **) alloc_mem (rowcount * sizeof (TO_ROW *));

    if (rows == NULL)
    {
        MEMORY_OUT.error ("compute_row_stats", ABORT, NULL);
    }

    rowcount = 0;
    prev_row = NULL;
    row_it.move_to_last ();        //start at bottom
    do
    {
        row = row_it.data ();
        if (prev_row != NULL)
        {
            rows[rowcount++] = prev_row;
            prev_row->spacing = row->intercept () - prev_row->intercept ();

            if (testing_on)
            {
                tprintf ("Row at %g yields spacing of %g\n", row->intercept (), prev_row->spacing);
            }
        }

        prev_row = row;
        row_it.backward ();
    }

    while (!row_it.at_last ());
    block->key_row = prev_row;
    block->baseline_offset = fmod (prev_row->parallel_c (), block->line_spacing);

    if (testing_on)
    {
        tprintf ("Blob based spacing=(%g,%g), offset=%g", block->line_size, block->line_spacing, block->baseline_offset);
    }

    if (rowcount > 0)
    {
        row_index = choose_nth_item (rowcount * 3 / 4, rows, rowcount, sizeof (TO_ROW *), row_spacing_order);
        iqr = rows[row_index]->spacing;
        row_index = choose_nth_item (rowcount / 4, rows, rowcount, sizeof (TO_ROW *), row_spacing_order);
        iqr -= rows[row_index]->spacing;
        row_index = choose_nth_item (rowcount / 2, rows, rowcount, sizeof (TO_ROW *), row_spacing_order);
        block->key_row = rows[row_index];

        if (testing_on)
        {
            tprintf (" row based=%g(%g)", rows[row_index]->spacing, iqr);
        }

        if (rowcount > 2 && iqr < rows[row_index]->spacing * textord_linespace_iqrlimit)
        {
            if (!textord_new_initial_xheight)
            {
                if (rows[row_index]->spacing < block->line_spacing && rows[row_index]->spacing > block->line_size)
                {
                    //within range
                    block->line_size = rows[row_index]->spacing;
                }
                //spacing=size
                else if (rows[row_index]->spacing > block->line_spacing)
                {
                    block->line_size = block->line_spacing;
                    //too big so use max
                }
            }
            else
            {
                if (rows[row_index]->spacing < block->line_spacing)
                {
                    block->line_size = rows[row_index]->spacing;
                }
                else
                {
                    block->line_size = block->line_spacing;
                    //too big so use max
                }
            }

            if (block->line_size < textord_min_xheight)
            {
                block->line_size = (float) textord_min_xheight;
            }

            block->line_spacing = rows[row_index]->spacing;
            block->max_blob_size = block->line_spacing * textord_excess_blobsize;
        }
        block->baseline_offset = fmod (rows[row_index]->intercept (), block->line_spacing);
    }

    if (testing_on)
    {
        tprintf ("\nEstimate line size=%g, spacing=%g, offset=%g\n", block->line_size, block->line_spacing, block->baseline_offset);
    }
    free_mem(rows);
}


/**
 * @name compute_block_xheight
 *
 * Compute the xheight of the individual rows, then correlate them
 * and interpret ascenderless lines, correcting xheights.
 *
 * First we compute our best guess of the x-height of each row independently
 * with compute_row_xheight(), which looks for a pair of commonly occurring
 * heights that could be x-height and ascender height. This function also
 * attempts to find descenders of lowercase letters (i.e. not the small
 * descenders that could appear in upper case letters as Q,J).
 *
 * After this computation each row falls into one of the following categories:
 * ROW_ASCENDERS_FOUND: we found xheight and ascender modes, so this must be
 *                      a regular row; we'll use its xheight to compute
 *                      xheight and ascrise estimates for the block
 * ROW_DESCENDERS_FOUND: no ascenders, so we do not have a high confidence in
 *                       the xheight of this row (don't use it for estimating
 *                       block xheight), but this row can't contain all caps
 * ROW_UNKNOWN: a row with no ascenders/descenders, could be all lowercase
 *              (or mostly lowercase for fonts with very few ascenders),
 *              all upper case or small caps
 * ROW_INVALID: no meaningful xheight could be found for this row
 *
 * We then run correct_row_xheight() and use the computed xheight and ascrise
 * averages to correct xheight values of the rows in ROW_DESCENDERS_FOUND,
 * ROW_UNKNOWN and ROW_INVALID categories.
 *
 */
void compute_block_xheight(TO_BLOCK *block, float gradient, Tesseract *tess)
{
    TO_ROW *row;                          // current row
    float asc_frac_xheight = textord_merge_asc / textord_merge_x;
    float desc_frac_xheight = textord_merge_desc / textord_merge_x;
    inT32 min_height, max_height;         // limits on xheight
    TO_ROW_IT row_it = block->get_rows();
    if (row_it.empty()) return;  // no rows

    // Compute the best guess of xheight of each row individually.
    // Use xheight and ascrise values of the rows where ascenders were found.
    get_min_max_xheight(block->line_size, &min_height, &max_height);
    STATS row_asc_xheights(min_height, max_height + 1);
    STATS row_asc_ascrise(static_cast<int>(min_height * asc_frac_xheight), static_cast<int>(max_height * asc_frac_xheight) + 1);
    int min_desc_height = static_cast<int>(min_height * desc_frac_xheight);
    int max_desc_height = static_cast<int>(max_height * desc_frac_xheight);

    STATS row_asc_descdrop(min_desc_height, max_desc_height + 1);
    STATS row_desc_xheights(min_height, max_height + 1);
    STATS row_desc_descdrop(min_desc_height, max_desc_height + 1);
    STATS row_cap_xheights(min_height, max_height + 1);
    STATS row_cap_floating_xheights(min_height, max_height + 1);

    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
    {
        row = row_it.data();

        // Compute the xheight of this row if it has not been computed before.
        if (row->xheight <= 0.0)
        {
            compute_row_xheight(row, gradient, block->line_size, tess);
        }

        ROW_CATEGORY row_category = get_row_category(row);
        if (row_category == ROW_ASCENDERS_FOUND)
        {
            row_asc_xheights.add(static_cast<inT32>(row->xheight), row->xheight_evidence);
            row_asc_ascrise.add(static_cast<inT32>(row->ascrise), row->xheight_evidence);
            row_asc_descdrop.add(static_cast<inT32>(-row->descdrop), row->xheight_evidence);
        }
        else if (row_category == ROW_DESCENDERS_FOUND)
        {
            row_desc_xheights.add(static_cast<inT32>(row->xheight), row->xheight_evidence);
            row_desc_descdrop.add(static_cast<inT32>(-row->descdrop), row->xheight_evidence);
        }
        else if (row_category == ROW_UNKNOWN)
        {
            fill_heights(row, gradient, min_height, max_height, &row_cap_xheights, &row_cap_floating_xheights);
        }
    }

    float xheight = 0.0;
    float ascrise = 0.0;
    float descdrop = 0.0;

    // Compute our best guess of xheight of this block.
    if (row_asc_xheights.get_total() > 0)
    {
        // Determine xheight from rows where ascenders were found.
        xheight = row_asc_xheights.median();
        ascrise = row_asc_ascrise.median();
        descdrop = -row_asc_descdrop.median();
    }
    else if (row_desc_xheights.get_total() > 0)
    {
        // Determine xheight from rows where descenders were found.
        xheight = row_desc_xheights.median();class SORTED_FLOAT:public ELIST_LINK
        {
          friend class SORTED_FLOATS;

          public:
            SORTED_FLOAT() {
            }                            //empty constructor
            SORTED_FLOAT(              //create one
                         float value,  //value of entry
                         inT32 key) {  //reference
              entry = value;
              address = key;
            }
          private:
            float entry;                 //value of float
            inT32 address;               //key
        };

        ELISTIZEH (SORTED_FLOAT)
        class SORTED_FLOATS
        {
          public:
            /** empty constructor */
            SORTED_FLOATS() {
              it.set_to_list (&list);
            }
            /**
             * add sample
             * @param value sample float
             * @param key retrieval key
             */
            void add(float value,
                     inT32 key);
            /**
             * delete sample
             * @param key key to delete
             */
            void remove(inT32 key);
            /**
             * index to list
             * @param index item to get
             */
            float operator[] (inT32 index);

          private:
            SORTED_FLOAT_LIST list;      //list of floats
            SORTED_FLOAT_IT it;          //iterator built-in
        };
        descdrop = -row_desc_descdrop.median();
    }
    else if (row_cap_xheights.get_total() > 0)
    {
        // All the rows in the block were (a/de)scenderless.
        // Try to search for two modes in row_cap_heights that could
        // be the xheight and the capheight (e.g. some of the rows
        // were lowercase, but did not have enough (a/de)scenders.
        // If such two modes can not be found, this block is most
        // likely all caps (or all small caps, in which case the code
        // still works as intended).
        compute_xheight_from_modes(&row_cap_xheights, &row_cap_floating_xheights, min_height, max_height, &(xheight), &(ascrise));
        if (ascrise == 0)
        {  // assume only caps in the whole block
            xheight = row_cap_xheights.median() * textord_merge_x / (textord_merge_x + textord_merge_asc);
        }
    }
    else
    {  // default block sizes
        xheight = block->line_size * textord_merge_x;
    }

    // Correct xheight, ascrise and descdrop if necessary.
    bool corrected_xheight = false;
    if (xheight < textord_min_xheight)
    {
        xheight = static_cast<float>(textord_min_xheight);
        corrected_xheight = true;
    }

    if (corrected_xheight || ascrise <= 0.0)
    {
        ascrise = xheight * asc_frac_xheight;
    }

    if (corrected_xheight || descdrop >= 0.0)
    {
        descdrop = -(xheight * desc_frac_xheight);
    }
    block->xheight = xheight;

    if (textord_debug_xheights)
    {
        tprintf("Block average xheight=%.4f, ascrise=%.4f, descdrop=%.4f\n", xheight, ascrise, descdrop);
    }

    // Correct xheight, ascrise, descdrop of rows based on block averages.
    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
    {
        correct_row_xheight(row_it.data(), xheight, ascrise, descdrop);
    }
}

/**
 * @name compute_row_xheight
 *
 * Estimate the xheight of this row.
 * Compute the ascender rise and descender drop at the same time.
 * Set xheigh_evidence to the number of blobs with the chosen xheight
 * that appear in this row.
 */

// row to do                          // global skew
void compute_row_xheight(TO_ROW *row, float gradient, int block_line_size, Tesseract *tess)
{
    // Find blobs representing repeated characters in rows and mark them.
    // This information is used for computing row xheight and at a later
    // stage when words are formed by make_words.
    if (!row->rep_chars_marked())
    {
        mark_repeated_chars(row, block_line_size * textord_merge_x, tess);
    }

    int min_height, max_height;
    get_min_max_xheight(block_line_size, &min_height, &max_height);
    STATS heights(min_height, max_height + 1);
    STATS floating_heights(min_height, max_height + 1);
    fill_heights(row, gradient, min_height, max_height, &heights, &floating_heights);
    row->ascrise = 0.0f;
    row->xheight = 0.0f;
    row->xheight_evidence = compute_xheight_from_modes(&heights, &floating_heights, min_height, max_height, &(row->xheight), &(row->ascrise));
    row->descdrop = 0.0f;

    if (row->xheight > 0.0)
    {
        row->descdrop = static_cast<float>(compute_row_descdrop(row, gradient, row->xheight_evidence, &heights));
    }
    else
    {
        // Since we could not find a meaningful xheight, the results
        // of mark_repeated_chars() should be recomputed at a later stage.
        row->clear_rep_chars_marked();
    }
}

/**
 * @name fill_heights
 *
 * Fill the given heights with heights of the blobs that are legal
 * candidates for estimating xheight.
 */
void fill_heights(TO_ROW *row, float gradient, int min_height, int max_height, STATS *heights, STATS *floating_heights)
{
    float xcentre;                 // centre of blob
    float top;                     // top y coord of blob
    float height;                  // height of blob
    BLOBNBOX *blob;                // current blob
    int repeated_set;
    BLOBNBOX_IT blob_it = row->blob_list();
    if (blob_it.empty()) return;  // no blobs in this row
    bool has_rep_chars = row->rep_chars_marked() && row->num_repeated_sets() > 0;

    do
    {
        blob = blob_it.data();
        if (!blob->joined_to_prev())
        {
            xcentre = (blob->bounding_box().left() + blob->bounding_box().right()) / 2.0f;
            top = blob->bounding_box().top();
            height = blob->bounding_box().height();

            if (textord_fix_xheight_bug)
            {
                top -= row->baseline.y(xcentre);
            }
            else
            {
                top -= gradient * xcentre + row->parallel_c();
            }

            if (top >= min_height && top <= max_height)
            {
                heights->add(static_cast<inT32>(floor(top + 0.5)), 1);
                if (height / top < textord_min_blob_height_fraction)
                {
                    floating_heights->add(static_cast<inT32>(floor(top + 0.5)), 1);
                }
            }
        }

        // Skip repeated chars, since they are likely to skew the height stats.
        if (has_rep_chars && blob->repeated_set() != 0)
        {
            repeated_set = blob->repeated_set();
            blob_it.forward();

            while (!blob_it.at_first() && blob_it.data()->repeated_set() == repeated_set)
            {
                blob_it.forward();
                if (textord_debug_xheights)
                {
                    tprintf("Skipping repeated char when computing xheight\n");
                }
            }
        }
        else
        {
            blob_it.forward();
        }
    } while (!blob_it.at_first());
}

/**
 * @name compute_xheight_from_modes
 *
 * Given a STATS object heights, looks for two most frequently occurring
 * heights that look like xheight and xheight + ascrise. If found, sets
 * the values of *xheight and *ascrise accordingly, otherwise sets xheight
 * to any most frequently occurring height and sets *ascrise to 0.
 * Returns the number of times xheight occurred in heights.
 * For each mode that is considered for being an xheight the count of
 * floating blobs (stored in floating_heights) is subtracted from the
 * total count of the blobs of this height. This is done because blobs
 * that sit far above the baseline could represent valid ascenders, but
 * it is highly unlikely that such a character's height will be an xheight
 * (e.g.  -, ', =, ^, `, ", ', etc)
 */
int compute_xheight_from_modes( STATS *heights, STATS *floating_heights, int min_height, int max_height, float *xheight, float *ascrise)
{
    int blob_index = heights->mode();  // find mode
    int blob_count = heights->pile_count(blob_index);  // get count of mode

    if (textord_debug_xheights)
    {
        tprintf ("min_height=%d, max_height=%d, mode=%d, count=%d, total=%d\n", min_height, max_height, blob_index, blob_count, heights->get_total());
        heights->print(NULL, true);
        floating_heights->print(NULL, true);
    }

    if (blob_count == 0) return 0;
    int modes[MAX_HEIGHT_MODES]; // biggest piles
    bool in_best_pile = FALSE;
    int prev_size = -MAX_INT32;
    int best_count = 0;
    int mode_count = compute_height_modes(heights, min_height, max_height, modes, MAX_HEIGHT_MODES);
    int x;
    if (textord_debug_xheights)
    {
        tprintf("found %d modes: ", mode_count);
        for (x = 0; x < mode_count; x++) tprintf("%d ", modes[x]);
        tprintf("\n");
    }

    for (x = 0; x < mode_count - 1; x++)
    {
        if (modes[x] != prev_size + 1)
        {
            in_best_pile = FALSE;    // had empty height
        }

        int modes_x_count = heights->pile_count(modes[x]) - floating_heights->pile_count(modes[x]);

        if ((modes_x_count >= blob_count * textord_xheight_mode_fraction) && (in_best_pile || modes_x_count > best_count))
        {
            for (int asc = x + 1; asc < mode_count; asc++)
            {
                float ratio = static_cast<float>(modes[asc]) / static_cast<float>(modes[x]);

                if (textord_ascx_ratio_min < ratio && ratio < textord_ascx_ratio_max && (heights->pile_count(modes[asc]) >= blob_count * textord_ascheight_mode_fraction))
                {
                    if (modes_x_count > best_count)
                    {
                        in_best_pile = true;
                        best_count = modes_x_count;
                    }

                    if (textord_debug_xheights)
                    {
                        tprintf("X=%d, asc=%d, count=%d, ratio=%g\n", modes[x], modes[asc]-modes[x], modes_x_count, ratio);
                    }

                    prev_size = modes[x];
                    *xheight = static_cast<float>(modes[x]);
                    *ascrise = static_cast<float>(modes[asc] - modes[x]);
                }
            }
        }
    }

    if (*xheight == 0)
    {
        // single mode
        // Remove counts of the "floating" blobs (the one whose height is too
        // small in relation to it's top end of the bounding box) from heights
        // before computing the single-mode xheight.
        // Restore the counts in heights after the mode is found, since
        // floating blobs might be useful for determining potential ascenders
        // in compute_row_descdrop().
        if (floating_heights->get_total() > 0)
        {
            for (x = min_height; x < max_height; ++x)
            {
                heights->add(x, -(floating_heights->pile_count(x)));
            }

            blob_index = heights->mode();  // find the modified mode
            for (x = min_height; x < max_height; ++x)
            {
                heights->add(x, floating_heights->pile_count(x));
            }
        }

        *xheight = static_cast<float>(blob_index);
        *ascrise = 0.0f;
        best_count = heights->pile_count(blob_index);

        if (textord_debug_xheights) tprintf("Single mode xheight set to %g\n", *xheight);
    }
    else if (textord_debug_xheights)
    {
        tprintf("Multi-mode xheight set to %g, asc=%g\n", *xheight, *ascrise);
    }

    return best_count;
}

/**
 * @name compute_row_descdrop
 *
 * Estimates the descdrop of this row. This function looks for
 * "significant" descenders of lowercase letters (those that could
 * not just be the small descenders of upper case letters like Q,J).
 * The function also takes into account how many potential ascenders
 * this row might contain. If the number of potential ascenders along
 * with descenders is close to the expected fraction of the total
 * number of blobs in the row, the function returns the descender
 * height, returns 0 otherwise.
 */
inT32 compute_row_descdrop(TO_ROW *row, float gradient,  int xheight_blob_count, STATS *asc_heights)
{
    // Count how many potential ascenders are in this row.
    int i_min = asc_heights->min_bucket();

    if ((i_min / row->xheight) < textord_ascx_ratio_min)
    {
        i_min = static_cast<int>(floor(row->xheight * textord_ascx_ratio_min + 0.5));
    }

    int i_max = asc_heights->max_bucket();
    if ((i_max / row->xheight) > textord_ascx_ratio_max)
    {
        i_max = static_cast<int>(floor(row->xheight * textord_ascx_ratio_max));
    }

    int num_potential_asc = 0;
    for (int i = i_min; i <= i_max; ++i)
    {
        num_potential_asc += asc_heights->pile_count(i);
    }
    inT32 min_height = static_cast<inT32>(floor(row->xheight * textord_descx_ratio_min + 0.5));
    inT32 max_height = static_cast<inT32>(floor(row->xheight * textord_descx_ratio_max));

    float xcentre;                 // centre of blob
    float height;                  // height of blob
    BLOBNBOX_IT blob_it = row->blob_list ();
    BLOBNBOX *blob;                // current blob
    STATS heights (min_height, max_height + 1);

    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward())
    {
        blob = blob_it.data();
        if (!blob->joined_to_prev())
        {
            xcentre = (blob->bounding_box().left() + blob->bounding_box().right()) / 2.0f;
            height = (gradient * xcentre + row->parallel_c() - blob->bounding_box().bottom());

            if (height >= min_height && height <= max_height)
            {
                heights.add(static_cast<int>(floor(height + 0.5)), 1);
            }
        }
    }
    int blob_index = heights.mode();  // find mode
    int blob_count = heights.pile_count(blob_index);  // get count of mode
    float total_fraction = (textord_descheight_mode_fraction + textord_ascheight_mode_fraction);
    if (static_cast<float>(blob_count + num_potential_asc) < xheight_blob_count * total_fraction)
    {
        blob_count = 0;
    }
    int descdrop = blob_count > 0 ? -blob_index : 0;

    if (textord_debug_xheights)
    {
        tprintf("Descdrop: %d (potential ascenders %d, descenders %d)\n", descdrop, num_potential_asc, blob_count);
        heights.print(NULL, true);
    }
    return descdrop;
}


/**
 * @name compute_height_modes
 *
 * Find the top maxmodes values in the input array and put their
 * indices in the output in the order in which they occurred.
 */
inT32 compute_height_modes(                   //find lines
                                              STATS *heights,    //stats to search
                                              inT32 min_height,  //bottom of range
                                              inT32 max_height,  //top of range
                                              inT32 *modes,      //output array
                                              inT32 maxmodes     //size of modes
                                              )
{
    inT32 pile_count;              //no in source pile
    inT32 src_count;               //no of source entries
    inT32 src_index;               //current entry
    inT32 least_count;             //height of smalllest
    inT32 least_index;             //index of least
    inT32 dest_count;              //index in modes

    src_count = max_height + 1 - min_height;
    dest_count = 0;
    least_count = MAX_INT32;
    least_index = -1;

    for (src_index = 0; src_index < src_count; src_index++)
    {
        pile_count = heights->pile_count (min_height + src_index);
        if (pile_count > 0)
        {
            if (dest_count < maxmodes)
            {
                if (pile_count < least_count)
                {
                    //find smallest in array
                    least_count = pile_count;
                    least_index = dest_count;
                }

                modes[dest_count++] = min_height + src_index;
            }
            else if (pile_count >= least_count)
            {
                while (least_index < maxmodes - 1)
                {
                    modes[least_index] = modes[least_index + 1];

                    //shuffle up
                    least_index++;
                }
                //new one on end
                modes[maxmodes - 1] = min_height + src_index;
                if (pile_count == least_count)
                {
                    //new smallest
                    least_index = maxmodes - 1;
                }
                else
                {
                    least_count = heights->pile_count (modes[0]);
                    least_index = 0;

                    for (dest_count = 1; dest_count < maxmodes; dest_count++)
                    {
                        pile_count = heights->pile_count (modes[dest_count]);
                        if (pile_count < least_count)
                        {
                            //find smallest
                            least_count = pile_count;
                            least_index = dest_count;
                        }
                    }
                }
            }
        }
    }

    return dest_count;
}


/**
 * @name correct_row_xheight
 *
 * Adjust the xheight etc of this row if not within reasonable limits
 * of the average for the block.
 */
void correct_row_xheight(TO_ROW *row, float xheight, float ascrise, float descdrop)
{
    ROW_CATEGORY row_category = get_row_category(row);
    if (textord_debug_xheights)
    {
        tprintf("correcting row xheight: row->xheight %.4f" ", row->acrise %.4f row->descdrop %.4f\n", row->xheight, row->ascrise, row->descdrop);
    }

    bool normal_xheight = within_error_margin(row->xheight, xheight, textord_xheight_error_margin);
    bool cap_xheight = within_error_margin(row->xheight, xheight + ascrise, textord_xheight_error_margin);

    // Use the average xheight/ascrise for the following cases:
    // -- the xheight of the row could not be determined at all
    // -- the row has descenders (e.g. "many groups", "ISBN 12345 p.3")
    //    and its xheight is close to either cap height or average xheight
    // -- the row does not have ascenders or descenders, but its xheight
    //    is close to the average block xheight (e.g. row with "www.mmm.com")
    if (row_category == ROW_ASCENDERS_FOUND)
    {
        if (row->descdrop >= 0.0)
        {
            row->descdrop = row->xheight * (descdrop / xheight);
        }
    }
    else  if (row_category == ROW_INVALID || (row_category == ROW_DESCENDERS_FOUND && (normal_xheight || cap_xheight)) || (row_category == ROW_UNKNOWN && normal_xheight))
    {
        if (textord_debug_xheights) tprintf("using average xheight\n");
        row->xheight = xheight;
        row->ascrise = ascrise;
        row->descdrop = descdrop;
    }

    // Assume this is a row with mostly lowercase letters and it's xheight
    // is computed correctly (unfortunately there is no way to distinguish
    // this from the case when descenders are found, but the most common
    // height is capheight).
    else if (row_category == ROW_DESCENDERS_FOUND)
    {
        if (textord_debug_xheights) tprintf("lowercase, corrected ascrise\n");
        row->ascrise = row->xheight * (ascrise / xheight);
    }
    // Otherwise assume this row is an all-caps or small-caps row
    // and adjust xheight and ascrise of the row.
    else if (row_category == ROW_UNKNOWN)
    {
        row->all_caps = true;
        if (cap_xheight)
        { // regular all caps
            if (textord_debug_xheights) tprintf("all caps\n");
            row->xheight = xheight;
            row->ascrise = ascrise;
            row->descdrop = descdrop;
        }
        else
        {  // small caps or caps with an odd xheight
            if (textord_debug_xheights)
            {
                if (row->xheight < xheight + ascrise && row->xheight > xheight)
                {
                    tprintf("small caps\n");
                }
                else
                {
                    tprintf("all caps with irregular xheight\n");
                }
            }
            row->ascrise = row->xheight * (ascrise / (xheight + ascrise));
            row->xheight -= row->ascrise;
            row->descdrop = row->xheight * (descdrop / xheight);
        }
    }
    if (textord_debug_xheights)
    {
        tprintf("corrected row->xheight = %.4f, row->acrise = %.4f, row->descdrop" " = %.4f\n", row->xheight, row->ascrise, row->descdrop);
    }
}

static int CountOverlaps(const TBOX& box, int min_height, BLOBNBOX_LIST* blobs)
{
    int overlaps = 0;
    BLOBNBOX_IT blob_it(blobs);
    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward())
    {
        BLOBNBOX* blob = blob_it.data();
        TBOX blob_box = blob->bounding_box();

        if (blob_box.height() >= min_height && box.major_overlap(blob_box))
        {
            ++overlaps;
        }
    }

    return overlaps;
}

/**
 * @name separate_underlines
 *
 * Test wide objects for being potential underlines. If they are then
 * put them in a separate list in the block.
 */
void separate_underlines(                  //make rough chars
                                           TO_BLOCK *block,  //block to do
                                           float gradient,   //skew angle
                                           FCOORD rotation,  //inverse landscape
                                           BOOL8 testing_on  //correct orientation
                                           )
{
    BLOBNBOX *blob;                //current blob
    PBLOB *poly_blob;              //rotated blob
    C_BLOB *rotated_blob;          //rotated blob
    TO_ROW *row;                   //current row
    float length;                  //of g_vec
    TBOX blob_box;
    FCOORD blob_rotation;          //inverse of rotation
    FCOORD g_vec;                  //skew rotation
    BLOBNBOX_IT blob_it;           //iterator
    //iterator

    BLOBNBOX_IT under_it = &block->underlines;
    BLOBNBOX_IT large_it = &block->large_blobs;
    TO_ROW_IT row_it = block->get_rows ();
    int min_blob_height = static_cast<int>(textord_min_blob_height_fraction * block->line_size + 0.5);

    //length of vector
    length = sqrt (1 + gradient * gradient);
    g_vec = FCOORD (1 / length, -gradient / length);
    blob_rotation = FCOORD (rotation.x (), -rotation.y ());
    blob_rotation.rotate (g_vec);  //unoding everything

    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
        row = row_it.data ();

        //get blobs
        blob_it.set_to_list (row->blob_list ());
        for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ())
        {
            blob = blob_it.data ();
            blob_box = blob->bounding_box ();

            if (blob_box.width () > block->line_size * textord_underline_width)
            {
                if (textord_cblob_blockocc && blob->cblob () != NULL)
                {
                    rotated_blob = crotate_cblob (blob->cblob(), blob_rotation);
                    if (test_underline(testing_on && textord_show_final_rows, rotated_blob,
                                       static_cast<inT16>(row->intercept()),
                                       static_cast<inT16>(block->line_size * (textord_merge_x + textord_merge_asc / 2.0f))))
                    {
                        under_it.add_after_then_move(blob_it.extract());
                        if (testing_on && textord_show_final_rows)
                        {
                            tprintf("Underlined blob at:");

                            rotated_blob->bounding_box().print();
                            tprintf("Was:");

                            blob_box.print();
                        }
                    }
                    else if (CountOverlaps(blob->bounding_box(), min_blob_height, row->blob_list()) > textord_max_blob_overlaps)
                    {
                        large_it.add_after_then_move(blob_it.extract());
                        if (testing_on && textord_show_final_rows)
                        {
                            tprintf("Large blob overlaps %d blobs at:", CountOverlaps(blob_box, min_blob_height, row->blob_list()));
                            blob_box.print();
                        }
                    }
                    delete rotated_blob;
                }
                else
                {
                    if (blob->blob () != NULL)
                    {
                        //                                      if (testing_on && textord_show_final_rows)
                        //                                              tprintf("Rotating by (%g,%g)\n",
                        //                                                      blob_rotation.x(),blob_rotation.y());
                        poly_blob = rotate_blob (blob->blob (), blob_rotation);
                    }
                    else
                    {
                        poly_blob = rotate_cblob (blob->cblob (), block->line_size, blob_rotation);
                    }

                    if (test_underline(testing_on && textord_show_final_rows, poly_blob, row->intercept (), block->line_size * (textord_merge_x + textord_merge_asc / 2)))
                    {
                        if (testing_on && textord_show_final_rows)
                        {
                            tprintf ("Underlined blob at (%d,%d)->(%d,%d) ", poly_blob->bounding_box ().left (), poly_blob->bounding_box ().bottom (),
                                     poly_blob->bounding_box ().right (), poly_blob->bounding_box ().top ());

                            tprintf ("(Was (%d,%d)->(%d,%d))\n", blob_box.left (), blob_box.bottom (), blob_box.right (), blob_box.top ());
                        }

                        under_it.add_after_then_move (blob_it.extract ());
                    }

                    delete poly_blob;
                }
            }
        }
    }
}


/**
 * @name pre_associate_blobs
 *
 * Associate overlapping blobs and fake chop wide blobs.
 */
void pre_associate_blobs(                  //make rough chars
                                           ICOORD page_tr,   //top right
                                           TO_BLOCK *block,  //block to do
                                           FCOORD rotation,  //inverse landscape
                                           BOOL8 testing_on  //correct orientation
                                           )
{
#ifndef GRAPHICS_DISABLED
    ScrollView::Color colour;                 //of boxes
#endif
    BLOBNBOX *blob;                //current blob
    BLOBNBOX *nextblob;            //next in list
    TBOX blob_box;
    FCOORD blob_rotation;          //inverse of rotation
    BLOBNBOX_IT blob_it;           //iterator
    BLOBNBOX_IT start_it;          //iterator
    TO_ROW_IT row_it = block->get_rows ();

#ifndef GRAPHICS_DISABLED
    colour = ScrollView::RED;
#endif

    blob_rotation = FCOORD (rotation.x (), -rotation.y ());
    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
        //get blobs
        blob_it.set_to_list (row_it.data ()->blob_list ());
        for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ())
        {
            blob = blob_it.data ();
            blob_box = blob->bounding_box ();
            start_it = blob_it;        //save start point

            //                      if (testing_on && textord_show_final_blobs)
            //                      {
            //                              tprintf("Blob at (%d,%d)->(%d,%d), addr=%x, count=%d\n",
            //                                      blob_box.left(),blob_box.bottom(),
            //                                      blob_box.right(),blob_box.top(),
            //                                      (void*)blob,blob_it.length());
            //                      }
            bool overlap;
            do
            {
                overlap = false;
                if (!blob_it.at_last ())
                {
                    nextblob = blob_it.data_relative(1);
                    overlap = blob_box.major_x_overlap(nextblob->bounding_box());
                    if (overlap)
                    {
                        blob->merge(nextblob); // merge new blob
                        blob_box = blob->bounding_box(); // get bigger box
                        blob_it.forward();
                    }
                }
            }
            while (overlap);

            blob->chop (&start_it, &blob_it, blob_rotation, block->line_size * textord_merge_x * textord_chop_width);
            //attempt chop
        }
#ifndef GRAPHICS_DISABLED
        if (testing_on && textord_show_final_blobs)
        {
            if (to_win == NULL)
            {
                create_to_win(page_tr);
            }
            to_win->Pen(colour);

            for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ())
            {
                blob = blob_it.data ();
                blob_box = blob->bounding_box ();
                blob_box.rotate (rotation);

                if (!blob->joined_to_prev ())
                {
                    to_win->Rectangle (blob_box.left(), blob_box.bottom(), blob_box.right (), blob_box.top());
                }
            }

            colour = (ScrollView::Color) (colour + 1);
            if (colour > ScrollView::MAGENTA) colour = ScrollView::RED;
        }
#endif
    }
}


/**
 * @name fit_parallel_rows
 *
 * Re-fit the rows in the block to the given gradient.
 */
void fit_parallel_rows(//find lines
                       TO_BLOCK *block,   //block to do
                       float gradient,    //gradient to fit
                       FCOORD rotation,   //for drawing
                       inT32 block_edge,  //edge of block
                       BOOL8 testing_on   //correct orientation
                       )
{
#ifndef GRAPHICS_DISABLED
    ScrollView::Color colour;                 //of row
#endif
    TO_ROW_IT row_it = block->get_rows();

    row_it.move_to_first();
    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
    {
        if (row_it.data()->blob_list()->empty())
        {
            delete row_it.extract();  //nothing in it
        }
        else
        {
            fit_parallel_lms(gradient, row_it.data());
        }
    }
#ifndef GRAPHICS_DISABLED
    if (testing_on)
    {
        colour = ScrollView::RED;
        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
        {
            plot_parallel_row(row_it.data(), gradient, block_edge, colour, rotation);
            colour = (ScrollView::Color)(colour + 1);

            if (colour > ScrollView::MAGENTA)
            {
                colour = ScrollView::RED;
            }
        }
    }
#endif
    row_it.sort(row_y_order);     //may have gone out of order
}


/**
 * @name fit_parallel_lms
 *
 * Fit an LMS line to a row.
 * Make the fit parallel to the given gradient and set the
 * row accordingly.
 */
void fit_parallel_lms(//sort function
                      float gradient,  //forced gradient
                      TO_ROW *row      //row to fit
                      )
{
    float c;                       //fitted line
    int blobcount;                 //no of blobs
    TBOX box;                       //blob box
    LMS lms(row->blob_list()->length());

    //blobs
    BLOBNBOX_IT blob_it = row->blob_list();

    blobcount = 0;
    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward())
    {
        if (!blob_it.data()->joined_to_prev())
        {
            box = blob_it.data()->bounding_box();
            lms.add(FCOORD((box.left() + box.right()) / 2.0, box.bottom()));
            blobcount++;
        }
    }

    lms.constrained_fit(gradient, c);
    row->set_parallel_line(gradient, c, lms.error());
    if (textord_straight_baselines && blobcount > lms_line_trials)
    {
        lms.fit(gradient, c);
    }

    //set the other too
    row->set_line(gradient, c, lms.error());
}


/**
 * @name make_spline_rows
 *
 * Re-fit the rows in the block to the given gradient.
 */
void make_spline_rows(//find lines
                      TO_BLOCK *block,   //block to do
                      float gradient,    //gradient to fit
                      FCOORD rotation,   //for drawing
                      inT32 block_edge,  //edge of block
                      BOOL8 testing_on,  //correct orientation
                      Tesseract* tess
                      )
{
    Q_UNUSED(rotation);
    Q_UNUSED(block_edge);
#ifndef GRAPHICS_DISABLED
    ScrollView::Color colour;       //of row
#endif
    TO_ROW_IT row_it = block->get_rows();

    row_it.move_to_first();
    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
    {
        if (row_it.data()->blob_list()->empty())
        {
            delete row_it.extract();  //nothing in it
        }
        else
        {
            make_baseline_spline(row_it.data(), block);
        }
    }
    if (textord_old_baselines)
    {
#ifndef GRAPHICS_DISABLED
        if (testing_on)
        {
            colour = ScrollView::RED;

            for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
            {
                row_it.data()->baseline.plot(to_win, colour);
                colour = (ScrollView::Color) (colour + 1);

                if (colour > ScrollView::MAGENTA)
                {
                    colour = ScrollView::RED;
                }
            }
        }
#endif
        make_old_baselines(block, testing_on, gradient, tess);
    }
#ifndef GRAPHICS_DISABLED
    if (testing_on)
    {
        colour = ScrollView::RED;
        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
        {
            row_it.data()->baseline.plot(to_win, colour);
            colour = (ScrollView::Color)(colour + 1);

            if (colour > ScrollView::MAGENTA)
            {
                colour = ScrollView::RED;
            }
        }
    }
#endif
}


/**
 * @name make_baseline_spline
 *
 * Fit an LMS line to a row.
 * Make the fit parallel to the given gradient and set the
 * row accordingly.
 */
void make_baseline_spline(//sort function
                          TO_ROW *row,     //row to fit
                          TO_BLOCK *block  //block it came from
                          )
{
    float b, c;                    //fitted curve
    float middle;                  //x middle of blob
    TBOX box;                       //blob box
    LMS lms(row->blob_list ()->length());

    //blobs
    BLOBNBOX_IT blob_it = row->blob_list();
    inT32 *xstarts;                //spline boundaries
    double *coeffs;                //quadratic coeffs
    inT32 segments;                //no of segments
    inT32 segment;                 //current segment

    xstarts = (inT32 *)alloc_mem((row->blob_list()->length() + 1) * sizeof(inT32));
    if (segment_baseline (row, block, segments, xstarts) && !textord_straight_baselines && !textord_parallel_baselines)
    {
        if (textord_quadratic_baselines)
        {
            coeffs = (double *)alloc_mem(segments * 3 * sizeof(double));
            for (segment = 0; segment < segments; segment++)
            {
                lms.clear();
                for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward())
                {
                    if (!blob_it.data()->joined_to_prev())
                    {
                        box = blob_it.data()->bounding_box();
                        middle = (box.left() + box.right()) / 2.0;

                        if (middle >= xstarts[segment] && middle < xstarts[segment + 1])
                        {
                            lms.add(FCOORD(middle, box.bottom()));
                        }
                    }
                }

                if (textord_quadratic_baselines)
                {
                    lms.fit_quadratic(block->line_size * textord_spline_outlier_fraction, coeffs[segment * 3], b, c);
                }
                else
                {
                    lms.fit (b, c);
                    coeffs[segment * 3] = 0;
                }

                coeffs[segment * 3 + 1] = b;
                coeffs[segment * 3 + 2] = c;
            }
        }
        else
        {
            coeffs = linear_spline_baseline(row, block, segments, xstarts);
        }
    }
    else
    {
        xstarts[1] = xstarts[segments];
        segments = 1;
        coeffs = (double *)alloc_mem(3 * sizeof (double));
        coeffs[0] = 0;
        coeffs[1] = row->line_m();
        coeffs[2] = row->line_c();
    }

    row->baseline = QSPLINE(segments, xstarts, coeffs);
    free_mem(coeffs);
    free_mem(xstarts);
}


/**
 * @name segment_baseline
 *
 * Divide the baseline up into segments which require a different
 * quadratic fitted to them.
 * Return TRUE if enough blobs were far enough away to need a quadratic.
 */
BOOL8
segment_baseline (               //split baseline
                                 TO_ROW * row,                    //row to fit
                                 TO_BLOCK * block,                //block it came from
                                 inT32 & segments,                //no fo segments
                                 inT32 xstarts[]                  //coords of segments
                                 )
{
    BOOL8 needs_curve;             //needs curved line
    int blobcount;                 //no of blobs
    int blobindex;                 //current blob
    int last_state;                //above, on , below
    int state;                     //of current blob
    float yshift;                  //from baseline
    TBOX box;                       //blob box
    TBOX new_box;                   //new_it box
    float middle;                  //xcentre of blob

    //blobs
    BLOBNBOX_IT blob_it = row->blob_list ();
    BLOBNBOX_IT new_it = blob_it;  //front end
    SORTED_FLOATS yshifts;         //shifts from baseline

    needs_curve = FALSE;
    box = box_next_pre_chopped (&blob_it);
    xstarts[0] = box.left ();
    segments = 1;
    blobcount = row->blob_list ()->length ();

    if (textord_oldbl_debug)
    {
        tprintf ("Segmenting baseline of %d blobs at (%d,%d)\n", blobcount, box.left (), box.bottom ());
    }

    if (blobcount <= textord_spline_medianwin || blobcount < textord_spline_minblobs)
    {
        blob_it.move_to_last ();
        box = blob_it.data ()->bounding_box ();
        xstarts[1] = box.right ();
        return FALSE;
    }

    last_state = 0;
    new_it.mark_cycle_pt ();
    for (blobindex = 0; blobindex < textord_spline_medianwin; blobindex++)
    {
        new_box = box_next_pre_chopped (&new_it);
        middle = (new_box.left () + new_box.right ()) / 2.0;
        yshift = new_box.bottom () - row->line_m () * middle - row->line_c ();

        //record shift
        yshifts.add (yshift, blobindex);
        if (new_it.cycled_list ())
        {
            xstarts[1] = new_box.right ();
            return FALSE;
        }
    }

    for (blobcount = 0; blobcount < textord_spline_medianwin / 2; blobcount++)
    {
        box = box_next_pre_chopped (&blob_it);
    }

    do
    {
        new_box = box_next_pre_chopped (&new_it);

        //get middle one
        yshift = yshifts[textord_spline_medianwin / 2];

        if (yshift > textord_spline_shift_fraction * block->line_size)
        {
            state = 1;
        }
        else if (-yshift > textord_spline_shift_fraction * block->line_size)
        {
            state = -1;
        }
        else
        {
            state = 0;
        }

        if (state != 0)
        {
            needs_curve = TRUE;
        }

        //              tprintf("State=%d, prev=%d, shift=%g\n",
        //                      state,last_state,yshift);
        if (state != last_state && blobcount > textord_spline_minblobs)
        {
            xstarts[segments++] = box.left ();
            blobcount = 0;
        }

        last_state = state;
        yshifts.remove (blobindex - textord_spline_medianwin);
        box = box_next_pre_chopped (&blob_it);
        middle = (new_box.left () + new_box.right ()) / 2.0;
        yshift = new_box.bottom () - row->line_m () * middle - row->line_c ();
        yshifts.add (yshift, blobindex);
        blobindex++;
        blobcount++;
    }
    while (!new_it.cycled_list ());

    if (blobcount > textord_spline_minblobs || segments == 1)
    {
        xstarts[segments] = new_box.right ();
    }
    else
    {
        xstarts[--segments] = new_box.right ();
    }

    if (textord_oldbl_debug)
    {
        tprintf ("Made %d segments on row at (%d,%d)\n", segments, box.right (), box.bottom ());
    }

    return needs_curve;
}


/**
 * @name linear_spline_baseline
 *
 * Divide the baseline up into segments which require a different
 * quadratic fitted to them.
 * @return TRUE if enough blobs were far enough away to need a quadratic.
 */
double *
linear_spline_baseline (         //split baseline
                                 TO_ROW * row,                    //row to fit
                                 TO_BLOCK * block,                //block it came from
                                 inT32 & segments,                //no fo segments
                                 inT32 xstarts[]                  //coords of segments
                                 )
{
    Q_UNUSED(block);
    int blobcount;                 //no of blobs
    int blobindex;                 //current blob
    int index1, index2;            //blob numbers
    int blobs_per_segment;         //blobs in each
    TBOX box;                       //blob box
    TBOX new_box;                   //new_it box
    float middle;                  //xcentre of blob

    //blobs
    BLOBNBOX_IT blob_it = row->blob_list ();
    BLOBNBOX_IT new_it = blob_it;  //front end
    float b, c;                    //fitted curve
    LMS lms (row->blob_list ()->length ());
    double *coeffs;                //quadratic coeffs
    inT32 segment;                 //current segment

    box = box_next_pre_chopped (&blob_it);
    xstarts[0] = box.left ();
    blobcount = 1;
    while (!blob_it.at_first ())
    {
        blobcount++;
        box = box_next_pre_chopped (&blob_it);
    }
    segments = blobcount / textord_spline_medianwin;

    if (segments < 1) segments = 1;
    blobs_per_segment = blobcount / segments;
    coeffs = (double *) alloc_mem (segments * 3 * sizeof (double));

    if (textord_oldbl_debug)
    {
        tprintf("Linear splining baseline of %d blobs at (%d,%d), into %d segments of %d blobs\n", blobcount, box.left (),
                box.bottom (), segments, blobs_per_segment);
    }
    segment = 1;

    for (index2 = 0; index2 < blobs_per_segment / 2; index2++)
    {
        box_next_pre_chopped(&new_it);
    }
    index1 = 0;
    blobindex = index2;

    do
    {
        blobindex += blobs_per_segment;
        lms.clear ();

        while (index1 < blobindex || (segment == segments && index1 < blobcount))
        {
            box = box_next_pre_chopped (&blob_it);
            middle = (box.left () + box.right ()) / 2.0;
            lms.add (FCOORD (middle, box.bottom ()));
            index1++;

            if (index1 == blobindex - blobs_per_segment / 2 || index1 == blobcount - 1)
            {
                xstarts[segment] = box.left ();
            }
        }
        lms.fit (b, c);
        coeffs[segment * 3 - 3] = 0;
        coeffs[segment * 3 - 2] = b;
        coeffs[segment * 3 - 1] = c;
        segment++;

        if (segment > segments) break;

        blobindex += blobs_per_segment;
        lms.clear ();

        while (index2 < blobindex || (segment == segments && index2 < blobcount))
        {
            new_box = box_next_pre_chopped (&new_it);
            middle = (new_box.left () + new_box.right ()) / 2.0;
            lms.add (FCOORD (middle, new_box.bottom ()));
            index2++;

            if (index2 == blobindex - blobs_per_segment / 2 || index2 == blobcount - 1)
            {
                xstarts[segment] = new_box.left ();
            }
        }

        lms.fit (b, c);
        coeffs[segment * 3 - 3] = 0;
        coeffs[segment * 3 - 2] = b;
        coeffs[segment * 3 - 1] = c;
        segment++;
    }
    while (segment <= segments);

    return coeffs;
}


/**
 * @name assign_blobs_to_rows
 *
 * Make enough rows to allocate all the given blobs to one.
 * If a block skew is given, use that, else attempt to track it.
 */
void assign_blobs_to_rows(//find lines
                          TO_BLOCK *block,      //block to do
                          float *gradient,      //block skew
                          int pass,             //identification
                          BOOL8 reject_misses,  //chuck big ones out
                          BOOL8 make_new_rows,  //add rows for unmatched
                          BOOL8 drawing_skew    //draw smoothed skew
                          )
{
    OVERLAP_STATE overlap_result;  //what to do with it
    float ycoord;                  //current y
    float top, bottom;             //of blob
    float g_length = 1.0f;         //from gradient
    inT16 row_count;               //no of rows
    inT16 left_x;                  //left edge
    inT16 last_x;                  //previous edge
    float block_skew;              //y delta
    float smooth_factor;           //for new coords
    float near_dist;               //dist to nearest row
    ICOORD testpt;                 //testing only
    BLOBNBOX *blob;                //current blob
    TO_ROW *row;                   //current row
    TO_ROW *dest_row;              //row to put blob in

    //iterators
    BLOBNBOX_IT blob_it = &block->blobs;
    TO_ROW_IT row_it = block->get_rows();

    ycoord = (block->block->bounding_box().bottom() + block->block->bounding_box().top()) / 2.0f;

    if (gradient != NULL) g_length = sqrt(1 + *gradient * *gradient);
    #ifndef GRAPHICS_DISABLED
    if (drawing_skew)
    {
        to_win->SetCursor(block->block->bounding_box().left(), ycoord);
    }
    #endif
    testpt = ICOORD(textord_test_x, textord_test_y);
    blob_it.sort(blob_x_order); //x坐标从小到排序轮廓框
    smooth_factor = 1.0;
    block_skew = 0.0f;
    row_count = row_it.length();  //might have rows

    if (!blob_it.empty())
    {
        left_x = blob_it.data()->bounding_box().left();
    }
    else
    {
        left_x = block->block->bounding_box().left();
    }

    last_x = left_x;
    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward())
    {
        blob = blob_it.data();
        if (gradient != NULL)
        {
            block_skew = (1 - 1 / g_length) * blob->bounding_box().bottom() + *gradient / g_length * blob->bounding_box().left();
        }
        else if (blob->bounding_box().left() - last_x > block->line_size / 2 && last_x - left_x > block->line_size * 2 && textord_interpolating_skew)
        {
            block_skew *= (float) (blob->bounding_box().left() - left_x) / (last_x - left_x);
        }
        last_x = blob->bounding_box().left();
        top = blob->bounding_box().top() - block_skew;
        bottom = blob->bounding_box().bottom() - block_skew;

        #ifndef GRAPHICS_DISABLED
        if (drawing_skew)
        {
            to_win->DrawTo(blob->bounding_box().left(), ycoord + block_skew);
        }
        #endif
        if (!row_it.empty())
        {
            for (row_it.move_to_first(); !row_it.at_last() && row_it.data()->min_y() > top; row_it.forward());
            row = row_it.data();
            if (row->min_y() <= top && row->max_y() >= bottom)
            {
                //any overlap
                dest_row = row;
                overlap_result = most_overlapping_row(&row_it, dest_row, top, bottom, block->line_size, blob->bounding_box().contains(testpt));

                if (overlap_result == NEW_ROW && !reject_misses)
                {
                    overlap_result = ASSIGN;
                }
            }
            else
            {
                overlap_result = NEW_ROW;
                if (!make_new_rows)
                {
                    near_dist = row_it.data_relative(-1)->min_y() - top;

                    //below bottom
                    if (bottom < row->min_y())
                    {
                        if (row->min_y() - bottom <= (block->line_spacing - block->line_size) * textord_merge_desc)
                        {
                            //done it
                            overlap_result = ASSIGN;
                            dest_row = row;
                        }
                    }
                    else if (near_dist > 0 && near_dist < bottom - row->max_y())
                    {
                        row_it.backward();
                        dest_row = row_it.data();

                        if (dest_row->min_y() - bottom <= (block->line_spacing - block->line_size) * textord_merge_desc)
                        {
                            //done it
                            overlap_result = ASSIGN;
                        }
                    }
                    else
                    {
                        if (top - row->max_y() <= (block->line_spacing - block->line_size) * (textord_overlap_x + textord_merge_asc))
                        {
                            //done it
                            overlap_result = ASSIGN;
                            dest_row = row;
                        }
                    }
                }
            }

            if (overlap_result == ASSIGN)
            {
                dest_row->add_blob(blob_it.extract(), top, bottom, block->line_size);
            }

            if (overlap_result == NEW_ROW)
            {
                if (make_new_rows && top - bottom < block->max_blob_size)
                {
                    dest_row = new TO_ROW (blob_it.extract(), top, bottom, block->line_size);
                    row_count++;

                    if (bottom > row_it.data()->min_y())
                    {
                        row_it.add_before_then_move(dest_row);
                        //insert in right place
                    }
                    else
                    {
                        row_it.add_after_then_move(dest_row);
                    }

                    smooth_factor = 1.0 / (row_count * textord_skew_lag + textord_skewsmooth_offset);
                }
                else
                {
                    overlap_result = REJECT;
                }
            }
        }
        else if (make_new_rows && top - bottom < block->max_blob_size)
        {
            overlap_result = NEW_ROW;
            dest_row = new TO_ROW(blob_it.extract(), top, bottom, block->line_size);
            row_count++;
            row_it.add_after_then_move(dest_row);
            smooth_factor = 1.0 /(row_count * textord_skew_lag + textord_skewsmooth_offset2);
        }
        else
        {
            overlap_result = REJECT;
        }

        if (blob->bounding_box().contains(testpt))
        {
            if (overlap_result != REJECT)
            {
                tprintf("Test blob assigned to row at (%g,%g) on pass %d\n", dest_row->min_y(), dest_row->max_y(), pass);
            }
            else
            {
                tprintf("Test blob assigned to no row on pass %d\n", pass);
            }
        }

        if (overlap_result != REJECT)
        {
            while (!row_it.at_first() && row_it.data()->min_y() > row_it.data_relative(-1)->min_y())
            {
                row = row_it.extract();
                row_it.backward();
                row_it.add_before_then_move(row);
            }
            while (!row_it.at_last() && row_it.data()->min_y() < row_it.data_relative(1)->min_y())
            {
                row = row_it.extract();
                row_it.forward();

                //keep rows in order
                row_it.add_after_then_move(row);
            }

            block_skew = (1 - smooth_factor) * block_skew + smooth_factor * (blob->bounding_box().bottom() - dest_row->initial_min_y());
        }
    }

    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
    {
        if (row_it.data()->blob_list()->empty())
        {
            delete row_it.extract();  //discard empty rows
        }
    }
}


/**
 * @name most_overlapping_row
 *
 * Return the row which most overlaps the blob.
 */
OVERLAP_STATE most_overlapping_row(//find best row
                                   TO_ROW_IT *row_it,  //iterator
                                   TO_ROW *&best_row,  //output row
                                   float top,          //top of blob
                                   float bottom,       //bottom of blob
                                   float rowsize,      //max row size
                                   BOOL8 testing_blob  //test stuff
                                   )
{
    OVERLAP_STATE result;          //result of tests
    float overlap;                 //of blob & row
    float bestover;                //nearest row
    float merge_top, merge_bottom; //size of merged row
    ICOORD testpt;                 //testing only
    TO_ROW *row;                   //current row
    TO_ROW *test_row;              //for multiple overlaps
    BLOBNBOX_IT blob_it;           //for merging rows

    result = ASSIGN;
    row = row_it->data();
    bestover = top - bottom;

    if (top > row->max_y())
    {
        bestover -= top - row->max_y();
    }

    if (bottom < row->min_y())
    {
        //compute overlap
        bestover -= row->min_y() - bottom;
    }

    if (testing_blob)
    {
        tprintf ("Test blob y=(%g,%g), row=(%f,%f), overlap=%f\n", bottom, top, row->min_y(), row->max_y(), bestover);
    }
    test_row = row;

    do
    {
        if (!row_it->at_last())
        {
            row_it->forward();
            test_row = row_it->data();
            if (test_row->min_y() <= top && test_row->max_y() >= bottom)
            {
                merge_top = test_row->max_y() > row->max_y()? test_row->max_y() : row->max_y();
                merge_bottom = test_row->min_y() < row->min_y()? test_row->min_y() : row->min_y();
                if (merge_top - merge_bottom <= rowsize)
                {
                    if (testing_blob)
                    {
                        tprintf ("Merging rows at (%g,%g), (%g,%g)\n", row->min_y(), row->max_y(), test_row->min_y(), test_row->max_y());
                    }

                    test_row->set_limits (merge_bottom, merge_top);
                    blob_it.set_to_list (test_row->blob_list());
                    blob_it.add_list_after (row->blob_list());
                    blob_it.sort (blob_x_order);
                    row_it->backward();
                    delete row_it->extract();
                    row_it->forward();
                    bestover = -1.0f;      //force replacement
                }

                overlap = top - bottom;
                if (top > test_row->max_y())
                {
                    overlap -= top - test_row->max_y();
                }

                if (bottom < test_row->min_y())
                {
                    overlap -= test_row->min_y() - bottom;
                }

                if (bestover >= rowsize - 1 && overlap >= rowsize - 1)
                {
                    result = REJECT;
                }

                if (overlap > bestover)
                {
                    bestover = overlap;    //find biggest overlap
                    row = test_row;
                }

                if (testing_blob)
                {
                    tprintf("Test blob y=(%g,%g), row=(%f,%f), overlap=%f->%f\n", bottom, top, test_row->min_y(), test_row->max_y(), overlap, bestover);
                }
            }
        }
    }
    while (!row_it->at_last() && test_row->min_y() <= top && test_row->max_y() >= bottom);
    while (row_it->data() != row) row_it->backward();         //make it point to row

    //doesn't overlap much
    if (top - bottom - bestover > rowsize * textord_overlap_x && (!textord_fix_makerow_bug || bestover < rowsize * textord_overlap_x) && result == ASSIGN)
    {
        result = NEW_ROW;            //doesn't overlap enough
    }
    best_row = row;

    return result;
}


/**
 * @name blob_x_order
 *
 * Sort function to sort blobs in x from page left.
 */
int blob_x_order(//sort function
                 const void *item1,  //items to compare
                 const void *item2)
{
    //converted ptr
    BLOBNBOX *blob1 = *(BLOBNBOX **)item1;

    //converted ptr
    BLOBNBOX *blob2 = *(BLOBNBOX **)item2;

    if (blob1->bounding_box().left() < blob2->bounding_box().left())
    {
        return -1;
    }
    else if (blob1->bounding_box().left() > blob2->bounding_box().left())
    {
        return 1;
    }
    else
    {
        return 0;
    }
}


/**
 * @name row_y_order
 *
 * Sort function to sort rows in y from page top.
 */
int row_y_order(                    //sort function
                                    const void *item1,  //items to compare
                                    const void *item2)
{
    //converted ptr
    TO_ROW *row1 = *(TO_ROW **) item1;

    //converted ptr
    TO_ROW *row2 = *(TO_ROW **) item2;

    if (row1->parallel_c () > row2->parallel_c ())
    {
        return -1;
    }
    else if (row1->parallel_c () < row2->parallel_c ())
    {
        return 1;
    }
    else
    {
        return 0;
    }
}


/**
 * @name row_spacing_order
 *
 * Qsort style function to compare 2 TO_ROWS based on their spacing value.
 */
int row_spacing_order(//sort function
                      const void *item1,  //items to compare
                      const void *item2)
{
    //converted ptr
    TO_ROW *row1 = *(TO_ROW **) item1;

    //converted ptr
    TO_ROW *row2 = *(TO_ROW **) item2;

    if (row1->spacing < row2->spacing)
    {
        return -1;
    }
    else if (row1->spacing > row2->spacing)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

/**
 * @name make_repeated_chars
 *
 * Mark textord_repeat_threshold or more adjacent chars which are the
 * same as repeated chars.
 */
void mark_repeated_chars(TO_ROW *row, float block_xheight, Tesseract *tess)
{
    ROW *real_row = NULL;          //output row
    BLOBNBOX *bblob;               //current blob
    BLOBNBOX *nextblob;            //neighbour to compare
    BLOBNBOX_IT box_it;            //iterator
    BLOBNBOX_IT search_it;         //forward search
    inT32 blobcount;               //no of neighbours
    inT32 matched_blobcount;       //no of matches
    inT32 blobindex;               //in row
    inT32 row_length;              //blobs in row
    inT32 width_change;            //max width change
    inT32 blob_width;              //required blob width
    inT32 space_width;             //required gap width
    inT32 prev_right;              //right edge of last blob
    float rating;                  //match rating
    PBLOB *pblob1;                 //polygonal blob
    PBLOB *pblob2;                 //second blob

    // kern_size and space_size are computed in the same way as in
    // compute_block_pitch().
    float kern_size = ceil(block_xheight * textord_words_default_nonspace);
    float space_size = floor(block_xheight * textord_words_default_minspace);
    int num_repeated_sets = 0;
    box_it.set_to_list(row->blob_list());
    row_length = row->blob_list()->length();
    blobindex = 0;

    if (!box_it.empty())
    {
        if (textord_debug_xheights)
        {
            tprintf("Running mark_repeated_chars(), row length %d\n", row_length);
        }

        real_row = new ROW(row, static_cast<inT32>(kern_size),static_cast<inT32>(space_size));

        // Use block_xheight, since xheight of the row (used in the ROW()
        // constructor) might not have been computed yet.
        real_row->set_x_height(block_xheight);

        do
        {
            bblob = box_it.data();
            blobcount = 1;
            search_it = box_it;
            search_it.forward();
            matched_blobcount = 1;
            width_change = MAX_INT16;
            blob_width = 0;
            space_width = 0;
            prev_right = bblob->bounding_box().right();

            if (bblob->bounding_box().height() * 2 < block_xheight && !bblob->joined_to_prev() && (bblob->blob() != NULL || bblob->cblob() != NULL))
            {
                pblob1 = (bblob->cblob() != NULL) ? new PBLOB(bblob->cblob(), block_xheight) : bblob->blob();
                rating = 0.0f;

                while (rating < textord_repeat_rating && blobindex + blobcount < row_length &&
                       ((nextblob = search_it.data())->blob() != NULL || nextblob->cblob() != NULL) &&
                       nextblob->bounding_box().height() * 2 < block_xheight)
                {
                    if (blobcount == 1)
                    {
                        space_width = nextblob->bounding_box().left() - bblob->bounding_box().right();
                        blob_width = bblob->bounding_box().width();
                        width_change = blob_width > space_width ? blob_width : space_width;
                        width_change = static_cast<inT32>(width_change * textord_repch_width_variance);
                        if (width_change < 3) width_change = 3;
                    }

                    if (nextblob->bounding_box().width() > blob_width + width_change ||
                            nextblob->bounding_box().width() < blob_width - width_change ||
                            nextblob->bounding_box().left() - prev_right >
                            space_width + width_change ||
                            nextblob->bounding_box().left() - prev_right < space_width - width_change)
                    {
                        break;  // not good enough
                    }

                    if (nextblob->blob() != NULL)
                    {
                        rating = tess->compare_blobs(pblob1, real_row, nextblob->blob(), real_row);
                    }
                    else
                    {
                        pblob2 = new PBLOB(nextblob->cblob(), block_xheight);
                        rating = tess->compare_blobs(pblob1, real_row, pblob2, real_row);
                        delete pblob2;
                    }

                    if (rating < textord_repeat_rating)
                    {
                        blobcount++;
                        search_it.forward();
                        matched_blobcount++;

                        while (blobindex + blobcount < row_length &&
                               (search_it.data()->joined_to_prev() ||
                                (search_it.data()->blob() == NULL &&
                                 search_it.data()->cblob() == NULL)))
                        {
                            search_it.forward();
                            blobcount++;     //suck in joined bits
                        }
                    }

                    prev_right = nextblob->bounding_box().right();
                }

                if (bblob->cblob() != NULL) delete pblob1;
            }

            // Record position and length of this run of repeated chars.
            if (matched_blobcount >= textord_repeat_threshold)
            {
                if (textord_debug_xheights)
                {
                    tprintf("Found %d repeated chars starting at blob index %d\n", blobcount, blobindex);
                }
                blobindex += blobcount;
                num_repeated_sets++;

                while (blobcount-- > 0 && !box_it.at_first())
                {
                    box_it.data()->set_repeated_set(num_repeated_sets);
                    box_it.forward();
                }
            }
            else
            {
                // just forward box_it to the next blob
                blobindex += blobcount;
                box_it.forward();
            }
        } while (!box_it.at_first());  // until all done

        if (real_row != NULL) delete real_row;
    }

    row->set_num_repeated_sets(num_repeated_sets);
}
/////////////////////////////////////////////////////////////////makerow////////////////////////////////////////

/////////////////////////////////////////////////////////////////topitch////////////////////////////////////////
#define EXTERN
EXTERN BOOL_VAR (textord_all_prop, FALSE, "All doc is proportial text");
EXTERN BOOL_VAR (textord_debug_pitch_test, FALSE, "Debug on fixed pitch test");
EXTERN BOOL_VAR (textord_disable_pitch_test, FALSE, "Turn off dp fixed pitch algorithm");
EXTERN BOOL_VAR (textord_fast_pitch_test, FALSE, "Do even faster pitch algorithm");
EXTERN BOOL_VAR (textord_debug_pitch_metric, FALSE, "Write full metric stuff");
EXTERN BOOL_VAR (textord_show_row_cuts, FALSE, "Draw row-level cuts");
EXTERN BOOL_VAR (textord_show_page_cuts, FALSE, "Draw page-level cuts");
EXTERN BOOL_VAR (textord_pitch_cheat, FALSE, "Use correct answer for fixed/prop");
EXTERN BOOL_VAR (textord_blockndoc_fixed, FALSE, "Attempt whole doc/block fixed pitch");
EXTERN double_VAR (textord_projection_scale, 0.200, "Ding rate for mid-cuts");
EXTERN double_VAR (textord_balance_factor, 1.0, "Ding rate for unbalanced char cells");

#define FIXED_WIDTH_MULTIPLE  5
#define BLOCK_STATS_CLUSTERS  10
#define MAX_ALLOWED_PITCH 100    //max pixel pitch.

/**********************************************************************
 * compute_fixed_pitch
 *
 * Decide whether each row is fixed pitch individually.
 * Correlate definite and uncertain results to obtain an individual
 * result for each row in the TO_ROW class.
 **********************************************************************/
//determine pitch
void compute_fixed_pitch(ICOORD page_tr,              //top right
                         TO_BLOCK_LIST *port_blocks,  //input list
                         float gradient,              //page skew
                         FCOORD rotation,             //for drawing
                         BOOL8 testing_on,            //correct orientation
                         Tesseract* tess
                         )
{
    TO_BLOCK_IT block_it;          //iterator
    TO_BLOCK *block;               //current block;
    TO_ROW_IT row_it;              //row iterator
    TO_ROW *row;                   //current row
    int block_index;               //block number
    int row_index;                 //row number

#ifndef GRAPHICS_DISABLED
    if (textord_show_initial_words && testing_on)
    {
        if (to_win == NULL)
            create_to_win(page_tr);
    }
#endif

    block_it.set_to_list(port_blocks);
    block_index = 1;
    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward())
    {
        block = block_it.data();
        compute_block_pitch(block, rotation, block_index, testing_on, tess);
        block_index++;
    }

    if (!try_doc_fixed (page_tr, port_blocks, gradient))
    {
        block_index = 1;
        for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward())
        {
            block = block_it.data ();
            if (!try_block_fixed (block, block_index))
            {
                try_rows_fixed(block, block_index, testing_on);
            }

            block_index++;
        }
    }

    block_index = 1;
    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward())
    {
        block = block_it.data();
        row_it.set_to_list(block->get_rows());
        row_index = 1;

        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
        {
            row = row_it.data();
            fix_row_pitch(row, block, port_blocks, row_index, block_index);
            row_index++;
        }

        block_index++;
    }

#ifndef GRAPHICS_DISABLED
    if (textord_show_initial_words && testing_on)
    {
        ScrollView::Update();
    }
#endif
}


/**********************************************************************
 * fix_row_pitch
 *
 * Get a pitch_decision for this row by voting among similar rows in the
 * block, then similar rows over all the page, or any other rows at all.
 **********************************************************************/

void fix_row_pitch(TO_ROW *bad_row,        // row to fix
                   TO_BLOCK *bad_block,    // block of bad_row
                   TO_BLOCK_LIST *blocks,  // blocks to scan
                   inT32 row_target,       // number of row
                   inT32 block_target)
{
    Q_UNUSED(bad_block);
    // number of block
    inT16 mid_cuts;
    int block_votes;               //votes in block
    int like_votes;                //votes over page
    int other_votes;               //votes of unlike blocks
    int block_index;               //number of block
    int row_index;                 //number of row
    int maxwidth;                  //max pitch
    TO_BLOCK_IT block_it = blocks; //block iterator
    TO_ROW_IT row_it;
    TO_BLOCK *block;               //current block
    TO_ROW *row;                   //current row
    float sp_sd;                   //space deviation
    STATS block_stats;             //pitches in block
    STATS like_stats;              //pitches in page

    block_votes = like_votes = other_votes = 0;
    maxwidth = (inT32) ceil (bad_row->xheight * textord_words_maxspace);
    if (bad_row->pitch_decision != PITCH_DEF_FIXED  && bad_row->pitch_decision != PITCH_DEF_PROP)
    {
        block_stats.set_range (0, maxwidth);
        like_stats.set_range (0, maxwidth);
        block_index = 1;
        for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ())
        {
            block = block_it.data ();
            row_index = 1;
            row_it.set_to_list (block->get_rows ());
            for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
            {
                row = row_it.data ();

                if ((bad_row->all_caps &&
                     row->xheight + row->ascrise < (bad_row->xheight + bad_row->ascrise) * (1 + textord_pitch_rowsimilarity) &&
                     row->xheight + row->ascrise > (bad_row->xheight + bad_row->ascrise) * (1 - textord_pitch_rowsimilarity)) ||
                        (!bad_row->all_caps &&
                         row->xheight < bad_row->xheight * (1 + textord_pitch_rowsimilarity) &&
                         row->xheight > bad_row->xheight * (1 - textord_pitch_rowsimilarity)))
                {
                    if (block_index == block_target)
                    {
                        if (row->pitch_decision == PITCH_DEF_FIXED)
                        {
                            block_votes += textord_words_veto_power;
                            block_stats.add ((inT32) row->fixed_pitch, textord_words_veto_power);
                        }
                        else if (row->pitch_decision == PITCH_MAYBE_FIXED || row->pitch_decision == PITCH_CORR_FIXED)
                        {
                            block_votes++;
                            block_stats.add ((inT32) row->fixed_pitch, 1);
                        }
                        else if (row->pitch_decision == PITCH_DEF_PROP)
                        {
                            block_votes -= textord_words_veto_power;
                        }
                        else if (row->pitch_decision == PITCH_MAYBE_PROP || row->pitch_decision == PITCH_CORR_PROP)
                        {
                            block_votes--;
                        }
                    }
                    else
                    {
                        if (row->pitch_decision == PITCH_DEF_FIXED)
                        {
                            like_votes += textord_words_veto_power;
                            like_stats.add ((inT32) row->fixed_pitch, textord_words_veto_power);
                        }
                        else if (row->pitch_decision == PITCH_MAYBE_FIXED
                                 || row->pitch_decision == PITCH_CORR_FIXED) {
                            like_votes++;
                            like_stats.add ((inT32) row->fixed_pitch, 1);
                        }
                        else if (row->pitch_decision == PITCH_DEF_PROP)
                        {
                            like_votes -= textord_words_veto_power;
                        }
                        else if (row->pitch_decision == PITCH_MAYBE_PROP || row->pitch_decision == PITCH_CORR_PROP)
                        {
                            like_votes--;
                        }
                    }
                }
                else
                {
                    if (row->pitch_decision == PITCH_DEF_FIXED)
                    {
                        other_votes += textord_words_veto_power;
                    }
                    else if (row->pitch_decision == PITCH_MAYBE_FIXED || row->pitch_decision == PITCH_CORR_FIXED)
                    {
                        other_votes++;
                    }
                    else if (row->pitch_decision == PITCH_DEF_PROP)
                    {
                        other_votes -= textord_words_veto_power;
                    }
                    else if (row->pitch_decision == PITCH_MAYBE_PROP || row->pitch_decision == PITCH_CORR_PROP)
                    {
                        other_votes--;
                    }
                }

                row_index++;
            }

            block_index++;
        }

        if (block_votes > textord_words_veto_power)
        {
            bad_row->fixed_pitch = block_stats.ile (0.5);
            bad_row->pitch_decision = PITCH_CORR_FIXED;
        }
        else if (block_votes <= textord_words_veto_power && like_votes > 0)
        {
            bad_row->fixed_pitch = like_stats.ile (0.5);
            bad_row->pitch_decision = PITCH_CORR_FIXED;
        }
        else
        {
            bad_row->pitch_decision = PITCH_CORR_PROP;
#ifndef SECURE_NAMES
            if (block_votes == 0 && like_votes == 0 && other_votes > 0 && (textord_debug_pitch_test || textord_debug_pitch_metric))
            {
                tprintf ("Warning:row %d of block %d set prop with no like rows against trend\n", row_target, block_target);
            }
#endif
        }
    }

    if (textord_debug_pitch_metric)
    {
        tprintf(":b_votes=%d:l_votes=%d:o_votes=%d", block_votes, like_votes, other_votes);
        tprintf("x=%g:asc=%g\n", bad_row->xheight, bad_row->ascrise);
    }

    if (bad_row->pitch_decision == PITCH_CORR_FIXED)
    {
        if (bad_row->fixed_pitch < textord_min_xheight)
        {
            if (block_votes > 0)
            {
                bad_row->fixed_pitch = block_stats.ile (0.5);
            }
            else if (block_votes == 0 && like_votes > 0)
            {
                bad_row->fixed_pitch = like_stats.ile (0.5);
            }
            else
            {
                tprintf("Warning:guessing pitch as xheight on row %d, block %d\n", row_target, block_target);
                bad_row->fixed_pitch = bad_row->xheight;
            }
        }

        if (bad_row->fixed_pitch < textord_min_xheight)
        {
            bad_row->fixed_pitch = (float) textord_min_xheight;
        }

        bad_row->kern_size = bad_row->fixed_pitch / 4;
        bad_row->min_space = (inT32) (bad_row->fixed_pitch * 0.6);
        bad_row->max_nonspace = (inT32) (bad_row->fixed_pitch * 0.4);
        bad_row->space_threshold = (bad_row->min_space + bad_row->max_nonspace) / 2;
        bad_row->space_size = bad_row->fixed_pitch;

        if (bad_row->char_cells.empty())
        {
            tune_row_pitch(bad_row, &bad_row->projection, bad_row->projection_left, bad_row->projection_right,
                           (bad_row->fixed_pitch + bad_row->max_nonspace * 3) / 4, bad_row->fixed_pitch, sp_sd, mid_cuts, &bad_row->char_cells, FALSE);
        }
    }
    else if (bad_row->pitch_decision == PITCH_CORR_PROP || bad_row->pitch_decision == PITCH_DEF_PROP)
    {
        bad_row->fixed_pitch = 0.0f;
        bad_row->char_cells.clear ();
    }
}


/**********************************************************************
 * compute_block_pitch
 *
 * Decide whether each block is fixed pitch individually.
 **********************************************************************/

void compute_block_pitch(//process each block
                         TO_BLOCK *block,    //input list
                         FCOORD rotation,    //for drawing
                         inT32 block_index,  //block number
                         BOOL8 testing_on,   //correct orientation
                         Tesseract* tess
                         )
{
    Q_UNUSED(rotation);
    TBOX block_box;                 //bounding box

    block_box = block->block->bounding_box();
    if (testing_on && textord_debug_pitch_test)
    {
        tprintf ("Block %d at (%d,%d)->(%d,%d)\n", block_index, block_box.left (), block_box.bottom (), block_box.right (), block_box.top ());
    }

    block->min_space = (inT32)floor(block->xheight * textord_words_default_minspace);
    block->max_nonspace = (inT32)ceil (block->xheight * textord_words_default_nonspace);
    block->fixed_pitch = 0.0f;
    block->space_size = (float)block->min_space;
    block->kern_size = (float)block->max_nonspace;
    block->pr_nonsp = block->xheight * words_default_prop_nonspace;
    block->pr_space = block->pr_nonsp * textord_spacesize_ratioprop;

    if (!block->get_rows()->empty())
    {
        ASSERT_HOST(block->xheight > 0);
        if (textord_repeat_extraction)
        {
            find_repeated_chars(block, textord_show_initial_words &&testing_on, tess);
        }
#ifndef GRAPHICS_DISABLED
        if (textord_show_initial_words && testing_on)
            //overlap_picture_ops(TRUE);
            ScrollView::Update();
#endif
        compute_rows_pitch(block, block_index, textord_debug_pitch_test &&testing_on);
    }
}

/**********************************************************************
 * compute_rows_pitch
 *
 * Decide whether each row is fixed pitch individually.
 **********************************************************************/

BOOL8 compute_rows_pitch(//find line stats
                         TO_BLOCK *block,    //block to do
                         inT32 block_index,  //block number
                         BOOL8 testing_on    //correct orientation
                         )
{
    inT32 maxwidth;                //of spaces
    TO_ROW *row;                   //current row
    inT32 row_index;               //row number.
    float lower, upper;            //cluster thresholds
    TO_ROW_IT row_it = block->get_rows ();

    row_index = 1;
    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
    {
        row = row_it.data();
        ASSERT_HOST(row->xheight > 0);
        row->compute_vertical_projection ();
        maxwidth = (inT32)ceil(row->xheight * textord_words_maxspace);

        if (row_pitch_stats(row, maxwidth, testing_on) && find_row_pitch(row, maxwidth, textord_dotmatrix_gap + 1, block, block_index, row_index, testing_on))
        {
            if (row->fixed_pitch == 0)
            {
                lower = row->pr_nonsp;
                upper = row->pr_space;
                row->space_size = upper;
                row->kern_size = lower;
            }
        }
        else
        {
            row->fixed_pitch = 0.0f;   //insufficient data
            row->pitch_decision = PITCH_DUNNO;
        }
        row_index++;
    }

    return FALSE;
}


/**********************************************************************
 * try_doc_fixed
 *
 * Attempt to call the entire document fixed pitch.
 **********************************************************************/

BOOL8 try_doc_fixed(//determine pitch
                    ICOORD page_tr,              //top right
                    TO_BLOCK_LIST *port_blocks,  //input list
                    float gradient               //page skew
                    )
{
    Q_UNUSED(page_tr);
    inT16 master_x;                //uniform shifts
    inT16 pitch;                   //median pitch.
    int x;                         //profile coord
    int prop_blocks;               //correct counts
    int fixed_blocks;
    int total_row_count;           //total in page
    //iterator
    TO_BLOCK_IT block_it = port_blocks;
    TO_BLOCK *block;               //current block;
    TO_ROW_IT row_it;              //row iterator
    TO_ROW *row;                   //current row
    inT16 projection_left;         //edges
    inT16 projection_right;
    inT16 row_left;                //edges of row
    inT16 row_right;
    ICOORDELT_LIST *master_cells;  //cells for page
    float master_y;                //uniform shifts
    float shift_factor;            //page skew correction
    float row_shift;               //shift for row
    float final_pitch;             //output pitch
    float row_y;                   //baseline
    STATS projection;              //entire page
    STATS pitches (0, MAX_ALLOWED_PITCH);
    //for median
    float sp_sd;                   //space sd
    inT16 mid_cuts;                //no of cheap cuts
    float pitch_sd;                //sync rating

    //      || block_it.data()==block_it.data_relative(1)
    if (block_it.empty () || !textord_blockndoc_fixed)
    {
        return FALSE;
    }

    shift_factor = gradient / (gradient * gradient + 1);
    row_it.set_to_list (block_it.data ()->get_rows ());
    master_x = row_it.data ()->projection_left;
    master_y = row_it.data ()->baseline.y (master_x);
    projection_left = MAX_INT16;
    projection_right = -MAX_INT16;
    prop_blocks = 0;
    fixed_blocks = 0;
    total_row_count = 0;

    for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ()) {

        block = block_it.data ();
        row_it.set_to_list (block->get_rows ());

        for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
        {
            row = row_it.data ();
            total_row_count++;

            if (row->fixed_pitch > 0)
            {
                pitches.add ((inT32) (row->fixed_pitch), 1);
            }

            //find median
            row_y = row->baseline.y (master_x);
            row_left = (inT16) (row->projection_left - shift_factor * (master_y - row_y));
            row_right = (inT16) (row->projection_right - shift_factor * (master_y - row_y));

            if (row_left < projection_left)
            {
                projection_left = row_left;
            }

            if (row_right > projection_right)
            {
                projection_right = row_right;
            }
        }
    }

    if (pitches.get_total () == 0)
    {
        return FALSE;
    }

    projection.set_range (projection_left, projection_right);

    for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ())
    {
        block = block_it.data ();
        row_it.set_to_list (block->get_rows ());

        for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
        {
            row = row_it.data ();
            row_y = row->baseline.y (master_x);

            row_left = (inT16) (row->projection_left - shift_factor * (master_y - row_y));

            for (x = row->projection_left; x < row->projection_right; x++, row_left++)
            {
                projection.add (row_left, row->projection.pile_count (x));
            }
        }
    }

    row_it.set_to_list (block_it.data ()->get_rows ());
    row = row_it.data ();
#ifndef GRAPHICS_DISABLED
    if (textord_show_page_cuts && to_win != NULL)
    {
        projection.plot(to_win, projection_left, row->intercept (), 1.0f, -1.0f, ScrollView::CORAL);
    }
#endif
    final_pitch = pitches.ile (0.5);
    pitch = (inT16) final_pitch;
    pitch_sd = tune_row_pitch (row, &projection, projection_left, projection_right, pitch * 0.75, final_pitch, sp_sd, mid_cuts, &row->char_cells, FALSE);

    if (textord_debug_pitch_metric)
    {
        tprintf("try_doc:props=%d:fixed=%d:pitch=%d:final_pitch=%g:pitch_sd=%g:sp_sd=%g:sd/trc=%g:sd/p=%g:sd/trc/p=%g\n",
                prop_blocks, fixed_blocks, pitch, final_pitch, pitch_sd, sp_sd,
                pitch_sd / total_row_count, pitch_sd / pitch,
                pitch_sd / total_row_count / pitch);
    }

#ifndef GRAPHICS_DISABLED
    if (textord_show_page_cuts && to_win != NULL)
    {
        master_cells = &row->char_cells;
        for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ())
        {
            block = block_it.data ();
            row_it.set_to_list (block->get_rows ());
            for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
            {
                row = row_it.data ();
                row_y = row->baseline.y (master_x);
                row_shift = shift_factor * (master_y - row_y);
                plot_row_cells(to_win, ScrollView::GOLDENROD, row, row_shift, master_cells);
            }
        }
    }
#endif
    row->char_cells.clear ();
    return FALSE;
}


/**********************************************************************
 * try_block_fixed
 *
 * Try to call the entire block fixed.
 **********************************************************************/

BOOL8 try_block_fixed(//find line stats
                      TO_BLOCK *block,   //block to do
                      inT32 block_index  //block number
                      )
{
    Q_UNUSED(block);
    Q_UNUSED(block_index);
    return FALSE;
}


/**********************************************************************
 * try_rows_fixed
 *
 * Decide whether each row is fixed pitch individually.
 **********************************************************************/

BOOL8 try_rows_fixed(//find line stats
                     TO_BLOCK *block,    //block to do
                     inT32 block_index,  //block number
                     BOOL8 testing_on    //correct orientation
                     )
{
    TO_ROW *row;                   //current row
    inT32 row_index;               //row number.
    inT32 def_fixed = 0;           //counters
    inT32 def_prop = 0;
    inT32 maybe_fixed = 0;
    inT32 maybe_prop = 0;
    inT32 dunno = 0;
    inT32 corr_fixed = 0;
    inT32 corr_prop = 0;
    float lower, upper;            //cluster thresholds
    TO_ROW_IT row_it = block->get_rows ();

    row_index = 1;
    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
        row = row_it.data ();
        ASSERT_HOST (row->xheight > 0);
        ceil(row->xheight * textord_words_maxspace);
        if (row->fixed_pitch > 0 && fixed_pitch_row (row, block_index))
        {
            if (row->fixed_pitch == 0)
            {
                lower = row->pr_nonsp;
                upper = row->pr_space;
                row->space_size = upper;
                row->kern_size = lower;
            }
        }
        row_index++;
    }

    count_block_votes(block, def_fixed, def_prop, maybe_fixed, maybe_prop, corr_fixed, corr_prop, dunno);

    if (testing_on && (textord_debug_pitch_test || textord_blocksall_prop || textord_blocksall_fixed))
    {
        tprintf ("Initially:");
        print_block_counts(block, block_index);
    }

    if (def_fixed > def_prop * textord_words_veto_power)
    {
        block->pitch_decision = PITCH_DEF_FIXED;
    }
    else if (def_prop > def_fixed * textord_words_veto_power)
    {
        block->pitch_decision = PITCH_DEF_PROP;
    }
    else if (def_fixed > 0 || def_prop > 0)
    {
        block->pitch_decision = PITCH_DUNNO;
    }
    else if (maybe_fixed > maybe_prop * textord_words_veto_power)
    {
        block->pitch_decision = PITCH_MAYBE_FIXED;
    }
    else if (maybe_prop > maybe_fixed * textord_words_veto_power)
    {
        block->pitch_decision = PITCH_MAYBE_PROP;
    }
    else
    {
        block->pitch_decision = PITCH_DUNNO;
    }

    return FALSE;
}


/**********************************************************************
 * print_block_counts
 *
 * Count up how many rows have what decision and print the results.
 **********************************************************************/

void print_block_counts(//find line stats
                        TO_BLOCK *block,   //block to do
                        inT32 block_index  //block number
                        )
{
    inT32 def_fixed = 0;           //counters
    inT32 def_prop = 0;
    inT32 maybe_fixed = 0;
    inT32 maybe_prop = 0;
    inT32 dunno = 0;
    inT32 corr_fixed = 0;
    inT32 corr_prop = 0;

    count_block_votes(block, def_fixed, def_prop, maybe_fixed, maybe_prop, corr_fixed, corr_prop, dunno);
    tprintf ("Block %d has (%d,%d,%d)", block_index, def_fixed, maybe_fixed, corr_fixed);

    if (textord_blocksall_prop && (def_fixed || maybe_fixed || corr_fixed))
    {
        tprintf (" (Wrongly)");
    }

    tprintf (" fixed, (%d,%d,%d)", def_prop, maybe_prop, corr_prop);

    if (textord_blocksall_fixed && (def_prop || maybe_prop || corr_prop))
    {
        tprintf (" (Wrongly)");
    }

    tprintf (" prop, %d dunno\n", dunno);
}


/**********************************************************************
 * count_block_votes
 *
 * Count the number of rows in the block with each kind of pitch_decision.
 **********************************************************************/

void count_block_votes(//find line stats
                       TO_BLOCK *block,   //block to do
                       inT32 &def_fixed,  //add to counts
                       inT32 &def_prop,
                       inT32 &maybe_fixed,
                       inT32 &maybe_prop,
                       inT32 &corr_fixed,
                       inT32 &corr_prop,
                       inT32 &dunno)
{
    TO_ROW *row;                   //current row
    TO_ROW_IT row_it = block->get_rows ();

    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
        row = row_it.data ();
        switch (row->pitch_decision)
        {
        case PITCH_DUNNO:
            dunno++;
            break;
        case PITCH_DEF_PROP:
            def_prop++;
            break;
        case PITCH_MAYBE_PROP:
            maybe_prop++;
            break;
        case PITCH_DEF_FIXED:
            def_fixed++;
            break;
        case PITCH_MAYBE_FIXED:
            maybe_fixed++;
            break;
        case PITCH_CORR_PROP:
            corr_prop++;
            break;
        case PITCH_CORR_FIXED:
            corr_fixed++;
            break;
        }
    }
}


/**********************************************************************
 * row_pitch_stats
 *
 * Decide whether each row is fixed pitch individually.
 **********************************************************************/

BOOL8 row_pitch_stats(//find line stats
                      TO_ROW *row,      //current row
                      inT32 maxwidth,   //of spaces
                      BOOL8 testing_on  //correct orientation
                      )
{
    BLOBNBOX *blob;                //current blob
    int gap_index;                 //current gap
    inT32 prev_x;                  //end of prev blob
    inT32 cluster_count;           //no of clusters
    inT32 prev_count;              //of clusters
    inT32 smooth_factor;           //for smoothing stats
    TBOX blob_box;                  //bounding box
    float lower, upper;            //cluster thresholds
    //gap sizes
    float gaps[BLOCK_STATS_CLUSTERS];

    //blobs
    BLOBNBOX_IT blob_it = row->blob_list ();
    STATS gap_stats (0, maxwidth);
    STATS cluster_stats[BLOCK_STATS_CLUSTERS + 1];
    //clusters

    smooth_factor = (inT32) (row->xheight * textord_wordstats_smooth_factor + 1.5);
    if (!blob_it.empty ())
    {
        prev_x = blob_it.data ()->bounding_box ().right ();
        blob_it.forward ();

        while (!blob_it.at_first ())
        {
            blob = blob_it.data ();
            if (!blob->joined_to_prev ())
            {
                blob_box = blob->bounding_box ();
                if (blob_box.left () - prev_x < maxwidth)
                {
                    gap_stats.add (blob_box.left () - prev_x, 1);
                }

                prev_x = blob_box.right ();
            }

            blob_it.forward ();
        }
    }

    if (gap_stats.get_total () == 0)
    {
        return FALSE;
    }

    cluster_count = 0;
    lower = row->xheight * words_initial_lower;
    upper = row->xheight * words_initial_upper;
    gap_stats.smooth (smooth_factor);

    do
    {
        prev_count = cluster_count;
        cluster_count = gap_stats.cluster(lower, upper, textord_spacesize_ratioprop, BLOCK_STATS_CLUSTERS, cluster_stats);
    }
    while (cluster_count > prev_count && cluster_count < BLOCK_STATS_CLUSTERS);

    if (cluster_count < 1)
    {
        return FALSE;
    }

    for (gap_index = 0; gap_index < cluster_count; gap_index++)
    {
        gaps[gap_index] = cluster_stats[gap_index + 1].ile (0.5);
    }

    //get medians
    if (testing_on)
    {
        tprintf ("cluster_count=%d:", cluster_count);

        for (gap_index = 0; gap_index < cluster_count; gap_index++)
        {
            tprintf(" %g(%d)", gaps[gap_index], cluster_stats[gap_index + 1].get_total ());
        }

        tprintf("\n");
    }
    qsort(gaps, cluster_count, sizeof (float), sort_floats2);

    //Try to find proportional non-space and space for row.
    lower = row->xheight * words_default_prop_nonspace;
    upper = row->xheight * textord_words_min_minspace;

    for (gap_index = 0; gap_index < cluster_count && gaps[gap_index] < lower; gap_index++);
    if (gap_index == 0)
    {
        if (testing_on)
        {
            tprintf ("No clusters below nonspace threshold!!\n");
        }

        if (cluster_count > 1)
        {
            row->pr_nonsp = gaps[0];
            row->pr_space = gaps[1];
        }
        else
        {
            row->pr_nonsp = lower;
            row->pr_space = gaps[0];
        }
    }
    else
    {
        row->pr_nonsp = gaps[gap_index - 1];

        while (gap_index < cluster_count && gaps[gap_index] < upper)
        {
            gap_index++;
        }

        if (gap_index == cluster_count)
        {
            if (testing_on)
            {
                tprintf ("No clusters above nonspace threshold!!\n");
            }
            row->pr_space = lower * textord_spacesize_ratioprop;
        }
        else
        {
            row->pr_space = gaps[gap_index];
        }
    }

    //Now try to find the fixed pitch space and non-space.
    upper = row->xheight * words_default_fixed_space;

    for (gap_index = 0; gap_index < cluster_count && gaps[gap_index] < upper; gap_index++);
    if (gap_index == 0)
    {
        if (testing_on)
        {
            tprintf ("No clusters below space threshold!!\n");
        }
        row->fp_nonsp = upper;
        row->fp_space = gaps[0];
    }
    else
    {
        row->fp_nonsp = gaps[gap_index - 1];
        if (gap_index == cluster_count)
        {
            if (testing_on)
            {
                tprintf ("No clusters above space threshold!!\n");
            }

            row->fp_space = row->xheight;
        }
        else
        {
            row->fp_space = gaps[gap_index];
        }
    }

    if (testing_on)
    {
        tprintf("Initial estimates:pr_nonsp=%g, pr_space=%g, fp_nonsp=%g, fp_space=%g\n", row->pr_nonsp, row->pr_space, row->fp_nonsp, row->fp_space);
    }

    return TRUE;                   //computed some stats
}


/**********************************************************************
 * find_row_pitch
 *
 * Check to see if this row could be fixed pitch using the given spacings.
 * Blobs with gaps smaller than the lower threshold are assumed to be one.
 * The larger threshold is the word gap threshold.
 **********************************************************************/

BOOL8 find_row_pitch(//find lines
                     TO_ROW *row,        //row to do
                     inT32 maxwidth,     //max permitted space
                     inT32 dm_gap,       //ignorable gaps
                     TO_BLOCK *block,    //block of row
                     inT32 block_index,  //block_number
                     inT32 row_index,    //number of row
                     BOOL8 testing_on    //correct orientation
                     )
{
    BOOL8 used_dm_model;           //looks lik dot matrix
    float min_space;               //estimate threshold
    float non_space;               //gap size
    float gap_iqr;                 //interquartile range
    float pitch_iqr;
    float dm_gap_iqr;              //interquartile range
    float dm_pitch_iqr;
    float dm_pitch;                //pitch with dm on
    float pitch;                   //revised estimate
    float initial_pitch;           //guess at pitch
    STATS gap_stats (0, maxwidth);

    //centre-centre
    STATS pitch_stats (0, maxwidth);

    row->fixed_pitch = 0.0f;
    initial_pitch = row->fp_space;
    if (initial_pitch > row->xheight * (1 + words_default_fixed_limit))
    {
        initial_pitch = row->xheight;//keep pitch decent
    }

    non_space = row->fp_nonsp;
    if (non_space > initial_pitch)
    {
        non_space = initial_pitch;
    }

    min_space = (initial_pitch + non_space) / 2;

    if (!count_pitch_stats (row, &gap_stats, &pitch_stats, initial_pitch, min_space, TRUE, FALSE, dm_gap))
    {
        dm_gap_iqr = 0.0001;
        dm_pitch_iqr = maxwidth * 2.0f;
        dm_pitch = initial_pitch;
    }
    else
    {
        dm_gap_iqr = gap_stats.ile (0.75) - gap_stats.ile (0.25);
        dm_pitch_iqr = pitch_stats.ile (0.75) - pitch_stats.ile (0.25);
        dm_pitch = pitch_stats.ile (0.5);
    }

    gap_stats.clear ();
    pitch_stats.clear ();

    if (!count_pitch_stats (row, &gap_stats, &pitch_stats, initial_pitch, min_space, TRUE, FALSE, 0))
    {
        gap_iqr = 0.0001;
        pitch_iqr = maxwidth * 3.0f;
    }
    else
    {
        gap_iqr = gap_stats.ile (0.75) - gap_stats.ile (0.25);
        pitch_iqr = pitch_stats.ile (0.75) - pitch_stats.ile (0.25);

        if (testing_on)
        {
            tprintf("First fp iteration:initial_pitch=%g, gap_iqr=%g, pitch_iqr=%g, pitch=%g\n", initial_pitch, gap_iqr, pitch_iqr, pitch_stats.ile (0.5));
        }

        initial_pitch = pitch_stats.ile (0.5);
        if (min_space > initial_pitch && count_pitch_stats (row, &gap_stats, &pitch_stats, initial_pitch, initial_pitch, TRUE, FALSE, 0))
        {
            min_space = initial_pitch;
            gap_iqr = gap_stats.ile (0.75) - gap_stats.ile (0.25);
            pitch_iqr = pitch_stats.ile (0.75) - pitch_stats.ile (0.25);

            if (testing_on)
            {
                tprintf("Revised fp iteration:initial_pitch=%g, gap_iqr=%g, pitch_iqr=%g, pitch=%g\n", initial_pitch, gap_iqr, pitch_iqr, pitch_stats.ile (0.5));
            }

            initial_pitch = pitch_stats.ile (0.5);
        }
    }

    if (textord_debug_pitch_metric)
    {
        tprintf("Blk=%d:Row=%d:%c:p_iqr=%g:g_iqr=%g:dm_p_iqr=%g:dm_g_iqr=%g:%c:",
                block_index, row_index, 'X',
                pitch_iqr, gap_iqr, dm_pitch_iqr, dm_gap_iqr,
                pitch_iqr > maxwidth && dm_pitch_iqr > maxwidth ? 'D' :
                                                                  (pitch_iqr * dm_gap_iqr <= dm_pitch_iqr * gap_iqr ? 'S' : 'M'));
    }

    if (pitch_iqr > maxwidth && dm_pitch_iqr > maxwidth)
    {
        row->pitch_decision = PITCH_DUNNO;

        if (textord_debug_pitch_metric)
        {
            tprintf ("\n");
        }

        return FALSE;                //insufficient data
    }

    if (pitch_iqr * dm_gap_iqr <= dm_pitch_iqr * gap_iqr)
    {
        if (testing_on)
        {
            tprintf("Choosing non dm version:pitch_iqr=%g, gap_iqr=%g, dm_pitch_iqr=%g, dm_gap_iqr=%g\n", pitch_iqr, gap_iqr, dm_pitch_iqr, dm_gap_iqr);
        }

        gap_iqr = gap_stats.ile (0.75) - gap_stats.ile (0.25);
        pitch_iqr = pitch_stats.ile (0.75) - pitch_stats.ile (0.25);
        pitch = pitch_stats.ile (0.5);
        used_dm_model = FALSE;
    }
    else
    {
        if (testing_on)
        {
            tprintf("Choosing dm version:pitch_iqr=%g, gap_iqr=%g, dm_pitch_iqr=%g, dm_gap_iqr=%g\n", pitch_iqr, gap_iqr, dm_pitch_iqr, dm_gap_iqr);
        }

        gap_iqr = dm_gap_iqr;
        pitch_iqr = dm_pitch_iqr;
        pitch = dm_pitch;
        used_dm_model = TRUE;
    }

    if (textord_debug_pitch_metric)
    {
        tprintf("rev_p_iqr=%g:rev_g_iqr=%g:pitch=%g:", pitch_iqr, gap_iqr, pitch);
        tprintf("p_iqr/g=%g:p_iqr/x=%g:iqr_res=%c:",
                pitch_iqr / gap_iqr, pitch_iqr / block->xheight,
                pitch_iqr < gap_iqr * textord_fpiqr_ratio
                && pitch_iqr < block->xheight * textord_max_pitch_iqr
                && pitch < block->xheight * textord_words_default_maxspace
                ? 'F' : 'P');
    }

    if (pitch_iqr < gap_iqr * textord_fpiqr_ratio && pitch_iqr < block->xheight * textord_max_pitch_iqr && pitch < block->xheight * textord_words_default_maxspace)
    {
        row->pitch_decision = PITCH_MAYBE_FIXED;
    }
    else
    {
        row->pitch_decision = PITCH_MAYBE_PROP;
    }

    row->fixed_pitch = pitch;
    row->kern_size = gap_stats.ile (0.5);
    row->min_space = (inT32) (row->fixed_pitch + non_space) / 2;

    if (row->min_space > row->fixed_pitch)
    {
        row->min_space = (inT32) row->fixed_pitch;
    }

    row->max_nonspace = row->min_space;
    row->space_size = row->fixed_pitch;
    row->space_threshold = (row->max_nonspace + row->min_space) / 2;
    row->used_dm_model = used_dm_model;

    return TRUE;
}


/**********************************************************************
 * fixed_pitch_row
 *
 * Check to see if this row could be fixed pitch using the given spacings.
 * Blobs with gaps smaller than the lower threshold are assumed to be one.
 * The larger threshold is the word gap threshold.
 **********************************************************************/

BOOL8 fixed_pitch_row(//find lines
                      TO_ROW *row,       //row to do
                      inT32 block_index  //block_number
                      )
{
    const char *res_string;        //pitch result
    inT16 mid_cuts;                //no of cheap cuts
    float non_space;               //gap size
    float pitch_sd;                //error on pitch
    float sp_sd;                   //space sd

    non_space = row->fp_nonsp;
    if (non_space > row->fixed_pitch)
    {
        non_space = row->fixed_pitch;
    }

    if (textord_all_prop)
    {
        // Set the decision to definitely proportional.
        pitch_sd = textord_words_def_prop * row->fixed_pitch;
        row->pitch_decision = PITCH_DEF_PROP;
    }
    else
    {
        pitch_sd = tune_row_pitch (row, &row->projection, row->projection_left,
                                   row->projection_right,
                                   (row->fixed_pitch + non_space * 3) / 4,
                                   row->fixed_pitch, sp_sd, mid_cuts,
                                   &row->char_cells,
                                   block_index == textord_debug_block);

        if (pitch_sd < textord_words_pitchsd_threshold * row->fixed_pitch &&
                ((pitsync_linear_version & 3) < 3 || ((pitsync_linear_version & 3) >= 3 && (row->used_dm_model || sp_sd > 20 || (pitch_sd == 0 && sp_sd > 10)))))
        {
            if (pitch_sd < textord_words_def_fixed * row->fixed_pitch && !row->all_caps && ((pitsync_linear_version & 3) < 3 || sp_sd > 20))
            {
                row->pitch_decision = PITCH_DEF_FIXED;
            }
            else
            {
                row->pitch_decision = PITCH_MAYBE_FIXED;
            }
        }
        else if ((pitsync_linear_version & 3) < 3 || sp_sd > 20 || mid_cuts > 0 || pitch_sd >= textord_words_pitchsd_threshold * row->fixed_pitch)
        {
            if (pitch_sd < textord_words_def_prop * row->fixed_pitch)
            {
                row->pitch_decision = PITCH_MAYBE_PROP;
            }
            else
            {
                row->pitch_decision = PITCH_DEF_PROP;
            }
        }
        else
        {
            row->pitch_decision = PITCH_DUNNO;
        }
    }

    if (textord_debug_pitch_metric)
    {
        res_string = "??";

        switch (row->pitch_decision)
        {
        case PITCH_DEF_PROP:
            res_string = "DP";
            break;
        case PITCH_MAYBE_PROP:
            res_string = "MP";
            break;
        case PITCH_DEF_FIXED:
            res_string = "DF";
            break;
        case PITCH_MAYBE_FIXED:
            res_string = "MF";
        default:
            res_string = "??";
        }

        tprintf (":sd/p=%g:occ=%g:init_res=%s\n", pitch_sd / row->fixed_pitch, sp_sd, res_string);
    }

    return TRUE;
}


/**********************************************************************
 * count_pitch_stats
 *
 * Count up the gap and pitch stats on the block to see if it is fixed pitch.
 * Blobs with gaps smaller than the lower threshold are assumed to be one.
 * The larger threshold is the word gap threshold.
 * The return value indicates whether there were any decent values to use.
 **********************************************************************/

BOOL8 count_pitch_stats(//find lines
                        TO_ROW *row,           //row to do
                        STATS *gap_stats,      //blob gaps
                        STATS *pitch_stats,    //centre-centre stats
                        float initial_pitch,   //guess at pitch
                        float min_space,       //estimate space size
                        BOOL8 ignore_outsize,  //discard big objects
                        BOOL8 split_outsize,   //split big objects
                        inT32 dm_gap           //ignorable gaps
                        )
{
    BOOL8 prev_valid;              //not word broken
    BLOBNBOX *blob;                //current blob

    //blobs
    BLOBNBOX_IT blob_it = row->blob_list ();
    inT32 prev_right;              //end of prev blob
    inT32 prev_centre;             //centre of previous blob
    inT32 x_centre;                //centre of this blob
    inT32 blob_width;              //width of blob
    inT32 width_units;             //no of widths in blob
    float width;                   //blob width
    TBOX blob_box;                  //bounding box
    TBOX joined_box;                //of super blob

    gap_stats->clear ();
    pitch_stats->clear ();
    if (blob_it.empty ())
    {
        return FALSE;
    }

    prev_valid = FALSE;
    prev_centre = 0;
    prev_right = 0;                //stop complier warning
    joined_box = blob_it.data ()->bounding_box ();

    do
    {
        blob_it.forward ();
        blob = blob_it.data ();

        if (!blob->joined_to_prev ())
        {
            blob_box = blob->bounding_box ();
            if ((blob_box.left () - joined_box.right () < dm_gap && !blob_it.at_first ()) || (blob->cblob () == NULL && blob->blob () == NULL))
            {
                joined_box += blob_box;  //merge blobs
            }
            else
            {
                blob_width = joined_box.width ();

                if (split_outsize)
                {
                    width_units = (inT32) floor ((float) blob_width / initial_pitch + 0.5);

                    if (width_units < 1)
                    {
                        width_units = 1;
                    }

                    width_units--;
                }
                else if (ignore_outsize)
                {
                    width = (float) blob_width / initial_pitch;
                    width_units = width < 1 + words_default_fixed_limit && width > 1 - words_default_fixed_limit ? 0 : -1;
                }
                else
                {
                    width_units = 0;       //everything in
                }

                x_centre = (inT32) (joined_box.left() + (blob_width - width_units * initial_pitch) / 2);
                if (prev_valid && width_units >= 0)
                {
                    gap_stats->add (joined_box.left () - prev_right, 1);
                    pitch_stats->add (x_centre - prev_centre, 1);
                }

                prev_centre = (inT32) (x_centre + width_units * initial_pitch);
                prev_right = joined_box.right ();
                prev_valid = blob_box.left () - joined_box.right () < min_space;
                prev_valid = prev_valid && width_units >= 0;
                joined_box = blob_box;
            }
        }
    }
    while (!blob_it.at_first ());

    return gap_stats->get_total () >= 3;
}


/**********************************************************************
 * tune_row_pitch
 *
 * Use a dp algorithm to fit the character cells and return the sd of
 * the cell size over the row.
 **********************************************************************/

float tune_row_pitch(//find fp cells
                     TO_ROW *row,                 //row to do
                     STATS *projection,           //vertical projection
                     inT16 projection_left,       //edge of projection
                     inT16 projection_right,      //edge of projection
                     float space_size,            //size of blank
                     float &initial_pitch,        //guess at pitch
                     float &best_sp_sd,           //space sd
                     inT16 &best_mid_cuts,        //no of cheap cuts
                     ICOORDELT_LIST *best_cells,  //row cells
                     BOOL8 testing_on             //inidividual words
                     )
{
    int pitch_delta;               //offset pitch
    inT16 mid_cuts;                //cheap cuts
    float pitch_sd;                //current sd
    float best_sd;                 //best result
    float best_pitch;              //pitch for best result
    float initial_sd;              //starting error
    float sp_sd;                   //space sd
    ICOORDELT_LIST test_cells;     //row cells
    ICOORDELT_IT best_it;          //start of best list

    if (textord_fast_pitch_test)
    {                                                                                                                    //space sd
        return tune_row_pitch2(row, projection, projection_left, projection_right, space_size, initial_pitch, best_sp_sd, best_mid_cuts, best_cells, testing_on);
    }

    if (textord_disable_pitch_test)
    {
        best_sp_sd = initial_pitch;

        return initial_pitch;
    }

    initial_sd = compute_pitch_sd(row, projection, projection_left, projection_right, space_size, initial_pitch, best_sp_sd, best_mid_cuts, best_cells, testing_on);

    best_sd = initial_sd;
    best_pitch = initial_pitch;

    if (testing_on)
    {
        tprintf ("tune_row_pitch:start pitch=%g, sd=%g\n", best_pitch, best_sd);
    }

    for (pitch_delta = 1; pitch_delta <= textord_pitch_range; pitch_delta++)
    {
        pitch_sd = compute_pitch_sd(row, projection, projection_left, projection_right,
                                    space_size, initial_pitch + pitch_delta, sp_sd, mid_cuts, &test_cells, testing_on);
        if (testing_on)
        {
            tprintf ("testing pitch at %g, sd=%g\n", initial_pitch + pitch_delta, pitch_sd);
        }

        if (pitch_sd < best_sd)
        {
            best_sd = pitch_sd;
            best_mid_cuts = mid_cuts;
            best_sp_sd = sp_sd;
            best_pitch = initial_pitch + pitch_delta;
            best_cells->clear ();
            best_it.set_to_list (best_cells);
            best_it.add_list_after (&test_cells);
        }
        else
        {
            test_cells.clear ();
        }

        if (pitch_sd > initial_sd)
        {
            break;                     //getting worse
        }
    }

    for (pitch_delta = 1; pitch_delta <= textord_pitch_range; pitch_delta++)
    {
        pitch_sd = compute_pitch_sd (row, projection, projection_left, projection_right,
                                     space_size, initial_pitch - pitch_delta, sp_sd, mid_cuts, &test_cells, testing_on);
        if (testing_on)
        {
            tprintf ("testing pitch at %g, sd=%g\n", initial_pitch - pitch_delta, pitch_sd);
        }

        if (pitch_sd < best_sd)
        {
            best_sd = pitch_sd;
            best_mid_cuts = mid_cuts;
            best_sp_sd = sp_sd;
            best_pitch = initial_pitch - pitch_delta;
            best_cells->clear ();
            best_it.set_to_list (best_cells);
            best_it.add_list_after (&test_cells);
        }
        else
        {
            test_cells.clear ();
        }

        if (pitch_sd > initial_sd)
        {
            break;
        }
    }
    initial_pitch = best_pitch;

    if (textord_debug_pitch_metric)
    {
        print_pitch_sd(row, projection, projection_left, projection_right, space_size, best_pitch);
    }

    return best_sd;
}


/**********************************************************************
 * tune_row_pitch
 *
 * Use a dp algorithm to fit the character cells and return the sd of
 * the cell size over the row.
 **********************************************************************/

float tune_row_pitch2(//find fp cells
                      TO_ROW *row,                 //row to do
                      STATS *projection,           //vertical projection
                      inT16 projection_left,       //edge of projection
                      inT16 projection_right,      //edge of projection
                      float space_size,            //size of blank
                      float &initial_pitch,        //guess at pitch
                      float &best_sp_sd,           //space sd
                      inT16 &best_mid_cuts,        //no of cheap cuts
                      ICOORDELT_LIST *best_cells,  //row cells
                      BOOL8 testing_on             //inidividual words
                      )
{
    int pitch_delta;               //offset pitch
    inT16 pixel;                   //pixel coord
    inT16 best_pixel;              //pixel coord
    inT16 best_delta;              //best pitch
    inT16 best_pitch;              //best pitch
    inT16 start;                   //of good range
    inT16 end;                     //of good range
    inT32 best_count;              //lowest sum
    float best_sd;                 //best result
    STATS *sum_proj;               //summed projection

    best_sp_sd = initial_pitch;

    if (textord_disable_pitch_test)
    {
        return initial_pitch;
    }

    sum_proj = new STATS[textord_pitch_range * 2 + 1];
    if (sum_proj == NULL)
    {
        return initial_pitch;
    }

    best_pitch = (inT32) initial_pitch;

    for (pitch_delta = -textord_pitch_range; pitch_delta <= textord_pitch_range; pitch_delta++)
    {
        sum_proj[textord_pitch_range + pitch_delta].set_range(0, best_pitch +pitch_delta + 1);
    }

    for (pixel = projection_left; pixel <= projection_right; pixel++)
    {
        for (pitch_delta = -textord_pitch_range; pitch_delta <= textord_pitch_range; pitch_delta++)
        {
            sum_proj[textord_pitch_range + pitch_delta].add ((pixel - projection_left) % (best_pitch + pitch_delta), projection->pile_count (pixel));
        }
    }

    best_count = sum_proj[textord_pitch_range].pile_count (0);
    best_delta = 0;
    best_pixel = 0;
    for (pitch_delta = -textord_pitch_range; pitch_delta <= textord_pitch_range; pitch_delta++)
    {
        for (pixel = 0; pixel < best_pitch + pitch_delta; pixel++)
        {
            if (sum_proj[textord_pitch_range + pitch_delta].pile_count (pixel) < best_count)
            {
                best_count = sum_proj[textord_pitch_range + pitch_delta].pile_count (pixel);
                best_delta = pitch_delta;
                best_pixel = pixel;
            }
        }
    }

    if (testing_on)
    {
        tprintf ("tune_row_pitch:start pitch=%g, best_delta=%d, count=%d\n", initial_pitch, best_delta, best_count);
    }

    best_pitch += best_delta;
    initial_pitch = best_pitch;
    best_count++;
    best_count += best_count;

    for (start = best_pixel - 2; start > best_pixel - best_pitch && sum_proj[textord_pitch_range + best_delta].pile_count (start % best_pitch) <= best_count; start--);

    for (end = best_pixel + 2; end < best_pixel + best_pitch && sum_proj[textord_pitch_range + best_delta].pile_count (end % best_pitch) <= best_count; end++);

    best_sd = compute_pitch_sd(row,
                               projection,
                               projection_left,
                               projection_right,
                               space_size,
                               initial_pitch,
                               best_sp_sd,
                               best_mid_cuts,
                               best_cells,
                               testing_on,
                               start,
                               end);
    if (testing_on)
    {
        tprintf ("tune_row_pitch:output pitch=%g, sd=%g\n", initial_pitch, best_sd);
    }

    if (textord_debug_pitch_metric)
    {
        print_pitch_sd(row, projection, projection_left, projection_right, space_size, initial_pitch);
    }

    delete[]sum_proj;

    return best_sd;
}


/**********************************************************************
 * compute_pitch_sd
 *
 * Use a dp algorithm to fit the character cells and return the sd of
 * the cell size over the row.
 **********************************************************************/

float compute_pitch_sd(//find fp cells
                       TO_ROW *row,                //row to do
                       STATS *projection,          //vertical projection
                       inT16 projection_left,      //edge
                       inT16 projection_right,     //edge
                       float space_size,           //size of blank
                       float initial_pitch,        //guess at pitch
                       float &sp_sd,               //space sd
                       inT16 &mid_cuts,            //no of free cuts
                       ICOORDELT_LIST *row_cells,  //list of chop pts
                       BOOL8 testing_on,           //inidividual words
                       inT16 start,                //start of good range
                       inT16 end                   //end of good range
                       )
{
    inT16 occupation;              //no of cells in word.

    //blobs
    BLOBNBOX_IT blob_it = row->blob_list ();
    BLOBNBOX_IT start_it;          //start of word
    BLOBNBOX_IT plot_it;           //for plotting
    inT16 blob_count;              //no of blobs
    TBOX blob_box;                  //bounding box
    TBOX prev_box;                  //of super blob
    inT32 prev_right;              //of word sync
    int scale_factor;              //on scores for big words
    inT32 sp_count;                //spaces
    FPSEGPT_LIST seg_list;         //char cells
    FPSEGPT_IT seg_it;             //iterator
    inT16 segpos;                  //position of segment
    inT16 cellpos;                 //previous cell boundary

    //iterator
    ICOORDELT_IT cell_it = row_cells;
    ICOORDELT *cell;               //new cell
    double sqsum;                  //sum of squares
    double spsum;                  //of spaces
    double sp_var;                 //space error
    double word_sync;              //result for word
    inT32 total_count;             //total blobs

    if ((pitsync_linear_version & 3) > 1)
    {
        word_sync = compute_pitch_sd2(row, projection, projection_left, projection_right,
                                      initial_pitch, occupation, mid_cuts, row_cells, testing_on, start, end);
        sp_sd = occupation;

        return word_sync;
    }

    mid_cuts = 0;
    cellpos = 0;
    total_count = 0;
    sqsum = 0;
    sp_count = 0;
    spsum = 0;
    prev_right = -1;

    if (blob_it.empty())
    {
        return space_size * 10;
    }

    #ifndef GRAPHICS_DISABLED
    if (testing_on && to_win != NULL)
    {
        blob_box = blob_it.data ()->bounding_box ();
        projection->plot (to_win, projection_left, row->intercept (), 1.0f, -1.0f, ScrollView::CORAL);
    }

    #endif
    start_it = blob_it;
    blob_count = 0;
    blob_box = box_next (&blob_it);//first blob
    blob_it.mark_cycle_pt ();

    do
    {
        for (; blob_count > 0; blob_count--)
        {
            box_next(&start_it);
        }

        do
        {
            prev_box = blob_box;
            blob_count++;
            blob_box = box_next (&blob_it);
        }
        while (!blob_it.cycled_list() && blob_box.left() - prev_box.right() < space_size);

        plot_it = start_it;

        if (pitsync_linear_version & 3)
        {
            word_sync =
                    check_pitch_sync2 (&start_it, blob_count, (inT16) initial_pitch, 2,
                                       projection, projection_left, projection_right,
                                       row->xheight * textord_projection_scale,
                                       occupation, &seg_list, start, end);
        }
        else
        {
            word_sync = check_pitch_sync(&start_it, blob_count, (inT16) initial_pitch, 2, projection, &seg_list);
        }

        if (testing_on)
        {
            tprintf("Word ending at (%d,%d), len=%d, sync rating=%g, ", prev_box.right (), prev_box.top (), seg_list.length () - 1, word_sync);

            seg_it.set_to_list (&seg_list);
            for (seg_it.mark_cycle_pt (); !seg_it.cycled_list (); seg_it.forward ())
            {
                if (seg_it.data ()->faked)
                {
                    tprintf ("(F)");
                }

                tprintf ("%d, ", seg_it.data ()->position ());
            }
            tprintf ("\n");
        }
        #ifndef GRAPHICS_DISABLED
        if (textord_show_fixed_cuts && blob_count > 0 && to_win != NULL)
        {
            plot_fp_cells2(to_win, ScrollView::GOLDENROD, row, &seg_list);
        }
        #endif
        seg_it.set_to_list (&seg_list);

        if (prev_right >= 0)
        {
            sp_var = seg_it.data ()->position () - prev_right;
            sp_var -= floor (sp_var / initial_pitch + 0.5) * initial_pitch;
            sp_var *= sp_var;
            spsum += sp_var;
            sp_count++;
        }

        for (seg_it.mark_cycle_pt (); !seg_it.cycled_list (); seg_it.forward ())
        {
            segpos = seg_it.data ()->position ();
            if (cell_it.empty () || segpos > cellpos + initial_pitch / 2)
            {
                //big gap
                while (!cell_it.empty () && segpos > cellpos + initial_pitch * 3 / 2)
                {
                    cell = new ICOORDELT (cellpos + (inT16) initial_pitch, 0);
                    cell_it.add_after_then_move (cell);
                    cellpos += (inT16) initial_pitch;
                }

                //make new one
                cell = new ICOORDELT (segpos, 0);
                cell_it.add_after_then_move (cell);
                cellpos = segpos;
            }
            else if (segpos > cellpos - initial_pitch / 2)
            {
                cell = cell_it.data ();

                //average positions
                cell->set_x ((cellpos + segpos) / 2);
                cellpos = cell->x ();
            }
        }

        seg_it.move_to_last ();
        prev_right = seg_it.data ()->position ();

        if (textord_pitch_scalebigwords)
        {
            scale_factor = (seg_list.length () - 2) / 2;
            if (scale_factor < 1)
            {
                scale_factor = 1;
            }
        }
        else
        {
            scale_factor = 1;
        }

        sqsum += word_sync * scale_factor;
        total_count += (seg_list.length () - 1) * scale_factor;
        seg_list.clear ();
    }
    while (!blob_it.cycled_list ());

    sp_sd = sp_count > 0 ? sqrt (spsum / sp_count) : 0;

    return total_count > 0 ? sqrt (sqsum / total_count) : space_size * 10;
}


/**********************************************************************
 * compute_pitch_sd2
 *
 * Use a dp algorithm to fit the character cells and return the sd of
 * the cell size over the row.
 **********************************************************************/

float compute_pitch_sd2(//find fp cells
                        TO_ROW *row,                //row to do
                        STATS *projection,          //vertical projection
                        inT16 projection_left,      //edge
                        inT16 projection_right,     //edge
                        float initial_pitch,        //guess at pitch
                        inT16 &occupation,          //no of occupied cells
                        inT16 &mid_cuts,            //no of free cuts
                        ICOORDELT_LIST *row_cells,  //list of chop pts
                        BOOL8 testing_on,           //inidividual words
                        inT16 start,                //start of good range
                        inT16 end                   //end of good range
                        )
{
    //blobs
    BLOBNBOX_IT blob_it = row->blob_list ();
    BLOBNBOX_IT plot_it;
    inT16 blob_count;              //no of blobs
    TBOX blob_box;                  //bounding box
    FPSEGPT_LIST seg_list;         //char cells
    FPSEGPT_IT seg_it;             //iterator
    inT16 segpos;                  //position of segment

    //iterator
    ICOORDELT_IT cell_it = row_cells;
    ICOORDELT *cell;               //new cell
    double word_sync;              //result for word

    mid_cuts = 0;
    if (blob_it.empty ())
    {
        occupation = 0;

        return initial_pitch * 10;
    }
    #ifndef GRAPHICS_DISABLED
    if (testing_on && to_win != NULL)
    {
        projection->plot (to_win, projection_left, row->intercept (), 1.0f, -1.0f, ScrollView::CORAL);
    }
    #endif
    blob_count = 0;
    blob_it.mark_cycle_pt ();
    do
    {
        //first blob
        blob_box = box_next (&blob_it);
        blob_count++;
    }
    while (!blob_it.cycled_list ());

    plot_it = blob_it;
    word_sync = check_pitch_sync2(&blob_it, blob_count, (inT16) initial_pitch, 2, projection,
                                  projection_left, projection_right, row->xheight * textord_projection_scale, occupation, &seg_list, start, end);

    if (testing_on)
    {
        tprintf ("Row ending at (%d,%d), len=%d, sync rating=%g, ", blob_box.right (), blob_box.top (), seg_list.length () - 1, word_sync);
        seg_it.set_to_list (&seg_list);

        for (seg_it.mark_cycle_pt (); !seg_it.cycled_list (); seg_it.forward ())
        {
            if (seg_it.data ()->faked)
            {
                tprintf ("(F)");
            }

            tprintf ("%d, ", seg_it.data ()->position ());
        }
        tprintf ("\n");
    }

    #ifndef GRAPHICS_DISABLED
    if (textord_show_fixed_cuts && blob_count > 0 && to_win != NULL)
    {
        plot_fp_cells2(to_win, ScrollView::GOLDENROD, row, &seg_list);
    }
    #endif
    seg_it.set_to_list (&seg_list);
    for (seg_it.mark_cycle_pt (); !seg_it.cycled_list (); seg_it.forward ())
    {
        segpos = seg_it.data ()->position ();

        //make new one
        cell = new ICOORDELT (segpos, 0);
        cell_it.add_after_then_move (cell);

        if (seg_it.at_last ())
        {
            mid_cuts = seg_it.data ()->cheap_cuts ();
        }
    }
    seg_list.clear();

    return occupation > 0 ? sqrt (word_sync / occupation) : initial_pitch * 10;
}


/**********************************************************************
 * print_pitch_sd
 *
 * Use a dp algorithm to fit the character cells and return the sd of
 * the cell size over the row.
 **********************************************************************/

void print_pitch_sd(//find fp cells
                    TO_ROW *row,            //row to do
                    STATS *projection,      //vertical projection
                    inT16 projection_left,  //edges //size of blank
                    inT16 projection_right,
                    float space_size,
                    float initial_pitch     //guess at pitch
                    )
{
    const char *res2;              //pitch result
    inT16 occupation;              //used cells
    float sp_sd;                   //space sd

    //blobs
    BLOBNBOX_IT blob_it = row->blob_list ();
    BLOBNBOX_IT start_it;          //start of word
    BLOBNBOX_IT row_start;         //start of row
    inT16 blob_count;              //no of blobs
    inT16 total_blob_count;        //total blobs in line
    TBOX blob_box;                  //bounding box
    TBOX prev_box;                  //of super blob
    inT32 prev_right;              //of word sync
    int scale_factor;              //on scores for big words
    inT32 sp_count;                //spaces
    FPSEGPT_LIST seg_list;         //char cells
    FPSEGPT_IT seg_it;             //iterator
    double sqsum;                  //sum of squares
    double spsum;                  //of spaces
    double sp_var;                 //space error
    double word_sync;              //result for word
    double total_count;            //total cuts

    if (blob_it.empty ()) return;

    row_start = blob_it;
    total_blob_count = 0;

    total_count = 0;
    sqsum = 0;
    sp_count = 0;
    spsum = 0;
    prev_right = -1;
    blob_it = row_start;
    start_it = blob_it;
    blob_count = 0;
    blob_box = box_next (&blob_it);//first blob
    blob_it.mark_cycle_pt ();

    do
    {
        for (; blob_count > 0; blob_count--)
        {
            box_next(&start_it);
        }

        do
        {
            prev_box = blob_box;
            blob_count++;
            blob_box = box_next (&blob_it);
        }
        while (!blob_it.cycled_list () && blob_box.left () - prev_box.right () < space_size);

        word_sync = check_pitch_sync2(&start_it, blob_count, (inT16) initial_pitch, 2, projection,
                                      projection_left, projection_right, row->xheight * textord_projection_scale, occupation, &seg_list, 0, 0);

        total_blob_count += blob_count;
        seg_it.set_to_list (&seg_list);

        if (prev_right >= 0)
        {
            sp_var = seg_it.data ()->position () - prev_right;
            sp_var -= floor (sp_var / initial_pitch + 0.5) * initial_pitch;
            sp_var *= sp_var;
            spsum += sp_var;
            sp_count++;
        }

        seg_it.move_to_last ();
        prev_right = seg_it.data ()->position ();

        if (textord_pitch_scalebigwords)
        {
            scale_factor = (seg_list.length () - 2) / 2;

            if (scale_factor < 1)
            {
                scale_factor = 1;
            }
        }
        else
        {
            scale_factor = 1;
        }

        sqsum += word_sync * scale_factor;
        total_count += (seg_list.length () - 1) * scale_factor;
        seg_list.clear ();
    }
    while (!blob_it.cycled_list ());

    sp_sd = sp_count > 0 ? sqrt (spsum / sp_count) : 0;
    word_sync = total_count > 0 ? sqrt (sqsum / total_count) : space_size * 10;

    tprintf("new_sd=%g:sd/p=%g:new_sp_sd=%g:res=%c:", word_sync, word_sync / initial_pitch, sp_sd,
            word_sync < textord_words_pitchsd_threshold * initial_pitch ? 'F' : 'P');

    start_it = row_start;
    blob_it = row_start;

    word_sync = check_pitch_sync2(&blob_it, total_blob_count, (inT16) initial_pitch, 2, projection, projection_left,
                                  projection_right, row->xheight * textord_projection_scale, occupation, &seg_list, 0, 0);

    if (occupation > 1)
    {
        word_sync /= occupation;
    }
    word_sync = sqrt (word_sync);

#ifndef GRAPHICS_DISABLED
    if (textord_show_row_cuts && to_win != NULL)
    {
        plot_fp_cells2(to_win, ScrollView::CORAL, row, &seg_list);
    }
#endif
    seg_list.clear ();
    if (word_sync < textord_words_pitchsd_threshold * initial_pitch)
    {
        if (word_sync < textord_words_def_fixed * initial_pitch && !row->all_caps)
        {
            res2 = "DF";
        }
        else
        {
            res2 = "MF";
        }
    }
    else
    {
        res2 = word_sync < textord_words_def_prop * initial_pitch ? "MP" : "DP";
    }

    tprintf
            ("row_sd=%g:sd/p=%g:res=%c:N=%d:res2=%s,init pitch=%g, row_pitch=%g, all_caps=%d\n",
             word_sync, word_sync / initial_pitch,
             word_sync < textord_words_pitchsd_threshold * initial_pitch ? 'F' : 'P',
             occupation, res2, initial_pitch, row->fixed_pitch, row->all_caps);
}


/**********************************************************************
 * sort_floats
 *
 * qsort function to sort 2 floats.
 **********************************************************************/

int sort_floats2(                   //qsort function
                                    const void *arg1,  //ptrs to floats
                                    const void *arg2)
{
    float diff;                    //difference

    diff = *((float *) arg1) - *((float *) arg2);

    if (diff > 0)
    {
        return 1;
    }
    else if (diff < 0)
    {
        return -1;
    }
    else
    {
        return 0;
    }
}


/**********************************************************************
 * find_repeated_chars
 *
 * Find 4 or more adjacent chars which are the same and put them
 * into words in advance of fixed pitch checking and word generation.
 **********************************************************************/
void find_repeated_chars(//search for equal chars
                         TO_BLOCK *block,  //block to search
                         BOOL8 testing_on,  //dbug mode
                         Tesseract* tess
                         )
{
    TO_ROW *row;
    BLOBNBOX_IT box_it;
    BLOBNBOX_IT search_it;         // forward search
    WERD_IT word_it;               // new words
    WERD *word;                    // new word
    TBOX word_box;                 // for plotting
    int blobcount, repeated_set;

    TO_ROW_IT row_it = block->get_rows();
    if (row_it.empty()) return;  // empty block

    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
    {
        row = row_it.data();
        box_it.set_to_list(row->blob_list());

        if (box_it.empty())  continue; // no blobs in this row

        if (!row->rep_chars_marked())
        {
            mark_repeated_chars(row, block->xheight, tess);
        }

        if (row->num_repeated_sets() == 0) continue;  // nothing to do for this row
        word_it.set_to_list(&row->rep_words);

        do
        {
            if (box_it.data()->repeated_set() != 0 && !box_it.data()->joined_to_prev())
            {
                blobcount = 1;
                repeated_set = box_it.data()->repeated_set();
                search_it = box_it;
                search_it.forward();

                while (!search_it.at_first() && search_it.data()->repeated_set() == repeated_set)
                {
                    blobcount++;
                    search_it.forward();
                }

                // After the call to make_real_word() all the blobs from this
                // repeated set will be removed from the blob list. box_it will be
                // set to point to the blob after the end of the extracted sequence.
                word = make_real_word(&box_it, blobcount, box_it.at_first(), false, false, 1);
                #ifndef GRAPHICS_DISABLED
                if (testing_on)
                {
                    word_box = word->bounding_box();
                    tprintf("Found repeated word of %d blobs from (%d,%d)->(%d,%d)\n", blobcount, word_box.left(), word_box.bottom(), word_box.right(), word_box.top());

                    //perimeter_color_index(to_win, RED);
                    to_win->Pen(255,0,0);

                    //interior_style(to_win, INT_HOLLOW, TRUE);
                    to_win->Rectangle(word_box.left(), word_box.bottom(), word_box.right(), word_box.top());
                }
                #endif
                word->set_flag(W_REP_CHAR, true);
                word->set_flag(W_DONT_CHOP, true);
                word_it.add_after_then_move(word);
            }
            else
            {
                box_it.forward();
            }
        } while (!box_it.at_first());
    }
}


/**********************************************************************
 * plot_fp_word
 *
 * Plot a block of words as if fixed pitch.
 **********************************************************************/

#ifndef GRAPHICS_DISABLED
void plot_fp_word(//draw block of words
                  TO_BLOCK *block,  //block to draw
                  float pitch,      //pitch to draw with
                  float nonspace    //for space threshold
                  )
{
    TO_ROW *row;                   //current row
    TO_ROW_IT row_it = block->get_rows ();

    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
        row = row_it.data ();
        row->min_space = (inT32) ((pitch + nonspace) / 2);
        row->max_nonspace = row->min_space;
        row->space_threshold = row->min_space;
        plot_word_decisions (to_win, (inT16) pitch, row);
    }
}
#endif
/////////////////////////////////////////////////////////////////topitch////////////////////////////////////////

/////////////////////////////////////////////////////////////////pitsync////////////////////////////////////////
#define PROJECTION_MARGIN 10     //arbitrary
#define EXTERN

/**********************************************************************
 * FPCUTPT::setup
 *
 * Constructor to make a new FPCUTPT.
 **********************************************************************/

void FPCUTPT::setup(                     //constructor
                    FPCUTPT *cutpts,     //predecessors
                    inT16 array_origin,  //start coord
                    STATS *projection,   //vertical occupation
                    inT16 zero_count,    //official zero
                    inT16 pitch,         //proposed pitch
                    inT16 x,             //position
                    inT16 offset         //dist to gap
                   ) {
                                 //half of pitch
  inT16 half_pitch = pitch / 2 - 1;
  uinT32 lead_flag;              //new flag
  inT32 ind;                     //current position

  if (half_pitch > 31)
    half_pitch = 31;
  else if (half_pitch < 0)
    half_pitch = 0;
  lead_flag = 1 << half_pitch;

  pred = NULL;
  mean_sum = 0;
  sq_sum = offset * offset;
  cost = sq_sum;
  faked = FALSE;
  terminal = FALSE;
  fake_count = 0;
  xpos = x;
  region_index = 0;
  mid_cuts = 0;
  if (x == array_origin) {
    back_balance = 0;
    fwd_balance = 0;
    for (ind = 0; ind <= half_pitch; ind++) {
      fwd_balance >>= 1;
      if (projection->pile_count (ind) > zero_count)
        fwd_balance |= lead_flag;
    }
  }
  else {
    back_balance = cutpts[x - 1 - array_origin].back_balance << 1;
    back_balance &= lead_flag + lead_flag - 1;
    if (projection->pile_count (x) > zero_count)
      back_balance |= 1;
    fwd_balance = cutpts[x - 1 - array_origin].fwd_balance >> 1;
    if (projection->pile_count (x + half_pitch) > zero_count)
      fwd_balance |= lead_flag;
  }
}


/**********************************************************************
 * FPCUTPT::assign
 *
 * Constructor to make a new FPCUTPT.
 **********************************************************************/

void FPCUTPT::assign(                         //constructor
                     FPCUTPT *cutpts,         //predecessors
                     inT16 array_origin,      //start coord
                     inT16 x,                 //position
                     BOOL8 faking,            //faking this one
                     BOOL8 mid_cut,           //cheap cut.
                     inT16 offset,            //dist to gap
                     STATS *projection,       //vertical occupation
                     float projection_scale,  //scaling
                     inT16 zero_count,        //official zero
                     inT16 pitch,             //proposed pitch
                     inT16 pitch_error        //allowed tolerance
                    ) {
  int index;                     //test index
  int balance_index;             //for balance factor
  inT16 balance_count;           //ding factor
  inT16 r_index;                 //test cut number
  FPCUTPT *segpt;                //segment point
  inT32 dist;                    //from prev segment
  double sq_dist;                //squared distance
  double mean;                   //mean pitch
  double total;                  //total dists
  double factor;                 //cost function
                                 //half of pitch
  inT16 half_pitch = pitch / 2 - 1;
  uinT32 lead_flag;              //new flag

  if (half_pitch > 31)
    half_pitch = 31;
  else if (half_pitch < 0)
    half_pitch = 0;
  lead_flag = 1 << half_pitch;

  back_balance = cutpts[x - 1 - array_origin].back_balance << 1;
  back_balance &= lead_flag + lead_flag - 1;
  if (projection->pile_count (x) > zero_count)
    back_balance |= 1;
  fwd_balance = cutpts[x - 1 - array_origin].fwd_balance >> 1;
  if (projection->pile_count (x + half_pitch) > zero_count)
    fwd_balance |= lead_flag;

  xpos = x;
  cost = MAX_FLOAT32;
  pred = NULL;
  faked = faking;
  terminal = FALSE;
  region_index = 0;
  fake_count = MAX_INT16;
  for (index = x - pitch - pitch_error; index <= x - pitch + pitch_error;
  index++) {
    if (index >= array_origin) {
      segpt = &cutpts[index - array_origin];
      dist = x - segpt->xpos;
      if (!segpt->terminal && segpt->fake_count < MAX_INT16) {
        balance_count = 0;
        if (textord_balance_factor > 0) {
          if (textord_fast_pitch_test) {
            lead_flag = back_balance ^ segpt->fwd_balance;
            balance_count = 0;
            while (lead_flag != 0) {
              balance_count++;
              lead_flag &= lead_flag - 1;
            }
          }
          else {
            for (balance_index = 0;
              index + balance_index < x - balance_index;
              balance_index++)
            balance_count +=
                (projection->pile_count (index + balance_index) <=
                zero_count) ^ (projection->pile_count (x -
                balance_index)
                <= zero_count);
          }
          balance_count =
            (inT16) (balance_count * textord_balance_factor /
            projection_scale);
        }
        r_index = segpt->region_index + 1;
        total = segpt->mean_sum + dist;
        balance_count += offset;
        sq_dist =
          dist * dist + segpt->sq_sum + balance_count * balance_count;
        mean = total / r_index;
        factor = mean - pitch;
        factor *= factor;
        factor += sq_dist / (r_index) - mean * mean;
        if (factor < cost && segpt->fake_count + faked <= fake_count) {
          cost = factor;         //find least cost
          pred = segpt;          //save path
          mean_sum = total;
          sq_sum = sq_dist;
          fake_count = segpt->fake_count + faked;
          mid_cuts = segpt->mid_cuts + mid_cut;
          region_index = r_index;
        }
      }
    }
  }
}


/**********************************************************************
 * FPCUTPT::assign_cheap
 *
 * Constructor to make a new FPCUTPT on the cheap.
 **********************************************************************/

void FPCUTPT::assign_cheap(                         //constructor
                           FPCUTPT *cutpts,         //predecessors
                           inT16 array_origin,      //start coord
                           inT16 x,                 //position
                           BOOL8 faking,            //faking this one
                           BOOL8 mid_cut,           //cheap cut.
                           inT16 offset,            //dist to gap
                           STATS *projection,       //vertical occupation
                           float projection_scale,  //scaling
                           inT16 zero_count,        //official zero
                           inT16 pitch,             //proposed pitch
                           inT16 pitch_error        //allowed tolerance
                          ) {
  Q_UNUSED(pitch_error);
  int index;                     //test index
  inT16 balance_count;           //ding factor
  inT16 r_index;                 //test cut number
  FPCUTPT *segpt;                //segment point
  inT32 dist;                    //from prev segment
  double sq_dist;                //squared distance
  double mean;                   //mean pitch
  double total;                  //total dists
  double factor;                 //cost function
                                 //half of pitch
  inT16 half_pitch = pitch / 2 - 1;
  uinT32 lead_flag;              //new flag

  if (half_pitch > 31)
    half_pitch = 31;
  else if (half_pitch < 0)
    half_pitch = 0;
  lead_flag = 1 << half_pitch;

  back_balance = cutpts[x - 1 - array_origin].back_balance << 1;
  back_balance &= lead_flag + lead_flag - 1;
  if (projection->pile_count (x) > zero_count)
    back_balance |= 1;
  fwd_balance = cutpts[x - 1 - array_origin].fwd_balance >> 1;
  if (projection->pile_count (x + half_pitch) > zero_count)
    fwd_balance |= lead_flag;

  xpos = x;
  cost = MAX_FLOAT32;
  pred = NULL;
  faked = faking;
  terminal = FALSE;
  region_index = 0;
  fake_count = MAX_INT16;
  index = x - pitch;
  if (index >= array_origin) {
    segpt = &cutpts[index - array_origin];
    dist = x - segpt->xpos;
    if (!segpt->terminal && segpt->fake_count < MAX_INT16) {
      balance_count = 0;
      if (textord_balance_factor > 0) {
        lead_flag = back_balance ^ segpt->fwd_balance;
        balance_count = 0;
        while (lead_flag != 0) {
          balance_count++;
          lead_flag &= lead_flag - 1;
        }
        balance_count = (inT16) (balance_count * textord_balance_factor
          / projection_scale);
      }
      r_index = segpt->region_index + 1;
      total = segpt->mean_sum + dist;
      balance_count += offset;
      sq_dist =
        dist * dist + segpt->sq_sum + balance_count * balance_count;
      mean = total / r_index;
      factor = mean - pitch;
      factor *= factor;
      factor += sq_dist / (r_index) - mean * mean;
      cost = factor;             //find least cost
      pred = segpt;              //save path
      mean_sum = total;
      sq_sum = sq_dist;
      fake_count = segpt->fake_count + faked;
      mid_cuts = segpt->mid_cuts + mid_cut;
      region_index = r_index;
    }
  }
}


/**********************************************************************
 * check_pitch_sync
 *
 * Construct the lattice of possible segmentation points and choose the
 * optimal path. Return the optimal path only.
 * The return value is a measure of goodness of the sync.
 **********************************************************************/

double check_pitch_sync2(                          //find segmentation
                         BLOBNBOX_IT *blob_it,     //blobs to do
                         inT16 blob_count,         //no of blobs
                         inT16 pitch,              //pitch estimate
                         inT16 pitch_error,        //tolerance
                         STATS *projection,        //vertical
                         inT16 projection_left,    //edges //scale factor
                         inT16 projection_right,
                         float projection_scale,
                         inT16 &occupation_count,  //no of occupied cells
                         FPSEGPT_LIST *seg_list,   //output list
                         inT16 start,              //start of good range
                         inT16 end                 //end of good range
                        ) {
  BOOL8 faking;                  //illegal cut pt
  BOOL8 mid_cut;                 //cheap cut pt.
  inT16 x;                       //current coord
  inT16 blob_index;              //blob number
  inT16 left_edge;               //of word
  inT16 right_edge;              //of word
  inT16 array_origin;            //x coord of array
  inT16 offset;                  //dist to legal area
  inT16 zero_count;              //projection zero
  inT16 best_left_x = 0;         //for equals
  inT16 best_right_x = 0;        //right edge
  TBOX this_box;                  //bounding box
  TBOX next_box;                  //box of next blob
  FPSEGPT *segpt;                //segment point
  FPCUTPT *cutpts;               //array of points
  double best_cost;              //best path
  double mean_sum;               //computes result
  FPCUTPT *best_end;             //end of best path
  inT16 best_fake;               //best fake level
  inT16 best_count;              //no of cuts
  BLOBNBOX_IT this_it;           //copy iterator
  FPSEGPT_IT seg_it = seg_list;  //output iterator

  //      tprintf("Computing sync on word of %d blobs with pitch %d\n",
  //              blob_count, pitch);
  //      if (blob_count==8 && pitch==27)
  //              projection->print(stdout,TRUE);
  zero_count = 0;
  if (pitch < 3)
    pitch = 3;                   //nothing ludicrous
  if ((pitch - 3) / 2 < pitch_error)
    pitch_error = (pitch - 3) / 2;
  this_it = *blob_it;
  this_box = box_next (&this_it);//get box
  //      left_edge=this_box.left();                                              //left of word
  //      right_edge=this_box.right();
  //      for (blob_index=1;blob_index<blob_count;blob_index++)
  //      {
  //              this_box=box_next(&this_it);
  //              if (this_box.right()>right_edge)
  //                      right_edge=this_box.right();
  //      }
  for (left_edge = projection_left; projection->pile_count (left_edge) == 0
    && left_edge < projection_right; left_edge++);
  for (right_edge = projection_right; projection->pile_count (right_edge) == 0
    && right_edge > left_edge; right_edge--);
  ASSERT_HOST (right_edge >= left_edge);
  if (pitsync_linear_version >= 4)
    return check_pitch_sync3 (projection_left, projection_right, zero_count,
      pitch, pitch_error, projection,
      projection_scale, occupation_count, seg_list,
      start, end);
  array_origin = left_edge - pitch;
  cutpts = (FPCUTPT *) alloc_mem ((right_edge - left_edge + pitch * 2 + 1)
    * sizeof (FPCUTPT));
  for (x = array_origin; x < left_edge; x++)
                                 //free cuts
    cutpts[x - array_origin].setup (cutpts, array_origin, projection, zero_count, pitch, x, 0);
  for (offset = 0; offset <= pitch_error; offset++, x++)
                                 //not quite free
    cutpts[x - array_origin].setup (cutpts, array_origin, projection, zero_count, pitch, x, offset);

  this_it = *blob_it;
  best_cost = MAX_FLOAT32;
  best_end = NULL;
  this_box = box_next (&this_it);//first box
  next_box = box_next (&this_it);//second box
  blob_index = 1;
  while (x < right_edge - pitch_error) {
    if (x > this_box.right () + pitch_error && blob_index < blob_count) {
      this_box = next_box;
      next_box = box_next (&this_it);
      blob_index++;
    }
    faking = FALSE;
    mid_cut = FALSE;
    if (x <= this_box.left ())
      offset = 0;
    else if (x <= this_box.left () + pitch_error)
      offset = x - this_box.left ();
    else if (x >= this_box.right ())
      offset = 0;
    else if (x >= next_box.left () && blob_index < blob_count) {
      offset = x - next_box.left ();
      if (this_box.right () - x < offset)
        offset = this_box.right () - x;
    }
    else if (x >= this_box.right () - pitch_error)
      offset = this_box.right () - x;
    else if (x - this_box.left () > pitch * pitsync_joined_edge
    && this_box.right () - x > pitch * pitsync_joined_edge) {
      mid_cut = TRUE;
      offset = 0;
    }
    else {
      faking = TRUE;
      offset = projection->pile_count (x);
    }
    cutpts[x - array_origin].assign (cutpts, array_origin, x,
      faking, mid_cut, offset, projection,
      projection_scale, zero_count, pitch,
      pitch_error);
    x++;
  }

  best_fake = MAX_INT16;
  best_cost = MAX_INT32;
  best_count = MAX_INT16;
  while (x < right_edge + pitch) {
    offset = x < right_edge ? right_edge - x : 0;
    cutpts[x - array_origin].assign (cutpts, array_origin, x,
      FALSE, FALSE, offset, projection,
      projection_scale, zero_count, pitch,
      pitch_error);
    cutpts[x - array_origin].terminal = TRUE;
    if (cutpts[x - array_origin].index () +
    cutpts[x - array_origin].fake_count <= best_count + best_fake) {
      if (cutpts[x - array_origin].fake_count < best_fake
        || (cutpts[x - array_origin].fake_count == best_fake
      && cutpts[x - array_origin].cost_function () < best_cost)) {
        best_fake = cutpts[x - array_origin].fake_count;
        best_cost = cutpts[x - array_origin].cost_function ();
        best_left_x = x;
        best_right_x = x;
        best_count = cutpts[x - array_origin].index ();
      }
      else if (cutpts[x - array_origin].fake_count == best_fake
        && x == best_right_x + 1
      && cutpts[x - array_origin].cost_function () == best_cost) {
      //exactly equal
        best_right_x = x;
      }
    }
    x++;
  }
  ASSERT_HOST (best_fake < MAX_INT16);

  best_end = &cutpts[(best_left_x + best_right_x) / 2 - array_origin];
  if (this_box.right () == textord_test_x
  && this_box.top () == textord_test_y) {
    for (x = left_edge - pitch; x < right_edge + pitch; x++) {
      tprintf ("x=%d, C=%g, s=%g, sq=%g, prev=%d\n",
        x, cutpts[x - array_origin].cost_function (),
        cutpts[x - array_origin].sum (),
        cutpts[x - array_origin].squares (),
        cutpts[x - array_origin].previous ()->position ());
    }
  }
  occupation_count = -1;
  do {
    for (x = best_end->position () - pitch + pitch_error;
      x < best_end->position () - pitch_error
      && projection->pile_count (x) == 0; x++);
    if (x < best_end->position () - pitch_error)
      occupation_count++;
                                 //copy it
    segpt = new FPSEGPT (best_end);
    seg_it.add_before_then_move (segpt);
    best_end = best_end->previous ();
  }
  while (best_end != NULL);
  seg_it.move_to_last ();
  mean_sum = seg_it.data ()->sum ();
  mean_sum = mean_sum * mean_sum / best_count;
  if (seg_it.data ()->squares () - mean_sum < 0)
    tprintf ("Impossible sqsum=%g, mean=%g, total=%d\n",
      seg_it.data ()->squares (), seg_it.data ()->sum (), best_count);
  free_mem(cutpts);
  //      tprintf("blob_count=%d, pitch=%d, sync=%g, occ=%d\n",
  //              blob_count,pitch,seg_it.data()->squares()-mean_sum,
  //              occupation_count);
  return seg_it.data ()->squares () - mean_sum;
}


/**********************************************************************
 * check_pitch_sync
 *
 * Construct the lattice of possible segmentation points and choose the
 * optimal path. Return the optimal path only.
 * The return value is a measure of goodness of the sync.
 **********************************************************************/

double check_pitch_sync3(                          //find segmentation
                         inT16 projection_left,    //edges //to be considered 0
                         inT16 projection_right,
                         inT16 zero_count,
                         inT16 pitch,              //pitch estimate
                         inT16 pitch_error,        //tolerance
                         STATS *projection,        //vertical
                         float projection_scale,   //scale factor
                         inT16 &occupation_count,  //no of occupied cells
                         FPSEGPT_LIST *seg_list,   //output list
                         inT16 start,              //start of good range
                         inT16 end                 //end of good range
                        ) {
  BOOL8 faking;                  //illegal cut pt
  BOOL8 mid_cut;                 //cheap cut pt.
  inT16 left_edge;               //of word
  inT16 right_edge;              //of word
  inT16 x;                       //current coord
  inT16 array_origin;            //x coord of array
  inT16 offset;                  //dist to legal area
  inT16 projection_offset;       //from scaled projection
  inT16 prev_zero;               //previous zero dist
  inT16 next_zero;               //next zero dist
  inT16 zero_offset;             //scan window
  inT16 best_left_x = 0;         //for equals
  inT16 best_right_x = 0;        //right edge
  FPSEGPT *segpt;                //segment point
  FPCUTPT *cutpts;               //array of points
  BOOL8 *mins;                   //local min results
  int minindex;                  //next input position
  int test_index;                //index to mins
  double best_cost;              //best path
  double mean_sum;               //computes result
  FPCUTPT *best_end;             //end of best path
  inT16 best_fake;               //best fake level
  inT16 best_count;              //no of cuts
  FPSEGPT_IT seg_it = seg_list;  //output iterator

  end = (end - start) % pitch;
  if (pitch < 3)
    pitch = 3;                   //nothing ludicrous
  if ((pitch - 3) / 2 < pitch_error)
    pitch_error = (pitch - 3) / 2;
                                 //min dist of zero
  zero_offset = (inT16) (pitch * pitsync_joined_edge);
  for (left_edge = projection_left; projection->pile_count (left_edge) == 0
    && left_edge < projection_right; left_edge++);
  for (right_edge = projection_right; projection->pile_count (right_edge) == 0
    && right_edge > left_edge; right_edge--);
  array_origin = left_edge - pitch;
  cutpts = (FPCUTPT *) alloc_mem ((right_edge - left_edge + pitch * 2 + 1)
    * sizeof (FPCUTPT));
  mins = (BOOL8 *) alloc_mem ((pitch_error * 2 + 1) * sizeof (BOOL8));
  for (x = array_origin; x < left_edge; x++)
                                 //free cuts
    cutpts[x - array_origin].setup (cutpts, array_origin, projection, zero_count, pitch, x, 0);
  prev_zero = left_edge - 1;
  for (offset = 0; offset <= pitch_error; offset++, x++)
                                 //not quite free
    cutpts[x - array_origin].setup (cutpts, array_origin, projection, zero_count, pitch, x, offset);

  best_cost = MAX_FLOAT32;
  best_end = NULL;
  for (offset = -pitch_error, minindex = 0; offset < pitch_error;
    offset++, minindex++)
  mins[minindex] = projection->local_min (x + offset);
  next_zero = x + zero_offset + 1;
  for (offset = next_zero - 1; offset >= x; offset--) {
    if (projection->pile_count (offset) <= zero_count) {
      next_zero = offset;
      break;
    }
  }
  while (x < right_edge - pitch_error) {
    mins[minindex] = projection->local_min (x + pitch_error);
    minindex++;
    if (minindex > pitch_error * 2)
      minindex = 0;
    faking = FALSE;
    mid_cut = FALSE;
    offset = 0;
    if (projection->pile_count (x) <= zero_count) {
      prev_zero = x;
    }
    else {
      for (offset = 1; offset <= pitch_error; offset++)
        if (projection->pile_count (x + offset) <= zero_count
        || projection->pile_count (x - offset) <= zero_count)
          break;
    }
    if (offset > pitch_error) {
      if (x - prev_zero > zero_offset && next_zero - x > zero_offset) {
        for (offset = 0; offset <= pitch_error; offset++) {
          test_index = minindex + pitch_error + offset;
          if (test_index > pitch_error * 2)
            test_index -= pitch_error * 2 + 1;
          if (mins[test_index])
            break;
          test_index = minindex + pitch_error - offset;
          if (test_index > pitch_error * 2)
            test_index -= pitch_error * 2 + 1;
          if (mins[test_index])
            break;
        }
      }
      if (offset > pitch_error) {
        offset = projection->pile_count (x);
        faking = TRUE;
      }
      else {
        projection_offset =
          (inT16) (projection->pile_count (x) / projection_scale);
        if (projection_offset > offset)
          offset = projection_offset;
        mid_cut = TRUE;
      }
    }
    if ((start == 0 && end == 0)
      || !textord_fast_pitch_test
      || (x - projection_left - start) % pitch <= end)
      cutpts[x - array_origin].assign (cutpts, array_origin, x,
        faking, mid_cut, offset, projection,
        projection_scale, zero_count, pitch,
        pitch_error);
    else
      cutpts[x - array_origin].assign_cheap (cutpts, array_origin, x,
        faking, mid_cut, offset,
        projection, projection_scale,
        zero_count, pitch,
        pitch_error);
    x++;
    if (next_zero < x || next_zero == x + zero_offset)
      next_zero = x + zero_offset + 1;
    if (projection->pile_count (x + zero_offset) <= zero_count)
      next_zero = x + zero_offset;
  }

  best_fake = MAX_INT16;
  best_cost = MAX_INT32;
  best_count = MAX_INT16;
  while (x < right_edge + pitch) {
    offset = x < right_edge ? right_edge - x : 0;
    cutpts[x - array_origin].assign (cutpts, array_origin, x,
      FALSE, FALSE, offset, projection,
      projection_scale, zero_count, pitch,
      pitch_error);
    cutpts[x - array_origin].terminal = TRUE;
    if (cutpts[x - array_origin].index () +
    cutpts[x - array_origin].fake_count <= best_count + best_fake) {
      if (cutpts[x - array_origin].fake_count < best_fake
        || (cutpts[x - array_origin].fake_count == best_fake
      && cutpts[x - array_origin].cost_function () < best_cost)) {
        best_fake = cutpts[x - array_origin].fake_count;
        best_cost = cutpts[x - array_origin].cost_function ();
        best_left_x = x;
        best_right_x = x;
        best_count = cutpts[x - array_origin].index ();
      }
      else if (cutpts[x - array_origin].fake_count == best_fake
        && x == best_right_x + 1
      && cutpts[x - array_origin].cost_function () == best_cost) {
      //exactly equal
        best_right_x = x;
      }
    }
    x++;
  }
  ASSERT_HOST (best_fake < MAX_INT16);

  best_end = &cutpts[(best_left_x + best_right_x) / 2 - array_origin];
  //      for (x=left_edge-pitch;x<right_edge+pitch;x++)
  //      {
  //              tprintf("x=%d, C=%g, s=%g, sq=%g, prev=%d\n",
  //                      x,cutpts[x-array_origin].cost_function(),
  //                      cutpts[x-array_origin].sum(),
  //                      cutpts[x-array_origin].squares(),
  //                      cutpts[x-array_origin].previous()->position());
  //      }
  occupation_count = -1;
  do {
    for (x = best_end->position () - pitch + pitch_error;
      x < best_end->position () - pitch_error
      && projection->pile_count (x) == 0; x++);
    if (x < best_end->position () - pitch_error)
      occupation_count++;
                                 //copy it
    segpt = new FPSEGPT (best_end);
    seg_it.add_before_then_move (segpt);
    best_end = best_end->previous ();
  }
  while (best_end != NULL);
  seg_it.move_to_last ();
  mean_sum = seg_it.data ()->sum ();
  mean_sum = mean_sum * mean_sum / best_count;
  if (seg_it.data ()->squares () - mean_sum < 0)
    tprintf ("Impossible sqsum=%g, mean=%g, total=%d\n",
      seg_it.data ()->squares (), seg_it.data ()->sum (), best_count);
  free_mem(mins);
  free_mem(cutpts);
  return seg_it.data ()->squares () - mean_sum;
}
/////////////////////////////////////////////////////////////////pitsync////////////////////////////////////////

/////////////////////////////////////////////////////////////////pitsync1////////////////////////////////////////
ELISTIZE (FPSEGPT) CLISTIZE (FPSEGPT_LIST)
#define EXTERN
EXTERN
INT_VAR (pitsync_linear_version, 6, "Use new fast algorithm");
EXTERN
double_VAR (pitsync_joined_edge, 0.75,
"Dist inside big blob for chopping");
EXTERN
double_VAR (pitsync_offset_freecut_fraction, 0.25,
"Fraction of cut for free cuts");
EXTERN
INT_VAR (pitsync_fake_depth, 1, "Max advance fake generation");

/**********************************************************************
 * FPSEGPT::FPSEGPT
 *
 * Constructor to make a new FPSEGPT.
 * The existing FPCUTPT is duplicated.
 **********************************************************************/

FPSEGPT::FPSEGPT(                //constructor
                 FPCUTPT *cutpt  //create from new form
                ) {
  pred = NULL;
  mean_sum = cutpt->sum ();
  sq_sum = cutpt->squares ();
  cost = cutpt->cost_function ();
  faked = cutpt->faked;
  terminal = cutpt->terminal;
  fake_count = cutpt->fake_count;
  xpos = cutpt->position ();
  mid_cuts = cutpt->cheap_cuts ();
}


/**********************************************************************
 * FPSEGPT::FPSEGPT
 *
 * Constructor to make a new FPSEGPT.
 **********************************************************************/

FPSEGPT::FPSEGPT (               //constructor
inT16 x                          //position
):xpos (x) {
  pred = NULL;
  mean_sum = 0;
  sq_sum = 0;
  cost = 0;
  faked = FALSE;
  terminal = FALSE;
  fake_count = 0;
  mid_cuts = 0;
}


/**********************************************************************
 * FPSEGPT::FPSEGPT
 *
 * Constructor to make a new FPSEGPT.
 **********************************************************************/

FPSEGPT::FPSEGPT (               //constructor
inT16 x,                         //position
BOOL8 faking,                    //faking this one
inT16 offset,                    //dist to gap
inT16 region_index,              //segment number
inT16 pitch,                     //proposed pitch
inT16 pitch_error,               //allowed tolerance
FPSEGPT_LIST * prev_list         //previous segment
):xpos (x) {
  inT16 best_fake;               //on previous
  FPSEGPT *segpt;                //segment point
  inT32 dist;                    //from prev segment
  double sq_dist;                //squared distance
  double mean;                   //mean pitch
  double total;                  //total dists
  double factor;                 //cost function
  FPSEGPT_IT pred_it = prev_list;//for previuos segment

  cost = MAX_FLOAT32;
  pred = NULL;
  faked = faking;
  terminal = FALSE;
  best_fake = MAX_INT16;
  mid_cuts = 0;
  for (pred_it.mark_cycle_pt (); !pred_it.cycled_list (); pred_it.forward ()) {
    segpt = pred_it.data ();
    if (segpt->fake_count < best_fake)
      best_fake = segpt->fake_count;
    dist = x - segpt->xpos;
    if (dist >= pitch - pitch_error && dist <= pitch + pitch_error
    && !segpt->terminal) {
      total = segpt->mean_sum + dist;
      sq_dist = dist * dist + segpt->sq_sum + offset * offset;
      //sum of squarees
      mean = total / region_index;
      factor = mean - pitch;
      factor *= factor;
      factor += sq_dist / (region_index) - mean * mean;
      if (factor < cost) {
        cost = factor;           //find least cost
        pred = segpt;            //save path
        mean_sum = total;
        sq_sum = sq_dist;
        fake_count = segpt->fake_count + faked;
      }
    }
  }
  if (fake_count > best_fake + 1)
    pred = NULL;                 //fail it
}


/**********************************************************************
 * check_pitch_sync
 *
 * Construct the lattice of possible segmentation points and choose the
 * optimal path. Return the optimal path only.
 * The return value is a measure of goodness of the sync.
 **********************************************************************/

double check_pitch_sync(                        //find segmentation
                        BLOBNBOX_IT *blob_it,   //blobs to do
                        inT16 blob_count,       //no of blobs
                        inT16 pitch,            //pitch estimate
                        inT16 pitch_error,      //tolerance
                        STATS *projection,      //vertical
                        FPSEGPT_LIST *seg_list  //output list
                       ) {
  inT16 x;                       //current coord
  inT16 min_index;               //blob number
  inT16 max_index;               //blob number
  inT16 left_edge;               //of word
  inT16 right_edge;              //of word
  inT16 right_max;               //max allowed x
  inT16 min_x;                   //in this region
  inT16 max_x;
  inT16 region_index;
  inT16 best_region_index = 0;   //for best result
  inT16 offset;                  //dist to legal area
  inT16 left_best_x;             //edge of good region
  inT16 right_best_x;            //right edge
  TBOX min_box;                   //bounding box
  TBOX max_box;                   //bounding box
  TBOX next_box;                  //box of next blob
  FPSEGPT *segpt;                //segment point
  FPSEGPT_LIST *segpts;          //points in a segment
  double best_cost;              //best path
  double mean_sum;               //computes result
  FPSEGPT *best_end;             //end of best path
  BLOBNBOX_IT min_it;            //copy iterator
  BLOBNBOX_IT max_it;            //copy iterator
  FPSEGPT_IT segpt_it;           //iterator
                                 //output segments
  FPSEGPT_IT outseg_it = seg_list;
  FPSEGPT_LIST_CLIST lattice;    //list of lists
                                 //region iterator
  FPSEGPT_LIST_C_IT lattice_it = &lattice;

  //      tprintf("Computing sync on word of %d blobs with pitch %d\n",
  //              blob_count, pitch);
  //      if (blob_count==8 && pitch==27)
  //              projection->print(stdout,TRUE);
  if (pitch < 3)
    pitch = 3;                   //nothing ludicrous
  if ((pitch - 3) / 2 < pitch_error)
    pitch_error = (pitch - 3) / 2;
  min_it = *blob_it;
  min_box = box_next (&min_it);  //get box
  //      if (blob_count==8 && pitch==27)
  //              tprintf("1st box at (%d,%d)->(%d,%d)\n",
  //                      min_box.left(),min_box.bottom(),
  //                      min_box.right(),min_box.top());
                                 //left of word
  left_edge = min_box.left () + pitch_error;
  for (min_index = 1; min_index < blob_count; min_index++) {
    min_box = box_next (&min_it);
    //              if (blob_count==8 && pitch==27)
    //                      tprintf("Box at (%d,%d)->(%d,%d)\n",
    //                              min_box.left(),min_box.bottom(),
    //                              min_box.right(),min_box.top());
  }
  right_edge = min_box.right (); //end of word
  max_x = left_edge;
                                 //min permissible
  min_x = max_x - pitch + pitch_error * 2 + 1;
  right_max = right_edge + pitch - pitch_error - 1;
  segpts = new FPSEGPT_LIST;     //list of points
  segpt_it.set_to_list (segpts);
  for (x = min_x; x <= max_x; x++) {
    segpt = new FPSEGPT (x);     //make a new one
                                 //put in list
    segpt_it.add_after_then_move (segpt);
  }
                                 //first segment
  lattice_it.add_before_then_move (segpts);
  min_index = 0;
  region_index = 1;
  best_cost = MAX_FLOAT32;
  best_end = NULL;
  min_it = *blob_it;
  min_box = box_next (&min_it);  //first box
  do {
    left_best_x = -1;
    right_best_x = -1;
    segpts = new FPSEGPT_LIST;   //list of points
    segpt_it.set_to_list (segpts);
    min_x += pitch - pitch_error;//next limits
    max_x += pitch + pitch_error;
    while (min_box.right () < min_x && min_index < blob_count) {
      min_index++;
      min_box = box_next (&min_it);
    }
    max_it = min_it;
    max_index = min_index;
    max_box = min_box;
    next_box = box_next (&max_it);
    for (x = min_x; x <= max_x && x <= right_max; x++) {
      while (x < right_edge && max_index < blob_count
      && x > max_box.right ()) {
        max_index++;
        max_box = next_box;
        next_box = box_next (&max_it);
      }
      if (x <= max_box.left () + pitch_error
        || x >= max_box.right () - pitch_error || x >= right_edge
        || (max_index < blob_count - 1 && x >= next_box.left ())
        || (x - max_box.left () > pitch * pitsync_joined_edge
      && max_box.right () - x > pitch * pitsync_joined_edge)) {
      //                      || projection->local_min(x))
        if (x - max_box.left () > 0
          && x - max_box.left () <= pitch_error)
                                 //dist to real break
          offset = x - max_box.left ();
        else if (max_box.right () - x > 0
          && max_box.right () - x <= pitch_error
          && (max_index >= blob_count - 1
          || x < next_box.left ()))
          offset = max_box.right () - x;
        else
          offset = 0;
        //                              offset=pitsync_offset_freecut_fraction*projection->pile_count(x);
        segpt = new FPSEGPT (x, FALSE, offset, region_index,
          pitch, pitch_error, lattice_it.data ());
      }
      else {
        offset = projection->pile_count (x);
        segpt = new FPSEGPT (x, TRUE, offset, region_index,
          pitch, pitch_error, lattice_it.data ());
      }
      if (segpt->previous () != NULL) {
        segpt_it.add_after_then_move (segpt);
        if (x >= right_edge - pitch_error) {
          segpt->terminal = TRUE;//no more wanted
          if (segpt->cost_function () < best_cost) {
            best_cost = segpt->cost_function ();
            //find least
            best_end = segpt;
            best_region_index = region_index;
            left_best_x = x;
            right_best_x = x;
          }
          else if (segpt->cost_function () == best_cost
            && right_best_x == x - 1)
            right_best_x = x;
        }
      }
      else {
        delete segpt;            //no good
      }
    }
    if (segpts->empty ()) {
      if (best_end != NULL)
        break;                   //already found one
      make_illegal_segment (lattice_it.data (), min_box, min_it,
        region_index, pitch, pitch_error, segpts);
    }
    else {
      if (right_best_x > left_best_x + 1) {
        left_best_x = (left_best_x + right_best_x + 1) / 2;
        for (segpt_it.mark_cycle_pt (); !segpt_it.cycled_list ()
          && segpt_it.data ()->position () != left_best_x;
          segpt_it.forward ());
        if (segpt_it.data ()->position () == left_best_x)
                                 //middle of region
          best_end = segpt_it.data ();
      }
    }
                                 //new segment
    lattice_it.add_before_then_move (segpts);
    region_index++;
  }
  while (min_x < right_edge);
  ASSERT_HOST (best_end != NULL);//must always find some

  for (lattice_it.mark_cycle_pt (); !lattice_it.cycled_list ();
  lattice_it.forward ()) {
    segpts = lattice_it.data ();
    segpt_it.set_to_list (segpts);
    //              if (blob_count==8 && pitch==27)
    //              {
    //                      for (segpt_it.mark_cycle_pt();!segpt_it.cycled_list();segpt_it.forward())
    //                      {
    //                              segpt=segpt_it.data();
    //                              tprintf("At %d, (%x) cost=%g, m=%g, sq=%g, pred=%x\n",
    //                                      segpt->position(),segpt,segpt->cost_function(),
    //                                      segpt->sum(),segpt->squares(),segpt->previous());
    //                      }
    //                      tprintf("\n");
    //              }
    for (segpt_it.mark_cycle_pt (); !segpt_it.cycled_list ()
      && segpt_it.data () != best_end; segpt_it.forward ());
    if (segpt_it.data () == best_end) {
                                 //save good one
      segpt = segpt_it.extract ();
      outseg_it.add_before_then_move (segpt);
      best_end = segpt->previous ();
    }
  }
  ASSERT_HOST (best_end == NULL);
  ASSERT_HOST (!outseg_it.empty ());
  outseg_it.move_to_last ();
  mean_sum = outseg_it.data ()->sum ();
  mean_sum = mean_sum * mean_sum / best_region_index;
  if (outseg_it.data ()->squares () - mean_sum < 0)
    tprintf ("Impossible sqsum=%g, mean=%g, total=%d\n",
      outseg_it.data ()->squares (), outseg_it.data ()->sum (),
      best_region_index);
  lattice.deep_clear ();         //shift the lot
  return outseg_it.data ()->squares () - mean_sum;
}


/**********************************************************************
 * make_illegal_segment
 *
 * Make a fake set of chop points due to having no legal places.
 **********************************************************************/

void make_illegal_segment(                          //find segmentation
                          FPSEGPT_LIST *prev_list,  //previous segments
                          TBOX blob_box,             //bounding box
                          BLOBNBOX_IT blob_it,      //iterator
                          inT16 region_index,       //number of segment
                          inT16 pitch,              //pitch estimate
                          inT16 pitch_error,        //tolerance
                          FPSEGPT_LIST *seg_list    //output list
                         ) {
  inT16 x;                       //current coord
  inT16 min_x = 0;               //in this region
  inT16 max_x = 0;
  inT16 offset;                  //dist to edge
  FPSEGPT *segpt;                //segment point
  FPSEGPT *prevpt;               //previous point
  float best_cost;               //best path
  FPSEGPT_IT segpt_it = seg_list;//iterator
                                 //previous points
  FPSEGPT_IT prevpt_it = prev_list;

  best_cost = MAX_FLOAT32;
  for (prevpt_it.mark_cycle_pt (); !prevpt_it.cycled_list ();
  prevpt_it.forward ()) {
    prevpt = prevpt_it.data ();
    if (prevpt->cost_function () < best_cost) {
                                 //find least
      best_cost = prevpt->cost_function ();
      min_x = prevpt->position ();
      max_x = min_x;             //limits on coords
    }
    else if (prevpt->cost_function () == best_cost) {
      max_x = prevpt->position ();
    }
  }
  min_x += pitch - pitch_error;
  max_x += pitch + pitch_error;
  for (x = min_x; x <= max_x; x++) {
    while (x > blob_box.right ()) {
      blob_box = box_next (&blob_it);
    }
    offset = x - blob_box.left ();
    if (blob_box.right () - x < offset)
      offset = blob_box.right () - x;
    segpt = new FPSEGPT (x, FALSE, offset,
      region_index, pitch, pitch_error, prev_list);
    if (segpt->previous () != NULL) {
      ASSERT_HOST (offset >= 0);
      fprintf (stderr, "made fake at %d\n", x);
                                 //make one up
      segpt_it.add_after_then_move (segpt);
      segpt->faked = TRUE;
      segpt->fake_count++;
    }
    else
      delete segpt;
  }
}
/////////////////////////////////////////////////////////////////pitsync1////////////////////////////////////////

/////////////////////////////////////////////////////////////////drawtord////////////////////////////////////////
#define TO_WIN_XPOS     0       //default window pos
#define TO_WIN_YPOS     0
#define TO_WIN_NAME     "Textord"
                                 //title of window
#define DEBUG_WIN_NAME    "TODebug"
#define DEBUG_XPOS      0
#define DEBUG_YPOS      120
#define DEBUG_XSIZE     80
#define DEBUG_YSIZE     32
#define YMAX        3508
#define XMAX        2550

#define EXTERN

EXTERN BOOL_VAR (textord_show_fixed_cuts, FALSE,
"Draw fixed pitch cell boundaries");
EXTERN STRING_VAR (to_debugfile, DEBUG_WIN_NAME, "Name of debugfile");

EXTERN ScrollView* to_win = NULL;
EXTERN FILE *to_debug = NULL;

/**********************************************************************
 * create_to_win
 *
 * Create the to window used to show the fit.
 **********************************************************************/
#ifndef GRAPHICS_DISABLED

void create_to_win(ICOORD page_tr) {
  to_win = new ScrollView(TO_WIN_NAME, TO_WIN_XPOS, TO_WIN_YPOS,
                          page_tr.x() + 1, page_tr.y() + 1,
                          page_tr.x(), page_tr.y(), true);
}


void close_to_win() {
  // to_win is leaked, but this enables the user to view the contents.
  if (to_win != NULL) {
    to_win->Update();
  }
}


/**********************************************************************
 * create_todebug_win
 *
 * Create the to window used to show the fit.
 **********************************************************************/

void create_todebug_win() {  //make gradients win
  if (strcmp (to_debugfile.string (), DEBUG_WIN_NAME) != 0)
    //              create_debug_window();
    //      else
    to_debug = fopen (to_debugfile.string (), "w");
}



/**********************************************************************
 * plot_box_list
 *
 * Draw a list of blobs.
 **********************************************************************/

void plot_box_list(                      //make gradients win
                   ScrollView* win,           //window to draw in
                   BLOBNBOX_LIST *list,  //blob list
                   ScrollView::Color body_colour    //colour to draw
                  ) {
  BLOBNBOX_IT it = list;         //iterator

  win->Pen(body_colour);
  win->Brush(ScrollView::NONE);
  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
    it.data ()->bounding_box ().plot (win);
  }
}


/**********************************************************************
 * plot_to_row
 *
 * Draw the blobs of a row in a given colour and draw the line fit.
 **********************************************************************/

void plot_to_row(                 //draw a row
                 TO_ROW *row,     //row to draw
                 ScrollView::Color colour,   //colour to draw in
                 FCOORD rotation  //rotation for line
                ) {
  FCOORD plot_pt;                //point to plot
                                 //blobs
  BLOBNBOX_IT it = row->blob_list ();
  float left, right;             //end of row

  if (it.empty ()) {
    tprintf ("No blobs in row at %g\n", row->parallel_c ());
    return;
  }
  left = it.data ()->bounding_box ().left ();
  it.move_to_last ();
  right = it.data ()->bounding_box ().right ();
  plot_blob_list (to_win, row->blob_list (), colour, ScrollView::BROWN);
  to_win->Pen(colour);
  plot_pt = FCOORD (left, row->line_m () * left + row->line_c ());
  plot_pt.rotate (rotation);
  to_win->SetCursor(plot_pt.x (), plot_pt.y ());
  plot_pt = FCOORD (right, row->line_m () * right + row->line_c ());
  plot_pt.rotate (rotation);
  to_win->DrawTo(plot_pt.x (), plot_pt.y ());
}


/**********************************************************************
 * plot_parallel_row
 *
 * Draw the blobs of a row in a given colour and draw the line fit.
 **********************************************************************/

void plot_parallel_row(                 //draw a row
                       TO_ROW *row,     //row to draw
                       float gradient,  //gradients of lines
                       inT32 left,      //edge of block
                       ScrollView::Color colour,   //colour to draw in
                       FCOORD rotation  //rotation for line
                      ) {
  FCOORD plot_pt;                //point to plot
                                 //blobs
  BLOBNBOX_IT it = row->blob_list ();
  float fleft = (float) left;    //floating version
  float right;                   //end of row

  //      left=it.data()->bounding_box().left();
  it.move_to_last ();
  right = it.data ()->bounding_box ().right ();
  plot_blob_list (to_win, row->blob_list (), colour, ScrollView::BROWN);
  to_win->Pen(colour);
  plot_pt = FCOORD (fleft, gradient * left + row->max_y ());
  plot_pt.rotate (rotation);
  to_win->SetCursor(plot_pt.x (), plot_pt.y ());
  plot_pt = FCOORD (fleft, gradient * left + row->min_y ());
  plot_pt.rotate (rotation);
  to_win->DrawTo(plot_pt.x (), plot_pt.y ());
  plot_pt = FCOORD (fleft, gradient * left + row->parallel_c ());
  plot_pt.rotate (rotation);
  to_win->SetCursor(plot_pt.x (), plot_pt.y ());
  plot_pt = FCOORD (right, gradient * right + row->parallel_c ());
  plot_pt.rotate (rotation);
  to_win->DrawTo(plot_pt.x (), plot_pt.y ());
}


/**********************************************************************
 * draw_occupation
 *
 * Draw the row occupation with points above the threshold in white
 * and points below the threshold in black.
 **********************************************************************/

void
draw_occupation (                //draw projection
inT32 xleft,                     //edge of block
inT32 ybottom,                   //bottom of block
inT32 min_y,                     //coordinate limits
inT32 max_y, inT32 occupation[], //projection counts
inT32 thresholds[]               //for drop out
) {
  inT32 line_index;              //pixel coord
  ScrollView::Color colour;                 //of histogram
  float fleft = (float) xleft;   //float version

  colour = ScrollView::WHITE;
  to_win->Pen(colour);
  to_win->SetCursor(fleft, (float) ybottom);
  for (line_index = min_y; line_index <= max_y; line_index++) {
    if (occupation[line_index - min_y] < thresholds[line_index - min_y]) {
      if (colour != ScrollView::BLUE) {
        colour = ScrollView::BLUE;
    to_win->Pen(colour);
      }
    }
    else {
      if (colour != ScrollView::WHITE) {
        colour = ScrollView::WHITE;
    to_win->Pen(colour);
      }
    }
  to_win->DrawTo(fleft + occupation[line_index - min_y] / 10.0,      (float) line_index);
  }
  colour=ScrollView::STEEL_BLUE;
  to_win->Pen(colour);
  to_win->SetCursor(fleft, (float) ybottom);
  for (line_index = min_y; line_index <= max_y; line_index++) {
     to_win->DrawTo(fleft + thresholds[line_index - min_y] / 10.0,      (float) line_index);
  }
}


/**********************************************************************
 * draw_meanlines
 *
 * Draw the meanlines of the given block in the given colour.
 **********************************************************************/

void draw_meanlines(                  //draw a block
                    TO_BLOCK *block,  //block to draw
                    float gradient,   //gradients of lines
                    inT32 left,       //edge of block
                    ScrollView::Color colour,    //colour to draw in
                    FCOORD rotation   //rotation for line
                   ) {
  FCOORD plot_pt;                //point to plot
                                 //rows
  TO_ROW_IT row_it = block->get_rows ();
  TO_ROW *row;                   //current row
  BLOBNBOX_IT blob_it;           //blobs
  float right;                   //end of row
  to_win->Pen(colour);
  for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ()) {
    row = row_it.data ();
    blob_it.set_to_list (row->blob_list ());
    blob_it.move_to_last ();
    right = blob_it.data ()->bounding_box ().right ();
    plot_pt =
      FCOORD ((float) left,
      gradient * left + row->parallel_c () + row->xheight);
    plot_pt.rotate (rotation);
  to_win->SetCursor(plot_pt.x (), plot_pt.y ());
    plot_pt =
      FCOORD ((float) right,
      gradient * right + row->parallel_c () + row->xheight);
    plot_pt.rotate (rotation);
    to_win->DrawTo (plot_pt.x (), plot_pt.y ());
  }
}


/**********************************************************************
 * plot_word_decisions
 *
 * Plot a row with words in different colours and fuzzy spaces
 * highlighted.
 **********************************************************************/

void plot_word_decisions(              //draw words
                         ScrollView* win,   //window tro draw in
                         inT16 pitch,  //of block
                         TO_ROW *row   //row to draw
                        ) {
  ScrollView::Color colour = ScrollView::MAGENTA;       //current colour
  ScrollView::Color rect_colour;            //fuzzy colour
  inT32 prev_x;                  //end of prev blob
  inT16 blob_count;              //blobs in word
  BLOBNBOX *blob;                //current blob
  TBOX blob_box;                  //bounding box
                                 //iterator
  BLOBNBOX_IT blob_it = row->blob_list ();
  BLOBNBOX_IT start_it = blob_it;//word start

  rect_colour = ScrollView::BLACK;
  prev_x = -MAX_INT16;
  blob_count = 0;
  for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ()) {
    blob = blob_it.data ();
    blob_box = blob->bounding_box ();
    if (!blob->joined_to_prev ()
    && blob_box.left () - prev_x > row->max_nonspace) {
      if ((blob_box.left () - prev_x >= row->min_space
        || blob_box.left () - prev_x > row->space_threshold)
      && blob_count > 0) {
        if (pitch > 0 && textord_show_fixed_cuts)
          plot_fp_cells (win, colour, &start_it, pitch, blob_count,
            &row->projection, row->projection_left,
            row->projection_right,
            row->xheight * textord_projection_scale);
        blob_count = 0;
        start_it = blob_it;
      }
      if (colour == ScrollView::MAGENTA)
        colour = ScrollView::RED;
      else
        colour = (ScrollView::Color) (colour + 1);
      if (blob_box.left () - prev_x < row->min_space) {
        if (blob_box.left () - prev_x > row->space_threshold)
          rect_colour = ScrollView::GOLDENROD;
        else
          rect_colour = ScrollView::CORAL;
        //fill_color_index(win, rect_colour);
        win->Brush(rect_colour);
        win->Rectangle (prev_x, blob_box.bottom (),
          blob_box.left (), blob_box.top ());
      }
    }
    if (!blob->joined_to_prev ())
      prev_x = blob_box.right ();
    if (blob->blob () != NULL)
                                 //draw it
      blob->blob ()->plot (win, colour, colour);
    if (blob->cblob () != NULL)
      blob->cblob ()->plot (win, colour, colour);
    if (!blob->joined_to_prev ()
      && (blob->blob () != NULL || blob->cblob () != NULL))
      blob_count++;
  }
  if (pitch > 0 && textord_show_fixed_cuts && blob_count > 0)
    plot_fp_cells (win, colour, &start_it, pitch, blob_count,
      &row->projection, row->projection_left,
      row->projection_right,
      row->xheight * textord_projection_scale);
}


/**********************************************************************
 * plot_fp_cells
 *
 * Make a list of fixed pitch cuts and draw them.
 **********************************************************************/

void plot_fp_cells(                        //draw words
                   ScrollView* win,             //window tro draw in
                   ScrollView::Color colour,          //colour of lines
                   BLOBNBOX_IT *blob_it,   //blobs
                   inT16 pitch,            //of block
                   inT16 blob_count,       //no of real blobs
                   STATS *projection,      //vertical
                   inT16 projection_left,  //edges //scale factor
                   inT16 projection_right,
                   float projection_scale) {
  inT16 occupation;              //occupied cells
  TBOX word_box;                  //bounding box
  FPSEGPT_LIST seg_list;         //list of cuts
  FPSEGPT_IT seg_it;
  FPSEGPT *segpt;                //current point

  if (pitsync_linear_version)
    check_pitch_sync2 (blob_it, blob_count, pitch, 2, projection,
      projection_left, projection_right,
      projection_scale, occupation, &seg_list, 0, 0);
  else
    check_pitch_sync (blob_it, blob_count, pitch, 2, projection, &seg_list);
  word_box = blob_it->data ()->bounding_box ();
  for (; blob_count > 0; blob_count--)
    word_box += box_next (blob_it);
  seg_it.set_to_list (&seg_list);
  for (seg_it.mark_cycle_pt (); !seg_it.cycled_list (); seg_it.forward ()) {
    segpt = seg_it.data ();
    if (segpt->faked) {
         colour = ScrollView::WHITE;
         win->Pen(colour);  }
    else {
      win->Pen(colour); }
    win->Line(segpt->position (), word_box.bottom (),segpt->position (), word_box.top ());
  }
}


/**********************************************************************
 * plot_fp_cells2
 *
 * Make a list of fixed pitch cuts and draw them.
 **********************************************************************/

void plot_fp_cells2(                        //draw words
                    ScrollView* win,             //window tro draw in
                    ScrollView::Color colour,          //colour of lines
                    TO_ROW *row,            //for location
                    FPSEGPT_LIST *seg_list  //segments to plot
                   ) {
  TBOX word_box;                  //bounding box
  FPSEGPT_IT seg_it = seg_list;
                                 //blobs in row
  BLOBNBOX_IT blob_it = row->blob_list ();
  FPSEGPT *segpt;                //current point

  word_box = blob_it.data ()->bounding_box ();
  for (blob_it.mark_cycle_pt (); !blob_it.cycled_list ();)
    word_box += box_next (&blob_it);
  for (seg_it.mark_cycle_pt (); !seg_it.cycled_list (); seg_it.forward ()) {
    segpt = seg_it.data ();
    if (segpt->faked) {
         colour = ScrollView::WHITE;
         win->Pen(colour); }
    else {
     win->Pen(colour); }
     win->Line(segpt->position (), word_box.bottom (),segpt->position (), word_box.top ());
  }
}


/**********************************************************************
 * plot_row_cells
 *
 * Make a list of fixed pitch cuts and draw them.
 **********************************************************************/

void plot_row_cells(                       //draw words
                    ScrollView* win,            //window tro draw in
                    ScrollView::Color colour,         //colour of lines
                    TO_ROW *row,           //for location
                    float xshift,          //amount of shift
                    ICOORDELT_LIST *cells  //cells to draw
                   ) {
  TBOX word_box;                  //bounding box
  ICOORDELT_IT cell_it = cells;
                                 //blobs in row
  BLOBNBOX_IT blob_it = row->blob_list ();
  ICOORDELT *cell;               //current cell

  word_box = blob_it.data ()->bounding_box ();
  for (blob_it.mark_cycle_pt (); !blob_it.cycled_list ();)
    word_box += box_next (&blob_it);
  win->Pen(colour);
  for (cell_it.mark_cycle_pt (); !cell_it.cycled_list (); cell_it.forward ()) {
    cell = cell_it.data ();
    win->Line(cell->x () + xshift, word_box.bottom (), cell->x () + xshift, word_box.top ());
  }
}

#endif  // GRAPHICS_DISABLED
/////////////////////////////////////////////////////////////////drawtord////////////////////////////////////////

/////////////////////////////////////////////////////////////////gap_map////////////////////////////////////////
#define EXTERN
EXTERN BOOL_VAR (gapmap_debug, FALSE, "Say which blocks have tables");
EXTERN BOOL_VAR (gapmap_use_ends, FALSE,
"Use large space at start and end of rows");
EXTERN BOOL_VAR (gapmap_no_isolated_quanta, FALSE,
"Ensure gaps not less than 2quanta wide");
EXTERN double_VAR (gapmap_big_gaps, 1.75, "xht multiplier");

/*************************************************************************
 * A block gap map is a quantised histogram of whitespace regions in the
 * block. It is a vertical projection of wide gaps WITHIN lines
 *
 * The map is held as an array of counts of rows which have a wide gap
 * covering that region of the row. Each bucket in the map represents a width
 * of about half an xheight - (The median of the xhts in the rows is used.)
 *
 * The block is considered RECTANGULAR - delimited by the left and right
 * extremes of the rows in the block. However, ONLY wide gaps WITHIN a row are
 * counted.
 *
 *************************************************************************/

GAPMAP::GAPMAP(                 //Constructor
               TO_BLOCK *block  //block
              ) {
  TO_ROW_IT row_it;              //row iterator
  TO_ROW *row;                   //current row
  BLOBNBOX_IT blob_it;           //iterator
  TBOX blob_box;
  TBOX prev_blob_box;
  inT16 gap_width;
  inT16 start_of_row;
  inT16 end_of_row;
  STATS xht_stats (0, 128);
  inT16 min_quantum;
  inT16 max_quantum;
  inT16 i;

  row_it.set_to_list (block->get_rows ());
  /*
    Find left and right extremes and bucket size
  */
  map = NULL;
  min_left = MAX_INT16;
  max_right = -MAX_INT16;
  total_rows = 0;
  any_tabs = FALSE;
  for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ()) {
    row = row_it.data ();
    if (!row->blob_list ()->empty ()) {
      total_rows++;
      xht_stats.add ((inT16) floor (row->xheight + 0.5), 1);
      blob_it.set_to_list (row->blob_list ());
      start_of_row = blob_it.data ()->bounding_box ().left ();
      end_of_row = blob_it.data_relative (-1)->bounding_box ().right ();
      if (min_left > start_of_row)
        min_left = start_of_row;
      if (max_right < end_of_row)
        max_right = end_of_row;
    }
  }
  if ((total_rows < 3) || (min_left >= max_right)) {
    total_rows = 0;
    min_left = max_right = 0;
    return;
  }
  bucket_size = (inT16) floor (xht_stats.median () + 0.5) / 2;
  map_max = (max_right - min_left) / bucket_size;
  map = (inT16 *) alloc_mem ((map_max + 1) * sizeof (inT16));
  for (i = 0; i <= map_max; i++)
    map[i] = 0;

  for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ()) {
    row = row_it.data ();
    if (!row->blob_list ()->empty ()) {
      blob_it.set_to_list (row->blob_list ());
      blob_it.mark_cycle_pt ();
      blob_box = box_next (&blob_it);
      prev_blob_box = blob_box;
      if (gapmap_use_ends) {
        /* Leading space */
        gap_width = blob_box.left () - min_left;
        if ((gap_width > gapmap_big_gaps * row->xheight)
        && gap_width > 2) {
          max_quantum = (blob_box.left () - min_left) / bucket_size;
          for (i = 0; i <= max_quantum; i++)
            map[i]++;
        }
      }
      while (!blob_it.cycled_list ()) {
        blob_box = box_next (&blob_it);
        gap_width = blob_box.left () - prev_blob_box.right ();
        if ((gap_width > gapmap_big_gaps * row->xheight)
        && gap_width > 2) {
          min_quantum =
            (prev_blob_box.right () - min_left) / bucket_size;
          max_quantum = (blob_box.left () - min_left) / bucket_size;
          for (i = min_quantum; i <= max_quantum; i++)
            map[i]++;
        }
        prev_blob_box = blob_box;
      }
      if (gapmap_use_ends) {
        /* Trailing space */
        gap_width = max_right - prev_blob_box.right ();
        if ((gap_width > gapmap_big_gaps * row->xheight)
        && gap_width > 2) {
          min_quantum =
            (prev_blob_box.right () - min_left) / bucket_size;
          for (i = min_quantum; i <= map_max; i++)
            map[i]++;
        }
      }
    }
  }
  for (i = 0; i <= map_max; i++) {
    if (map[i] > total_rows / 2) {
      if (gapmap_no_isolated_quanta &&
        (((i == 0) &&
        (map[i + 1] <= total_rows / 2)) ||
        ((i == map_max) &&
        (map[i - 1] <= total_rows / 2)) ||
        ((i > 0) &&
        (i < map_max) &&
        (map[i - 1] <= total_rows / 2) &&
      (map[i + 1] <= total_rows / 2)))) {
        map[i] = 0;              //prevent isolated quantum
      }
      else
        any_tabs = TRUE;
    }
  }
  if (gapmap_debug && any_tabs)
    tprintf ("Table found\n");
}


/*************************************************************************
 * GAPMAP::table_gap()
 * Is there a bucket in the specified range where more than half the rows in the
 * block have a wide gap?
 *************************************************************************/

BOOL8 GAPMAP::table_gap(             //Is gap a table?
                        inT16 left,  //From here
                        inT16 right  //To here
                       ) {
  inT16 min_quantum;
  inT16 max_quantum;
  inT16 i;
  BOOL8 tab_found = FALSE;

  if (!any_tabs)
    return FALSE;

  min_quantum = (left - min_left) / bucket_size;
  max_quantum = (right - min_left) / bucket_size;
  for (i = min_quantum; (!tab_found && (i <= max_quantum)); i++)
    if (map[i] > total_rows / 2)
      tab_found = TRUE;
  return tab_found;
}
/////////////////////////////////////////////////////////////////gap_map////////////////////////////////////////

/////////////////////////////////////////////////////////////////tospace////////////////////////////////////////
BOOL_VAR(tosp_old_to_method, FALSE, "Space stats use prechopping?");
BOOL_VAR(tosp_only_use_prop_rows, TRUE, "Block stats to use fixed pitch rows?");
BOOL_VAR(tosp_force_wordbreak_on_punct, FALSE, "Force word breaks on punct to break long lines in non-space delimited langs");
BOOL_VAR(tosp_use_pre_chopping, FALSE, "Space stats use prechopping?");
BOOL_VAR(tosp_old_to_bug_fix, FALSE, "Fix suspected bug in old code");
BOOL_VAR(tosp_block_use_cert_spaces, TRUE, "Only stat OBVIOUS spaces");
BOOL_VAR(tosp_row_use_cert_spaces, TRUE, "Only stat OBVIOUS spaces");
BOOL_VAR(tosp_narrow_blobs_not_cert, TRUE, "Only stat OBVIOUS spaces");
BOOL_VAR(tosp_row_use_cert_spaces1, TRUE, "Only stat OBVIOUS spaces");
BOOL_VAR(tosp_recovery_isolated_row_stats, TRUE, "Use row alone when inadequate cert spaces");
BOOL_VAR(tosp_only_small_gaps_for_kern, FALSE, "Better guess");
BOOL_VAR(tosp_all_flips_fuzzy, FALSE, "Pass ANY flip to context?");
BOOL_VAR(tosp_fuzzy_limit_all, TRUE, "Dont restrict kn->sp fuzzy limit to tables");
BOOL_VAR(tosp_stats_use_xht_gaps, TRUE, "Use within xht gap for wd breaks");
BOOL_VAR(tosp_use_xht_gaps, TRUE, "Use within xht gap for wd breaks");
BOOL_VAR(tosp_only_use_xht_gaps, FALSE, "Only use within xht gap for wd breaks");
BOOL_VAR(tosp_rule_9_test_punct, FALSE, "Dont chng kn to space next to punct");
BOOL_VAR(tosp_flip_fuzz_kn_to_sp, TRUE, "Default flip");
BOOL_VAR(tosp_flip_fuzz_sp_to_kn, TRUE, "Default flip");
BOOL_VAR(tosp_improve_thresh, FALSE, "Enable improvement heuristic");
INT_VAR(tosp_debug_level, 0, "Debug data");
INT_VAR(tosp_enough_space_samples_for_median, 3, "or should we use mean");
INT_VAR(tosp_redo_kern_limit, 10, "No.samples reqd to reestimate for row");
INT_VAR(tosp_few_samples, 40, "No.gaps reqd with 1 large gap to treat as a table");
INT_VAR(tosp_short_row, 20, "No.gaps reqd with few cert spaces to use certs");
INT_VAR(tosp_sanity_method, 1, "How to avoid being silly");
double_VAR(tosp_threshold_bias1, 0, "how far between kern and space?");
double_VAR(tosp_threshold_bias2, 0, "how far between kern and space?");
double_VAR(tosp_narrow_fraction, 0.3, "Fract of xheight for narrow");
double_VAR(tosp_narrow_aspect_ratio, 0.48, "narrow if w/h less than this");
double_VAR(tosp_wide_fraction, 0.52, "Fract of xheight for wide");
double_VAR(tosp_wide_aspect_ratio, 0.0, "wide if w/h less than this");
double_VAR(tosp_fuzzy_space_factor, 0.6, "Fract of xheight for fuzz sp");
double_VAR(tosp_fuzzy_space_factor1, 0.5, "Fract of xheight for fuzz sp");
double_VAR(tosp_fuzzy_space_factor2, 0.72, "Fract of xheight for fuzz sp");
double_VAR(tosp_gap_factor, 0.83, "gap ratio to flip sp->kern");
double_VAR(tosp_kern_gap_factor1, 2.0, "gap ratio to flip kern->sp");
double_VAR(tosp_kern_gap_factor2, 1.3, "gap ratio to flip kern->sp");
double_VAR(tosp_kern_gap_factor3, 2.5, "gap ratio to flip kern->sp");
double_VAR(tosp_ignore_big_gaps, -1, "xht multiplier");
double_VAR(tosp_ignore_very_big_gaps, 3.5, "xht multiplier");
double_VAR(tosp_rep_space, 1.6, "rep gap multiplier for space");
double_VAR(tosp_enough_small_gaps, 0.65, "Fract of kerns reqd for isolated row stats");
double_VAR(tosp_table_kn_sp_ratio, 2.25, "Min difference of kn & sp in table");
double_VAR(tosp_table_xht_sp_ratio, 0.33, "Expect spaces bigger than this");
double_VAR(tosp_table_fuzzy_kn_sp_ratio, 3.0, "Fuzzy if less than this");
double_VAR(tosp_fuzzy_kn_fraction, 0.5, "New fuzzy kn alg");
double_VAR(tosp_fuzzy_sp_fraction, 0.5, "New fuzzy sp alg");
double_VAR(tosp_min_sane_kn_sp, 1.5, "Dont trust spaces less than this time kn");
double_VAR(tosp_init_guess_kn_mult, 2.2, "Thresh guess - mult kn by this");
double_VAR(tosp_init_guess_xht_mult, 0.28, "Thresh guess - mult xht by this");
double_VAR(tosp_max_sane_kn_thresh, 5.0, "Multiplier on kn to limit thresh");
double_VAR(tosp_flip_caution, 0.0, "Dont autoflip kn to sp when large separation");
double_VAR(tosp_large_kerning, 0.19, "Limit use of xht gap with large kns");
double_VAR(tosp_dont_fool_with_small_kerns, -1, "Limit use of xht gap with odd small kns");
double_VAR(tosp_near_lh_edge, 0, "Dont reduce box if the top left is non blank");
double_VAR(tosp_silly_kn_sp_gap, 0.2, "Dont let sp minus kn get too small");
double_VAR(tosp_pass_wide_fuzz_sp_to_context, 0.75, "How wide fuzzies need context");

#define MAXSPACING      128      /*max expected spacing in pix */
/**********************************************************************
 * to_spacing
 *
 * Compute fuzzy word spacing thresholds for each row.
 * I.e. set :   max_nonspace
 *							space_threshold
 *							min_space
 *							kern_size
 *							space_size     for each row.
 * ONLY FOR PROPORTIONAL BLOCKS - FIXED PITCH IS ASSUMED ALREADY DONE
 **********************************************************************/

void to_spacing(                       //set spacing
                ICOORD page_tr,        //topright of page
                TO_BLOCK_LIST *blocks  //blocks on page
               )
{
  Q_UNUSED(page_tr);
  TO_BLOCK_IT block_it;          //iterator
  TO_BLOCK *block;               //current block;
  TO_ROW_IT row_it;              //row iterator
  TO_ROW *row;                   //current row
  int block_index;               //block number
  int row_index;                 //row number
  inT16 block_space_gap_width;   //Estimated width of    real spaces for whole block

  //Estimate width ofnon space gaps for whole block
  inT16 block_non_space_gap_width;

  //Old fixed/prop result
  BOOL8 old_text_ord_proportional;
  GAPMAP *gapmap = NULL;         //map of big vert gaps in blk

  block_it.set_to_list (blocks);
  block_index = 1;
  for (block_it.mark_cycle_pt(); !block_it.cycled_list();
  block_it.forward())
  {
    block = block_it.data();
    gapmap = new GAPMAP (block);
    block_spacing_stats(block, gapmap, old_text_ord_proportional, block_space_gap_width, block_non_space_gap_width);
    row_it.set_to_list(block->get_rows());
    row_index = 1;

    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
    {
      row = row_it.data();
      if ((row->pitch_decision == PITCH_DEF_PROP) || (row->pitch_decision == PITCH_CORR_PROP))
      {
        if ((tosp_debug_level > 0) && !old_text_ord_proportional)
        {
            tprintf ("Block %d Row %d: Now Proportional\n", block_index, row_index);
        }

        row_spacing_stats(row, gapmap, block_index, row_index, block_space_gap_width, block_non_space_gap_width);
      }
      else
      {
        if ((tosp_debug_level > 0) && old_text_ord_proportional)
        {
          tprintf("Block %d Row %d: Now Fixed Pitch Decision:%d fp flag:%f\n", block_index, row_index, row->pitch_decision, row->fixed_pitch);
        }
      }
#ifndef GRAPHICS_DISABLED
      if (textord_show_initial_words)
        plot_word_decisions(to_win, (inT16) row->fixed_pitch, row);
#endif
      row_index++;
    }
    delete gapmap;
    block_index++;
  }
}


/*************************************************************************
 * block_spacing_stats()
 *************************************************************************/

void block_spacing_stats(                                  //DEBUG USE ONLY
                         TO_BLOCK *block,
                         GAPMAP *gapmap,
                         BOOL8 &old_text_ord_proportional,
                         inT16 &block_space_gap_width,     //resulting estimate
                         inT16 &block_non_space_gap_width  //resulting estimate
                        )
{
  TO_ROW_IT row_it;              //row iterator
  TO_ROW *row;                   //current row
  BLOBNBOX_IT blob_it;           //iterator

  STATS centre_to_centre_stats(0, MAXSPACING);

  //DEBUG USE ONLY
  STATS all_gap_stats(0, MAXSPACING);
  STATS space_gap_stats(0, MAXSPACING);
  inT16 minwidth = MAX_INT16;    //narrowest blob
  TBOX blob_box;
  TBOX prev_blob_box;
  inT16 centre_to_centre;
  inT16 gap_width;
  float real_space_threshold;
  float iqr_centre_to_centre;    //DEBUG USE ONLY
  float iqr_all_gap_stats;       //DEBUG USE ONLY
  inT32 end_of_row;
  inT32 row_length;

  row_it.set_to_list (block->get_rows());
  for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
  {
    row = row_it.data();

    if (!row->blob_list ()->empty () && (!tosp_only_use_prop_rows || (row->pitch_decision == PITCH_DEF_PROP) || (row->pitch_decision == PITCH_CORR_PROP)))
    {
      blob_it.set_to_list (row->blob_list ());
      blob_it.mark_cycle_pt ();
      end_of_row = blob_it.data_relative (-1)->bounding_box ().right ();

      if (tosp_use_pre_chopping)
      {
        blob_box = box_next_pre_chopped (&blob_it);
      }
      else if (tosp_stats_use_xht_gaps)
      {
        blob_box = reduced_box_next (row, &blob_it);
      }
      else
      {
        blob_box = box_next (&blob_it);
      }

      row_length = end_of_row - blob_box.left ();

      if (blob_box.width () < minwidth)
      {
        minwidth = blob_box.width ();
      }
      prev_blob_box = blob_box;

      while (!blob_it.cycled_list ())
      {
        if (tosp_use_pre_chopping)
        {
          blob_box = box_next_pre_chopped (&blob_it);
        }
        else if (tosp_stats_use_xht_gaps)
        {
          blob_box = reduced_box_next (row, &blob_it);
        }
        else
        {
          blob_box = box_next (&blob_it);
        }

        if (blob_box.width () < minwidth)
        {
          minwidth = blob_box.width();
        }

        gap_width = blob_box.left() - prev_blob_box.right();
        if (!ignore_big_gap (row, row_length, gapmap, prev_blob_box.right(), blob_box.left()))
        {
          all_gap_stats.add(gap_width, 1);

          centre_to_centre = (blob_box.left() + blob_box.right() - (prev_blob_box.left() + prev_blob_box.right())) / 2;

          //DEBUG
          centre_to_centre_stats.add(centre_to_centre, 1);
          // DEBUG
        }
        prev_blob_box = blob_box;
      }
    }
  }


  //Inadequate samples
  if (all_gap_stats.get_total () <= 1)
  {
    block_non_space_gap_width = minwidth;
    block_space_gap_width = -1;  //No est. space width

    //DEBUG
    old_text_ord_proportional = TRUE;
  }
  else
  {
    /* For debug only ..... */
    iqr_centre_to_centre = centre_to_centre_stats.ile (0.75) - centre_to_centre_stats.ile (0.25);
    iqr_all_gap_stats = all_gap_stats.ile (0.75) - all_gap_stats.ile (0.25);
    old_text_ord_proportional = iqr_centre_to_centre * 2 > iqr_all_gap_stats;
    /* .......For debug only */

    /*
    The median of the gaps is used as an estimate of the NON-SPACE gap width.
    This RELIES on the assumption that there are more gaps WITHIN words than
    BETWEEN words in a block

    Now try to estimate the width of a real space for all real spaces in the
    block. Do this by using a crude threshold to ignore "narrow" gaps, then
    find the median of the "wide" gaps and use this.
    */
    block_non_space_gap_width = (inT16) floor (all_gap_stats.median ());
    // median gap

    row_it.set_to_list (block->get_rows ());
    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
      row = row_it.data ();
      if (!row->blob_list ()->empty () && (!tosp_only_use_prop_rows || (row->pitch_decision == PITCH_DEF_PROP) || (row->pitch_decision == PITCH_CORR_PROP)))
      {
        real_space_threshold = MAX (tosp_init_guess_kn_mult * block_non_space_gap_width, tosp_init_guess_xht_mult * row->xheight);
        blob_it.set_to_list (row->blob_list ());
        blob_it.mark_cycle_pt ();

        end_of_row = blob_it.data_relative (-1)->bounding_box ().right ();

        if (tosp_use_pre_chopping)
        {
          blob_box = box_next_pre_chopped (&blob_it);
        }
        else if (tosp_stats_use_xht_gaps)
        {
          blob_box = reduced_box_next (row, &blob_it);
        }
        else
        {
          blob_box = box_next (&blob_it);
        }

        row_length = blob_box.left () - end_of_row;
        prev_blob_box = blob_box;

        while (!blob_it.cycled_list ())
        {
          if (tosp_use_pre_chopping)
          {
            blob_box = box_next_pre_chopped (&blob_it);
          }
          else if (tosp_stats_use_xht_gaps)
          {
            blob_box = reduced_box_next (row, &blob_it);
          }
          else
          {
            blob_box = box_next (&blob_it);
          }
          gap_width = blob_box.left () - prev_blob_box.right ();

          if ((gap_width > real_space_threshold) && !ignore_big_gap (row, row_length, gapmap, prev_blob_box.right (), blob_box.left ()))
          {
            /*
            If tosp_use_cert_spaces is enabled, the estimate of the space gap is
            restricted to obvious spaces - those wider than half the xht or those
            with wide blobs on both sides - i.e not things that are suspect 1's or
            punctiation that is sometimes widely spaced.
            */
            if (!tosp_block_use_cert_spaces || (gap_width > tosp_fuzzy_space_factor2 * row->xheight) || ((gap_width > tosp_fuzzy_space_factor1 * row->xheight)
              && (!tosp_narrow_blobs_not_cert || (!narrow_blob (row, prev_blob_box) && !narrow_blob (row, blob_box)))) || (wide_blob (row, prev_blob_box)
              && wide_blob (row, blob_box)))
            {
                space_gap_stats.add (gap_width, 1);
            }
          }
          prev_blob_box = blob_box;
        }
      }
    }

    //Inadequate samples
    if (space_gap_stats.get_total () <= 2)
    {
      block_space_gap_width = -1;//No est. space width
    }
    else
    {
      block_space_gap_width = MAX ((inT16) floor (space_gap_stats.median ()), 3 * block_non_space_gap_width);
    }
  }
}


/*************************************************************************
 * row_spacing_stats()
 * Set values for min_space, max_non_space based on row stats only
 * If failure - return 0 values.
 *************************************************************************/

void row_spacing_stats(                                 //estimate for block
                       TO_ROW *row,
                       GAPMAP *gapmap,
                       inT16 block_idx,
                       inT16 row_idx,
                       inT16 block_space_gap_width,
                       inT16 block_non_space_gap_width  //estimate for block
                      )
{
  //iterator
  BLOBNBOX_IT blob_it = row->blob_list ();
  STATS all_gap_stats (0, MAXSPACING);
  STATS cert_space_gap_stats (0, MAXSPACING);
  STATS all_space_gap_stats (0, MAXSPACING);
  STATS small_gap_stats (0, MAXSPACING);
  TBOX blob_box;
  TBOX prev_blob_box;
  inT16 gap_width;
  inT16 real_space_threshold = 0;
  inT16 max = 0;
  inT16 index;
  inT16 large_gap_count = 0;
  BOOL8 suspected_table;
  inT32 max_max_nonspace;        //upper bound
  BOOL8 good_block_space_estimate = block_space_gap_width > 0;
  inT32 end_of_row;
  inT32 row_length = 0;
  float sane_space;
  inT32 sane_threshold;

  /* Collect first pass stats for row */

  if (!good_block_space_estimate)
  {
    block_space_gap_width = inT16 (floor (row->xheight / 2));
  }

  if (!row->blob_list ()->empty ())
  {
    if (tosp_threshold_bias1 > 0)
    {
      real_space_threshold = block_non_space_gap_width + inT16 (floor (0.5 + tosp_threshold_bias1 * (block_space_gap_width - block_non_space_gap_width)));
    }
    else
    {
      real_space_threshold = (block_space_gap_width + block_non_space_gap_width) / 2; //Old TO method
    }

    blob_it.set_to_list (row->blob_list ());
    blob_it.mark_cycle_pt ();
    end_of_row = blob_it.data_relative (-1)->bounding_box ().right ();

    if (tosp_use_pre_chopping)
    {
      blob_box = box_next_pre_chopped (&blob_it);
    }
    else if (tosp_stats_use_xht_gaps)
    {
      blob_box = reduced_box_next (row, &blob_it);
    }
    else
    {
      blob_box = box_next (&blob_it);
    }

    row_length = end_of_row - blob_box.left ();
    prev_blob_box = blob_box;

    while (!blob_it.cycled_list ())
    {
      if (tosp_use_pre_chopping)
      {
        blob_box = box_next_pre_chopped (&blob_it);
      }
      else if (tosp_stats_use_xht_gaps)
      {
        blob_box = reduced_box_next (row, &blob_it);
      }
      else
      {
        blob_box = box_next (&blob_it);
      }
      gap_width = blob_box.left () - prev_blob_box.right ();

      if (ignore_big_gap (row, row_length, gapmap, prev_blob_box.right (), blob_box.left ()))
      {
        large_gap_count++;
      }
      else
      {
        if (gap_width >= real_space_threshold)
        {
          if (!tosp_row_use_cert_spaces || (gap_width > tosp_fuzzy_space_factor2 * row->xheight) ||
            ((gap_width > tosp_fuzzy_space_factor1 * row->xheight) && (!tosp_narrow_blobs_not_cert
            || (!narrow_blob (row, prev_blob_box) && !narrow_blob (row, blob_box))))
            || (wide_blob (row, prev_blob_box) && wide_blob (row, blob_box)))
          {
            cert_space_gap_stats.add (gap_width, 1);
          }

          all_space_gap_stats.add (gap_width, 1);
        }
        else
        {
          small_gap_stats.add (gap_width, 1);
        }

        all_gap_stats.add (gap_width, 1);
      }

      prev_blob_box = blob_box;
    }
  }

  suspected_table = (large_gap_count > 1) || ((large_gap_count > 0) && (all_gap_stats.get_total () <= tosp_few_samples));

  /* Now determine row kern size, space size and threshold */

  if ((cert_space_gap_stats.get_total () >= tosp_enough_space_samples_for_median) ||
    ((suspected_table || all_gap_stats.get_total () <= tosp_short_row) && cert_space_gap_stats.get_total () > 0))
  {
    old_to_method(row, &all_gap_stats, &cert_space_gap_stats, &small_gap_stats, block_space_gap_width,block_non_space_gap_width);
  }
  else
  {
    if (!tosp_recovery_isolated_row_stats || !isolated_row_stats (row, gapmap, &all_gap_stats, suspected_table, block_idx, row_idx))
    {
      if (tosp_row_use_cert_spaces && (tosp_debug_level > 5))
      {
        tprintf ("B:%d R:%d -- Inadequate certain spaces.\n", block_idx, row_idx);
      }

      if (tosp_row_use_cert_spaces1 && good_block_space_estimate)
      {
        //Use block default
        row->space_size = block_space_gap_width;

        if (all_gap_stats.get_total () > tosp_redo_kern_limit)
        {
          row->kern_size = all_gap_stats.median ();
        }
        else
        {
          row->kern_size = block_non_space_gap_width;
        }

        row->space_threshold = inT32 (floor ((row->space_size + row->kern_size) / 2));
      }
      else
      {
        old_to_method(row, &all_gap_stats, &all_space_gap_stats, &small_gap_stats, block_space_gap_width, block_non_space_gap_width);
      }
    }
  }

  if (tosp_improve_thresh && !suspected_table)
    improve_row_threshold(row, &all_gap_stats);

  /* Now lets try to be careful not to do anything silly with tables when we
  are ignoring big gaps*/
  if (tosp_sanity_method == 0)
  {
    if (suspected_table && (row->space_size < tosp_table_kn_sp_ratio * row->kern_size))
    {
      if (tosp_debug_level > 0)
      {
        tprintf ("B:%d R:%d -- DONT BELIEVE SPACE %3.2f %d %3.2f.\n", block_idx, row_idx, row->kern_size, row->space_threshold, row->space_size);
      }

      row->space_threshold = (inT32) (tosp_table_kn_sp_ratio * row->kern_size);
      row->space_size = MAX (row->space_threshold + 1, row->xheight);
    }
  }
  else if (tosp_sanity_method == 1)
  {
    sane_space = row->space_size;

    /* NEVER let space size get too close to kern size */
    if ((row->space_size < tosp_min_sane_kn_sp * MAX (row->kern_size, 2.5)) || ((row->space_size - row->kern_size) < (tosp_silly_kn_sp_gap * row->xheight)))
    {
      if (good_block_space_estimate && (block_space_gap_width >= tosp_min_sane_kn_sp * row->kern_size))
      {
        sane_space = block_space_gap_width;
      }
      else
      {
        sane_space = MAX (tosp_min_sane_kn_sp * MAX (row->kern_size, 2.5), row->xheight / 2);
      }

      if (tosp_debug_level > 0)
      {
        tprintf("B:%d R:%d -- DONT BELIEVE SPACE %3.2f %d %3.2f -> %3.2f.\n", block_idx, row_idx, row->kern_size, row->space_threshold, row->space_size, sane_space);
      }
      row->space_size = sane_space;
      row->space_threshold = inT32 (floor ((row->space_size + row->kern_size) / 2));
    }

    /* NEVER let threshold get VERY far away from kern */
    sane_threshold = inT32 (floor (tosp_max_sane_kn_thresh * MAX (row->kern_size, 2.5)));

    if (row->space_threshold > sane_threshold)
    {
      if (tosp_debug_level > 0)
      {
        tprintf("B:%d R:%d -- DONT BELIEVE THRESH %3.2f %d %3.2f->%d.\n", block_idx, row_idx, row->kern_size, row->space_threshold, row->space_size, sane_threshold);
      }

      row->space_threshold = sane_threshold;

      if (row->space_size <= sane_threshold)
      {
        row->space_size = row->space_threshold + 1.0f;
      }
    }

    /* Beware of tables - there may be NO spaces */
    if (suspected_table)
    {
      sane_space = MAX (tosp_table_kn_sp_ratio * row->kern_size, tosp_table_xht_sp_ratio * row->xheight);
      sane_threshold = inT32 (floor ((sane_space + row->kern_size) / 2));

      if ((row->space_size < sane_space) || (row->space_threshold < sane_threshold))
      {
        if (tosp_debug_level > 0)
        {
          tprintf ("B:%d R:%d -- SUSPECT NO SPACES %3.2f %d %3.2f.\n", block_idx, row_idx, row->kern_size, row->space_threshold, row->space_size);
        }

        //the minimum sane value
        row->space_threshold = (inT32) sane_space;
        row->space_size = MAX (row->space_threshold + 1, row->xheight);
      }
    }
  }

  /* Now lets try to put some error limits on the threshold */

  if (tosp_old_to_method)
  {
    /* Old textord made a space if gap >= threshold */
    //NO FUZZY SPACES YET
    row->max_nonspace = row->space_threshold;

    //NO FUZZY SPACES       YET
    row->min_space = row->space_threshold + 1;
  }
  else
  {
    /* Any gap greater than 0.6 x-ht is bound to be a space (isn't it:-) */
    row->min_space = MIN (inT32 (ceil (tosp_fuzzy_space_factor * row->xheight)), inT32 (row->space_size));

    if (row->min_space <= row->space_threshold)
    {
      //Dont be silly
      row->min_space = row->space_threshold + 1;
    }

    /*
    Lets try to guess the max certain kern gap by looking at the cluster of
    kerns for the row. The row is proportional so the kerns should cluster
    tightly at the bottom of the distribution. We also expect most gaps to be
    kerns. Find the maximum of the kern piles between 0 and twice the kern
    estimate. Piles before the first one with less than 1/10 the maximum
    number of samples can be taken as certain kerns.

      Of course, there are some cases where the kern peak and space peaks merge,
      so we will put an UPPER limit on the max certain kern gap of some fraction
      below the threshold.
    */

    max_max_nonspace = inT32 ((row->space_threshold + row->kern_size) / 2);

    //default
    row->max_nonspace = max_max_nonspace;
    for (index = 0; index <= max_max_nonspace; index++)
    {
      if (all_gap_stats.pile_count (index) > max)
      {
        max = all_gap_stats.pile_count (index);
      }

      if ((index > row->kern_size) && (all_gap_stats.pile_count (index) < 0.1 * max))
      {
        row->max_nonspace = index;
        break;
      }
    }
  }

  /* Yet another algorithm - simpler this time - just choose a fraction of the
  threshold to space range */

  if ((tosp_fuzzy_sp_fraction > 0) && (row->space_size > row->space_threshold))
  {
    row->min_space = MAX (row->min_space, (inT32) ceil (row->space_threshold + tosp_fuzzy_sp_fraction * (row->space_size - row->space_threshold)));
  }

  /* Ensure that ANY space less than some multiplier times the kern size is
  fuzzy.  In tables there is a risk of erroneously setting a small space size
  when there are no real spaces. Sometimes tables have text squashed into
  columns so that the kn->sp ratio is small anyway - this means that we cant
  use this to force a wider separation - hence we rely on context to join any
  dubious breaks. */

  if ((tosp_table_fuzzy_kn_sp_ratio > 0) && (suspected_table || tosp_fuzzy_limit_all))
  {
      row->min_space = MAX(row->min_space, (inT32) ceil (tosp_table_fuzzy_kn_sp_ratio * row->kern_size));
  }

  if ((tosp_fuzzy_kn_fraction > 0) && (row->kern_size < row->space_threshold))
  {
    row->max_nonspace = (inT32) floor (0.5 + row->kern_size + tosp_fuzzy_kn_fraction * (row->space_threshold - row->kern_size));
  }

  if (row->max_nonspace > row->space_threshold)
  {
    //Dont be silly
    row->max_nonspace = row->space_threshold;
  }

  if (tosp_debug_level > 5)
  {
    tprintf("B:%d R:%d L:%d-- Kn:%d Sp:%d Thr:%d -- Kn:%3.2f (%d) Thr:%d (%d) Sp:%3.2f\n",
      block_idx, row_idx, row_length, block_non_space_gap_width,
      block_space_gap_width, real_space_threshold, row->kern_size,
      row->max_nonspace, row->space_threshold, row->min_space,
      row->space_size);
  }
}


void old_to_method(                                 //estimate for block
                   TO_ROW *row,
                   STATS *all_gap_stats,
                   STATS *space_gap_stats,
                   STATS *small_gap_stats,
                   inT16 block_space_gap_width,
                   inT16 block_non_space_gap_width  //estimate for block
                  )
{
  /* Old to condition was > 2 */
  if (space_gap_stats->get_total () >= tosp_enough_space_samples_for_median)
  {
  //Adequate samples
    /* Set space size to median of spaces BUT limits it if it seems wildly out */
    row->space_size = space_gap_stats->median ();
    if (row->space_size > block_space_gap_width * 1.5)
    {
      if (tosp_old_to_bug_fix)
      {
        row->space_size = block_space_gap_width * 1.5;
      }
      else
      {
       //BUG??? should be *1.5
        row->space_size = block_space_gap_width;
      }
    }
    if (row->space_size < (block_non_space_gap_width * 2) + 1)
    {
      row->space_size = (block_non_space_gap_width * 2) + 1;
    }
  }
  else if (space_gap_stats->get_total () >= 1) //Only 1 or 2 samples
  {
    //hence mean not median
    row->space_size = space_gap_stats->mean ();

    if (row->space_size > block_space_gap_width * 1.5)
    {
      if (tosp_old_to_bug_fix)
      {
        row->space_size = block_space_gap_width * 1.5;
      }
      else //BUG??? should be *1.5
      {
        row->space_size = block_space_gap_width;
      }
    }

    if (row->space_size < (block_non_space_gap_width * 3) + 1)
    {
      row->space_size = (block_non_space_gap_width * 3) + 1;
    }
  }
  else //Use block default
  {
    row->space_size = block_space_gap_width;
  }

  if ((tosp_only_small_gaps_for_kern) && (small_gap_stats->get_total () > tosp_redo_kern_limit))
  {
    row->kern_size = small_gap_stats->median ();
  }
  else if (all_gap_stats->get_total () > tosp_redo_kern_limit)
  {
    row->kern_size = all_gap_stats->median ();
  }
  else //old TO -SAME FOR ALL ROWS
  {
    row->kern_size = block_non_space_gap_width;
  }

  if (tosp_threshold_bias2 > 0)
  {
    row->space_threshold = inT32 (floor (0.5 + row->kern_size + tosp_threshold_bias2 * (row->space_size - row->kern_size)));
  }
  else
  {
    /*
      NOTE old text ord uses (space_size + kern_size + 1)/2  as the threshold
    and holds this in a float. The use is with a >= test
    NEW textord uses an integer threshold and a > test
    It comes to the same thing.
      (Though there is a difference in that old textor has integer space_size
      and kern_size.)
    */
    row->space_threshold = inT32 (floor ((row->space_size + row->kern_size) / 2));
  }
}


/*************************************************************************
 * isolated_row_stats()
 * Set values for min_space, max_non_space based on row stats only
 *************************************************************************/

BOOL8 isolated_row_stats(TO_ROW *row,
                         GAPMAP *gapmap,
                         STATS *all_gap_stats,
                         BOOL8 suspected_table,
                         inT16 block_idx,
                         inT16 row_idx)
{
  float kern_estimate;
  float crude_threshold_estimate;
  inT16 small_gaps_count;
  inT16 total;

  //iterator
  BLOBNBOX_IT blob_it = row->blob_list ();
  STATS cert_space_gap_stats (0, MAXSPACING);
  STATS all_space_gap_stats (0, MAXSPACING);
  STATS small_gap_stats (0, MAXSPACING);
  TBOX blob_box;
  TBOX prev_blob_box;
  inT16 gap_width;
  inT32 end_of_row;
  inT32 row_length;

  kern_estimate = all_gap_stats->median ();
  crude_threshold_estimate = MAX (tosp_init_guess_kn_mult * kern_estimate, tosp_init_guess_xht_mult * row->xheight);
  small_gaps_count = stats_count_under (all_gap_stats, (inT16) ceil (crude_threshold_estimate));
  total = all_gap_stats->get_total ();

  if ((total <= tosp_redo_kern_limit) || ((small_gaps_count / (float) total) < tosp_enough_small_gaps) || (total - small_gaps_count < 1))
  {
    if (tosp_debug_level > 5)
    {
      tprintf ("B:%d R:%d -- Cant do isolated row stats.\n", block_idx, row_idx);
    }

    return FALSE;
  }

  blob_it.set_to_list (row->blob_list ());
  blob_it.mark_cycle_pt ();
  end_of_row = blob_it.data_relative (-1)->bounding_box ().right ();

  if (tosp_use_pre_chopping)
  {
    blob_box = box_next_pre_chopped (&blob_it);
  }
  else if (tosp_stats_use_xht_gaps)
  {
    blob_box = reduced_box_next (row, &blob_it);
  }
  else
  {
    blob_box = box_next (&blob_it);
  }

  row_length = end_of_row - blob_box.left ();
  prev_blob_box = blob_box;

  while (!blob_it.cycled_list ())
  {
    if (tosp_use_pre_chopping)
    {
      blob_box = box_next_pre_chopped (&blob_it);
    }
    else if (tosp_stats_use_xht_gaps)
    {
      blob_box = reduced_box_next (row, &blob_it);
    }
    else
    {
      blob_box = box_next (&blob_it);
    }

    gap_width = blob_box.left () - prev_blob_box.right ();

    if (!ignore_big_gap (row, row_length, gapmap, prev_blob_box.right (), blob_box.left ()) && (gap_width > crude_threshold_estimate))
    {
      if ((gap_width > tosp_fuzzy_space_factor2 * row->xheight) || ((gap_width > tosp_fuzzy_space_factor1 * row->xheight) &&
        (!tosp_narrow_blobs_not_cert || (!narrow_blob (row, prev_blob_box) && !narrow_blob (row, blob_box)))) ||
        (wide_blob (row, prev_blob_box) && wide_blob (row, blob_box)))
      {
        cert_space_gap_stats.add (gap_width, 1);
      }

      all_space_gap_stats.add (gap_width, 1);
    }

    if (gap_width < crude_threshold_estimate)
    {
      small_gap_stats.add (gap_width, 1);
    }

    prev_blob_box = blob_box;
  }

  if (cert_space_gap_stats.get_total () >= tosp_enough_space_samples_for_median)
  {
    //median
    row->space_size = cert_space_gap_stats.median ();
  }
  else if (suspected_table && (cert_space_gap_stats.get_total () > 0))
  {
    //to avoid spaced
    row->space_size = cert_space_gap_stats.mean ();
  }
  else if (all_space_gap_stats.get_total () >= tosp_enough_space_samples_for_median) //      1's in tables
  {
    //median
    row->space_size = all_space_gap_stats.median ();
  }
  else
  {
    row->space_size = all_space_gap_stats.mean ();
  }

  if (tosp_only_small_gaps_for_kern)
  {
    row->kern_size = small_gap_stats.median ();
  }
  else
  {
    row->kern_size = all_gap_stats->median ();
  }

  row->space_threshold = inT32 (floor ((row->space_size + row->kern_size) / 2));

  /* Sanity check */
  if ((row->kern_size >= row->space_threshold) || (row->space_threshold >= row->space_size) || (row->space_threshold <= 0))
  {
    if (tosp_debug_level > 0)
    {
      tprintf ("B:%d R:%d -- Isolated row stats SANITY FAILURE: %f %d %f\n", block_idx, row_idx, row->kern_size, row->space_threshold, row->space_size);
    }

    row->kern_size = 0.0f;
    row->space_threshold = 0;
    row->space_size = 0.0f;

    return FALSE;
  }

  if (tosp_debug_level > 5)
  {
    tprintf ("B:%d R:%d -- Isolated row stats: %f %d %f\n", block_idx, row_idx, row->kern_size, row->space_threshold, row->space_size);
  }

  return TRUE;
}


inT16 stats_count_under(STATS *stats, inT16 threshold)
{
  inT16 index;
  inT16 total = 0;

  for (index = 0; index < threshold; index++)
  {
    total += stats->pile_count (index);
  }

  return total;
}


/*************************************************************************
 * improve_row_threshold()
 *    Try to recognise a "normal line" -
 *           > 25 gaps
 *     &&    space > 3 * kn  && space > 10
 *              (I.e. reasonably large space and kn:sp ratio)
 *     &&    > 3/4 # gaps < kn + (sp - kn)/3
 *              (I.e. most gaps are well away from space estimate)
 *     &&    a gap of max( 3, (sp - kn)/3 ) empty histogram positions is found
 *           somewhere in the histogram between kn and sp
 *     THEN set the threshold and fuzzy limits to this gap - ie NO fuzzies
 *          NO!!!!! the bristol line has "11" with a gap of 12 between the 1's!!!
 *          try moving the default threshold to within this band but leave the
 *          fuzzy limit calculation as at present.
 *************************************************************************/

void improve_row_threshold(TO_ROW *row, STATS *all_gap_stats)
{
  float sp = row->space_size;
  float kn = row->kern_size;
  inT16 reqd_zero_width = 0;
  inT16 zero_width = 0;
  inT16 zero_start = 0;
  inT16 index = 0;

  if (tosp_debug_level > 10)
  {
    tprintf ("Improve row threshold 0");
  }

  if ((all_gap_stats->get_total () <= 25) || (sp <= 10) || (sp <= 3 * kn) ||
    (stats_count_under (all_gap_stats, (inT16) ceil (kn + (sp - kn) / 3 + 0.5)) < (0.75 * all_gap_stats->get_total ())))
  {
    return;
  }

  if (tosp_debug_level > 10) tprintf (" 1");

  /*
  Look for the first region of all 0's in the histogram which is wider than
  max( 3, (sp - kn)/3 ) and starts between kn and sp. If found, and current
  threshold is not within it, move the threshold so that is is just inside it.
  */
  reqd_zero_width = (inT16) floor ((sp - kn) / 3 + 0.5);
  if (reqd_zero_width < 3) reqd_zero_width = 3;

  for (index = inT16 (ceil (kn)); index < inT16 (floor (sp)); index++)
  {
    if (all_gap_stats->pile_count (index) == 0)
    {
      if (zero_width == 0)
      {
        zero_start = index;
      }

      zero_width++;
    }
    else
    {
      if (zero_width >= reqd_zero_width)
      {
          break;
      }
      else
      {
        zero_width = 0;
      }
    }
  }
  index--;

  if (tosp_debug_level > 10)
  {
    tprintf (" reqd_z_width: %d found %d 0's, starting %d; thresh: %d/n", reqd_zero_width, zero_width, zero_start, row->space_threshold);
  }

  if ((zero_width < reqd_zero_width) || ((row->space_threshold >= zero_start) && (row->space_threshold <= index)))
  {
    return;
  }

  if (tosp_debug_level > 10)
  {
    tprintf (" 2");
  }

  if (row->space_threshold < zero_start)
  {
    if (tosp_debug_level > 5)
    {
      tprintf("Improve row kn:%5.2f sp:%5.2f 0's: %d -> %d  thresh:%d -> %d\n", kn, sp, zero_start, index, row->space_threshold, zero_start);
    }

    row->space_threshold = zero_start;
  }

  if (row->space_threshold > index)
  {
    if (tosp_debug_level > 5)
    {
      tprintf("Improve row kn:%5.2f sp:%5.2f 0's: %d -> %d  thresh:%d -> %d\n", kn, sp, zero_start, index, row->space_threshold, index);
    }

    row->space_threshold = index;
  }
}


/**********************************************************************
 * make_prop_words
 *
 * Convert a TO_BLOCK to a BLOCK.
 **********************************************************************/

ROW *make_prop_words(                 //find lines
                     TO_ROW *row,     //row to make
                     FCOORD rotation  //for drawing
                    )
{
  Q_UNUSED(rotation);
  BOOL8 bol;                     //start of line

  /* prev_ values are for start of word being built. non prev_ values are for
  the gap between the word being built and the next one. */
  BOOL8 prev_fuzzy_sp;           //probably space
  BOOL8 prev_fuzzy_non;          //probably not
  uinT8 prev_blanks;             //in front of word
  BOOL8 fuzzy_sp;                //probably space
  BOOL8 fuzzy_non;               //probably not
  uinT8 blanks;                  //in front of word
  ROW *real_row;                 //output row
  OUTLINE_IT out_it;             //outlines
  C_OUTLINE_IT cout_it;
  PBLOB_LIST blobs;              //blobs in word
  C_BLOB_LIST cblobs;
  PBLOB_IT blob_it = &blobs;     //iterator
  C_BLOB_IT cblob_it = &cblobs;
  WERD_LIST words;
  WERD_IT word_it;               //new words
  WERD *word;                    //new word
  WERD_IT rep_char_it;           //repeated char words
  inT32 next_rep_char_word_right = MAX_INT32;
  float repetition_spacing;      //gap between repetitions
  inT32 xstarts[2];              //row ends
  inT32 prev_x;                  //end of prev blob
  BLOBNBOX *bblob;               //current blob
  TBOX blob_box;                  //bounding box
  BLOBNBOX_IT box_it;            //iterator
  TBOX prev_blob_box;
  TBOX next_blob_box;
  inT16 prev_gap = MAX_INT16;
  inT16 current_gap = MAX_INT16;
  inT16 next_gap = MAX_INT16;
  inT16 prev_within_xht_gap = MAX_INT16;
  inT16 current_within_xht_gap = MAX_INT16;
  inT16 next_within_xht_gap = MAX_INT16;
  inT16 word_count = 0;
  static inT16 row_count = 0;

  row_count++;
  rep_char_it.set_to_list (&(row->rep_words));
  if (!rep_char_it.empty ())
  {
    next_rep_char_word_right = rep_char_it.data ()->bounding_box ().right ();
  }

  prev_x = -MAX_INT16;
  blob_it.set_to_list (&blobs);
  cblob_it.set_to_list (&cblobs);
  box_it.set_to_list (row->blob_list ());
  word_it.set_to_list (&words);
  bol = TRUE;
  prev_blanks = 0;
  prev_fuzzy_sp = FALSE;
  prev_fuzzy_non = FALSE;

  if (!box_it.empty ())
  {
    xstarts[0] = box_it.data ()->bounding_box ().left ();
    if (xstarts[0] > next_rep_char_word_right)
    {
      /* We need to insert a repeated char word at the start of the row */
      word = rep_char_it.extract ();
      word_it.add_after_then_move (word);

      /* Set spaces before repeated char word */
      word->set_flag (W_BOL, TRUE);
      bol = FALSE;
      word->set_blanks (0);

      //NO uncertainty
      word->set_flag (W_FUZZY_SP, FALSE);
      word->set_flag (W_FUZZY_NON, FALSE);
      xstarts[0] = word->bounding_box ().left ();

      /* Set spaces after repeated char word (and leave current word set) */
      repetition_spacing = find_mean_blob_spacing (word);
      current_gap = box_it.data ()->bounding_box ().left () - next_rep_char_word_right;
      current_within_xht_gap = current_gap;

      if (current_gap > tosp_rep_space * repetition_spacing)
      {
        prev_blanks = (uinT8) floor (current_gap / row->space_size);
        if (prev_blanks < 1) prev_blanks = 1;
      }
      else
      {
        prev_blanks = 0;
      }

      if (tosp_debug_level > 5)
      {
        tprintf ("Repch wd at BOL(%d, %d). rep spacing %5.2f;  Rgap:%d  ",
          box_it.data ()->bounding_box ().left (),
          box_it.data ()->bounding_box ().bottom (),
          repetition_spacing, current_gap);
      }

      prev_fuzzy_sp = FALSE;
      prev_fuzzy_non = FALSE;
      if (rep_char_it.empty ())
      {
        next_rep_char_word_right = MAX_INT32;
      }
      else
      {
        rep_char_it.forward ();
        next_rep_char_word_right = rep_char_it.data ()->bounding_box ().right ();
      }
    }

    peek_at_next_gap(row, box_it, next_blob_box, next_gap, next_within_xht_gap);

    do
    {
      bblob = box_it.data ();
      blob_box = bblob->bounding_box ();

      if (bblob->joined_to_prev ())
      {
        if (bblob->blob () != NULL)
        {
          out_it.set_to_list (blob_it.data ()->out_list ());
          out_it.move_to_last ();
          out_it.add_list_after (bblob->blob ()->out_list ());

          delete bblob->blob ();
        }
        else if (bblob->cblob () != NULL)
        {
          cout_it.set_to_list (cblob_it.data ()->out_list ());
          cout_it.move_to_last ();
          cout_it.add_list_after (bblob->cblob ()->out_list ());

          delete bblob->cblob ();
        }
      }
      else
      {
        if (bblob->blob () != NULL)
        {
          blob_it.add_after_then_move (bblob->blob ());
        }
        else if (bblob->cblob () != NULL)
        {
          cblob_it.add_after_then_move (bblob->cblob ());
        }

        prev_x = blob_box.right ();
      }

      box_it.forward ();         //next one
      bblob = box_it.data ();
      blob_box = bblob->bounding_box ();

      if (!bblob->joined_to_prev () && (bblob->blob () != NULL || bblob->cblob () != NULL))
      {
        /* Real Blob - not multiple outlines or pre-chopped */
        prev_gap = current_gap;
        prev_within_xht_gap = current_within_xht_gap;
        prev_blob_box = next_blob_box;
        current_gap = next_gap;
        current_within_xht_gap = next_within_xht_gap;
        peek_at_next_gap(row, box_it, next_blob_box, next_gap, next_within_xht_gap);

        inT16 prev_gap_arg = prev_gap;
        inT16 next_gap_arg = next_gap;
        if (tosp_only_use_xht_gaps)
        {
          prev_gap_arg = prev_within_xht_gap;
          next_gap_arg = next_within_xht_gap;
        }

        // Decide if a word-break should be inserted
        if (blob_box.left () > next_rep_char_word_right ||
           make_a_word_break(row, blob_box, prev_gap_arg, prev_blob_box,
                             current_gap, current_within_xht_gap, next_blob_box, next_gap_arg, blanks, fuzzy_sp, fuzzy_non) || box_it.at_first())
        {
          /* Form a new word out of the blobs collected */
          if (!blob_it.empty ())
          {
            word = new WERD (&blobs, prev_blanks, NULL);

            //make real word
            word_count++;
          }
          else
          {
            word = new WERD (&cblobs, prev_blanks, NULL);
            word_count++;
          }

          word_it.add_after_then_move (word);

          if (bol)
          {
            word->set_flag (W_BOL, TRUE);
            bol = FALSE;
          }
          if (prev_fuzzy_sp)
          {
                                 //probably space
            word->set_flag (W_FUZZY_SP, TRUE);
          }
          else if (prev_fuzzy_non)
          {
            word->set_flag (W_FUZZY_NON, TRUE);
          }
          //probably not

          if (blob_box.left () > next_rep_char_word_right)
          {
            /* We need to insert a repeated char word */
            word = rep_char_it.extract ();
            word_it.add_after_then_move (word);

            /* Set spaces before repeated char word */
            repetition_spacing = find_mean_blob_spacing (word);
            current_gap = word->bounding_box ().left () - prev_x;
            current_within_xht_gap = current_gap;

            if (current_gap > tosp_rep_space * repetition_spacing)
            {
              blanks = (uinT8) floor (current_gap / row->space_size);

              if (blanks < 1) blanks = 1;
            }
            else
            {
              blanks = 0;
            }

            if (tosp_debug_level > 5)
            {
              tprintf("Repch wd (%d,%d) rep gap %5.2f;  Lgap:%d (%d blanks);", word->bounding_box ().left (), word->bounding_box ().bottom (), repetition_spacing, current_gap, blanks);
            }

            word->set_blanks (blanks);

            //NO uncertainty
            word->set_flag (W_FUZZY_SP, FALSE);
            word->set_flag (W_FUZZY_NON, FALSE);

            /* Set spaces after repeated char word (and leave current word set) */
            current_gap = blob_box.left () - next_rep_char_word_right;

            if (current_gap > tosp_rep_space * repetition_spacing)
            {
              blanks = (uinT8) (current_gap / row->space_size);
              if (blanks < 1) blanks = 1;
            }
            else
            {
              blanks = 0;
            }

            if (tosp_debug_level > 5)
            {
              tprintf (" Rgap:%d (%d blanks)\n", current_gap, blanks);
            }

            fuzzy_sp = FALSE;
            fuzzy_non = FALSE;

            if (rep_char_it.empty ())
            {
              next_rep_char_word_right = MAX_INT32;
            }
            else
            {
              rep_char_it.forward ();
              next_rep_char_word_right = rep_char_it.data ()->bounding_box ().right ();
            }
          }

          if (box_it.at_first () && rep_char_it.empty ())
          {
            //at end of line
            word->set_flag (W_EOL, TRUE);
            xstarts[1] = prev_x;
          }
          else
          {
            prev_blanks = blanks;
            prev_fuzzy_sp = fuzzy_sp;
            prev_fuzzy_non = fuzzy_non;
          }
        }
      }
    }
    while (!box_it.at_first ()); //until back at start

    /* Insert any further repeated char words */
    while (!rep_char_it.empty ())
    {
      word = rep_char_it.extract ();
      word_it.add_after_then_move (word);

      /* Set spaces before repeated char word */
      repetition_spacing = find_mean_blob_spacing (word);
      current_gap = word->bounding_box ().left () - prev_x;

      if (current_gap > tosp_rep_space * repetition_spacing)
      {
        blanks = (uinT8) floor (current_gap / row->space_size);
        if (blanks < 1) blanks = 1;
      }
      else
      {
        blanks = 0;
      }

      if (tosp_debug_level > 5)
      {
        tprintf("Repch wd at EOL (%d,%d). rep spacing %d; Lgap:%d (%d blanks)\n",
                word->bounding_box ().left (), word->bounding_box ().bottom (), repetition_spacing, current_gap, blanks);
      }

      word->set_blanks (blanks);

      //NO uncertainty
      word->set_flag (W_FUZZY_SP, FALSE);
      word->set_flag (W_FUZZY_NON, FALSE);
      prev_x = word->bounding_box ().right ();

      if (rep_char_it.empty ())
      {
        //at end of line
        word->set_flag (W_EOL, TRUE);
        xstarts[1] = prev_x;
      }
      else
      {
        rep_char_it.forward ();
      }
    }

    real_row = new ROW (row, (inT16) row->kern_size, (inT16) row->space_size);
    word_it.set_to_list(real_row->word_list());

    //put words in row
    word_it.add_list_after (&words);
    real_row->recalc_bounding_box ();

    if (tosp_debug_level > 9)
    {
      tprintf ("Row %d Made %d words in row ((%d,%d)(%d,%d))\n",
        row_count,
        word_count,
        real_row->bounding_box ().left (),
        real_row->bounding_box ().bottom (),
        real_row->bounding_box ().right (),
        real_row->bounding_box ().top ());
    }

    return real_row;
  }

  return NULL;
}

/**********************************************************************
 * make_blob_words
 *
 * Converts words into blobs so that each blob is a single character.
 *  Used for chopper test.
 **********************************************************************/

// find lines
ROW *make_blob_words(
                     TO_ROW *row,     // row to make
                     FCOORD rotation  // for drawing
                    )
{
  Q_UNUSED(rotation);
  bool bol;                      // start of line
  ROW *real_row;                 // output row
  C_OUTLINE_IT cout_it;
  C_BLOB_LIST cblobs;
  C_BLOB_IT cblob_it = &cblobs;
  WERD_LIST words;
  WERD_IT word_it;               // new words
  WERD *word;                    // new word
  BLOBNBOX *bblob;               // current blob
  TBOX blob_box;                 // bounding box
  BLOBNBOX_IT box_it;            // iterator
  inT16 word_count = 0;
  static inT16 row_count = 0;

  row_count++;

  cblob_it.set_to_list(&cblobs);
  box_it.set_to_list(row->blob_list());
  word_it.set_to_list(&words);
  bol = TRUE;
  if (!box_it.empty())
  {
    do
      {
      bblob = box_it.data();
      blob_box = bblob->bounding_box();

      if (bblob->joined_to_prev())
      {
        if (bblob->cblob() != NULL)
        {
          cout_it.set_to_list(cblob_it.data()->out_list());
          cout_it.move_to_last();
          cout_it.add_list_after(bblob->cblob()->out_list());

          delete bblob->cblob();
        }
      }
      else
      {
        if (bblob->cblob() != NULL)
        {
          cblob_it.add_after_then_move(bblob->cblob());
        }
      }
      box_it.forward();         // next one
      bblob = box_it.data();
      blob_box = bblob->bounding_box();

      if (!bblob->joined_to_prev() && !cblobs.empty())
      {
        word = new WERD(&cblobs, 1, NULL);
        word_count++;
        word_it.add_after_then_move(word);

        if (bol)
        {
          word->set_flag(W_BOL, TRUE);
          bol = FALSE;
        }

        if (box_it.at_first())
        {
          // at end of line
          word->set_flag(W_EOL, TRUE);
        }
      }
    }
    while (!box_it.at_first()); // until back at start

    /* Setup the row with created words. */
    real_row = new ROW(row, (inT16) row->kern_size, (inT16) row->space_size);
    word_it.set_to_list(real_row->word_list());

    //put words in row
    word_it.add_list_after(&words);
    real_row->recalc_bounding_box();

    if (tosp_debug_level > 9)
    {
      tprintf ("Row %d Made %d words in row ((%d,%d)(%d,%d))\n",
        row_count,
        word_count,
        real_row->bounding_box().left(),
        real_row->bounding_box().bottom(),
        real_row->bounding_box().right(),
        real_row->bounding_box().top());
    }

    return real_row;
  }

  return NULL;
}

BOOL8 make_a_word_break(               //decide on word break
                        TO_ROW *row,   //row being made
                        TBOX blob_box,  //for next_blob //how many blanks?
                        inT16 prev_gap,
                        TBOX prev_blob_box,
                        inT16 real_current_gap,
                        inT16 within_xht_current_gap,
                        TBOX next_blob_box,
                        inT16 next_gap,
                        uinT8 &blanks,
                        BOOL8 &fuzzy_sp,
                        BOOL8 &fuzzy_non)
{
  static BOOL8 prev_gap_was_a_space = FALSE;
  static BOOL8 break_at_next_gap = FALSE;
  BOOL8 space;
  inT16 current_gap;
  float fuzzy_sp_to_kn_limit;

  if (break_at_next_gap)
  {
    break_at_next_gap = FALSE;
    return TRUE;
  }

  /* Inhibit using the reduced gap if
    The kerning is large - chars are not kerned and reducing "f"s can cause
    erroneous blanks
  OR  The real gap is less than 0
  OR  The real gap is less than the kerning estimate
  */
  if ((row->kern_size > tosp_large_kerning * row->xheight) ||
      ((tosp_dont_fool_with_small_kerns >= 0) &&
       (real_current_gap < tosp_dont_fool_with_small_kerns * row->kern_size)))
  {
    //Ignore the difference
    within_xht_current_gap = real_current_gap;
  }

  if (tosp_use_xht_gaps && tosp_only_use_xht_gaps)
  {
    current_gap = within_xht_current_gap;
  }
  else
  {
    current_gap = real_current_gap;
  }

  if (tosp_old_to_method)
  {
    //Boring old method
    space = current_gap > row->max_nonspace;

    if (space && (current_gap < MAX_INT16))
    {
      if (current_gap < row->min_space)
      {
        if (current_gap > row->space_threshold)
        {
          blanks = 1;
          fuzzy_sp = TRUE;
          fuzzy_non = FALSE;
        }
        else
        {
          blanks = 0;
          fuzzy_sp = FALSE;
          fuzzy_non = TRUE;
        }
      }
      else
      {
        blanks = (uinT8) (current_gap / row->space_size);
        if (blanks < 1) blanks = 1;

        fuzzy_sp = FALSE;
        fuzzy_non = FALSE;
      }
    }

    return space;
  }
  else
  {
  /* New exciting heuristic method */
    if (prev_blob_box.null_box ())  // Beginning of row
    {
      prev_gap_was_a_space = TRUE;
    }

    //Default as old TO
    space = current_gap > row->space_threshold;

    /* Set defaults for the word break incase we find one.  Currently there are
    no fuzzy spaces. Depending on the reliability of the different heuristics
    we may need to set PARTICULAR spaces to fuzzy or not. The values will ONLY
    be used if the function returns TRUE - ie the word is to be broken.
    */
    blanks = (uinT8) (current_gap / row->space_size);
    if (blanks < 1) blanks = 1;
    fuzzy_sp = FALSE;
    fuzzy_non = FALSE;

    /*
    If xht measure causes gap to flip one of the 3 thresholds act accordingly -
    despite any other heuristics - the MINIMUM action is to pass a fuzzy kern to
    context.
    */
    if (tosp_use_xht_gaps && (real_current_gap <= row->max_nonspace) && (within_xht_current_gap > row->max_nonspace))
    {
      space = TRUE;
      fuzzy_non = TRUE;
#ifndef GRAPHICS_DISABLED
      mark_gap (blob_box, 20,     prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(), next_gap);
#endif
    }
    else if (tosp_use_xht_gaps && (real_current_gap <= row->space_threshold) && (within_xht_current_gap > row->space_threshold))
    {
      space = TRUE;
      if (tosp_flip_fuzz_kn_to_sp)
      {
        fuzzy_sp = TRUE;
      }
      else
      {
        fuzzy_non = TRUE;
      }
#ifndef GRAPHICS_DISABLED
      mark_gap (blob_box, 21, prev_gap, prev_blob_box.width (), current_gap, next_blob_box.width (), next_gap);
#endif
    }
    else if (tosp_use_xht_gaps && (real_current_gap < row->min_space) && (within_xht_current_gap >= row->min_space))
    {
      space = TRUE;
#ifndef GRAPHICS_DISABLED
      mark_gap(blob_box, 22, prev_gap, prev_blob_box.width(), current_gap, next_blob_box.width(), next_gap);
#endif
    }
    else if (tosp_force_wordbreak_on_punct &&
             !suspected_punct_blob(row, prev_blob_box) &&
             suspected_punct_blob(row, blob_box))
    {
      break_at_next_gap = TRUE;
    }
    else if ((current_gap < row->min_space) && (current_gap > row->space_threshold)) /* Now continue with normal heuristics */
    {
      /* Heuristics to turn dubious spaces to kerns */
      if (tosp_pass_wide_fuzz_sp_to_context > 0)
      {
        fuzzy_sp_to_kn_limit = row->kern_size + tosp_pass_wide_fuzz_sp_to_context * (row->space_size - row->kern_size);
      }
      else
      {
        fuzzy_sp_to_kn_limit = 99999.0f;
      }

      /* If current gap is significantly smaller than the previous space the other
      side of a narrow blob then this gap is a kern. */
      if ((prev_blob_box.width () > 0) && narrow_blob (row, prev_blob_box) && prev_gap_was_a_space && (current_gap <= tosp_gap_factor * prev_gap))
      {
        if ((tosp_all_flips_fuzzy) || (current_gap > fuzzy_sp_to_kn_limit))
        {
          if (tosp_flip_fuzz_sp_to_kn)
          {
            fuzzy_non = TRUE;
          }
          else
          {
            fuzzy_sp = TRUE;
          }
        }
        else
        {
          space = FALSE;
        }

#ifndef GRAPHICS_DISABLED
        mark_gap (blob_box, 1, prev_gap, prev_blob_box.width (), current_gap, next_blob_box.width (), next_gap);
#endif
      }
      /* If current gap not much bigger than the previous kern the other side of a
      narrow blob then this gap is a kern as well */
      else if ((prev_blob_box.width () > 0) && narrow_blob (row, prev_blob_box) && !prev_gap_was_a_space && (current_gap * tosp_gap_factor <= prev_gap))
      {
        if ((tosp_all_flips_fuzzy) || (current_gap > fuzzy_sp_to_kn_limit))
        {
          if (tosp_flip_fuzz_sp_to_kn)
          {
            fuzzy_non = TRUE;
          }
          else
          {
            fuzzy_sp = TRUE;
          }
        }
        else
        {
          space = FALSE;
        }
#ifndef GRAPHICS_DISABLED
        mark_gap (blob_box, 2, prev_gap, prev_blob_box.width (), current_gap, next_blob_box.width (), next_gap);
#endif
      }
      else if ((next_blob_box.width () > 0) && narrow_blob (row, next_blob_box) && (next_gap > row->space_threshold) && (current_gap <= tosp_gap_factor * next_gap))
      {
        if ((tosp_all_flips_fuzzy) || (current_gap > fuzzy_sp_to_kn_limit))
        {
          if (tosp_flip_fuzz_sp_to_kn)
          {
            fuzzy_non = TRUE;
          }
          else
          {
            fuzzy_sp = TRUE;
          }
        }
        else
        {
          space = FALSE;
        }
#ifndef GRAPHICS_DISABLED
        mark_gap (blob_box, 3, prev_gap, prev_blob_box.width (), current_gap, next_blob_box.width (), next_gap);
#endif
      }
      else if ((next_blob_box.width () > 0) && narrow_blob (row, next_blob_box) && (next_gap <= row->space_threshold) && (current_gap * tosp_gap_factor <= next_gap))
      {
        if ((tosp_all_flips_fuzzy) || (current_gap > fuzzy_sp_to_kn_limit))
        {
          if (tosp_flip_fuzz_sp_to_kn)
          {
            fuzzy_non = TRUE;
          }
          else
          {
            fuzzy_sp = TRUE;
          }
        }
        else
        {
          space = FALSE;
        }
#ifndef GRAPHICS_DISABLED
        mark_gap (blob_box, 4, prev_gap, prev_blob_box.width (), current_gap, next_blob_box.width (), next_gap);
#endif
      }
      else if ((((next_blob_box.width () > 0) && narrow_blob (row, next_blob_box)) || ((prev_blob_box.width () > 0) && narrow_blob (row, prev_blob_box))))
      {
        fuzzy_sp = TRUE;
#ifndef GRAPHICS_DISABLED
        mark_gap (blob_box, 6, prev_gap, prev_blob_box.width (), current_gap, next_blob_box.width (), next_gap);
#endif
      }
    }
    else if ((current_gap > row->max_nonspace) && (current_gap <= row->space_threshold))
    {

      /* Heuristics to turn dubious kerns to spaces */
      /* TRIED THIS BUT IT MADE THINGS WORSE
          if ( prev_gap == MAX_INT16 )
            prev_gap = 0;								//start of row
          if ( next_gap == MAX_INT16 )
            next_gap = 0;								//end of row
      */
      if ((prev_blob_box.width () > 0) && (next_blob_box.width () > 0) && (current_gap >= tosp_kern_gap_factor1 * MAX(prev_gap, next_gap)) &&
              wide_blob (row, prev_blob_box) && wide_blob (row, next_blob_box))
      {

        space = TRUE;
        /*
        tosp_flip_caution is an attempt to stop the default changing in cases
        where there is a large difference between the kern and space estimates.
          See problem in 'chiefs' where "have" gets split in the quotation.
        */
        if ((tosp_flip_fuzz_kn_to_sp) && ((tosp_flip_caution <= 0) || (tosp_flip_caution * row->kern_size > row->space_size)))
        {
          fuzzy_sp = TRUE;
        }
        else
        {
          fuzzy_non = TRUE;
        }
#ifndef GRAPHICS_DISABLED
        mark_gap (blob_box, 7, prev_gap, prev_blob_box.width (), current_gap, next_blob_box.width (), next_gap);
#endif
      }
      else if ((prev_blob_box.width () > 0) && (next_blob_box.width () > 0) &&
               (current_gap >= tosp_kern_gap_factor2 * MAX (prev_gap, next_gap)) &&
               !(narrow_blob (row, prev_blob_box) || suspected_punct_blob (row, prev_blob_box)) &&
               !(narrow_blob (row, next_blob_box) || suspected_punct_blob (row, next_blob_box)))
      {
        space = TRUE;
        fuzzy_non = TRUE;
#ifndef GRAPHICS_DISABLED
        mark_gap (blob_box, 8, prev_gap, prev_blob_box.width (), current_gap, next_blob_box.width (), next_gap);
#endif
      }
      else if ((tosp_kern_gap_factor3 > 0) && (prev_blob_box.width () > 0) && (next_blob_box.width () > 0) &&
               (current_gap >= tosp_kern_gap_factor3 * MAX (prev_gap, next_gap)) && (!tosp_rule_9_test_punct ||
                (!suspected_punct_blob (row, prev_blob_box) && !suspected_punct_blob (row, next_blob_box))))
      {
        space = TRUE;
        fuzzy_non = TRUE;
#ifndef GRAPHICS_DISABLED
        mark_gap (blob_box, 9, prev_gap, prev_blob_box.width (), current_gap, next_blob_box.width (), next_gap);
#endif
      }
    }
    prev_gap_was_a_space = space && !(fuzzy_non);

    return space;
  }
}


BOOL8 narrow_blob(TO_ROW *row, TBOX blob_box)
{
  BOOL8 result;

  result = ((blob_box.width () <= tosp_narrow_fraction * row->xheight) || (((float) blob_box.width () / blob_box.height ()) <= tosp_narrow_aspect_ratio));

  return result;
}


BOOL8 wide_blob(TO_ROW *row, TBOX blob_box)
{
  BOOL8 result;

  if (tosp_wide_fraction > 0)
  {
    if (tosp_wide_aspect_ratio > 0)
    {
      result = ((blob_box.width () >= tosp_wide_fraction * row->xheight) && (((float) blob_box.width () / blob_box.height ()) > tosp_wide_aspect_ratio));
    }
    else
    {
      result = (blob_box.width () >= tosp_wide_fraction * row->xheight);
    }
  }
  else
  {
    result = !narrow_blob (row, blob_box);
  }

  return result;
}


BOOL8 suspected_punct_blob(TO_ROW *row, TBOX box)
{
  BOOL8 result;
  float baseline;
  float blob_x_centre;

  /* Find baseline of centre of blob */

  blob_x_centre = (box.right () + box.left ()) / 2.0;
  baseline = row->baseline.y (blob_x_centre);

  result = (box.height () <= 0.66 * row->xheight) || (box.top () < baseline + row->xheight / 2.0) || (box.bottom () > baseline + row->xheight / 2.0);

  return result;
}


void peek_at_next_gap(  //A COPY FOR PEEKING
                      TO_ROW *row,
                      BLOBNBOX_IT box_it,
                      TBOX &next_blob_box,
                      inT16 &next_gap,
                      inT16 &next_within_xht_gap)
{
  TBOX next_reduced_blob_box;
  TBOX bit_beyond;
  BLOBNBOX_IT reduced_box_it = box_it;

  next_blob_box = box_next (&box_it);
  next_reduced_blob_box = reduced_box_next (row, &reduced_box_it);

  if (box_it.at_first ())
  {
    next_gap = MAX_INT16;
    next_within_xht_gap = MAX_INT16;
  }
  else
  {
    bit_beyond = box_it.data ()->bounding_box ();
    next_gap = bit_beyond.left () - next_blob_box.right ();
    bit_beyond = reduced_box_next (row, &reduced_box_it);
    next_within_xht_gap = bit_beyond.left () - next_reduced_blob_box.right ();
  }
}


#ifndef GRAPHICS_DISABLED
void mark_gap(             //Debug stuff
              TBOX blob,    //blob following gap
              inT16 rule,  // heuristic id
              inT16 prev_gap,
              inT16 prev_blob_width,
              inT16 current_gap,
              inT16 next_blob_width,
              inT16 next_gap)
{
  ScrollView::Color col;                    //of ellipse marking flipped gap

  switch (rule)
  {
    case 1:
      col = ScrollView::RED;
      break;
    case 2:
      col = ScrollView::CYAN;
      break;
    case 3:
      col = ScrollView::GREEN;
      break;
    case 4:
      col = ScrollView::BLACK;
      break;
    case 5:
      col = ScrollView::MAGENTA;
      break;
    case 6:
      col = ScrollView::BLUE;
      break;

    case 7:
      col = ScrollView::WHITE;
      break;
    case 8:
      col = ScrollView::YELLOW;
      break;
    case 9:
      col = ScrollView::BLACK;
      break;

    case 20:
      col = ScrollView::CYAN;
      break;
    case 21:
      col = ScrollView::GREEN;
      break;
    case 22:
      col = ScrollView::MAGENTA;
      break;
    default:
      col = ScrollView::BLACK;
  }

  if (textord_show_initial_words)
  {
    to_win->Pen(col);

    //x radius                           //y radius             //x centre                         //y centre
    to_win->Ellipse (current_gap / 2.0f, blob.height () / 2.0f, blob.left () - current_gap / 2.0f, blob.bottom () + blob.height () / 2.0f);
 }

  if (tosp_debug_level > 0)
  {
    tprintf (" (%d,%d) Sp<->Kn Rule %d %d %d %d %d\n", blob.left () - current_gap / 2, blob.bottom (),
             rule, prev_gap, prev_blob_width, current_gap, next_blob_width, next_gap);
  }
}
#endif


float find_mean_blob_spacing(WERD *word)
{
  PBLOB_IT blob_it;
  C_BLOB_IT cblob_it;
  TBOX blob_box;
  inT32 gap_sum = 0;
  inT16 gap_count = 0;
  inT16 prev_right;

  if (word->flag (W_POLYGON))
  {
    blob_it.set_to_list (word->blob_list ());

    if (!blob_it.empty ())
    {
      blob_it.mark_cycle_pt ();
      prev_right = blob_it.data ()->bounding_box ().right ();

      //first blob
      blob_it.forward ();

      for (; !blob_it.cycled_list (); blob_it.forward ())
      {
        blob_box = blob_it.data ()->bounding_box ();
        gap_sum += blob_box.left () - prev_right;
        gap_count++;
        prev_right = blob_box.right ();
      }
    }
  }
  else
  {
    cblob_it.set_to_list (word->cblob_list ());

    if (!cblob_it.empty ())
    {
      cblob_it.mark_cycle_pt ();
      prev_right = cblob_it.data ()->bounding_box ().right ();

      //first blob
      cblob_it.forward ();
      for (; !cblob_it.cycled_list (); cblob_it.forward ())
      {
        blob_box = cblob_it.data ()->bounding_box ();
        gap_sum += blob_box.left () - prev_right;
        gap_count++;
        prev_right = blob_box.right ();
      }
    }
  }

  if (gap_count > 0)
  {
    return (gap_sum / (float) gap_count);
  }
  else
  {
    return 0.0f;
  }
}


BOOL8 ignore_big_gap(TO_ROW *row, inT32 row_length, GAPMAP *gapmap, inT16 left, inT16 right)
{
  inT16 gap = right - left + 1;

  if (tosp_ignore_big_gaps > 999)
  {
    return FALSE;                //Dont ignore
  }

  if (tosp_ignore_big_gaps > 0)
  {
    return (gap > tosp_ignore_big_gaps * row->xheight);
  }

  if (gap > tosp_ignore_very_big_gaps * row->xheight)
  {
    return TRUE;
  }

  if (tosp_ignore_big_gaps == 0)
  {
    if ((gap > 2.1 * row->xheight) && (row_length > 20 * row->xheight))
    {
      return TRUE;
    }

    if ((gap > 1.75 * row->xheight) && ((row_length > 35 * row->xheight) || gapmap->table_gap (left, right)))
    {
      return TRUE;
    }
  }
  else
  {
  /* ONLY time gaps < 3.0 * xht are ignored is when they are part of a table */
    if ((gap > gapmap_big_gaps * row->xheight) && gapmap->table_gap (left, right))
    {
      return TRUE;
    }
  }

  return FALSE;
}


/**********************************************************************
 * reduced_box_next
 *
 * Compute the bounding box of this blob with merging of x overlaps
 * but no pre-chopping.
 * Then move the iterator on to the start of the next blob.
 * DONT reduce the box for small things - eg punctuation.
 **********************************************************************/
//get bounding box
TBOX reduced_box_next(TO_ROW *row,     //current row
                     BLOBNBOX_IT *it  //iterator to blobds
                    )
{
  BLOBNBOX *blob;                //current blob
  BLOBNBOX *head_blob;           //place to store box
  TBOX full_box;                  //full blob boundg box
  TBOX reduced_box;               //box of significant part
  inT16 left_above_xht;          //ABOVE xht left limit
  inT16 new_left_above_xht;      //ABOVE xht left limit

  blob = it->data ();
  if (blob->red_box_set ())
  {
    reduced_box = blob->reduced_box ();
    do
    {
      it->forward ();
      blob = it->data ();
    }

    //until next real blob
    while ((blob->blob () == NULL && blob->cblob () == NULL) || blob->joined_to_prev ());

    return reduced_box;
  }

  head_blob = blob;
  full_box = blob->bounding_box ();
  reduced_box = reduced_box_for_blob (blob, row, &left_above_xht);

  do
  {
    it->forward ();
    blob = it->data ();
    if (blob->blob () == NULL && blob->cblob () == NULL)
    {
      //was pre-chopped
      full_box += blob->bounding_box ();
    }
    else if (blob->joined_to_prev ())
    {
      reduced_box += reduced_box_for_blob(blob, row, &new_left_above_xht);
      left_above_xht = MIN (left_above_xht, new_left_above_xht);
    }
  }

  //until next real blob
  while ((blob->blob () == NULL && blob->cblob () == NULL) || blob->joined_to_prev ());

  if ((reduced_box.width () > 0) && ((reduced_box.left () + tosp_near_lh_edge * reduced_box.width ()) < left_above_xht) &&
          (reduced_box.height () > 0.7 * row->xheight))
  {
#ifndef GRAPHICS_DISABLED
    if (textord_show_initial_words)
    {
      reduced_box.plot (to_win, ScrollView::YELLOW, ScrollView::YELLOW);
    }
#endif
  }
  else
  {
    reduced_box = full_box;
  }

  head_blob->set_reduced_box (reduced_box);

  return reduced_box;
}


/*************************************************************************
 * reduced_box_for_blob()
 * Find box for blob which is the same height and y position as the whole blob,
 * but whose left limit is the left most position of the blob ABOVE the
 * baseline and whose right limit is the right most position of the blob BELOW
 * the xheight.
 *
 *
 * !!!!!!! WONT WORK WITH LARGE UPPER CASE CHARS - T F V W - look at examples on
 *         "home".  Perhaps we need something which say if the width ABOVE the
 *         xht alone includes the whole of the reduced width, then use the full
 *         blob box - Might still fail on italic F
 *
 *         Alternatively we could be a little less severe and only reduce the
 *         left and right edges by half the difference between the full box and
 *         the reduced box.
 *
 * NOTE that we need to rotate all the coordinates as
 * find_blob_limits finds the y min and max within a specified x band
 *************************************************************************/

TBOX reduced_box_for_blob(BLOBNBOX *blob, TO_ROW *row, inT16 *left_above_xht)
{
  float baseline;
  float blob_x_centre;
  float left_limit;
  float right_limit;
  float junk;
  TBOX blob_box;

  /* Find baseline of centre of blob */

  blob_box = blob->bounding_box ();
  blob_x_centre = (blob_box.left () + blob_box.right ()) / 2.0;
  baseline = row->baseline.y (blob_x_centre);

  /*
  Find LH limit of blob ABOVE the xht. This is so that we can detect certain
  caps ht chars which should NOT have their box reduced: T, Y, V, W etc
  */
  left_limit = (float) MAX_INT32;
  junk = (float) -MAX_INT32;
  if (blob->blob () != NULL)
  {
    //blob to test                                         //rotated lower limit          //rotated upper limit  //90deg anticlock rot
    find_blob_limits(blob->blob (), (float) -MAX_INT16, -(baseline + 1.1 * row->xheight), FCOORD (0.0, 1.0),     left_limit, junk);         //min y max_y
  }
  else
  {
                                 //blob to test        //rotated lower limit
    find_cblob_hlimits (blob->cblob (), (baseline + 1.1 * row->xheight), (float) MAX_INT16,left_limit, junk);         //min y max_y
  }

  if (left_limit > junk)
  {
    *left_above_xht = MAX_INT16; //No area above xht
  }
  else
  {
    *left_above_xht = (inT16) floor (left_limit);
  }

  /*
  Find reduced LH limit of blob - the left extent of the region ABOVE the
  baseline.
  */
  left_limit = (float) MAX_INT32;
  junk = (float) -MAX_INT32;

  if (blob->blob () != NULL)
   {
      //blob to test  //rotated lower limit  //rotated upper limit //90deg anticlock rot
    find_blob_limits (blob->blob (), (float) -MAX_INT16, -baseline, FCOORD (0.0, 1.0), left_limit, junk);         //min y max_y
  }
  else
  {
    find_cblob_hlimits (blob->cblob (), baseline, (float) MAX_INT16,   left_limit, junk);
  }

  if (left_limit > junk)
  {
    return TBOX ();               //no area within xht so return empty box
  }

  /*
  Find reduced RH limit of blob - the right extent of the region BELOW the xht.
  */
  junk = (float) MAX_INT32;
  right_limit = (float) -MAX_INT32;
  if (blob->blob () != NULL) //blob to test
  {
    find_blob_limits (blob->blob (), -(baseline + row->xheight),
      (float) MAX_INT16,         //rotated upper limit
      FCOORD (0.0, 1.0),         //90deg anticlock rot
      junk, right_limit);        //min y max_y
  }
  else //blob to test
  {
    find_cblob_hlimits (blob->cblob(), (float) -MAX_INT16, (baseline + row->xheight), junk, right_limit);
  }

  if (junk > right_limit)
  {
    return TBOX ();               //no area within xht so return empty box
  }

  return TBOX (ICOORD ((inT16) floor (left_limit), blob_box.bottom ()), ICOORD ((inT16) ceil (right_limit), blob_box.top ()));
}
/////////////////////////////////////////////////////////////////tospace////////////////////////////////////////

/////////////////////////////////////////////////////////////////wordseg////////////////////////////////////////
#define EXTERN
EXTERN BOOL_VAR (textord_fp_chopping, TRUE, "Do fixed pitch chopping");
EXTERN BOOL_VAR (textord_force_make_prop_words, FALSE, "Force proportional word segmentation on all rows");
EXTERN BOOL_VAR (textord_chopper_test, FALSE, "Chopper is being tested.");
extern /*"C" */ ETEXT_DESC *global_monitor;     //progress monitor

ETEXT_DESC *global_monitor = NULL;

#define FIXED_WIDTH_MULTIPLE  5
#define BLOCK_STATS_CLUSTERS  10


/**
 * @name make_single_word
 *
 * Arrange the blobs into one word. There is no fixed pitch detection.
 */

void make_single_word(bool one_blob, TO_ROW_LIST *rows, ROW_LIST* real_rows)
{
    TO_ROW_IT to_row_it(rows);
    TO_ROW* row = to_row_it.data();

    // The blobs have to come out of the BLOBNBOX into the C_BLOB_LIST ready
    // to create the word.
    C_BLOB_LIST cblobs;
    C_BLOB_IT cblob_it(&cblobs);
    BLOBNBOX_IT box_it(row->blob_list());

    for (;!box_it.empty(); box_it.forward())
    {
        BLOBNBOX* bblob= box_it.extract();
        if (bblob->joined_to_prev() || (one_blob && !cblob_it.empty()))
        {
            if (bblob->cblob() != NULL)
            {
                C_OUTLINE_IT cout_it(cblob_it.data()->out_list());
                cout_it.move_to_last();
                cout_it.add_list_after(bblob->cblob()->out_list());
                delete bblob->cblob();
            }
        }
        else
        {
            if (bblob->cblob() != NULL)
            {
                cblob_it.add_after_then_move(bblob->cblob());
            }
            delete bblob;
        }
    }

    // Convert the TO_ROW to a ROW.
    ROW* real_row = new ROW(row, static_cast<inT16>(row->kern_size), static_cast<inT16>(row->space_size));

    WERD_IT word_it(real_row->word_list());
    WERD* word = new WERD(&cblobs, 0, NULL);
    word->set_flag(W_BOL, TRUE);
    word->set_flag(W_EOL, TRUE);
    word_it.add_after_then_move(word);
    ROW_IT row_it(real_rows);
    row_it.add_after_then_move(real_row);
}

/**
 * @name make_words
 *
 * Arrange the blobs into words.
 */

void make_words(//make words
                ICOORD page_tr,              //top right
                float gradient,              //page skew
                BLOCK_LIST *blocks,          //block list
                TO_BLOCK_LIST *land_blocks,  //rotated for landscape
                TO_BLOCK_LIST *port_blocks,  //output list
                Tesseract* tess
                )
{
    Q_UNUSED(blocks);
    Q_UNUSED(land_blocks);
    TO_BLOCK_IT block_it;          //iterator
    TO_BLOCK *block;               //current block;

    compute_fixed_pitch(page_tr, port_blocks, gradient, FCOORD (0.0f, -1.0f), !(BOOL8) textord_test_landscape, tess);

    if (global_monitor != NULL)
    {
        global_monitor->ocr_alive = TRUE;
        global_monitor->progress = 25;
    }

    to_spacing(page_tr, port_blocks);
    block_it.set_to_list (port_blocks);
    for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ())
    {
        block = block_it.data ();
        //set_row_spaces(block,FCOORD(1,0),!(BOOL8)textord_test_landscape);

        //make proper classes
        make_real_words(block, FCOORD(1.0f, 0.0f));
    }
}


/**
 * @name set_row_spaces
 *
 * Set the min_space and max_nonspace members of the row so that
 * the blobs can be arranged into words.
 */

void set_row_spaces(                  //find space sizes
                                      TO_BLOCK *block,  //block to do
                                      FCOORD rotation,  //for drawing
                                      BOOL8 testing_on  //correct orientation
                                      )
{
    Q_UNUSED(rotation);
    TO_ROW *row;                   //current row
    TO_ROW_IT row_it = block->get_rows ();

    if (row_it.empty ()) return;                      //empty block

    ceil(block->xheight * textord_words_maxspace);

    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
        row = row_it.data ();
        if (row->fixed_pitch == 0)
        {
            //                      if (!textord_test_mode
            //                      && row_words(block,row,maxwidth,rotation,testing_on)==0
            //                      || textord_test_mode
            //                      && row_words2(block,row,maxwidth,rotation,testing_on)==0)
            //                      {
            row->min_space = (inT32) ceil (row->pr_space - (row->pr_space - row->pr_nonsp) * textord_words_definite_spread);
            row->max_nonspace = (inT32) floor (row->pr_nonsp + (row->pr_space - row->pr_nonsp) * textord_words_definite_spread);
            if (testing_on && textord_show_initial_words)
            {
                tprintf ("Assigning defaults %d non, %d space to row at %g\n", row->max_nonspace, row->min_space, row->intercept ());
            }
            row->space_threshold = (row->max_nonspace + row->min_space) / 2;
            row->space_size = row->pr_space;
            row->kern_size = row->pr_nonsp;
            //                      }
        }
#ifndef GRAPHICS_DISABLED
        if (textord_show_initial_words && testing_on)
        {
            plot_word_decisions (to_win, (inT16) row->fixed_pitch, row);
        }
#endif
    }
}


/**
 * @name row_words
 *
 * Compute the max nonspace and min space for the row.
 */

inT32 row_words(                  //compute space size
                                  TO_BLOCK *block,  //block it came from
                                  TO_ROW *row,      //row to operate on
                                  inT32 maxwidth,   //max expected space size
                                  FCOORD rotation,  //for drawing
                                  BOOL8 testing_on  //for debug
                                  )
{
    Q_UNUSED(rotation);
    BOOL8 testing_row;             //contains testpt
    BOOL8 prev_valid;              //if decent size
    BOOL8 this_valid;              //current blob big enough
    inT32 prev_x;                  //end of prev blob
    inT32 cluster_count;           //no of clusters
    inT32 gap_index;               //which cluster
    inT32 smooth_factor;           //for smoothing stats
    BLOBNBOX *blob;                //current blob
    float lower, upper;            //clustering parameters
    float gaps[3];                 //gap clusers
    ICOORD testpt;
    TBOX blob_box;                  //bounding box
    //iterator
    BLOBNBOX_IT blob_it = row->blob_list ();
    STATS gap_stats (0, maxwidth);
    STATS cluster_stats[4];        //clusters

    testpt = ICOORD (textord_test_x, textord_test_y);
    smooth_factor = (inT32) (block->xheight * textord_wordstats_smooth_factor + 1.5);

    //      if (testing_on)
    //              tprintf("Row smooth factor=%d\n",smooth_factor);
    prev_valid = FALSE;
    prev_x = -MAX_INT32;
    testing_row = FALSE;

    for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ())
    {
        blob = blob_it.data ();
        blob_box = blob->bounding_box ();
        if (blob_box.contains (testpt))
        {
            testing_row = TRUE;
        }

        gap_stats.add (blob_box.width (), 1);
    }

    floor(gap_stats.ile (textord_words_width_ile));
    gap_stats.clear ();

    for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ())
    {
        blob = blob_it.data ();

        if (!blob->joined_to_prev ())
        {
            blob_box = blob->bounding_box ();

            //this_valid=blob_box.width()>=min_gap;
            this_valid = TRUE;
            if (this_valid && prev_valid && blob_box.left () - prev_x < maxwidth)
            {
                gap_stats.add (blob_box.left () - prev_x, 1);
            }

            prev_x = blob_box.right ();
            prev_valid = this_valid;
        }
    }

    if (gap_stats.get_total () == 0)
    {
        row->min_space = 0;          //no evidence
        row->max_nonspace = 0;
        return 0;
    }

    gap_stats.smooth (smooth_factor);
    lower = row->xheight * textord_words_initial_lower;
    upper = row->xheight * textord_words_initial_upper;
    cluster_count = gap_stats.cluster (lower, upper, textord_spacesize_ratioprop, 3, cluster_stats);

    while (cluster_count < 2 && ceil (lower) < floor (upper))
    {
        //shrink gap
        upper = (upper * 3 + lower) / 4;
        lower = (lower * 3 + upper) / 4;
        cluster_count = gap_stats.cluster (lower, upper, textord_spacesize_ratioprop, 3, cluster_stats);
    }

    if (cluster_count < 2)
    {
        row->min_space = 0;          //no evidence
        row->max_nonspace = 0;
        return 0;
    }

    for (gap_index = 0; gap_index < cluster_count; gap_index++)
    {
        gaps[gap_index] = cluster_stats[gap_index + 1].ile (0.5);
    }

    //get medians
    if (cluster_count > 2)
    {
        if (testing_on && textord_show_initial_words)
        {
            tprintf ("Row at %g has 3 sizes of gap:%g,%g,%g\n", row->intercept(),
                     cluster_stats[1].ile(0.5), cluster_stats[2].ile(0.5), cluster_stats[3].ile(0.5));
        }
        lower = gaps[0];

        if (gaps[1] > lower)
        {
            upper = gaps[1];           //prefer most frequent
            if (upper < block->xheight * textord_words_min_minspace && gaps[2] > gaps[1])
            {
                upper = gaps[2];
            }
        }
        else if (gaps[2] > lower && gaps[2] >= block->xheight * textord_words_min_minspace)
        {
            upper = gaps[2];
        }
        else if (lower >= block->xheight * textord_words_min_minspace)
        {
            upper = lower;             //not nice
            lower = gaps[1];

            if (testing_on && textord_show_initial_words)
            {
                tprintf ("Had to switch most common from lower to upper!!\n");
                gap_stats.print (stdout, TRUE);
            }
        }
        else
        {
            row->min_space = 0;        //no evidence
            row->max_nonspace = 0;
            return 0;
        }
    }
    else
    {
        if (gaps[1] < gaps[0])
        {
            if (testing_on && textord_show_initial_words)
            {
                tprintf ("Had to switch most common from lower to upper!!\n");
                gap_stats.print (stdout, TRUE);
            }

            lower = gaps[1];
            upper = gaps[0];
        }
        else
        {
            upper = gaps[1];
            lower = gaps[0];
        }
    }

    if (upper < block->xheight * textord_words_min_minspace)
    {
        row->min_space = 0;          //no evidence
        row->max_nonspace = 0;
        return 0;
    }

    if (upper * 3 < block->min_space * 2 + block->max_nonspace || lower * 3 > block->min_space * 2 + block->max_nonspace)
    {
        if (testing_on && textord_show_initial_words)
        {
            tprintf ("Disagreement between block and row at %g!!\n", row->intercept ());
            tprintf ("Lower=%g, upper=%g, Stats:\n", lower, upper);
            gap_stats.print (stdout, TRUE);
        }
    }

    row->min_space = (inT32) ceil (upper - (upper - lower) * textord_words_definite_spread);
    row->max_nonspace = (inT32) floor (lower + (upper - lower) * textord_words_definite_spread);
    row->space_threshold = (row->max_nonspace + row->min_space) / 2;
    row->space_size = upper;
    row->kern_size = lower;

    if (testing_on && textord_show_initial_words)
    {
        if (testing_row)
        {
            tprintf ("GAP STATS\n");
            gap_stats.print (stdout, TRUE);
            tprintf ("SPACE stats\n");
            cluster_stats[2].print (stdout, FALSE);
            tprintf ("NONSPACE stats\n");
            cluster_stats[1].print (stdout, FALSE);
        }

        tprintf ("Row at %g has minspace=%d(%g), max_non=%d(%g)\n", row->intercept (), row->min_space, upper, row->max_nonspace, lower);
    }

    return cluster_stats[2].get_total ();
}


/**
 * @name row_words2
 *
 * Compute the max nonspace and min space for the row.
 */

inT32 row_words2(                  //compute space size
                                   TO_BLOCK *block,  //block it came from
                                   TO_ROW *row,      //row to operate on
                                   inT32 maxwidth,   //max expected space size
                                   FCOORD rotation,  //for drawing
                                   BOOL8 testing_on  //for debug
                                   )
{
    Q_UNUSED(rotation);
    BOOL8 testing_row;             //contains testpt
    BOOL8 prev_valid;              //if decent size
    BOOL8 this_valid;              //current blob big enough
    inT32 prev_x;                  //end of prev blob
    inT32 min_width;               //min interesting width
    inT32 valid_count;             //good gaps
    inT32 total_count;             //total gaps
    inT32 cluster_count;           //no of clusters
    inT32 prev_count;              //previous cluster_count
    inT32 gap_index;               //which cluster
    inT32 smooth_factor;           //for smoothing stats
    BLOBNBOX *blob;                //current blob
    float lower, upper;            //clustering parameters
    ICOORD testpt;
    TBOX blob_box;                  //bounding box
    //iterator
    BLOBNBOX_IT blob_it = row->blob_list ();
    STATS gap_stats (0, maxwidth);
    //gap sizes
    float gaps[BLOCK_STATS_CLUSTERS];
    STATS cluster_stats[BLOCK_STATS_CLUSTERS + 1];
    //clusters

    testpt = ICOORD (textord_test_x, textord_test_y);
    smooth_factor = (inT32) (block->xheight * textord_wordstats_smooth_factor + 1.5);

    //      if (testing_on)
    //              tprintf("Row smooth factor=%d\n",smooth_factor);
    prev_valid = FALSE;
    prev_x = -MAX_INT16;
    testing_row = FALSE;

    //min blob size
    min_width = (inT32) block->pr_space;
    total_count = 0;

    for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ())
    {
        blob = blob_it.data ();
        if (!blob->joined_to_prev ())
        {
            blob_box = blob->bounding_box ();
            this_valid = blob_box.width () >= min_width;
            this_valid = TRUE;

            if (this_valid && prev_valid && blob_box.left () - prev_x < maxwidth)
            {
                gap_stats.add (blob_box.left () - prev_x, 1);
            }

            total_count++;             //count possibles
            prev_x = blob_box.right ();
            prev_valid = this_valid;
        }
    }

    valid_count = gap_stats.get_total ();
    if (valid_count < total_count * textord_words_minlarge)
    {
        gap_stats.clear ();
        prev_x = -MAX_INT16;

        for (blob_it.mark_cycle_pt (); !blob_it.cycled_list ();blob_it.forward ())
        {
            blob = blob_it.data ();
            if (!blob->joined_to_prev ())
            {
                blob_box = blob->bounding_box ();
                if (blob_box.left () - prev_x < maxwidth)
                {
                    gap_stats.add (blob_box.left () - prev_x, 1);
                }
                prev_x = blob_box.right ();
            }
        }
    }

    if (gap_stats.get_total () == 0)
    {
        row->min_space = 0;          //no evidence
        row->max_nonspace = 0;
        return 0;
    }

    cluster_count = 0;
    lower = block->xheight * words_initial_lower;
    upper = block->xheight * words_initial_upper;
    gap_stats.smooth (smooth_factor);

    do
    {
        prev_count = cluster_count;
        cluster_count = gap_stats.cluster (lower, upper, textord_spacesize_ratioprop, BLOCK_STATS_CLUSTERS, cluster_stats);
    }

    while (cluster_count > prev_count && cluster_count < BLOCK_STATS_CLUSTERS);
    if (cluster_count < 1)
    {
        row->min_space = 0;
        row->max_nonspace = 0;
        return 0;
    }

    for (gap_index = 0; gap_index < cluster_count; gap_index++)
    {
        gaps[gap_index] = cluster_stats[gap_index + 1].ile (0.5);
    }

    //get medians
    if (testing_on)
    {
        tprintf ("cluster_count=%d:", cluster_count);
        for (gap_index = 0; gap_index < cluster_count; gap_index++)
        {
            tprintf (" %g(%d)", gaps[gap_index],cluster_stats[gap_index + 1].get_total ());
        }
        tprintf ("\n");
    }

    //Try to find proportional non-space and space for row.
    for (gap_index = 0; gap_index < cluster_count && gaps[gap_index] > block->max_nonspace; gap_index++);
    if (gap_index < cluster_count)
    {
        lower = gaps[gap_index];     //most frequent below
    }
    else
    {
        if (testing_on)
        {
            tprintf ("No cluster below block threshold!, using default=%g\n", block->pr_nonsp);
        }
        lower = block->pr_nonsp;
    }

    for (gap_index = 0; gap_index < cluster_count && gaps[gap_index] <= block->max_nonspace; gap_index++);
    if (gap_index < cluster_count)
    {
        upper = gaps[gap_index];     //most frequent above
    }
    else
    {
        if (testing_on)
        {
            tprintf ("No cluster above block threshold!, using default=%g\n", block->pr_space);
        }
        upper = block->pr_space;
    }

    row->min_space = (inT32) ceil (upper - (upper - lower) * textord_words_definite_spread);
    row->max_nonspace = (inT32) floor (lower + (upper - lower) * textord_words_definite_spread);
    row->space_threshold = (row->max_nonspace + row->min_space) / 2;
    row->space_size = upper;
    row->kern_size = lower;

    if (testing_on)
    {
        if (testing_row)
        {
            tprintf ("GAP STATS\n");
            gap_stats.print (stdout, TRUE);
            tprintf ("SPACE stats\n");
            cluster_stats[2].print (stdout, FALSE);
            tprintf ("NONSPACE stats\n");
            cluster_stats[1].print (stdout, FALSE);
        }

        tprintf ("Row at %g has minspace=%d(%g), max_non=%d(%g)\n", row->intercept (), row->min_space, upper, row->max_nonspace, lower);
    }

    return 1;
}


/**
 * @name make_real_words
 *
 * Convert a TO_BLOCK to a BLOCK.
 */
//find lines
void make_real_words(TO_BLOCK *block,  //block to do
                     FCOORD rotation   //for drawing
                     )
{
    TO_ROW *row;                   //current row
    TO_ROW_IT row_it = block->get_rows();
    ROW *real_row = NULL;          //output row
    ROW_IT real_row_it = block->block->row_list();

    if (row_it.empty()) return;                      //empty block

    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
    {
        row = row_it.data();
        if (row->blob_list()->empty() && !row->rep_words.empty())
        {
            real_row = make_rep_words(row, block);
        }
        else if (!row->blob_list()->empty())
        {
            // In a fixed pitch document, some lines may be detected as fixed pitch
            // while others don't, and will go through different path.
            // For non-space delimited language like CJK, fixed pitch chop always
            // leave the entire line as one word.  We can force consistent chopping
            // with force_make_prop_words flag.
            if (textord_chopper_test)
            {
                real_row = make_blob_words(row, rotation);
            }
            else if (textord_force_make_prop_words || row->pitch_decision == PITCH_DEF_PROP || row->pitch_decision == PITCH_CORR_PROP)
            {
                real_row = make_prop_words(row, rotation);
            }
            else if (row->pitch_decision == PITCH_DEF_FIXED || row->pitch_decision == PITCH_CORR_FIXED)
            {
                real_row = fixed_pitch_words(row, rotation);
            }
            else
            {
                ASSERT_HOST(FALSE);
            }
        }

        if (real_row != NULL)
        {
            //put row in block
            real_row_it.add_after_then_move(real_row);
        }
    }

    block->block->set_stats(block->fixed_pitch == 0, (inT16)block->kern_size, (inT16) block->space_size, (inT16) block->fixed_pitch);
    block->block->check_pitch();
}


/**
 * @name make_rep_words
 *
 * Fabricate a real row from only the repeated blob words.
 * Get the xheight from the block as it may be more meaningful.
 */

ROW *make_rep_words(                 //make a row
                                     TO_ROW *row,     //row to convert
                                     TO_BLOCK *block  //block it lives in
                                     )
{
    ROW *real_row;                 //output row
    TBOX word_box;                  //bounding box

    //iterator
    WERD_IT word_it = &row->rep_words;

    if (word_it.empty ()) return NULL;

    word_box = word_it.data ()->bounding_box ();
    for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ())
    {
        word_box += word_it.data ()->bounding_box ();
    }

    row->xheight = block->xheight;

    real_row = new ROW(row, (inT16) block->kern_size, (inT16) block->space_size);
    word_it.set_to_list (real_row->word_list ());

    //put words in row
    word_it.add_list_after (&row->rep_words);
    real_row->recalc_bounding_box ();

    return real_row;
}


/**
 * @name make_real_word
 *
 * Construct a WERD from a given number of adjacent entries in a
 * list of BLOBNBOXs.
 */

WERD *make_real_word(                      //make a WERD
                                           BLOBNBOX_IT *box_it,  //iterator
                                           inT32 blobcount,      //no of blobs to use
                                           BOOL8 bol,            //start of line
                                           BOOL8 fuzzy_sp,       //fuzzy space
                                           BOOL8 fuzzy_non,      //fuzzy non-space
                                           uinT8 blanks          //no of blanks
                                           )
{
    OUTLINE_IT out_it;             //outlines
    C_OUTLINE_IT cout_it;
    PBLOB_LIST blobs;              //blobs in word
    C_BLOB_LIST cblobs;
    PBLOB_IT blob_it = &blobs;     //iterator
    C_BLOB_IT cblob_it = &cblobs;
    WERD *word;                    //new word
    BLOBNBOX *bblob;               //current blob
    inT32 blobindex;               //in row

    for (blobindex = 0; blobindex < blobcount; blobindex++)
    {
        bblob = box_it->extract ();
        if (bblob->joined_to_prev ())
        {
            if (bblob->blob () != NULL)
            {
                out_it.set_to_list (blob_it.data ()->out_list ());
                out_it.move_to_last ();
                out_it.add_list_after (bblob->blob ()->out_list ());
                delete bblob->blob ();
            }
            else if (bblob->cblob () != NULL)
            {
                cout_it.set_to_list (cblob_it.data ()->out_list ());
                cout_it.move_to_last ();
                cout_it.add_list_after (bblob->cblob ()->out_list ());
                delete bblob->cblob ();
            }
        }
        else
        {
            if (bblob->blob () != NULL)
                blob_it.add_after_then_move (bblob->blob ());
            else if (bblob->cblob () != NULL)
                cblob_it.add_after_then_move (bblob->cblob ());
        }

        delete bblob;
        box_it->forward ();          //next one
    }

    if (blanks < 1) blanks = 1;

    if (!blob_it.empty ())
    {
        //make real word
        word = new WERD (&blobs, blanks, NULL);
    }
    else
    {
        word = new WERD (&cblobs, blanks, NULL);
    }

    if (bol)
    {
        word->set_flag (W_BOL, TRUE);
    }

    if (fuzzy_sp)
    {
        //probably space
        word->set_flag (W_FUZZY_SP, TRUE);
    }
    else if (fuzzy_non)
    {
        //probably not
        word->set_flag (W_FUZZY_NON, TRUE);
    }

    if (box_it->at_first ())
    {
        word->set_flag (W_EOL, TRUE);//at end of line
    }

    return word;
}
/////////////////////////////////////////////////////////////////wordseg////////////////////////////////////////

/////////////////////////////////////////////////////////////////scanedg////////////////////////////////////////
#define WHITE_PIX     1          /*thresholded colours */
#define BLACK_PIX     0
/*W->B->W */
#define FLIP_COLOUR(pix)  (1-(pix))

#define EWSIZE        4          /*edge operator size */

#define XMARGIN       2          //margin needed
#define YMARGIN       3          //by edge detector

/*local freelist */
static CRACKEDGE *free_cracks = NULL;

/**********************************************************************
 * block_edges
 *
 * Extract edges from a PDBLK.
 **********************************************************************/

//get edges in a block
void block_edges(IMAGE *t_image, //threshold image
                        PDBLK *block,   //block in image
                        ICOORD page_tr  //corner of page
                       )
{
    Q_UNUSED(page_tr);
    uinT8 margin;                  //margin colour
    inT16 x;                       //line coords
    inT16 y;                       //current line
    ICOORD bleft;                  //bounding box
    ICOORD tright;
    ICOORD block_bleft;            //bounding box
    ICOORD block_tright;
    int xindex;                    //index to pixel
    BLOCK_LINE_IT line_it = block; //line iterator
    IMAGELINE bwline;              //thresholded line

    //lines in progress
    CRACKEDGE **ptrline = new CRACKEDGE*[t_image->get_xsize()+1];
    block->bounding_box(bleft, tright); // block box
    block_bleft = bleft;
    block_tright = tright;

    //no lines in progress
    for (x = tright.x() - bleft.x(); x >= 0; x--)
    {
        ptrline[x] = NULL;
    }

    bwline.init(t_image->get_xsize());
    margin = WHITE_PIX;

    for (y = tright.y() - 1; y >= bleft.y() - 1; y--)
     {
        if (y >= block_bleft.y() && y < block_tright.y())
        {
            t_image->get_line(bleft.x(), y, tright.x() - bleft.x(), &bwline, 0);
            make_margins(block, &line_it, bwline.pixels, margin, bleft.x(), tright.x(), y);
        }
        else
        {
            x = tright.x() - bleft.x();
            for (xindex = 0; xindex < x; xindex++)
            {
                bwline.pixels[xindex] = margin;
            }
        }

        line_edges(bleft.x(), y, tright.x() - bleft.x(), margin, bwline.pixels, ptrline);
    }

    free_crackedges(free_cracks);  //really free them
    free_cracks = NULL;

    delete[] ptrline;
}


/**********************************************************************
 * make_margins
 *
 * Get an image line and set to margin non-text pixels.
 **********************************************************************/
//get a line
void make_margins(PDBLK *block,//block in image
                  BLOCK_LINE_IT *line_it,  //for old style
                  uinT8 *pixels, //pixels to strip
                  uinT8 margin,  //white-out pixel
                  inT16 left,    //block edges
                  inT16 right,
                  inT16 y        //line coord
                 )
{
    PB_LINE_IT *lines;
    ICOORDELT_LIST *segments;      //bits of a line
    ICOORDELT_IT seg_it;
    inT32 start;                   //of segment
    inT16 xext;                    //of segment
    int xindex;                    //index to pixel

    if (block->poly_block() != NULL)
    {
        lines = new PB_LINE_IT (block->poly_block());
        segments = lines->get_line(y);

        if (!segments->empty())
        {
            seg_it.set_to_list(segments);
            seg_it.mark_cycle_pt();
            start = seg_it.data()->x();
            xext = seg_it.data()->y();

            for (xindex = left; xindex < right; xindex++)
            {
                if (xindex >= start && !seg_it.cycled_list())
                {
                    xindex = start + xext - 1;
                    seg_it.forward();
                    start = seg_it.data()->x();
                    xext = seg_it.data()->y();
                }
                else
                {
                    pixels[xindex - left] = margin;
                }
            }
        }
        else
        {
            for (xindex = left; xindex < right; xindex++)
            {
                pixels[xindex - left] = margin;
            }
        }

        delete segments;
        delete lines;
    }
    else
    {
        start = line_it->get_line(y, xext);

        for (xindex = left; xindex < start; xindex++)
        {
            pixels[xindex - left] = margin;
        }

        for (xindex = start + xext; xindex < right; xindex++)
        {
            pixels[xindex - left] = margin;
        }
    }
}


/**********************************************************************
 * whiteout_block
 *
 * Extract edges from a PDBLK.
 **********************************************************************/

//clean it          //threshold image  //block in image
void whiteout_block(IMAGE *t_image,    PDBLK *block)
{
    inT16 x;                       //line coords
    inT16 y;                       //current line
    inT16 xext;                    //line width
    int xindex;                    //index to pixel
    uinT8 *dest;                   //destination pixel
    TBOX block_box;                 //bounding box
    BLOCK_LINE_IT line_it = block; //line iterator
    IMAGELINE bwline;              //thresholded line

    block_box = block->bounding_box();
    for (y = block_box.bottom(); y < block_box.top(); y++)
    {
        //find line limits
        x = line_it.get_line(y, xext);
        t_image->get_line(x, y, xext, &bwline, 0);
        dest = bwline.pixels;        //destination pixel
        for (xindex = 0; xindex < xext; xindex++)
        {
            *dest++ = 1;
        }

        t_image->put_line(x, y, xext, &bwline, 0);
    }
}


/**********************************************************************
 * line_edges
 *
 * Scan a line for edges and update the edges in progress.
 * When edges close into loops, send them for approximation.
 **********************************************************************/

//scan for edges
void line_edges(inT16 x,//coord of line start
                inT16 y, //coord of line
                inT16 xext,  //width of line
                uinT8 uppercolour,//start of prev line
                uinT8 * bwpos, //thresholded line
                CRACKEDGE ** prevline //edges in progress
                )
{
    int xpos;                      //current x coord
    int xmax;                      //max x coord
    int colour;                    //of current pixel
    int prevcolour;                //of previous pixel
    CRACKEDGE *current;            //current h edge
    CRACKEDGE *newcurrent;         //new h edge

    xmax = x + xext;               //max allowable coord
    prevcolour = uppercolour;      //forced plain margin
    current = NULL;                //nothing yet

    //do each pixel
    for (xpos = x; xpos < xmax; xpos++, prevline++)
    {
        colour = *bwpos++;           //current pixel
        if (*prevline != NULL)
        {
            //changed above
            //change colour
            uppercolour = FLIP_COLOUR(uppercolour);
            if (colour == prevcolour)
            {
                if (colour == uppercolour)
                {
                    //finish a line
                    join_edges(current, *prevline);
                    current = NULL;        //no edge now
                }
                else//new horiz edge
                {
                    current = h_edge(xpos, y, uppercolour - colour, *prevline);
                }

                *prevline = NULL;        //no change this time
            }
            else
            {
                if (colour == uppercolour)
                {
                    *prevline = v_edge(xpos, y, colour - prevcolour, *prevline);
                }
                else if (colour == WHITE_PIX) //8 vs 4 connection
                {
                    join_edges(current, *prevline);
                    current = h_edge(xpos, y, uppercolour - colour, NULL);
                    *prevline = v_edge(xpos, y, colour - prevcolour, current);
                }
                else
                {
                    newcurrent = h_edge(xpos, y, uppercolour - colour, *prevline);
                    *prevline = v_edge(xpos, y, colour - prevcolour, current);
                    current = newcurrent;  //right going h edge
                }
                prevcolour = colour;     //remember new colour
            }
        }
        else
        {
            if (colour != prevcolour)
            {
                *prevline = current = v_edge(xpos, y, colour - prevcolour, current);
                prevcolour = colour;
            }

            if (colour != uppercolour)
            {
                current = h_edge(xpos, y, uppercolour - colour, current);
            }
            else
            {
                current = NULL;          //no edge now
            }
        }
    }

    if (current != NULL)
    {
        //out of block
        if (*prevline != NULL)
        {
            //got one to join to?
            join_edges(current, *prevline);
            *prevline = NULL;//tidy now
        }
        else
        {
            //fake vertical
            *prevline = v_edge(xpos, y, FLIP_COLOUR(prevcolour)-prevcolour, current);
        }
    }
    else if (*prevline != NULL)
    {
        //continue fake
        *prevline = v_edge(xpos, y, FLIP_COLOUR(prevcolour)-prevcolour, *prevline);
    }
}


/**********************************************************************
 * h_edge
 *
 * Create a new horizontal CRACKEDGE and join it to the given edge.
 **********************************************************************/

//horizontal edge
CRACKEDGE* h_edge(inT16 x, //xposition
                  inT16 y, //y position
                  inT8 sign, //sign of edge
                  CRACKEDGE * join //edge to join to
                  )
{
    CRACKEDGE *newpt;              //return value

    //check_mem("h_edge",JUSTCHECKS);
    if (free_cracks != NULL)
    {
        newpt = free_cracks;
        free_cracks = newpt->next;   //get one fast
    }
    else
    {
        newpt = new CRACKEDGE;
    }
    newpt->pos.set_y(y + 1);      //coords of pt
    newpt->stepy = 0;             //edge is horizontal

    if (sign > 0)
    {
        newpt->pos.set_x(x + 1);    //start location
        newpt->stepx = -1;
        newpt->stepdir = 0;
    }
    else
    {
        newpt->pos.set_x(x);        //start location
        newpt->stepx = 1;
        newpt->stepdir = 2;
    }

    if (join == NULL)
    {
        newpt->next = newpt;         //ptrs to other ends
        newpt->prev = newpt;
    }
    else
    {
        if (newpt->pos.x() + newpt->stepx == join->pos.x() && newpt->pos.y() == join->pos.y())
        {
            newpt->prev = join->prev;  //update other ends
            newpt->prev->next = newpt;
            newpt->next = join;        //join up
            join->prev = newpt;
        }
        else
        {
            newpt->next = join->next;  //update other ends
            newpt->next->prev = newpt;
            newpt->prev = join;        //join up
            join->next = newpt;
        }
    }

    return newpt;
}


/**********************************************************************
 * v_edge
 *
 * Create a new vertical CRACKEDGE and join it to the given edge.
 **********************************************************************/

//vertical edge
CRACKEDGE* v_edge(inT16 x, //xposition
                  inT16 y, //y position
                  inT8 sign, //sign of edge
                  CRACKEDGE * join //edge to join to
                  )
{
    CRACKEDGE *newpt;              //return value

    if (free_cracks != NULL)
    {
        newpt = free_cracks;
        free_cracks = newpt->next;   //get one fast
    }
    else
    {
        newpt = new CRACKEDGE;
    }
    newpt->pos.set_x(x);          //coords of pt
    newpt->stepx = 0;             //edge is vertical

    if (sign > 0)
    {
        newpt->pos.set_y(y);        //start location
        newpt->stepy = 1;
        newpt->stepdir = 3;
    }
    else
    {
        newpt->pos.set_y(y + 1);    //start location
        newpt->stepy = -1;
        newpt->stepdir = 1;
    }

    if (join == NULL)
    {
        newpt->next = newpt;         //ptrs to other ends
        newpt->prev = newpt;
    }
    else
    {
        if (newpt->pos.x() == join->pos.x() && newpt->pos.y() + newpt->stepy == join->pos.y())
        {
            newpt->prev = join->prev;  //update other ends
            newpt->prev->next = newpt;
            newpt->next = join;        //join up
            join->prev = newpt;
        }
        else
        {
            newpt->next = join->next;  //update other ends
            newpt->next->prev = newpt;
            newpt->prev = join;        //join up
            join->next = newpt;
        }
    }

    return newpt;
}


/**********************************************************************
 * join_edges
 *
 * Join 2 edges together. Send the outline for approximation when a
 * closed loop is formed.
 **********************************************************************/
//join edge fragments
void join_edges(CRACKEDGE *edge1, //edges to join
                CRACKEDGE *edge2 //no specific order
                )
{
    CRACKEDGE *tempedge;           //for exchanging

    if (edge1->pos.x() + edge1->stepx != edge2->pos.x() || edge1->pos.y() + edge1->stepy != edge2->pos.y())
    {
        tempedge = edge1;
        edge1 = edge2;               //swap araound
        edge2 = tempedge;
    }

    if (edge1->next == edge2)
    {
        //already closed
        complete_edge(edge1);  //approximate it

        //attach freelist to end
        edge1->prev->next = free_cracks;

        free_cracks = edge1;         //and free list
    }
    else
    {
        //update opposite ends
        edge2->prev->next = edge1->next;
        edge1->next->prev = edge2->prev;
        edge1->next = edge2;         //make joins
        edge2->prev = edge1;
    }
}


/**********************************************************************
 * free_crackedges
 *
 * Really free the CRACKEDGEs by giving them back to delete.
 **********************************************************************/

//really free them   //start of loop
void free_crackedges(CRACKEDGE *start)
{
    CRACKEDGE *current;            //current edge to free
    CRACKEDGE *next;               //next one to free

    for (current = start; current != NULL; current = next)
    {
        next = current->next;
        delete current;              //delete them all
    }
}
/////////////////////////////////////////////////////////////////scanedg////////////////////////////////////////

/////////////////////////////////////////////////////////////////drawedg////////////////////////////////////////
/** title of window */
#define IMAGE_WIN_NAME    "Edges"
#define IMAGE_XPOS      250
/** default position */
#define IMAGE_YPOS      0
/** control D */
#define CTRLD         '\004'

#define EXTERN

/**
 * @name create_edges_window
 *
 * Create the edges window.
 * @param page_tr size of image
 */

ScrollView* create_edges_window(ICOORD page_tr) {
  ScrollView* image_win;              //image window

                                 //create the window
  image_win = new ScrollView (IMAGE_WIN_NAME, IMAGE_XPOS, IMAGE_YPOS, 0, 0, page_tr.x (),  page_tr.y ());
  return image_win;              //window
}


/**
 * @name draw_raw_edge
 *
 * Draw the raw steps to the given window in the given colour.
 * @param fd window to draw in
 * @param start start of loop
 * @param colour colour to draw in
 */

void draw_raw_edge(ScrollView* fd,
                   CRACKEDGE *start,
                   ScrollView::Color colour) {
  CRACKEDGE *edgept;             //current point

  fd->Pen(colour);
  edgept = start;
  fd->SetCursor(edgept->pos.x (), edgept->pos.y ());
  do {
    do
    edgept = edgept->next;
                                 //merge straight lines
    while (edgept != start && edgept->prev->stepx == edgept->stepx && edgept->prev->stepy == edgept->stepy);

                                 //draw lines
  fd->DrawTo(edgept->pos.x (), edgept->pos.y ());
  }
  while (edgept != start);
}
/////////////////////////////////////////////////////////////////drawedg////////////////////////////////////////

/////////////////////////////////////////////////////////////////edgloop////////////////////////////////////////
#define MINEDGELENGTH   8        //min decent length
#define EXTERN
EXTERN double_VAR (edges_threshold_greyfraction, 0.07, "Min edge diff for grad vector");
EXTERN BOOL_VAR (edges_show_paths, FALSE, "Draw raw outlines");
EXTERN BOOL_VAR (edges_show_needles, FALSE, "Draw edge needles");
EXTERN INT_VAR (edges_maxedgelength, 16000, "Max steps in any outline");

#ifndef GRAPHICS_DISABLED
static ScrollView* edge_win;          //window
#endif
static C_OUTLINE_IT *outline_it; //iterator
static int short_edges;          //no of short ones
static int long_edges;           //no of long ones

/**********************************************************************
 * get_outlines
 *
 * Run the edge detector over the block and return a list of outlines.
 **********************************************************************/

void get_outlines(                      //edge detect
#ifndef GRAPHICS_DISABLED
                         ScrollView* window,        //window for output
#endif
                         IMAGE *image,         //image to scan
                         IMAGE *t_image,       //thresholded image
                         ICOORD page_tr,       //corner of page
                         PDBLK *block,         //block to scan
                         C_OUTLINE_IT *out_it  //output iterator
                        )
{
    Q_UNUSED(image);
#ifndef GRAPHICS_DISABLED
  edge_win = window;             //set statics
#endif
  outline_it = out_it;
  block_edges(t_image, block, page_tr);
  out_it->move_to_first();
#ifndef GRAPHICS_DISABLED
  if (window != NULL)
//    overlap_picture_ops(TRUE);  //update window
  ScrollView::Update();
#endif
}


/**********************************************************************
 * complete_edge
 *
 * Complete the edge by cleaning it up andapproximating it.
 **********************************************************************/
//clean and approximate //start of loop
void complete_edge(CRACKEDGE *start)
{
  ScrollView::Color colour;      //colour to draw in
  inT16 looplength;              //steps in loop
  ICOORD botleft;                //bounding box
  ICOORD topright;
  C_OUTLINE *outline;            //new outline

  //check length etc.
  colour = check_path_legal(start);
#ifndef GRAPHICS_DISABLED
  if (edges_show_paths)
  {
     //in red
    draw_raw_edge(edge_win, start, colour);
  }
#endif

  if (colour == ScrollView::RED || colour == ScrollView::BLUE)
  {
    looplength = loop_bounding_box(start, botleft, topright);
    outline = new C_OUTLINE(start, botleft, topright, looplength);

    //add to list
    outline_it->add_after_then_move(outline);
  }
}




/**********************************************************************
 * check_path_legal
 *
 * Check that the outline is legal for length and for chaincode sum.
 * The return value is RED for a normal black-inside outline,
 * BLUE for a white-inside outline, MAGENTA if it is too short,
 * YELLOW if it is too long, and GREEN if it is illegal.
 * These colours are used to draw the raw outline.
 **********************************************************************/

//certify outline                  //start of loop
ScrollView::Color check_path_legal(CRACKEDGE *start)
{
  int lastchain;              //last chain code
  int chaindiff;               //chain code diff
  inT32 length;                  //length of loop
  inT32 chainsum;                //sum of chain diffs
  CRACKEDGE *edgept;             //current point
  const ERRCODE ED_ILLEGAL_SUM = "Illegal sum of chain codes";

  length = 0;
  chainsum = 0;                  //sum of chain codes
  edgept = start;
  lastchain = edgept->prev->stepdir; //previous chain code

  do
  {
    length++;
    if (edgept->stepdir != lastchain)
    {
                                 //chain code difference
      chaindiff = edgept->stepdir - lastchain;
      if (chaindiff > 2)
      {
        chaindiff -= 4;
      }
      else if (chaindiff < -2)
      {
        chaindiff += 4;
      }

      chainsum += chaindiff;     //sum differences
      lastchain = edgept->stepdir;
    }

    edgept = edgept->next;
  }
  while (edgept != start && length < edges_maxedgelength);

  if ((chainsum != 4 && chainsum != -4) || edgept != start || length < MINEDGELENGTH)
  {
    if (edgept != start)
    {
      long_edges++;
      return ScrollView::YELLOW;
    }
    else if (length < MINEDGELENGTH)
    {
      short_edges++;
      return ScrollView::MAGENTA;
    }
    else
    {
      ED_ILLEGAL_SUM.error ("check_path_legal", TESSLOG, "chainsum=%d", chainsum);

      return ScrollView::GREEN;
    }
  }

  //colour on inside
  return chainsum < 0 ? ScrollView::BLUE : ScrollView::RED;
}

int iTimes = 0;
/**********************************************************************
 * loop_bounding_box
 *
 * Find the bounding box of the edge loop.
 **********************************************************************/

//get bounding box      //edge loop        //bounding box
inT16 loop_bounding_box(CRACKEDGE *&start, ICOORD &botleft, ICOORD &topright)
{
  inT16 length;                  //length of loop
  inT16 leftmost;                //on top row
  CRACKEDGE *edgept;             //current point
  CRACKEDGE *realstart;          //topleft start

  edgept = start;
  realstart = start;
  botleft = topright = ICOORD(edgept->pos.x(), edgept->pos.y());
  leftmost = edgept->pos.x();
  length = 0;                    //coutn length

  Mat mat(121, 421, CV_8UC3, Scalar(255, 255, 255));
  char szPath[1024] = {0};
  sprintf(szPath, "/home/osatnbzs/Desktop/img/d_%d.bmp", iTimes++);

  do
  {
    edgept = edgept->next;
    cv::line(mat, Point(edgept->pos.x(), edgept->pos.y()), Point(edgept->pos.x(), edgept->pos.y()), Scalar(0, 0, 255));

    if (edgept->pos.x() < botleft.x())
    {
      //get bounding box
      botleft.set_x(edgept->pos.x());
    }
    else if (edgept->pos.x() > topright.x())
    {
      topright.set_x(edgept->pos.x());
    }

    if (edgept->pos.y() < botleft.y())
    {
      //get bounding box
      botleft.set_y(edgept->pos.y());
    }
    else if (edgept->pos.y() > topright.y())
    {
      realstart = edgept;
      leftmost = edgept->pos.x();
      topright.set_y(edgept->pos.y());
    }
    else if (edgept->pos.y() == topright.y() && edgept->pos.x() < leftmost)
    {
      //leftmost on line
      leftmost = edgept->pos.x();
      realstart = edgept;
    }
    length++;                    //count elements

  }while(edgept != start);

  start = realstart;             //shift it to topleft

  imwrite(szPath, mat);

  return length;
}
/////////////////////////////////////////////////////////////////edgloop////////////////////////////////////////

/////////////////////////////////////////////////////////////////edgblob////////////////////////////////////////
#define EXTERN
// Control parameters used in outline_complexity(), which rejects an outline
// if any one of the 3 conditions is satisfied:
//  - number of children exceeds edges_max_children_per_outline
//  - number of nested layers exceeds edges_max_children_layers
//  - joint complexity exceeds edges_children_count_limit(as in child_count())
EXTERN BOOL_VAR(edges_use_new_outline_complexity, FALSE, "Use the new outline complexity module");
EXTERN INT_VAR(edges_max_children_per_outline, 10, "Max number of children inside a character outline");
EXTERN INT_VAR(edges_max_children_layers, 5, "Max layers of nested children inside a character outline");
EXTERN BOOL_VAR(edges_debug, FALSE, "turn on debugging for this module");


EXTERN INT_VAR(edges_children_per_grandchild, 10, "Importance ratio for chucking outlines");
EXTERN INT_VAR(edges_children_count_limit, 45, "Max holes allowed in blob");
EXTERN BOOL_VAR(edges_children_fix, FALSE, "Remove boxy parents of char-like children");
EXTERN INT_VAR(edges_min_nonhole, 12, "Min pixels for potential char in box");
EXTERN INT_VAR(edges_patharea_ratio, 40, "Max lensq/area for acceptable child outline");
EXTERN double_VAR(edges_childarea, 0.5, "Min area fraction of child outline");
EXTERN double_VAR(edges_boxarea, 0.875,"Min area fraction of grandchild for box");

/**
 * @name OL_BUCKETS::OL_BUCKETS
 *
 * Construct an array of buckets for associating outlines into blobs.
 */

// constructor         // corners
OL_BUCKETS::OL_BUCKETS(ICOORD bleft, ICOORD tright): bl(bleft), tr(tright)
{
  bxdim =(tright.x() - bleft.x()) / BUCKETSIZE + 1;
  bydim =(tright.y() - bleft.y()) / BUCKETSIZE + 1;

  // make array
  buckets = new C_OUTLINE_LIST[bxdim * bydim];
  index = 0;
}


/**
 * @name OL_BUCKETS::operator(
 *
 * Return a pointer to a list of C_OUTLINEs corresponding to the
 * given pixel coordinates.
 */
                            // array access     // image coords
C_OUTLINE_LIST* OL_BUCKETS::operator()(inT16 x, inT16 y)
{
  return &buckets[(y-bl.y()) / BUCKETSIZE * bxdim + (x-bl.x()) / BUCKETSIZE];
}


/**
 * @name OL_BUCKETS::outline_complexity
 *
 * This is the new version of count_child.
 *
 * The goal of this function is to determine if an outline and its
 * interiors could be part of a character blob.  This is done by
 * computing a "complexity" index for the outline, which is the return
 * value of this function, and checking it against a threshold.
 * The max_count is used for short-circuiting the recursion and forcing
 * a rejection that guarantees to fail the threshold test.
 * The complexity F for outline X with N children X[i] is
 *   F(X) = N + sum_i F(X[i]) * edges_children_per_grandchild
 * so each layer of nesting increases complexity exponentially.
 * An outline can be rejected as a text blob candidate if its complexity
 * is too high, has too many children(likely a container), or has too
 * many layers of nested inner loops.  This has the side-effect of
 * flattening out boxed or reversed video text regions.
 */

inT32 OL_BUCKETS::outline_complexity(
                                     C_OUTLINE *outline,   // parent outline
                                     inT32 max_count,      // max output
                                     inT16 depth           // recurion depth
                                    )
{
  inT16 xmin, xmax;              // coord limits
  inT16 ymin, ymax;
  inT16 xindex, yindex;          // current bucket
  C_OUTLINE *child;              // current child
  inT32 child_count;             // no of children
  inT32 grandchild_count;        // no of grandchildren
  C_OUTLINE_IT child_it;         // search iterator

  TBOX olbox = outline->bounding_box();
  xmin =(olbox.left() - bl.x()) / BUCKETSIZE;
  xmax =(olbox.right() - bl.x()) / BUCKETSIZE;
  ymin =(olbox.bottom() - bl.y()) / BUCKETSIZE;
  ymax =(olbox.top() - bl.y()) / BUCKETSIZE;
  child_count = 0;
  grandchild_count = 0;

  if (++depth > edges_max_children_layers)  // nested loops are too deep
  {
    return max_count + depth;
  }

  for (yindex = ymin; yindex <= ymax; yindex++)
  {
    for (xindex = xmin; xindex <= xmax; xindex++)
    {
      child_it.set_to_list(&buckets[yindex * bxdim + xindex]);

      if (child_it.empty()) continue;

      for (child_it.mark_cycle_pt(); !child_it.cycled_list(); child_it.forward())
      {
        child = child_it.data();

        if (child == outline || !(*child < *outline)) continue;
        child_count++;

        if (child_count > edges_max_children_per_outline)
        {   // too fragmented
          if (edges_debug)
          {
              tprintf("Discard outline on child_count=%d > " "max_children_per_outline=%d\n", child_count, static_cast<inT32>(edges_max_children_per_outline));
          }

          return max_count + child_count;
        }

        // Compute the "complexity" of each child recursively
        inT32 remaining_count = max_count - child_count - grandchild_count;
        if (remaining_count > 0)
        {
          grandchild_count += edges_children_per_grandchild * outline_complexity(child, remaining_count, depth);
        }

        if (child_count + grandchild_count > max_count)
        {
            // too complex
          if (edges_debug)
          {
              tprintf("Disgard outline on child_count=%d + grandchild_count=%d " "> max_count=%d\n", child_count, grandchild_count, max_count);
          }

          return child_count + grandchild_count;
        }
      }
    }
  }

  return child_count + grandchild_count;
}


/**
 * @name OL_BUCKETS::count_children
 *
 * Find number of descendants of this outline.
 */

inT32 OL_BUCKETS::count_children(                     // recursive count
                                 C_OUTLINE *outline,  // parent outline
                                 inT32 max_count      // max output
                                ) {
  BOOL8 parent_box;              // could it be boxy
  inT16 xmin, xmax;              // coord limits
  inT16 ymin, ymax;
  inT16 xindex, yindex;          // current bucket
  C_OUTLINE *child;              // current child
  inT32 child_count;             // no of children
  inT32 grandchild_count;        // no of grandchildren
  inT32 parent_area;             // potential box
  FLOAT32 max_parent_area;       // potential box
  inT32 child_area;              // current child
  inT32 child_length;            // current child
  TBOX olbox;
  C_OUTLINE_IT child_it;         // search iterator

  olbox = outline->bounding_box();
  xmin =(olbox.left() - bl.x()) / BUCKETSIZE;
  xmax =(olbox.right() - bl.x()) / BUCKETSIZE;
  ymin =(olbox.bottom() - bl.y()) / BUCKETSIZE;
  ymax =(olbox.top() - bl.y()) / BUCKETSIZE;
  child_count = 0;
  grandchild_count = 0;
  parent_area = 0;
  max_parent_area = 0;
  parent_box = TRUE;

  for (yindex = ymin; yindex <= ymax; yindex++)
  {
    for (xindex = xmin; xindex <= xmax; xindex++)
    {
      child_it.set_to_list(&buckets[yindex * bxdim + xindex]);
      if (child_it.empty()) continue;

      for (child_it.mark_cycle_pt(); !child_it.cycled_list(); child_it.forward())
      {
        child = child_it.data();
        if (child != outline && *child < *outline)
        {
          child_count++;
          if (child_count <= max_count)
          {
            int max_grand =(max_count - child_count) / edges_children_per_grandchild;
            if (max_grand > 0)
            {
              grandchild_count += count_children(child, max_grand) * edges_children_per_grandchild;
            }
            else
            {
              grandchild_count += count_children(child, 1);
            }
          }

          if (child_count + grandchild_count > max_count)
          {
            if (edges_debug) tprintf("Discarding parent with child count=%d, gc=%d\n", child_count,grandchild_count);

            return child_count + grandchild_count;
          }

          if (parent_area == 0)
          {
            parent_area = outline->outer_area();
            if (parent_area < 0) parent_area = -parent_area;

            max_parent_area = outline->bounding_box().area() * edges_boxarea;

            if (parent_area < max_parent_area) parent_box = FALSE;
          }

          if (parent_box && (!edges_children_fix || child->bounding_box().height() > edges_min_nonhole))
          {
            child_area = child->outer_area();
            if (child_area < 0) child_area = -child_area;

            if (edges_children_fix)
            {
              if (parent_area - child_area < max_parent_area)
              {
                parent_box = FALSE;
                continue;
              }

              if (grandchild_count > 0)
              {
                if (edges_debug)
                  tprintf("Discarding parent of area %d, child area=%d, max%g " "with gc=%d\n", parent_area, child_area, max_parent_area, grandchild_count);

                return max_count + 1;
              }

              child_length = child->pathlength();
              if (child_length * child_length > child_area * edges_patharea_ratio)
              {
                if (edges_debug)
                  tprintf("Discarding parent of area %d, child area=%d, max%g " "with child length=%d\n", parent_area, child_area, max_parent_area, child_length);

                return max_count + 1;
              }
            }

            if (child_area < child->bounding_box().area() * edges_childarea)
            {
              if (edges_debug)
                tprintf("Discarding parent of area %d, child area=%d, max%g " "with child rect=%d\n", parent_area, child_area, max_parent_area, child->bounding_box().area());

              return max_count + 1;
            }
          }
        }
      }
    }
  }

  return child_count + grandchild_count;
}




/**
 * @name OL_BUCKETS::extract_children
 *
 * Find number of descendants of this outline.
 */

void OL_BUCKETS::extract_children(                     // recursive count
                                  C_OUTLINE *outline,  // parent outline
                                  C_OUTLINE_IT *it     // destination iterator
                                 )
{
  inT16 xmin, xmax;              // coord limits
  inT16 ymin, ymax;
  inT16 xindex, yindex;          // current bucket
  TBOX olbox;
  C_OUTLINE_IT child_it;         // search iterator

  olbox = outline->bounding_box();
  xmin =(olbox.left() - bl.x()) / BUCKETSIZE;
  xmax =(olbox.right() - bl.x()) / BUCKETSIZE;
  ymin =(olbox.bottom() - bl.y()) / BUCKETSIZE;
  ymax =(olbox.top() - bl.y()) / BUCKETSIZE;

  for (yindex = ymin; yindex <= ymax; yindex++)
  {
    for (xindex = xmin; xindex <= xmax; xindex++)
    {
      child_it.set_to_list(&buckets[yindex * bxdim + xindex]);
      for (child_it.mark_cycle_pt(); !child_it.cycled_list(); child_it.forward())
      {
        if (*child_it.data() < *outline)
        {
          it->add_after_then_move(child_it.extract());
        }
      }
    }
  }
}


/**
 * @name extract_edges
 *
 * Run the edge detector over the block and return a list of blobs.
 */

void extract_edges(                 // find blobs
#ifndef GRAPHICS_DISABLED
                   ScrollView* window,   // window for output
#endif
                   IMAGE *image,    // image to scan
                   IMAGE *t_image,  // thresholded image
                   ICOORD page_tr,  // corner of page
                   BLOCK *block     // block to scan
                  )
{
  ICOORD bleft;                  // block box
  ICOORD tright;
  C_OUTLINE_LIST outlines;       // outlines in block
                                 // iterator
  C_OUTLINE_IT out_it = &outlines;

#ifndef GRAPHICS_DISABLED
  get_outlines(window, image, t_image, page_tr, (PDBLK*)block, &out_it);
#else
  get_outlines(image, t_image, page_tr, (PDBLK *) block, &out_it);
#endif

  //block box
  block->bounding_box(bleft, tright);

  //make blobs
  outlines_to_blobs(block, bleft, tright, &outlines);
}


/**
 * @name outlines_to_blobs
 *
 * Gather together outlines into blobs using the usual bucket sort.
 */

void outlines_to_blobs(               // find blobs
                       BLOCK *block,  // block to scan
                       ICOORD bleft,
                       ICOORD tright,
                       C_OUTLINE_LIST *outlines)
{
  // make buckets
  OL_BUCKETS buckets(bleft, tright);

  fill_buckets(outlines, &buckets);
  empty_buckets(block, &buckets);
}


/**
 * @name fill_buckets
 *
 * Run the edge detector over the block and return a list of blobs.
 */

void fill_buckets(                           // find blobs
                  C_OUTLINE_LIST *outlines,  // outlines in block
                  OL_BUCKETS *buckets        // output buckets
                 )
{
  TBOX ol_box;                     // outline box
  C_OUTLINE_IT out_it = outlines;  // iterator
  C_OUTLINE_IT bucket_it;          // iterator in bucket
  C_OUTLINE *outline;              // current outline

  for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward())
  {
    outline = out_it.extract();  // take off list

    // get box
    ol_box = outline->bounding_box();
    bucket_it.set_to_list((*buckets)(ol_box.left(), ol_box.bottom()));
    bucket_it.add_to_end(outline);
  }
}


/**
 * @name empty_buckets
 *
 * Run the edge detector over the block and return a list of blobs.
 */
// find blobs      // block to scan  // output buckets
void empty_buckets(BLOCK *block, OL_BUCKETS *buckets)
{
  BOOL8 good_blob;               // healthy blob
  C_OUTLINE_LIST outlines;       // outlines in block

  // iterator
  C_OUTLINE_IT out_it = &outlines;
  C_OUTLINE_IT bucket_it = buckets->start_scan();
  C_OUTLINE_IT parent_it;        // parent outline
  C_BLOB *blob;                  // new blob
  C_BLOB_IT good_blobs = block->blob_list();
  C_BLOB_IT junk_blobs = block->reject_blobs();

  while (!bucket_it.empty())
  {
    out_it.set_to_list(&outlines);
    do
    {
      parent_it = bucket_it;     // find outermost
      do
      bucket_it.forward();
      while (!bucket_it.at_first() && !(*parent_it.data() < *bucket_it.data()));
    }
    while (!bucket_it.at_first());

    // move to new list
    out_it.add_after_then_move(parent_it.extract());
    good_blob = capture_children(buckets, &junk_blobs, &out_it);
    blob = new C_BLOB(&outlines);

    if (good_blob)
    {
      good_blobs.add_after_then_move(blob);
    }
    else
    {
      junk_blobs.add_after_then_move(blob);
    }

    bucket_it.set_to_list(buckets->scan_next());
  }
}


/**
 * @name capture_children
 *
 * Find all neighbouring outlines that are children of this outline
 * and either move them to the output list or declare this outline
 * illegal and return FALSE.
 */

BOOL8 capture_children(                       // find children
                       OL_BUCKETS *buckets,   // bucket sort clanss
                       C_BLOB_IT *reject_it,  // dead grandchildren
                       C_OUTLINE_IT *blob_it  // output outlines
                      )
{
  Q_UNUSED(reject_it);
  C_OUTLINE *outline;            // master outline
  inT32 child_count;             // no of children

  outline = blob_it->data();
  if (edges_use_new_outline_complexity) child_count = buckets->outline_complexity(outline, edges_children_count_limit, 0);
  else
  {
    child_count = buckets->count_children(outline, edges_children_count_limit);
  }

  if (child_count > edges_children_count_limit) return FALSE;

  if (child_count > 0)
  {
    buckets->extract_children(outline, blob_it);
  }

  return TRUE;
}
/////////////////////////////////////////////////////////////////edgblob////////////////////////////////////////

/////////////////////////////////////////////////////////////////tordmain////////////////////////////////////////
const ERRCODE BLOCKLESS_BLOBS = "Warning:some blobs assigned to no block";

#undef EXTERN
#define EXTERN

EXTERN BOOL_VAR (textord_no_rejects, FALSE, "Don't remove noise blobs");
EXTERN BOOL_VAR (textord_show_blobs, FALSE, "Display unsorted blobs");
EXTERN BOOL_VAR (textord_show_boxes, FALSE, "Display unsorted blobs");
EXTERN BOOL_VAR (textord_new_initial_xheight, TRUE,
                 "Use test xheight mechanism");
EXTERN BOOL_VAR (textord_exit_after, FALSE, "Exit after completing textord");
EXTERN INT_VAR (textord_max_noise_size, 7, "Pixel size of noise");
EXTERN double_VAR (textord_blob_size_bigile, 95,
                   "Percentile for large blobs");
EXTERN double_VAR (textord_noise_area_ratio, 0.7,
                   "Fraction of bounding box for noise");
EXTERN double_VAR (textord_blob_size_smallile, 20,
                   "Percentile for small blobs");
EXTERN double_VAR (textord_initialx_ile, 0.75,
                   "Ile of sizes for xheight guess");
EXTERN double_VAR (textord_initialasc_ile, 0.90,
                   "Ile of sizes for xheight guess");
EXTERN INT_VAR (textord_noise_sizefraction, 10,
                "Fraction of size for maxima");
EXTERN double_VAR (textord_noise_sizelimit, 0.5,
                   "Fraction of x for big t count");
EXTERN INT_VAR (textord_noise_translimit, 16, "Transitions for normal blob");
EXTERN double_VAR (textord_noise_normratio, 2.0,
                   "Dot to norm ratio for deletion");
EXTERN BOOL_VAR (textord_noise_rejwords, TRUE, "Reject noise-like words");
EXTERN BOOL_VAR (textord_noise_rejrows, TRUE, "Reject noise-like rows");
EXTERN double_VAR (textord_noise_syfract, 0.2,
                   "xh fract error for norm blobs");
EXTERN double_VAR (textord_noise_sxfract, 0.4,
                   "xh fract width error for norm blobs");
EXTERN double_VAR(textord_noise_hfract, 1.0/64,
                  "Height fraction to discard outlines as speckle noise");
EXTERN INT_VAR (textord_noise_sncount, 1, "super norm blobs to save row");
EXTERN double_VAR (textord_noise_rowratio, 6.0,
                   "Dot to norm ratio for deletion");

EXTERN BOOL_VAR (textord_noise_debug, FALSE, "Debug row garbage detector");
EXTERN double_VAR (textord_blshift_maxshift, 0.00, "Max baseline shift");
EXTERN double_VAR (textord_blshift_xfraction, 9.99,
                   "Min size of baseline shift");
EXTERN STRING_EVAR (tessedit_image_ext, ".tif", "Externsion for image file");

#ifndef EMBEDDED
EXTERN clock_t previous_cpu;
#endif

extern BOOL_VAR_H (polygon_tess_approximation, TRUE,
                   "Do tess poly instead of grey scale");

#define MAX_NEAREST_DIST  600    //for block skew stats
#define MAX_BLOB_TRANSITIONS100  //for nois stats

extern IMAGE page_image;         //must be defined somewhere
extern BOOL_VAR_H (interactive_mode, TRUE, "Run interactively?");
extern /*"C" */ ETEXT_DESC *global_monitor;     //progress monitor

/**********************************************************************
 * find_components
 *
 * Find the C_OUTLINEs of the connected components in each block, put them
 * in C_BLOBs, and filter them by size, putting the different size
 * grades on different lists in the matching TO_BLOCK in port_blocks.
 **********************************************************************/
void find_components(BLOCK_LIST *blocks, TO_BLOCK_LIST *land_blocks, TO_BLOCK_LIST *port_blocks, TBOX *page_box)
{
    BLOCK *block;                  //current block
    BLOCK_IT block_it = blocks;    //iterator

    int width = page_image.get_xsize();
    int height = page_image.get_ysize();
    if (width > MAX_INT16 || height > MAX_INT16)
    {
        tprintf("Input image too large! (%d, %d)\n", width, height);
        return;  // Can't handle it.
    }

    ICOORD page_tr(width, height);
    block_it.set_to_list(blocks);
    if (global_monitor != NULL) global_monitor->ocr_alive = TRUE;

    set_global_loc_code(LOC_EDGE_PROG);
    if (!page_image.white_high()) invert_image(&page_image);

    #ifndef EMBEDDED
    previous_cpu = clock();
    #endif

    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward())
    {
        block = block_it.data();
        if (block->poly_block() == NULL || block->poly_block()->IsText())
        {
            #ifndef GRAPHICS_DISABLED
            extract_edges(NULL, &page_image, &page_image, page_tr, block);
            #else
            extract_edges(&page_image, &page_image, page_tr, block);
            #endif
            *page_box += block->bounding_box();
        }
    }

    if (global_monitor != NULL)
    {
        global_monitor->ocr_alive = TRUE;
        global_monitor->progress = 10;
    }

    assign_blobs_to_blocks2(blocks, land_blocks, port_blocks);
    if (global_monitor != NULL) global_monitor->ocr_alive = TRUE;
    filter_blobs(page_box->topright(), land_blocks, textord_test_landscape);

    #ifndef EMBEDDED
    previous_cpu = clock();
    #endif
    filter_blobs(page_box->topright(), port_blocks, !textord_test_landscape);
    if (global_monitor != NULL) global_monitor->ocr_alive = TRUE;
}

/**********************************************************************
 * SetBlobStrokeWidth
 *
 * Set the horizontal and vertical stroke widths in the blob.
 **********************************************************************/
void SetBlobStrokeWidth(bool debug, BLOBNBOX* blob)
{
    Q_UNUSED(debug);
#ifdef HAVE_LIBLEPT
    // Cut the blob rectangle into a Pix.
    // TODO(rays) make the page_image a Pix so this is more direct.
    const TBOX& box = blob->bounding_box();
    IMAGE blob_im;
    int width = box.width();
    int height = box.height();
    blob_im.create(width, height, 1);
    copy_sub_image(&page_image, box.left(), box.bottom(), width, height, &blob_im, 0, 0, false);
    Pix* pix = blob_im.ToPix();
    Pix* dist_pix = pixDistanceFunction(pix, 4, 8, L_BOUNDARY_BG);

    if (debug)
    {
        pixWrite("cutpix.png", pix, IFF_PNG);
        pixWrite("distpix.png", dist_pix, IFF_PNG);
    }

    pixDestroy(&pix);

    // Compute the stroke widths.
    uinT32* data = pixGetData(dist_pix);
    int wpl = pixGetWpl(dist_pix);

    // Horizontal width of stroke.
    STATS h_stats(0, width + 1);
    for (int y = 0; y < height; ++y)
    {
        uinT32* pixels = data + y*wpl;
        int prev_pixel = 0;
        int pixel = GET_DATA_BYTE(pixels, 0);

        for (int x = 1; x < width; ++x)
        {
            int next_pixel = GET_DATA_BYTE(pixels, x);

            // We are looking for a pixel that is equal to its vertical neighbours,
            // yet greater than its left neighbour.
            if (prev_pixel < pixel && (y == 0 || pixel == GET_DATA_BYTE(pixels - wpl, x - 1)) && (y == height - 1 || pixel == GET_DATA_BYTE(pixels + wpl, x - 1)))
            {
                if (pixel > next_pixel)
                {
                    // Single local max, so an odd width.
                    h_stats.add(pixel * 2 - 1, 1);
                }
                else if (pixel == next_pixel && x + 1 < width && pixel > GET_DATA_BYTE(pixels, x + 1))
                {
                    // Double local max, so an even width.
                    h_stats.add(pixel * 2, 1);
                }
            }

            prev_pixel = pixel;
            pixel = next_pixel;
        }
    }

    if (debug)
    {
        h_stats.print(stderr, true);
    }

    // Vertical width of stroke.
    STATS v_stats(0, height + 1);
    for (int x = 0; x < width; ++x)
    {
        int prev_pixel = 0;
        int pixel = GET_DATA_BYTE(data, x);
        for (int y = 1; y < height; ++y)
        {
            uinT32* pixels = data + y*wpl;
            int next_pixel = GET_DATA_BYTE(pixels, x);

            // We are looking for a pixel that is equal to its horizontal neighbours,
            // yet greater than its upper neighbour.
            if (prev_pixel < pixel && (x == 0 || pixel == GET_DATA_BYTE(pixels - wpl, x - 1)) &&
                    (x == width - 1 || pixel == GET_DATA_BYTE(pixels - wpl, x + 1)))
            {
                if (pixel > next_pixel)
                {
                    // Single local max, so an odd width.
                    v_stats.add(pixel * 2 - 1, 1);
                }
                else if (pixel == next_pixel && y + 1 < height && pixel > GET_DATA_BYTE(pixels + wpl, x))
                {
                    // Double local max, so an even width.
                    v_stats.add(pixel * 2, 1);
                }
            }

            prev_pixel = pixel;
            pixel = next_pixel;
        }
    }

    if (debug)
    {
        v_stats.print(stderr, true);
    }

    pixDestroy(&dist_pix);

    // Store the horizontal and vertical width in the blob, keeping both
    // widths if there is enough information, otherwse only the one with
    // the most samples.
    // If there are insufficent samples, store zero, rather than using
    // 2*area/perimeter, as the numbers that gives do not match the numbers
    // from the distance method.
    if (debug)
    {
        tprintf("box=%d,%d->%d,%d, hcount=%d, vcount=%d, target=%d\n",
                box.left(), box.bottom(), box.right(), box.top(),
                h_stats.get_total(), v_stats.get_total(), (width+height) /4);
        tprintf("hstats median=%f, lq=%f, uq=%f, sd=%f\n",
                h_stats.median(), h_stats.ile(0.25f), h_stats.ile(0.75f),
                h_stats.sd());
        tprintf("vstats median=%f, lq=%f, uq=%f, sd=%f\n",
                v_stats.median(), v_stats.ile(0.25f), v_stats.ile(0.75f),
                v_stats.sd());

    }

    if (h_stats.get_total() >= (width + height) / 4)
    {
        blob->set_horz_stroke_width(h_stats.ile(0.5f));
        if (v_stats.get_total() >= (width + height) / 4)
        {
            blob->set_vert_stroke_width(v_stats.ile(0.5f));
        }
        else
        {
            blob->set_vert_stroke_width(0.0f);
        }
    }
    else
    {
        if (v_stats.get_total() >= (width + height) / 4 || v_stats.get_total() > h_stats.get_total())
        {
            blob->set_horz_stroke_width(0.0f);
            blob->set_vert_stroke_width(v_stats.ile(0.5f));
        }
        else
        {
            blob->set_horz_stroke_width(h_stats.get_total() > 2 ? h_stats.ile(0.5f) : 0.0f);
            blob->set_vert_stroke_width(0.0f);
        }
    }
#else
    // Without leptonica present, use the 2*area/perimeter as an approximation.
    float width = 2.0f * blob->cblob()->area();
    width /= blob->cblob()->perimeter();
    blob->set_horz_stroke_width(width);
    blob->set_vert_stroke_width(width);
#endif
}


/**********************************************************************
 * assign_blobs_to_blocks2
 *
 * Make a list of TO_BLOCKs for portrait and landscape orientation.
 **********************************************************************/

void assign_blobs_to_blocks2(                             // split into groups
                                                          BLOCK_LIST *blocks,          // blocks to process
                                                          TO_BLOCK_LIST *land_blocks,  // ** unused **
                                                          TO_BLOCK_LIST *port_blocks   // output list
                                                          )
{
    Q_UNUSED(land_blocks);
    BLOCK *block;                  // current block
    BLOBNBOX *newblob;             // created blob
    C_BLOB *blob;                  // current blob
    BLOCK_IT block_it = blocks;
    C_BLOB_IT blob_it;             // iterator
    BLOBNBOX_IT port_box_it;       // iterator
    // destination iterator
    TO_BLOCK_IT port_block_it = port_blocks;
    TO_BLOCK *port_block;          // created block

    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward())
    {
        block = block_it.data();
        port_block = new TO_BLOCK(block);

        // Convert the good outlines to block->blob_list
        port_box_it.set_to_list(&port_block->blobs);
        blob_it.set_to_list(block->blob_list());

        for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward())
        {
            blob = blob_it.extract();
            newblob = new BLOBNBOX(blob);  // Convert blob to BLOBNBOX.
            SetBlobStrokeWidth(false, newblob);
            port_box_it.add_after_then_move(newblob);
        }

        // Put the rejected outlines in block->noise_blobs, which allows them to
        // be reconsidered and sorted back into rows and recover outlines mistakenly
        // rejected.
        port_box_it.set_to_list(&port_block->noise_blobs);
        blob_it.set_to_list(block->reject_blobs());
        for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward())
        {
            blob = blob_it.extract();
            newblob = new BLOBNBOX(blob);  // Convert blob to BLOBNBOX.
            SetBlobStrokeWidth(false, newblob);
            port_box_it.add_after_then_move(newblob);
        }

        port_block_it.add_after_then_move(port_block);
    }
}


/**********************************************************************
 * filter_blobs
 *
 * Sort the blobs into sizes in all the blocks for later work.
 **********************************************************************/
//split into groups
void filter_blobs(ICOORD page_tr,         //top right
                  TO_BLOCK_LIST *blocks,  //output list
                  BOOL8 testing_on        //for plotting
                  )
{
    TO_BLOCK_IT block_it = blocks; //destination iterator
    TO_BLOCK *block;               //created block

    if (to_win != NULL) to_win->Clear();

    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward ())
    {
        block = block_it.data();
        block->line_size = filter_noise_blobs(&block->blobs, &block->noise_blobs, &block->small_blobs, &block->large_blobs);
        block->line_spacing = block->line_size * (textord_merge_desc + textord_merge_x + textord_merge_asc + textord_merge_asc) / textord_merge_x;
        block->line_size *= textord_min_linesize;
        block->max_blob_size = block->line_size * textord_excess_blobsize;

#ifndef GRAPHICS_DISABLED
        if (textord_show_blobs && testing_on)
        {
            if (to_win == NULL) create_to_win(page_tr);
            block->plot_graded_blobs(to_win);
        }

        if (textord_show_boxes && testing_on)
        {
            if (to_win == NULL) create_to_win(page_tr);
            plot_box_list(to_win, &block->noise_blobs, ScrollView::WHITE);
            plot_box_list(to_win, &block->small_blobs, ScrollView::WHITE);
            plot_box_list(to_win, &block->large_blobs, ScrollView::WHITE);
            plot_box_list(to_win, &block->blobs, ScrollView::WHITE);
        }
#endif
    }
}


/**********************************************************************
 * filter_noise_blobs
 *
 * Move small blobs to a separate list.
 **********************************************************************/

float filter_noise_blobs(                            //separate noise
                                                     BLOBNBOX_LIST *src_list,    //origonal list
                                                     BLOBNBOX_LIST *noise_list,  //noise list
                                                     BLOBNBOX_LIST *small_list,  //small blobs
                                                     BLOBNBOX_LIST *large_list   //large blobs
                                                     )
{
    inT16 height;                  //height of blob
    inT16 width;                   //of blob
    BLOBNBOX_IT src_it = src_list; //iterators
    BLOBNBOX_IT noise_it = noise_list;
    BLOBNBOX_IT small_it = small_list;
    BLOBNBOX_IT large_it = large_list;
    STATS size_stats (0, MAX_NEAREST_DIST);

    //blob heights
    if (textord_new_initial_xheight) return filter_noise_blobs2(src_list, noise_list, small_list, large_list);
    float min_y;                   //size limits
    float max_y;
    float max_x;

    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward())
    {
        if (src_it.data()->bounding_box().height() < textord_max_noise_size) noise_it.add_after_then_move(src_it.extract());
    }

    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward())
    {
        size_stats.add (src_it.data()->bounding_box().height(), 1);
    }

    min_y = floor(size_stats.ile(textord_blob_size_smallile / 100.0));
    max_y = ceil(size_stats.ile(textord_blob_size_bigile / 100.0));
    max_x = ceil(size_stats.ile(0.5) * textord_width_limit);

    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward())
    {
        height = src_it.data()->bounding_box().height();
        width = src_it.data()->bounding_box().width();

        if (height < min_y)
        {
            small_it.add_after_then_move(src_it.extract());
        }
        else if (height > max_y || width > max_x)
        {
            large_it.add_after_then_move(src_it.extract());
        }
    }

    return size_stats.ile(textord_initialx_ile);
}


/**********************************************************************
 * filter_noise_blobs2
 *
 * Move small blobs to a separate list.
 **********************************************************************/

float filter_noise_blobs2(                            //separate noise
                                                      BLOBNBOX_LIST *src_list,    //origonal list
                                                      BLOBNBOX_LIST *noise_list,  //noise list
                                                      BLOBNBOX_LIST *small_list,  //small blobs
                                                      BLOBNBOX_LIST *large_list   //large blobs
                                                      )
{
    inT16 height;                  //height of blob
    inT16 width;                   //of blob
    BLOBNBOX *blob;                //current blob
    float initial_x;               //first guess
    BLOBNBOX_IT src_it = src_list; //iterators
    BLOBNBOX_IT noise_it = noise_list;
    BLOBNBOX_IT small_it = small_list;
    BLOBNBOX_IT large_it = large_list;
    STATS size_stats (0, MAX_NEAREST_DIST);
    //blob heights
    float min_y;                   //size limits
    float max_y;
    float max_x;
    float max_height;              //of good blobs

    for (src_it.mark_cycle_pt (); !src_it.cycled_list (); src_it.forward ())
    {
        blob = src_it.data ();
        if (blob->bounding_box ().height () < textord_max_noise_size)
        {
            noise_it.add_after_then_move (src_it.extract ());
        }
        else if (blob->enclosed_area () >= blob->bounding_box ().height () * blob->bounding_box ().width () * textord_noise_area_ratio)
        {
            small_it.add_after_then_move (src_it.extract ());
        }
    }

    for (src_it.mark_cycle_pt (); !src_it.cycled_list (); src_it.forward ())
    {
        size_stats.add (src_it.data ()->bounding_box ().height (), 1);
    }

    initial_x = size_stats.ile (textord_initialx_ile);
    max_y = ceil (initial_x * (textord_merge_desc + textord_merge_x + 2 * textord_merge_asc) / textord_merge_x);
    min_y = floor (initial_x / 2);
    max_x = ceil (initial_x * textord_width_limit);
    small_it.move_to_first ();

    for (small_it.mark_cycle_pt (); !small_it.cycled_list (); small_it.forward ())
    {
        height = small_it.data()->bounding_box().height();
        if (height > max_y)
            large_it.add_after_then_move(small_it.extract ());
        else if (height >= min_y)
            src_it.add_after_then_move(small_it.extract ());
    }

    size_stats.clear ();
    for (src_it.mark_cycle_pt (); !src_it.cycled_list (); src_it.forward ())
    {
        height = src_it.data ()->bounding_box ().height ();
        width = src_it.data ()->bounding_box ().width ();
        if (height < min_y)
        {
            small_it.add_after_then_move (src_it.extract ());
        }
        else if (height > max_y || width > max_x)
        {
            large_it.add_after_then_move (src_it.extract ());
        }
        else
        {
            size_stats.add (height, 1);
        }
    }

    max_height = size_stats.ile (textord_initialasc_ile);
    //      printf("max_y=%g, min_y=%g, initial_x=%g, max_height=%g,",
    //              max_y,min_y,initial_x,max_height);

    max_height *= textord_merge_x / (textord_merge_x + textord_merge_asc);
    if (max_height > initial_x) initial_x = max_height;
    //      printf(" ret=%g\n",initial_x);

    return initial_x;
}


/**********************************************************************
 * textord_page
 *
 * Textord the list of blobs and return a list of proper blocks.
 **********************************************************************/

void textord_page(//make rows & words
                  ICOORD page_tr,              //top right
                  BLOCK_LIST *blocks,          //block list
                  TO_BLOCK_LIST *land_blocks,  //rotated for landscape
                  TO_BLOCK_LIST *port_blocks,  //output list
                  Tesseract* tess
                  )
{
    float gradient;                //global skew

    set_global_loc_code(LOC_TEXT_ORD_ROWS);
    gradient = make_rows(page_tr, blocks, land_blocks, port_blocks, tess);

    if (global_monitor != NULL)
    {
        global_monitor->ocr_alive = TRUE;
        global_monitor->progress = 20;
    }

    set_global_loc_code(LOC_TEXT_ORD_WORDS);
    make_words(page_tr, gradient, blocks, land_blocks, port_blocks, tess);
    if (global_monitor != NULL)
    {
        global_monitor->ocr_alive = TRUE;
        global_monitor->progress = 30;
    }

    cleanup_blocks(blocks);  //remove empties
#ifndef GRAPHICS_DISABLED
    close_to_win();
#endif
    if (textord_exit_after && !interactive_mode) exit (0);
}

/**********************************************************************
 * cleanup_blocks
 *
 * Delete empty blocks, rows from the page.
 **********************************************************************/

void cleanup_blocks(                    //remove empties
                                        BLOCK_LIST *blocks  //list
                                        )
{
    BLOCK_IT block_it = blocks;    //iterator
    ROW_IT row_it;                 //row iterator

    for (block_it.mark_cycle_pt (); !block_it.cycled_list ();
         block_it.forward ())
    {
        row_it.set_to_list (block_it.data ()->row_list ());
        for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
        {
            clean_small_noise_from_words(row_it.data());
            if ((textord_noise_rejrows && !row_it.data ()->word_list ()->empty () && clean_noise_from_row (row_it.data ())) || row_it.data ()->word_list ()->empty ())
                delete row_it.extract ();//lose empty row
            else
            {
                if (textord_noise_rejwords)
                {
                    clean_noise_from_words (row_it.data ());
                }
                if (textord_blshift_maxshift >= 0)
                {
                    tweak_row_baseline (row_it.data ());
                }
            }
        }

        if (block_it.data ()->row_list ()->empty ())
        {
            delete block_it.extract ();//lose empty block
        }
    }
}


/**********************************************************************
 * clean_noise_from_row
 *
 * Move blobs of words from rows of garbage into the reject blobs list.
 **********************************************************************/

BOOL8 clean_noise_from_row(          //remove empties
                                     ROW *row  //row to clean
                                     )
{
    BOOL8 testing_on;
    TBOX blob_box;                  //bounding box
    C_BLOB *blob;                  //current blob
    C_OUTLINE *outline;            //current outline
    WERD *word;                    //current word
    inT32 blob_size;               //biggest size
    inT32 trans_count = 0;         //no of transitions
    inT32 trans_threshold;         //noise tolerance
    inT32 dot_count;               //small objects
    inT32 norm_count;              //normal objects
    inT32 super_norm_count;        //real char-like
    //words of row
    WERD_IT word_it = row->word_list ();
    C_BLOB_IT blob_it;             //blob iterator
    C_OUTLINE_IT out_it;           //outline iterator

    if (textord_test_y > row->base_line (textord_test_x) && textord_show_blobs && textord_test_y < row->base_line (textord_test_x) + row->x_height ())
    {
        testing_on = TRUE;
    }
    else
    {
        testing_on = FALSE;
    }

    dot_count = 0;
    norm_count = 0;
    super_norm_count = 0;
    for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ())
    {
        word = word_it.data ();      //current word
        //blobs in word
        blob_it.set_to_list (word->cblob_list ());
        for (blob_it.mark_cycle_pt (); !blob_it.cycled_list ();   blob_it.forward ())
        {
            blob = blob_it.data ();
            if (!word->flag (W_DONT_CHOP))
            {
                //get outlines
                out_it.set_to_list (blob->out_list ());
                for (out_it.mark_cycle_pt (); !out_it.cycled_list (); out_it.forward ())
                {
                    outline = out_it.data ();
                    blob_box = outline->bounding_box ();
                    blob_size = blob_box.width () > blob_box.height ()? blob_box.width () : blob_box. height();

                    if (blob_size < textord_noise_sizelimit * row->x_height ()) dot_count++;         //count smal outlines
                    if (!outline->child ()->empty () && blob_box.height () < (1 + textord_noise_syfract) * row->x_height () &&
                            blob_box.height () > (1 - textord_noise_syfract) * row->x_height () &&
                            blob_box.width () < (1 + textord_noise_sxfract) * row->x_height () &&
                            blob_box.width () > (1 - textord_noise_sxfract) * row->x_height ())
                    {
                        super_norm_count++;  //count smal outlines
                    }
                }
            }
            else
            {
                super_norm_count++;
            }

            blob_box = blob->bounding_box ();
            blob_size = blob_box.width () > blob_box.height ()? blob_box.width () : blob_box.height ();

            if (blob_size >= textord_noise_sizelimit * row->x_height () && blob_size < row->x_height () * 2)
            {
                trans_threshold = blob_size / textord_noise_sizefraction;
                trans_count = blob->count_transitions (trans_threshold);
                if (trans_count < textord_noise_translimit) norm_count++;
            }
            else if (blob_box.height () > row->x_height () * 2 && (!word_it.at_first () || !blob_it.at_first ()))
            {
                dot_count += 2;
            }
#ifndef SECURE_NAMES
            if (testing_on)
            {
                tprintf
                        ("Blob at (%d,%d) -> (%d,%d), ols=%d, tc=%d, bldiff=%g\n",
                         blob_box.left (), blob_box.bottom (), blob_box.right (),
                         blob_box.top (), blob->out_list ()->length (), trans_count,
                         blob_box.bottom () - row->base_line (blob_box.left ()));
            }
#endif
        }
    }
#ifndef SECURE_NAMES
    if (textord_noise_debug)
    {
        tprintf ("Row ending at (%d,%g):",
                 blob_box.right (), row->base_line (blob_box.right ()));
        tprintf (" R=%g, dc=%d, nc=%d, %s\n",
                 norm_count > 0 ? (float) dot_count / norm_count : 9999,
                 dot_count, norm_count,
                 dot_count > norm_count * textord_noise_normratio
                 && dot_count > 2 ? "REJECTED" : "ACCEPTED");
    }
#endif
    return super_norm_count < textord_noise_sncount
            && dot_count > norm_count * textord_noise_rowratio && dot_count > 2;
}


/**********************************************************************
 * clean_noise_from_words
 *
 * Move blobs of words from rows of garbage into the reject blobs list.
 **********************************************************************/

void clean_noise_from_words(          //remove empties
                                      ROW *row  //row to clean
                                      )
{
    TBOX blob_box;                  //bounding box
    inT8 *word_dud;                //was it chucked
    C_BLOB *blob;                  //current blob
    C_OUTLINE *outline;            //current outline
    WERD *word;                    //current word
    inT32 blob_size;               //biggest size
    inT32 trans_count;             //no of transitions
    inT32 trans_threshold;         //noise tolerance
    inT32 dot_count;               //small objects
    inT32 norm_count;              //normal objects
    inT32 dud_words;               //number discarded
    inT32 ok_words;                //number remaining
    inT32 word_index;              //current word
    //words of row
    WERD_IT word_it = row->word_list ();
    C_BLOB_IT blob_it;             //blob iterator
    C_OUTLINE_IT out_it;           //outline iterator

    ok_words = word_it.length ();
    if (ok_words == 0 || textord_no_rejects) return;
    word_dud = (inT8 *) alloc_mem (ok_words * sizeof (inT8));
    dud_words = 0;
    ok_words = 0;
    word_index = 0;

    for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ())
    {
        word = word_it.data ();      //current word
        dot_count = 0;
        norm_count = 0;
        //blobs in word
        blob_it.set_to_list (word->cblob_list ());
        for (blob_it.mark_cycle_pt (); !blob_it.cycled_list ();
             blob_it.forward ())
        {
            blob = blob_it.data ();
            if (!word->flag (W_DONT_CHOP))
            {
                //get outlines
                out_it.set_to_list (blob->out_list ());
                for (out_it.mark_cycle_pt (); !out_it.cycled_list (); out_it.forward ())
                {
                    outline = out_it.data ();
                    blob_box = outline->bounding_box ();
                    blob_size = blob_box.width () > blob_box.height ()? blob_box.width () : blob_box. height();
                    if (blob_size < textord_noise_sizelimit * row->x_height ()) dot_count++;         //count smal outlines

                    if (!outline->child ()->empty () &&
                            blob_box.height () < (1 + textord_noise_syfract) * row->x_height () &&
                            blob_box.height () > (1 - textord_noise_syfract) * row->x_height () &&
                            blob_box.width () < (1 + textord_noise_sxfract) * row->x_height () &&
                            blob_box.width () > (1 - textord_noise_sxfract) * row->x_height ())
                    {
                        norm_count++;        //count smal outlines
                    }
                }
            }
            else
            {
                norm_count++;
            }

            blob_box = blob->bounding_box ();
            blob_size = blob_box.width () > blob_box.height ()? blob_box.width () : blob_box.height ();

            if (blob_size >= textord_noise_sizelimit * row->x_height () && blob_size < row->x_height () * 2)
            {
                trans_threshold = blob_size / textord_noise_sizefraction;
                trans_count = blob->count_transitions (trans_threshold);
                if (trans_count < textord_noise_translimit) norm_count++;
            }
            else if (blob_box.height () > row->x_height () * 2 && (!word_it.at_first () || !blob_it.at_first ()))
            {
                dot_count += 2;
            }
        }

        if (dot_count > 2)
        {
            if (dot_count > norm_count * textord_noise_normratio * 2)
            {
                word_dud[word_index] = 2;
            }
            else if (dot_count > norm_count * textord_noise_normratio)
            {
                word_dud[word_index] = 1;
            }
            else
            {
                word_dud[word_index] = 0;
            }
        }
        else
        {
            word_dud[word_index] = 0;
        }

        if (word_dud[word_index] == 2)
        {
            dud_words++;
        }
        else
        {
            ok_words++;
        }

        word_index++;
    }

    word_index = 0;
    for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ())
    {
        if (word_dud[word_index] == 2 || (word_dud[word_index] == 1 && dud_words > ok_words))
        {
            word = word_it.data ();    //current word
            //rejected blobs
            blob_it.set_to_list (word->rej_cblob_list ());
            //move from blobs
            blob_it.add_list_after (word->cblob_list ());
        }

        word_index++;
    }

    free_mem(word_dud);
}

// Remove outlines that are a tiny fraction in either width or height
// of the word height.
void clean_small_noise_from_words(ROW *row)
{
    WERD_IT word_it(row->word_list());
    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward())
    {
        WERD* word = word_it.data();
        int min_size = static_cast<int>(textord_noise_hfract * word->bounding_box().height() + 0.5);
        C_BLOB_IT blob_it(word->cblob_list());

        for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward())
        {
            C_BLOB* blob = blob_it.data();
            C_OUTLINE_IT out_it(blob->out_list());

            for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward())
            {
                C_OUTLINE* outline = out_it.data();
                outline->RemoveSmallRecursive(min_size, &out_it);
            }

            if (blob->out_list()->empty())
            {
                delete blob_it.extract();
            }
        }

        if (word->cblob_list()->empty())
        {
            if (!word_it.at_last()) {
                // The next word is no longer a fuzzy non space if it was before,
                // since the word before is about to be deleted.
                WERD* next_word = word_it.data_relative(1);
                if (next_word->flag(W_FUZZY_NON))
                {
                    next_word->set_flag(W_FUZZY_NON, false);
                }
            }

            delete word_it.extract();
        }
    }
}


/**********************************************************************
 * tweak_row_baseline
 *
 * Shift baseline to fit the blobs more accurately where they are
 * close enough.
 **********************************************************************/

void tweak_row_baseline(          //remove empties
                                  ROW *row  //row to clean
                                  )
{
    TBOX blob_box;                  //bounding box
    C_BLOB *blob;                  //current blob
    WERD *word;                    //current word
    inT32 blob_count;              //no of blobs
    inT32 src_index;               //source segment
    inT32 dest_index;              //destination segment
    inT32 *xstarts;                //spline segments
    double *coeffs;                //spline coeffs
    float ydiff;                   //baseline error
    float x_centre;                //centre of blob
    //words of row
    WERD_IT word_it = row->word_list ();
    C_BLOB_IT blob_it;             //blob iterator

    blob_count = 0;
    for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ())
    {
        word = word_it.data ();      //current word
        //get total blobs
        blob_count += word->cblob_list ()->length ();
    }

    if (blob_count == 0) return;
    xstarts = (inT32 *) alloc_mem ((blob_count + row->baseline.segments + 1) * sizeof (inT32));
    coeffs = (double *) alloc_mem ((blob_count + row->baseline.segments) * 3 * sizeof (double));

    src_index = 0;
    dest_index = 0;
    xstarts[0] = row->baseline.xcoords[0];
    for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ())
    {
        word = word_it.data ();      //current word
        //blobs in word
        blob_it.set_to_list (word->cblob_list ());

        for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ())
        {
            blob = blob_it.data ();
            blob_box = blob->bounding_box ();
            x_centre = (blob_box.left () + blob_box.right ()) / 2.0;
            ydiff = blob_box.bottom () - row->base_line (x_centre);

            if (ydiff < 0)
            {
                ydiff = -ydiff / row->x_height ();
            }
            else
            {
                ydiff = ydiff / row->x_height ();
            }

            if (ydiff < textord_blshift_maxshift  && blob_box.height () / row->x_height () > textord_blshift_xfraction)
            {
                if (xstarts[dest_index] >= x_centre) xstarts[dest_index] = blob_box.left ();
                coeffs[dest_index * 3] = 0;
                coeffs[dest_index * 3 + 1] = 0;
                coeffs[dest_index * 3 + 2] = blob_box.bottom ();

                //shift it
                dest_index++;
                xstarts[dest_index] = blob_box.right () + 1;
            }
            else
            {
                if (xstarts[dest_index] <= x_centre)
                {
                    while (row->baseline.xcoords[src_index + 1] <= x_centre && src_index < row->baseline.segments - 1)
                    {
                        if (row->baseline.xcoords[src_index + 1] > xstarts[dest_index])
                        {
                            coeffs[dest_index * 3] = row->baseline.quadratics[src_index].a;
                            coeffs[dest_index * 3 + 1] = row->baseline.quadratics[src_index].b;
                            coeffs[dest_index * 3 + 2] = row->baseline.quadratics[src_index].c;
                            dest_index++;
                            xstarts[dest_index] = row->baseline.xcoords[src_index + 1];
                        }

                        src_index++;
                    }

                    coeffs[dest_index * 3] = row->baseline.quadratics[src_index].a;
                    coeffs[dest_index * 3 + 1] = row->baseline.quadratics[src_index].b;
                    coeffs[dest_index * 3 + 2] = row->baseline.quadratics[src_index].c;
                    dest_index++;
                    xstarts[dest_index] = row->baseline.xcoords[src_index + 1];
                }
            }
        }
    }

    while (src_index < row->baseline.segments && row->baseline.xcoords[src_index + 1] <= xstarts[dest_index]) src_index++;

    while (src_index < row->baseline.segments)
    {
        coeffs[dest_index * 3] = row->baseline.quadratics[src_index].a;
        coeffs[dest_index * 3 + 1] = row->baseline.quadratics[src_index].b;
        coeffs[dest_index * 3 + 2] = row->baseline.quadratics[src_index].c;
        dest_index++;
        src_index++;
        xstarts[dest_index] = row->baseline.xcoords[src_index];
    }
    //turn to spline
    row->baseline = QSPLINE (dest_index, xstarts, coeffs);
    free_mem(xstarts);
    free_mem(coeffs);
}


/**********************************************************************
 * blob_y_order
 *
 * Sort function to sort blobs in y from page top.
 **********************************************************************/

inT32 blob_y_order(              //sort function
                                 void *item1,  //items to compare
                                 void *item2)
{
    //converted ptr
    BLOBNBOX *blob1 = *(BLOBNBOX **) item1;
    //converted ptr
    BLOBNBOX *blob2 = *(BLOBNBOX **) item2;

    if (blob1->bounding_box ().bottom () > blob2->bounding_box ().bottom ())
    {
        return -1;
    }
    else if (blob1->bounding_box ().bottom () <  blob2->bounding_box ().bottom ())
    {
        return 1;
    }
    else
    {
        if (blob1->bounding_box ().left () < blob2->bounding_box ().left ())
        {
            return -1;
        }
        else if (blob1->bounding_box ().left () >  blob2->bounding_box ().left ())
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
}
/////////////////////////////////////////////////////////////////tordmain////////////////////////////////////////

/////////////////////////////////////////////////////////////////genblob////////////////////////////////////////
/**********************************************************************
 *  blob_comparator()
 *
 *  Blob comparator used to sort a blob list so that blobs are in increasing
 *  order of left edge.
 **********************************************************************/

int blob_comparator(                     //sort blobs
                    const void *blob1p,  //ptr to ptr to blob1
                    const void *blob2p   //ptr to ptr to blob2
                   ) {
  PBLOB *blob1 = *(PBLOB **) blob1p;
  PBLOB *blob2 = *(PBLOB **) blob2p;

  return blob1->bounding_box ().left () - blob2->bounding_box ().left ();
}


/**********************************************************************
 *  c_blob_comparator()
 *
 *  Blob comparator used to sort a blob list so that blobs are in increasing
 *  order of left edge.
 **********************************************************************/

int c_blob_comparator(                     //sort blobs
                      const void *blob1p,  //ptr to ptr to blob1
                      const void *blob2p   //ptr to ptr to blob2
                     ) {
  C_BLOB *blob1 = *(C_BLOB **) blob1p;
  C_BLOB *blob2 = *(C_BLOB **) blob2p;

  return blob1->bounding_box ().left () - blob2->bounding_box ().left ();
}


/**********************************************************************
 *  gblob_bounding_box()
 *
 *  Return the bounding box of a generic blob.
 **********************************************************************/

TBOX gblob_bounding_box(                 //Get bounding box
                       PBLOB *blob,     //generic blob
                       BOOL8 polygonal  //is blob polygonal?
                      ) {
  if (polygonal)
    return blob->bounding_box ();
  else
    return ((C_BLOB *) blob)->bounding_box ();
}


/**********************************************************************
 *  gblob_sort_list()
 *
 *  Sort a generic blob list into order of bounding box left edge
 **********************************************************************/

void gblob_sort_list(                        //Sort a gblob list
                     PBLOB_LIST *blob_list,  //generic blob list
                     BOOL8 polygonal         //is list polygonal?
                    ) {
  PBLOB_IT b_it;
  C_BLOB_IT c_it;

  if (polygonal) {
    b_it.set_to_list (blob_list);
    b_it.sort (blob_comparator);
  }
  else {
    c_it.set_to_list ((C_BLOB_LIST *) blob_list);
    c_it.sort (c_blob_comparator);
  }
}


/**********************************************************************
 *  gblob_out_list()
 *
 *  Return the generic outline list of a generic blob.
 **********************************************************************/

OUTLINE_LIST *gblob_out_list(                 //Get outline list
                             PBLOB *blob,     //generic blob
                             BOOL8 polygonal  //is blob polygonal?
                            ) {
  if (polygonal)
    return blob->out_list ();
  else
    return (OUTLINE_LIST *) ((C_BLOB *) blob)->out_list ();
}


/**********************************************************************
 *  goutline_bounding_box()
 *
 *  Return the bounding box of a generic outline.
 **********************************************************************/

TBOX goutline_bounding_box(                   //Get bounding box
                          OUTLINE *outline,  //generic outline
                          BOOL8 polygonal    //is outline polygonal?
                         ) {
  if (polygonal)
    return outline->bounding_box ();
  else
    return ((C_OUTLINE *) outline)->bounding_box ();
}
/////////////////////////////////////////////////////////////////genblob////////////////////////////////////////

/////////////////////////////////////////////////////////////////pgedit////////////////////////////////////////
#ifndef GRAPHICS_DISABLED
#define ASC_HEIGHT     (2 * bln_baseline_offset + bln_x_height)
#define X_HEIGHT       (bln_baseline_offset + bln_x_height)
#define BL_HEIGHT     bln_baseline_offset
#define DESC_HEIGHT     0
#define MAXSPACING      128      /*max expected spacing in pix */

const ERRCODE EMPTYBLOCKLIST = "No blocks to edit";
extern IMAGE page_image;

enum CMD_EVENTS
{
  NULL_CMD_EVENT,
  DELETE_CMD_EVENT,
  COPY_CMD_EVENT,
  CHANGE_DISP_CMD_EVENT,
  CHANGE_TEXT_CMD_EVENT,
  TOGGLE_SEG_CMD_EVENT,
  DUMP_WERD_CMD_EVENT,
  SHOW_POINT_CMD_EVENT,
  ROW_SPACE_STAT_CMD_EVENT,
  BLOCK_SPACE_STAT_CMD_EVENT,
  SHOW_BLN_WERD_CMD_EVENT,
  SEGMENT_WERD_CMD_EVENT,
  BOUNDING_BOX_CMD_EVENT,
  CORRECT_TEXT_CMD_EVENT,
  POLYGONAL_CMD_EVENT,
  BL_NORM_CMD_EVENT,
  BITMAP_CMD_EVENT,
  TIDY_CMD_EVENT,
  VIEW_CMD_EVENT,
  IMAGE_CMD_EVENT,
  BLOCKS_CMD_EVENT,
  BASELINES_CMD_EVENT,
  WRITE_CMD_EVENT,
  NEW_SOURCE_CMD_EVENT,
  UNIFORM_DISP_CMD_EVENT,
  REFRESH_CMD_EVENT,
  QUIT_CMD_EVENT,
  RECOG_WERDS,
  RECOG_PSEUDO
};

/*
 *
 *  Some global data
 *
 */

ScrollView* image_win;
VariablesEditor* ve;
bool stillRunning = false;

#ifdef __UNIX__
FILE *debug_window = NULL;       // opened on demand
#endif
                                 // baseline norm words
ScrollView* bln_word_window = NULL;

CMD_EVENTS mode = CHANGE_DISP_CMD_EVENT;
                                 // Selected words op

BITS16 word_display_mode;
BOOL8 display_image1 = FALSE;
BOOL8 display_blocks = FALSE;
BOOL8 display_baselines = FALSE;
BOOL8 viewing_source = TRUE;

BLOCK_LIST *source_block_list = NULL;    // image blocks
BLOCK_LIST target_block_list;    // target blocks
BLOCK_LIST *other_block_list = &target_block_list;

BOOL8 source_changed = FALSE;    // Changes not saved
BOOL8 target_changed = FALSE;    // Changes not saved
BOOL8 *other_image_changed = &target_changed;


/* Public globals */

#define EXTERN

EXTERN BLOCK_LIST *current_block_list = NULL;
EXTERN BOOL8 *current_image_changed = &source_changed;

/* Variables */

EXTERN STRING_VAR(editor_image_win_name, "EditorImage",
"Editor image window name");
EXTERN INT_VAR(editor_image_xpos, 590, "Editor image X Pos");
EXTERN INT_VAR(editor_image_ypos, 10, "Editor image Y Pos");
EXTERN INT_VAR(editor_image_menuheight, 50, "Add to image height for menu bar");
EXTERN INT_VAR(editor_image_word_bb_color, ScrollView::BLUE,
"Word bounding box colour");
EXTERN INT_VAR(editor_image_blob_bb_color, ScrollView::YELLOW,
"Blob bounding box colour");
EXTERN INT_VAR(editor_image_text_color, ScrollView::WHITE,
"Correct text colour");

EXTERN STRING_VAR(editor_dbwin_name, "EditorDBWin",
"Editor debug window name");
EXTERN INT_VAR(editor_dbwin_xpos, 50, "Editor debug window X Pos");
EXTERN INT_VAR(editor_dbwin_ypos, 500, "Editor debug window Y Pos");
EXTERN INT_VAR(editor_dbwin_height, 24, "Editor debug window height");
EXTERN INT_VAR(editor_dbwin_width, 80, "Editor debug window width");

EXTERN STRING_VAR(editor_word_name, "BlnWords", "BL normalised word window");
EXTERN INT_VAR(editor_word_xpos, 60, "Word window X Pos");
EXTERN INT_VAR(editor_word_ypos, 510, "Word window Y Pos");
EXTERN INT_VAR(editor_word_height, 240, "Word window height");
EXTERN INT_VAR(editor_word_width, 655, "Word window width");

EXTERN double_VAR(editor_smd_scale_factor, 1.0, "Scaling for smd image");

/**
 *  add_word()
 *
 *  Inserts the a word into a specified block list. The list is searched for a
 *  block and row of the same file as those of the word to be added, which
 *  contain the bounding box of the word.  If such a row is found, the new
 *  word is inserted into the row in the correct X order.  If the
 *  block is found, but not the row, a copy of the word's old row is added to
 *  the block in the correct Y order, and the word is put in that row.
 *  If neither the row nor the block are found, then the word's old block is
 *  copied with only the word's row. It is added to the block list in the
 *  correct Y order.
 */

void add_word(                            // to block list
              WERD *word,                  //< word to be added
              ROW *src_row,                //< source row
              BLOCK *src_block,            //< source block
              BLOCK_LIST *dest_block_list  //< add to this
             ) {
  BLOCK_IT block_it(dest_block_list);
  BLOCK *block;                  // current block
  BLOCK *dest_block = NULL;      // destination block
  ROW_IT row_it;
  ROW *row;                      // destination row
  ROW *dest_row = NULL;          // destination row
  WERD_IT word_it;
  TBOX word_box = word->bounding_box();
  TBOX insert_point_word_box;
  BOOL8 seen_blocks_for_current_file = FALSE;

  block_it.mark_cycle_pt();
  while(!block_it.cycled_list() &&(dest_block == NULL)) {
    block = block_it.data();
    if ((block->bounding_box().contains(word_box)) &&
   (strcmp(block->name(), src_block->name()) == 0)) {
      dest_block = block;        // found dest block
      row_it.set_to_list(block->row_list());
      row_it.mark_cycle_pt();
      while((!row_it.cycled_list()) &&(dest_row == NULL)) {
        row = row_it.data();
        if (row->bounding_box().contains(word_box))
          dest_row = row;        // found dest row
        else
          row_it.forward();
      }
    }
    else
      block_it.forward();
  }

  if (dest_block == NULL) {      // make a new one
    dest_block = new BLOCK;
    *dest_block = *src_block;

    block_it.set_to_list(dest_block_list);
    for (block_it.mark_cycle_pt();
    !block_it.cycled_list(); block_it.forward()) {
      block = block_it.data();

      if (!seen_blocks_for_current_file &&
       (strcmp(block->name(), dest_block->name()) == 0))
        seen_blocks_for_current_file = TRUE;

      if (seen_blocks_for_current_file &&
       ((strcmp(block->name(), dest_block->name()) != 0) ||
       (block->bounding_box().top() <
        dest_block->bounding_box().top())))
        break;
    }

    if (block_it.cycled_list())
                                 // didn't find insrt pt
      block_it.add_to_end(dest_block);
    else
                                 // did find insert pt
      block_it.add_before_stay_put(dest_block);
  }

  if (dest_row == NULL) {        // make a new one
    dest_row = new ROW;
    *dest_row = *src_row;

    row_it.set_to_list(dest_block->row_list());
    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
      if (row_it.data()->bounding_box().top() <
        dest_row->bounding_box().top())
        break;
    }

    if (row_it.cycled_list())
                                 // didn't find insrt pt
        row_it.add_to_end(dest_row);
    else
                                 // did find insert pt
      row_it.add_before_stay_put(dest_row);
  }

  /* dest_block and dest_row are now found or built and inserted as necessesary
    so add the word to dest row */

  word_it.set_to_list(dest_row->word_list());
  for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
    if (word_it.data()->bounding_box().right() >= word_box.left())
      break;
  }

  if (word_it.cycled_list())
    word_it.add_to_end(word);   // didn't find insrt pt
  else {                         // did find insert pt
    insert_point_word_box = word_it.data()->bounding_box();
    if (insert_point_word_box.contains(word_box) ||
      word_box.contains(insert_point_word_box))
      image_win->AddMessage("Refusing to add words which obliterate,"
                               " or are obliterated by, others");
    else {
      if (word_it.data()->bounding_box().left() >
        word->bounding_box().left())
                                 // infront of insert pt
        word_it.add_before_stay_put(word);
      else
                                 // behind insert pt
        word_it.add_after_stay_put(word);
    }
  }
}


class BlnEventHandler : public SVEventHandler {
 public:
  void Notify(const SVEvent* sv_event) {
    if (sv_event->type == SVET_DESTROY)
      bln_word_window = NULL;
    else if (sv_event->type == SVET_CLICK)
      show_point(current_block_list, sv_event->x, sv_event->y);
  }
};

/**
 *  bln_word_window_handle()
 *
 *  @return a WINDOW for the word window, creating it if necessary
 */
ScrollView* bln_word_window_handle() {  // return handle
                                 // not opened yet
  if (bln_word_window == NULL) {
    pgeditor_msg("Creating BLN word window...");
    bln_word_window = new ScrollView(editor_word_name.string(),
      editor_word_xpos, editor_word_ypos, editor_word_width,
      editor_word_height, 4000, 4000, true);
    BlnEventHandler* a = new BlnEventHandler();
    bln_word_window->AddEventHandler(a);
    pgeditor_msg("Creating BLN word window...Done");
  }
  return bln_word_window;
}

/**
 *  build_image_window()
 *
 *  Destroy the existing image window if there is one.  Work out how big the
 *  new window needs to be. Create it and re-display.
 */

void build_image_window(TBOX page_bounding_box) {
  if (image_win != NULL) { delete image_win; }
  image_win = new ScrollView(editor_image_win_name.string(),
                             editor_image_xpos, editor_image_ypos,
                             page_bounding_box.right() + 1,
                             page_bounding_box.top() +
                               editor_image_menuheight + 1,
                             page_bounding_box.right() + 1,
                             page_bounding_box.top() + 1,
                             true);
}


/**
 *  build_menu()
 *
 *  Construct the menu tree used by the command window
 */
SVMenuNode *Tesseract::build_menu_new() {

  SVMenuNode* parent_menu;
  SVMenuNode* root_menu_item = new SVMenuNode();

  SVMenuNode* modes_menu_item = root_menu_item->AddChild("MODES");

  modes_menu_item->AddChild("Change Display",
      CHANGE_DISP_CMD_EVENT);
  modes_menu_item->AddChild("Delete",
      DELETE_CMD_EVENT);
  modes_menu_item->AddChild("Copy to TARGET",
      COPY_CMD_EVENT);
  modes_menu_item->AddChild("Change Text",
      CHANGE_TEXT_CMD_EVENT);
  modes_menu_item->AddChild("Toggle Correct Seg Flg",
      TOGGLE_SEG_CMD_EVENT);
  modes_menu_item->AddChild("Dump Word",
      DUMP_WERD_CMD_EVENT);
  modes_menu_item->AddChild("Show Point",
      SHOW_POINT_CMD_EVENT);
  modes_menu_item->AddChild("Row gaps hist",
      ROW_SPACE_STAT_CMD_EVENT);
  modes_menu_item->AddChild("Block gaps hist",
      BLOCK_SPACE_STAT_CMD_EVENT);
  modes_menu_item->AddChild("Show BL Norm Word",
      SHOW_BLN_WERD_CMD_EVENT);
  modes_menu_item->AddChild("Re-Segment Word",
      SEGMENT_WERD_CMD_EVENT);
  modes_menu_item->AddChild("Recog Words",
      RECOG_WERDS);
  modes_menu_item->AddChild("Recog Blobs",
      RECOG_PSEUDO);

  parent_menu = root_menu_item->AddChild("DISPLAY");

  parent_menu->AddChild("Bounding Boxes",
      BOUNDING_BOX_CMD_EVENT, FALSE);
  parent_menu->AddChild("Correct Text",
      CORRECT_TEXT_CMD_EVENT, FALSE);
  parent_menu->AddChild("Polygonal Approx",
      POLYGONAL_CMD_EVENT, FALSE);
  parent_menu->AddChild("Baseline Normalised",
      BL_NORM_CMD_EVENT, FALSE);
  parent_menu->AddChild("Edge Steps",
      BITMAP_CMD_EVENT, TRUE);

  parent_menu = root_menu_item->AddChild("OTHER");

  parent_menu->AddChild("Quit",
      QUIT_CMD_EVENT);
  parent_menu->AddChild("Tidy Target",
      TIDY_CMD_EVENT);

  parent_menu->AddChild("View TARGET",
      VIEW_CMD_EVENT, FALSE);
  parent_menu->AddChild("Show Image",
      IMAGE_CMD_EVENT, FALSE);
  parent_menu->AddChild("ShowBlock Outlines",
      BLOCKS_CMD_EVENT, FALSE);
  parent_menu->AddChild("Show Baselines",
      BASELINES_CMD_EVENT, FALSE);
  parent_menu->AddChild("Write File",
      WRITE_CMD_EVENT,    imagebasename.string());
  parent_menu->AddChild("New Source File",
      NEW_SOURCE_CMD_EVENT,    imagebasename.string());
  parent_menu->AddChild("Uniform Display",
      UNIFORM_DISP_CMD_EVENT);
  parent_menu->AddChild("Refresh Display",
      REFRESH_CMD_EVENT);

  return root_menu_item;
}

/**
 *  display_bln_lines()
 *
 *  Display normalised baseline, x-height, ascender limit and descender limit
 */

void display_bln_lines(ScrollView* window,
                       ScrollView::Color colour,
                       float scale_factor,
                       float y_offset,
                       float minx,
                       float maxx) {
  window->Pen(colour);
  window->Line(minx, y_offset + scale_factor * DESC_HEIGHT,
               maxx, y_offset + scale_factor * DESC_HEIGHT);
  window->Line(minx, y_offset + scale_factor * BL_HEIGHT,
               maxx, y_offset + scale_factor * BL_HEIGHT);
  window->Line(minx, y_offset + scale_factor * X_HEIGHT,
               maxx, y_offset + scale_factor * X_HEIGHT);
  window->Line(minx, y_offset + scale_factor * ASC_HEIGHT,
               maxx, y_offset + scale_factor * ASC_HEIGHT);
}


/**
 *  do_new_source()
 *
 *  Change to another source file.  Automatically tidy page first
 *
 */
void Tesseract::do_new_source() {
  FILE *infp;                    // input file

  char* name = image_win->ShowInputDialog("New Source File name");

  STRING name_str(name);
  delete[] name;

  if (source_changed) {

    int a = image_win->ShowYesNoDialog(
        "Source changes will be LOST.  Continue?(Y/N)");
    if (a != 'y') { image_win->AddMessage("Write cancelled"); return; }

  }

                                 // if not file exists
  if (!(infp = fopen(name_str.string(), "r"))) {

     image_win->AddMessage("Cant open file " "%s" "", name_str.string());
    return;
  }

  fclose(infp);

  image_win->AddMessage("Reading file " "%s" "...", name_str.string());
  source_block_list->clear();
                                 // appends to SOURCE
  pgeditor_read_file(name_str, source_block_list);
  source_changed = FALSE;

  image_win->AddMessage("Doing automatic Tidy Target...");
  viewing_source = FALSE;        // Force viewing source
  do_tidy_cmd();

  image_win->AddMessage("Doing automatic Tidy Target...Done");

}


/**
 *  do_re_display()
 *
 *  Redisplay page
 */

void
                                 // function to call
do_re_display(BOOL8 word_painter(
BLOCK *, ROW *, WERD *)) {
  BLOCK_IT block_it(current_block_list);
  BLOCK *block;
  int block_count = 1;

  ROW_IT row_it;
  ROW *row;

  WERD_IT word_it;
  WERD *word;

  image_win->Clear();
  if (display_image1 != 0) {
    sv_show_sub_image(&page_image, 0, 0,
      page_image.get_xsize(), page_image.get_ysize(),
      image_win, 0, 0);
  }

  for (block_it.mark_cycle_pt();
  !block_it.cycled_list(); block_it.forward()) {
    block = block_it.data();
    row_it.set_to_list(block->row_list());
    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
      row = row_it.data();
      word_it.set_to_list(row->word_list());
      for (word_it.mark_cycle_pt();
      !word_it.cycled_list(); word_it.forward()) {
        word = word_it.data();
        word_painter(block, row, word);
      }
      if (display_baselines)
        row->plot_baseline(image_win, ScrollView::GREEN);
    }
    if (display_blocks)
      block->plot(image_win, block_count++, ScrollView::RED);
  }
  image_win->Update();
}


/**
 *  do_tidy_cmd()
 *
 *  Tidy TARGET page
 */

const TBOX do_tidy_cmd() {  // tidy
  ICOORD shift_vector;
  TBOX tidy_box;                  // Just the tidy area
  TBOX source_box;                // source file area

  source_box = block_list_bounding_box(source_block_list);
  // find src area

  if (!target_block_list.empty()) {
    tidy_box = block_list_compress(&target_block_list);

    /* Shift tidied target above the source image area. */

    shift_vector = ICOORD(0, source_box.top() + BLOCK_SPACING)
      - tidy_box.botleft();
    block_list_move(&target_block_list, shift_vector);
    tidy_box.move(shift_vector);
  }
  source_box += tidy_box;
                                 // big enough for both
  build_image_window(source_box);
  do_view_cmd();
  return tidy_box;
}


/**
 *  do_view_cmd()
 *
 *  View TARGET/View SOURCE command
 */

void do_view_cmd() {
  viewing_source = !viewing_source;
  image_win->Clear();
  if (viewing_source) {
    current_block_list = source_block_list;
    current_image_changed = &source_changed;
    other_block_list = &target_block_list;
    other_image_changed = &target_changed;
    do_re_display(&word_display);
  }
  else {
    current_block_list = &target_block_list;
    current_image_changed = &target_changed;
    other_block_list = source_block_list;
    other_image_changed = &source_changed;
    do_re_display(&word_display);
  }
}


/**
 *  do_write_file()
 *
 *  Serialise a block list to file
 *
 *  If writing image, tidy page and move to(0,0) first
 */

void do_write_file(           // serialise
                  ) {

  char* name = image_win->ShowInputDialog("File Name");

  FILE *infp;                    // input file
  char msg_str[80];

  TBOX enclosing_box;

                                 // if file exists
  if ((infp = fopen(name, "r")) != NULL) {
    fclose(infp);
    sprintf(msg_str, "Overwrite file " "%s" "?(Y/N)", name);

    int a = image_win->ShowYesNoDialog(msg_str);
    if (a != 'y') { image_win->AddMessage("Write cancelled"); delete[] name; return; }
  }

  infp = fopen(name, "w");      // can we write to it?
  if (infp == NULL) {

  image_win->AddMessage("Cant write to file " "%s" "", name);
    delete[] name;
    return;
  }
  fclose(infp);

  delete [] name;

  if (!viewing_source && !target_block_list.empty()) {
                                 // Tidy & move to(0,0)
    image_win->AddMessage("Automatic tidy...");
    viewing_source = TRUE;       // Stay viewing target!
    enclosing_box = do_tidy_cmd();
    block_list_move(&target_block_list, -enclosing_box.botleft());
    image_win->AddMessage("Writing file...");
    pgeditor_write_file(name, &target_block_list);
                                 // move back
    block_list_move(&target_block_list,
      enclosing_box.botleft());
  }
  else {
    image_win->AddMessage("Writing file...");
    pgeditor_write_file(name, current_block_list);
  }
  image_win->AddMessage("Writing file...Done");
  *current_image_changed = FALSE;

}

/**
 *  notify()
 *
 *  Event handler that processes incoming events, either forwarding
 *  them to process_cmd_win_event or process_image_event.
 *
 */

void PGEventHandler::Notify(const SVEvent* event) {
  char myval = '0';
  if (event->type == SVET_POPUP) {
ve->Notify(event);
  } // These are handled by Var. Editor
  else if (event->type == SVET_EXIT) { stillRunning = false; }
  else if (event->type == SVET_MENU) {
     if (strcmp(event->parameter, "true") == 0) { myval = 'T'; }
     else if (strcmp(event->parameter, "false") == 0) { myval = 'F'; }
     tess_->process_cmd_win_event(event->command_id, &myval);
  }
  else {
     tess_->process_image_event(*event);
     // else    pgeditor_show_point(*event);
  }
  current_word_quit.set_value(FALSE);
  selection_quit.set_value(FALSE);
                                 // replot all var wins
}


/**
 *  pgeditor_main()
 *
 *  Top level editor operation:
 *  Setup a new window and an according event handler
 *
 */
void Tesseract::pgeditor_main(BLOCK_LIST *blocks) {

  source_block_list = blocks;
  current_block_list = blocks;
  if (current_block_list->empty())
    return;

  stillRunning = true;

  build_image_window(block_list_bounding_box(source_block_list));
  word_display_mode.turn_on_bit(DF_EDGE_STEP);
  do_re_display(&word_set_display);
#ifndef GRAPHICS_DISABLED
  ve = new VariablesEditor(this, image_win);
#endif
  PGEventHandler pgEventHandler(this);

  image_win->AddEventHandler(&pgEventHandler);
  image_win->AddMessageBox();

  SVMenuNode* svMenuRoot = build_menu_new();

  svMenuRoot->BuildMenu(image_win);
  image_win->SetVisible(true);

  image_win->AwaitEvent(SVET_DESTROY);
  image_win->AddEventHandler(NULL);
}

/**
 * pgeditor_msg()
 *
 * Display a message - in the command window if there is one, or to stdout
 */

void pgeditor_msg( // message display
                  const char *msg) {
    image_win->AddMessage(msg);
}


/**
 * pgeditor_read_file()
 *
 * Deserialise source file
 */
void Tesseract::pgeditor_read_file(                   // of serialised file
                                   STRING &filename,
                                   BLOCK_LIST *blocks  // block list to add to
                                  ) {
  STRING name = filename;        //truncated name
  const char *lastdot;           //of name
  TO_BLOCK_LIST *land_blocks = NULL, *port_blocks = NULL; //TO_BLOCK_LIST land_blocks, port_blocks cwj
  TBOX page_box;

  lastdot = strrchr (name.string (), '.');
  if (lastdot != NULL)
    name[lastdot-name.string()] = '\0';
  if (!read_unlv_file(name, page_image.get_xsize(), page_image.get_ysize(), blocks))
    FullPageBlock(page_image.get_xsize(), page_image.get_ysize(), blocks);
  find_components(blocks, land_blocks, port_blocks, &page_box);
  textord_page(page_box.topright(), blocks, land_blocks, port_blocks, this);
}

/**
 * pgeditor_show_point()
 *
 * Display the coordinates of a point in the command window
 */

void pgeditor_show_point( // display coords
                         SVEvent *event) {
  image_win->AddMessage("Pointing at(%d, %d)", event->x, event->y);
}


/**
 *  pgeditor_write_file()
 *
 *  Serialise a block list to file
 *
 */

void pgeditor_write_file(                   // serialise
                         char *name,         // file name
                         BLOCK_LIST *blocks  // block list to write
                        ) {
  FILE *infp;                    // input file
  BLOCK_IT block_it(blocks);  // block iterator
  BLOCK *block;                  // current block
  ROW_IT row_it;                 // row iterator

  infp = fopen(name, "w");      // create output file
  if (infp == NULL)
    CANTCREATEFILE.error("pgeditor_write_file", EXIT, name);

  for (block_it.mark_cycle_pt();
  !block_it.cycled_list(); block_it.forward()) {
    block = block_it.extract();

    row_it.set_to_list(block->row_list());
    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward())
                                 // ensure correct
      row_it.data()->recalc_bounding_box();

    block->serialise(infp);     // serialize     non-empty
    block_it.add_after_then_move(block);
  }
  fclose(infp);
}


/**
 *  process_cmd_win_event()
 *
 *  Process a command returned from the command window
 * (Just call the appropriate command handler)
 */
BOOL8 Tesseract::process_cmd_win_event(                 // UI command semantics
                                       inT32 cmd_event,  // which menu item?
                                       char *new_value   // any prompt data
                                      ) {
  char msg[160];
  BOOL8 exit = FALSE;

  switch(cmd_event) {
    case NULL_CMD_EVENT:
      break;

    case VIEW_CMD_EVENT:
      do_view_cmd();
      break;
    case CHANGE_DISP_CMD_EVENT:
    case DELETE_CMD_EVENT:
    case CHANGE_TEXT_CMD_EVENT:
    case TOGGLE_SEG_CMD_EVENT:
    case DUMP_WERD_CMD_EVENT:
    case SHOW_POINT_CMD_EVENT:
    case ROW_SPACE_STAT_CMD_EVENT:
    case BLOCK_SPACE_STAT_CMD_EVENT:
    case SHOW_BLN_WERD_CMD_EVENT:
    case SEGMENT_WERD_CMD_EVENT:
      mode =(CMD_EVENTS) cmd_event;
      break;
    case COPY_CMD_EVENT:
      mode =(CMD_EVENTS) cmd_event;
      if (!viewing_source)
        image_win->AddMessage("Can't COPY while viewing target!");
      break;
    case BOUNDING_BOX_CMD_EVENT:
      if (new_value[0] == 'T')
        word_display_mode.turn_on_bit(DF_BOX);
      else
        word_display_mode.turn_off_bit(DF_BOX);
      mode = CHANGE_DISP_CMD_EVENT;
      break;
    case CORRECT_TEXT_CMD_EVENT:
      if (new_value[0] == 'T')
        word_display_mode.turn_on_bit(DF_TEXT);
      else
        word_display_mode.turn_off_bit(DF_TEXT);
      mode = CHANGE_DISP_CMD_EVENT;
      break;
    case POLYGONAL_CMD_EVENT:
      if (new_value[0] == 'T')
        word_display_mode.turn_on_bit(DF_POLYGONAL);
      else
        word_display_mode.turn_off_bit(DF_POLYGONAL);
      mode = CHANGE_DISP_CMD_EVENT;
      break;
    case BL_NORM_CMD_EVENT:
      if (new_value[0] == 'T')
        word_display_mode.turn_on_bit(DF_BN_POLYGONAL);
      else
        word_display_mode.turn_off_bit(DF_BN_POLYGONAL);
      mode = CHANGE_DISP_CMD_EVENT;
      break;
    case BITMAP_CMD_EVENT:
      if (new_value[0] == 'T')
        word_display_mode.turn_on_bit(DF_EDGE_STEP);
      else
        word_display_mode.turn_off_bit(DF_EDGE_STEP);
      mode = CHANGE_DISP_CMD_EVENT;
      break;
    case UNIFORM_DISP_CMD_EVENT:
      do_re_display(&word_set_display);
      *current_image_changed = TRUE;
      break;
    case WRITE_CMD_EVENT:
      do_write_file();
      break;
    case TIDY_CMD_EVENT:
      if (!target_block_list.empty()) {
        viewing_source = TRUE;   // Force viewing target
        do_tidy_cmd();
      }
      break;
    case NEW_SOURCE_CMD_EVENT:
      do_new_source();
      break;
    case IMAGE_CMD_EVENT:
      display_image1 =(new_value[0] == 'T');
      do_re_display(&word_display);
      break;
    case BLOCKS_CMD_EVENT:
      display_blocks =(new_value[0] == 'T');
      do_re_display(&word_display);
      break;
    case BASELINES_CMD_EVENT:
      display_baselines =(new_value[0] == 'T');
      do_re_display(&word_display);
      break;
    case REFRESH_CMD_EVENT:
      do_re_display(&word_display);
      break;
    case QUIT_CMD_EVENT:
      if (source_changed || target_changed) {
        int a = image_win->ShowYesNoDialog(
            "Changes not saved. Exit anyway?(Y/N)");
    if (a == 'y') { exit = TRUE; ScrollView::Exit(); }
      }
      else {
        exit = TRUE;
    ScrollView::Exit();
    }
      break;
    case RECOG_WERDS:
      mode = RECOG_WERDS;
    break;
    case RECOG_PSEUDO:
      mode = RECOG_PSEUDO;
    break;

    default:
      sprintf(msg, "Unrecognised event " INT32FORMAT "(%s)",
               cmd_event, new_value);
      image_win->AddMessage(msg);
    break;
  }
  return exit;
}


/**
 * process_image_event()
 *
 * User has done something in the image window - mouse down or up.  Work out
 * what it is and do something with it.
 * If DOWN - just remember where it was.
 * If UP - for each word in the selected area do the operation defined by
 * the current mode.
 */
void Tesseract::process_image_event( // action in image win
                                    const SVEvent &event) {
  static ICOORD down;
  ICOORD up;
  TBOX selection_box;
  char msg[80];

  switch(event.type) {

    case SVET_SELECTION:
      if (event.type == SVET_SELECTION) {
    down.set_x(event.x - event.x_size);
        down.set_y(event.y + event.y_size);
        if (mode == SHOW_POINT_CMD_EVENT)
          show_point(current_block_list, event.x, event.y);
      }

      up.set_x(event.x);
      up.set_y(event.y);

      selection_box = TBOX(down, up);

      switch(mode) {
        case CHANGE_DISP_CMD_EVENT:
          ::process_selected_words(current_block_list,
                                 selection_box,
                                 &word_blank_and_set_display);
          break;
        case COPY_CMD_EVENT:
          if (!viewing_source)
            image_win->AddMessage("Can't COPY while viewing target!");
          else
            ::process_selected_words(current_block_list,
                                   selection_box,
                                   &word_copy);
          break;
        case DELETE_CMD_EVENT:
          ::process_selected_words_it(current_block_list,
                                    selection_box,
                                    &word_delete);
          break;
        case CHANGE_TEXT_CMD_EVENT:
          ::process_selected_words(current_block_list,
                                 selection_box,
                                 &word_change_text);
          break;
        case TOGGLE_SEG_CMD_EVENT:
          ::process_selected_words(current_block_list,
                                   selection_box,
                                   &word_toggle_seg);
          break;
        case DUMP_WERD_CMD_EVENT:
          ::process_selected_words(current_block_list,
                                   selection_box,
                                   &word_dumper);
          break;
        case SHOW_BLN_WERD_CMD_EVENT:
          ::process_selected_words(current_block_list,
                                   selection_box,
                                   &word_bln_display);
          break;
        case SEGMENT_WERD_CMD_EVENT:
          re_segment_word(current_block_list, selection_box);
          break;
        case ROW_SPACE_STAT_CMD_EVENT:
          row_space_stat(current_block_list, selection_box);
          break;
        case BLOCK_SPACE_STAT_CMD_EVENT:
          block_space_stat(current_block_list, selection_box);
          break;
        case SHOW_POINT_CMD_EVENT:
          break;                 // ignore up event

        case RECOG_WERDS:
          image_win->AddMessage("Recogging selected words");
          this->process_selected_words(current_block_list,
                                       selection_box,
                                       &Tesseract::recog_interactive);
          break;
        case RECOG_PSEUDO:
          image_win->AddMessage("Recogging selected blobs");
          recog_pseudo_word(current_block_list, selection_box);
          break;

        default:
          sprintf(msg, "Mode %d not yet implemented", mode);
          image_win->AddMessage(msg);
          break;
      }
    default:
      break;
  }
}

/**
 * re_scale_and_move_bln_word()
 *
 * Scale and move a bln word so that it fits in a specified bounding box.
 * Scale by width or height to generate the largest image
 */

float re_scale_and_move_bln_word(                 // put bln word in       box
                                 WERD *norm_word,  //< BL normalised word
                                 const TBOX &box   //< destination box
                                ) {
  TBOX norm_box = norm_word->bounding_box();
  float width_scale_factor;
  float height_scale_factor;
  float selected_scale_factor;

  width_scale_factor = box.width() /(float) norm_box.width();
  height_scale_factor = box.height() /(float) ASC_HEIGHT;

  if ((ASC_HEIGHT * width_scale_factor) <= box.height())
    selected_scale_factor = width_scale_factor;
  else
    selected_scale_factor = height_scale_factor;

  norm_word->scale(selected_scale_factor);
  norm_word->move(ICOORD((box.left() + box.width() / 2), box.bottom()));
  return selected_scale_factor;
}


/**
 * re_segment_word()
 *
 * If all selected blobs are in the same row, remove them from their current
 * word(s) and put them in a new word.  Insert the new word in the row at the
 * appropriate point. Delete any empty words.
 *
 */

void re_segment_word(                        // break/join words
                     BLOCK_LIST *block_list,  // blocks to check
                     TBOX &selection_box) {
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  BLOCK *block_to_process = NULL;
  ROW_IT row_it;
  ROW *row;
  ROW *row_to_process = NULL;
  WERD_IT word_it;
  WERD *word;
  WERD *new_word = NULL;
  BOOL8 polyg = false;
  PBLOB_IT blob_it;
  PBLOB_LIST dummy;  // Just to initialize new_blob_it.
  PBLOB_IT new_blob_it = &dummy;
  PBLOB *blob;

  /* Find row to process - error if selections from more than one row */

  for (block_it.mark_cycle_pt();
  !block_it.cycled_list(); block_it.forward()) {
    block = block_it.data();
    if (block->bounding_box().overlap(selection_box)) {
      row_it.set_to_list(block->row_list());
      for (row_it.mark_cycle_pt();
      !row_it.cycled_list(); row_it.forward()) {
        row = row_it.data();
        if (row->bounding_box().overlap(selection_box)) {
          if (row_to_process == NULL) {
            block_to_process = block;
            row_to_process = row;
          }
          else {
            image_win->AddMessage("Cant resegment words "
                                     "in more than one row");
            return;
          }
        }
      }
    }
  }
  /* Continue with row_to_process */

  word_it.set_to_list(row_to_process->word_list());
  for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
    word = word_it.data();
    polyg = word->flag(W_POLYGON);
    if (word->bounding_box().overlap(selection_box)) {
      blob_it.set_to_list(word->gblob_list());
      for (blob_it.mark_cycle_pt();
      !blob_it.cycled_list(); blob_it.forward()) {
        blob = blob_it.data();
        if (gblob_bounding_box(blob, polyg).overlap(selection_box)) {
          if (new_word == NULL) {
            new_word = word->shallow_copy();
            new_blob_it.set_to_list(new_word->gblob_list());
          }
          new_blob_it.add_to_end(blob_it.extract());
          // move blob
        }
      }
      if (blob_it.empty()) {    // no blobs in word
                                 // so delete word
        delete word_it.extract();
      }
    }
  }
  if (new_word != NULL) {
    gblob_sort_list(new_word->gblob_list(), polyg);
    word_it.add_to_end(new_word);
    word_it.sort(word_comparator);
    row_to_process->bounding_box().plot(image_win,
      ScrollView::BLACK, ScrollView::BLACK);
    word_it.set_to_list(row_to_process->word_list());
    for (word_it.mark_cycle_pt();
      !word_it.cycled_list(); word_it.forward())
    word_display(block_to_process, row_to_process, word_it.data());
    *current_image_changed = TRUE;
  }
}

/// show space stats
void block_space_stat(BLOCK_LIST *block_list,  // blocks to check
                      TBOX &selection_box) {
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ROW_IT row_it;
  ROW *row;
  int block_idx = 0;
  STATS all_gap_stats(0, MAXSPACING);
  WERD_IT word_it;
  WERD *word;
  PBLOB_IT blob_it;
  PBLOB *blob;
  C_BLOB_IT cblob_it;
  C_BLOB *cblob;
  TBOX box;
  inT16 prev_box_right;
  inT16 gap_width;
  inT16 min_inter_word_gap;
  inT16 max_inter_char_gap;

  /* Find blocks to process */

  for (block_it.mark_cycle_pt();
  !block_it.cycled_list(); block_it.forward()) {
    block_idx++;
    block = block_it.data();
    if (block->bounding_box().overlap(selection_box)) {
      /* Process a block */
      tprintf("\nBlock %d\n", block_idx);
      min_inter_word_gap = 3000;
      max_inter_char_gap = 0;
      all_gap_stats.clear();
      row_it.set_to_list(block->row_list());
      for (row_it.mark_cycle_pt();
      !row_it.cycled_list(); row_it.forward()) {
        row = row_it.data();
        prev_box_right = -1;
        word_it.set_to_list(row->word_list());
        for (word_it.mark_cycle_pt();
        !word_it.cycled_list(); word_it.forward()) {
          word = word_it.data();
          if (word->flag(W_POLYGON)) {
            blob_it.set_to_list(word->blob_list());
            for (blob_it.mark_cycle_pt();
            !blob_it.cycled_list(); blob_it.forward()) {
              blob = blob_it.data();
              box = blob->bounding_box();
              if (prev_box_right > -1) {
                gap_width = box.left() - prev_box_right;
                all_gap_stats.add(gap_width, 1);
                if (blob_it.at_first()) {
                  if (gap_width < min_inter_word_gap)
                    min_inter_word_gap = gap_width;
                }
                else {
                  if (gap_width > max_inter_char_gap)
                    max_inter_char_gap = gap_width;
                }
              }
              prev_box_right = box.right();
            }
          }
          else {
            cblob_it.set_to_list(word->cblob_list());
            for (cblob_it.mark_cycle_pt();
            !cblob_it.cycled_list(); cblob_it.forward()) {
              cblob = cblob_it.data();
              box = cblob->bounding_box();
              if (prev_box_right > -1) {
                gap_width = box.left() - prev_box_right;
                all_gap_stats.add(gap_width, 1);
                if (cblob_it.at_first()) {
                  if (gap_width < min_inter_word_gap)
                    min_inter_word_gap = gap_width;
                }
                else {
                  if (gap_width > max_inter_char_gap)
                    max_inter_char_gap = gap_width;
                }
              }
              prev_box_right = box.right();
            }
          }
        }
      }
      tprintf("Max inter char gap = %d.\nMin inter word gap = %d.\n",
        max_inter_char_gap, min_inter_word_gap);
      all_gap_stats.short_print(NULL, TRUE);
      all_gap_stats.smooth(2);
      tprintf("SMOOTHED DATA...\n");
      all_gap_stats.short_print(NULL, TRUE);
    }
  }
}

/// show space stats
void row_space_stat(BLOCK_LIST *block_list,  // blocks to check
                    TBOX &selection_box) {
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ROW_IT row_it;
  ROW *row;
  int block_idx = 0;
  int row_idx;
  STATS all_gap_stats(0, MAXSPACING);
  WERD_IT word_it;
  WERD *word;
  PBLOB_IT blob_it;
  PBLOB *blob;
  C_BLOB_IT cblob_it;
  C_BLOB *cblob;
  TBOX box;
  inT16 prev_box_right;
  inT16 gap_width;
  inT16 min_inter_word_gap;
  inT16 max_inter_char_gap;

  /* Find rows to process */

  for (block_it.mark_cycle_pt();
  !block_it.cycled_list(); block_it.forward()) {
    block_idx++;
    block = block_it.data();
    if (block->bounding_box().overlap(selection_box)) {
      row_it.set_to_list(block->row_list());
      row_idx = 0;
      for (row_it.mark_cycle_pt();
      !row_it.cycled_list(); row_it.forward()) {
        row_idx++;
        row = row_it.data();
        if (row->bounding_box().overlap(selection_box)) {
          /* Process a row */

          tprintf("\nBlock %d Row %d\n", block_idx, row_idx);
          min_inter_word_gap = 3000;
          max_inter_char_gap = 0;
          prev_box_right = -1;
          all_gap_stats.clear();
          word_it.set_to_list(row->word_list());
          for (word_it.mark_cycle_pt();
          !word_it.cycled_list(); word_it.forward()) {
            word = word_it.data();
            if (word->flag(W_POLYGON)) {
              blob_it.set_to_list(word->blob_list());
              for (blob_it.mark_cycle_pt();
              !blob_it.cycled_list(); blob_it.forward()) {
                blob = blob_it.data();
                box = blob->bounding_box();
                if (prev_box_right > -1) {
                  gap_width = box.left() - prev_box_right;
                  all_gap_stats.add(gap_width, 1);
                  if (blob_it.at_first()) {
                    if (gap_width < min_inter_word_gap)
                      min_inter_word_gap = gap_width;
                  }
                  else {
                    if (gap_width > max_inter_char_gap)
                      max_inter_char_gap = gap_width;
                  }
                }
                prev_box_right = box.right();
              }
            }
            else {
              cblob_it.set_to_list(word->cblob_list());
              for (cblob_it.mark_cycle_pt();
              !cblob_it.cycled_list(); cblob_it.forward()) {
                cblob = cblob_it.data();
                box = cblob->bounding_box();
                if (prev_box_right > -1) {
                  gap_width = box.left() - prev_box_right;
                  all_gap_stats.add(gap_width, 1);
                  if (cblob_it.at_first()) {
                    if (gap_width < min_inter_word_gap)
                      min_inter_word_gap = gap_width;
                  }
                  else {
                    if (gap_width > max_inter_char_gap)
                      max_inter_char_gap = gap_width;
                  }
                }
                prev_box_right = box.right();
              }
            }
          }
          tprintf
           ("Max inter char gap = %d.\nMin inter word gap = %d.\n",
            max_inter_char_gap, min_inter_word_gap);
          all_gap_stats.short_print(NULL, TRUE);
          all_gap_stats.smooth(2);
          tprintf("SMOOTHED DATA...\n");
          all_gap_stats.short_print(NULL, TRUE);
        }
      }
    }
  }
}


/**
 * show_point()
 *
 * Show coords of point, blob bounding box, word bounding box and offset from
 * row baseline
 */

void show_point(                        // display posn of bloba word
                BLOCK_LIST *block_list,  // blocks to check
                float x,
                float y) {
  FCOORD pt(x, y);
  TBOX box;
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ROW_IT row_it;
  ROW *row;
  WERD_IT word_it;
  WERD *word;
  PBLOB_IT blob_it;
  PBLOB *blob;
  C_BLOB_IT cblob_it;
  C_BLOB *cblob;

  char msg[160];
  char *msg_ptr = msg;

  msg_ptr += sprintf(msg_ptr, "Pt:(%0.3f, %0.3f) ", x, y);

  for (block_it.mark_cycle_pt();
  !block_it.cycled_list(); block_it.forward()) {
    block = block_it.data();
    if (block->bounding_box().contains(pt)) {
      row_it.set_to_list(block->row_list());
      for (row_it.mark_cycle_pt();
      !row_it.cycled_list(); row_it.forward()) {
        row = row_it.data();
        if (row->bounding_box().contains(pt)) {
          msg_ptr += sprintf(msg_ptr, "BL(x)=%0.3f ",
            row->base_line(x));

          word_it.set_to_list(row->word_list());
          for (word_it.mark_cycle_pt();
          !word_it.cycled_list(); word_it.forward()) {
            word = word_it.data();
            box = word->bounding_box();
            if (box.contains(pt)) {
              msg_ptr += sprintf(msg_ptr,
                "Wd(%d, %d)/(%d, %d) ",
                box.left(), box.bottom(),
                box.right(), box.top());

              if (word->flag(W_POLYGON)) {
                blob_it.set_to_list(word->blob_list());
                for (blob_it.mark_cycle_pt();
                  !blob_it.cycled_list();
                blob_it.forward()) {
                  blob = blob_it.data();
                  box = blob->bounding_box();
                  if (box.contains(pt)) {
                    msg_ptr += sprintf(msg_ptr,
                      "Blb(%d, %d)/(%d, %d) ",
                      box.left(),
                      box.bottom(),
                      box.right(),
                      box.top());
                  }
                }
              }
              else {
                cblob_it.set_to_list(word->cblob_list());
                for (cblob_it.mark_cycle_pt();
                  !cblob_it.cycled_list();
                cblob_it.forward()) {
                  cblob = cblob_it.data();
                  box = cblob->bounding_box();
                  if (box.contains(pt)) {
                    msg_ptr += sprintf(msg_ptr,
                      "CBlb(%d, %d)/(%d, %d) ",
                      box.left(),
                      box.bottom(),
                      box.right(),
                      box.top());
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  image_win->AddMessage(msg);
}


/**********************************************************************
 * WERD PROCESSOR FUNCTIONS
 * ========================
 *
 * These routines are invoked by one or more of:
 *    process_all_words()
 *    process_selected_words()
 * or
 *    process_all_words_it()
 *    process_selected_words_it()
 * for each word to be processed
 **********************************************************************/

/**
 * word_blank_and_set_display()  Word processor
 *
 * Blank display of word then redisplay word according to current display mode
 * settings
 */

BOOL8 word_blank_and_set_display(              // display a word
                                 BLOCK *block,  // block holding word
                                 ROW *row,      // row holding word
                                 WERD *word     // word to be processed
                                ) {
  word->bounding_box().plot(image_win, ScrollView::BLACK, ScrollView::BLACK);
  return word_set_display(block, row, word);
}


/**
 * word_bln_display()
 *
 * Normalise word and display in word window
 */

BOOL8 word_bln_display(           // bln & display
                       BLOCK *,    // block holding word
                       ROW *row,   // row holding word
                       WERD *word  // word to be processed
                      ) {
  WERD *bln_word;

  bln_word = word->poly_copy(row->x_height());
  bln_word->baseline_normalise(row);
  bln_word_window_handle()->Clear();
  display_bln_lines(bln_word_window_handle(), ScrollView::CYAN,
                     1.0, 0.0f, -1000.0f, 1000.0f);
  bln_word->plot(bln_word_window_handle(), ScrollView::RED);
  delete bln_word;
  return TRUE;
}


/**
 * word_change_text()
 *
 * Change the correct text of a word
 */

BOOL8 word_change_text(              // change correct text
                       BLOCK *block,  // block holding word
                       ROW *row,      // row holding word
                       WERD *word     // word to be processed
                      ) {
  char* cp = image_win->ShowInputDialog(
      "Enter/edit the correct text and press <<RETURN>>");
  word->set_text(cp);
  delete[] cp;

  if (word_display_mode.bit(DF_TEXT) || word->display_flag(DF_TEXT)) {
    word_blank_and_set_display(block, row, word);
    ScrollView::Update();
  }

  *current_image_changed = TRUE;
  return TRUE;
}


/**
 * word_copy()
 *
 * Copy a word to other display list
 */

BOOL8 word_copy(              // copy a word
                BLOCK *block,  // block holding word
                ROW *row,      // row holding word
                WERD *word     // word to be processed
               ) {
  WERD *copy_word = new WERD;

  *copy_word = *word;
  add_word(copy_word, row, block, other_block_list);
  *other_image_changed = TRUE;
  return TRUE;
}


/**
 * word_delete()
 *
 * Delete a word
 */

BOOL8 word_delete(                    // delete a word
                  BLOCK *block,        // block holding word
                  ROW *row,            // row holding word
                  WERD *word,          // word to be processed
                  BLOCK_IT &block_it,  // block list iterator
                  ROW_IT &row_it,      // row list iterator
                  WERD_IT &word_it     // word list iterator
                 ) {
  word_it.extract();
  word->bounding_box().plot(image_win, ScrollView::BLACK, ScrollView::BLACK);
  delete(word);

  if (word_it.empty()) {        // no words left in row
                                 // so delete row
    row_it.extract();
    row->bounding_box().plot(image_win, ScrollView::BLACK, ScrollView::BLACK);
    delete(row);

    if (row_it.empty()) {       // no rows left in blk
                                 // so delete block
      block_it.extract();
      block->bounding_box().plot(image_win, ScrollView::BLACK, ScrollView::BLACK);
      delete(block);
    }
  }
  *current_image_changed = TRUE;
  return TRUE;
}


/**
 *  word_display()  Word Processor
 *
 *  Display a word according to its display modes
 */

BOOL8 word_display(           // display a word
                   BLOCK *,    // block holding word
                   ROW *row,   // row holding word
                   WERD *word  // word to be processed
                  ) {
  TBOX word_bb;                   // word bounding box
  int word_height;               // ht of word BB
  BOOL8 displayed_something = FALSE;
  BOOL8 displayed_rainbow = FALSE;
  float shift;                   // from bot left
  PBLOB_IT it;                   // blob iterator
  C_BLOB_IT c_it;                // cblob iterator
  WERD *word_ptr;                // poly copy
  WERD temp_word;
  float scale_factor;            // for BN_POLYGON

  /*
    Note the double coercions of(COLOUR)((inT32)editor_image_word_bb_color)
    etc. are to keep the compiler happy.
  */

                                 // display bounding box
  if (word->display_flag(DF_BOX)) {
    word->bounding_box().plot(image_win,
     (ScrollView::Color)((inT32)
      editor_image_word_bb_color),
     (ScrollView::Color)((inT32)
      editor_image_word_bb_color));

    ScrollView::Color c = (ScrollView::Color)
       ((inT32) editor_image_blob_bb_color);
    image_win->Pen(c);
    if (word->flag(W_POLYGON)) {
      it.set_to_list(word->blob_list());
      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
        it.data()->bounding_box().plot(image_win);
    }
    else {
      c_it.set_to_list(word->cblob_list());
      for (c_it.mark_cycle_pt(); !c_it.cycled_list(); c_it.forward())
        c_it.data()->bounding_box().plot(image_win);
    }
    displayed_something = TRUE;
  }

                                 // display edge steps
  if (word->display_flag(DF_EDGE_STEP) &&
  !word->flag(W_POLYGON)) {     // edgesteps available
    word->plot(image_win);      // rainbow colors
    displayed_something = TRUE;
    displayed_rainbow = TRUE;
  }

                                 // display poly approx
  if (word->display_flag(DF_POLYGONAL)) {
                                 // need to convert
    if (!word->flag(W_POLYGON)) {
      word_ptr = word->poly_copy(row->x_height());

      /* CALL POLYGONAL APPROXIMATOR WHEN AVAILABLE - on a temp_word */

      if (displayed_rainbow)
                                 // ensure its visible
        word_ptr->plot(image_win, ScrollView::WHITE);
      else
                                 // rainbow colors
          word_ptr->plot(image_win);
      delete word_ptr;
    }
    else {
      if (displayed_rainbow)
                                 // ensure its visible
        word->plot(image_win, ScrollView::WHITE);
      else
        word->plot(image_win);  // rainbow colors
    }

    displayed_rainbow = TRUE;
    displayed_something = TRUE;
  }

                                 // disp BN poly approx
  if (word->display_flag(DF_BN_POLYGONAL)) {
                                 // need to convert
    if (!word->flag(W_POLYGON)) {
      word_ptr = word->poly_copy(row->x_height());
      temp_word = *word_ptr;
      delete word_ptr;

      /* CALL POLYGONAL APPROXIMATOR WHEN AVAILABLE - on a temp_word */

    }
    else
      temp_word = *word;         // copy word
    word_bb = word->bounding_box();
    if (!temp_word.flag(W_NORMALIZED))
      temp_word.baseline_normalise(row);

    scale_factor = re_scale_and_move_bln_word(&temp_word, word_bb);
    display_bln_lines(image_win, ScrollView::CYAN, scale_factor,
      word_bb.bottom(), word_bb.left(), word_bb.right());

    if (displayed_rainbow)
                                 // ensure its visible
      temp_word.plot(image_win, ScrollView::WHITE);
    else
      temp_word.plot(image_win); // rainbow colors

    displayed_rainbow = TRUE;
    displayed_something = TRUE;
  }

  // display correct text
  if (word->display_flag(DF_TEXT)) {
    word_bb = word->bounding_box();
    ScrollView::Color c =(ScrollView::Color)
       ((inT32) editor_image_blob_bb_color);
    image_win->Pen(c);
    word_height = word_bb.height();
    image_win->TextAttributes("Times", 0.75 * word_height,
                              false, false, false);
    if (word_height < word_bb.width())
      shift = 0.25 * word_height;
    else
      shift = 0.0f;

    image_win->Text(word_bb.left() + shift,
                    word_bb.bottom() + 0.25 * word_height, word->text());

    if (strlen(word->text()) > 0)
      displayed_something = TRUE;
  }

  if (!displayed_something)      // display BBox anyway
    word->bounding_box().plot(image_win,
     (ScrollView::Color)((inT32) editor_image_word_bb_color),
     (ScrollView::Color)((inT32)
      editor_image_word_bb_color));
  return TRUE;
}


/**
 * word_dumper()
 *
 * Dump members to the debug window
 */

BOOL8 word_dumper(              // dump word
                  BLOCK *block,  //< block holding word
                  ROW *row,      //< row holding word
                  WERD *word     //< word to be processed
                 ) {

  if (block != NULL) {
    tprintf("\nBlock data...\n");
    block->print(NULL, FALSE);
  }
  tprintf("\nRow data...\n");
  row->print(NULL);
  tprintf("\nWord data...\n");
  word->print(NULL);
  return TRUE;
}


/**
 * word_set_display()  Word processor
 *
 * Display word according to current display mode settings
 */

BOOL8 word_set_display(              // display a word
                       BLOCK *block,  //< block holding word
                       ROW *row,      //< row holding word
                       WERD *word     //< word to be processed
                      ) {
  TBOX word_bb;                   // word bounding box

  word->set_display_flag(DF_BOX, word_display_mode.bit(DF_BOX));
  word->set_display_flag(DF_TEXT, word_display_mode.bit(DF_TEXT));
  word->set_display_flag(DF_POLYGONAL, word_display_mode.bit(DF_POLYGONAL));
  word->set_display_flag(DF_EDGE_STEP, word_display_mode.bit(DF_EDGE_STEP));
  word->set_display_flag(DF_BN_POLYGONAL,
    word_display_mode.bit(DF_BN_POLYGONAL));
  *current_image_changed = TRUE;
  return word_display(block, row, word);
}


/**
 * word_toggle_seg()
 *
 * Toggle the correct segmentation flag
 */

BOOL8 word_toggle_seg(           // toggle seg flag
                      BLOCK *,    //< block holding word
                      ROW *,      //< row holding word
                      WERD *word  //< word to be processed
                     ) {
  word->set_flag(W_SEGMENTED, !word->flag(W_SEGMENTED));
  *current_image_changed = TRUE;
  return TRUE;
}

#endif  // GRAPHICS_DISABLED

/* DEBUG ONLY */

void do_check_mem( // do it
                  inT32 level) {
  check_mem("Doing it", level);
}
/////////////////////////////////////////////////////////////////pgedit////////////////////////////////////////

/////////////////////////////////////////////////////////////////charcut////////////////////////////////////////
#define LARGEST(a,b) ( (a) > (b) ? (a) : (b) )
#define SMALLEST(a,b) ( (a) > (b) ? (b) : (a) )
#define BUG_OFFSET 1
#define EXTERN

EXTERN INT_VAR (pix_word_margin, 3, "How far outside word BB to grow");

ELISTIZE (PIXROW)
/*************************************************************************
 * PIXROW::PIXROW()
 *
 * Constructor for a specified size PIXROW from a blob
 *************************************************************************/
PIXROW::PIXROW(inT16 pos, inT16 count, PBLOB *blob) {
  OUTLINE_LIST *outline_list;
  OUTLINE_IT outline_it;
  POLYPT_LIST *pts_list;
  POLYPT_IT pts_it;
  inT16 i;
  FCOORD pt;
  FCOORD vec;
  float y_coord;
  inT16 x_coord;

  row_offset = pos;
  row_count = count;
  min = (inT16 *) alloc_mem (count * sizeof (inT16));
  max = (inT16 *) alloc_mem (count * sizeof (inT16));
  outline_list = blob->out_list ();
  outline_it.set_to_list (outline_list);

  for (i = 0; i < count; i++) {
    min[i] = MAX_INT16 - 1;
    max[i] = -MAX_INT16 + 1;
    y_coord = row_offset + i + 0.5;
    for (outline_it.mark_cycle_pt ();
    !outline_it.cycled_list (); outline_it.forward ()) {
      pts_list = outline_it.data ()->polypts ();
      pts_it.set_to_list (pts_list);
      for (pts_it.mark_cycle_pt ();
      !pts_it.cycled_list (); pts_it.forward ()) {
        pt = pts_it.data ()->pos;
        vec = pts_it.data ()->vec;
        if ((vec.y () != 0) &&
          (((pt.y () <= y_coord) && (pt.y () + vec.y () >= y_coord))
          || ((pt.y () >= y_coord)
        && (pt.y () + vec.y () <= y_coord)))) {
          /* The segment crosses y_coord so find x-point and check for min/max. */
          x_coord = (inT16) floor ((y_coord -
            pt.y ()) * vec.x () / vec.y () +
            pt.x () + 0.5);
          if (x_coord < min[i])
            min[i] = x_coord;
          x_coord--;             //to get pix to left of line
          if (x_coord > max[i])
            max[i] = x_coord;
        }
      }
    }
  }
}


/*************************************************************************
 * PIXROW::plot()
 *
 * Draw the PIXROW
 *************************************************************************/

#ifndef GRAPHICS_DISABLED
void PIXROW::plot(ScrollView* fd  //where to paint
                 ) const {
  inT16 i;
  inT16 y_coord;

  for (i = 0; i < row_count; i++) {
    y_coord = row_offset + i;
    if (min[i] <= max[i]) {
      fd->Rectangle(min[i], y_coord, max[i] + 1, y_coord + 1);
    }
  }
}
#endif

/*************************************************************************
 * PIXROW::bounding_box()
 *
 * Generate bounding box for blob image
 *************************************************************************/

bool PIXROW::bad_box(  //return true if box exceeds image
                     int xsize,
                     int ysize) const {
  TBOX bbox = bounding_box ();
  if (bbox.left () < 0 || bbox.right () > xsize
  || bbox.top () > ysize || bbox.bottom () < 0) {
    tprintf("Box (%d,%d)->(%d,%d) bad compared to %d,%d\n",
            bbox.left(),bbox.bottom(), bbox.right(), bbox.top(),
            xsize, ysize);
    return true;
  }
  return false;
}


/*************************************************************************
 * PIXROW::bounding_box()
 *
 * Generate bounding box for blob image
 *************************************************************************/

TBOX PIXROW::bounding_box() const {
  inT16 i;
  inT16 y_coord;
  inT16 min_x = MAX_INT16 - 1;
  inT16 min_y = MAX_INT16 - 1;
  inT16 max_x = -MAX_INT16 + 1;
  inT16 max_y = -MAX_INT16 + 1;

  for (i = 0; i < row_count; i++) {
    y_coord = row_offset + i;
    if (min[i] <= max[i]) {
      if (y_coord < min_y)
        min_y = y_coord;
      if (y_coord + 1 > max_y)
        max_y = y_coord + 1;
      if (min[i] < min_x)
        min_x = min[i];
      if (max[i] + 1 > max_x)
        max_x = max[i] + 1;
    }
  }
  if (min_x > max_x || min_y > max_y)
    return TBOX ();
  else
    return TBOX (ICOORD (min_x, min_y), ICOORD (max_x, max_y));
}


/*************************************************************************
 * PIXROW::contract()
 *
 * Reduce the mins and maxs so that they end on black pixels
 *************************************************************************/

void PIXROW::contract(                         //image array
                      IMAGELINE *imlines,
                      inT16 x_offset,          //of pixels[0]
                      inT16 foreground_colour  //0 or 1
                     ) {
  inT16 i;
  uinT8 *line_pixels;

  for (i = 0; i < row_count; i++) {
    if (min[i] > max[i])
      continue;

    line_pixels = imlines[i].pixels;
    while (line_pixels[min[i] - x_offset] != foreground_colour) {
      if (min[i] == max[i]) {
        min[i] = MAX_INT16 - 1;
        max[i] = -MAX_INT16 + 1;
        goto nextline;
      }
      else
        min[i]++;
    }
    while (line_pixels[max[i] - x_offset] != foreground_colour) {
      if (min[i] == max[i]) {
        min[i] = MAX_INT16 - 1;
        max[i] = -MAX_INT16 + 1;
        goto nextline;
      }
      else
        max[i]--;
    }
    nextline:;
    //goto label!
  }
}


/*************************************************************************
 * PIXROW::extend()
 *
 * 1 pixel extension in each direction to cover extra black area
 *************************************************************************/

BOOL8 PIXROW::extend(               //image array
                     IMAGELINE *imlines,
                     TBOX &imbox,
                     PIXROW *prev,  //for prev blob
                     PIXROW *next,  //for next blob
                     inT16 foreground_colour) {
  inT16 i;
  inT16 x_offset = imbox.left ();
  inT16 limit;
  inT16 left_limit;
  inT16 right_limit;
  uinT8 *pixels = NULL;
  uinT8 *pixels_below = NULL;    //row below current
  uinT8 *pixels_above = NULL;    //row above current
  BOOL8 changed = FALSE;

  pixels_above = imlines[0].pixels;
  for (i = 0; i < row_count; i++) {
    pixels_below = pixels;
    pixels = pixels_above;
    if (i < (row_count - 1))
      pixels_above = imlines[i + 1].pixels;
    else
      pixels_above = NULL;

    /* Extend Left by one pixel*/
    if (prev == NULL || prev->max[i] < prev->min[i])
      limit = imbox.left ();
    else
      limit = prev->max[i] + 1;
    if ((min[i] <= max[i]) &&
      (min[i] > limit) &&
    (pixels[min[i] - 1 - x_offset] == foreground_colour)) {
      min[i]--;
      changed = TRUE;
    }

    /* Extend Right by one pixel*/
    if (next == NULL || next->min[i] > next->max[i])
      limit = imbox.right () - 1;//-1 to index inside pix
    else
      limit = next->min[i] - 1;
    if ((min[i] <= max[i]) &&
      (max[i] < limit) &&
    (pixels[max[i] + 1 - x_offset] == foreground_colour)) {
      max[i]++;
      changed = TRUE;
    }

    /* Extend down by one row */
    if (pixels_below != NULL) {
      if (min[i] < min[i - 1]) { //row goes left of row below
        if (prev == NULL || prev->max[i - 1] < prev->min[i - 1])
          left_limit = min[i];
        else
          left_limit = LARGEST (min[i], prev->max[i - 1] + 1);
      }
      else
        left_limit = min[i - 1];

      if (max[i] > max[i - 1]) { //row goes right of row below
        if (next == NULL || next->min[i - 1] > next->max[i - 1])
          right_limit = max[i];
        else
          right_limit = SMALLEST (max[i], next->min[i - 1] - 1);
      }
      else
        right_limit = max[i - 1];

      while ((left_limit <= right_limit) &&
        (pixels_below[left_limit - x_offset] != foreground_colour))
        left_limit++;            //find black extremity

      if ((left_limit <= right_limit) && (left_limit < min[i - 1])) {
        min[i - 1] = left_limit; //widen left if poss
        changed = TRUE;
      }

      while ((left_limit <= right_limit) &&
        (pixels_below[right_limit - x_offset] != foreground_colour))
        right_limit--;           //find black extremity

      if ((left_limit <= right_limit) && (right_limit > max[i - 1])) {
        max[i - 1] = right_limit;//widen right if poss
        changed = TRUE;
      }
    }

    /* Extend up by one row */
    if (pixels_above != NULL) {
      if (min[i] < min[i + 1]) { //row goes left of row above
        if (prev == NULL || prev->min[i + 1] > prev->max[i + 1])
          left_limit = min[i];
        else
          left_limit = LARGEST (min[i], prev->max[i + 1] + 1);
      }
      else
        left_limit = min[i + 1];

      if (max[i] > max[i + 1]) { //row goes right of row above
        if (next == NULL || next->min[i + 1] > next->max[i + 1])
          right_limit = max[i];
        else
          right_limit = SMALLEST (max[i], next->min[i + 1] - 1);
      }
      else
        right_limit = max[i + 1];

      while ((left_limit <= right_limit) &&
        (pixels_above[left_limit - x_offset] != foreground_colour))
        left_limit++;            //find black extremity

      if ((left_limit <= right_limit) && (left_limit < min[i + 1])) {
        min[i + 1] = left_limit; //widen left if poss
        changed = TRUE;
      }

      while ((left_limit <= right_limit) &&
        (pixels_above[right_limit - x_offset] != foreground_colour))
        right_limit--;           //find black extremity

      if ((left_limit <= right_limit) && (right_limit > max[i + 1])) {
        max[i + 1] = right_limit;//widen right if poss
        changed = TRUE;
      }
    }
  }
  return changed;
}


/*************************************************************************
 * PIXROW::char_clip_image()
 * Cut out a sub image for a character
 *************************************************************************/

void PIXROW::char_clip_image(                     //box of imlines extnt
                             IMAGELINE *imlines,
                             TBOX &im_box,
                             ROW *row,            //row containing word
                             IMAGE &clip_image,   //unscaled sq subimage
                             float &baseline_pos  //baseline ht in image
                            ) {
  inT16 clip_image_xsize;        //sub image x size
  inT16 clip_image_ysize;        //sub image y size
  inT16 x_shift;                 //from pixrow to subim
  inT16 y_shift;                 //from pixrow to subim
  TBOX char_pix_box;              //bbox of char pixels
  inT16 y_dest;
  inT16 x_min;
  inT16 x_max;
  inT16 x_min_dest;
  inT16 x_max_dest;
  inT16 x_width;
  inT16 y;

  clip_image_xsize = clip_image.get_xsize ();
  clip_image_ysize = clip_image.get_ysize ();

  char_pix_box = bounding_box ();
  /*
    The y shift is calculated by first finding the coord of the bottom of the
    image relative to the image lines. Then reducing this so by the amount
    relative to the clip image size, necessary to vertically position the
    character.
  */
  y_shift = char_pix_box.bottom () - row_offset -
    (inT16) floor ((clip_image_ysize - char_pix_box.height () + 0.5) / 2);

  /*
    The x_shift is the shift to be applied to the page coord in the pixrow to
    generate a centred char in the clip image.  Thus the left hand edge of the
    char is shifted to the margin width of the centred character.
  */
  x_shift = char_pix_box.left () -
    (inT16) floor ((clip_image_xsize - char_pix_box.width () + 0.5) / 2);

  for (y = 0; y < row_count; y++) {
    /*
      Check that there is something in this row of the source that will fit in the
      sub image.  If there is, reduce x range if necessary, then copy it
    */
    y_dest = y - y_shift;
    if ((min[y] <= max[y]) && (y_dest >= 0) && (y_dest < clip_image_ysize)) {
      x_min = min[y];
      x_min_dest = x_min - x_shift;
      if (x_min_dest < 0) {
        x_min = x_min - x_min_dest;
        x_min_dest = 0;
      }
      x_max = max[y];
      x_max_dest = x_max - x_shift;
      if (x_max_dest > clip_image_xsize - 1) {
        x_max = x_max - (x_max_dest - (clip_image_xsize - 1));
        x_max_dest = clip_image_xsize - 1;
      }
      x_width = x_max - x_min + 1;
      if (x_width > 0) {
        x_min -= im_box.left ();
                                 //offset pixel ptr
        imlines[y].pixels += x_min;
        clip_image.put_line (x_min_dest, y_dest, x_width, imlines + y,
          0);
        imlines[y].init ();      //reset pixel ptr
      }
    }
  }
  /*
    Baseline position relative to clip image: First find the baseline relative
    to the page origin at the x coord of the centre of the character. Then
    make this relative to the character bottom. Finally shift by the margin
    between the bottom of the character and the bottom of the clip image.
  */
  if (row == NULL)
    baseline_pos = 0;            //Not needed
  else
    baseline_pos = row->base_line ((char_pix_box.left () +
      char_pix_box.right ()) / 2.0)
      - char_pix_box.bottom ()
      + ((clip_image_ysize - char_pix_box.height ()) / 2);
}


/*************************************************************************
 * char_clip_word()
 *
 * Generate a PIXROW_LIST with one element for each blob in the word, together
 * with the image lines for the whole word.
 *************************************************************************/

void char_clip_word(                            //
                    WERD *word,                 //word to be processed
                    IMAGE &bin_image,           //whole image
                    PIXROW_LIST *&pixrow_list,  //pixrows built
                    IMAGELINE *&imlines,        //lines cut from image
                    TBOX &pix_box                //box defining imlines
                   ) {
  TBOX word_box = word->bounding_box ();
  PBLOB_LIST *blob_list;
  PBLOB_IT blob_it;
  PIXROW_IT pixrow_it;
  inT16 pix_offset;              //Y pos of pixrow[0]
  inT16 row_height;              //No of pix rows
  inT16 imlines_x_offset;
  PIXROW *prev;
  PIXROW *next;
  PIXROW *current;
  BOOL8 changed;                 //still improving
  BOOL8 just_changed;            //still improving
  inT16 iteration_count = 0;
  inT16 foreground_colour;

  if (word->flag (W_INVERSE))
    foreground_colour = 1;
  else
    foreground_colour = 0;

  /* Define region for max pixrow expansion */
  pix_box = word_box;
  pix_box.move_bottom_edge (-pix_word_margin);
  pix_box.move_top_edge (pix_word_margin);
  pix_box.move_left_edge (-pix_word_margin);
  pix_box.move_right_edge (pix_word_margin);
  pix_box -= TBOX (ICOORD (0, 0 + BUG_OFFSET),
    ICOORD (bin_image.get_xsize (),
    bin_image.get_ysize () - BUG_OFFSET));

  /* Generate pixrows list */

  pix_offset = pix_box.bottom ();
  row_height = pix_box.height ();
  blob_list = word->blob_list ();
  blob_it.set_to_list (blob_list);

  pixrow_list = new PIXROW_LIST;
  pixrow_it.set_to_list (pixrow_list);

  for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ()) {
    PIXROW *row = new PIXROW (pix_offset, row_height, blob_it.data ());
    ASSERT_HOST (!row->
      bad_box (bin_image.get_xsize (), bin_image.get_ysize ()));
    pixrow_it.add_after_then_move (row);
  }

  imlines = generate_imlines (bin_image, pix_box);

  /* Contract pixrows - shrink min and max back to black pixels */

  imlines_x_offset = pix_box.left ();

  pixrow_it.move_to_first ();
  for (pixrow_it.mark_cycle_pt ();
  !pixrow_it.cycled_list (); pixrow_it.forward ()) {
    ASSERT_HOST (!pixrow_it.data ()->
      bad_box (bin_image.get_xsize (), bin_image.get_ysize ()));
    pixrow_it.data ()->contract (imlines, imlines_x_offset,
      foreground_colour);
    ASSERT_HOST (!pixrow_it.data ()->
      bad_box (bin_image.get_xsize (), bin_image.get_ysize ()));
  }

  /* Expand pixrows iteratively 1 pixel at a time */
  do {
    changed = FALSE;
    pixrow_it.move_to_first ();
    prev = NULL;
    current = NULL;
    next = pixrow_it.data ();
    for (pixrow_it.mark_cycle_pt ();
    !pixrow_it.cycled_list (); pixrow_it.forward ()) {
      prev = current;
      current = next;
      if (pixrow_it.at_last ())
        next = NULL;
      else
        next = pixrow_it.data_relative (1);
      just_changed = current->extend (imlines, pix_box, prev, next,
        foreground_colour);
      ASSERT_HOST (!current->
        bad_box (bin_image.get_xsize (),
        bin_image.get_ysize ()));
      changed = changed || just_changed;
    }
    iteration_count++;
  }
  while (changed);
}


/*************************************************************************
 * generate_imlines()
 * Get an array of IMAGELINES  holding a portion of an image
 *************************************************************************/

IMAGELINE *generate_imlines(                   //get some imagelines
                            IMAGE &bin_image,  //from here
                            TBOX &pix_box) {
  IMAGELINE *imlines;            //array of lines
  int i;

  imlines = new IMAGELINE[pix_box.height ()];
  for (i = 0; i < pix_box.height (); i++) {
    imlines[i].init (pix_box.width ());
                                 //coord to start at
    bin_image.fast_get_line (pix_box.left (),
      pix_box.bottom () + i + BUG_OFFSET,
    //line to get
      pix_box.width (),          //width to get
      imlines + i);              //dest imline
  }
  return imlines;
}


/*************************************************************************
 * display_clip_image()
 * All the boring user interface bits to let you see what's going on
 *************************************************************************/
ScrollView* display_clip_image(WERD *word,                //word to be processed
                          IMAGE &bin_image,          //whole image
                          PIXROW_LIST *pixrow_list,  //pixrows built
                          TBOX &pix_box               //box of subimage
                         ) {
  ScrollView* clip_window;            //window for debug
  TBOX word_box = word->bounding_box ();
  int border = word_box.height () / 2;
  TBOX display_box = word_box;

  display_box.move_bottom_edge (-border);
  display_box.move_top_edge (border);
  display_box.move_left_edge (-border);
  display_box.move_right_edge (border);
  display_box -= TBOX (ICOORD (0, 0 - BUG_OFFSET),
    ICOORD (bin_image.get_xsize (),
    bin_image.get_ysize () - BUG_OFFSET));

  pgeditor_msg("Creating Clip window...");
  clip_window = new ScrollView("Clipped Blobs",
    editor_word_xpos, editor_word_ypos,
    3 * (word_box.width () + 2 * border),
    3 * (word_box.height () + 2 * border),
    display_box.left () + display_box.right (),
    display_box.bottom () - BUG_OFFSET +
    display_box.top () - BUG_OFFSET,
    true);
  // ymin, ymax
  pgeditor_msg ("Creating Clip window...Done");

  clip_window->Clear();
  sv_show_sub_image (&bin_image,
    display_box.left (),
    display_box.bottom (),
    display_box.width (),
    display_box.height (),
    clip_window,
    display_box.left (), display_box.bottom () - BUG_OFFSET);

  word->plot (clip_window, ScrollView::RED);
  word_box.plot (clip_window, ScrollView::BLUE, ScrollView::BLUE);
  pix_box.plot (clip_window, ScrollView::BLUE, ScrollView::BLUE);
  plot_pixrows(pixrow_list, clip_window);
  return clip_window;
}


/*************************************************************************
 * display_images()
 * Show a pair of clip and scaled character images and wait for key before
 * continuing.
 *************************************************************************/

void display_images(IMAGE &clip_image, IMAGE &scaled_image) {
  ScrollView* clip_im_window;         //window for debug
  ScrollView* scale_im_window;        //window for debug
  inT16 i;

                                 // xmin xmax ymin ymax
  clip_im_window = new ScrollView ("Clipped Blob", editor_word_xpos - 20,
      editor_word_ypos - 100, 5 * clip_image.get_xsize (),
      5 * clip_image.get_ysize (), clip_image.get_xsize (),
      clip_image.get_ysize (), true);

  sv_show_sub_image (&clip_image,
    0, 0,
    clip_image.get_xsize (), clip_image.get_ysize (),
    clip_im_window, 0, 0);

  clip_im_window->Pen(255,0,0);
  for (i = 1; i < clip_image.get_xsize (); i++) {
    clip_im_window->SetCursor(i,0);
    clip_im_window->DrawTo(i, clip_image.get_xsize ());
  }
  for (i = 1; i < clip_image.get_ysize (); i++) {
    clip_im_window->SetCursor(0,i);
    clip_im_window->DrawTo(clip_image.get_xsize (),i);

  }

                                 // xmin xmax ymin ymax
  scale_im_window = new ScrollView ("Scaled Blob", editor_word_xpos + 300,
      editor_word_ypos - 100, 5 * scaled_image.get_xsize (),
      5 * scaled_image.get_ysize (), scaled_image.get_xsize (),
      scaled_image.get_ysize (), true);

  sv_show_sub_image (&scaled_image,
    0, 0,
    scaled_image.get_xsize (), scaled_image.get_ysize (),
    scale_im_window, 0, 0);

  scale_im_window->Pen(255,0,0);
  for (i = 1; i < scaled_image.get_xsize (); i++) {
    scale_im_window->SetCursor(i,0);
    scale_im_window->DrawTo(i, scaled_image.get_xsize ());
  }
  for (i = 1; i < scaled_image.get_ysize (); i++) {
    scale_im_window->SetCursor(0,i);
    scale_im_window->DrawTo(scaled_image.get_xsize (),i);
  }

  ScrollView::Update();
}


/*************************************************************************
 * plot_pixrows()
 * Display a list of pixrows
 *************************************************************************/

void plot_pixrows(  //plot for all blobs
                  PIXROW_LIST *pixrow_list,
                  ScrollView* win) {
  PIXROW_IT pixrow_it(pixrow_list);
  inT16 colour = ScrollView::RED;

  for (pixrow_it.mark_cycle_pt ();
  !pixrow_it.cycled_list (); pixrow_it.forward ()) {
    if (colour > ScrollView::RED + 7)
      colour = ScrollView::RED;

   win->Pen((ScrollView::Color) colour);
    pixrow_it.data ()->plot (win);
    colour++;
  }
}
/////////////////////////////////////////////////////////////////charcut////////////////////////////////////////

/////////////////////////////////////////////////////////////////polyblk////////////////////////////////////////
#define PBLOCK_LABEL_SIZE 150
#define INTERSECTING MAX_INT16

int lessthan(const void *first, const void *second);

POLY_BLOCK::POLY_BLOCK(ICOORDELT_LIST *points, PolyBlockType t) {
  ICOORDELT_IT v = &vertices;

  vertices.clear();
  v.move_to_first();
  v.add_list_before(points);
  compute_bb();
  type = t;
}


/**
 * @name POLY_BLOCK::compute_bb
 *
 * Compute the bounding box from the outline points.
 */

void POLY_BLOCK::compute_bb() {  //constructor
  ICOORD ibl, itr;               //integer bb
  ICOORD botleft;                //bounding box
  ICOORD topright;
  ICOORD pos;                    //current pos;
  ICOORDELT_IT pts = &vertices;  //iterator

  botleft = *pts.data ();
  topright = botleft;
  do {
    pos = *pts.data ();
    if (pos.x () < botleft.x ())
                                 //get bounding box
      botleft = ICOORD (pos.x (), botleft.y ());
    if (pos.y () < botleft.y ())
      botleft = ICOORD (botleft.x (), pos.y ());
    if (pos.x () > topright.x ())
      topright = ICOORD (pos.x (), topright.y ());
    if (pos.y () > topright.y ())
      topright = ICOORD (topright.x (), pos.y ());
    pts.forward ();
  }
  while (!pts.at_first ());
  ibl = ICOORD (botleft.x (), botleft.y ());
  itr = ICOORD (topright.x (), topright.y ());
  box = TBOX (ibl, itr);
}


/**
 * @name POLY_BLOCK::winding_number
 *
 * Return the winding number of the outline around the given point.
 * @param point point to wind around
 */

inT16 POLY_BLOCK::winding_number(const ICOORD &point) {
  inT16 count;                   //winding count
  ICOORD pt;                     //current point
  ICOORD vec;                    //point to current point
  ICOORD vvec;                   //current point to next point
  inT32 cross;                   //cross product
  ICOORDELT_IT it = &vertices;   //iterator

  count = 0;
  do {
    pt = *it.data ();
    vec = pt - point;
    vvec = *it.data_relative (1) - pt;
                                 //crossing the line
    if (vec.y () <= 0 && vec.y () + vvec.y () > 0) {
      cross = vec * vvec;        //cross product
      if (cross > 0)
        count++;                 //crossing right half
      else if (cross == 0)
        return INTERSECTING;     //going through point
    }
    else if (vec.y () > 0 && vec.y () + vvec.y () <= 0) {
      cross = vec * vvec;
      if (cross < 0)
        count--;                 //crossing back
      else if (cross == 0)
        return INTERSECTING;     //illegal
    }
    else if (vec.y () == 0 && vec.x () == 0)
      return INTERSECTING;
    it.forward ();
  }
  while (!it.at_first ());
  return count;                  //winding number
}


/// @return true if other is inside this.
bool POLY_BLOCK::contains(POLY_BLOCK *other) {
  inT16 count;                   // winding count
  ICOORDELT_IT it = &vertices;   // iterator
  ICOORD vertex;

  if (!box.overlap (*(other->bounding_box ())))
    return false;                // can't be contained

  /* check that no vertex of this is inside other */

  do {
    vertex = *it.data ();
                                 // get winding number
    count = other->winding_number (vertex);
    if (count != INTERSECTING)
      if (count != 0)
        return false;
    it.forward ();
  }
  while (!it.at_first ());

  /* check that all vertices of other are inside this */

                                 //switch lists
  it.set_to_list (other->points ());
  do {
    vertex = *it.data ();
                                 //try other way round
    count = winding_number (vertex);
    if (count != INTERSECTING)
      if (count == 0)
        return false;
    it.forward ();
  }
  while (!it.at_first ());
  return true;
}


/**
 * @name POLY_BLOCK::rotate
 *
 * Rotate the POLY_BLOCK.
 * @param rotation cos, sin of angle
 */

void POLY_BLOCK::rotate(FCOORD rotation) {
  FCOORD pos;                    //current pos;
  ICOORDELT *pt;                 //current point
  ICOORDELT_IT pts = &vertices;  //iterator

  do {
    pt = pts.data ();
    pos.set_x (pt->x ());
    pos.set_y (pt->y ());
    pos.rotate (rotation);
    pt->set_x ((inT16) (floor (pos.x () + 0.5)));
    pt->set_y ((inT16) (floor (pos.y () + 0.5)));
    pts.forward ();
  }
  while (!pts.at_first ());
  compute_bb();
}


/**
 * POLY_BLOCK::move
 *
 * Move the POLY_BLOCK.
 * @param shift cos, sin of angle
 */

void POLY_BLOCK::move(ICOORD shift) {
  ICOORDELT *pt;                 //current point
  ICOORDELT_IT pts = &vertices;  //iterator

  do {
    pt = pts.data ();
    *pt += shift;
    pts.forward ();
  }
  while (!pts.at_first ());
  compute_bb();
}


#ifndef GRAPHICS_DISABLED
void POLY_BLOCK::plot(ScrollView* window, inT32 num) {
  ICOORDELT_IT v = &vertices;

  window->Pen(ColorForPolyBlockType(type));

  v.move_to_first ();

  if (num > 0) {
    window->TextAttributes("Times", 80, false, false, false);
    char temp_buff[34];
    #ifdef __UNIX__
    sprintf(temp_buff, INT32FORMAT, num);
    #else
    ltoa (num, temp_buff, 10);
    #endif
    window->Text(v.data ()->x (), v.data ()->y (), temp_buff);
  }

  window->SetCursor(v.data ()->x (), v.data ()->y ());
  for (v.mark_cycle_pt (); !v.cycled_list (); v.forward ()) {
    window->DrawTo(v.data ()->x (), v.data ()->y ());
   }
  v.move_to_first ();
   window->DrawTo(v.data ()->x (), v.data ()->y ());
}


void POLY_BLOCK::fill(ScrollView* window, ScrollView::Color colour) {
  inT16 y;
  inT16 width;
  PB_LINE_IT *lines;
  ICOORDELT_LIST *segments;
  ICOORDELT_IT s_it;

  lines = new PB_LINE_IT (this);
  window->Pen(colour);

  for (y = this->bounding_box ()->bottom ();
  y <= this->bounding_box ()->top (); y++) {
    segments = lines->get_line (y);
    if (!segments->empty ()) {
      s_it.set_to_list (segments);
      for (s_it.mark_cycle_pt (); !s_it.cycled_list (); s_it.forward ()) {
        // Note different use of ICOORDELT, x coord is x coord of pixel
        // at the start of line segment, y coord is length of line segment
        // Last pixel is start pixel + length.
        width = s_it.data ()->y ();
        window->SetCursor(s_it.data ()->x (), y);
        window->DrawTo(s_it.data ()->x () + (float) width, y);
      }
    }
  }
}
#endif


/// @return true if the polygons of other and this overlap.
bool POLY_BLOCK::overlap(POLY_BLOCK *other) {
  inT16 count;                   // winding count
  ICOORDELT_IT it = &vertices;   // iterator
  ICOORD vertex;

  if (!box.overlap(*(other->bounding_box())))
    return false;                // can't be any overlap.

  /* see if a vertex of this is inside other */

  do {
    vertex = *it.data ();
                                 // get winding number
    count = other->winding_number (vertex);
    if (count != INTERSECTING)
      if (count != 0)
        return true;
    it.forward ();
  }
  while (!it.at_first ());

  /* see if a vertex of other is inside this */

                                 // switch lists
  it.set_to_list (other->points ());
  do {
    vertex = *it.data();
                                 // try other way round
    count = winding_number (vertex);
    if (count != INTERSECTING)
      if (count != 0)
        return true;
    it.forward ();
  }
  while (!it.at_first ());
  return false;
}


ICOORDELT_LIST *PB_LINE_IT::get_line(inT16 y) {
  ICOORDELT_IT v, r;
  ICOORDELT_LIST *result;
  ICOORDELT *x, *current, *previous;
  float fy, fx;

  fy = (float) (y + 0.5);
  result = new ICOORDELT_LIST ();
  r.set_to_list (result);
  v.set_to_list (block->points ());

  for (v.mark_cycle_pt (); !v.cycled_list (); v.forward ()) {
    if (((v.data_relative (-1)->y () > y) && (v.data ()->y () <= y))
    || ((v.data_relative (-1)->y () <= y) && (v.data ()->y () > y))) {
      previous = v.data_relative (-1);
      current = v.data ();
      fx = (float) (0.5 + previous->x () +
        (current->x () - previous->x ()) * (fy -
        previous->y ()) /
        (current->y () - previous->y ()));
      x = new ICOORDELT ((inT16) fx, 0);
      r.add_to_end (x);
    }
  }

  if (!r.empty ()) {
    r.sort (lessthan);
    for (r.mark_cycle_pt (); !r.cycled_list (); r.forward ())
      x = r.data ();
    for (r.mark_cycle_pt (); !r.cycled_list (); r.forward ()) {
      r.data ()->set_y (r.data_relative (1)->x () - r.data ()->x ());
      r.forward ();
      delete (r.extract ());
    }
  }

  return result;
}


int lessthan(const void *first, const void *second) {
  ICOORDELT *p1 = (*(ICOORDELT **) first);
  ICOORDELT *p2 = (*(ICOORDELT **) second);

  if (p1->x () < p2->x ())
    return (-1);
  else if (p1->x () > p2->x ())
    return (1);
  else
    return (0);
}


/**
 * @name POLY_BLOCK::serialise_asc
 *
 * Convert to ascii file.
 * @param f file to use
 */

void POLY_BLOCK::serialise_asc(FILE *f) {
  vertices.serialise_asc (f);
  box.serialise_asc (f);
  serialise_INT32(f, type);
}


/**
 * @name POLY_BLOCK::de_serialise_asc
 *
 * Converto from ascii file.
 * @param f file to use
 */

void POLY_BLOCK::de_serialise_asc(FILE *f) {
  vertices.de_serialise_asc (f);
  box.de_serialise_asc (f);
  type = (PolyBlockType) de_serialise_INT32 (f);
}


/// Returns a color to draw the given type.
ScrollView::Color POLY_BLOCK::ColorForPolyBlockType(PolyBlockType type) {
  const ScrollView::Color kPBColors[PT_COUNT] = {
    ScrollView::WHITE,
    ScrollView::BLUE,
    ScrollView::CYAN,
    ScrollView::MEDIUM_BLUE,
    ScrollView::MAGENTA,
    ScrollView::YELLOW,
    ScrollView::RED,
    ScrollView::MAROON,
    ScrollView::ORANGE,
    ScrollView::GREEN,
    ScrollView::LIME_GREEN,
    ScrollView::DARK_GREEN,
    ScrollView::GREY
  };
  if (type >= 0 && type < PT_COUNT) {
    return kPBColors[type];
  }
  return ScrollView::WHITE;
}
/////////////////////////////////////////////////////////////////polyblk////////////////////////////////////////

/////////////////////////////////////////////////////////////////pdblock////////////////////////////////////////
#define BLOCK_LABEL_HEIGHT  150  //char height of block id

CLISTIZE (PDBLK)
/**********************************************************************
 * PDBLK::PDBLK
 *
 * Constructor for a simple rectangular block.
 **********************************************************************/
PDBLK::PDBLK (                   //rectangular block
inT16 xmin,                      //bottom left
inT16 ymin, inT16 xmax,          //top right
inT16 ymax):    box (ICOORD (xmin, ymin), ICOORD (xmax, ymax))
{
                                 //boundaries
  ICOORDELT_IT left_it = &leftside;
  ICOORDELT_IT right_it = &rightside;

  hand_poly = NULL;
  left_it.set_to_list (&leftside);
  right_it.set_to_list (&rightside);
                                 //make default box
  left_it.add_to_end (new ICOORDELT (xmin, ymin));
  left_it.add_to_end (new ICOORDELT (xmin, ymax));
  right_it.add_to_end (new ICOORDELT (xmax, ymin));
  right_it.add_to_end (new ICOORDELT (xmax, ymax));
  index_ = 0;
}


/**********************************************************************
 * PDBLK::set_sides
 *
 * Sets left and right vertex lists
 **********************************************************************/

void PDBLK::set_sides(                       //set vertex lists
                      ICOORDELT_LIST *left,  //left vertices
                      ICOORDELT_LIST *right  //right vertices
                     )
{
                                 //boundaries
  ICOORDELT_IT left_it = &leftside;
  ICOORDELT_IT right_it = &rightside;

  leftside.clear ();
  left_it.move_to_first ();
  left_it.add_list_before (left);
  rightside.clear ();
  right_it.move_to_first ();
  right_it.add_list_before (right);
}


/**********************************************************************
 * PDBLK::contains
 *
 * Return TRUE if the given point is within the block.
 **********************************************************************/

BOOL8 PDBLK::contains(           //test containment
                      ICOORD pt  //point to test
                     )
{
  BLOCK_RECT_IT it = this;       //rectangle iterator
  ICOORD bleft, tright;          //corners of rectangle

  for (it.start_block (); !it.cycled_rects (); it.forward ())
  {
    //get rectangle
    it.bounding_box (bleft, tright);

    //inside rect
    if (pt.x () >= bleft.x () && pt.x () <= tright.x () && pt.y () >= bleft.y () && pt.y () <= tright.y ())

      return TRUE;               //is inside
  }

  return FALSE;                  //not inside
}


/**********************************************************************
 * PDBLK::move
 *
 * Reposition block
 **********************************************************************/

void PDBLK::move(                  // reposition block
                 const ICOORD vec  // by vector
                )
{
  ICOORDELT_IT it(&leftside);

  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
  {
    *(it.data ()) += vec;
  }

  it.set_to_list (&rightside);

  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
  {
    *(it.data ()) += vec;
  }

  box.move (vec);
}


/**********************************************************************
 * PDBLK::plot
 *
 * Plot the outline of a block in the given colour.
 **********************************************************************/

#ifndef GRAPHICS_DISABLED
void PDBLK::plot(                //draw outline
                 ScrollView* window,  //window to draw in
                 inT32 serial,   //serial number
                 ScrollView::Color colour   //colour to draw in
                )
{
  ICOORD startpt;                //start of outline
  ICOORD endpt;                  //end of outline
  ICOORD prevpt;                 //previous point
  ICOORDELT_IT it = &leftside;   //iterator

                                 //set the colour
  window->Pen(colour);
  window->TextAttributes("Times", BLOCK_LABEL_HEIGHT, false, false, false);

  if (hand_poly != NULL)
  {
    hand_poly->plot(window, serial);
  }
  else if (!leftside.empty ())
  {
    startpt = *(it.data ());     //bottom left corner
    //              tprintf("Block %d bottom left is (%d,%d)\n",
    //                      serial,startpt.x(),startpt.y());
    char temp_buff[34];
    #ifdef __UNIX__
    sprintf(temp_buff, INT32FORMAT, serial);
    #else
    ultoa (serial, temp_buff, 10);
    #endif
    window->Text(startpt.x (), startpt.y (), temp_buff);

    window->SetCursor(startpt.x (), startpt.y ());
    do
    {
      prevpt = *(it.data ());    //previous point
      it.forward ();             //move to next point
                                 //draw round corner
    window->DrawTo(prevpt.x (), it.data ()->y ());
    window->DrawTo(it.data ()->x (), it.data ()->y ());
    }
    while (!it.at_last ());      //until end of list
    endpt = *(it.data ());       //end point

    //other side of boundary
    window->SetCursor(startpt.x (), startpt.y ());
    it.set_to_list (&rightside);
    prevpt = startpt;
    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
    {
                                 //draw round corner
    window->DrawTo(prevpt.x (), it.data ()->y ());
    window->DrawTo(it.data ()->x (), it.data ()->y ());
    prevpt = *(it.data ());    //previous point
    }
                                 //close boundary
    window->DrawTo(endpt.x(), endpt.y());
  }
}
#endif


/**********************************************************************
 * PDBLK::show
 *
 * Show the image corresponding to a block as its set of rectangles.
 **********************************************************************/

#ifndef GRAPHICS_DISABLED
void PDBLK::show(               //show image block
                 IMAGE *image,  //image to show
                 ScrollView* window  //window to show in
                )
{
  BLOCK_RECT_IT it = this;       //rectangle iterator
  ICOORD bleft, tright;          //corners of rectangle

  for (it.start_block (); !it.cycled_rects (); it.forward ())
  {
                                 //get rectangle
    it.bounding_box (bleft, tright);
    //              tprintf("Drawing a block with a bottom left of (%d,%d)\n",
    //                      bleft.x(),bleft.y());
                                 //show it
    sv_show_sub_image (image, bleft.x (), bleft.y (), tright.x () - bleft.x (), tright.y () - bleft.y (), window, bleft.x (), bleft.y ());
  }
}
#endif


/**********************************************************************
 * PDBLK::operator=
 *
 * Assignment - duplicate the block structure, but with an EMPTY row list.
 **********************************************************************/

PDBLK & PDBLK::operator= (       //assignment
const PDBLK & source             //from this
)
{
  //      this->ELIST_LINK::operator=(source);
  if (!leftside.empty ()) leftside.clear ();

  if (!rightside.empty ()) rightside.clear ();

  leftside.deep_copy(&source.leftside, &ICOORDELT::deep_copy);
  rightside.deep_copy(&source.rightside, &ICOORDELT::deep_copy);
  box = source.box;

  return *this;
}


/**********************************************************************
 * BLOCK_RECT_IT::BLOCK_RECT_IT
 *
 * Construct a block rectangle iterator.
 **********************************************************************/

//iterate rectangles         //from block
BLOCK_RECT_IT::BLOCK_RECT_IT(PDBLK * blkptr):left_it (&blkptr->leftside), right_it (&blkptr->rightside)
{
  block = blkptr;                //remember block
                                 //non empty list
  if (!blkptr->leftside.empty ())
  {
    start_block();  //ready for iteration
  }
}


/**********************************************************************
 * BLOCK_RECT_IT::set_to_block
 *
 * Start a new block.
 **********************************************************************/

//start (new) block
void BLOCK_RECT_IT::set_to_block(PDBLK *blkptr)
{
  //block to start
  block = blkptr;                //remember block

  //set iterators
  left_it.set_to_list (&blkptr->leftside);
  right_it.set_to_list (&blkptr->rightside);

  if (!blkptr->leftside.empty ()) start_block();  //ready for iteration
}


/**********************************************************************
 * BLOCK_RECT_IT::start_block
 *
 * Restart a block.
 **********************************************************************/

void BLOCK_RECT_IT::start_block()
{
  //start (new) block
  left_it.move_to_first ();
  right_it.move_to_first ();
  left_it.mark_cycle_pt ();
  right_it.mark_cycle_pt ();
  ymin = left_it.data ()->y ();  //bottom of first box
  ymax = left_it.data_relative (1)->y ();

  if (right_it.data_relative (1)->y () < ymax)
  {
    //smallest step
    ymax = right_it.data_relative (1)->y ();
  }
}


/**********************************************************************
 * BLOCK_RECT_IT::forward
 *
 * Move to the next rectangle in the block.
 **********************************************************************/

void BLOCK_RECT_IT::forward()
{  //next rectangle
  if (!left_it.empty())
  {       //non-empty list
    if (left_it.data_relative(1)->y() == ymax)
    {
      left_it.forward();        //move to meet top
    }

    if (right_it.data_relative(1)->y() == ymax)
    {
      right_it.forward();
    }
                                 //last is special
    if (left_it.at_last() || right_it.at_last())
    {
      left_it.move_to_first();  //restart
      right_it.move_to_first();
                                 //now at bottom
      ymin = left_it.data()->y();
    }
    else
    {
      ymin = ymax;               //new bottom
    }
                                 //next point
    ymax = left_it.data_relative(1)->y();

    if (right_it.data_relative(1)->y() < ymax)
    {
      //least step forward
      ymax = right_it.data_relative(1)->y();
    }
  }
}


/**********************************************************************
 * BLOCK_LINE_IT::get_line
 *
 * Get the the start and width of a line in the block.
 **********************************************************************/

inT16 BLOCK_LINE_IT::get_line(             //get a line
                              inT16 y,     //line to get
                              inT16 &xext  //output extent
                             )
{
  ICOORD bleft;                  //bounding box
  ICOORD tright;                 //of block & rect

  //get block box
  block->bounding_box(bleft, tright);
  if (y < bleft.y () || y >= tright.y ())
  {
    //block->print(stderr,FALSE);
    BADBLOCKLINE.error ("BLOCK_LINE_IT::get_line", ABORT, "Y=%d", y);
  }

  //get rectangle box
  rect_it.bounding_box(bleft, tright);

  //inside rectangle
  if (y >= bleft.y () && y < tright.y ())
  {
    //width of line
    xext = tright.x () - bleft.x ();
    return bleft.x ();           //start of line
  }

  for (rect_it.start_block (); !rect_it.cycled_rects (); rect_it.forward ())
  {
    //get rectangle box
    rect_it.bounding_box (bleft, tright);

    //inside rectangle
    if (y >= bleft.y () && y < tright.y ())
    {
      //width of line
      xext = tright.x () - bleft.x ();
      return bleft.x ();         //start of line
    }
  }

  LOSTBLOCKLINE.error ("BLOCK_LINE_IT::get_line", ABORT, "Y=%d", y);

  return 0;                      //dummy to stop warning
}
/////////////////////////////////////////////////////////////////pdblock////////////////////////////////////////

/////////////////////////////////////////////////////////////////ocrblock////////////////////////////////////////
#define BLOCK_LABEL_HEIGHT  150  //char height of block id

ELISTIZE_S (BLOCK)
/**
 * BLOCK::BLOCK
 *
 * Constructor for a simple rectangular block.
 */
BLOCK::BLOCK(const char *name,                //< filename
             BOOL8 prop,                      //< proportional
             inT16 kern,                      //< kerning
             inT16 space,                     //< spacing
             inT16 xmin,                      //< bottom left
             inT16 ymin,
             inT16 xmax,          //< top right
             inT16 ymax)
    : PDBLK (xmin, ymin, xmax, ymax), filename(name), re_rotation_(1.0f, 0.0f), classify_rotation_(1.0f, 0.0f), skew_(1.0f, 0.0f)
{
    ICOORDELT_IT left_it = &leftside;
    ICOORDELT_IT right_it = &rightside;

    proportional = prop;
    kerning = kern;
    spacing = space;
    font_class = -1;               //not assigned
    cell_over_xheight_ = 2.0f;
    hand_poly = NULL;
    left_it.set_to_list (&leftside);
    right_it.set_to_list (&rightside);

    //make default box
    left_it.add_to_end(new ICOORDELT (xmin, ymin));
    left_it.add_to_end(new ICOORDELT (xmin, ymax));
    right_it.add_to_end(new ICOORDELT (xmax, ymin));
    right_it.add_to_end(new ICOORDELT (xmax, ymax));
}

/**
 * decreasing_top_order
 *
 * Sort Comparator: Return <0 if row1 top < row2 top
 */

int decreasing_top_order(const void *row1, const void *row2)
{
    return (*(ROW **) row2)->bounding_box ().top () - (*(ROW **) row1)->bounding_box ().top ();
}


/**
 * BLOCK::rotate
 *
 * Rotate the polygon by the given rotation and recompute the bounding_box.
 */
void BLOCK::rotate(const FCOORD& rotation)
{
    poly_block()->rotate(rotation);
    box = *poly_block()->bounding_box();
}

/**
 * BLOCK::sort_rows
 *
 * Order rows so that they are in order of decreasing Y coordinate
 */

void BLOCK::sort_rows()
{
    // order on "top"
    ROW_IT row_it(&rows);

    row_it.sort (decreasing_top_order);
}


/**
 * BLOCK::compress
 *
 * Delete space between the rows. (And maybe one day, compress the rows)
 * Fill space of block from top down, left aligning rows.
 */

void BLOCK::compress()
{
    // squash it up
#define           ROW_SPACING 5

    ROW_IT row_it(&rows);
    ROW *row;
    ICOORD row_spacing (0, ROW_SPACING);

    ICOORDELT_IT icoordelt_it;

    sort_rows();

    box = TBOX (box.topleft (), box.topleft ());
    box.move_bottom_edge (ROW_SPACING);

    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
        row = row_it.data ();
        row->move (box.botleft() - row_spacing - row->bounding_box ().topleft ());
        box += row->bounding_box ();
    }

    leftside.clear ();
    icoordelt_it.set_to_list (&leftside);
    icoordelt_it.add_to_end (new ICOORDELT (box.left (), box.bottom ()));
    icoordelt_it.add_to_end (new ICOORDELT (box.left (), box.top ()));
    rightside.clear ();
    icoordelt_it.set_to_list (&rightside);
    icoordelt_it.add_to_end (new ICOORDELT (box.right (), box.bottom ()));
    icoordelt_it.add_to_end (new ICOORDELT (box.right (), box.top ()));
}


/**
 * BLOCK::check_pitch
 *
 * Check whether the block is fixed or prop, set the flag, and set
 * the pitch if it is fixed.
 */

void BLOCK::check_pitch()
{  // check prop
    //      tprintf("Missing FFT fixed pitch stuff!\n");
    pitch = -1;
}


/**
 * BLOCK::compress
 *
 * Compress and move in a single operation.
 */

// squash it up            // and move
void BLOCK::compress(const ICOORD vec)
{
    box.move (vec);
    compress();
}


/**
 * BLOCK::print
 *
 * Print the info on a block
 */

void BLOCK::print(            //print list of sides
                              FILE *,     //< file to print on
                              BOOL8 dump  //< print full detail
                              )
{
    ICOORDELT_IT it = &leftside;   //iterator

    box.print ();
    tprintf ("Proportional= %s\n", proportional ? "TRUE" : "FALSE");
    tprintf ("Kerning= %d\n", kerning);
    tprintf ("Spacing= %d\n", spacing);
    tprintf ("Fixed_pitch=%d\n", pitch);
    tprintf ("Filename= %s\n", filename.string ());

    if (dump)
    {
        tprintf ("Left side coords are:\n");
        for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
        {
            tprintf ("(%d,%d) ", it.data ()->x (), it.data ()->y ());
        }

        tprintf ("\n");
        tprintf ("Right side coords are:\n");
        it.set_to_list (&rightside);
        for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
        {
            tprintf ("(%d,%d) ", it.data ()->x (), it.data ()->y ());
        }
        tprintf ("\n");
    }
}

/**
 * BLOCK::operator=
 *
 * Assignment - duplicate the block structure, but with an EMPTY row list.
 */
//assignment              //from this
BLOCK & BLOCK::operator= (const BLOCK & source)
{
    this->ELIST_LINK::operator= (source);
    this->PDBLK::operator= (source);
    proportional = source.proportional;
    kerning = source.kerning;
    spacing = source.spacing;
    filename = source.filename;    //STRINGs assign ok

    if (!rows.empty ()) rows.clear ();

    re_rotation_ = source.re_rotation_;
    classify_rotation_ = source.classify_rotation_;
    skew_ = source.skew_;

    return *this;
}
/////////////////////////////////////////////////////////////////ocrblock////////////////////////////////////////

/////////////////////////////////////////////////////////////////varabled////////////////////////////////////////
#define VARDIR        "configs/" /*variables files */
#define MAX_ITEMS_IN_SUBMENU 30

const ERRCODE NO_VARIABLES_TO_EDIT = "No Variables defined to edit";

// Contains the mappings from unique VC ids to their actual pointers.
static std::map<int, VariableContent*> vcMap;

static int nrVariables = 0;
static int writeCommands[2];

ELISTIZE(VariableContent)

// Constructors for the various VarTypes.
VariableContent::VariableContent(STRING_VARIABLE* it) {
  my_id_ = nrVariables;
  nrVariables++;
  var_type_ = VT_STRING;
  sIt = it;
  vcMap[my_id_] = this;
}
// Constructors for the various VarTypes.
VariableContent::VariableContent(INT_VARIABLE* it) {
  my_id_ = nrVariables;
  nrVariables++;
  var_type_ = VT_INTEGER;
  iIt = it;
  vcMap[my_id_] = this;
}
// Constructors for the various VarTypes.
VariableContent::VariableContent(BOOL_VARIABLE* it) {
  my_id_ = nrVariables;
  nrVariables++;
  var_type_ = VT_BOOLEAN;
  bIt = it;
  vcMap[my_id_] = this;
}
// Constructors for the various VarTypes.
VariableContent::VariableContent(double_VARIABLE* it) {
  my_id_ = nrVariables;
  nrVariables++;
  var_type_ = VT_DOUBLE;
  dIt = it;
  vcMap[my_id_] = this;
}

// Gets a VC object identified by its ID.
VariableContent* VariableContent::GetVariableContentById(int id) {
  return vcMap[id];
}

// Copy the first N words from the source string to the target string.
// Words are delimited by "_".
void VariablesEditor::GetFirstWords(
                     const char *s,  // source string
                     int n,          // number of words
                     char *t         // target string
                    ) {
  int full_length = strlen(s);
  int reqd_len = 0;              // No. of chars requird
  const char *next_word = s;

  while ((n > 0) && reqd_len < full_length) {
    reqd_len += strcspn(next_word, "_") + 1;
    next_word += reqd_len;
    n--;
  }
  strncpy(t, s, reqd_len);
  t[reqd_len] = '\0';            // ensure null terminal
}

// Getter for the name.
const char* VariableContent::GetName() const {
  if (var_type_ == VT_INTEGER) { return iIt->name_str(); }
  else if (var_type_ == VT_BOOLEAN) { return bIt->name_str(); }
  else if (var_type_ == VT_DOUBLE) { return dIt->name_str(); }
  else if (var_type_ == VT_STRING) { return sIt->name_str(); }
  else
    return "ERROR: VariableContent::GetName()";
}

// Getter for the description.
const char* VariableContent::GetDescription() const {
  if (var_type_ == VT_INTEGER) { return iIt->info_str(); }
  else if (var_type_ == VT_BOOLEAN) { return bIt->info_str(); }
  else if (var_type_ == VT_DOUBLE) { return dIt->info_str(); }
  else if (var_type_ == VT_STRING) { return sIt->info_str(); }
  else return NULL;
}

// Getter for the value.
const char* VariableContent::GetValue() const {
char* msg = new char[1024];
  if (var_type_ == VT_INTEGER) {
    sprintf(msg, "%d", ((inT32) *(iIt)));
  } else if (var_type_ == VT_BOOLEAN) {
    sprintf(msg, "%d", ((BOOL8) * (bIt)));
  } else if (var_type_ == VT_DOUBLE) {
    sprintf(msg, "%g", ((double) * (dIt)));
  } else if (var_type_ == VT_STRING) {
    if (((STRING) * (sIt)).string() != NULL) {
      sprintf(msg, "%s", ((STRING) * (sIt)).string());
    } else {
      sprintf(msg, "Null");
    }
  }
  return msg;
}

// Setter for the value.
void VariableContent::SetValue(const char* val) {
// TODO (wanke) Test if the values actually are properly converted.
// (Quickly visible impacts?)
  changed_ = TRUE;
  if (var_type_ == VT_INTEGER) {
    iIt->set_value(atoi(val));
  } else if (var_type_ == VT_BOOLEAN) {
    bIt->set_value(atoi(val));
  } else if (var_type_ == VT_DOUBLE) {
    dIt->set_value(strtod(val, NULL));
  } else if (var_type_ == VT_STRING) {
    sIt->set_value(val);
  }
}

// Gets the up to the first 3 prefixes from s (split by _).
// For example, tesseract_foo_bar will be split into tesseract,foo and bar.
void VariablesEditor::GetPrefixes(const char* s, STRING* level_one,
                                                 STRING* level_two,
                                                 STRING* level_three) {
  char* p = new char[1024];
  GetFirstWords(s, 1, p);
  *level_one = p;
  GetFirstWords(s, 2, p);
  *level_two = p;
  GetFirstWords(s, 3, p);
  *level_three = p;
  delete[] p;
}

// Compare two VC objects by their name.
int VariableContent::Compare(const void* v1, const void* v2) {
  const VariableContent* one =
    *reinterpret_cast<const VariableContent* const *>(v1);
  const VariableContent* two =
    *reinterpret_cast<const VariableContent* const *>(v2);
  return strcmp(one->GetName(), two->GetName());
}

// Find all editable variables used within tesseract and create a
// SVMenuNode tree from it.
// TODO (wanke): This is actually sort of hackish.
SVMenuNode* VariablesEditor::BuildListOfAllLeaves() {  // find all variables.
  SVMenuNode* mr = new SVMenuNode();
  VariableContent_LIST vclist;
  VariableContent_IT vc_it(&vclist);
  // Amount counts the number of entries for a specific char*.
  // TODO(rays) get rid of the use of std::map.
  std::map<const char*, int> amount;

  INT_VARIABLE_C_IT int_it(INT_VARIABLE::get_head());
  BOOL_VARIABLE_C_IT bool_it(BOOL_VARIABLE::get_head());
  STRING_VARIABLE_C_IT str_it(STRING_VARIABLE::get_head());
  double_VARIABLE_C_IT dbl_it(double_VARIABLE::get_head());

  // Add all variables to a list.
  for (int_it.mark_cycle_pt(); !int_it.cycled_list(); int_it.forward()) {
    vc_it.add_after_then_move(new VariableContent(int_it.data()));
  }

  for (bool_it.mark_cycle_pt(); !bool_it.cycled_list(); bool_it.forward()) {
    vc_it.add_after_then_move(new VariableContent(bool_it.data()));
  }

  for (str_it.mark_cycle_pt(); !str_it.cycled_list(); str_it.forward()) {
    vc_it.add_after_then_move(new VariableContent(str_it.data()));
  }

  for (dbl_it.mark_cycle_pt(); !dbl_it.cycled_list(); dbl_it.forward()) {
    vc_it.add_after_then_move(new VariableContent(dbl_it.data()));
  }

  // Count the # of entries starting with a specific prefix.
  for (vc_it.mark_cycle_pt(); !vc_it.cycled_list(); vc_it.forward()) {
    VariableContent* vc = vc_it.data();
    STRING tag;
    STRING tag2;
    STRING tag3;

    GetPrefixes(vc->GetName(), &tag, &tag2, &tag3);
    amount[tag.string()]++;
    amount[tag2.string()]++;
    amount[tag3.string()]++;
  }

  vclist.sort(VariableContent::Compare);  // Sort the list alphabetically.

  SVMenuNode* other = mr->AddChild("OTHER");

  // go through the list again and this time create the menu structure.
  vc_it.move_to_first();
  for (vc_it.mark_cycle_pt(); !vc_it.cycled_list(); vc_it.forward()) {
    VariableContent* vc = vc_it.data();
    STRING tag;
    STRING tag2;
    STRING tag3;
    GetPrefixes(vc->GetName(), &tag, &tag2, &tag3);

    if (amount[tag.string()] == 1) { other->AddChild(vc->GetName(), vc->GetId(),
                                            vc->GetValue(),
                                            vc->GetDescription());
    } else {  // More than one would use this submenu -> create submenu.
      SVMenuNode* sv = mr->AddChild(tag.string());
      if ((amount[tag.string()] <= MAX_ITEMS_IN_SUBMENU) ||
          (amount[tag2.string()] <= 1)) {
        sv->AddChild(vc->GetName(), vc->GetId(),
                     vc->GetValue(), vc->GetDescription());
      } else {  // Make subsubmenus.
        SVMenuNode* sv2 = sv->AddChild(tag2.string());
        sv2->AddChild(vc->GetName(), vc->GetId(),
                      vc->GetValue(), vc->GetDescription());
      }
    }
  }
  return mr;
}

// Event listener. Waits for SVET_POPUP events and processes them.
void VariablesEditor::Notify(const SVEvent* sve) {
  if (sve->type == SVET_POPUP) {  // only catch SVET_POPUP!
    char* param = sve->parameter;
    if (sve->command_id == writeCommands[0]) {
      WriteVars(param, false);
    } else if (sve->command_id == writeCommands[1]) {
      WriteVars(param, true);
    } else {
      VariableContent* vc = VariableContent::GetVariableContentById(
          sve->command_id);
      vc->SetValue(param);
      sv_window_->AddMessage("Setting %s to %s",
                             vc->GetName(), vc->GetValue());
    }
  }
}

// Integrate the variables editor as popupmenu into the existing scrollview
// window (usually the pg editor). If sv == null, create a new empty
// empty window and attach the variables editor to that window (ugly).
VariablesEditor::VariablesEditor(const Tesseract* tess,
                                 ScrollView* sv) {
  if (sv == NULL) {
    const char* name = "VarEditorMAIN";
    sv = new ScrollView(name, 1, 1, 200, 200, 300, 200);
  }

  sv_window_ = sv;

  //Only one event handler per window.
  //sv->AddEventHandler((SVEventHandler*) this);

  SVMenuNode* svMenuRoot = BuildListOfAllLeaves();

  STRING varfile;
  varfile = tess->datadir;
  varfile += VARDIR;             // variables dir
  varfile += "edited";           // actual name

  SVMenuNode* std_menu = svMenuRoot->AddChild ("Build Config File");

  writeCommands[0] = nrVariables+1;
  std_menu->AddChild("All Variables", writeCommands[0],
                     varfile.string(), "Config file name?");

  writeCommands[1] = nrVariables+2;
  std_menu->AddChild ("changed_ Variables Only", writeCommands[1],
                      varfile.string(), "Config file name?");

  svMenuRoot->BuildMenu(sv, false);
}


// Write all (changed_) variables to a config file.
void VariablesEditor::WriteVars(char *filename,    // in this file
                                bool changes_only  // changed_ vars only?
                               ) {
  FILE *fp;                      // input file
  char msg_str[255];
                                 // if file exists
  if ((fp = fopen (filename, "r")) != NULL) {
    fclose(fp);
    sprintf (msg_str, "Overwrite file " "%s" "? (Y/N)", filename);
    int a = sv_window_->ShowYesNoDialog(msg_str);
    if (a == 'n') { return; }  // dont write
  }


  fp = fopen (filename, "w");  // can we write to it?
  if (fp == NULL) {
    sv_window_->AddMessage("Cant write to file " "%s" "", filename);
    return;
  }

  for (std::map<int, VariableContent*>::iterator iter = vcMap.begin();
                                          iter != vcMap.end();
                                          ++iter) {
    VariableContent* cur = iter->second;
    if (!changes_only || cur->HasChanged()) {
      fprintf (fp, "%-25s   %-12s   # %s\n",
               cur->GetName(), cur->GetValue(), cur->GetDescription());
    }
  }
  fclose(fp);
}
/////////////////////////////////////////////////////////////////varabled////////////////////////////////////////

/////////////////////////////////////////////////////////////////rejctmap////////////////////////////////////////
#define EXTERN
EXTERN BOOL_VAR (rejword_only_set_if_accepted, TRUE, "Mimic old reject_word");
EXTERN BOOL_VAR (rejmap_allow_more_good_qual, FALSE,
"Use initial good qual setting");
EXTERN BOOL_VAR (rej_use_1Il_rej, TRUE, "1Il rejection enabled");

BOOL8 REJ::perm_rejected() {  //Is char perm reject?
  return (flag (R_TESS_FAILURE) ||
    flag (R_SMALL_XHT) ||
    flag (R_EDGE_CHAR) ||
    flag (R_1IL_CONFLICT) ||
    flag (R_POSTNN_1IL) ||
    flag (R_REJ_CBLOB) ||
    flag (R_BAD_REPETITION) || flag (R_MM_REJECT));
}


BOOL8 REJ::rej_before_nn_accept() {
  return flag (R_POOR_MATCH) ||
    flag (R_NOT_TESS_ACCEPTED) ||
    flag (R_CONTAINS_BLANKS) || flag (R_BAD_PERMUTER);
}


BOOL8 REJ::rej_between_nn_and_mm() {
  return flag (R_HYPHEN) ||
    flag (R_DUBIOUS) ||
    flag (R_NO_ALPHANUMS) || flag (R_MOSTLY_REJ) || flag (R_XHT_FIXUP);
}


BOOL8 REJ::rej_between_mm_and_quality_accept() {
  return flag (R_BAD_QUALITY);
}


BOOL8 REJ::rej_between_quality_and_minimal_rej_accept() {
  return flag (R_DOC_REJ) ||
    flag (R_BLOCK_REJ) || flag (R_ROW_REJ) || flag (R_UNLV_REJ);
}


BOOL8 REJ::rej_before_mm_accept() {
  return rej_between_nn_and_mm () ||
    (rej_before_nn_accept () &&
    !flag (R_NN_ACCEPT) && !flag (R_HYPHEN_ACCEPT));
}


BOOL8 REJ::rej_before_quality_accept() {
  return rej_between_mm_and_quality_accept () ||
    (!flag (R_MM_ACCEPT) && rej_before_mm_accept ());
}


BOOL8 REJ::rejected() {  //Is char rejected?
  if (flag (R_MINIMAL_REJ_ACCEPT))
    return FALSE;
  else
    return (perm_rejected () ||
      rej_between_quality_and_minimal_rej_accept () ||
      (!flag (R_QUALITY_ACCEPT) && rej_before_quality_accept ()));
}


BOOL8 REJ::accept_if_good_quality() {  //potential rej?
  return (rejected () &&
    !perm_rejected () &&
    flag (R_BAD_PERMUTER) &&
    !flag (R_POOR_MATCH) &&
    !flag (R_NOT_TESS_ACCEPTED) &&
    !flag (R_CONTAINS_BLANKS) &&
    (rejmap_allow_more_good_qual ||
    (!rej_between_nn_and_mm () &&
    !rej_between_mm_and_quality_accept () &&
    !rej_between_quality_and_minimal_rej_accept ())));
}


void REJ::setrej_tess_failure() {  //Tess generated blank
  set_flag(R_TESS_FAILURE);
}


void REJ::setrej_small_xht() {  //Small xht char/wd
  set_flag(R_SMALL_XHT);
}


void REJ::setrej_edge_char() {  //Close to image edge
  set_flag(R_EDGE_CHAR);
}


void REJ::setrej_1Il_conflict() {  //Initial reject map
  if (rej_use_1Il_rej)
    set_flag(R_1IL_CONFLICT);
}


void REJ::setrej_postNN_1Il() {  //1Il after NN
  set_flag(R_POSTNN_1IL);
}


void REJ::setrej_rej_cblob() {  //Insert duff blob
  set_flag(R_REJ_CBLOB);
}


void REJ::setrej_mm_reject() {  //Matrix matcher
  set_flag(R_MM_REJECT);
}


void REJ::setrej_bad_repetition() {  //Odd repeated char
  set_flag(R_BAD_REPETITION);
}


void REJ::setrej_poor_match() {  //Failed Rays heuristic
  set_flag(R_POOR_MATCH);
}


void REJ::setrej_not_tess_accepted() {
                                 //TEMP reject_word
  set_flag(R_NOT_TESS_ACCEPTED);
}


void REJ::setrej_contains_blanks() {
                                 //TEMP reject_word
  set_flag(R_CONTAINS_BLANKS);
}


void REJ::setrej_bad_permuter() {  //POTENTIAL reject_word
  set_flag(R_BAD_PERMUTER);
}


void REJ::setrej_hyphen() {  //PostNN dubious hyphen or .
  set_flag(R_HYPHEN);
}


void REJ::setrej_dubious() {  //PostNN dubious limit
  set_flag(R_DUBIOUS);
}


void REJ::setrej_no_alphanums() {  //TEMP reject_word
  set_flag(R_NO_ALPHANUMS);
}


void REJ::setrej_mostly_rej() {  //TEMP reject_word
  set_flag(R_MOSTLY_REJ);
}


void REJ::setrej_xht_fixup() {  //xht fixup
  set_flag(R_XHT_FIXUP);
}


void REJ::setrej_bad_quality() {  //TEMP reject_word
  set_flag(R_BAD_QUALITY);
}


void REJ::setrej_doc_rej() {  //TEMP reject_word
  set_flag(R_DOC_REJ);
}


void REJ::setrej_block_rej() {  //TEMP reject_word
  set_flag(R_BLOCK_REJ);
}


void REJ::setrej_row_rej() {  //TEMP reject_word
  set_flag(R_ROW_REJ);
}


void REJ::setrej_unlv_rej() {  //TEMP reject_word
  set_flag(R_UNLV_REJ);
}


void REJ::setrej_hyphen_accept() {  //NN Flipped a char
  set_flag(R_HYPHEN_ACCEPT);
}


void REJ::setrej_nn_accept() {  //NN Flipped a char
  set_flag(R_NN_ACCEPT);
}


void REJ::setrej_mm_accept() {  //Matrix matcher
  set_flag(R_MM_ACCEPT);
}


void REJ::setrej_quality_accept() {  //Quality flip a char
  set_flag(R_QUALITY_ACCEPT);
}


void REJ::setrej_minimal_rej_accept() {
                                 //Accept all except blank
  set_flag(R_MINIMAL_REJ_ACCEPT);
}


void REJ::full_print(FILE *fp) {
  #ifndef SECURE_NAMES

  fprintf (fp, "R_TESS_FAILURE: %s\n", flag (R_TESS_FAILURE) ? "T" : "F");
  fprintf (fp, "R_SMALL_XHT: %s\n", flag (R_SMALL_XHT) ? "T" : "F");
  fprintf (fp, "R_EDGE_CHAR: %s\n", flag (R_EDGE_CHAR) ? "T" : "F");
  fprintf (fp, "R_1IL_CONFLICT: %s\n", flag (R_1IL_CONFLICT) ? "T" : "F");
  fprintf (fp, "R_POSTNN_1IL: %s\n", flag (R_POSTNN_1IL) ? "T" : "F");
  fprintf (fp, "R_REJ_CBLOB: %s\n", flag (R_REJ_CBLOB) ? "T" : "F");
  fprintf (fp, "R_MM_REJECT: %s\n", flag (R_MM_REJECT) ? "T" : "F");
  fprintf (fp, "R_BAD_REPETITION: %s\n", flag (R_BAD_REPETITION) ? "T" : "F");
  fprintf (fp, "R_POOR_MATCH: %s\n", flag (R_POOR_MATCH) ? "T" : "F");
  fprintf (fp, "R_NOT_TESS_ACCEPTED: %s\n",
    flag (R_NOT_TESS_ACCEPTED) ? "T" : "F");
  fprintf (fp, "R_CONTAINS_BLANKS: %s\n",
    flag (R_CONTAINS_BLANKS) ? "T" : "F");
  fprintf (fp, "R_BAD_PERMUTER: %s\n", flag (R_BAD_PERMUTER) ? "T" : "F");
  fprintf (fp, "R_HYPHEN: %s\n", flag (R_HYPHEN) ? "T" : "F");
  fprintf (fp, "R_DUBIOUS: %s\n", flag (R_DUBIOUS) ? "T" : "F");
  fprintf (fp, "R_NO_ALPHANUMS: %s\n", flag (R_NO_ALPHANUMS) ? "T" : "F");
  fprintf (fp, "R_MOSTLY_REJ: %s\n", flag (R_MOSTLY_REJ) ? "T" : "F");
  fprintf (fp, "R_XHT_FIXUP: %s\n", flag (R_XHT_FIXUP) ? "T" : "F");
  fprintf (fp, "R_BAD_QUALITY: %s\n", flag (R_BAD_QUALITY) ? "T" : "F");
  fprintf (fp, "R_DOC_REJ: %s\n", flag (R_DOC_REJ) ? "T" : "F");
  fprintf (fp, "R_BLOCK_REJ: %s\n", flag (R_BLOCK_REJ) ? "T" : "F");
  fprintf (fp, "R_ROW_REJ: %s\n", flag (R_ROW_REJ) ? "T" : "F");
  fprintf (fp, "R_UNLV_REJ: %s\n", flag (R_UNLV_REJ) ? "T" : "F");
  fprintf (fp, "R_HYPHEN_ACCEPT: %s\n", flag (R_HYPHEN_ACCEPT) ? "T" : "F");
  fprintf (fp, "R_NN_ACCEPT: %s\n", flag (R_NN_ACCEPT) ? "T" : "F");
  fprintf (fp, "R_MM_ACCEPT: %s\n", flag (R_MM_ACCEPT) ? "T" : "F");
  fprintf (fp, "R_QUALITY_ACCEPT: %s\n", flag (R_QUALITY_ACCEPT) ? "T" : "F");
  fprintf (fp, "R_MINIMAL_REJ_ACCEPT: %s\n",
    flag (R_MINIMAL_REJ_ACCEPT) ? "T" : "F");
  #endif
}


//The REJMAP class has been hacked to use alloc_struct instead of new [].
//This is to reduce memory fragmentation only as it is rather kludgy.
//alloc_struct by-passes the call to the contsructor of REJ on each
//array element. Although the constructor is empty, the BITS16 members
//do have a constructor which sets all the flags to 0. The memset
//replaces this functionality.

REJMAP::REJMAP(  //classwise copy
               const REJMAP &source) {
  REJ *to;
  REJ *from = source.ptr;
  int i;

  len = source.length ();

  if (len > 0) {
    ptr = (REJ *) alloc_struct (len * sizeof (REJ), "REJ");
    to = ptr;
    for (i = 0; i < len; i++) {
      *to = *from;
      to++;
      from++;
    }
  }
  else
    ptr = NULL;
}


REJMAP & REJMAP::operator= (     //assign REJMAP
const REJMAP & source            //from this
) {
  REJ *
    to;
  REJ *
    from = source.ptr;
  int
    i;

  initialise (source.len);
  to = ptr;
  for (i = 0; i < len; i++) {
    *to = *from;
    to++;
    from++;
  }
  return *this;
}


void REJMAP::initialise(  //Redefine map
                        inT16 length) {
  if (ptr != NULL)
    free_struct (ptr, len * sizeof (REJ), "REJ");
  len = length;
  if (len > 0)
    ptr = (REJ *) memset (alloc_struct (len * sizeof (REJ), "REJ"),
      0, len * sizeof (REJ));
  else
    ptr = NULL;
}


inT16 REJMAP::accept_count() {  //How many accepted?
  int i;
  inT16 count = 0;

  for (i = 0; i < len; i++) {
    if (ptr[i].accepted ())
      count++;
  }
  return count;
}


BOOL8 REJMAP::recoverable_rejects() {  //Any non perm rejs?
  int i;

  for (i = 0; i < len; i++) {
    if (ptr[i].recoverable ())
      return TRUE;
  }
  return FALSE;
}


BOOL8 REJMAP::quality_recoverable_rejects() {  //Any potential rejs?
  int i;

  for (i = 0; i < len; i++) {
    if (ptr[i].accept_if_good_quality ())
      return TRUE;
  }
  return FALSE;
}


void REJMAP::remove_pos(           //Cut out an element
                        inT16 pos  //element to remove
                       ) {
  REJ *new_ptr;                  //new, smaller map
  int i;

  ASSERT_HOST (pos >= 0);
  ASSERT_HOST (pos < len);
  ASSERT_HOST (len > 0);

  len--;
  if (len > 0)
    new_ptr = (REJ *) memset (alloc_struct (len * sizeof (REJ), "REJ"),
      0, len * sizeof (REJ));
  else
    new_ptr = NULL;

  for (i = 0; i < pos; i++)
    new_ptr[i] = ptr[i];         //copy pre pos

  for (; pos < len; pos++)
    new_ptr[pos] = ptr[pos + 1]; //copy post pos

                                 //delete old map
  free_struct (ptr, (len + 1) * sizeof (REJ), "REJ");
  ptr = new_ptr;
}


void REJMAP::print(FILE *fp) {
  int i;
  char buff[512];

  for (i = 0; i < len; i++) {
    buff[i] = ptr[i].display_char ();
  }
  buff[i] = '\0';
  fprintf (fp, "\"%s\"", buff);
}


void REJMAP::full_print(FILE *fp) {
  int i;

  for (i = 0; i < len; i++) {
    ptr[i].full_print (fp);
    fprintf (fp, "\n");
  }
}


void REJMAP::rej_word_small_xht() {  //Reject whole word
  int i;

  for (i = 0; i < len; i++) {
    ptr[i].setrej_small_xht ();
  }
}


void REJMAP::rej_word_tess_failure() {  //Reject whole word
  int i;

  for (i = 0; i < len; i++) {
    ptr[i].setrej_tess_failure ();
  }
}


void REJMAP::rej_word_not_tess_accepted() {  //Reject whole word
  int i;

  for (i = 0; i < len; i++) {
    if (!rejword_only_set_if_accepted || ptr[i].accepted ())
      ptr[i].setrej_not_tess_accepted ();
  }
}


void REJMAP::rej_word_contains_blanks() {  //Reject whole word
  int i;

  for (i = 0; i < len; i++) {
    if (!rejword_only_set_if_accepted || ptr[i].accepted ())
      ptr[i].setrej_contains_blanks ();
  }
}


void REJMAP::rej_word_bad_permuter() {  //Reject whole word
  int i;

  for (i = 0; i < len; i++) {
    if (!rejword_only_set_if_accepted || ptr[i].accepted ())
      ptr[i].setrej_bad_permuter ();
  }
}


void REJMAP::rej_word_xht_fixup() {  //Reject whole word
  int i;

  for (i = 0; i < len; i++) {
    if (!rejword_only_set_if_accepted || ptr[i].accepted ())
      ptr[i].setrej_xht_fixup ();
  }
}


void REJMAP::rej_word_no_alphanums() {  //Reject whole word
  int i;

  for (i = 0; i < len; i++) {
    if (!rejword_only_set_if_accepted || ptr[i].accepted ())
      ptr[i].setrej_no_alphanums ();
  }
}


void REJMAP::rej_word_mostly_rej() {  //Reject whole word
  int i;

  for (i = 0; i < len; i++) {
    if (!rejword_only_set_if_accepted || ptr[i].accepted ())
      ptr[i].setrej_mostly_rej ();
  }
}


void REJMAP::rej_word_bad_quality() {  //Reject whole word
  int i;

  for (i = 0; i < len; i++) {
    if (!rejword_only_set_if_accepted || ptr[i].accepted ())
      ptr[i].setrej_bad_quality ();
  }
}


void REJMAP::rej_word_doc_rej() {  //Reject whole word
  int i;

  for (i = 0; i < len; i++) {
    if (!rejword_only_set_if_accepted || ptr[i].accepted ())
      ptr[i].setrej_doc_rej ();
  }
}


void REJMAP::rej_word_block_rej() {  //Reject whole word
  int i;

  for (i = 0; i < len; i++) {
    if (!rejword_only_set_if_accepted || ptr[i].accepted ())
      ptr[i].setrej_block_rej ();
  }
}


void REJMAP::rej_word_row_rej() {  //Reject whole word
  int i;

  for (i = 0; i < len; i++) {
    if (!rejword_only_set_if_accepted || ptr[i].accepted ())
      ptr[i].setrej_row_rej ();
  }
}
/////////////////////////////////////////////////////////////////rejctmap////////////////////////////////////////

/////////////////////////////////////////////////////////////////pageres////////////////////////////////////////
ELISTIZE (BLOCK_RES)
CLISTIZE (BLOCK_RES) ELISTIZE (ROW_RES) ELISTIZE (WERD_RES)
/*************************************************************************
 * PAGE_RES::PAGE_RES
 *
 * Constructor for page results
 *************************************************************************/
//recursive construct   //real page
PAGE_RES::PAGE_RES(BLOCK_LIST *the_block_list)
{
    BLOCK_IT block_it(the_block_list);
    BLOCK_RES_IT block_res_it(&block_res_list);

    char_count = 0;
    rej_count = 0;
    rejected = FALSE;

    for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ())
    {
        block_res_it.add_to_end (new BLOCK_RES (block_it.data ()));
    }
}


/*************************************************************************
 * BLOCK_RES::BLOCK_RES
 *
 * Constructor for BLOCK results
 *************************************************************************/
//recursive construct  //real BLOCK
BLOCK_RES::BLOCK_RES(BLOCK *the_block)
{
    ROW_IT row_it (the_block->row_list ());
    ROW_RES_IT row_res_it(&row_res_list);

    char_count = 0;
    rej_count = 0;
    font_class = -1;               //not assigned
    x_height = -1.0;
    font_assigned = FALSE;
    bold = FALSE;
    italic = FALSE;
    row_count = 0;

    block = the_block;

    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
        row_res_it.add_to_end (new ROW_RES (row_it.data ()));
    }
}


/*************************************************************************
 * ROW_RES::ROW_RES
 *
 * Constructor for ROW results
 *************************************************************************/
//recursive construct  //real ROW
ROW_RES::ROW_RES(ROW *the_row)
{
    WERD_IT word_it (the_row->word_list ());
    WERD_RES_IT word_res_it(&word_res_list);
    WERD_RES *combo = NULL;        //current combination of fuzzies
    WERD_RES *word_res;            //current word
    WERD *copy_word;

    char_count = 0;
    rej_count = 0;
    whole_word_rej_count = 0;
    font_class = -1;
    font_class_score = -1.0;
    bold = FALSE;
    italic = FALSE;

    row = the_row;

    for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ())
    {
        word_res = new WERD_RES (word_it.data ());
        word_res->x_height = the_row->x_height();

        if (word_res->word->flag (W_FUZZY_NON))
        {
            ASSERT_HOST (combo != NULL);
            word_res->part_of_combo = TRUE;
            combo->copy_on (word_res);
        }

        if (word_it.data_relative (1)->flag (W_FUZZY_NON))
        {
            if (combo == NULL)
            {
                copy_word = new WERD;

                //deep copy
                *copy_word = *(word_it.data ());
                combo = new WERD_RES (copy_word);
                combo->x_height = the_row->x_height();
                combo->combination = TRUE;
                word_res_it.add_to_end (combo);
            }

            word_res->part_of_combo = TRUE;
        }
        else
        {
            combo = NULL;
        }

        word_res_it.add_to_end (word_res);
    }
}

//assign word_res                     //from this
WERD_RES & WERD_RES::operator= (const WERD_RES & source)
{
    this->ELIST_LINK::operator= (source);
    if (source.combination)
    {
        word = new WERD;
        *word = *(source.word);      //deep copy
    }
    else
    {
        word = source.word;          //pt to same word
    }

    if (source.outword != NULL)
    {
        outword = new WERD;
        *outword = *(source.outword);//deep copy
    }
    else
    {
        outword = NULL;
    }

    denorm = source.denorm;
    if (source.best_choice != NULL)
    {
        best_choice = new WERD_CHOICE;
        *best_choice = *(source.best_choice);
        raw_choice = new WERD_CHOICE;
        *raw_choice = *(source.raw_choice);
    }
    else
    {
        best_choice = NULL;
        raw_choice = NULL;
    }

    if (source.ep_choice != NULL)
    {
        ep_choice = new WERD_CHOICE;
        *ep_choice = *(source.ep_choice);
    }
    else
    {
        ep_choice = NULL;
    }

    reject_map = source.reject_map;
    tess_failed = source.tess_failed;
    tess_accepted = source.tess_accepted;
    tess_would_adapt = source.tess_would_adapt;
    done = source.done;
    unlv_crunch_mode = source.unlv_crunch_mode;
    italic = source.italic;
    bold = source.bold;
    font1 = source.font1;
    font1_count = source.font1_count;
    font2 = source.font2;
    font2_count = source.font2_count;
    x_height = source.x_height;
    caps_height = source.caps_height;
    guessed_x_ht = source.guessed_x_ht;
    guessed_caps_ht = source.guessed_caps_ht;
    combination = source.combination;
    part_of_combo = source.part_of_combo;
    reject_spaces = source.reject_spaces;
    return *this;
}


WERD_RES::~WERD_RES ()
{
    if (combination) delete word;

    if (outword != NULL) delete outword;
    if (best_choice != NULL)
    {
        delete best_choice;
        delete raw_choice;
    }

    if (ep_choice != NULL)
    {
        delete ep_choice;
    }
}


/*************************************************************************
 * PAGE_RES_IT::restart_page
 *
 * Set things up at the start of the page
 *************************************************************************/

WERD_RES *PAGE_RES_IT::restart_page()
{
    block_res_it.set_to_list (&page_res->block_res_list);
    block_res_it.mark_cycle_pt ();
    prev_block_res = NULL;
    prev_row_res = NULL;
    prev_word_res = NULL;
    block_res = NULL;
    row_res = NULL;
    word_res = NULL;
    next_block_res = NULL;
    next_row_res = NULL;
    next_word_res = NULL;
    internal_forward(TRUE);
    return internal_forward (FALSE);
}


/*************************************************************************
 * PAGE_RES_IT::internal_forward
 *
 * Find the next word on the page. Empty blocks and rows are skipped.
 * The iterator maintains pointers to block, row and word for the previous,
 * current and next words.  These are correct, regardless of block/row
 * boundaries. NULL values denote start and end of the page.
 *************************************************************************/

WERD_RES *PAGE_RES_IT::internal_forward(BOOL8 new_block)
{
    BOOL8 found_next_word = FALSE;
    BOOL8 new_row = FALSE;

    prev_block_res = block_res;
    prev_row_res = row_res;
    prev_word_res = word_res;
    block_res = next_block_res;
    row_res = next_row_res;
    word_res = next_word_res;

    while (!found_next_word && !block_res_it.cycled_list ())
    {
        if (new_block)
        {
            new_block = FALSE;
            row_res_it.set_to_list (&block_res_it.data ()->row_res_list);
            row_res_it.mark_cycle_pt ();
            new_row = TRUE;
        }

        while (!found_next_word && !row_res_it.cycled_list ())
        {
            if (new_row)
            {
                new_row = FALSE;
                word_res_it.set_to_list (&row_res_it.data ()->word_res_list);
                word_res_it.mark_cycle_pt ();
            }

            while (!found_next_word && !word_res_it.cycled_list ())
            {
                next_block_res = block_res_it.data ();
                next_row_res = row_res_it.data ();
                next_word_res = word_res_it.data ();
                found_next_word = TRUE;

                do
                {
                    word_res_it.forward ();
                }
                while (word_res_it.data ()->part_of_combo);
            }

            if (!found_next_word)
            {
                //end of row reached
                row_res_it.forward ();
                new_row = TRUE;
            }
        }

        if (!found_next_word)
        {
            //end of block reached
            block_res_it.forward ();
            new_block = TRUE;
        }
    }

    if (!found_next_word)
    {
        //end of page reached
        next_block_res = NULL;
        next_row_res = NULL;
        next_word_res = NULL;
    }

    return word_res;
}


/*************************************************************************
 * PAGE_RES_IT::forward_block
 *
 * Move to the first word of the next block
 * Can be followed by subsequent calls to forward() BUT at the first word in
 * the block, the prev block, row and word are all NULL.
 *************************************************************************/

WERD_RES *PAGE_RES_IT::forward_block()
{
    if (block_res == next_block_res)
    {
        block_res_it.forward ();;
        block_res = NULL;
        row_res = NULL;
        word_res = NULL;
        next_block_res = NULL;
        next_row_res = NULL;
        next_word_res = NULL;
        internal_forward(TRUE);
    }

    return internal_forward (FALSE);
}


void PAGE_RES_IT::rej_stat_word()
{
    inT16 chars_in_word;
    inT16 rejects_in_word = 0;

    chars_in_word = word_res->reject_map.length ();
    page_res->char_count += chars_in_word;
    block_res->char_count += chars_in_word;
    row_res->char_count += chars_in_word;

    rejects_in_word = word_res->reject_map.reject_count ();

    page_res->rej_count += rejects_in_word;
    block_res->rej_count += rejects_in_word;
    row_res->rej_count += rejects_in_word;
    if (chars_in_word == rejects_in_word)
        row_res->whole_word_rej_count += rejects_in_word;
}
/////////////////////////////////////////////////////////////////pageres////////////////////////////////////////

/////////////////////////////////////////////////////////////////tstruct////////////////////////////////////////
static ERRCODE BADFRAGMENTS = "Couldn't find matching fragment ends";

ELISTIZE (FRAGMENT)
//extern /*"C"*/ oldoutline(TESSLINE*);
/**********************************************************************
 * FRAGMENT::FRAGMENT
 *
 * Constructor for fragments.
 **********************************************************************/
FRAGMENT::FRAGMENT (             //constructor
EDGEPT * head_pt,                //start point
EDGEPT * tail_pt                 //end point
):head (head_pt->pos.x, head_pt->pos.y), tail (tail_pt->pos.x,
tail_pt->pos.y) {
  headpt = head_pt;              // save ptrs
  tailpt = tail_pt;
}

// Helper function to make a fake PBLOB formed from the bounding box
// of the given old-format outline.
static PBLOB* MakeRectBlob(TESSLINE* ol) {
  POLYPT_LIST poly_list;
  POLYPT_IT poly_it = &poly_list;
  FCOORD pos, vec;
  POLYPT *polypt;

  // Create points at each of the 4 corners of the rectangle in turn.
  pos = FCOORD(ol->topleft.x, ol->topleft.y);
  vec = FCOORD(0.0f, ol->botright.y - ol->topleft.y);
  polypt = new POLYPT(pos, vec);
  poly_it.add_after_then_move(polypt);
  pos = FCOORD(ol->topleft.x, ol->botright.y);
  vec = FCOORD(ol->botright.x - ol->topleft.x, 0.0f);
  polypt = new POLYPT(pos, vec);
  poly_it.add_after_then_move(polypt);
  pos = FCOORD(ol->botright.x, ol->botright.y);
  vec = FCOORD(0.0f, ol->topleft.y - ol->botright.y);
  polypt = new POLYPT(pos, vec);
  poly_it.add_after_then_move(polypt);
  pos = FCOORD(ol->botright.x, ol->topleft.y);
  vec = FCOORD(ol->topleft.x - ol->botright.x, 0.0f);
  polypt = new POLYPT(pos, vec);
  poly_it.add_after_then_move(polypt);

  OUTLINE_LIST out_list;
  OUTLINE_IT out_it = &out_list;
  out_it.add_after_then_move(new OUTLINE(&poly_it));
  return new PBLOB(&out_list);
}

/**********************************************************************
 * make_ed_word
 *
 * Make an editor format word from the tess style word.
 **********************************************************************/

WERD *make_ed_word(                  //construct word
                   TWERD *tessword,  //word to convert
                   WERD *clone       //clone this one
                  ) {
  WERD *word;                    //converted word
  TBLOB *tblob;                  //current blob
  PBLOB *blob;                   //new blob
  PBLOB_LIST blobs;              //list of blobs
  PBLOB_IT blob_it = &blobs;     //iterator

  for (tblob = tessword->blobs; tblob != NULL; tblob = tblob->next) {
    blob = make_ed_blob (tblob);
    if (blob == NULL && tblob->outlines != NULL) {
      // Make a fake blob using the bounding box rectangle of the 1st outline.
      blob = MakeRectBlob(tblob->outlines);
    }
    if (blob != NULL) {
      blob_it.add_after_then_move (blob);
    }
  }
  if (!blobs.empty ())
    word = new WERD (&blobs, clone);
  else
    word = NULL;
  return word;
}

/**********************************************************************
 * make_tess_row
 *
 * Make a fake row structure to pass to the tesseract matchers.
 **********************************************************************/

void make_tess_row(                  //make fake row
                   DENORM *denorm,   //row info
                   TEXTROW *tessrow  //output row
                  ) {
  tessrow->baseline.segments = 1;
  tessrow->baseline.xstarts[0] = -32767;
  tessrow->baseline.xstarts[1] = 32767;
  tessrow->baseline.quads[0].a = 0;
  tessrow->baseline.quads[0].b = 0;
  tessrow->baseline.quads[0].c = bln_baseline_offset;
  tessrow->xheight.segments = 1;
  tessrow->xheight.xstarts[0] = -32767;
  tessrow->xheight.xstarts[1] = 32767;
  tessrow->xheight.quads[0].a = 0;
  tessrow->xheight.quads[0].b = 0;
  tessrow->xheight.quads[0].c = bln_x_height + bln_baseline_offset;
  tessrow->lineheight = bln_x_height;
  if (denorm != NULL) {
    tessrow->ascrise = denorm->row ()->ascenders () * denorm->scale ();
    tessrow->descdrop = denorm->row ()->descenders () * denorm->scale ();
  } else {
    tessrow->ascrise = bln_baseline_offset;
    tessrow->descdrop = -bln_baseline_offset;
  }
}


/**********************************************************************
 * make_tess_word
 *
 * Convert the word to Tess format.
 **********************************************************************/

TWERD *make_tess_word(              //convert word
                      WERD *word,   //word to do
                      TEXTROW *row  //fake row
                     ) {
  TWERD *tessword;               //tess format

  tessword = newword ();         //use old allocator
  tessword->row = row;           //give them something
                                 //copy string
  tessword->correct = strsave (word->text ());
  tessword->guess = NULL;
  tessword->blobs = make_tess_blobs (word->blob_list ());
  tessword->blanks = 1;
  tessword->blobcount = word->blob_list ()->length ();
  tessword->next = NULL;
  return tessword;
}


/**********************************************************************
 * make_tess_blobs
 *
 * Make Tess style blobs from a list of BLOBs.
 **********************************************************************/

TBLOB *make_tess_blobs(                      //make tess blobs
                       PBLOB_LIST *bloblist  //list to convert
                      ) {
  PBLOB_IT it = bloblist;        //iterator
  PBLOB *blob;                   //current blob
  TBLOB *head;                   //output list
  TBLOB *tail;                   //end of list
  TBLOB *tessblob;

  head = NULL;
  tail = NULL;
  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
    blob = it.data ();
    tessblob = make_tess_blob (blob, TRUE);
    if (head)
      tail->next = tessblob;
    else
      head = tessblob;
    tail = tessblob;
  }
  return head;
}

/**********************************************************************
 * make_rotated_tess_blob
 *
 * Make a single Tess style blob, applying the given rotation and
 * renormalizing.
 **********************************************************************/
TBLOB *make_rotated_tess_blob(const DENORM* denorm, PBLOB *blob,
                              BOOL8 flatten) {
  if (denorm != NULL && denorm->block() != NULL &&
      denorm->block()->classify_rotation().y() != 0.0) {
    TBOX box = blob->bounding_box();
    int src_width = box.width();
    int src_height = box.height();
    src_width = static_cast<int>(src_width / denorm->scale() + 0.5);
    src_height = static_cast<int>(src_height / denorm->scale() + 0.5);
    int x_middle = (box.left() + box.right()) / 2;
    int y_middle = (box.top() + box.bottom()) / 2;
    PBLOB* rotated_blob = PBLOB::deep_copy(blob);
    rotated_blob->move(FCOORD(-x_middle, -y_middle));
    rotated_blob->rotate(denorm->block()->classify_rotation());
    ICOORD median_size = denorm->block()->median_size();
    int tolerance = median_size.x() / 8;
    // TODO(dsl/rays) find a better normalization solution. In the mean time
    // make it work for CJK by normalizing for Cap height in the same way
    // as is applied in compute_block_xheight when the row is presumed to
    // be ALLCAPS, i.e. the x-height is the fixed fraction
    // blob height * textord_merge_x / (textord_merge_x + textord_merge_asc)
    if (NearlyEqual(src_width, static_cast<int>(median_size.x()), tolerance) &&
        NearlyEqual(src_height, static_cast<int>(median_size.y()), tolerance)) {
      float target_height = bln_x_height * (textord_merge_x + textord_merge_asc)
                          / textord_merge_x;
      rotated_blob->scale(target_height / box.width());
      rotated_blob->move(FCOORD(0.0f,
                                bln_baseline_offset -
                                  rotated_blob->bounding_box().bottom()));
    }
    TBLOB* result = make_tess_blob(rotated_blob, flatten);
    delete rotated_blob;
    return result;
  } else {
    return make_tess_blob(blob, flatten);
  }
}

/**********************************************************************
 * make_tess_blob
 *
 * Make a single Tess style blob
 **********************************************************************/

TBLOB *make_tess_blob(               //make tess blob
                      PBLOB *blob,   //blob to convert
                      BOOL8 flatten  //flatten outline structure
                     ) {
  inT32 index;
  TBLOB *tessblob;

  tessblob = newblob ();
  tessblob->outlines = (struct olinestruct *)
    make_tess_outlines (blob->out_list (), flatten);
  for (index = 0; index < TBLOBFLAGS; index++)
    tessblob->flags[index] = 0;  //!!
  tessblob->correct = 0;
  tessblob->guess = 0;
  for (index = 0; index < MAX_WO_CLASSES; index++) {
    tessblob->classes[index] = 0;
    tessblob->values[index] = 0;
  }
  tessblob->next = NULL;
  return tessblob;
}


/**********************************************************************
 * make_tess_outlines
 *
 * Make Tess style outlines from a list of OUTLINEs.
 **********************************************************************/

TESSLINE *make_tess_outlines(                            //make tess outlines
                             OUTLINE_LIST *outlinelist,  //list to convert
                             BOOL8 flatten               //flatten outline structure
                            ) {
  OUTLINE_IT it = outlinelist;   //iterator
  OUTLINE *outline;              //current outline
  TESSLINE *head;                //output list
  TESSLINE *tail;                //end of list
  TESSLINE *tessoutline;

  head = NULL;
  tail = NULL;
  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
    outline = it.data ();
    tessoutline = newoutline ();
    tessoutline->compactloop = NULL;
    tessoutline->loop = make_tess_edgepts (outline->polypts (),
      tessoutline->topleft,
      tessoutline->botright);
    if (tessoutline->loop == NULL) {
      oldoutline(tessoutline);
      continue;
    }
    tessoutline->start = tessoutline->loop->pos;
    tessoutline->node = NULL;
    tessoutline->next = NULL;
    tessoutline->child = NULL;
    if (!outline->child ()->empty ()) {
      if (flatten)
        tessoutline->next = (struct olinestruct *)
          make_tess_outlines (outline->child (), flatten);
      else {
        tessoutline->next = NULL;
        tessoutline->child = (struct olinestruct *)
          make_tess_outlines (outline->child (), flatten);
      }
    }
    else
      tessoutline->next = NULL;
    if (head)
      tail->next = tessoutline;
    else
      head = tessoutline;
    while (tessoutline->next != NULL)
      tessoutline = tessoutline->next;
    tail = tessoutline;
  }
  return head;
}


/**********************************************************************
 * make_tess_edgepts
 *
 * Make Tess style edgepts from a list of POLYPTs.
 **********************************************************************/

EDGEPT *make_tess_edgepts(                          //make tess edgepts
                          POLYPT_LIST *edgeptlist,  //list to convert
                          TPOINT &tl,               //bounding box
                          TPOINT &br) {
  inT32 index;
  POLYPT_IT it = edgeptlist;     //iterator
  POLYPT *edgept;                //current edgept
  EDGEPT *head;                  //output list
  EDGEPT *tail;                  //end of list
  EDGEPT *tessedgept;

  head = NULL;
  tail = NULL;
  tl.x = MAX_INT16;
  tl.y = -MAX_INT16;
  br.x = -MAX_INT16;
  br.y = MAX_INT16;
  for (it.mark_cycle_pt (); !it.cycled_list ();) {
    edgept = it.data ();
    tessedgept = newedgept ();
    tessedgept->pos.x = (inT16) edgept->pos.x ();
    tessedgept->pos.y = (inT16) edgept->pos.y ();
    if (tessedgept->pos.x < tl.x)
      tl.x = tessedgept->pos.x;
    if (tessedgept->pos.x > br.x)
      br.x = tessedgept->pos.x;
    if (tessedgept->pos.y > tl.y)
      tl.y = tessedgept->pos.y;
    if (tessedgept->pos.y < br.y)
      br.y = tessedgept->pos.y;
    if (head != NULL && tessedgept->pos.x == tail->pos.x
    && tessedgept->pos.y == tail->pos.y) {
      oldedgept(tessedgept);
    }
    else {
      for (index = 0; index < EDGEPTFLAGS; index++)
        tessedgept->flags[index] = 0;
      if (head != NULL) {
        tail->vec.x = tessedgept->pos.x - tail->pos.x;
        tail->vec.y = tessedgept->pos.y - tail->pos.y;
        tessedgept->prev = tail;
      }
      tessedgept->next = head;
      if (head)
        tail->next = tessedgept;
      else
        head = tessedgept;
      tail = tessedgept;
    }
    it.forward ();
  }
  head->prev = tail;
  tail->vec.x = head->pos.x - tail->pos.x;
  tail->vec.y = head->pos.y - tail->pos.y;
  if (head == tail) {
    oldedgept(head);
    return NULL;                 //empty
  }
  return head;
}
/////////////////////////////////////////////////////////////////tstruct////////////////////////////////////////

/////////////////////////////////////////////////////////////////docqual////////////////////////////////////////
#define EXTERN
EXTERN STRING_VAR (outlines_odd, "%| ", "Non standard number of outlines");
EXTERN STRING_VAR (outlines_2, "ij!?%\":;", "Non standard number of outlines");
EXTERN BOOL_VAR (docqual_excuse_outline_errs, FALSE, "Allow outline errs in unrejection?");
EXTERN BOOL_VAR (tessedit_good_quality_unrej, TRUE, "Reduce rejection on good docs");
EXTERN BOOL_VAR (tessedit_use_reject_spaces, TRUE, "Reject spaces?");
EXTERN double_VAR (tessedit_reject_doc_percent, 65.00, "%rej allowed before rej whole doc");
EXTERN double_VAR (tessedit_reject_block_percent, 45.00, "%rej allowed before rej whole block");
EXTERN double_VAR (tessedit_reject_row_percent, 40.00, "%rej allowed before rej whole row");
EXTERN double_VAR (tessedit_whole_wd_rej_row_percent, 70.00, "%of row rejects in whole word rejects which prevents whole row rejection");
EXTERN BOOL_VAR (tessedit_preserve_blk_rej_perfect_wds, TRUE, "Only rej partially rejected words in block rejection");
EXTERN BOOL_VAR (tessedit_preserve_row_rej_perfect_wds, TRUE, "Only rej partially rejected words in row rejection");
EXTERN BOOL_VAR (tessedit_dont_blkrej_good_wds, FALSE, "Use word segmentation quality metric");
EXTERN BOOL_VAR (tessedit_dont_rowrej_good_wds, FALSE, "Use word segmentation quality metric");
EXTERN INT_VAR (tessedit_preserve_min_wd_len, 2, "Only preserve wds longer than this");
EXTERN BOOL_VAR (tessedit_row_rej_good_docs, TRUE, "Apply row rejection to good docs");
EXTERN double_VAR (tessedit_good_doc_still_rowrej_wd, 1.1, "rej good doc wd if more than this fraction rejected");
EXTERN BOOL_VAR (tessedit_reject_bad_qual_wds, TRUE, "Reject all bad quality wds");
EXTERN BOOL_VAR (tessedit_debug_doc_rejection, FALSE, "Page stats");
EXTERN BOOL_VAR (tessedit_debug_quality_metrics, FALSE, "Output data to debug file");
EXTERN BOOL_VAR (bland_unrej, FALSE, "unrej potential with no checks");
EXTERN double_VAR (quality_rowrej_pc, 1.1, "good_quality_doc gte good char limit");

EXTERN BOOL_VAR (unlv_tilde_crunching, TRUE, "Mark v.bad words for tilde crunch");
EXTERN BOOL_VAR (crunch_early_merge_tess_fails, TRUE, "Before word crunch?");
EXTERN BOOL_EVAR (crunch_early_convert_bad_unlv_chs, FALSE, "Take out ~^ early?");

EXTERN double_VAR (crunch_terrible_rating, 80.0, "crunch rating lt this");
EXTERN BOOL_VAR (crunch_terrible_garbage, TRUE, "As it says");
EXTERN double_VAR (crunch_poor_garbage_cert, -9.0, "crunch garbage cert lt this");
EXTERN double_VAR (crunch_poor_garbage_rate, 60, "crunch garbage rating lt this");

EXTERN double_VAR (crunch_pot_poor_rate, 40, "POTENTIAL crunch rating lt this");
EXTERN double_VAR (crunch_pot_poor_cert, -8.0, "POTENTIAL crunch cert lt this");
EXTERN BOOL_VAR (crunch_pot_garbage, TRUE, "POTENTIAL crunch garbage");

EXTERN double_VAR (crunch_del_rating, 60, "POTENTIAL crunch rating lt this");
EXTERN double_VAR (crunch_del_cert, -10.0, "POTENTIAL crunch cert lt this");
EXTERN double_VAR (crunch_del_min_ht, 0.7, "Del if word ht lt xht x this");
EXTERN double_VAR (crunch_del_max_ht, 3.0, "Del if word ht gt xht x this");
EXTERN double_VAR (crunch_del_min_width, 3.0, "Del if word width lt xht x this");
EXTERN double_VAR (crunch_del_high_word, 1.5, "Del if word gt xht x this above bl");
EXTERN double_VAR (crunch_del_low_word, 0.5, "Del if word gt xht x this below bl");
EXTERN double_VAR (crunch_small_outlines_size, 0.6, "Small if lt xht x this");

EXTERN INT_VAR (crunch_rating_max, 10, "For adj length in rating per ch");
EXTERN INT_VAR (crunch_pot_indicators, 1, "How many potential indicators needed");

EXTERN BOOL_VAR (crunch_leave_ok_strings, TRUE, "Dont touch sensible strings");
EXTERN BOOL_VAR (crunch_accept_ok, TRUE, "Use acceptability in okstring");
EXTERN BOOL_VAR (crunch_leave_accept_strings, FALSE, "Dont pot crunch sensible strings");
EXTERN BOOL_VAR (crunch_include_numerals, FALSE, "Fiddle alpha figures");
EXTERN INT_VAR (crunch_leave_lc_strings, 4, "Dont crunch words with long lower case strings");
EXTERN INT_VAR (crunch_leave_uc_strings, 4, "Dont crunch words with long lower case strings");
EXTERN INT_VAR (crunch_long_repetitions, 3, "Crunch words with long repetitions");

EXTERN INT_VAR (crunch_debug, 0, "As it says");

static BOOL8 crude_match_blobs(PBLOB *blob1, PBLOB *blob2);
static void unrej_good_chs(WERD_RES *word, ROW *row);

/*************************************************************************
 * word_blob_quality()
 * How many blobs in the outword are identical to those of the inword?
 * ASSUME blobs in both initial word and outword are in ascending order of
 * left hand blob edge.
 *************************************************************************/
//Blob seg changes
inT16 word_blob_quality(WERD_RES *word, ROW *row)
{
  WERD *bln_word;                //BL norm init word
  TWERD *tessword;               //tess format
  WERD *init_word;               //BL norm init word
  PBLOB_IT outword_it;
  PBLOB_IT initial_it;
  inT16 i;
  inT16 init_blobs_left;
  inT16 match_count = 0;
  BOOL8 matched;
  TBOX out_box;
  PBLOB *test_blob;
  DENORM denorm;
  float bln_xht;

  if (word->word->gblob_list ()->empty ())
  {
    return 0;
  }

  //xht used for blnorm
  bln_xht = bln_x_height / word->denorm.scale ();
  bln_word = make_bln_copy(word->word, row, NULL, bln_xht, &denorm);

  /*
    NOTE: Need to convert to tess format and back again to ensure that the
    same float -> int rounding of coords is done to source wd as out wd before
    comparison
  */
  tessword = make_tess_word(bln_word, NULL);  // Convert word.
  init_word = make_ed_word(tessword, bln_word);
  delete bln_word;
  delete_word(tessword);

  if (init_word == NULL)
  {
    // Conversion failed.
    return 0;
  }

  initial_it.set_to_list(init_word->blob_list());
  init_blobs_left = initial_it.length();
  outword_it.set_to_list(word->outword->blob_list());

  for (outword_it.mark_cycle_pt(); !outword_it.cycled_list(); outword_it.forward())
  {
    out_box = outword_it.data()->bounding_box();

    // Skip any initial blobs LEFT of current outword blob.
    while (!initial_it.at_last() && (initial_it.data()->bounding_box().left() < out_box.left()))
    {
      initial_it.forward();
      init_blobs_left--;
    }

    /* See if current outword blob matches any initial blob with the same left
      coord. (Normally only one but possibly more - in unknown order) */

    i = 0;
    matched = FALSE;
    do
    {
      test_blob = initial_it.data_relative (i++);
      matched = crude_match_blobs (test_blob, outword_it.data ());

      if (matched)
      {
        match_count++;
      }
    }
    while (!matched && (init_blobs_left - i > 0) && (i < 129) && !initial_it.at_last() && test_blob->bounding_box().left() == out_box.left());
  }

  delete init_word;

  return match_count;
}


/*************************************************************************
 * crude_match_blobs()
 * Check bounding boxes are the same and the number of outlines are the same.
 *************************************************************************/
static BOOL8 crude_match_blobs(PBLOB *blob1, PBLOB *blob2)
{
  TBOX box1 = blob1->bounding_box();
  TBOX box2 = blob2->bounding_box();

  if (box1.contains(box2) && box2.contains(box1) && (blob1->out_list()->length() == blob1->out_list()->length()))
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}


inT16 word_outline_errs(WERD_RES *word)
{
  PBLOB_IT outword_it;
  inT16 i = 0;
  inT16 err_count = 0;

  outword_it.set_to_list(word->outword->blob_list());

  for (outword_it.mark_cycle_pt(); !outword_it.cycled_list(); outword_it.forward())
  {
    err_count += count_outline_errs(word->best_choice->unichar_string()[i], outword_it.data()->out_list()->length());
    i++;
  }

  return err_count;
}


/*************************************************************************
 * word_char_quality()
 * Combination of blob quality and outline quality - how many good chars are
 * there? - I.e chars which pass the blob AND outline tests.
 *************************************************************************/
void word_char_quality(WERD_RES *word, ROW *row, inT16 *match_count, inT16 *accepted_match_count)
{
  WERD *bln_word;                // BL norm init word
  TWERD *tessword;               // tess format
  WERD *init_word;               // BL norm init word
  PBLOB_IT outword_it;
  PBLOB_IT initial_it;
  inT16 i;
  inT16 init_blobs_left;
  BOOL8 matched;
  TBOX out_box;
  PBLOB *test_blob;
  DENORM denorm;
  float bln_xht;
  inT16 j = 0;

  *match_count = 0;
  *accepted_match_count = 0;
  if (word->word->gblob_list ()->empty ())
  {
    return;
  }


  // xht used for blnorm
  bln_xht = bln_x_height / word->denorm.scale();
  bln_word = make_bln_copy(word->word, row, NULL, bln_xht, &denorm);

  /*
    NOTE: Need to convert to tess format and back again to ensure that the
    same float -> int rounding of coords is done to source wd as out wd before
    comparison
  */
  tessword = make_tess_word(bln_word, NULL);  // Convert word.
  init_word = make_ed_word(tessword, bln_word);
  delete bln_word;
  delete_word(tessword);

  if (init_word == NULL)
  {
    return;
  }

  initial_it.set_to_list(init_word->blob_list());
  init_blobs_left = initial_it.length();
  outword_it.set_to_list(word->outword->blob_list());

  for (outword_it.mark_cycle_pt(); !outword_it.cycled_list(); outword_it.forward())
  {
    out_box = outword_it.data()->bounding_box();

    /* Skip any initial blobs LEFT of current outword blob */
    while (!initial_it.at_last() && (initial_it.data()->bounding_box().left() < out_box.left()))
    {
      initial_it.forward();
      init_blobs_left--;
    }

    /* See if current outword blob matches any initial blob with the same left
      coord. (Normally only one but possibly more - in unknown order) */

    i = 0;
    matched = FALSE;
    do
    {
      test_blob = initial_it.data_relative(i++);
      matched = crude_match_blobs(test_blob, outword_it.data());

      if (matched && (count_outline_errs (word->best_choice->unichar_string()[j], outword_it.data ()->out_list ()->length ()) == 0))
      {
        (*match_count)++;

          if (word->reject_map[j].accepted ())
          {
             (*accepted_match_count)++;
          }
      }
    }
    while (!matched && (init_blobs_left - i > 0) && (i < 129) && !initial_it.at_last() && test_blob->bounding_box().left() == out_box.left());

    j++;
  }

  delete init_word;
}


/*************************************************************************
 * unrej_good_chs()
 * Unreject POTENTIAL rejects if the blob passes the blob and outline checks
 *************************************************************************/
static void unrej_good_chs(WERD_RES *word, ROW *row)
{
  WERD *bln_word;                // BL norm init word
  TWERD *tessword;               // tess format
  WERD *init_word;               // BL norm init word
  PBLOB_IT outword_it;
  PBLOB_IT initial_it;
  inT16 i;
  inT16 init_blobs_left;
  BOOL8 matched;
  TBOX out_box;
  PBLOB *test_blob;
  DENORM denorm;
  float bln_xht;
  inT16 j = 0;

  if (word->word->gblob_list ()->empty ())
  {
    return;
  }


  // xht used for blnorm
  bln_xht = bln_x_height / word->denorm.scale ();
  bln_word = make_bln_copy(word->word, row, NULL, bln_xht, &denorm);

  /*
    NOTE: Need to convert to tess format and back again to ensure that the
    same float -> int rounding of coords is done to source wd as out wd before
    comparison
  */
  tessword = make_tess_word(bln_word, NULL);  // Convert word
  init_word = make_ed_word(tessword, bln_word);
  delete bln_word;
  delete_word(tessword);

  if (init_word == NULL)
  {
    return;
  }

  initial_it.set_to_list (init_word->blob_list ());
  init_blobs_left = initial_it.length ();
  outword_it.set_to_list (word->outword->blob_list ());

  for (outword_it.mark_cycle_pt (); !outword_it.cycled_list (); outword_it.forward ())
  {
    out_box = outword_it.data ()->bounding_box ();

    /* Skip any initial blobs LEFT of current outword blob */
    while (!initial_it.at_last () && (initial_it.data ()->bounding_box ().left () < out_box.left ()))
    {
      initial_it.forward ();
      init_blobs_left--;
    }

    /* See if current outword blob matches any initial blob with the same left
      coord. (Normally only one but possibly more - in unknown order) */

    i = 0;
    matched = FALSE;
    do
    {
      test_blob = initial_it.data_relative (i++);
      matched = crude_match_blobs (test_blob, outword_it.data ());

      if (matched && (word->reject_map[j].accept_if_good_quality ()) &&
              (docqual_excuse_outline_errs || (count_outline_errs(word->best_choice->unichar_string()[j], outword_it.data ()->out_list ()-> length ()) == 0)))
      {
        word->reject_map[j].setrej_quality_accept ();
      }
    }
    while (!matched && (init_blobs_left - i > 0) && (i < 129) && !initial_it.at_last () && test_blob->bounding_box ().left () == out_box.left ());

    j++;
  }

  delete init_word;
}


void print_boxes(WERD *word)
{
  PBLOB_IT it;
  TBOX box;

  it.set_to_list (word->blob_list ());
  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
  {
    box = it.data ()->bounding_box ();
    box.print ();
  }
}


inT16 count_outline_errs(char c, inT16 outline_count)
{
  int expected_outline_count;

  if (STRING (outlines_odd).contains (c))
  {
    return 0;                    //Dont use this char
  }
  else if (STRING (outlines_2).contains (c))
  {
    expected_outline_count = 2;
  }
  else
  {
    expected_outline_count = 1;
  }

  return abs (outline_count - expected_outline_count);
}

void Tesseract::quality_based_rejection(PAGE_RES_IT &page_res_it, BOOL8 good_quality_doc)
{
  if ((tessedit_good_quality_unrej && good_quality_doc))
  {
    unrej_good_quality_words(page_res_it);
  }
  doc_and_block_rejection(page_res_it, good_quality_doc);

  page_res_it.restart_page ();
  while (page_res_it.word () != NULL)
  {
    insert_rej_cblobs(page_res_it.word());
    page_res_it.forward();
  }

  if (unlv_tilde_crunching)
  {
    tilde_crunch(page_res_it);
    tilde_delete(page_res_it);
  }
}


/*************************************************************************
 * unrej_good_quality_words()
 * Accept potential rejects in words which pass the following checks:
 *    - Contains a potential reject
 *    - Word looks like a sensible alpha word.
 *    - Word segmentation is the same as the original image
 *		- All characters have the expected number of outlines
 * NOTE - the rejection counts are recalculated after unrejection
 *      - CANT do it in a single pass without a bit of fiddling
 *		- keep it simple but inefficient
 *************************************************************************/
//unreject potential
void Tesseract::unrej_good_quality_words(PAGE_RES_IT &page_res_it)
{
  WERD_RES *word;
  ROW_RES *current_row;
  BLOCK_RES *current_block;
  int i;

  page_res_it.restart_page ();
  while (page_res_it.word () != NULL)
  {
    check_debug_pt (page_res_it.word (), 100);
    if (bland_unrej)
    {
      word = page_res_it.word ();
      for (i = 0; i < word->reject_map.length (); i++)
      {
        if (word->reject_map[i].accept_if_good_quality ())
        {
          word->reject_map[i].setrej_quality_accept ();
        }
      }

      page_res_it.forward ();
    }
    else if ((page_res_it.row ()->char_count > 0) && ((page_res_it.row ()->rej_count / (float) page_res_it.row ()->char_count) <= quality_rowrej_pc))
    {
      word = page_res_it.word ();
      if (word->reject_map.quality_recoverable_rejects () && (tessedit_unrej_any_wd ||
        acceptable_word_string(word->best_choice->unichar_string().string(), word->best_choice->unichar_lengths().string()) != AC_UNACCEPTABLE))
      {
        unrej_good_chs (word, page_res_it.row ()->row);
      }

      page_res_it.forward ();
    }
    else
    {
      /* Skip to end of dodgy row */
      current_row = page_res_it.row ();
      while ((page_res_it.word () != NULL) && (page_res_it.row () == current_row))
      {
        page_res_it.forward ();
      }
    }

    check_debug_pt (page_res_it.word (), 110);
  }

  page_res_it.restart_page ();
  page_res_it.page_res->char_count = 0;
  page_res_it.page_res->rej_count = 0;
  current_block = NULL;
  current_row = NULL;

  while (page_res_it.word () != NULL)
  {
    if (current_block != page_res_it.block ())
    {
      current_block = page_res_it.block ();
      current_block->char_count = 0;
      current_block->rej_count = 0;
    }

    if (current_row != page_res_it.row ())
    {
      current_row = page_res_it.row ();
      current_row->char_count = 0;
      current_row->rej_count = 0;
      current_row->whole_word_rej_count = 0;
    }

    page_res_it.rej_stat_word ();
    page_res_it.forward ();
  }
}


/*************************************************************************
 * doc_and_block_rejection()
 *
 * If the page has too many rejects - reject all of it.
 * If any block has too many rejects - reject all words in the block
 *************************************************************************/
//reject big chunks
void Tesseract::doc_and_block_rejection(PAGE_RES_IT &page_res_it, BOOL8 good_quality_doc)
{
  inT16 block_no = 0;
  inT16 row_no = 0;
  BLOCK_RES *current_block;
  ROW_RES *current_row;

  BOOL8 rej_word;
  BOOL8 prev_word_rejected;
  inT16 char_quality;
  inT16 accepted_char_quality;

  if ((page_res_it.page_res->rej_count * 100.0 / page_res_it.page_res->char_count) > tessedit_reject_doc_percent)
  {
    reject_whole_page(page_res_it);
    #ifndef SECURE_NAMES
    if (tessedit_debug_doc_rejection)
    {
      tprintf ("REJECT ALL #chars: %d #Rejects: %d; \n", page_res_it.page_res->char_count, page_res_it.page_res->rej_count);
    }
    #endif
  }
  else
  {
    #ifndef SECURE_NAMES
    if (tessedit_debug_doc_rejection)
    {
        tprintf("NO PAGE REJECTION #chars: %d  # Rejects: %d; \n", page_res_it.page_res->char_count, page_res_it.page_res->rej_count);
    }
    #endif

    /* Walk blocks testing for block rejection */
    page_res_it.restart_page ();
    while (page_res_it.word () != NULL)
    {
      current_block = page_res_it.block();
      block_no = current_block->block->index();

      if ((page_res_it.block ()->char_count > 0) && ((page_res_it.block ()->rej_count * 100.0 / page_res_it.block ()->char_count) > tessedit_reject_block_percent))
      {
        #ifndef SECURE_NAMES
        if (tessedit_debug_block_rejection)
        {
          tprintf ("REJECTING BLOCK %d  #chars: %d;  #Rejects: %d\n", block_no, page_res_it.block ()->char_count, page_res_it.block ()->rej_count);
        }
        #endif
        prev_word_rejected = FALSE;
        while ((page_res_it.word () != NULL) && (page_res_it.block () == current_block))
        {
            if (tessedit_preserve_blk_rej_perfect_wds)
            {
            rej_word = (page_res_it.word ()->reject_map.reject_count () > 0) || (page_res_it.word ()->reject_map.length () < tessedit_preserve_min_wd_len);

            if (rej_word && tessedit_dont_blkrej_good_wds && !(page_res_it.word ()->reject_map.length () < tessedit_preserve_min_wd_len) &&
                (acceptable_word_string(page_res_it.word()->best_choice->unichar_string().string(), page_res_it.word ()->best_choice->unichar_lengths().string()) != AC_UNACCEPTABLE))
            {
              word_char_quality(page_res_it.word(), page_res_it.row()->row, &char_quality, &accepted_char_quality);
              rej_word = char_quality != page_res_it.word ()->reject_map.length ();
            }
          }
          else
            rej_word = TRUE;

          if (rej_word)
          {
            /*
              Reject spacing if both current and prev words are rejected.
              NOTE - this is NOT restricted to FUZZY spaces. - When tried this
              generated more space errors.
            */
            if (tessedit_use_reject_spaces && prev_word_rejected && (page_res_it.prev_row () == page_res_it.row ()) && (page_res_it.word ()->word->space () == 1))
            {
              page_res_it.word ()->reject_spaces = TRUE;
            }

            page_res_it.word ()->reject_map.rej_word_block_rej ();
          }

          prev_word_rejected = rej_word;
          page_res_it.forward ();
        }
      }
      else
      {
        #ifndef SECURE_NAMES
        if (tessedit_debug_block_rejection)
          tprintf("NOT REJECTING BLOCK %d #chars: %d  # Rejects: %d; \n", block_no, page_res_it.block ()->char_count, page_res_it.block ()->rej_count);
        #endif

        /* Walk rows in block testing for row rejection */
        row_no = 0;
        while ((page_res_it.word () != NULL) && (page_res_it.block () == current_block))
        {
          current_row = page_res_it.row ();
          row_no++;

          /* Reject whole row if:
            fraction of chars on row which are rejected exceed a limit AND
            fraction rejects which occur in WHOLE WERD rejects is LESS THAN a
            limit
          */
          if ((page_res_it.row ()->char_count > 0) && ((page_res_it.row ()->rej_count * 100.0 / page_res_it.row ()->char_count) > tessedit_reject_row_percent) &&
            ((page_res_it.row ()->whole_word_rej_count * 100.0 / page_res_it.row ()->rej_count) < tessedit_whole_wd_rej_row_percent))
          {
            #ifndef SECURE_NAMES
            if (tessedit_debug_block_rejection)
            {
              tprintf("REJECTING ROW %d  #chars: %d;  #Rejects: %d\n", row_no, page_res_it.row ()->char_count, page_res_it.row ()->rej_count);
            }
            #endif
            prev_word_rejected = FALSE;

            while ((page_res_it.word () != NULL) && (page_res_it.row () == current_row))
            {
              /* Preserve words on good docs unless they are mostly rejected*/
              if (!tessedit_row_rej_good_docs && good_quality_doc)
              {
                rej_word = page_res_it.word ()->reject_map.reject_count () / (float) page_res_it.word ()->reject_map. length () > tessedit_good_doc_still_rowrej_wd;
              }
              else if (tessedit_preserve_row_rej_perfect_wds) /* Preserve perfect words anyway */
              {
                rej_word = (page_res_it.word ()->reject_map.reject_count () > 0) || (page_res_it.word ()->reject_map. length () < tessedit_preserve_min_wd_len);

                if (rej_word && tessedit_dont_rowrej_good_wds && !(page_res_it.word ()->reject_map. length () < tessedit_preserve_min_wd_len) &&
                  (acceptable_word_string(page_res_it.word ()->best_choice->unichar_string().string(), page_res_it.word ()->best_choice-> unichar_lengths().string()) != AC_UNACCEPTABLE))
                {
                  word_char_quality(page_res_it.word(), page_res_it.row()->row, &char_quality, &accepted_char_quality);
                  rej_word = char_quality != page_res_it.word ()->reject_map.length ();
                }
              }
              else
                rej_word = TRUE;

              if (rej_word)
              {
                /*
                  Reject spacing if both current and prev words are rejected.
                  NOTE - this is NOT restricted to FUZZY spaces. - When tried
                  this generated more space errors.
                */
                if (tessedit_use_reject_spaces && prev_word_rejected && (page_res_it.prev_row () == page_res_it.row ()) && (page_res_it.word ()->word->space () == 1))
                {
                  page_res_it.word ()->reject_spaces = TRUE;
                }

                page_res_it.word ()->reject_map.rej_word_row_rej();
              }

              prev_word_rejected = rej_word;
              page_res_it.forward ();
            }
          }
          else
          {
            #ifndef SECURE_NAMES
            if (tessedit_debug_block_rejection)
            {
              tprintf("NOT REJECTING ROW %d #chars: %d  # Rejects: %d; \n", row_no, page_res_it.row ()->char_count, page_res_it.row ()->rej_count);
            }
            #endif
            while ((page_res_it.word () != NULL) && (page_res_it.row () == current_row))
            {
              page_res_it.forward ();
            }
          }
        }
      }
    }
  }
}


/*************************************************************************
 * reject_whole_page()
 * Dont believe any of it - set the reject map to 00..00 in all words
 *
 *************************************************************************/

void reject_whole_page(PAGE_RES_IT &page_res_it)
{
  page_res_it.restart_page ();
  while (page_res_it.word () != NULL)
  {
    page_res_it.word ()->reject_map.rej_word_doc_rej ();
    page_res_it.forward ();
  }

  //whole page is rejected
  page_res_it.page_res->rejected = TRUE;
}

    void Tesseract::tilde_crunch(PAGE_RES_IT &page_res_it)
    {
      WERD_RES *word;
      GARBAGE_LEVEL garbage_level;
      PAGE_RES_IT copy_it;
      BOOL8 prev_potential_marked = FALSE;
      BOOL8 found_terrible_word = FALSE;
      BOOL8 ok_dict_word;

      page_res_it.restart_page ();
      while (page_res_it.word () != NULL)
      {
        word = page_res_it.word ();

        if (crunch_early_convert_bad_unlv_chs)
        {
          convert_bad_unlv_chs(word);
        }

        if (crunch_early_merge_tess_fails)
        {
          merge_tess_fails(word);
        }

        if (word->reject_map.accept_count () != 0)
        {
          found_terrible_word = FALSE;

          //Forget earlier potential crunches
          prev_potential_marked = FALSE;
        }
        else
        {
          ok_dict_word = safe_dict_word(*(word->best_choice));
          garbage_level = garbage_word (word, ok_dict_word);

          if ((garbage_level != G_NEVER_CRUNCH) && (terrible_word_crunch (word, garbage_level)))
          {
            if (crunch_debug > 0)
            {
              tprintf ("T CRUNCHING: \"%s\"\n", word->best_choice->unichar_string().string());
            }
            word->unlv_crunch_mode = CR_KEEP_SPACE;

            if (prev_potential_marked)
            {
              while (copy_it.word () != word)
              {
                if (crunch_debug > 0)
                {
                  tprintf ("P1 CRUNCHING: \"%s\"\n", copy_it.word()->best_choice->unichar_string().string());
                }

                copy_it.word ()->unlv_crunch_mode = CR_KEEP_SPACE;
                copy_it.forward ();
              }

              prev_potential_marked = FALSE;
            }

            found_terrible_word = TRUE;
          }
          else if ((garbage_level != G_NEVER_CRUNCH) && (potential_word_crunch (word, garbage_level, ok_dict_word)))
          {
            if (found_terrible_word)
            {
              if (crunch_debug > 0)
              {
                tprintf ("P2 CRUNCHING: \"%s\"\n", word->best_choice->unichar_string().string());
              }

              word->unlv_crunch_mode = CR_KEEP_SPACE;
            }
            else if (!prev_potential_marked)
            {
              copy_it = page_res_it;
              prev_potential_marked = TRUE;

              if (crunch_debug > 1)
              {
                tprintf ("P3 CRUNCHING: \"%s\"\n", word->best_choice->unichar_string().string());
              }
            }
          }
          else
          {
            found_terrible_word = FALSE;

            //Forget earlier potential crunches
            prev_potential_marked = FALSE;

            if (crunch_debug > 2)
            {
              tprintf ("NO CRUNCH: \"%s\"\n", word->best_choice->unichar_string().string());
            }
          }
        }

        page_res_it.forward ();
      }
    }

BOOL8 terrible_word_crunch(WERD_RES *word, GARBAGE_LEVEL garbage_level)
{
  float rating_per_ch;
  int adjusted_len;
  int crunch_mode = 0;

  if ((word->best_choice->unichar_string().length () == 0) ||
          (strspn(word->best_choice->unichar_string().string(), " ") == (size_t)word->best_choice->unichar_string().length ()))
  {
    crunch_mode = 1;
  }
  else
  {
    adjusted_len = word->reject_map.length ();

    if (adjusted_len > crunch_rating_max)
    {
      adjusted_len = crunch_rating_max;
    }
    rating_per_ch = word->best_choice->rating () / adjusted_len;

    if (rating_per_ch > crunch_terrible_rating)
    {
      crunch_mode = 2;
    }
    else if (crunch_terrible_garbage && (garbage_level == G_TERRIBLE))
    {
      crunch_mode = 3;
    }
    else if ((word->best_choice->certainty () < crunch_poor_garbage_cert) && (garbage_level != G_OK))
    {
      crunch_mode = 4;
    }
    else if ((rating_per_ch > crunch_poor_garbage_rate) && (garbage_level != G_OK))
    {
      crunch_mode = 5;
    }
  }

  if (crunch_mode > 0)
  {
    if (crunch_debug > 2)
    {
      tprintf ("Terrible_word_crunch (%d) on \"%s\"\n", crunch_mode, word->best_choice->unichar_string().string());
    }

    return TRUE;
  }
  else
  {
    return FALSE;
  }
}

    BOOL8 Tesseract::potential_word_crunch(WERD_RES *word, GARBAGE_LEVEL garbage_level, BOOL8 ok_dict_word)
    {
      float rating_per_ch;
      int adjusted_len;
      const char *str = word->best_choice->unichar_string().string();
      const char *lengths = word->best_choice->unichar_lengths().string();
      BOOL8 word_crunchable;
      int poor_indicator_count = 0;

      word_crunchable = !crunch_leave_accept_strings || (word->reject_map.length () < 3) ||
                        ((acceptable_word_string (str, lengths) == AC_UNACCEPTABLE) && !ok_dict_word);

      adjusted_len = word->reject_map.length ();

      if (adjusted_len > 10)
      {
        adjusted_len = 10;
      }

      rating_per_ch = word->best_choice->rating () / adjusted_len;

      if (rating_per_ch > crunch_pot_poor_rate)
      {
        if (crunch_debug > 2)
        {
          tprintf ("Potential poor rating on \"%s\"\n", word->best_choice->unichar_string().string());
        }

        poor_indicator_count++;
      }

      if (word_crunchable && (word->best_choice->certainty () < crunch_pot_poor_cert))
      {
        if (crunch_debug > 2)
        {
          tprintf ("Potential poor cert on \"%s\"\n", word->best_choice->unichar_string().string());
        }

        poor_indicator_count++;
      }

      if (garbage_level != G_OK)
      {
        if (crunch_debug > 2)
        {
          tprintf ("Potential garbage on \"%s\"\n", word->best_choice->unichar_string().string());
        }

        poor_indicator_count++;
      }

      return (poor_indicator_count >= crunch_pot_indicators);
    }

void Tesseract::tilde_delete(PAGE_RES_IT &page_res_it)
{
  WERD_RES *word;
  PAGE_RES_IT copy_it;
  BOOL8 deleting_from_bol = FALSE;
  BOOL8 marked_delete_point = FALSE;
  inT16 debug_delete_mode;
  CRUNCH_MODE delete_mode;
  inT16 x_debug_delete_mode;
  CRUNCH_MODE x_delete_mode;

  page_res_it.restart_page ();

  while (page_res_it.word () != NULL)
  {
    word = page_res_it.word ();

    delete_mode = word_deletable (word, debug_delete_mode);

    if (delete_mode != CR_NONE)
    {
      if (word->word->flag (W_BOL) || deleting_from_bol)
      {
        if (crunch_debug > 0)
        {
          tprintf ("BOL CRUNCH DELETING(%d): \"%s\"\n", debug_delete_mode, word->best_choice->unichar_string().string());
        }
        word->unlv_crunch_mode = delete_mode;
        deleting_from_bol = TRUE;
      }
      else if (word->word->flag (W_EOL))
      {
        if (marked_delete_point)
        {
          while (copy_it.word () != word)
          {
            x_delete_mode = word_deletable (copy_it.word (), x_debug_delete_mode);
            if (crunch_debug > 0)
            {
              tprintf ("EOL CRUNCH DELETING(%d): \"%s\"\n", x_debug_delete_mode, copy_it.word()->best_choice->unichar_string().string());
            }

            copy_it.word ()->unlv_crunch_mode = x_delete_mode;
            copy_it.forward ();
          }
        }

        if (crunch_debug > 0)
        {
          tprintf ("EOL CRUNCH DELETING(%d): \"%s\"\n", debug_delete_mode, word->best_choice->unichar_string().string());
        }

        word->unlv_crunch_mode = delete_mode;
        deleting_from_bol = FALSE;
        marked_delete_point = FALSE;
      }
      else
      {
        if (!marked_delete_point)
        {
          copy_it = page_res_it;
          marked_delete_point = TRUE;
        }
      }
    }
    else
    {
      deleting_from_bol = FALSE;

      //Forget earlier potential crunches
      marked_delete_point = FALSE;
    }

    /*
      The following step has been left till now as the tess fails are used to
      determine if the word is deletable.
    */
    if (!crunch_early_merge_tess_fails)
    {
      merge_tess_fails(word);
    }

    page_res_it.forward ();
  }
}


void Tesseract::convert_bad_unlv_chs(WERD_RES *word_res)
{
  int i;
  UNICHAR_ID unichar_dash = unicharset.unichar_to_id("-");
  UNICHAR_ID unichar_space = unicharset.unichar_to_id(" ");
  UNICHAR_ID unichar_tilde = unicharset.unichar_to_id("~");
  UNICHAR_ID unichar_pow = unicharset.unichar_to_id("^");
  bool modified = false;

  for (i = 0; i < word_res->reject_map.length(); ++i)
  {
    if (word_res->best_choice->unichar_id(i) == unichar_tilde)
    {
      word_res->best_choice->set_unichar_id(unichar_dash, i);
      modified = true;

      if (word_res->reject_map[i].accepted ())
      {
        word_res->reject_map[i].setrej_unlv_rej ();
      }
    }

    if (word_res->best_choice->unichar_id(i) == unichar_pow)
    {
      word_res->best_choice->set_unichar_id(unichar_space, i);
      modified = true;

      if (word_res->reject_map[i].accepted ())
      {
        word_res->reject_map[i].setrej_unlv_rej ();
      }
    }
  }

  if (modified)
  {
    word_res->best_choice->populate_unichars(unicharset);
  }
}

// Change pairs of tess failures to a single one
void Tesseract::merge_tess_fails(WERD_RES *word_res)
{
  PBLOB_IT blob_it;              //blobs
  int len = word_res->best_choice->length();
  bool modified = false;

  ASSERT_HOST (word_res->reject_map.length () == len);
  ASSERT_HOST (word_res->outword->blob_list ()->length () == len);

  UNICHAR_ID unichar_space = unicharset.unichar_to_id(" ");
  blob_it = word_res->outword->blob_list ();
  int i = 0;

  while (i < word_res->best_choice->length()-1)
  {
    if ((word_res->best_choice->unichar_id(i) == unichar_space) && (word_res->best_choice->unichar_id(i+1) == unichar_space))
    {
      modified = true;
      word_res->best_choice->remove_unichar_id(i);
      word_res->reject_map.remove_pos (i);
      merge_blobs (blob_it.data_relative (1), blob_it.data ());
      delete blob_it.extract (); //get rid of spare
    }
    else
    {
      i++;
    }

    blob_it.forward ();
  }

  len = word_res->best_choice->length();
  ASSERT_HOST (word_res->reject_map.length () == len);
  ASSERT_HOST (word_res->outword->blob_list ()->length () == len);

  if (modified)
  {
    word_res->best_choice->populate_unichars(unicharset);
  }
}

GARBAGE_LEVEL Tesseract::garbage_word(WERD_RES *word, BOOL8 ok_dict_word)
{
  enum STATES
  {
    JUNK,
    FIRST_UPPER,
    FIRST_LOWER,
    FIRST_NUM,
    SUBSEQUENT_UPPER,
    SUBSEQUENT_LOWER,
    SUBSEQUENT_NUM
  };

  const char *str = word->best_choice->unichar_string().string();
  const char *lengths = word->best_choice->unichar_lengths().string();
  STATES state = JUNK;
  int len = 0;
  int isolated_digits = 0;
  int isolated_alphas = 0;
  int bad_char_count = 0;
  int tess_rejs = 0;
  int dodgy_chars = 0;
  int ok_chars;
  UNICHAR_ID last_char = -1;
  int alpha_repetition_count = 0;
  int longest_alpha_repetition_count = 0;
  int longest_lower_run_len = 0;
  int lower_string_count = 0;
  int longest_upper_run_len = 0;
  int upper_string_count = 0;
  int total_alpha_count = 0;
  int total_digit_count = 0;

  for (; *str != '\0'; str += *(lengths++))
  {
    len++;
    if (unicharset.get_isupper (str, *lengths))
    {
      total_alpha_count++;
      switch (state)
      {
        case SUBSEQUENT_UPPER:
        case FIRST_UPPER:
          state = SUBSEQUENT_UPPER;
          upper_string_count++;
          if (longest_upper_run_len < upper_string_count)
          {
            longest_upper_run_len = upper_string_count;
          }

          if (last_char == unicharset.unichar_to_id(str, *lengths))
          {
            alpha_repetition_count++;
            if (longest_alpha_repetition_count < alpha_repetition_count)
            {
              longest_alpha_repetition_count = alpha_repetition_count;
            }
          }
          else
          {
            last_char = unicharset.unichar_to_id(str, *lengths);
            alpha_repetition_count = 1;
          }
          break;
        case FIRST_NUM:
          isolated_digits++;
        default:
          state = FIRST_UPPER;
          last_char = unicharset.unichar_to_id(str, *lengths);
          alpha_repetition_count = 1;
          upper_string_count = 1;
          break;
      }
    }
    else if (unicharset.get_islower (str, *lengths))
    {
      total_alpha_count++;
      switch (state)
      {
        case SUBSEQUENT_LOWER:
        case FIRST_LOWER:
          state = SUBSEQUENT_LOWER;
          lower_string_count++;

          if (longest_lower_run_len < lower_string_count)
          {
            longest_lower_run_len = lower_string_count;
          }

          if (last_char == unicharset.unichar_to_id(str, *lengths))
          {
            alpha_repetition_count++;
            if (longest_alpha_repetition_count < alpha_repetition_count)
            {
              longest_alpha_repetition_count = alpha_repetition_count;
            }
          }
          else
          {
            last_char = unicharset.unichar_to_id(str, *lengths);
            alpha_repetition_count = 1;
          }
          break;
        case FIRST_NUM:
          isolated_digits++;
        default:
          state = FIRST_LOWER;
          last_char = unicharset.unichar_to_id(str, *lengths);
          alpha_repetition_count = 1;
          lower_string_count = 1;
          break;
      }
    }
    else if (unicharset.get_isdigit (str, *lengths))
    {
      total_digit_count++;
      switch (state)
      {
        case FIRST_NUM:
          state = SUBSEQUENT_NUM;
        case SUBSEQUENT_NUM:
          break;
        case FIRST_UPPER:
        case FIRST_LOWER:
          isolated_alphas++;
        default:
          state = FIRST_NUM;
          break;
      }
    }
    else
    {
      if (*lengths == 1 && *str == ' ')
      {
        tess_rejs++;
      }
      else
      {
        bad_char_count++;
      }

      switch (state)
      {
        case FIRST_NUM:
          isolated_digits++;
          break;
        case FIRST_UPPER:
        case FIRST_LOWER:
          isolated_alphas++;
        default:
          break;
      }
      state = JUNK;
    }
  }

  switch (state)
  {
    case FIRST_NUM:
      isolated_digits++;
      break;
    case FIRST_UPPER:
    case FIRST_LOWER:
      isolated_alphas++;
    default:
      break;
  }

  if (crunch_include_numerals)
  {
    total_alpha_count += total_digit_count - isolated_digits;
  }

  if (crunch_leave_ok_strings && (len >= 4) && (2 * (total_alpha_count - isolated_alphas) > len) && (longest_alpha_repetition_count < crunch_long_repetitions))
  {
    if ((crunch_accept_ok && (acceptable_word_string (str, lengths) != AC_UNACCEPTABLE)) ||
            (longest_lower_run_len > crunch_leave_lc_strings) || (longest_upper_run_len > crunch_leave_uc_strings))
    {
      return G_NEVER_CRUNCH;
    }
  }

  if ((word->reject_map.length () > 1) && (strpbrk (str, " ") == NULL) &&
    ((word->best_choice->permuter () == SYSTEM_DAWG_PERM) ||
    (word->best_choice->permuter () == FREQ_DAWG_PERM) ||
    (word->best_choice->permuter () == USER_DAWG_PERM) ||
    (word->best_choice->permuter () == NUMBER_PERM) ||
    (acceptable_word_string (str, lengths) != AC_UNACCEPTABLE) || ok_dict_word))
  {
    return G_OK;
  }

  ok_chars = len - bad_char_count - isolated_digits - isolated_alphas - tess_rejs;

  if (crunch_debug > 3)
  {
    tprintf("garbage_word: \"%s\"\n", word->best_choice->unichar_string().string());
    tprintf("LEN: %d  bad: %d  iso_N: %d  iso_A: %d  rej: %d\n", len, bad_char_count, isolated_digits, isolated_alphas, tess_rejs);
  }

  if ((bad_char_count == 0) && (tess_rejs == 0) && ((len > isolated_digits + isolated_alphas) || (len <= 2)))
  {
    return G_OK;
  }

  if ((tess_rejs > ok_chars) || ((tess_rejs > 0) && ((bad_char_count + tess_rejs) * 2 > len)))
  {
    return G_TERRIBLE;
  }

  if (len > 4)
  {
    dodgy_chars = 2 * tess_rejs + bad_char_count + isolated_digits + isolated_alphas;

    if ((dodgy_chars > 5) || ((dodgy_chars / (float) len) > 0.5))
    {
      return G_DODGY;
    }
    else
    {
      return G_OK;
    }
  }
  else
  {
    dodgy_chars = 2 * tess_rejs + bad_char_count;

    if (((len == 4) && (dodgy_chars > 2)) || ((len == 3) && (dodgy_chars > 2)) || (dodgy_chars >= len))
    {
      return G_DODGY;
    }
    else
    {
      return G_OK;
    }
  }
}


/*************************************************************************
 * word_deletable()
 *     DELETE WERDS AT ENDS OF ROWS IF
 *        Word is crunched &&
 *        ( string length = 0                                          OR
 *          > 50% of chars are "|" (before merging)                    OR
 *          certainty < -10                                            OR
 *          rating /char > 60                                          OR
 *          TOP of word is more than 0.5 xht BELOW baseline            OR
 *          BOTTOM of word is more than 0.5 xht ABOVE xht              OR
 *          length of word < 3xht                                      OR
 *          height of word < 0.7 xht                                   OR
 *          height of word > 3.0 xht                                   OR
 *          >75% of the outline BBs have longest dimension < 0.5xht
 *************************************************************************/

CRUNCH_MODE word_deletable(WERD_RES *word, inT16 &delete_mode)
{
  int word_len = word->reject_map.length ();
  float rating_per_ch;
  TBOX box;                       //BB of word

  if (word->unlv_crunch_mode == CR_NONE)
  {
    delete_mode = 0;
    return CR_NONE;
  }

  if (word_len == 0)
  {
    delete_mode = 1;
    return CR_DELETE;
  }

  box = word->outword->bounding_box ();
  if (box.height () < crunch_del_min_ht * bln_x_height)
  {
    delete_mode = 4;
    return CR_DELETE;
  }

  if (noise_outlines (word->outword))
  {
    delete_mode = 5;
    return CR_DELETE;
  }

  if ((failure_count (word) * 1.5) > word_len)
  {
    delete_mode = 2;
    return CR_LOOSE_SPACE;
  }

  if (word->best_choice->certainty () < crunch_del_cert)
  {
    delete_mode = 7;
    return CR_LOOSE_SPACE;
  }

  rating_per_ch = word->best_choice->rating () / word_len;

  if (rating_per_ch > crunch_del_rating)
  {
    delete_mode = 8;
    return CR_LOOSE_SPACE;
  }

  if (box.top () < bln_baseline_offset - crunch_del_low_word * bln_x_height)
  {
    delete_mode = 9;
    return CR_LOOSE_SPACE;
  }

  if (box.bottom () > bln_baseline_offset + crunch_del_high_word * bln_x_height)
  {
    delete_mode = 10;
    return CR_LOOSE_SPACE;
  }

  if (box.height () > crunch_del_max_ht * bln_x_height)
  {
    delete_mode = 11;
    return CR_LOOSE_SPACE;
  }

  if (box.width () < crunch_del_min_width * bln_x_height)
  {
    delete_mode = 3;
    return CR_LOOSE_SPACE;
  }

  delete_mode = 0;
  return CR_NONE;
}

inT16 failure_count(WERD_RES *word)
{
  const char *str = word->best_choice->unichar_string().string();
  int tess_rejs = 0;

  for (; *str != '\0'; str++)
  {
    if (*str == ' ')
    {
      tess_rejs++;
    }
  }

  return tess_rejs;
}

BOOL8 noise_outlines(WERD *word)
{
  PBLOB_IT blob_it;
  OUTLINE_IT outline_it;
  TBOX box;                       //BB of outline
  inT16 outline_count = 0;
  inT16 small_outline_count = 0;
  inT16 max_dimension;
  float small_limit = bln_x_height * crunch_small_outlines_size;

  blob_it.set_to_list(word->blob_list());

  for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward())
  {
    outline_it.set_to_list (blob_it.data()->out_list());
    for (outline_it.mark_cycle_pt(); !outline_it.cycled_list(); outline_it.forward())
    {
      outline_count++;
      box = outline_it.data ()->bounding_box();

      if (box.height() > box.width())
      {
        max_dimension = box.height ();
      }
      else
      {
        max_dimension = box.width ();
      }

      if (max_dimension < small_limit)
      {
        small_outline_count++;
      }
    }
  }

  return (small_outline_count >= outline_count);
}


/*************************************************************************
 * insert_rej_cblobs()
 * Put rejected word blobs back into the outword.
 * NOTE!!! AFTER THIS THE CHOICES LIST WILL NOT HAVE THE CORRECT NUMBER
 * OF ELEMENTS.
 *************************************************************************/
void Tesseract::insert_rej_cblobs(WERD_RES *word)
{
  PBLOB_IT blob_it;              //blob iterator
  PBLOB_IT rej_blob_it;
  const STRING *word_str;
  const STRING *word_lengths;
  int old_len;
  int rej_len;
  char new_str[512 * UNICHAR_LEN];
  char new_lengths[512];
  REJMAP new_map;
  int i = 0;                     //new_str index
  int j = 0;                     //old_str index
  int i_offset = 0;              //new_str offset
  int j_offset = 0;              //old_str offset
  int new_len;

  gblob_sort_list (word->outword->rej_blob_list (), TRUE);
  rej_blob_it.set_to_list (word->outword->rej_blob_list ());

  if (rej_blob_it.empty())
  {
    return;
  }

  rej_len = rej_blob_it.length();
  blob_it.set_to_list(word->outword->blob_list());
  word_str = &(word->best_choice->unichar_string());
  word_lengths = &(word->best_choice->unichar_lengths());
  old_len = word->best_choice->length();
  ASSERT_HOST (word->reject_map.length() == old_len);
  ASSERT_HOST (blob_it.length () == old_len);

  if ((old_len + rej_len) > 511)
  {
    return;                      //Word is garbage anyway prevent abort
  }
  new_map.initialise (old_len + rej_len);

  while (!rej_blob_it.empty())
  {
    if ((j >= old_len) || (rej_blob_it.data ()->bounding_box ().left () <= blob_it.data ()->bounding_box ().left ()))
    {
      /* Insert reject blob */
      if (j >= old_len)
      {
        blob_it.add_to_end (rej_blob_it.extract ());
      }
      else
      {
        blob_it.add_before_stay_put (rej_blob_it.extract ());
      }

      if (!rej_blob_it.empty())
      {
        rej_blob_it.forward ();
      }

      new_str[i_offset] = ' ';
      new_lengths[i] = 1;
      new_map[i].setrej_rej_cblob();
      i_offset += new_lengths[i++];
    }
    else
    {
      strncpy(new_str + i_offset, &(*word_str)[j_offset], (*word_lengths)[j]);
      new_lengths[i] = (*word_lengths)[j];
      new_map[i] = word->reject_map[j];
      i_offset += new_lengths[i++];
      j_offset += (*word_lengths)[j++];
      blob_it.forward ();
    }
  }

  /* Add any extra normal blobs to strings */
  while (j < word_lengths->length())
  {
    strncpy(new_str + i_offset, &(*word_str)[j_offset], (*word_lengths)[j]);
    new_lengths[i] = (*word_lengths)[j];
    new_map[i] = word->reject_map[j];
    i_offset += new_lengths[i++];
    j_offset += (*word_lengths)[j++];
  }

  new_str[i_offset] = '\0';
  new_lengths[i] = 0;

  /*
    tprintf(
          "\nOld len %d; New len %d; New str \"%s\"; New map \"%s\"\n",
          old_len, i, new_str, new_map );
  */
  ASSERT_HOST (i == blob_it.length ());
  ASSERT_HOST (i == old_len + rej_len);
  word->reject_map = new_map;

  // Update word->best_choice if needed.
  if (strcmp(new_str, word->best_choice->unichar_string().string()) != 0 ||
      strcmp(new_lengths, word->best_choice->unichar_lengths().string()) != 0)
  {
    WERD_CHOICE *new_choice = new WERD_CHOICE(new_str, new_lengths, word->best_choice->rating(), word->best_choice->certainty(),
                                              word->best_choice->permuter(), getDict().getUnicharset());

   new_choice->populate_unichars(getDict().getUnicharset());
   delete word->best_choice;
   word->best_choice = new_choice;
  }

  new_len = word->best_choice->length();
  ASSERT_HOST (word->reject_map.length () == new_len);
  ASSERT_HOST (word->outword->blob_list ()->length () == new_len);

}
/////////////////////////////////////////////////////////////////docqual////////////////////////////////////////

/////////////////////////////////////////////////////////////////tally////////////////////////////////////////
/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**********************************************************************
 * new_tally
 *
 * Create a new tally record and initialize it.
 **********************************************************************/
TALLY new_tally(int num_buckets) {
  TALLY t;
  int x;

  t = (TALLY) memalloc ((num_buckets + 2) * sizeof (int));
  t->count = 0;
  t->num_buckets = num_buckets;

  iterate_tally (t, x) tally_entry (t, x) = 0;

  return (t);
}


/**********************************************************************
 * print_tally
 *
 * Print the results of a given tally.
 **********************************************************************/
void print_tally(FILE *file, const char *string, TALLY t)
{
  Q_UNUSED(file);
  int x;

  cprintf ("%d %s buckets\n", t->num_buckets, string);
  cprintf ("%d samples in %s\n", t->count, string);

  iterate_tally (t, x)
    cprintf ("   %s [%d] = %d\n", string, x, tally_entry (t, x));
  cprintf ("\n");
}
/////////////////////////////////////////////////////////////////tally////////////////////////////////////////

/////////////////////////////////////////////////////////////////associate////////////////////////////////////////
extern TBLOB *newblob();

/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/

BOOL_VAR(wordrec_enable_assoc, 1, "Associator Enable");
BOOL_VAR(force_word_assoc, FALSE, "always force associator to run, "
         "independent of what enable_assoc is." "This is used for CJK where component grouping is necessary.");

EVALUATION_ARRAY last_segmentation;

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/

/**********************************************************************
 * print_eval_record
 **********************************************************************/
void print_eval_record(const char *label, EVALUATION_RECORD *rec)
{
    if (rec)
    {
        cprintf ("%s: r%.2f c%.2f width=%d gap=%d\n", label, rec->match, rec->certainty, rec->width, rec->gap);
    }
}
/////////////////////////////////////////////////////////////////associate////////////////////////////////////////

/////////////////////////////////////////////////////////////////closed////////////////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
#define TABLE_SIZE 2000
HASH_TABLE global_hash = NULL;

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**
 * @name hash_add
 *
 * Look in the hash table for a particular value. If it is not there
 * then add it.
 */
int hash_add(HASH_TABLE state_table, STATE *state) {
  int x;
  int i = 0;
  int table_limit = TABLE_SIZE;

  x = state->part2 % table_limit;
  while (i < table_limit) {
    assert (0 <= x && x < table_limit);
    /* Found it */
    if ((state_table[x].part2 == state->part2) &&
    (state_table[x].part1 == state->part1)) {
      return (FALSE);
    }
    /* Not in table */
    else if ((int)state_table[x].part1 == NO_STATE) {
      state_table[x].part2 = state->part2;
      state_table[x].part1 = state->part1;
      return (TRUE);
    }
    i++;
    if (++x >= table_limit)
      x = 0;
  }
  cprintf("warning: hash table is full");

  abort();
  return 0;
}


/**
 * @name hash_lookup
 *
 * Look in the hash table for a particular value. If the value is there
 * then return TRUE, FALSE otherwise.
 */
int hash_lookup(HASH_TABLE state_table, STATE *state) {
  int x;
  int i = 0;
  int table_limit = TABLE_SIZE;

  x = state->part2 % table_limit;
  while (i < table_limit) {
    assert (0 <= x && x < table_limit);
    /* Found it */
    if ((state_table[x].part2 == state->part2) &&
    (state_table[x].part1 == state->part1)) {
      return (TRUE);
    }
    /* Not in table */
    else if ((int)state_table[x].part1 == NO_STATE) {
      return (FALSE);
    }

    i++;
    if (++x >= table_limit)
      x = 0;
  }
  cprintf ("warning: fell off end of hash table  (%x) %x\n",
    state->part2, state->part2 % table_limit);
  abort();
  return 0;
}


/**
 * @name new_hash_table
 *
 * Create and initialize a hash table.
 */
HASH_TABLE new_hash_table() {
  HASH_TABLE ht;
  int x;

  if (global_hash == NULL)
    ht = (HASH_TABLE) memalloc (TABLE_SIZE * sizeof (STATE));
  else
    ht = global_hash;

  for (x = 0; x < TABLE_SIZE; x++) {
    ht[x].part1 = NO_STATE;
    ht[x].part2 = NO_STATE;
  }
  return (ht);
}
/////////////////////////////////////////////////////////////////closed////////////////////////////////////////

/////////////////////////////////////////////////////////////////render////////////////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
ScrollView *blob_window = NULL;

C_COL color_list[] = {
  Red, Cyan, Yellow, Blue, Green, White
};

BOOL_VAR(wordrec_display_all_blobs, 0, "Display Blobs");

BOOL_VAR(wordrec_display_all_words, 0, "Display Words");

BOOL_VAR(wordrec_blob_pause, 0, "Blob pause");

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**********************************************************************
 * display_blob
 *
 * Macro to display blob in a window.
 **********************************************************************/
void display_blob(TBLOB *blob, C_COL color) {
  /* Size of drawable */
  if (blob_window == NULL) {
    blob_window = c_create_window ("Blobs", 520, 10,
      500, 256, -1000.0, 1000.0, 0.0, 256.0);
  }
  else {
    c_clear_window(blob_window);
  }

  render_blob(blob_window, blob, color);
}

/**********************************************************************
 * render_blob
 *
 * Create a list of line segments that represent the expanded outline
 * that was supplied as input.
 **********************************************************************/
void render_blob(void *window, TBLOB *blob, C_COL color) {
  /* No outline */
  if (!blob)
    return;

  render_outline (window, blob->outlines, color);
}


/**********************************************************************
 * render_edgepts
 *
 * Create a list of line segments that represent the expanded outline
 * that was supplied as input.
 **********************************************************************/
void render_edgepts(void *window, EDGEPT *edgept, C_COL color) {
  float x = edgept->pos.x;
  float y = edgept->pos.y;
  EDGEPT *this_edge = edgept;

  if (!edgept)
    return;

  c_line_color_index(window, color);
  c_move(window, x, y);
  do {
    this_edge = this_edge->next;
    x = this_edge->pos.x;
    y = this_edge->pos.y;
    c_draw(window, x, y);
  }
  while (edgept != this_edge);
}


/**********************************************************************
 * render_outline
 *
 * Create a list of line segments that represent the expanded outline
 * that was supplied as input.
 **********************************************************************/
void render_outline(void *window,
                    TESSLINE *outline,
                    C_COL color) {
  /* No outline */
  if (!outline)
    return;
  /* Draw Compact outline */
  if (outline->loop)
    render_edgepts (window, outline->loop, color);
  /* Add on next outlines */
  render_outline (window, outline->next, color);

  /* Add on child outlines */
  render_outline(window, outline->child, Grey);
}
/////////////////////////////////////////////////////////////////render////////////////////////////////////////

/////////////////////////////////////////////////////////////////plotseg////////////////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
ScrollView *segm_window = NULL;

INT_VAR(wordrec_display_segmentations, 0, "Display Segmentations");

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**********************************************************************
 * display_segmentation
 *
 * Display all the words on the page into a window.
 **********************************************************************/
void display_segmentation(TBLOB *chunks, SEARCH_STATE segmentation) {
  /* If no window create it */
  if (segm_window == NULL) {
    segm_window = c_create_window ("Segmentation", 5, 10,
      500, 256, -1000.0, 1000.0, 0.0, 256.0);
  }
  else {
    c_clear_window(segm_window);
  }

  render_segmentation(segm_window, chunks, segmentation);
  /* Put data in the window */
  c_make_current(segm_window);
}

/**********************************************************************
 * render_segmentation
 *
 * Create a list of line segments that represent the list of chunks
 * using the correct segmentation that was supplied as input.
 **********************************************************************/
void render_segmentation(ScrollView *window,
                         TBLOB *chunks,
                         SEARCH_STATE segmentation) {
  TBLOB *blob;
  C_COL color = Black;
  int char_num = -1;
  int chunks_left = 0;

  TPOINT topleft;
  TPOINT botright;

  // Find bounding box.
  blobs_bounding_box(chunks, &topleft, &botright);

  iterate_blobs(blob, chunks) {

    if (chunks_left-- == 0) {
      color = color_list[++char_num % NUM_COLORS];

      if (char_num < segmentation[0])
        chunks_left = segmentation[char_num + 1];
      else
        chunks_left = MAX_INT32;
    }
    render_outline(window, blob->outlines, color);
  }
  window->ZoomToRectangle(topleft.x, topleft.y, botright.x, botright.y);
}
/////////////////////////////////////////////////////////////////plotseg////////////////////////////////////////

/////////////////////////////////////////////////////////////////matchtab////////////////////////////////////////
/*----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------*/
typedef struct _MATCH_
{
  int topleft;
  int botright;
  BLOB_CHOICE_LIST *rating;
} MATCH;

/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
MATCH *match_table;
//?int   missed_count = 0;

/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
#define NUM_MATCH_ENTRIES 500    /* Entries in match_table */

/**********************************************************************
 * blank_entry
 *
 * Test an element in the blob match table to see if it is blank.
 * Return a non-zero value if it is blank.
 **********************************************************************/

#define blank_entry(match_table,x)  \
(! (match_table[x].topleft | match_table[x].botright))

/*----------------------------------------------------------------------
          Public Function Code
----------------------------------------------------------------------*/
/**********************************************************************
 * init_match_table
 *
 * Create and clear a match table to be used to speed up the splitter.
 **********************************************************************/
static int been_initialized = 0;
void init_match_table() {
  int x;

  if (been_initialized) {
    /* Reclaim old choices */
    for (x = 0; x < NUM_MATCH_ENTRIES; x++) {
      if ((!blank_entry (match_table, x)) && match_table[x].rating)
        match_table[x].rating->clear();
        delete match_table[x].rating;
    }
  }
  else {
    /* Allocate memory once */
    been_initialized = 1;
    match_table = new MATCH[NUM_MATCH_ENTRIES];
  }
  /* Initialize the table */
  for (x = 0; x < NUM_MATCH_ENTRIES; x++) {
    match_table[x].topleft = 0;
    match_table[x].botright = 0;
    match_table[x].rating = NULL;
  }
}

void end_match_table() {
  if (been_initialized) {
    init_match_table();
    delete[] match_table;
    match_table = NULL;
    been_initialized = 0;
  }
}


/**********************************************************************
 * put_match
 *
 * Put a new blob and its corresponding match ratings into the match
 * table.
 **********************************************************************/
void put_match(TBLOB *blob, BLOB_CHOICE_LIST *ratings) {
  unsigned int topleft;
  unsigned int botright;
  unsigned int start;
  TPOINT tp_topleft;
  TPOINT tp_botright;
  int x;
  /* Hash into table */
  blob_bounding_box(blob, &tp_topleft, &tp_botright);

  TPOINT *p1 = &tp_topleft;
  TPOINT *p2 = &tp_botright;
  topleft = *(unsigned int *)p1;
  botright = *(unsigned int *)p2;
  start = (topleft * botright) % NUM_MATCH_ENTRIES;

  /* Look for empty */
  x = start;
  do {
    if (blank_entry (match_table, x)) {
      /* Add this entry */
      match_table[x].topleft = topleft;
      match_table[x].botright = botright;
      // Copy ratings to match_table[x].rating
      match_table[x].rating = new BLOB_CHOICE_LIST();
      match_table[x].rating->deep_copy(ratings, &BLOB_CHOICE::deep_copy);
      return;
    }
    if (++x >= NUM_MATCH_ENTRIES)
      x = 0;
  }
  while (x != (int)start);

  cprintf ("error: Match table is full\n");
}


/**********************************************************************
 * get_match
 *
 * Look up this blob in the match table to see if it needs to be
 * matched.  If it is not present then NULL is returned.
 **********************************************************************/
BLOB_CHOICE_LIST *get_match(TBLOB *blob) {
  unsigned int topleft;
  unsigned int botright;
  TPOINT tp_topleft;
  TPOINT tp_botright;
  /* Do starting hash */
  blob_bounding_box(blob, &tp_topleft, &tp_botright);

  TPOINT *p1 = &tp_topleft;
  TPOINT *p2 = &tp_botright;
  topleft = *(unsigned int *)p1;
  botright = *(unsigned int *)p2;
  return (get_match_by_bounds (topleft, botright));
}


/**********************************************************************
 * get_match_by_bounds
 *
 * Look up this blob in the match table to see if it needs to be
 * matched.  If it is not present then NULL is returned.
 **********************************************************************/
BLOB_CHOICE_LIST *get_match_by_bounds(unsigned int topleft,
                                      unsigned int botright) {
  unsigned int start;
  int x;
  /* Do starting hash */
  start = (topleft * botright) % NUM_MATCH_ENTRIES;
  /* Search for match */
  x = start;
  do {
    /* Not found when blank */
    if (blank_entry (match_table, x))
      break;
    /* Is this the match ? */
    if (match_table[x].topleft == (int)topleft &&
        match_table[x].botright == (int)botright) {
      BLOB_CHOICE_LIST *blist = new BLOB_CHOICE_LIST();
      blist->deep_copy(match_table[x].rating, &BLOB_CHOICE::deep_copy);
      return blist;
    }
    if (++x >= NUM_MATCH_ENTRIES)
      x = 0;
  }
  while (x != (int)start);
  return NULL;
}

/**********************************************************************
 * add_to_match
 *
 * Update ratings list in the match_table corresponding to the given
 * blob. The function assumes that:
 * -- the match table contains the initial non-NULL list with choices
 *    for the given blob
 * -- the new ratings list is a superset of the corresponding list in
 *    the match_table and the unichar ids of the blob choices in the
 *    list are unique.
 * The entries that appear in the new ratings list and not in the
 * old one are added to the old ratings list in the match_table.
 **********************************************************************/
void add_to_match(TBLOB *blob, BLOB_CHOICE_LIST *ratings) {
  unsigned int topleft;
  unsigned int botright;
  TPOINT tp_topleft;
  TPOINT tp_botright;
  blob_bounding_box(blob, &tp_topleft, &tp_botright);

  TPOINT *p1 = &tp_topleft;
  TPOINT *p2 = &tp_botright;
  topleft = *(unsigned int *)p1;
  botright = *(unsigned int *)p2;
  unsigned int start;
  int x;
  /* Do starting hash */
  start = (topleft * botright) % NUM_MATCH_ENTRIES;
  /* Search for match */
  x = start;
  do {
    if (blank_entry(match_table, x)) {
      fprintf(stderr, "Can not update uninitialized entry in match_table\n");
      ASSERT_HOST(!blank_entry(match_table, x));
    }
    if (match_table[x].topleft == (int)topleft &&
        match_table[x].botright == (int)botright) {
      // Copy new ratings to match_table[x].rating.
      BLOB_CHOICE_IT it;
      it.set_to_list(match_table[x].rating);
      BLOB_CHOICE_IT new_it;
      new_it.set_to_list(ratings);
      assert(it.length() <= new_it.length());
      for (it.mark_cycle_pt(), new_it.mark_cycle_pt();
           !it.cycled_list() && !new_it.cycled_list(); new_it.forward()) {
        if (it.data()->unichar_id() == new_it.data()->unichar_id()) {
          it.forward();
        } else {
          it.add_before_stay_put(new BLOB_CHOICE(*(new_it.data())));
        }
      }
      return;
    }
    if (++x >= NUM_MATCH_ENTRIES)
      x = 0;
  }
  while (x != (int)start);
}
/////////////////////////////////////////////////////////////////matchtab////////////////////////////////////////

/////////////////////////////////////////////////////////////////pieces////////////////////////////////////////
/*----------------------------------------------------------------------
          M a c r o s
----------------------------------------------------------------------*/
/**********************************************************************
 * set_bounds_entry
 *
 * Set the value of the entry in an array of bounds elements.
 **********************************************************************/

#define set_bounds_entry(array,index,top_left,bot_right)  \
((array)[index].topleft  = (top_left),                  \
(array)[index].botright = (bot_right))                 \


/**********************************************************************
 * get_bounds_entry
 *
 * Get the value of the entry in an array of bounds elements.
 **********************************************************************/

#define get_bounds_entry(array,index,top_left,bot_right)  \
((top_left)  = (array)[index].topleft,                  \
(bot_right) = (array)[index].botright)                 \


/*----------------------------------------------------------------------
          F u n c t i o n s
----------------------------------------------------------------------*/
/**********************************************************************
 * break_pieces
 *
 * Break up the blobs in this chain so that they are all independent.
 * This operation should undo the affect of join_pieces.
 **********************************************************************/
void break_pieces(TBLOB *blobs, SEAMS seams, inT16 start, inT16 end) {
  TESSLINE *outline = blobs->outlines;
  TBLOB *next_blob;
  inT16 x;

  for (x = start; x < end; x++)
    reveal_seam ((SEAM *) array_value (seams, x));

  next_blob = blobs->next;

  while (outline && next_blob) {
    if (outline->next == next_blob->outlines) {
      outline->next = NULL;
      outline = next_blob->outlines;
      next_blob = next_blob->next;
    }
    else {
      outline = outline->next;
    }
  }
}


/**********************************************************************
 * join_pieces
 *
 * Join a group of base level pieces into a single blob that can then
 * be classified.
 **********************************************************************/
void join_pieces(TBLOB *piece_blobs, SEAMS seams, inT16 start, inT16 end) {
  TBLOB *next_blob;
  TBLOB *blob;
  inT16 x;
  TESSLINE *outline;
  SEAM *seam;

  for (x = 0, blob = piece_blobs; x < start; x++)
    blob = blob->next;
  next_blob = blob->next;
  outline = blob->outlines;
  if (!outline)
    return;

  while (x < end) {
    seam = (SEAM *) array_value (seams, x);
    if (x - seam->widthn >= start && x + seam->widthp < end)
      hide_seam(seam);
    while (outline->next)
      outline = outline->next;
    outline->next = next_blob->outlines;
    next_blob = next_blob->next;

    x++;
  }
}


/**********************************************************************
 * hide_seam
 *
 * Change the edge points that are referenced by this seam to make
 * them hidden edges.
 **********************************************************************/
void hide_seam(SEAM *seam) {
  if (seam == NULL || seam->split1 == NULL)
    return;
  hide_edge_pair (seam->split1->point1, seam->split1->point2);

  if (seam->split2 == NULL)
    return;
  hide_edge_pair (seam->split2->point1, seam->split2->point2);

  if (seam->split3 == NULL)
    return;
  hide_edge_pair (seam->split3->point1, seam->split3->point2);
}


/**********************************************************************
 * hide_edge_pair
 *
 * Change the edge points that are referenced by this seam to make
 * them hidden edges.
 **********************************************************************/
void hide_edge_pair(EDGEPT *pt1, EDGEPT *pt2) {
  EDGEPT *edgept;

  edgept = pt1;
  do {
    hide_edge(edgept);
    edgept = edgept->next;
  }
  while (!exact_point (edgept, pt2) && edgept != pt1);
  if (edgept == pt1) {
    /*              cprintf("Hid entire outline at (%d,%d)!!\n",
       edgept->pos.x,edgept->pos.y);                                */
  }
  edgept = pt2;
  do {
    hide_edge(edgept);
    edgept = edgept->next;
  }
  while (!exact_point (edgept, pt1) && edgept != pt2);
  if (edgept == pt2) {
    /*              cprintf("Hid entire outline at (%d,%d)!!\n",
       edgept->pos.x,edgept->pos.y);                                */
  }
}


/**********************************************************************
 * reveal_seam
 *
 * Change the edge points that are referenced by this seam to make
 * them hidden edges.
 **********************************************************************/
void reveal_seam(SEAM *seam) {
  if (seam == NULL || seam->split1 == NULL)
    return;
  reveal_edge_pair (seam->split1->point1, seam->split1->point2);

  if (seam->split2 == NULL)
    return;
  reveal_edge_pair (seam->split2->point1, seam->split2->point2);

  if (seam->split3 == NULL)
    return;
  reveal_edge_pair (seam->split3->point1, seam->split3->point2);
}


/**********************************************************************
 * reveal_edge_pair
 *
 * Change the edge points that are referenced by this seam to make
 * them hidden edges.
 **********************************************************************/
void reveal_edge_pair(EDGEPT *pt1, EDGEPT *pt2) {
  EDGEPT *edgept;

  edgept = pt1;
  do {
    reveal_edge(edgept);
    edgept = edgept->next;
  }
  while (!exact_point (edgept, pt2) && edgept != pt1);
  if (edgept == pt1) {
    /*              cprintf("Hid entire outline at (%d,%d)!!\n",
       edgept->pos.x,edgept->pos.y);                                */
  }
  edgept = pt2;
  do {
    reveal_edge(edgept);
    edgept = edgept->next;
  }
  while (!exact_point (edgept, pt1) && edgept != pt2);
  if (edgept == pt2) {
    /*              cprintf("Hid entire outline at (%d,%d)!!\n",
       edgept->pos.x,edgept->pos.y);                                */
  }
}


/**********************************************************************
 * bounds_of_piece
 *
 * Find the bounds of the piece that will be created by joining the
 * requested collection of pieces together.
 **********************************************************************/
void bounds_of_piece(BOUNDS_LIST bounds,
                     inT16 start,
                     inT16 end,
                     TPOINT *extreme_tl,
                     TPOINT *extreme_br) {
  TPOINT topleft;
  TPOINT botright;
  inT16 x;

  get_bounds_entry(bounds, start, *extreme_tl, *extreme_br);

  for (x = start + 1; x <= end; x++) {
    get_bounds_entry(bounds, x, topleft, botright);

    extreme_tl->x = MIN (topleft.x, extreme_tl->x);
    extreme_tl->y = MAX (topleft.y, extreme_tl->y);
    extreme_br->x = MAX (botright.x, extreme_br->x);
    extreme_br->y = MIN (botright.y, extreme_br->y);
  }
}


/**********************************************************************
 * classify_piece
 *
 * Create a larger piece from a collection of smaller ones.  Classify
 * it and return the results.  Take the large piece apart to leave
 * the collection of small pieces un modified.
 **********************************************************************/
BLOB_CHOICE_LIST *Wordrec::classify_piece(TBLOB *pieces,
                                          SEAMS seams,
                                          inT16 start,
                                          inT16 end) {
  STATE current_state;
  BLOB_CHOICE_LIST *choices;
  TBLOB *pblob;
  TBLOB *blob;
  TBLOB *nblob;
  inT16 x;
  SEARCH_STATE chunk_groups;

  set_n_ones (&current_state, array_count (seams));

  join_pieces(pieces, seams, start, end);
  for (blob = pieces, pblob = NULL, x = 0; x < start; x++) {
    pblob = blob;
    blob = blob->next;
  }
  for (nblob = blob->next; x < end; x++)
    nblob = nblob->next;
  choices = classify_blob (pblob, blob, nblob, NULL, "pieces:", White);

  break_pieces(blob, seams, start, end);
#ifndef GRAPHICS_DISABLED
  if (wordrec_display_segmentations > 2) {
    chunk_groups = bin_to_chunks (&current_state, array_count (seams));
    display_segmentation(pieces, chunk_groups);
    window_wait(segm_window);
    memfree(chunk_groups);
  }
#endif

  return (choices);
}


/**********************************************************************
 * get_piece_rating
 *
 * Check to see if this piece has already been classified.  If it has
 * return that rating.  Otherwise build the piece from the smaller
 * pieces, classify it, store the rating for later, and take the piece
 * apart again.
 **********************************************************************/
BLOB_CHOICE_LIST *Wordrec::get_piece_rating(MATRIX *ratings,
                                            TBLOB *blobs,
                                            SEAMS seams,
                                            inT16 start,
                                            inT16 end) {
  BLOB_CHOICE_LIST *choices = ratings->get(start, end);
  if (choices == NOT_CLASSIFIED) {
    choices = classify_piece(blobs,
                             seams,
                             start,
                             end);
    ratings->put(start, end, choices);
  }
  return (choices);
}

/**********************************************************************
 * record_blob_bounds
 *
 * Set up and initialize an array that holds the bounds of a set of
 * blobs.
 **********************************************************************/
BOUNDS_LIST record_blob_bounds(TBLOB *blobs) {
  TBLOB *blob;
  BOUNDS_LIST bounds;
  TPOINT topleft;
  TPOINT botright;
  inT16 x = 0;

  bounds = (BOUNDS_LIST) memalloc (count_blobs (blobs) * sizeof (BOUNDS));

  iterate_blobs(blob, blobs) {
    blob_bounding_box(blob, &topleft, &botright);
    set_bounds_entry(bounds, x, topleft, botright);
    x++;
  }
  return (bounds);
}


/**********************************************************************
 * record_piece_ratings
 *
 * Save the choices for all the pieces that have been classified into
 * a matrix that can be used to look them up later.  A two dimensional
 * matrix is created.  The indices correspond to the starting and
 * ending initial piece number.
 **********************************************************************/
MATRIX *record_piece_ratings(TBLOB *blobs) {
  BOUNDS_LIST bounds;
  inT16 num_blobs;
  inT16 x;
  inT16 y;
  TPOINT tp_topleft;
  TPOINT tp_botright;
  unsigned int topleft;
  unsigned int botright;
  MATRIX *ratings;
  BLOB_CHOICE_LIST *choices;

  bounds = record_blob_bounds (blobs);
  num_blobs = count_blobs (blobs);
  ratings = new MATRIX(num_blobs);

  for (x = 0; x < num_blobs; x++) {
    for (y = x; y < num_blobs; y++) {
      bounds_of_piece(bounds, x, y, &tp_topleft, &tp_botright);

      TPOINT *p1 = &tp_topleft;
      TPOINT *p2 = &tp_botright;
      topleft = *(unsigned int *)p1;
      botright = *(unsigned int *)p2;
      choices = get_match_by_bounds (topleft, botright);
      if (choices != NULL) {
        ratings->put(x, y, choices);
      }
    }
  }
  memfree(bounds);
  return (ratings);
}
/////////////////////////////////////////////////////////////////pieces////////////////////////////////////////

/////////////////////////////////////////////////////////////////heuristic////////////////////////////////////////
/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
#define MAX_SQUAT       2.0      /* Width ratio */
#define BAD_RATING   1000.0      /* No valid blob */

INT_VAR(segment_adjust_debug, 0,
        "Segmentation adjustment debug");
BOOL_VAR(assume_fixed_pitch_char_segment, 0,
         "include fixed-pitch heuristics in char segmentation");
BOOL_VAR(use_new_state_cost, 0,
         "use new state cost heuristics for segmentation state evaluation");
double_VAR(heuristic_segcost_rating_base, 1.25,
           "base factor for adding segmentation cost into word rating."
           "It's a multiplying factor, the larger the value above 1, "
           "the bigger the effect of segmentation cost.");
double_VAR(heuristic_weight_rating, 1,
           "weight associated with char rating in combined cost of state");
double_VAR(heuristic_weight_width, 0,
           "weight associated with width evidence in combined cost of state");
double_VAR(heuristic_weight_seamcut, 0,
           "weight associated with seam cut in combined cost of state");
double_VAR(heuristic_max_char_wh_ratio, MAX_SQUAT,
           "max char width-to-height ratio allowed in segmentation");
/*----------------------------------------------------------------------
// Some static helpers used only in this file
----------------------------------------------------------------------*/

// Return a character width record corresponding to the character
// width that will be generated in this segmentation state.
// The calling function need to memfree WIDTH_RECORD when finished.
// This is the same as the original function, only cosmetic changes,
// except instead of passing chunks back to be freed, it deallocates
// internally.
WIDTH_RECORD *state_char_widths(WIDTH_RECORD *chunk_widths,
                                STATE *state,
                                int num_joints) {
  SEARCH_STATE chunks = bin_to_chunks(state, num_joints);
  int num_chars = chunks[0] + 1;

  // allocate and store (n+1,w0,g0,w1,g1...,wn) in int[2*(n+1)] as a
  // struct { num_chars, widths[2*n+1]; }
  WIDTH_RECORD *char_widths = (WIDTH_RECORD*) memalloc(sizeof(int)*num_chars*2);
  char_widths->num_chars = num_chars;

  int first_blob = 0;
  int last_blob;
  for (int i = 1; i <= num_chars; i++) {
    last_blob = (i > chunks[0]) ? num_joints : first_blob + chunks[i];

    char_widths->widths[2*i-2] = chunks_width(chunk_widths,
                                              first_blob, last_blob);
    if (i <= chunks[0])
      char_widths->widths[2*i-1] = chunks_gap(chunk_widths, last_blob);

    if (segment_adjust_debug > 3)
      tprintf("width_record[%d]s%d--s%d(%d) %d %d:%d\n",
              i-1, first_blob, last_blob, chunks[i],
              char_widths->widths[2*i-2], char_widths->widths[2*i-1],
              chunk_widths->widths[2*last_blob+1]);
    first_blob = last_blob + 1;
  }

  memfree(chunks);
  return char_widths;
}

// Computes the variance of the char widths normalized to the given height
// TODO(dsl): Do this in a later stage and use char choice info to skip
// punctuations.
FLOAT32 get_width_variance(WIDTH_RECORD *wrec, float norm_height) {
  MEASUREMENT ws;
  new_measurement(ws);
  for (int x = 0; x < wrec->num_chars; x++) {
    FLOAT32 wh_ratio = wrec->widths[2 * x] * 1.0f / norm_height;
    if (x == wrec->num_chars - 1 && wh_ratio > 0.3)
      continue;   // exclude trailing punctuation from stats
    ADD_SAMPLE(ws, wh_ratio);
  }
  if (segment_adjust_debug > 2)
    tprintf("Width Mean=%g Var=%g\n", MEAN(ws), VARIANCE(ws));
  return VARIANCE(ws);
}

// Computes the variance of char positioning (width + spacing) wrt norm_height
FLOAT32 get_gap_variance(WIDTH_RECORD *wrec, float norm_height) {
  MEASUREMENT ws;
  new_measurement(ws);
  for (int x = 0; x < wrec->num_chars - 1; x++) {
    FLOAT32 gap_ratio = (wrec->widths[2 * x] + wrec->widths[ 2*x + 1])
                        * 1.0 / norm_height;
    ADD_SAMPLE(ws, gap_ratio);
  }
  if (segment_adjust_debug > 2)
    tprintf("Gap Mean=%g Var=%g\n", MEAN(ws), VARIANCE(ws));
  return VARIANCE(ws);
}


/*----------------------------------------------------------------------
 Below are the new state prioritization functions, which incorporates
 segmentation cost and width distribution for fixed pitch languages.
 They are included as methods in class Wordrec to obtain more context.
 ----------------------------------------------------------------------*/

/**********************************************************************
 * Returns the cost associated with the segmentation state.
 *
 * The number of states should be the same as the number of seams.
 * If state[i] is 1, then seams[i] is present; otherwise, it is hidden.
 * This function returns the sum of priority for active seams.
 * TODO(dsl): To keep this clean, this function will just return the
 * sum of raw "priority" as seam cost.  The normalization of this score
 * relative to other costs will be done in bestfirst.cpp evaluate_seg().
 **********************************************************************/

FLOAT32 Wordrec::seamcut_priority(SEAMS seams,
                                  STATE *state,
                                  int num_joints) {
  int x;
  unsigned int mask = (num_joints > 32) ? (1 << (num_joints - 1 - 32))
                                        : (1 << (num_joints - 1));
  float seam_cost = 0.0f;
  for (x = num_joints - 1; x >= 0; x--) {
    int i = num_joints - 1 - x;
    uinT32 value = (x < 32) ? state->part2 : state->part1;
    bool state_on = value & mask;
    if (state_on) {
      SEAM* seam = (SEAM *) array_value(seams, i);
      seam_cost += seam->priority;
    }
    if (mask == 1)
      mask = 1 << 31;
    else
      mask >>= 1;
  }
  if (segment_adjust_debug > 2)
    tprintf("seam_cost: %f\n", seam_cost);
  return seam_cost;
}

/**********************************************************************
 * rating_priority
 *
 * Assign a segmentation priority based on the ratings of the blobs
 * (in that segmentation) that have been classified.  The average
 * "goodness" (i.e. rating / weight) for each blob is used to indicate
 * the segmentation priority.  This is the original.
 **********************************************************************/
FLOAT32 Wordrec::rating_priority(CHUNKS_RECORD *chunks_record,
                                 STATE *state,
                                 int num_joints) {
  BLOB_CHOICE_LIST *blob_choices;
  BLOB_CHOICE_IT blob_choice_it;
  inT16 first_chunk = 0;
  inT16 last_chunk;
  inT16 ratings = 0;
  inT16 weights = 0;

  PIECES_STATE blob_chunks;
  bin_to_pieces(state, num_joints, blob_chunks);

  for (int x = 0; blob_chunks[x]; x++) {
    last_chunk = first_chunk + blob_chunks[x];

    blob_choices = chunks_record->ratings->get(first_chunk, last_chunk - 1);
    if (blob_choices != NOT_CLASSIFIED && blob_choices->length() > 0) {
      blob_choice_it.set_to_list(blob_choices);
      ratings += (inT16) blob_choice_it.data()->rating();
      for (int y = first_chunk; y < last_chunk; y++) {
        weights += (inT16) (chunks_record->weights[y]);
      }
    }
    first_chunk = last_chunk;
  }
  if (weights <= 0)
    weights = 1;
  FLOAT32 rating_cost = static_cast<FLOAT32>(ratings) /
                        static_cast<FLOAT32>(weights);
  if (segment_adjust_debug > 2)
    tprintf("rating_cost: r%f / w%f = %f\n", ratings, weights, rating_cost);
  return rating_cost;
}

// Returns the cost, eg. -log(p), of a given value in char width distribution.
FLOAT32 fp_width_cost(float norm_width, bool end_pos) {
  bool use_old_hack = true;
  if (use_old_hack) {
    float cost = 0;
    if (norm_width > heuristic_max_char_wh_ratio)
      cost += norm_width;
    if (norm_width > MAX_SQUAT)  // extra penalty for merging two CJK chars
      cost += norm_width * norm_width;
    // penalize skinny blobs, except for punctuation in the last position
    if (norm_width < 0.5 && !end_pos)
      cost += 1 - norm_width;
    return cost;
  }

  // otherwise, approximate with our not-so-normal distribution
  float s = fabs((norm_width - 0.85) / 0.35);
  if (s < 1)   // clip penalty to zero for anything within 1 std
    return 0.0f;
  // Allow smaller chars at begin or end position for punctuations
  if (end_pos && norm_width < 0.3)
    return 0.0f;
  if (segment_adjust_debug > 2)
    tprintf("fp_width_cost(%f) = %f**2 = %f\n", norm_width, s, s*s);
  return s*s;
}

FLOAT32 fp_gap_cost(float norm_gap, bool end_pos) {
  bool use_old_hack = true;
  if (use_old_hack) {
    if (norm_gap < 0.05 && !end_pos)
      return 5;   // penalize vertically overlapping components
    else
      return 0;
  }
  float s = fabs((norm_gap - 0.1) / 0.02);
  if (s > -1) return 0.0f;  // no penalty for wider gaps
  if (segment_adjust_debug > 2)
    tprintf("fp_gap_cost(%f) = %f**2 = %f\n", norm_gap, s, s*s);
  return s*s;
}

/**********************************************************************
 * width_priority
 *
 * Return a priority value for this word segmentation based on the
 * character widths present in the new segmentation.
 * For variable-pitch fonts, this should do the same thing as before:
 * ie. penalize only on really wide squatting blobs.
 * For fixed-pitch fonts, this will include a measure of char & gap
 * width consistency.
 * TODO(dsl): generalize this to use a PDF estimate for proportional and
 * fixed pitch mode.
 **********************************************************************/
FLOAT32 Wordrec::width_priority(CHUNKS_RECORD *chunks_record,
                                STATE *state,
                                int num_joints) {
  FLOAT32 penalty = 0.0;
  WIDTH_RECORD *width_rec = state_char_widths(chunks_record->chunk_widths,
                                              state, num_joints);
  // When baseline_enable==True, which is the current default for Tesseract,
  // a fixed value of 128 (BASELINE_SCALE) is always used.
  FLOAT32 normalizing_height = BASELINE_SCALE;
  if (!classify_baseline_normalized)   // this doesn't work and is never invoked
    normalizing_height = chunks_record->row->lineheight;
  if (assume_fixed_pitch_char_segment) {
    // For fixed pitch language like CJK, we use the full text height as the
    // normalizing factor so we are not dependent on xheight calculation.
    // In the normalized coord. xheight * scale == BASELINE_SCALE(128),
    // so add proportionally scaled ascender zone to get full text height.
    normalizing_height = tess_denorm->scale() *
        (tess_denorm->row()->x_height() + tess_denorm->row()->ascenders());
    if (segment_adjust_debug > 1)
      tprintf("WidthPriority: %f %f normalizing height = %f\n",
              tess_denorm->row()->x_height(), tess_denorm->row()->ascenders(),
              normalizing_height);
    // Impose additional segmentation penalties if blob widths or gaps
    // distribution don't fit a fixed-pitch model.
    FLOAT32 width_var = get_width_variance(width_rec, normalizing_height);
    FLOAT32 gap_var = get_gap_variance(width_rec, normalizing_height);
    penalty += width_var;
    penalty += gap_var;
  }

  for (int x = 0; x < width_rec->num_chars; x++) {
    FLOAT32 squat = width_rec->widths[2*x];
    FLOAT32 gap = (x < width_rec->num_chars-1) ? width_rec->widths[2*x+1] : 0;
    squat /= normalizing_height;
    gap /= normalizing_height;
    if (assume_fixed_pitch_char_segment) {
      penalty += fp_width_cost(squat, x == 0 || x == width_rec->num_chars -1);
      penalty += fp_gap_cost(gap, x == width_rec->num_chars - 1);
      if (width_rec->num_chars == 1 && squat > MAX_SQUAT)
        penalty += 10;
    } else {
      // original equation when heuristic_max_char_ratio == MAX_SQUAT
      if (squat > heuristic_max_char_wh_ratio)
        penalty += squat - heuristic_max_char_wh_ratio;
    }
  }

  free_widths(width_rec);
  return (penalty);
}


/**********************************************************************
 * prioritize_state
 *
 * Create a priority for this state.  It represents the urgency of
 * checking this state.  The larger the priority value, the worse the
 * state is (lower priority).  The "value" of this priority should be
 * somewhat consistent with the final word rating.
 * The question is how to normalize the different scores, and adjust
 * the relative importance among them.
 **********************************************************************/
FLOAT32 Wordrec::prioritize_state(CHUNKS_RECORD *chunks_record,
                                  SEARCH_RECORD *the_search) {
  FLOAT32 shape_cost;
  FLOAT32 width_cost;
  FLOAT32 seam_cost;

  shape_cost = rating_priority(chunks_record,
                               the_search->this_state,
                               the_search->num_joints);

  width_cost = width_priority(chunks_record,
                              the_search->this_state,
                              the_search->num_joints);

  // The rating_priority is the same as the original, and the width_priority
  // is the same as before if assume_fixed_pitch_char_segment == FALSE.
  // So this would return the original state priority.
  if (!use_new_state_cost)
    return width_cost * 1000 + shape_cost;

  seam_cost = seamcut_priority(chunks_record->splits,
                               the_search->this_state,
                               the_search->num_joints);
  record_priorities(the_search, shape_cost, width_cost);

  // TODO(dsl): how do we normalize the scores for these separate evidence?
  // FLOAT32 total_cost = shape_cost + width_cost * 0.01 + seam_cost * 0.001;
  FLOAT32 total_cost = shape_cost * heuristic_weight_rating +
                       width_cost * heuristic_weight_width +
                       seam_cost * heuristic_weight_seamcut;

  // We don't have an adjustment model for variable pitch segmentation cost
  // into word rating
  if (assume_fixed_pitch_char_segment) {
    float seg_bias = 1.0;
    if (width_cost < 1) seg_bias *= 0.85;
    if (width_cost > 3)
      seg_bias *= pow(heuristic_segcost_rating_base, width_cost/3.0);
    if (seam_cost > 10)
      seg_bias *= pow(heuristic_segcost_rating_base, log(seam_cost)/log(10.0));
    if (shape_cost > 5)
      seg_bias *= pow(heuristic_segcost_rating_base, shape_cost/5.0);
    if (segment_adjust_debug) {
      tprintf("SegCost: %g Weight: %g rating: %g  width: %g  seam: %g\n",
               total_cost, seg_bias, shape_cost, width_cost, seam_cost);
    }
    the_search->segcost_bias = seg_bias;
  } else {
    the_search->segcost_bias = 0;
  }

  return total_cost;
}
/////////////////////////////////////////////////////////////////heuristic////////////////////////////////////////

/////////////////////////////////////////////////////////////////bestfirst////////////////////////////////////////
void call_caller();

/*----------------------------------------------------------------------
          V a r i a b l e s
---------------------------------------------------------------------*/
int num_joints;                  /* Number of chunks - 1 */
int num_pushed = 0;
int num_popped = 0;

INT_VAR(wordrec_num_seg_states, 30, "Segmentation states");

double_VAR(wordrec_worst_state, 1, "Worst segmentation state");

/**/
/*----------------------------------------------------------------------
          F u n c t i o n s
----------------------------------------------------------------------*/
/**
 * @name best_first_search
 *
 * Find the best segmentation by doing a best first search of the
 * solution space.
 */
void Wordrec::best_first_search(CHUNKS_RECORD *chunks_record, WERD_CHOICE *best_choice,
                                WERD_CHOICE *raw_choice, STATE *state, DANGERR *fixpt, STATE *best_state)
{
    SEARCH_RECORD *the_search;
    inT16 keep_going;
    STATE guided_state;   // not used

    num_joints = chunks_record->ratings->dimension() - 1;
    the_search = new_search(chunks_record, num_joints, best_choice, raw_choice, state);

    // The default state is initialized as the best choice.  In order to apply
    // segmentation adjustment, or any other contextual processing in permute,
    // we give the best choice a poor rating to force the processed raw choice
    // to be promoted to best choice.
    the_search->best_choice->set_rating(100000.0);
    evaluate_state(chunks_record, the_search, fixpt);
    if (permute_debug)
    {
        tprintf("\n\n\n =========== BestFirstSearch ==============\n");
        best_choice->print("**Initial BestChoice**");
    }

#ifndef GRAPHICS_DISABLED
    save_best_state(chunks_record);
#endif
    start_recording();
    FLOAT32 worst_priority = 2.0f * prioritize_state(chunks_record, the_search);
    if (worst_priority < wordrec_worst_state) worst_priority = wordrec_worst_state;

    if (segment_debug)
    {
        print_state("BestFirstSearch", best_state, num_joints);
    }

    guided_state = *state;
    do
    {
        /* Look for answer */
        if (!hash_lookup (the_search->closed_states, the_search->this_state))
        {

            if (tord_blob_skip)
            {
                free_state (the_search->this_state);
                break;
            }

            guided_state = *(the_search->this_state);
            keep_going = evaluate_state(chunks_record, the_search, fixpt);
            hash_add (the_search->closed_states, the_search->this_state);

            if (!keep_going || (the_search->num_states > wordrec_num_seg_states) || (tord_blob_skip))
            {
                if (segment_debug)
                    tprintf("Breaking best_first_search on keep_going %s numstates %d\n", ((keep_going) ? "T" :"F"), the_search->num_states);
                free_state (the_search->this_state);

                break;
            }

            FLOAT32 new_worst_priority = 2.0f * prioritize_state(chunks_record, the_search);
            if (new_worst_priority < worst_priority)
            {
                if (segment_debug)
                {
                    tprintf("Lowering WorstPriority %f --> %f\n", worst_priority, new_worst_priority);
                }

                // Tighten the threshold for admitting new paths as better search
                // candidates are found.  After lowering this threshold, we can safely
                // popout everything that is worse than this score also.
                worst_priority = new_worst_priority;
            }

            expand_node(worst_priority, chunks_record, the_search);
        }

        free_state (the_search->this_state);
        num_popped++;
        the_search->this_state = pop_queue (the_search->open_states);

        if (segment_debug && !the_search->this_state)
        {
            tprintf("No more states to evalaute after %d evals", num_popped);
        }
    }
    while (the_search->this_state);

    state->part1 = the_search->best_state->part1;
    state->part2 = the_search->best_state->part2;
    stop_recording();

    if (permute_debug)
    {
        tprintf("\n\n\n =========== BestFirstSearch ==============\n"); // best_choice->debug_string(getDict().getUnicharset()).string());
        best_choice->print("**Final BestChoice**");
    }

    // save the best_state stats
    delete_search(the_search);
}

/**
 * @name chunks_width
 *
 * Return the width of a chunk which is a composed of several blobs
 * blobs[start_blob..last_blob] inclusively,
 * whose individual widths and gaps are record in width_record in the form
 * width_record->num_char = n
 * width_record->widths[2*n-1] = w0,g0,w1,g1..w(n-1),g(n-1)
 */
int chunks_width(WIDTH_RECORD *width_record, int start_blob, int last_blob)
{
    int result = 0;
    for (int x = start_blob * 2; x <= last_blob * 2; x++)
    {
        result += width_record->widths[x];
    }

    return (result);
}

/**
 * @name chunks_gap
 *
 * Return the width of between the specified chunk and next.
 */
int chunks_gap(WIDTH_RECORD *width_record, int last_chunk)
{
    return (last_chunk < width_record->num_chars - 1) ? width_record->widths[last_chunk * 2 + 1] : 0;
    }


    /**
 * delete_search
 *
 * Terminate the current search and free all the memory involved.
 */
    void delete_search(SEARCH_RECORD *the_search)
    {
    float closeness;

    closeness = (the_search->num_joints ? (hamming_distance(reinterpret_cast<uinT32*>(the_search->first_state),
                                                            reinterpret_cast<uinT32*>(the_search->best_state), 2) / (float) the_search->num_joints) : 0.0f);

    record_search_status (the_search->num_states, the_search->before_best, closeness);

    free_state (the_search->first_state);
    free_state (the_search->best_state);

    free_hash_table (the_search->closed_states);
    FreeHeapData (the_search->open_states, (void_dest) free_state);

    memfree(the_search);
}

/**
 * evaluate_chunks
 *
 * A particular word level segmentation has been chosen.  Evaluation
 * this to find the word list that corresponds to it.
 */
BLOB_CHOICE_LIST_VECTOR *Wordrec::evaluate_chunks(CHUNKS_RECORD *chunks_record, SEARCH_STATE search_state)
{
    BLOB_CHOICE_LIST_VECTOR *char_choices = new BLOB_CHOICE_LIST_VECTOR();
    BLOB_CHOICE_LIST *blob_choices;
    BLOB_CHOICE_IT blob_choice_it;
    int i;
    int x = 0;
    int y;

    /* Iterate sub-paths */
    for (i = 1; i <= search_state[0] + 1; i++)
    {
        if (i > search_state[0])
        {
            y = count_blobs (chunks_record->chunks) - 1;
        }
        else
        {
            y = x + search_state[i];
        }

        if (tord_blob_skip)
        {
            delete char_choices;
            return (NULL);
        }                            /* Process one square */

        /* Classify if needed */
        blob_choices = get_piece_rating(chunks_record->ratings, chunks_record->chunks, chunks_record->splits, x, y);

        if (blob_choices == NULL)
        {
            delete char_choices;
            return (NULL);
        }

        /* Add permuted ratings */
        blob_choice_it.set_to_list(blob_choices);
        last_segmentation[i - 1].certainty = blob_choice_it.data()->certainty();
        last_segmentation[i - 1].match = blob_choice_it.data()->rating();

        last_segmentation[i - 1].width = chunks_width (chunks_record->chunk_widths, x, y);
        last_segmentation[i - 1].gap = chunks_gap (chunks_record->chunk_widths, y);

        *char_choices += blob_choices;
        x = y + 1;
    }

    return (char_choices);
}

/**
 * @name evaluate_state
 *
 * Evaluate the segmentation that is represented by this state in the
 * best first search.  Add this state to the "states_seen" list.
 */
inT16 Wordrec::evaluate_state(CHUNKS_RECORD *chunks_record, SEARCH_RECORD *the_search, DANGERR *fixpt)
{
    BLOB_CHOICE_LIST_VECTOR *char_choices;
    SEARCH_STATE chunk_groups;
    float rating_limit = the_search->best_choice->rating();
    inT16 keep_going = TRUE;
    PIECES_STATE widths;

    the_search->num_states++;
    chunk_groups = bin_to_chunks(the_search->this_state, the_search->num_joints);
    bin_to_pieces (the_search->this_state, the_search->num_joints, widths);
    getDict().LogNewSegmentation(widths);

    char_choices = evaluate_chunks(chunks_record, chunk_groups);
    wordseg_rating_adjust_factor = -1.0f;

    if (char_choices != NULL && char_choices->length() > 0)
    {
        // Compute the segmentation cost and include the cost in word rating.
        // TODO(dsl): We should change the SEARCH_RECORD to store this cost
        // from state evaluation and avoid recomputing it here.
        prioritize_state(chunks_record, the_search);
        wordseg_rating_adjust_factor = the_search->segcost_bias;
        getDict().permute_characters(*char_choices, rating_limit, the_search->best_choice, the_search->raw_choice);

        bool replaced = false;
        if (getDict().AcceptableChoice(char_choices, the_search->best_choice, *(the_search->raw_choice), fixpt, ASSOCIATOR_CALLER, &replaced))
        {
            keep_going = FALSE;
        }
    }
    wordseg_rating_adjust_factor = -1.0f;

#ifndef GRAPHICS_DISABLED
    if (wordrec_display_segmentations)
    {
        display_segmentation (chunks_record->chunks, chunk_groups);
        if (wordrec_display_segmentations > 1) window_wait(segm_window);
    }
#endif

    if (rating_limit != the_search->best_choice->rating())
    {
        the_search->before_best = the_search->num_states;
        the_search->best_state->part1 = the_search->this_state->part1;
        the_search->best_state->part2 = the_search->this_state->part2;
        replace_char_widths(chunks_record, chunk_groups);
    }
    else if (char_choices != NULL)
    {
        fixpt->index = -1;
    }

    if (char_choices != NULL)
    {
        delete char_choices;
    }

    memfree(chunk_groups);

    return (keep_going);
}


/**
 * rebuild_current_state
 *
 * Evaluate the segmentation that is represented by this state in the
 * best first search.  Add this state to the "states_seen" list.
 */
BLOB_CHOICE_LIST_VECTOR *Wordrec::rebuild_current_state(TBLOB *blobs, SEAMS seam_list, STATE *state, BLOB_CHOICE_LIST_VECTOR *old_choices,
                                                        int fx, bool force_rebuild, const WERD_CHOICE &best_choice, const MATRIX *ratings)
{
    // Initialize search_state, num_joints, x, y.
    int num_joints = array_count(seam_list);
#ifndef GRAPHICS_DISABLED
    if (wordrec_display_segmentations)
    {
        print_state("Rebuiling state", state, num_joints);
    }
#endif
    SEARCH_STATE search_state = bin_to_chunks(state, num_joints);
    int x = 0;
    int y;
    int i;
    for (i = 1; i <= search_state[0]; i++)
    {
        y = x + search_state[i];
        x = y + 1;
    }
    y = count_blobs (blobs) - 1;

    // Initialize char_choices, expanded_fragment_lengths:
    // e.g. if fragment_lengths = {1 1 2 3 1},
    // expanded_fragment_lengths_str = {1 1 2 2 3 3 3 1}.
    BLOB_CHOICE_LIST_VECTOR *char_choices = new BLOB_CHOICE_LIST_VECTOR();
    STRING expanded_fragment_lengths_str = "";
    bool state_has_fragments = false;
    const char *fragment_lengths = NULL;

    if (best_choice.length() > 0)
    {
        fragment_lengths = best_choice.fragment_lengths();
    }

    if (fragment_lengths)
    {
        for (int i = 0; i < best_choice.length(); ++i)
        {
            *char_choices += NULL;
            if (fragment_lengths[i] > 1)
            {
                state_has_fragments = true;
            }

            for (int j = 0; j < fragment_lengths[i]; ++j)
            {
                expanded_fragment_lengths_str += fragment_lengths[i];
            }
        }
    }
    else
    {
        for (i = 0; i <= search_state[0]; ++i)
        {
            expanded_fragment_lengths_str += (char)1;
            *char_choices += NULL;
        }
    }

    // Finish early if force_rebuld is false and there are no fragments to merge.
    if (!force_rebuild && !state_has_fragments)
    {
        delete char_choices;
        memfree(search_state);
        return old_choices;
    }

    // Set up variables for concatenating fragments.
    const char *word_lengths_ptr = NULL;
    const char *word_ptr = NULL;
    if (state_has_fragments)
    {
        // Make word_lengths_ptr point to the last element in
        // best_choice->unichar_lengths().
        word_lengths_ptr = best_choice.unichar_lengths().string();
        word_lengths_ptr += (strlen(word_lengths_ptr)-1);

        // Make word_str point to the beginning of the last
        // unichar in best_choice->unichar_string().
        word_ptr = best_choice.unichar_string().string();
        word_ptr += (strlen(word_ptr)-*word_lengths_ptr);
    }

    const char *expanded_fragment_lengths = expanded_fragment_lengths_str.string();
    bool merging_fragment = false;
    int true_y = -1;
    char unichar[UNICHAR_LEN + 1];
    int fragment_pieces = -1;
    float rating = 0.0;
    float certainty = -MAX_FLOAT32;

    // Populate char_choices list such that it corresponds to search_state.
    //
    // If we are rebuilding a state that contains character fragments:
    // -- combine blobs that belong to character fragments
    // -- re-classify the blobs to obtain choices list for the merged blob
    // -- ensure that correct classification appears in the new choices list
    //    NOTE: a choice composed form original fragment choices will be always
    //    added to the new choices list for each character composed from
    //    fragments (even if the choice for the corresponding character appears
    //    in the re-classified choices list of for the newly merged blob).
    BLOB_CHOICE_IT temp_it;
    int char_choices_index = char_choices->length() - 1;
    for (i = search_state[0]; i >= 0; i--) {
        BLOB_CHOICE_LIST *current_choices = join_blobs_and_classify(blobs, seam_list, x, y, fx, ratings, old_choices);

        // Combine character fragments.
        if (expanded_fragment_lengths[i] > 1)
        {
            // Start merging character fragments.
            if (!merging_fragment)
            {
                merging_fragment = true;
                true_y = y;
                fragment_pieces = expanded_fragment_lengths[i];
                rating = 0.0;
                certainty = -MAX_FLOAT32;
                strncpy(unichar, word_ptr, *word_lengths_ptr);
                unichar[(int)*word_lengths_ptr] = '\0';
            }

            // Take into account the fact that we could have joined pieces
            // since we first recorded the ending point of a fragment (true_y).
            true_y -= y - x;
            // Populate fragment with updated values and look for the
            // fragment with the same values in current_choices.
            // Update rating and certainty of the character being composed.
            fragment_pieces--;
            CHAR_FRAGMENT fragment;
            fragment.set_all(unichar, fragment_pieces, expanded_fragment_lengths[i]);
            temp_it.set_to_list(current_choices);

            for (temp_it.mark_cycle_pt(); !temp_it.cycled_list(); temp_it.forward())
            {
                const CHAR_FRAGMENT *current_fragment = getDict().getUnicharset().get_fragment(temp_it.data()->unichar_id());
                if (current_fragment && fragment.equals(current_fragment))
                {
                    rating += temp_it.data()->rating();
                    if (temp_it.data()->certainty() > certainty)
                    {
                        certainty = temp_it.data()->certainty();
                    }
                    break;
                }
            }
            assert(!temp_it.cycled_list());  // make sure we found the fragment

            // Free current_choices for the fragmented character.
            delete current_choices;

            // Finish composing character from fragments.
            if (fragment_pieces == 0)
            {
                // Populate current_choices with the classification of
                // the blob merged from blobs of each character fragment.
                current_choices = join_blobs_and_classify(blobs, seam_list, x, true_y, fx, ratings, NULL);
                BLOB_CHOICE *merged_choice = new BLOB_CHOICE(getDict().getUnicharset().unichar_to_id(unichar), rating, certainty, 0, NO_PERM);

                // Insert merged_blob into current_choices, such that current_choices
                // are still sorted in non-descending order by rating.
                ASSERT_HOST(!current_choices->empty());
                temp_it.set_to_list(current_choices);
                for (temp_it.mark_cycle_pt(); !temp_it.cycled_list() && merged_choice->rating() > temp_it.data()->rating(); temp_it.forward());
                temp_it.add_before_stay_put(merged_choice);

                // Done merging this fragmented character.
                merging_fragment = false;
            }
        }

        if (!merging_fragment)
        {
            // Get rid of fragments in current_choices.
            temp_it.set_to_list(current_choices);
            for (temp_it.mark_cycle_pt(); !temp_it.cycled_list(); temp_it.forward())
            {
                if (getDict().getUnicharset().get_fragment(temp_it.data()->unichar_id()))
                {
                    delete temp_it.extract();
                }
            }
            char_choices->set(current_choices, char_choices_index);
            char_choices_index--;

            // Update word_ptr and word_lengths_ptr.
            if (word_lengths_ptr != NULL && word_ptr != NULL)
            {
                word_lengths_ptr--;
                word_ptr -= (*word_lengths_ptr);
            }
        }

        y = x - 1;
        x = y - search_state[i];
    }

    old_choices->delete_data_pointers();
    delete old_choices;

    memfree(search_state);

    return (char_choices);
}

/**
 * @name expand_node
 *
 * Create the states that are attached to this one.  Check to see that
 * each one has not already been visited.  If not add it to the priority
 * queue.
 */
void Wordrec::expand_node(FLOAT32 worst_priority, CHUNKS_RECORD *chunks_record, SEARCH_RECORD *the_search)
{
    STATE old_state;
    int nodes_added = 0;
    int x;
    uinT32 mask = 1 << (the_search->num_joints - 1 - 32);

    old_state.part1 = the_search->this_state->part1;
    old_state.part2 = the_search->this_state->part2;

    // We need to expand the search more intelligently, or we get stuck
    // with a bad starting segmentation in a long word sequence as in CJK.
    // Expand a child node only if it is within the global bound, and no
    // worse than 2x of its parent.
    // TODO(dsl): There is some redudency here in recomputing the priority,
    // and in filtering of old_merit and worst_priority.
    the_search->this_state->part2 = old_state.part2;

    for (x = the_search->num_joints; x > 32; x--)
    {
        the_search->this_state->part1 = mask ^ old_state.part1;
        if (!hash_lookup (the_search->closed_states, the_search->this_state))
        {
            FLOAT32 new_merit = prioritize_state(chunks_record, the_search);
            if (segment_debug && permute_debug)
            {
                cprintf ("....checking state: %8.3f ", new_merit);
                print_state ("", the_search->this_state, num_joints);
            }

            if (new_merit < worst_priority)
            {
                push_queue (the_search->open_states, the_search->this_state, worst_priority, new_merit);
                nodes_added++;
            }
        }

        mask >>= 1;
    }

    if (the_search->num_joints > 32)
    {
        mask = 1 << 31;
    }
    else
    {
        mask = 1 << (the_search->num_joints - 1);
    }

    the_search->this_state->part1 = old_state.part1;
    while (x--)
    {
        the_search->this_state->part2 = mask ^ old_state.part2;
        if (!hash_lookup (the_search->closed_states, the_search->this_state))
        {
            FLOAT32 new_merit = prioritize_state(chunks_record, the_search);
            if (segment_debug && permute_debug)
            {
                cprintf ("....checking state: %8.3f ", new_merit);
                print_state ("", the_search->this_state, num_joints);
            }

            if (new_merit < worst_priority)
            {
                push_queue(the_search->open_states, the_search->this_state, worst_priority, new_merit);
                nodes_added++;
            }
        }

        mask >>= 1;
    }
}

/**
 * @name new_search
 *
 * Create and initialize a new search record.
 */
SEARCH_RECORD *new_search(CHUNKS_RECORD *chunks_record, int num_joints, WERD_CHOICE *best_choice, WERD_CHOICE *raw_choice, STATE *state)
{
    Q_UNUSED(chunks_record);
    SEARCH_RECORD *this_search;

    this_search = (SEARCH_RECORD *) memalloc (sizeof (SEARCH_RECORD));

    this_search->open_states = MakeHeap (wordrec_num_seg_states * 20);
    this_search->closed_states = new_hash_table ();

    if (state)
    {
        this_search->this_state = new_state (state);
    }
    else
    {
        cprintf ("error: bad initial state in new_search\n");
    }

    this_search->first_state = new_state (this_search->this_state);
    this_search->best_state = new_state (this_search->this_state);

    this_search->best_choice = best_choice;
    this_search->raw_choice = raw_choice;

    this_search->num_joints = num_joints;
    this_search->num_states = 0;
    this_search->before_best = 0;
    this_search->segcost_bias = 0;

    return (this_search);
}


/**
 * @name pop_queue
 *
 * Get this state from the priority queue.  It should be the state that
 * has the greatest urgency to be evaluated.
 */
STATE *pop_queue(HEAP *queue)
{
    HEAPENTRY entry;

    if (GetTopOfHeap (queue, &entry) == OK)
    {
#ifndef GRAPHICS_DISABLED
        if (wordrec_display_segmentations)
        {
            cprintf ("eval state: %8.3f ", entry.Key);
            print_state ("", (STATE *) entry.Data, num_joints);
        }
#endif
        return ((STATE *) entry.Data);
    }
    else
    {
        return (NULL);
    }
}


/**
 * @name push_queue
 *
 * Add this state into the priority queue.
 */
void push_queue(HEAP *queue, STATE *state, FLOAT32 worst_priority, FLOAT32 priority)
{
    HEAPENTRY entry;

    if (priority < worst_priority)
    {
        if (SizeOfHeap (queue) >= MaxSizeOfHeap(queue))
        {
            if (segment_debug) tprintf("Heap is Full\n");
            return;
        }

        if (segment_debug)
        {
            tprintf("\tpushing %d node  %f\n", num_pushed, priority);
        }

        entry.Data = (char *) new_state (state);
        num_pushed++;
        entry.Key = priority;
        HeapStore(queue, &entry);
    }
}


/**
 * @name replace_char_widths
 *
 * Replace the value of the char_width field in the chunks_record with
 * the updated width measurements from the last_segmentation.
 */
void replace_char_widths(CHUNKS_RECORD *chunks_record, SEARCH_STATE state)
{
    WIDTH_RECORD *width_record;
    int num_blobs;
    int i;

    free_widths (chunks_record->char_widths);

    num_blobs = state[0] + 1;
    width_record = (WIDTH_RECORD *) memalloc (sizeof (int) * num_blobs * 2);
    width_record->num_chars = num_blobs;

    for (i = 0; i < num_blobs; i++)
    {

        width_record->widths[2 * i] = last_segmentation[i].width;

        if (i + 1 < num_blobs)
        {
            width_record->widths[2 * i + 1] = last_segmentation[i].gap;
        }
    }

    chunks_record->char_widths = width_record;
}

BLOB_CHOICE_LIST *Wordrec::join_blobs_and_classify(TBLOB *blobs, SEAMS seam_list, int x, int y, int fx,
                                                   const MATRIX *ratings, BLOB_CHOICE_LIST_VECTOR *old_choices)
{
    Q_UNUSED(fx);
    BLOB_CHOICE_LIST *choices = NULL;

    // First check to see if we can look up the classificaiton
    // in old_choices (if there is no need to merge blobs).
    if (x == y && old_choices != NULL && ratings == NULL)
    {
        choices = old_choices->get(x);
        old_choices->set(NULL, x);
        return choices;
    }

    // The ratings matrix filled in by the associator will contain the most
    // up-to-date classification info. Thus we look up the classification there
    // first, and only call classify_blob() if the classification is not found.
    if (ratings != NULL)
    {
        BLOB_CHOICE_LIST *choices_ptr = ratings->get(x, y);
        if (choices_ptr != NOT_CLASSIFIED)
        {
            choices = new BLOB_CHOICE_LIST();
            choices->deep_copy(choices_ptr, &BLOB_CHOICE::deep_copy);
        }
    }

    if (x != y)
    {
        join_pieces(blobs, seam_list, x, y);

        int blobindex;  // current blob
        TBLOB *p_blob;
        TBLOB *blob;
        TBLOB *next_blob;

        for (blob = blobs, blobindex = 0, p_blob = NULL; blobindex < x; blobindex++)
        {
            p_blob = blob;
            blob = blob->next;
        }

        while (blobindex < y)
        {
            next_blob = blob->next;
            blob->next = next_blob->next;
            oldblob(next_blob);  // junk dead blobs
            blobindex++;
        }

        if (choices == NULL)
        {
            choices = classify_blob(p_blob, blob, blob->next, NULL, "rebuild", Orange);
        }
    }

    return choices;
}
/////////////////////////////////////////////////////////////////bestfirst////////////////////////////////////////

/////////////////////////////////////////////////////////////////wordclass////////////////////////////////////////
extern TBLOB *newblob();

/*----------------------------------------------------------------------
            Variables
----------------------------------------------------------------------*/
inT16 first_pass;

/*----------------------------------------------------------------------
          C o n s t a n t s
----------------------------------------------------------------------*/

#define BOLD_ON              "&dB(s3B"
#define BOLD_OFF             "&d@(s0B"
#define UNDERLINE_ON         "&dD"
#define UNDERLINE_OFF        "&d@"

/*----------------------------------------------------------------------
          F u n c t i o n s
----------------------------------------------------------------------*/
/**
 * @name classify_blob
 *
 * Classify the this blob if it is not already recorded in the match
 * table. Attempt to recognize this blob as a character. The recognition
 * rating for this blob will be stored as a part of the blob. This value
 * will also be returned to the caller.
 *
 * @param pblob Previous blob
 * @param blob Current blob
 * @param nlob Next blob
 * @param row The row to process
 * @param string The string to display in ScrollView
 * @param color The colour to use when displayed with ScrollView
 */
BLOB_CHOICE_LIST *Wordrec::classify_blob(TBLOB *pblob,
                                         TBLOB *blob,
                                         TBLOB *nblob,
                                         TEXTROW *row,
                                         const char *string,
                                         C_COL color) {
  BLOB_CHOICE_LIST *choices = NULL;
  chars_classified++;            /* Global value */
  if (tord_blob_skip)
    return (NULL);
#ifndef GRAPHICS_DISABLED
  if (wordrec_display_all_blobs)
    display_blob(blob, color);
#endif
  choices = get_match(blob);
  if (choices == NULL) {
    choices = call_matcher(pblob, blob, nblob, NULL, row);
    put_match(blob, choices);
  }
#ifndef GRAPHICS_DISABLED
  if (tord_display_ratings && string)
    print_ratings_list(string, choices, getDict().getUnicharset());

  if (wordrec_blob_pause)
    window_wait(blob_window);
#endif

  return (choices);
}

/**
 * @name update_blob_classifications
 *
 * For each blob in the given word update match_table with the
 * corresponding BLOB_CHOICES_LIST from choices.
 */
void Wordrec::update_blob_classifications(
    TWERD *word, const BLOB_CHOICE_LIST_VECTOR &choices) {
  TBLOB *tblob = word->blobs;
  int index = 0;
  for (; tblob != NULL && index < choices.length();
       tblob = tblob->next, index++) {
    add_to_match(tblob, choices.get(index));
  }
}

/**
 * @name write_text_files
 *
 * Write an answer to the output file that is the raw guess (without
 * context) directly from the classifier.
 */
void write_text_files(TWERD *word,
                      char *raw_choice,
                      int same_row,
                      int good_word,
                      int firstpass) {
  int x;
  /* Raw output */
  if (tord_write_raw_output) {
    if (same_row)
      fprintf (rawfile, "\n");
    if (raw_choice && strlen (raw_choice)) {
      fprintf (rawfile, "%s ", raw_choice);
      fflush(rawfile);
    }
  }
  /* Text file output */
  if (tord_write_output) {
    if (same_row)
      fprintf (textfile, "\n");
    if (word->guess && strlen (word->guess)) {
      for (x = 0; x < word->blanks; x++)
        fprintf (textfile, " ");
      if (!firstpass)
        fprintf(textfile, BOLD_ON);
      if (!good_word)
        fprintf(textfile, UNDERLINE_ON);
      fprintf (textfile, "%s", word->guess);
      if (!good_word)
        fprintf(textfile, UNDERLINE_OFF);
      if (!firstpass)
        fprintf(textfile, BOLD_OFF);
      fflush(textfile);
    }
  }
  /* Global counters */
  character_count += (word->guess ? strlen (word->guess) : 0);
  word_count++;
}
/////////////////////////////////////////////////////////////////wordclass////////////////////////////////////////

/////////////////////////////////////////////////////////////////metrics////////////////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
static int states_timed_out1;    /* Counters */
static int states_timed_out2;
static int words_segmented1;
static int words_segmented2;
static int segmentation_states1;
static int segmentation_states2;
static int save_priorities;

int words_chopped1;
int words_chopped2;
int chops_attempted1;
int chops_performed1;
int chops_attempted2;
int chops_performed2;

int character_count;
int word_count;
int chars_classified;

MEASUREMENT num_pieces;
MEASUREMENT width_measure;

MEASUREMENT width_priority_range;/* Help to normalize */
MEASUREMENT match_priority_range;

TALLY states_before_best;
TALLY best_certainties[2];
TALLY character_widths;          /* Width histogram */

FILE *priority_file_1;           /* Output to cluster */
FILE *priority_file_2;
FILE *priority_file_3;

STATE *known_best_state = NULL;  /* The right answer */

/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
#define   CERTAINTY_BUCKET_SIZE -0.5
#define   CERTAINTY_BUCKETS     40

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**********************************************************************
 * init_metrics
 *
 * Set up the appropriate variables to record information about the
 * OCR process. Later calls will log the data and save a summary.
 **********************************************************************/
void init_metrics() {
  words_chopped1 = 0;
  words_chopped2 = 0;
  chops_performed1 = 0;
  chops_performed2 = 0;
  chops_attempted1 = 0;
  chops_attempted2 = 0;

  words_segmented1 = 0;
  words_segmented2 = 0;
  states_timed_out1 = 0;
  states_timed_out2 = 0;
  segmentation_states1 = 0;
  segmentation_states2 = 0;

  save_priorities = 0;

  character_count = 0;
  word_count = 0;
  chars_classified = 0;
  permutation_count = 0;

  end_metrics();

  states_before_best = new_tally (MIN (100, wordrec_num_seg_states));

  best_certainties[0] = new_tally (CERTAINTY_BUCKETS);
  best_certainties[1] = new_tally (CERTAINTY_BUCKETS);
  reset_width_tally();
}

void end_metrics() {
  if (states_before_best != NULL) {
    memfree(states_before_best);
    memfree(best_certainties[0]);
    memfree(best_certainties[1]);
    memfree(character_widths);
    states_before_best = NULL;
    best_certainties[0] = NULL;
    best_certainties[1] = NULL;
    character_widths = NULL;
  }
}


/**********************************************************************
 * record_certainty
 *
 * Maintain a record of the best certainty values achieved on each
 * word recognition.
 **********************************************************************/
void record_certainty(float certainty, int pass) {
  int bucket;

  if (certainty / CERTAINTY_BUCKET_SIZE < MAX_INT32)
    bucket = (int) (certainty / CERTAINTY_BUCKET_SIZE);
  else
    bucket = MAX_INT32;

  inc_tally_bucket (best_certainties[pass - 1], bucket);
}


/**********************************************************************
 * record_search_status
 *
 * Record information about each iteration of the search.  This  data
 * is kept in global memory and accumulated over multiple segmenter
 * searches.
 **********************************************************************/
void record_search_status(int num_states, int before_best, float closeness)
{
    Q_UNUSED(closeness);
  inc_tally_bucket(states_before_best, before_best);

  if (first_pass) {
    if (num_states == wordrec_num_seg_states + 1)
      states_timed_out1++;
    segmentation_states1 += num_states;
    words_segmented1++;
  }
  else {
    if (num_states == wordrec_num_seg_states + 1)
      states_timed_out2++;
    segmentation_states2 += num_states;
    words_segmented2++;
  }
}


/**********************************************************************
 * save_summary
 *
 * Save the summary information into the file "file.sta".
 **********************************************************************/
void Wordrec::save_summary(inT32 elapsed_time) {
  #ifndef SECURE_NAMES
  STRING outfilename;
  FILE *f;
  int x;
  int total;

  outfilename = imagefile + ".sta";
  f = open_file (outfilename.string(), "w");

  fprintf (f, INT32FORMAT " seconds elapsed\n", elapsed_time);
  fprintf (f, "\n");

  fprintf (f, "%d characters\n", character_count);
  fprintf (f, "%d words\n", word_count);
  fprintf (f, "\n");

  fprintf (f, "%d permutations performed\n", permutation_count);
  fprintf (f, "%d characters classified\n", chars_classified);
  fprintf (f, "%4.0f%% classification overhead\n",
    (float) chars_classified / character_count * 100.0 - 100.0);
  fprintf (f, "\n");

  fprintf (f, "%d words chopped (pass 1) ", words_chopped1);
  fprintf (f, " (%0.0f%%)\n", (float) words_chopped1 / word_count * 100);
  fprintf (f, "%d chops performed\n", chops_performed1);
  fprintf (f, "%d chops attempted\n", chops_attempted1);
  fprintf (f, "\n");

  fprintf (f, "%d words joined (pass 1)", words_segmented1);
  fprintf (f, " (%0.0f%%)\n", (float) words_segmented1 / word_count * 100);
  fprintf (f, "%d segmentation states\n", segmentation_states1);
  fprintf (f, "%d segmentations timed out\n", states_timed_out1);
  fprintf (f, "\n");

  fprintf (f, "%d words chopped (pass 2) ", words_chopped2);
  fprintf (f, " (%0.0f%%)\n", (float) words_chopped2 / word_count * 100);
  fprintf (f, "%d chops performed\n", chops_performed2);
  fprintf (f, "%d chops attempted\n", chops_attempted2);
  fprintf (f, "\n");

  fprintf (f, "%d words joined (pass 2)", words_segmented2);
  fprintf (f, " (%0.0f%%)\n", (float) words_segmented2 / word_count * 100);
  fprintf (f, "%d segmentation states\n", segmentation_states2);
  fprintf (f, "%d segmentations timed out\n", states_timed_out2);
  fprintf (f, "\n");

  total = 0;
  iterate_tally (states_before_best, x)
    total += (tally_entry (states_before_best, x) * x);
  fprintf (f, "segmentations (before best) = %d\n", total);
  if (total != 0.0)
    fprintf (f, "%4.0f%% segmentation overhead\n",
      (float) (segmentation_states1 + segmentation_states2) /
      total * 100.0 - 100.0);
  fprintf (f, "\n");

  print_tally (f, "segmentations (before best)", states_before_best);

  iterate_tally (best_certainties[0], x)
    cprintf ("best certainty of %8.4f = %4d %4d\n",
    x * CERTAINTY_BUCKET_SIZE,
    tally_entry (best_certainties[0], x),
    tally_entry (best_certainties[1], x));

  PrintIntMatcherStats(f);
  dj_statistics(f);
  fclose(f);
  #endif
}

/**********************************************************************
 * record_priorities
 *
 * If the record mode is set then record the priorities returned by
 * each of the priority voters.  Save them in a file that is set up for
 * doing clustering.
 **********************************************************************/
void record_priorities(SEARCH_RECORD *the_search,
                       FLOAT32 priority_1,
                       FLOAT32 priority_2)
{
  Q_UNUSED(the_search);
  record_samples(priority_1, priority_2);
}


/**********************************************************************
 * record_samples
 *
 * Remember the priority samples to summarize them later.
 **********************************************************************/
void record_samples(FLOAT32 match_pri, FLOAT32 width_pri) {
  ADD_SAMPLE(match_priority_range, match_pri);
  ADD_SAMPLE(width_priority_range, width_pri);
}


/**********************************************************************
 * reset_width_tally
 *
 * Create a tally record and initialize it.
 **********************************************************************/
void reset_width_tally() {
  character_widths = new_tally (20);
  new_measurement(width_measure);
  width_measure.num_samples = 158;
  width_measure.sum_of_samples = 125.0;
  width_measure.sum_of_squares = 118.0;
}


#ifndef GRAPHICS_DISABLED
/**********************************************************************
 * save_best_state
 *
 * Save this state away to be compared later.
 **********************************************************************/
void save_best_state(CHUNKS_RECORD *chunks_record) {
  STATE state;
  SEARCH_STATE chunk_groups;
  int num_joints;

  if (save_priorities) {
    num_joints = chunks_record->ratings->dimension() - 1;

    state.part1 = 0xffffffff;
    state.part2 = 0xffffffff;

    chunk_groups = bin_to_chunks (&state, num_joints);
    display_segmentation (chunks_record->chunks, chunk_groups);
    memfree(chunk_groups);

    cprintf ("Enter the correct segmentation > ");
    fflush(stdout);
    state.part1 = 0;
    scanf ("%x", &state.part2);

    chunk_groups = bin_to_chunks (&state, num_joints);
    display_segmentation (chunks_record->chunks, chunk_groups);
    memfree(chunk_groups);
    window_wait(segm_window);  /* == 'n') */

    if (known_best_state)
      free_state(known_best_state);
    known_best_state = new_state (&state);
  }
}
#endif


/**********************************************************************
 * start_record
 *
 * Set up everything needed to record the priority voters.
 **********************************************************************/
void start_recording() {
  if (save_priorities) {
    priority_file_1 = open_file ("Priorities1", "w");
    priority_file_2 = open_file ("Priorities2", "w");
    priority_file_3 = open_file ("Priorities3", "w");
  }
}


/**********************************************************************
 * stop_recording
 *
 * Put an end to the priority recording mechanism.
 **********************************************************************/
void stop_recording() {
  if (save_priorities) {
    fclose(priority_file_1);
    fclose(priority_file_2);
    fclose(priority_file_3);
  }
}
/////////////////////////////////////////////////////////////////metrics////////////////////////////////////////

/////////////////////////////////////////////////////////////////plotedges////////////////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
ScrollView *edge_window = NULL;

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**********************************************************************
 * display_edgepts
 *
 * Macro to display edge points in a window.
 **********************************************************************/
void display_edgepts(LIST outlines) {
  void *window;
  /* Set up window */
  if (edge_window == NULL) {
    edge_window = c_create_window ("Edges", 750, 150,
      400, 128, -400.0, 400.0, 0.0, 256.0);
  }
  else {
    c_clear_window(edge_window);
  }
  /* Render the outlines */
  window = edge_window;
  /* Reclaim old memory */
  iterate(outlines) {
    render_edgepts (window, (EDGEPT *) first_node (outlines), White);
  }
}


/**********************************************************************
 * draw_blob_edges
 *
 * Display the edges of this blob in the edges window.
 **********************************************************************/
void draw_blob_edges(TBLOB *blob) {
  TESSLINE *ol;
  LIST edge_list = NIL;

  if (wordrec_display_splits) {
    for (ol = blob->outlines; ol != NULL; ol = ol->next)
      push_on (edge_list, ol->loop);
    display_edgepts(edge_list);
    destroy(edge_list);
  }
}


/**********************************************************************
 * mark_outline
 *
 * Make a mark on the edges window at a particular location.
 **********************************************************************/
void mark_outline(EDGEPT *edgept) {  /* Start of point list */
  void *window = edge_window;
  float x = edgept->pos.x;
  float y = edgept->pos.y;

  c_line_color_index(window, Red);
  c_move(window, x, y);

  x -= 4;
  y -= 12;
  c_draw(window, x, y);

  x -= 2;
  y += 4;
  c_draw(window, x, y);

  x -= 4;
  y += 2;
  c_draw(window, x, y);

  x += 10;
  y += 6;
  c_draw(window, x, y);

  c_make_current(window);
}


/**********************************************************************
 * mark_split
 *
 * Set up the marks list to be displayed in subsequent updates and draw
 * the marks in the current window.  The marks are stored in the second
 * sublist. The first sublist is left unmodified.
 **********************************************************************/
void mark_split(SPLIT *split) {
  void *window = edge_window;

  c_line_color_index(window, Green);
  c_move (window, (float) split->point1->pos.x, (float) split->point1->pos.y);
  c_draw (window, (float) split->point2->pos.x, (float) split->point2->pos.y);
  c_make_current(window);
}
/////////////////////////////////////////////////////////////////plotedges////////////////////////////////////////

/////////////////////////////////////////////////////////////////vecfuncs////////////////////////////////////////
/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**********************************************************************
 *  direction
 *
 *  Show if the line is going in the positive or negative X direction.
 **********************************************************************/
int direction(EDGEPT *point) {
  int dir;                       /** direction to return **/
  EDGEPT *prev;                  /** prev point **/
  EDGEPT *next;                  /** next point **/

  dir = 0;
  prev = point->prev;
  next = point->next;

  if (((prev->pos.x <= point->pos.x) &&
    (point->pos.x < next->pos.x)) ||
    ((prev->pos.x < point->pos.x) && (point->pos.x <= next->pos.x)))
    dir = 1;

  if (((prev->pos.x >= point->pos.x) &&
    (point->pos.x > next->pos.x)) ||
    ((prev->pos.x > point->pos.x) && (point->pos.x >= next->pos.x)))
    dir = -1;

  return dir;
}
/////////////////////////////////////////////////////////////////vecfuncs////////////////////////////////////////

/////////////////////////////////////////////////////////////////outlines////////////////////////////////////////
/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**********************************************************************
 * crosses_outline
 *
 * Check to see if this line crosses over this outline.  If it does
 * return TRUE.
 **********************************************************************/
int crosses_outline(EDGEPT *p0,         /* Start of line */
                    EDGEPT *p1,         /* End of line */
                    EDGEPT *outline) {  /* Outline to check */
  EDGEPT *pt = outline;
  do {
    if (is_crossed (p0->pos, p1->pos, pt->pos, pt->next->pos))
      return (TRUE);
    pt = pt->next;
  }
  while (pt != outline);
  return (FALSE);
}


/**********************************************************************
 * is_crossed
 *
 * Return TRUE when the two line segments cross each other.  Find out
 * where the projected lines would cross and then check to see if the
 * point of intersection lies on both of the line segments. If it does
 * then these two segments cross.
 **********************************************************************/
int is_crossed(TPOINT a0, TPOINT a1, TPOINT b0, TPOINT b1) {
  int b0a1xb0b1, b0b1xb0a0;
  int a1b1xa1a0, a1a0xa1b0;

  TPOINT b0a1, b0a0, a1b1, b0b1, a1a0;

  b0a1.x = a1.x - b0.x;
  b0a0.x = a0.x - b0.x;
  a1b1.x = b1.x - a1.x;
  b0b1.x = b1.x - b0.x;
  a1a0.x = a0.x - a1.x;
  b0a1.y = a1.y - b0.y;
  b0a0.y = a0.y - b0.y;
  a1b1.y = b1.y - a1.y;
  b0b1.y = b1.y - b0.y;
  a1a0.y = a0.y - a1.y;

  b0a1xb0b1 = CROSS (b0a1, b0b1);
  b0b1xb0a0 = CROSS (b0b1, b0a0);
  a1b1xa1a0 = CROSS (a1b1, a1a0);
                                 /*a1a0xa1b0=CROSS(a1a0,a1b0); */
  a1a0xa1b0 = -CROSS (a1a0, b0a1);

  return ((b0a1xb0b1 > 0 && b0b1xb0a0 > 0)
    || (b0a1xb0b1 < 0 && b0b1xb0a0 < 0))
    && ((a1b1xa1a0 > 0 && a1a0xa1b0 > 0) || (a1b1xa1a0 < 0 && a1a0xa1b0 < 0));
}


/**********************************************************************
 * is_same_edgept
 *
 * Return true if the points are identical.
 **********************************************************************/
int is_same_edgept(EDGEPT *p1, EDGEPT *p2) {
  return (p1 == p2);
}


/**********************************************************************
 * near_point
 *
 * Find the point on a line segment that is closest to a point not on
 * the line segment.  Return that point.
 **********************************************************************/
EDGEPT *near_point(EDGEPT *point, EDGEPT *line_pt_0, EDGEPT *line_pt_1) {
  TPOINT p;

  float slope;
  float intercept;

  float x0 = line_pt_0->pos.x;
  float x1 = line_pt_1->pos.x;
  float y0 = line_pt_0->pos.y;
  float y1 = line_pt_1->pos.y;

  if (x0 == x1) {
                                 /* Handle vertical line */
    p.x = (inT16) x0;
    p.y = point->pos.y;
  }
  else {
    /* Slope and intercept */
    slope = (y0 - y1) / (x0 - x1);
    intercept = y1 - x1 * slope;

    /* Find perpendicular */
    p.x = (inT16) ((point->pos.x + (point->pos.y - intercept) * slope) /
      (slope * slope + 1));
    p.y = (inT16) (slope * p.x + intercept);
  }

  if (is_on_line (p, line_pt_0->pos, line_pt_1->pos) &&
    (!same_point (p, line_pt_0->pos)) && (!same_point (p, line_pt_1->pos)))
    /* Intersection on line */
    return (make_edgept (p.x, p.y, line_pt_1, line_pt_0));
  else                           /* Intersection not on line */
    return (closest (point, line_pt_0, line_pt_1));
}


/**********************************************************************
 * reverse_outline
 *
 * Change the direction of the outline.  If it was clockwise make it
 * counter-clockwise and vice versa.  Do this by swapping each of the
 * next and prev fields of each edge point.
 **********************************************************************/
void reverse_outline(EDGEPT *outline) {
  EDGEPT *edgept = outline;
  EDGEPT *temp;

  do {
                                 /* Swap next and prev */
    temp = edgept->prev;
    edgept->prev = edgept->next;
    edgept->next = temp;
    /* Set up vec field */
    edgept->vec.x = edgept->next->pos.x - edgept->pos.x;
    edgept->vec.y = edgept->next->pos.y - edgept->pos.y;

    edgept = edgept->prev;       /* Go to next point */
  }
  while (edgept != outline);
}
/////////////////////////////////////////////////////////////////outlines////////////////////////////////////////

/////////////////////////////////////////////////////////////////chop////////////////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
INT_VAR(chop_debug, 0, "Chop debug");

BOOL_VAR(chop_enable, 1, "Chop enable");

BOOL_VAR(chop_vertical_creep, 0, "Vertical creep");

INT_VAR(chop_split_length, 10000, "Split Length");

INT_VAR(chop_same_distance, 2, "Same distance");

INT_VAR(chop_min_outline_points, 6, "Min Number of Points on Outline");

INT_VAR(chop_inside_angle, -50, "Min Inside Angle Bend");

INT_VAR(chop_min_outline_area, 2000, "Min Outline Area");

double_VAR(chop_split_dist_knob, 0.5, "Split length adjustment");

double_VAR(chop_overlap_knob, 0.9, "Split overlap adjustment");

double_VAR(chop_center_knob, 0.15, "Split center adjustment");

double_VAR(chop_sharpness_knob, 0.06, "Split sharpness adjustment");

double_VAR(chop_width_change_knob, 5.0, "Width change adjustment");

double_VAR(chop_ok_split, 100.0, "OK split limit");

double_VAR(chop_good_split, 50.0, "Good split limit");

INT_VAR(chop_x_y_weight, 3, "X / Y  length weight");

/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
/**
 * @name length_product
 *
 * Compute the product of the length of two vectors.  The
 * vectors must be of type POINT.   This product is used in computing
 * angles.
 */
#define length_product(p1,p2)                                      \
(sqrt ((((float) (p1).x * (p1).x + (float) (p1).y * (p1).y) *    \
            ((float) (p2).x * (p2).x + (float) (p2).y * (p2).y))))

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**
 * @name point_priority
 *
 * Assign a priority to and edge point that might be used as part of a
 * split. The argument should be of type EDGEPT.
 */
PRIORITY point_priority(EDGEPT *point) {
  return ((PRIORITY) point_bend_angle (point));
}


/**
 * @name add_point_to_list
 *
 * Add an edge point to a POINT_GROUP containg a list of other points.
 */
void add_point_to_list(POINT_GROUP point_list, EDGEPT *point) {
  HEAPENTRY data;

  if (SizeOfHeap (point_list) < MAX_NUM_POINTS - 2) {
    data.Data = (char *) point;
    data.Key = point_priority (point);
    HeapStore(point_list, &data);
  }

#ifndef GRAPHICS_DISABLED
  if (chop_debug > 2)
    mark_outline(point);
#endif
}


/**
 * @name angle_change
 *
 * Return the change in angle (degrees) of the line segments between
 * points one and two, and two and three.
 */
int angle_change(EDGEPT *point1, EDGEPT *point2, EDGEPT *point3) {
  VECTOR vector1;
  VECTOR vector2;

  int angle;
  float length;

  /* Compute angle */
  vector1.x = point2->pos.x - point1->pos.x;
  vector1.y = point2->pos.y - point1->pos.y;
  vector2.x = point3->pos.x - point2->pos.x;
  vector2.y = point3->pos.y - point2->pos.y;
  /* Use cross product */
  length = length_product (vector1, vector2);
  if ((int) length == 0)
    return (0);
  angle = static_cast<int>(floor(asin(CROSS(vector1, vector2) /
                                      length) / PI * 180.0 + 0.5));

  /* Use dot product */
  if (SCALAR (vector1, vector2) < 0)
    angle = 180 - angle;
  /* Adjust angle */
  if (angle > 180)
    angle -= 360;
  if (angle <= -180)
    angle += 360;
  return (angle);
}

/**
 * @name is_little_chunk
 *
 * Return TRUE if one of the pieces resulting from this split would
 * less than some number of edge points.
 */
int is_little_chunk(EDGEPT *point1, EDGEPT *point2) {
  EDGEPT *p = point1;            /* Iterator */
  int counter = 0;

  do {
                                 /* Go from P1 to P2 */
    if (is_same_edgept (point2, p)) {
      if (is_small_area (point1, point2))
        return (TRUE);
      else
        break;
    }
    p = p->next;
  }
  while ((p != point1) && (counter++ < chop_min_outline_points));
  /* Go from P2 to P1 */
  p = point2;
  counter = 0;
  do {
    if (is_same_edgept (point1, p)) {
      return (is_small_area (point2, point1));
    }
    p = p->next;
  }
  while ((p != point2) && (counter++ < chop_min_outline_points));

  return (FALSE);
}


/**
 * @name is_small_area
 *
 * Test the area defined by a split accross this outline.
 */
int is_small_area(EDGEPT *point1, EDGEPT *point2) {
  EDGEPT *p = point1->next;      /* Iterator */
  int area = 0;
  TPOINT origin;

  do {
                                 /* Go from P1 to P2 */
    origin.x = p->pos.x - point1->pos.x;
    origin.y = p->pos.y - point1->pos.y;
    area += CROSS (origin, p->vec);
    p = p->next;
  }
  while (!is_same_edgept (point2, p));

  return (area < chop_min_outline_area);
}


/**
 * @name pick_close_point
 *
 * Choose the edge point that is closest to the critical point.  This
 * point may not be exactly vertical from the critical point.
 */
EDGEPT *pick_close_point(EDGEPT *critical_point,
                         EDGEPT *vertical_point,
                         int *best_dist) {
  EDGEPT *best_point = NULL;
  int this_distance;
  int found_better;

  do {
    found_better = FALSE;

    this_distance = edgept_dist (critical_point, vertical_point);
    if (this_distance <= *best_dist) {

      if (!(same_point (critical_point->pos, vertical_point->pos) ||
        same_point (critical_point->pos, vertical_point->next->pos) ||
        (best_point && same_point (best_point->pos, vertical_point->pos)) ||
      is_exterior_point (critical_point, vertical_point))) {
        *best_dist = this_distance;
        best_point = vertical_point;
        if (chop_vertical_creep)
          found_better = TRUE;
      }
    }
    vertical_point = vertical_point->next;
  }
  while (found_better == TRUE);

  return (best_point);
}


/**
 * @name prioritize_points
 *
 * Find a list of edge points from the outer outline of this blob.  For
 * each of these points assign a priority.  Sort these points using a
 * heap structure so that they can be visited in order.
 */
void prioritize_points(TESSLINE *outline, POINT_GROUP points) {
  EDGEPT *this_point;
  EDGEPT *local_min = NULL;
  EDGEPT *local_max = NULL;

  this_point = outline->loop;
  local_min = this_point;
  local_max = this_point;
  do {
    if (tord_debug_5)
      cprintf ("(%3d,%3d)  min=%3d, max=%3d, dir=%2d, ang=%2.0f\n",
        this_point->pos.x, this_point->pos.y,
        (local_min ? local_min->pos.y : 999),
      (local_max ? local_max->pos.y : 999),
      direction (this_point), point_priority (this_point));

    if (this_point->vec.y < 0) {
                                 /* Look for minima */
      if (local_max != NULL)
        new_max_point(local_max, points);
      else if (is_inside_angle (this_point))
        add_point_to_list(points, this_point);
      local_max = NULL;
      local_min = this_point->next;
    }
    else if (this_point->vec.y > 0) {
                                 /* Look for maxima */
      if (local_min != NULL)
        new_min_point(local_min, points);
      else if (is_inside_angle (this_point))
        add_point_to_list(points, this_point);
      local_min = NULL;
      local_max = this_point->next;
    }
    else {
      /* Flat area */
      if (local_max != NULL) {
        if (local_max->prev->vec.y != 0) {
          new_max_point(local_max, points);
        }
        local_max = this_point->next;
        local_min = NULL;
      }
      else {
        if (local_min->prev->vec.y != 0) {
          new_min_point(local_min, points);
        }
        local_min = this_point->next;
        local_max = NULL;
      }
    }

                                 /* Next point */
    this_point = this_point->next;
  }
  while (this_point != outline->loop);
}


/**
 * @name new_min_point
 *
 * Found a new minimum point try to decide whether to save it or not.
 * Return the new value for the local minimum.  If a point is saved then
 * the local minimum is reset to NULL.
 */
void new_min_point(EDGEPT *local_min, POINT_GROUP points) {
  inT16 dir;

  dir = direction (local_min);

  if (dir < 0) {
    add_point_to_list(points, local_min);
    return;
  }

  if (dir == 0 && point_priority (local_min) < 0) {
    add_point_to_list(points, local_min);
    return;
  }
}


/**
 * @name new_max_point
 *
 * Found a new minimum point try to decide whether to save it or not.
 * Return the new value for the local minimum.  If a point is saved then
 * the local minimum is reset to NULL.
 */
void new_max_point(EDGEPT *local_max, POINT_GROUP points) {
  inT16 dir;

  dir = direction (local_max);

  if (dir > 0) {
    add_point_to_list(points, local_max);
    return;
  }

  if (dir == 0 && point_priority (local_max) < 0) {
    add_point_to_list(points, local_max);
    return;
  }
}


/**
 * @name vertical_projection_point
 *
 * For one point on the outline, find the corresponding point on the
 * other side of the outline that is a likely projection for a split
 * point.  This is done by iterating through the edge points until the
 * X value of the point being looked at is greater than the X value of
 * the split point.  Ensure that the point being returned is not right
 * next to the split point.  Return the edge point as a result.
 */
void vertical_projection_point(EDGEPT *split_point, EDGEPT *target_point,
                               EDGEPT** best_point) {
  EDGEPT *p;                     /* Iterator */
  EDGEPT *this_edgept;           /* Iterator */
  int x = split_point->pos.x;    /* X value of vertical */
  int best_dist = LARGE_DISTANCE;/* Best point found */

  if (*best_point != NULL)
    best_dist = edgept_dist(split_point, *best_point);

  p = target_point;
  /* Look at each edge point */
  do {
    if ((((p->pos.x <= x) && (x <= p->next->pos.x)) ||
      ((p->next->pos.x <= x) && (x <= p->pos.x))) &&
      !same_point (split_point->pos, p->pos) &&
      !same_point (split_point->pos, p->next->pos)
    && (*best_point == NULL || !same_point ((*best_point)->pos, p->pos))) {

      this_edgept = near_point (split_point, p, p->next);

      if (*best_point == NULL)
        best_dist = edgept_dist (split_point, this_edgept);

      this_edgept =
        pick_close_point(split_point, this_edgept, &best_dist);
      if (this_edgept)
        *best_point = this_edgept;
    }

    p = p->next;
  }
  while (p != target_point);
}
/////////////////////////////////////////////////////////////////chop////////////////////////////////////////

/////////////////////////////////////////////////////////////////tessinit////////////////////////////////////////
/*----------------------------------------------------------------------
            Variables
----------------------------------------------------------------------*/

INT_VAR(wordrec_plots_fx, 0, "plots_fx");
INT_VAR(wordrec_plots_ocr, 0, "plots_ocr");
INT_VAR(wordrec_debugs_fx, 0, "debugs_fx");
INT_VAR(wordrec_debugs_ocr, 0, "debugs_ocr");
INT_VAR(wordrec_acts_fx, 2048, "acts_fx");
INT_VAR(wordrec_acts_ocr, 32, "acts_ocr");
INT_VAR(wordrec_corner_0, 0, "wordrec_corner_0");
INT_VAR(wordrec_corner_1, 0, "wordrec_corner_1");
INT_VAR(wordrec_corner_2, 2550, "wordrec_corner_2");
INT_VAR(wordrec_corner_3, 3508, "wordrec_corner_3");
INT_VAR(wordrec_resolution, 300, "Resolution");
STRING_VAR(wordrec_debugfile, "debugfile", "Debug file name");

int row_number;

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**
 * @name program_init
 *
 * Initialize all the things in the program that need to be initialized.
 */
void Wordrec::program_init() {
  /* Plots flags */
  plots[OCR1] = wordrec_plots_ocr;
  debugs[OCR1] = wordrec_debugs_ocr;
  acts[OCR1] = wordrec_acts_ocr;
  plots[FX] = wordrec_plots_fx;
  debugs[FX] = wordrec_debugs_fx;
  acts[FX] = wordrec_acts_fx;

  corners[0] = wordrec_corner_0;
  corners[1] = wordrec_corner_1;
  corners[2] = wordrec_corner_2;
  corners[3] = wordrec_corner_3;
}

/**
 * @name matherr
 *
 * Trap procedure for the Standard Math library
 */
#ifdef __UNIX
int
matherr (error)
struct exception *error;
{
  if (error->type == DOMAIN) {
    if (!strcmp (error->name, "sqrt")) {
      cprintf ("Sqrt:Domain error!!\n");
      abort();
    }
    if (!strcmp (error->name, "atan2")) {
      cprintf ("Arc Tangent error: atan2 (%ld, %ld)\n",
        error->arg1, error->arg2);
      abort();
    }
  }
  return 0;                      /*all others default */
}
#endif
/////////////////////////////////////////////////////////////////tessinit////////////////////////////////////////

/////////////////////////////////////////////////////////////////tface////////////////////////////////////////
void Wordrec::mfeature_init() {
  SetupExtractors();
  InitAdaptiveClassifier();
}

const int kReallyBadCertainty = -20;

namespace tesseract
{
class Tesseract;
}

//extern "C" int record_matcher_output;

/*----------------------------------------------------------------------
              Variables
----------------------------------------------------------------------*/
static PRIORITY pass2_ok_split;
static int pass2_seg_states;

BOOL_VAR(wordrec_no_block, false, "Don't output block information");

/*----------------------------------------------------------------------
              Function Code
----------------------------------------------------------------------*/
/**
 * @name start_recog
 *
 * Startup recog program ready to recognize words.
 */
int Wordrec::start_recog(const char *textbase)
{

    program_editup(textbase, true);

    return (0);
}


/**
 * @name program_editup
 *
 * Initialize all the things in the program that need to be initialized.
 * init_permute determines whether to initialize the permute functions
 * and Dawg models.
 */
void Wordrec::program_editup(const char *textbase, bool init_permute)
{
    if (textbase != NULL)
    {
        imagefile = textbase;

        /* Read in data files */
        edit_with_ocr(textbase);
    }

    /* Initialize subsystems */
    program_init();
    mfeature_init();  // assumes that imagefile is initialized
    if (init_permute) getDict().init_permute();
    setup_cp_maps();

    init_metrics();
    pass2_ok_split = chop_ok_split;
    pass2_seg_states = wordrec_num_seg_states;
}

/**
 * @name edit_with_ocr
 *
 * Initialize all the things in the program needed before the classifier
 * code is called.
 */
void edit_with_ocr(const char *imagename)
{
    char name[FILENAMESIZE];       /*base name of file */

    if (tord_write_output)
    {
        strcpy(name, imagename);
        strcat (name, ".txt");
        //xiaofan
        textfile = open_file (name, "w");
    }

    if (tord_write_raw_output)
    {
        strcpy(name, imagename);
        strcat (name, ".raw");
        rawfile = open_file (name, "w");
    }

    if (record_matcher_output)
    {
        strcpy(name, imagename);
        strcat (name, ".mlg");
        matcher_fp = open_file (name, "w");
        strcpy(name, imagename);
        strcat (name, ".ctx");
        correct_fp = open_file (name, "r");
    }
}


/**
 * @name end_recog
 *
 * Cleanup and exit the recog program.
 */
int Wordrec::end_recog()
{
    program_editdown (0);

    return (0);
}


/**
 * @name program_editdown
 *
 * This function holds any nessessary post processing for the Wise Owl
 * program.
 */
void Wordrec::program_editdown(inT32 elasped_time)
{
    dj_cleanup();
    if (tord_display_text) cprintf ("\n");

    if (!wordrec_no_block && tord_write_output) fprintf (textfile, "\n");

    if (tord_write_raw_output) fprintf (rawfile, "\n");

    if (tord_write_output)
    {
#ifdef __UNIX__
        fsync (fileno (textfile));
#endif
        fclose(textfile);
    }

    if (tord_write_raw_output)
    {
#ifdef __UNIX__
        fsync (fileno (rawfile));
#endif
        fclose(rawfile);
    }

    close_choices();
    if (tessedit_save_stats) save_summary (elasped_time);

    end_match_table();
    getDict().InitChoiceAccum();

    if (global_hash != NULL)
    {
        free_mem(global_hash);
        global_hash = NULL;
    }

    end_metrics();
    getDict().end_permute();
}


/**
 * @name set_pass1
 *
 * Get ready to do some pass 1 stuff.
 */
void Wordrec::set_pass1()
{
    tord_blob_skip.set_value(false);
    chop_ok_split.set_value(70.0);
    wordrec_num_seg_states.set_value(15);
    SettupPass1();
    first_pass = 1;
}


/**
 * @name set_pass2
 *
 * Get ready to do some pass 2 stuff.
 */
void Wordrec::set_pass2()
{
    tord_blob_skip.set_value(false);
    chop_ok_split.set_value(pass2_ok_split);
    wordrec_num_seg_states.set_value(pass2_seg_states);
    SettupPass2();
    first_pass = 0;
}


/**
 * @name cc_recog
 *
 * Recognize a word.
 */
BLOB_CHOICE_LIST_VECTOR *Wordrec::cc_recog(TWERD *tessword, WERD_CHOICE *best_choice, WERD_CHOICE *best_raw_choice,
                                           BOOL8 tester, BOOL8 trainer, bool last_word_on_line)
{
    int fx;
    BLOB_CHOICE_LIST_VECTOR *results;          /*matcher results */

    if (SetErrorTrap (NULL))
    {
        cprintf ("Tess copped out!\n");
        ReleaseErrorTrap();
        class_string (best_choice) = NULL;
        return NULL;
    }

    getDict().InitChoiceAccum();
    getDict().reset_hyphen_vars(last_word_on_line);
    init_match_table();

    for (fx = 0; fx < MAX_FX && (acts[OCR1] & (FXSELECT << fx)) == 0; fx++);
    results = chop_word_main(tessword, fx, best_choice, best_raw_choice, tester, trainer);
    getDict().DebugWordChoices();
    ReleaseErrorTrap();

    return results;
}


/**
 * @name dict_word()
 *
 * Test the dictionaries, returning NO_PERM (0) if not found, or one
 * of the PermuterType values if found, according to the dictionary.
 */
int Wordrec::dict_word(const WERD_CHOICE &word)
{
    return getDict().valid_word(word);
}

/**
 * @name call_matcher
 *
 * Called from Tess with a blob in tess form.
 * Convert the blob to editor form.
 * Call the matcher setup by the segmenter in tess_matcher.
 * Convert the output choices back to tess form.
 */
BLOB_CHOICE_LIST *Wordrec::call_matcher(TBLOB *ptblob,    //< previous blob
                                        TBLOB *tessblob,  //< blob to match
                                        TBLOB *ntblob,    //< next blob
                                        void *,           //< unused parameter
                                        TEXTROW *         //< always null anyway
                                        )
{
    PBLOB *pblob;                  //converted blob
    PBLOB *blob;                   //converted blob
    PBLOB *nblob;                  //converted blob
    BLOB_CHOICE_LIST *ratings = new BLOB_CHOICE_LIST();  // matcher result

    blob = make_ed_blob (tessblob);//convert blob
    if (blob == NULL)
    {
        // Since it is actually possible to get a NULL blob here, due to invalid
        // segmentations, fake a really bad classification.
        BLOB_CHOICE *choice = new BLOB_CHOICE(0, static_cast<float>(MAX_NUM_INT_FEATURES), static_cast<float>(-MAX_FLOAT32), 0, 0);
        BLOB_CHOICE_IT temp_it;
        temp_it.set_to_list(ratings);
        temp_it.add_after_stay_put(choice);

        return ratings;
    }

    pblob = ptblob != NULL ? make_ed_blob (ptblob) : NULL;
    nblob = ntblob != NULL ? make_ed_blob (ntblob) : NULL;

    // Because of the typedef for tess_matcher, the object on which it is called
    // must be of type Tesseract*. With a Wordrec type it seems it doesn't work.
    (reinterpret_cast<Tesseract* const>(this)->*tess_matcher)(pblob, blob, nblob, tess_word, tess_denorm, ratings, NULL);

    //match it
    delete blob;                   //don't need that now

    if (pblob != NULL)
    {
        delete pblob;
    }

    if (nblob != NULL)
    {
        delete nblob;
    }

    return ratings;
}

/**
 * @name make_ed_blob
 *
 * Make an editor format blob from the tess style blob.
 */

//construct blob    //< blob to convert
PBLOB *make_ed_blob(TBLOB *tessblob)
{
    TESSLINE *tessol;              //tess outline
    FRAGMENT_LIST fragments;       //list of fragments
    OUTLINE *outline;              //current outline
    OUTLINE_LIST out_list;         //list of outlines
    OUTLINE_IT out_it = &out_list; //iterator

    for (tessol = tessblob->outlines; tessol != NULL; tessol = tessol->next)
    {
        register_outline(tessol, &fragments); //stick in list
    }

    while (!fragments.empty ())
    {
        outline = make_ed_outline (&fragments);
        if (outline != NULL)
        {
            out_it.add_after_then_move (outline);
        }
    }

    if (out_it.empty()) return NULL;                 //couldn't do it

    return new PBLOB (&out_list);  //turn to blob
}
/**
 * @name make_ed_outline
 *
 * Make an editor format outline from the list of fragments.
 */

//constructoutline       //< list of fragments
OUTLINE *make_ed_outline(FRAGMENT_LIST *list)
{
    FRAGMENT *fragment;            //current fragment
    EDGEPT *edgept;                //current point
    ICOORD headpos;                //coords of head
    ICOORD tailpos;                //coords of tail
    FCOORD pos;                    //coords of edgept
    FCOORD vec;                    //empty
    POLYPT *polypt;                //current point
    POLYPT_LIST poly_list;         //list of point
    POLYPT_IT poly_it = &poly_list;//iterator
    FRAGMENT_IT fragment_it = list;//fragment

    headpos = fragment_it.data ()->head;
    do
    {
        fragment = fragment_it.data ();
        edgept = fragment->headpt;   //start of segment

        do
        {
            pos = FCOORD (edgept->pos.x, edgept->pos.y);
            vec = FCOORD (edgept->vec.x, edgept->vec.y);
            polypt = new POLYPT (pos, vec);
            //add to list
            poly_it.add_after_then_move (polypt);
            edgept = edgept->next;
        }

        while (edgept != fragment->tailpt);
        tailpos = ICOORD (edgept->pos.x, edgept->pos.y);

        //get rid of it
        delete fragment_it.extract ();
        if (tailpos != headpos)
        {
            if (fragment_it.empty ())
            {
                return NULL;
            }

            fragment_it.forward ();

            //find next segment
            for (fragment_it.mark_cycle_pt (); !fragment_it.cycled_list () && fragment_it.data ()->head != tailpos; fragment_it.forward ());
            if (fragment_it.data ()->head != tailpos)
            {
                // It is legitimate for the heads to not all match to tails,
                // since not all combinations of seams always make sense.
                for (fragment_it.mark_cycle_pt (); !fragment_it.cycled_list (); fragment_it.forward ())
                {
                    fragment = fragment_it.extract ();
                    delete fragment;
                }

                return NULL;             //can't do it
            }
        }
    }
    while (tailpos != headpos);

    return new OUTLINE (&poly_it); //turn to outline
}
/**
 * @name register_outline
 *
 * Add the fragments in the given outline to the list
 */

void register_outline(                     //add fragments
                                           TESSLINE *outline,   //< tess format
                                           FRAGMENT_LIST *list  //< list to add to
                                           )
{
    EDGEPT *startpt;               //start of outline
    EDGEPT *headpt;                //start of fragment
    EDGEPT *tailpt;                //end of fragment
    FRAGMENT *fragment;            //new fragment
    FRAGMENT_IT it = list;         //iterator

    startpt = outline->loop;
    do
    {
        startpt = startpt->next;
        if (startpt == NULL) return;//illegal!
    }
    while (startpt->flags[0] == 0 && startpt != outline->loop);
    headpt = startpt;

    do
        startpt = startpt->next;
    while (startpt->flags[0] != 0 && startpt != headpt);

    if (startpt->flags[0] != 0) return;//all hidden!

    headpt = startpt;
    do
    {
        tailpt = headpt;

        do
            tailpt = tailpt->next;
        while (tailpt->flags[0] == 0 && tailpt != startpt);

        fragment = new FRAGMENT (headpt, tailpt);
        it.add_after_then_move (fragment);

        while (tailpt->flags[0] != 0)
        {
            tailpt = tailpt->next;
        }
        headpt = tailpt;
    }
    while (tailpt != startpt);
}

//ELISTIZE(FRAGMENT)

///**
// * @name FRAGMENT::FRAGMENT
// *
// * Constructor for fragments.
// */
//FRAGMENT::FRAGMENT (             //constructor
//                                 EDGEPT * head_pt,                //< start point
//                                 EDGEPT * tail_pt                 //< end point
//                                 ):head (head_pt->pos.x, head_pt->pos.y), tail (tail_pt->pos.x,tail_pt->pos.y)
//{
//    headpt = head_pt;              // save ptrs
//    tailpt = tail_pt;
//}
/////////////////////////////////////////////////////////////////tface////////////////////////////////////////

/////////////////////////////////////////////////////////////////ocrshell////////////////////////////////////////
#define EXTERN

#ifdef __UNIX__
EXTERN ESHM_INFO shm;            /*info on shm */
#define TICKS       1
#endif

#ifdef __MSW32__
EXTERN ESHM_INFO shm;            /*info on shm */
#define TICKS       1000
#endif

#ifdef __MAC__

#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)
#pragma import on
#endif

extern volatile ESHM_INFO shm;   /*info on shm */
extern unsigned short WaitForSingleObject(  /*"C" */
                                          volatile Boolean &semaphore,
                                          unsigned long timeout);
extern unsigned short ReleaseSemaphore(  /*"C" */
                                       volatile Boolean &semaphore);
#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)
#pragma import reset
#endif
#define WAIT_OBJECT_0   1
#define TICKS       60
#endif

typedef enum {
  OCS_UNINIT,                    /*uninitialized */
  OCS_SETUP_SHM,                 /*shm setup done */
  OCS_SETUP_INFO,                /*startinfo sent */
  OCS_READING_STRIPS,            /*read first but more to come */
  OCS_READ_STRIPS,               /*read all but no monitor yet */
  OCS_RECOGNIZING,               /*OCR incomplete */
  OCS_SENDING_TEXT,              /*sent buffer but more to come */
  OCS_DEAD                       /*disconnected */
} OCR_STATE;

/* forward declarations - not in .h file as not needed outside this file*/
inT16 ocr_internal_shutdown();  /*closedown */
inT16 wait_for_mutex();  /*wait for HP to be ready */
inT16 wait_for_hp(               /*wait for semaphore */
                  inT32 timeout  /*in seconds */
                 );
inT16 release_mutex();  /*release mutex */
inT16 release_ocr();  /*release semaphore */

static inT32 font_count = 0;     /*number of fonts */
static inT16 lines_read = 0;     /*no read in this image */
                                 /*current state */
static OCR_STATE ocr_state = OCS_UNINIT;

#ifdef __MAC__
pascal short TerminateOCR(AppleEvent *theEvent,
                          AppleEvent *theReply,
                          long refCon) {
  ocr_internal_shutdown();
  ExitToShell();

}
#endif

/**********************************************************************
 * ocr_open_shm
 *
 * Attempt to connect to the shared memory segment and semaphores used
 * in talking to the OCR engine. Called from OCR engine.
 * The parameters are the command line arguments in order.
 **********************************************************************/
#ifdef __MAC__
inT16
ocr_open_shm (uinT16 * lang)
#else
inT16
ocr_open_shm (                   /*open the shm */
const char *shm_h,               /*handle of shm */
const char *shm_size,            /*size of shm segment */
const char *mutex_h,             /*hp mutex */
const char *ocr_h,               /*ocr semaphore */
const char *hp_h,                /*hp semaphore */
const char *lang_str,            /*language */
uinT16 * lang                    /*required language */
)
#endif
{
  Q_UNUSED(shm_h);
  Q_UNUSED(shm_size);
  Q_UNUSED(mutex_h);
  Q_UNUSED(ocr_h);
  Q_UNUSED(hp_h);
  font_count = 0;                /*no fonts yet */
  #ifdef __MAC__
  if (shm.OCRProcess.lowLongOfPSN && shm.OCRProcess.highLongOfPSN)
    return HPERR;
  *lang = shm.language;
  GetCurrentProcess (&shm.OCRProcess);
  if (WakeUpProcess (&shm.IPEProcess))
    ExitToShell();
  AEInstallEventHandler (kCoreEventClass, kAEQuitApplication,
    (AEEventHandlerUPP) TerminateOCR, 0, FALSE);
  #else
  if (lang != NULL)
                                 /*get language */
    *lang = (uinT16) strtol (lang_str, NULL, 10);
  #endif
  if (ocr_state != OCS_UNINIT) {
    ocr_error(OCR_ERR_BAD_STATE);
    return OCR_API_BAD_STATE;    /*incorrect state */
  }
  #ifdef __MSW32__
  shm.shm_size = strtol (shm_size, NULL, 10);
                                 /*convert to handle */
  shm.shm_hand = (HANDLE) strtol (shm_h, NULL, 10);
  shm.shm_mem = MapViewOfFile (shm.shm_hand, FILE_MAP_WRITE, 0, 0, 0);
  if (shm.shm_mem == NULL)
    return HPERR;                /*failed */
                                 /*convert to handle */
  shm.mutex = (HANDLE) strtol (mutex_h, NULL, 10);
                                 /*convert to handle */
  shm.ocr_sem = (HANDLE) strtol (ocr_h, NULL, 10);
                                 /*convert to handle */
  shm.hp_sem = (HANDLE) strtol (hp_h, NULL, 10);
  #endif

  ocr_state = OCS_SETUP_SHM;     /*record state */
  return OKAY;

}


/**********************************************************************
 * ocr_error
 *
 * Inform the HP side of an error.
 * The OCR engine should do any cleanup of its own and exit aferwards.
 * Uses the current state to determine how to send it and cleanup.
 **********************************************************************/

void ocr_error(                   /*send an error code */
               OCR_ERR_CODE code  /*error code */
              ) {
  ESTRIP_DESC *strip = (ESTRIP_DESC *) shm.shm_mem;
  /*strip info */
  ETEXT_DESC *monitor = (ETEXT_DESC *) shm.shm_mem;
  /*progress monitor */

  switch (ocr_state) {
    case OCS_UNINIT:             /*uninitialized */
    case OCS_DEAD:               /*uninitialized */
      return;                    /*can't do anything else */
    case OCS_SETUP_SHM:          /*shm setup done */
      if (font_count < 1)
        font_count = 1;
      ocr_setup_startinfo_ansi (-code, LANGE_NONE, "", "");
      /*report error */
      break;
    case OCS_SETUP_INFO:         /*startinfo sent */
      if (ocr_get_first_image_strip () == NULL)
        break;                   /*disconnected */
    case OCS_READING_STRIPS:     /*read first but more to come */
      strip->x_size = -code;     /*report error */
      release_ocr();  /*send ack */
      release_mutex();
      break;
    case OCS_READ_STRIPS:        /*read all but no monitor yet */
      monitor->count = 0;        /*chars in this buffer(-1) */
      monitor->progress = 0;     /*percent complete increasing (0-100) */
                                 /*text not complete */
      monitor->more_to_come = FALSE;
      monitor->ocr_alive = TRUE; /*ocr sets to 1, hp 0 */
      monitor->err_code = -code; /*report error */
      monitor->cancel = 0;   /*0=continue, 1=cancel */
      release_ocr();  /*send ack */
      break;
    case OCS_RECOGNIZING:        /*OCR incomplete */
    case OCS_SENDING_TEXT:       /*sent buffer but more to come */
      monitor->err_code = -code; /*report error */
      release_ocr();  /*send ack */
  }
  ocr_internal_shutdown();  /*get ready for exit */
}


/**********************************************************************
 * ocr_append_fontinfo
 *
 * Initialize one of the font descriptors.
 **********************************************************************/

inT16 ocr_append_fontinfo(                    /*put info into shm */
                          uinT16 language,    /*default language */
                          uinT8 font_family,  /*serif/not, fixed/not */
                          uinT8 char_set,     /*character set standard */
                          uinT8 pitch,        /*fixed or prop */
                          const char *name    /*plain ascii name */
                         ) {
  EOCR_DESC *desc;               /*ocr engine info */
  int index;                     /*char index */
  inT32 font_index;              /*which font */

  if (ocr_state != OCS_SETUP_SHM) {
    ocr_error(OCR_ERR_BAD_STATE);
    return OCR_API_BAD_STATE;    /*incorrect state */
  }

                                 /*turn to right type */
  desc = (EOCR_DESC *) shm.shm_mem;
  if (font_count >
    (inT32) ((shm.shm_size - sizeof (EOCR_DESC)) / sizeof (EFONT_DESC)))
    return OCR_API_NO_MEM;       /*insufficient space */
  font_index = font_count++;     /*add a font */
                                 /*setup structure */
  desc->fonts[font_index].language = language;
                                 /*setup structure */
  desc->fonts[font_index].font_family = font_family;
                                 /*setup structure */
  desc->fonts[font_index].char_set = char_set;
                                 /*setup structure */
  desc->fonts[font_index].pitch = pitch;
  if (name != NULL) {
    for (index = 0; index < MAX_FONT_NAME && name[index] != 0; index++)
      desc->fonts[font_index].name[index] = name[index];
  }
  else
    index = 0;
  desc->fonts[font_index].name[index] = 0;
  return OKAY;
}


/**********************************************************************
 * ocr_setup_startinfo
 *
 * Setup the info on the OCR engine. Uses 16 bit chars to name the
 * engine.
 **********************************************************************/

inT16 ocr_setup_startinfo(                       /*put info into shm */
                          inT32 protocol,        /*interface version */
                          uinT16 language,       /*default language */
                          const uinT16 *name,    /*name of engine */
                          const uinT16 *version  /*version of engine */
                         ) {
  EOCR_DESC *desc;               /*ocr engine info */
  int index;                     /*char index */
  inT16 result;                  /*from open */

  if (ocr_state != OCS_SETUP_SHM || font_count < 1) {
    ocr_error(OCR_ERR_BAD_STATE);
    return OCR_API_BAD_STATE;    /*incorrect state */
  }

                                 /*turn to right type */
  desc = (EOCR_DESC *) shm.shm_mem;
  desc->protocol = protocol;     /*setup structure */
  desc->font_count = font_count;
  desc->language = language;
  for (index = 0; index < MAX_OCR_NAME && name[index] != 0; index++)
    desc->name[index] = name[index];
  desc->name[index] = 0;
  for (index = 0; index < MAX_OCR_VERSION && version[index] != 0; index++)
    desc->version[index] = version[index];
  desc->version[index] = 0;

  result = release_ocr ();
  if (result != OKAY)
    return result;
  ocr_state = OCS_SETUP_INFO;    /*record state */
  return OKAY;
}


/**********************************************************************
 * ocr_setup_startinfo_ansi
 *
 * Setup the info on the OCR engine. Uses 8 bit chars to name the
 * engine.
 **********************************************************************/

inT16 ocr_setup_startinfo_ansi(                     /*put info into shm */
                               uinT32 protocol,     /*interface version */
                               uinT16 language,     /*default language */
                               const char *name,    /*name of engine */
                               const char *version  /*version of engine */
                              ) {
  EOCR_DESC *desc;               /*ocr engine info */
  int index;                     /*char index */
  inT16 result;                  /*from open */

  if (ocr_state != OCS_SETUP_SHM || font_count < 1) {
    ocr_error(OCR_ERR_BAD_STATE);
    return OCR_API_BAD_STATE;    /*incorrect state */
  }

                                 /*turn to right type */
  desc = (EOCR_DESC *) shm.shm_mem;
  desc->protocol = protocol;     /*setup structure */
  desc->font_count = font_count;
  desc->language = language;
  for (index = 0; index < MAX_OCR_NAME && name[index] != 0; index++)
    desc->name[index] = name[index];
  desc->name[index] = 0;
  for (index = 0; index < MAX_OCR_VERSION && version[index] != 0; index++)
    desc->version[index] = version[index];
  desc->version[index] = 0;

  result = release_ocr ();
  if (result != OKAY)
    return result;
  ocr_state = OCS_SETUP_INFO;    /*record state */
  return OKAY;
}


/**********************************************************************
 * ocr_get_first_image_strip
 *
 * Wait for the master to send the first image strip and return a
 * pointer to it. The result is NULL if it is time to exit.
 **********************************************************************/

ESTRIP_DESC *ocr_get_first_image_strip() {  /*get image strip */
  ESTRIP_DESC *strip;            /*strip info */
  inT16 result;                  /*of wait/release */

  if (ocr_state != OCS_SETUP_INFO) {
    tprintf ("Bad state reading strip");
    ocr_error(OCR_ERR_BAD_STATE);
    return NULL;                 /*incorrect state */
  }

                                 /*strip info */
  strip = (ESTRIP_DESC *) shm.shm_mem;
  lines_read = 0;

  result = wait_for_mutex ();
  if (result != OKAY) {
    tprintf ("Mutax wait failed reading strip");
    return NULL;                 /*HP dead */
  }
  result = release_mutex ();
  if (result != OKAY) {
    tprintf ("Mutax release failed reading strip");
    return NULL;                 /*HP dead */
  }
  result = wait_for_hp (READIM_TIMEOUT);
  if (result != OKAY) {
    tprintf ("Wait for HP failed reading strip");
    return NULL;                 /*HP dead */
  }
  lines_read = strip->strip_size;/*lines read so far */
  if (lines_read < strip->y_size)
                                 /*record state */
      ocr_state = OCS_READING_STRIPS;
  else
    ocr_state = OCS_READ_STRIPS;
  if (strip->x_size == 0 || strip->y_size == 0)
    return NULL;                 /*end of job */

  return strip;
}


/**********************************************************************
 * ocr_get_next_image_strip
 *
 * Wait for the master to send the next image strip and return a
 * pointer to it. The result is NULL if it is time to exit.
 **********************************************************************/

ESTRIP_DESC *ocr_get_next_image_strip() {  /*get image strip */
  ESTRIP_DESC *strip;            /*strip info */
  inT16 result;                  /*of wait/release */

  if (ocr_state != OCS_READING_STRIPS) {
    ocr_error(OCR_ERR_BAD_STATE);
    return NULL;                 /*incorrect state */
  }

                                 /*strip info */
  strip = (ESTRIP_DESC *) shm.shm_mem;
  result = release_ocr ();
  if (result != OKAY)
    return NULL;                 /*HP dead */
  result = wait_for_hp (READIM_TIMEOUT);
  if (result != OKAY)
    return NULL;                 /*HP dead */
                                 /*lines read so far */
  lines_read += strip->strip_size;
  if (lines_read < strip->y_size)
                                 /*record state */
      ocr_state = OCS_READING_STRIPS;
  else
    ocr_state = OCS_READ_STRIPS;

  return strip;
}


/**********************************************************************
 * ocr_setup_monitor
 *
 * Setup the progress monitor. Call before starting the recognize task.
 **********************************************************************/

ETEXT_DESC *ocr_setup_monitor() {  /*setup monitor */
  ETEXT_DESC *monitor;           /*progress monitor */

                                 /*text info */
  monitor = (ETEXT_DESC *) shm.shm_mem;
  monitor->count = 0;            /*chars in this buffer(-1) */
  monitor->progress = 0;         /*percent complete increasing (0-100) */
  monitor->more_to_come = TRUE;  /*text not complete */
  monitor->ocr_alive = TRUE;     /*ocr sets to 1, hp 0 */
  monitor->err_code = 0;         /*used by ocr_error */
  monitor->cancel = 0;       /*0=continue, 1=cancel */


//by jetsoft
//the sem functions are old and were meant for an hp product
 // if (release_ocr () != OKAY)
   // return NULL;                 /*release failed */

  ocr_state = OCS_RECOGNIZING;   /*record state */
  return monitor;
}


/**********************************************************************
 * ocr_char_space
 *
 * Return the number of chars that can be fitted into the buffer.
 **********************************************************************/

inT32 ocr_char_space() {  /*put char into shm */
  ETEXT_DESC *buf;               /*text buffer */
  int result;

                                 /*progress info */
  buf = (ETEXT_DESC *) shm.shm_mem;
  if (buf == NULL)
    return 0;

  result =
    (shm.shm_size - sizeof (ETEXT_DESC)) / sizeof (EANYCODE_CHAR) -
    buf->count + 1;

  //      while (buf->hp_alive==-1)
  //              Sleep(50);                                                                              /*wait for HP*/

  return result;
}


/**********************************************************************
 * ocr_append_char
 *
 * Add a character to the output. Returns OKAY if successful, OCR_API_NO_MEM
 * if there was insufficient room in the buffer.
 **********************************************************************/

inT16 ocr_append_char(                              /*put char into shm */
                      uinT16 char_code,             /*character itself */
                      inT16 left,                   /*of char (-1) */
                      inT16 right,                  /*of char (-1) */
                      inT16 top,                    /*of char (-1) */
                      inT16 bottom,                 /*of char (-1) */
                      inT16 font_index,             /*what font (-1) */
                      uinT8 confidence,             /*0=perfect, 100=reject (0/100) */
                      uinT8 point_size,             /*of char, 72=i inch, (10) */
                      inT8 blanks,                  /*no of spaces before this char (1) */
                      uinT8 enhancement,            /*char enhancement (0) */
                      OCR_CHAR_DIRECTION text_dir,  /*rendering direction (OCR_CDIR_RIGHT_LEFT) */
                      OCR_LINE_DIRECTION line_dir,  /*line rendering direction (OCR_LDIR_DOWN_RIGHT) */
                      OCR_NEWLINE_TYPE nl_type      /*type of newline (if any) (OCR_NL_NONE) */
                     ) {
  ETEXT_DESC *buf;               /*text buffer */
  int index;                     /*char index */
  inT16 result;                  /*of callback */

  if (ocr_state != OCS_RECOGNIZING && ocr_state != OCS_SENDING_TEXT) {
    ocr_error(OCR_ERR_BAD_STATE);
    return OCR_API_BAD_STATE;    /*incorrect state */
  }

  if (char_code == ' ' || char_code == '\n' || char_code == '\r'
    || char_code == '\t')
    return OCR_API_BAD_CHAR;     /*illegal char */

                                 /*progress info */
  buf = (ETEXT_DESC *) shm.shm_mem;

  result =
    (shm.shm_size - sizeof (ETEXT_DESC)) / sizeof (EANYCODE_CHAR) -
    buf->count;
  if (result < 1)
    return OCR_API_NO_MEM;       /*insufficient room */

  index = buf->count++;          /*count of chars */
                                 /*setup structure */
  buf->text[index].char_code = char_code;
  buf->text[index].left = left;  /*setup structure */
  buf->text[index].right = right;/*setup structure */
  buf->text[index].top = top;    /*setup structure */
                                 /*setup structure */
  buf->text[index].bottom = bottom;
                                 /*setup structure */
  buf->text[index].font_index = font_index;
                                 /*setup structure */
  buf->text[index].confidence = confidence;
                                 /*setup structure */
  buf->text[index].point_size = point_size;
                                 /*setup structure */
  buf->text[index].blanks = blanks;
  if (nl_type == OCR_NL_NONE) {
    if (text_dir == OCR_CDIR_TOP_BOTTOM || text_dir == OCR_CDIR_BOTTOM_TOP)
      buf->text[index].formatting = (text_dir << 5) | 128;
    /*setup structure */
    else
                                 /*setup structure */
      buf->text[index].formatting = text_dir << 5;
  }
  else {
    buf->text[index].formatting = (nl_type << 6) | (line_dir << 5);
    /*setup structure */
  }
  buf->text[index].formatting |= enhancement & (~EUC_FORMAT_MASK);
  return OKAY;
}


/**********************************************************************
 * ocr_send_text
 *
 * Send the text to the host and wait for the ack.
 * Use this function after a sequence of ocr_append_char calls to
 * actually sent the text to the master process.
 * Set more to come TRUE if there is more text in this page, FALSE
 * if the OCR engine is now ready to receive another image.
 **********************************************************************/

inT16 ocr_send_text(                    /*send shm */
                    BOOL8 more_to_come  /*any text left */
                   ) {
  ETEXT_DESC *buf;               /*text buffer */

  if (ocr_state != OCS_RECOGNIZING && ocr_state != OCS_SENDING_TEXT) {
    ocr_error(OCR_ERR_BAD_STATE);
    return OCR_API_BAD_STATE;    /*incorrect state */
  }

                                 /*progress info */
  buf = (ETEXT_DESC *) shm.shm_mem;

                                 /*setup structure */
  buf->more_to_come = more_to_come;
  if (more_to_come) {
    if ((buf->text[buf->count - 1].formatting >> 6) != OCR_NL_NEWLINE
    && (buf->text[buf->count - 1].formatting >> 6) != OCR_NL_NEWPARA) {
                                 /*force line end */
      buf->text[buf->count - 1].formatting &= 63;
      buf->text[buf->count - 1].formatting |= OCR_NL_NEWLINE << 6;
    }
  }
  else {
    if (buf->count < 1)
      ocr_append_char ('~', -1, -1, -1, -1, 0, 100, 10, 0,
        0, OCR_CDIR_RIGHT_LEFT, OCR_LDIR_DOWN_RIGHT,
        OCR_NL_NEWPARA);
    /*dummy character */
    else if ((buf->text[buf->count - 1].formatting >> 6) != OCR_NL_NEWPARA) {
                                 /*force para end */
      buf->text[buf->count - 1].formatting &= 63;
      buf->text[buf->count - 1].formatting |= OCR_NL_NEWPARA << 6;
    }
  }

  if (release_ocr () != OKAY)
    return HPERR;                /*release failed */
  if (wait_for_hp (READTEXT_TIMEOUT) != OKAY)
    return HPERR;
  if (more_to_come) {
    buf->count = 0;              /*setup structure */
    ocr_state = OCS_SENDING_TEXT;/*record state */
  }
  else
    ocr_state = OCS_SETUP_INFO;  /*record state */
  return OKAY;
}


/**********************************************************************
 * ocr_shutdown
 *
 * Closedown communications with the HP side and free up handles.
 **********************************************************************/

inT16 ocr_shutdown() {  /*closedown */
  #ifdef __MAC__
  shm.OCRProcess.lowLongOfPSN = kNoProcess;
  shm.OCRProcess.highLongOfPSN = 0;
  #endif
  ocr_error(OCR_ERR_CLEAN_EXIT);  /*signal exit */

  return OKAY;
}


/**********************************************************************
 * ocr_internal_shutdown
 *
 * Free up handles or whatever to clean up without attempting to communicate.
 **********************************************************************/

inT16 ocr_internal_shutdown() {  /*closedown */
  ocr_state = OCS_DEAD;          /*record state */
  #ifdef __MSW32__
  if (shm.shm_mem != NULL) {
    UnmapViewOfFile (shm.shm_mem);
    CloseHandle (shm.shm_hand);  /*no longer used */
    CloseHandle (shm.mutex);     /*release handles */
    CloseHandle (shm.ocr_sem);
    CloseHandle (shm.hp_sem);
    shm.shm_mem = NULL;
  }
  #elif defined (__MAC__)
  shm.OCRProcess.lowLongOfPSN = kNoProcess;
  shm.OCRProcess.highLongOfPSN = 0;
  #endif
  return OKAY;
}


/**********************************************************************
 * wait_for_mutex
 *
 * Wait for the HP side to release its mutex.
 * The return value is HPERR if the HP side has terminated.
 **********************************************************************/

inT16 wait_for_mutex() {  /*wait for HP to be ready */
  inT16 result = HPERR;          /*return code */
  #if defined (__MSW32__) || defined (__MAC__)
  result = WaitForSingleObject (shm.mutex, (unsigned long) -1)
  /*wait for thread to move */
                                 /*bad if timeout */
    == WAIT_OBJECT_0 ? OKAY : HPERR;
  #endif
  if (result != OKAY)
    ocr_internal_shutdown();
  return result;
}


/**********************************************************************
 * wait_for_hp
 *
 * Wait for the HP side to release its semaphore.
 * The return value is HPERR if the timeout (in seconds) elapsed.
 **********************************************************************/

inT16 wait_for_hp(               /*wait for semaphore */
                  inT32 timeout  /*in seconds */
                 )
{
    Q_UNUSED(timeout);
  inT16 result = HPERR;          /*return code */
  #if defined (__MSW32__) || defined (__MAC__)
                                 /*wait for thread to move */
  result = WaitForSingleObject (shm.hp_sem, timeout * TICKS)
                                 /*bad if timeout */
    == WAIT_OBJECT_0 ? OKAY : HPERR;
  #endif
  if (result != OKAY)
    ocr_internal_shutdown();
  return result;
}


/**********************************************************************
 * release_mutex
 *
 * Release the HP mutex.
 * The return value is OKAY if the call succeeds.
 **********************************************************************/

inT16 release_mutex() {  /*release mutex */
  inT16 result = HPERR;          /*return code */
  #ifdef __MSW32__
                                 /*release it */
  result = ReleaseMutex (shm.mutex) ? OKAY : HPERR;
  #elif defined (__MAC__)
                                 /*release it */
  result = ReleaseSemaphore (shm.mutex) ? OKAY : HPERR;
  #endif
  if (result != OKAY)
    ocr_internal_shutdown();
  return result;
}


/**********************************************************************
 * release_ocr
 *
 * Release the OCR semaphore.
 * The return value is OKAY if the call succeeds.
 **********************************************************************/

inT16 release_ocr() {  /*release semaphore */
  #ifdef __MSW32__

//jetsoft
// this stuff is old and no longer applies

  return OKAY;
//

  BOOL result = 0;               //of release
  do {
                                 //release it
    result = ReleaseSemaphore (shm.ocr_sem, 1, NULL);
    if (result == FALSE) {
      timeout -= 50;
      Sleep (50);
    }
  }
  while (result == FALSE && timeout > 0);
  if (!result)
    ocr_internal_shutdown();
  return OKAY;
  #elif defined (__MAC__)
  inT16 result = HPERR;          /*return code */
                                 /*release it */
  result = ReleaseSemaphore (shm.ocr_sem) ? OKAY : HPERR;

  if (result != OKAY)
    ocr_internal_shutdown();
  return result;
  #elif defined (__UNIX__)
  return 0;
  #endif
}
/////////////////////////////////////////////////////////////////ocrshell////////////////////////////////////////

/////////////////////////////////////////////////////////////////output////////////////////////////////////////
#define EXTERN
#define EPAPER_EXT      ".ep"
#define PAGE_YSIZE      3508
#define CTRL_INSET      '\024'   //dc4=text inset
#define CTRL_FONT       '\016'   //so=font change
#define CTRL_DEFAULT      '\017' //si=default font
#define CTRL_SHIFT      '\022'   //dc2=x shift
#define CTRL_TAB        '\011'   //tab
#define CTRL_NEWLINE      '\012' //newline
#define CTRL_HARDLINE   '\015'   //cr

EXTERN BOOL_EVAR (tessedit_write_block_separators, FALSE,
"Write block separators in output");
EXTERN BOOL_VAR (tessedit_write_raw_output, FALSE,
"Write raw stuff to name.raw");
EXTERN BOOL_EVAR (tessedit_write_output, FALSE, "Write text to name.txt");
EXTERN BOOL_EVAR (tessedit_write_ratings, FALSE,
"Return ratings in IPEOCRAPI data");
EXTERN BOOL_EVAR (tessedit_write_txt_map, FALSE,
"Write .txt to .etx map file");
EXTERN BOOL_EVAR (tessedit_write_rep_codes, FALSE,
"Write repetition char code");
EXTERN BOOL_EVAR (tessedit_write_unlv, FALSE, "Write .unlv output file");
EXTERN STRING_EVAR (unrecognised_char, "|",
"Output char for unidentified blobs");
EXTERN INT_EVAR (suspect_level, 99, "Suspect marker level");
EXTERN INT_VAR (suspect_space_level, 100,
"Min suspect level for rejecting spaces");
EXTERN INT_VAR (suspect_short_words, 2,
"Dont Suspect dict wds longer than this");
EXTERN BOOL_VAR (suspect_constrain_1Il, FALSE,
"UNLV keep 1Il chars rejected");
EXTERN double_VAR (suspect_rating_per_ch, 999.9,
"Dont touch bad rating limit");
EXTERN double_VAR (suspect_accept_rating, -999.9, "Accept good rating limit");

EXTERN BOOL_EVAR (tessedit_minimal_rejection, FALSE,
"Only reject tess failures");
EXTERN BOOL_VAR (tessedit_zero_rejection, FALSE, "Dont reject ANYTHING");
EXTERN BOOL_VAR (tessedit_word_for_word, FALSE,
"Make output have exactly one word per WERD");
EXTERN BOOL_VAR (tessedit_zero_kelvin_rejection, FALSE,
"Dont reject ANYTHING AT ALL");
EXTERN BOOL_VAR (tessedit_consistent_reps, TRUE,
"Force all rep chars the same");

FILE *txt_mapfile = NULL;        //reject map
FILE *unlv_file = NULL;          //reject map

/**********************************************************************
 * pixels_to_pts
 *
 * Convert an integer number of pixels to the nearest integer
 * number of points.
 **********************************************************************/

inT32 pixels_to_pts(               //convert coords
                    inT32 pixels,
                    inT32 pix_res  //resolution
                   ) {
  float pts;                     //converted value

  pts = pixels * 72.0 / pix_res;
  return (inT32) (pts + 0.5);    //round it
}

void Tesseract::output_pass(  //Tess output pass //send to api
                            PAGE_RES_IT &page_res_it,
                            BOOL8 write_to_shm,
                            TBOX *target_word_box) {
  BLOCK_RES *block_of_last_word;
  inT16 block_id;
  BOOL8 force_eol;               //During output
  BLOCK *nextblock;              //block of next word
  WERD *nextword;                //next word

  if (tessedit_write_txt_map)
    txt_mapfile = open_outfile (".map");

  page_res_it.restart_page ();
  block_of_last_word = NULL;
  while (page_res_it.word () != NULL) {
    check_debug_pt (page_res_it.word (), 120);

    if (target_word_box)
    {

        TBOX current_word_box=page_res_it.word ()->word->bounding_box();
        FCOORD center_pt((current_word_box.right()+current_word_box.left())/2,(current_word_box.bottom()+current_word_box.top())/2);
        if (!target_word_box->contains(center_pt))
        {
            page_res_it.forward ();
            continue;
        }

    }
    if (tessedit_write_block_separators &&
    block_of_last_word != page_res_it.block ()) {
      block_of_last_word = page_res_it.block ();
      block_id = block_of_last_word->block->index();
      if (!wordrec_no_block)
        fprintf (textfile, "|^~tr%d\n", block_id);
      fprintf (txt_mapfile, "|^~tr%d\n", block_id);
    }

    force_eol = (tessedit_write_block_separators &&
      (page_res_it.block () != page_res_it.next_block ())) ||
      (page_res_it.next_word () == NULL);

    if (page_res_it.next_word () != NULL)
      nextword = page_res_it.next_word ()->word;
    else
      nextword = NULL;
    if (page_res_it.next_block () != NULL)
      nextblock = page_res_it.next_block ()->block;
    else
      nextblock = NULL;
                                 //regardless of tilde crunching
    write_results (page_res_it, determine_newline_type (page_res_it.word ()->word, page_res_it.block ()->block, nextword, nextblock), force_eol,
      write_to_shm);
    page_res_it.forward ();
  }
  if (write_to_shm)
    ocr_send_text(FALSE);
  if (tessedit_write_block_separators) {
    if (!wordrec_no_block)
      fprintf (textfile, "|^~tr\n");
    fprintf (txt_mapfile, "|^~tr\n");
  }
  if (tessedit_write_txt_map) {
    fprintf (txt_mapfile, "\n"); //because txt gets one
    #ifdef __UNIX__
    fsync (fileno (txt_mapfile));
    #endif
    fclose(txt_mapfile);
  }
}


/*************************************************************************
 * write_results()
 *
 * All recognition and rejection has now been done. Generate the following:
 *   .txt file     - giving the final best choices with NO highlighting
 *   .raw file     - giving the tesseract top choice output for each word
 *   .map file     - showing how the .txt file has been rejected in the .ep file
 *   epchoice list - a list of one element per word, containing the text for the
 *                   epaper. Reject strings are inserted.
 *   inset list    - a list of bounding boxes of reject insets - indexed by the
 *                   reject strings in the epchoice text.
 *************************************************************************/

void Tesseract::write_results(                        //output a word
                                                      //full info
                              PAGE_RES_IT &page_res_it,
                              char newline_type,      //type of newline
                                                      //override tilde crunch?
                              BOOL8 force_eol,
                              BOOL8 write_to_shm      //send to api
                  ) {
                                 //word to do
  WERD_RES *word = page_res_it.word ();
//   WERD_CHOICE *ep_choice;        //ep format
  STRING repetition_code;
  const STRING *wordstr;
  STRING wordstr_lengths;
  int i;
  char unrecognised = STRING (unrecognised_char)[0];
  char ep_chars[32];             //Only for unlv_tilde_crunch
  int ep_chars_index = 0;
  char txt_chs[32];              //Only for unlv_tilde_crunch
  char map_chs[32];              //Only for unlv_tilde_crunch
  int txt_index = 0;
  static BOOL8 tilde_crunch_written = FALSE;
  static BOOL8 last_char_was_newline = TRUE;
  static BOOL8 last_char_was_tilde = FALSE;
  static BOOL8 empty_block = TRUE;
  BOOL8 need_reject = FALSE;
  PBLOB_IT blob_it;              //blobs
  UNICHAR_ID space = unicharset.unichar_to_id(" ");

  /*	if (word->best_choice->string().length() == 0)
    {
      tprintf("No output: to output\n");
    }
    else if (word->best_choice->string()[0]==' ')
    {
      tprintf("spaceword to output\n");
    }
    else if (word->best_choice->string()[0]=='\0')
    {
      tprintf("null to output\n");
    }*/
  if (word->unlv_crunch_mode != CR_NONE
  && !tessedit_zero_kelvin_rejection && !tessedit_word_for_word) {
    if ((word->unlv_crunch_mode != CR_DELETE) &&
      (!tilde_crunch_written ||
      ((word->unlv_crunch_mode == CR_KEEP_SPACE) &&
      (word->word->space () > 0) &&
      !word->word->flag (W_FUZZY_NON) &&
    !word->word->flag (W_FUZZY_SP)))) {
      if (!word->word->flag (W_BOL) &&
        (word->word->space () > 0) &&
        !word->word->flag (W_FUZZY_NON) &&
      !word->word->flag (W_FUZZY_SP)) {
        /* Write a space to separate from preceeding good text */
        txt_chs[txt_index] = ' ';
        map_chs[txt_index++] = '1';
        ep_chars[ep_chars_index++] = ' ';
        last_char_was_tilde = FALSE;
      }
      need_reject = TRUE;
    }
    if ((need_reject && !last_char_was_tilde) || (force_eol && empty_block)) {
      /* Write a reject char - mark as rejected unless zero_rejection mode */
      last_char_was_tilde = TRUE;
      txt_chs[txt_index] = unrecognised;
      if (tessedit_zero_rejection || (suspect_level == 0)) {
        map_chs[txt_index++] = '1';
        ep_chars[ep_chars_index++] = unrecognised;
      }
      else {
        map_chs[txt_index++] = '0';
        /*
           The ep_choice string is a faked reject to allow newdiff to sync the
           .etx with the .txt and .map files.
         */
        ep_chars[ep_chars_index++] = CTRL_INSET;
        //escape code
                                 //dummy reject
        ep_chars[ep_chars_index++] = 1;
                                 //dummy reject
        ep_chars[ep_chars_index++] = 1;
                                 //type
        ep_chars[ep_chars_index++] = 2;
                                 //dummy reject
        ep_chars[ep_chars_index++] = 1;
                                 //dummy reject
        ep_chars[ep_chars_index++] = 1;
      }
      tilde_crunch_written = TRUE;
      last_char_was_newline = FALSE;
      empty_block = FALSE;
    }

    if ((word->word->flag (W_EOL) && !last_char_was_newline) || force_eol) {
      /* Add a new line output */
      txt_chs[txt_index] = '\n';
      map_chs[txt_index++] = '\n';
                                 //end line
      ep_chars[ep_chars_index++] = newline_type;

                                 //Cos of the real newline
      tilde_crunch_written = FALSE;
      last_char_was_newline = TRUE;
      last_char_was_tilde = FALSE;
    }
    txt_chs[txt_index] = '\0';
    map_chs[txt_index] = '\0';
                                 //xiaofan
    if (tessedit_write_output && !wordrec_no_block)
      fprintf (textfile, "%s", txt_chs);

    if (tessedit_write_txt_map)
      fprintf (txt_mapfile, "%s", map_chs);

                                 //terminate string
    ep_chars[ep_chars_index] = '\0';
    word->ep_choice = new WERD_CHOICE(ep_chars, unicharset);

    if (force_eol)
      empty_block = TRUE;
    return;
  }

  /* NORMAL PROCESSING of non tilde crunched words */

  tilde_crunch_written = FALSE;
  if (newline_type)
    last_char_was_newline = TRUE;
  else
    last_char_was_newline = FALSE;
  empty_block = force_eol;       //About to write a real word

  if (unlv_tilde_crunching &&
      last_char_was_tilde &&
      (word->word->space() == 0) &&
      !(word->word->flag(W_REP_CHAR) && tessedit_write_rep_codes) &&
      (word->best_choice->unichar_id(0) == space)) {
    /* Prevent adjacent tilde across words - we know that adjacent tildes within
       words have been removed */
    word->best_choice->remove_unichar_id(0);
    word->best_choice->populate_unichars(getDict().getUnicharset());
    word->reject_map.remove_pos (0);
    blob_it = word->outword->blob_list ();
    delete blob_it.extract ();   //get rid of reject blob
  }
  if (newline_type ||
    (word->word->flag (W_REP_CHAR) && tessedit_write_rep_codes))
    last_char_was_tilde = FALSE;
  else {
    if (word->reject_map.length () > 0) {
      if (word->best_choice->unichar_id(word->reject_map.length() - 1) == space)
        last_char_was_tilde = TRUE;
      else
        last_char_was_tilde = FALSE;
    }
    else if (word->word->space () > 0)
      last_char_was_tilde = FALSE;
    /* else it is unchanged as there are no output chars */
  }

  ASSERT_HOST (word->best_choice->length() == word->reject_map.length());

  if (word->word->flag (W_REP_CHAR) && tessedit_consistent_reps)
    ensure_rep_chars_are_consistent(word);

  set_unlv_suspects(word);
  check_debug_pt (word, 120);
  if (tessedit_rejection_debug) {
    tprintf ("Dict word: \"%s\": %d\n",
             word->best_choice->debug_string(unicharset).string(),
             dict_word(*(word->best_choice)));
  }

#if 0
  if (tessedit_write_unlv) {
    write_unlv_text(word);
  }
#endif

  if (word->word->flag (W_REP_CHAR) && tessedit_write_rep_codes) {
    repetition_code = "|^~R";
    wordstr_lengths = "\001\001\001\001";
    repetition_code += unicharset.id_to_unichar(get_rep_char (word));
    wordstr_lengths += strlen(unicharset.id_to_unichar(get_rep_char (word)));
    wordstr = &repetition_code;
  }
  else {
    if (tessedit_zero_rejection) {
      /* OVERRIDE ALL REJECTION MECHANISMS - ONLY REJECT TESS FAILURES */
      for (i = 0; i < word->best_choice->length(); ++i) {
        if (word->reject_map[i].rejected())
          word->reject_map[i].setrej_minimal_rej_accept();
      }
    }
    if (tessedit_minimal_rejection) {
      /* OVERRIDE ALL REJECTION MECHANISMS - ONLY REJECT TESS FAILURES */
      for (i = 0; i < word->best_choice->length(); ++i) {
        if ((word->best_choice->unichar_id(i) != space) &&
            word->reject_map[i].rejected())
          word->reject_map[i].setrej_minimal_rej_accept();
      }
    }
  }

  if (write_to_shm)
    write_shm_text (word, page_res_it.block ()->block,
      page_res_it.row (), *wordstr, wordstr_lengths);

#if 0
  if (tessedit_write_output)
    write_cooked_text (word->word, *wordstr, TRUE, FALSE, textfile);

  if (tessedit_write_raw_output)
    write_cooked_text (word->word, word->raw_choice->string (),
      TRUE, FALSE, rawfile);

  if (tessedit_write_txt_map)
    write_map(txt_mapfile, word);

  ep_choice = make_epaper_choice (word, newline_type);
  word->ep_choice = ep_choice;
#endif

  character_count += word->best_choice->length();
  word_count++;
}

/**********************************************************************
 * make_epaper_choice
 *
 * Construct the epaper text string for a word, using the reject map to
 * determine whether each blob should be rejected.
 **********************************************************************/

#if 0
WERD_CHOICE *make_epaper_choice(                   //convert one word
                                WERD_RES *word,    //word to do
                                char newline_type  //type of newline
                               ) {
  inT16 index = 0;               //to string
  inT16 blobindex;               //to word
  inT16 prevright = 0;           //right of previous blob
  inT16 nextleft;                //left of next blob
  PBLOB *blob;
  TBOX inset_box;                 //bounding box
  PBLOB_IT blob_it;              //blob iterator
  char word_string[MAX_PATH];    //converted string
  BOOL8 force_total_reject;
  char unrecognised = STRING (unrecognised_char)[0];

  blob_it.set_to_list (word->outword->blob_list ());

  ASSERT_HOST (word->reject_map.length () ==
    word->best_choice->string ().length ());
  /*
  tprintf( "\"%s\" -> length: %d;  blobcount: %d (%d)\n",
      word->best_choice->string().string(),
        word->best_choice->string().length(),
      blob_it.length(),
        blob_count( word->outword ) );
  */

  if (word->best_choice->string ().length () == 0)
    force_total_reject = TRUE;
  else {
    force_total_reject = FALSE;
    ASSERT_HOST (blob_it.length () ==
      word->best_choice->string ().length ());
  }
  if (!blob_it.empty ()) {
    for (index = 0; index < word->word->space (); index++)
      word_string[index] = ' ';  //leading blanks
  }
  /* Why does this generate leading blanks regardless of whether the
  word_choice string is empty, when write_cooked_text ony generates leading
  blanks when the string is NOT empty???. */

  if (word->word->flag (W_REP_CHAR) && tessedit_write_rep_codes) {
    strcpy (word_string + index, "|^~R");
    index += 4;
    strcpy(word_string + index, unicharset.id_to_unichar(get_rep_char (word)));
    index += strlen(unicharset.id_to_unichar(get_rep_char (word)));
  }
  else {
    if (!blob_it.empty ())
      prevright = blob_it.data ()->bounding_box ().left ();
    //actually first left
    for (blobindex = 0, blob_it.mark_cycle_pt ();
    !blob_it.cycled_list (); blobindex++, blob_it.forward ()) {
      blob = blob_it.data ();
      if (word->reject_map[blobindex].accepted ()) {
        if (word->best_choice->string ()[blobindex] == ' ')
                                 //but not rejected!!
          word_string[index++] = unrecognised;
        else
          word_string[index++] =
            word->best_choice->string ()[blobindex];
      }
      else {                     // start reject
        inset_box = blob->bounding_box ();
        /* Extend reject box to include rejected neighbours */
        while (!blob_it.at_last () &&
          (force_total_reject ||
        (word->reject_map[blobindex + 1].rejected ()))) {
          blobindex++;
          blob = blob_it.forward ();
                                 //get total box
          inset_box += blob->bounding_box ();
        }
        if (blob_it.at_last ())
          nextleft = inset_box.right ();
        else
          nextleft = blob_it.data_relative (1)->bounding_box ().left ();

        //       tprintf("Making reject from (%d,%d)->(%d,%d)\n",
        //          inset_box.left(),inset_box.bottom(),
        //          inset_box.right(),inset_box.top());

        index += make_reject (&inset_box, prevright, nextleft,
          &word->denorm, &word_string[index]);
      }
      prevright = blob->bounding_box ().right ();
    }
  }
  if (newline_type)
                                 //end line
    word_string[index++] = newline_type;
  word_string[index] = '\0';     //terminate string
  if (strlen (word_string) != index) {
    tprintf ("ASSERT ABOUT TO FAIL: %s, index %d len %d\n",
      word_string, index, strlen (word_string));
  }
                                 //don't pass any zeros
  ASSERT_HOST (strlen (word_string) == index);
  return new WERD_CHOICE (word_string, 0, 0, NO_PERM);
}
#endif

/**********************************************************************
 * make_reject
 *
 * Add the escape code to the string for the reject.
 **********************************************************************/

inT16
make_reject (                    //make reject code
TBOX * inset_box,                 //bounding box
inT16 prevright,                 //previous char
inT16 nextleft,                  //next char
DENORM * denorm,                 //de-normalizer
char word_string[]               //output string
)
{
  Q_UNUSED(prevright);
  Q_UNUSED(nextleft);
  inT16 index;                   //to string
  inT16 xpos;                    //start of inset
  inT16 width;                   //size of inset
  inT16 inset_index = 0;         //number of inset
  inT16 min_chars;               //min width estimate
  inT16 max_chars;               //max width estimate

  index = 0;
  xpos = (inT16) floor (denorm->x (inset_box->left ()));
  width = (inT16) ceil (denorm->x (inset_box->right ())) - xpos;

  //escape code
  word_string[index++] = CTRL_INSET;
  min_chars = (inT16) ceil (0.27 * width / denorm->row ()->x_height ());
  max_chars = (inT16) floor (1.8 * width / denorm->row ()->x_height ());
  /*
  Ensure min_chars and max_chars are in the range 0..254. This ensures that
  we can add 1 to them to avoid putting \0 in a string, and still not exceed
  the max value in a byte.
  */
  if (min_chars < 0)
    min_chars = 0;
  if (min_chars > 254)
    min_chars = 254;
  if (max_chars < min_chars)
    max_chars = min_chars;
  if (max_chars > 254)
    max_chars = 254;
                                 //min chars
  word_string[index++] = min_chars + 1;
                                 //max chars
  word_string[index++] = max_chars + 1;
  word_string[index++] = 2;      //type?
                                 //store index
  word_string[index++] = inset_index / 255 + 1;
  word_string[index++] = inset_index % 255 + 1;
  return index;                  //size of string
}


/**********************************************************************
 * determine_newline_type
 *
 * Find whether we have a wrapping or hard newline.
 * Return FALSE if not at end of line.
 **********************************************************************/

char determine_newline_type(                   //test line ends
                            WERD *word,        //word to do
                            BLOCK *block,      //current block
                            WERD *next_word,   //next word
                            BLOCK *next_block  //block of next word
                           ) {
  inT16 end_gap;                 //to right edge
  inT16 width;                   //of next word
  TBOX word_box;                  //bounding
  TBOX next_box;                  //next word
  TBOX block_box;                 //block bounding

  if (!word->flag (W_EOL))
    return FALSE;                //not end of line
  if (next_word == NULL || next_block == NULL || block != next_block)
    return CTRL_NEWLINE;
  if (next_word->space () > 0)
    return CTRL_HARDLINE;        //it is tabbed
  word_box = word->bounding_box ();
  next_box = next_word->bounding_box ();
  block_box = block->bounding_box ();
                                 //gap to eol
  end_gap = block_box.right () - word_box.right ();
  end_gap -= (inT32) block->space ();
  width = next_box.right () - next_box.left ();
  //      tprintf("end_gap=%d-%d=%d, width=%d-%d=%d, nl=%d\n",
  //              block_box.right(),word_box.right(),end_gap,
  //              next_box.right(),next_box.left(),width,
  //              end_gap>width ? CTRL_HARDLINE : CTRL_NEWLINE);
  return end_gap > width ? CTRL_HARDLINE : CTRL_NEWLINE;
}

/**********************************************************************
 * write_shm_text
 *
 * Write the cooked text to the shared memory for the api.
 **********************************************************************/

void write_shm_text(                    //write output
                    WERD_RES *word,     //word to do
                    BLOCK *block,       //block it is from
                    ROW_RES *row,       //row it is from
                    const STRING &text, //text to write
                    const STRING &text_lengths
                   )
{
  Q_UNUSED(block);
  inT32 index;                   //char counter
  inT32 index2;                  //char counter
  inT32 length;                  //chars in word
  inT32 ptsize;                  //font size
  inT8 blanks;                   //blanks in word
  uinT8 enhancement;             //bold etc
  uinT8 font;                    //font index
  char unrecognised = STRING (unrecognised_char)[0];
  PBLOB *blob;
  TBOX blob_box;                  //bounding box
  PBLOB_IT blob_it;              //blob iterator
  WERD copy_outword;             // copy to denorm
  uinT32 rating;                 //of char
  BOOL8 lineend;                 //end of line
  int offset;
  int offset2;

                                 //point size
  ptsize = pixels_to_pts ((inT32) (row->row->x_height () + row->row->ascenders () - row->row->descenders ()), 300);
  if (word->word->flag (W_BOL) && ocr_char_space () < 128
    && ocr_send_text (TRUE) != OKAY)
    return;                      //release failed
  copy_outword = *(word->outword);
  copy_outword.baseline_denormalise (&word->denorm);
  blob_it.set_to_list (copy_outword.blob_list ());
  length = text_lengths.length ();

  if (length > 0) {
    blanks = word->word->space ();
    if (blanks == 0 && tessedit_word_for_word && !word->word->flag (W_BOL))
      blanks = 1;
    for (index = 0, offset = 0; index < length;
         offset += text_lengths[index++], blob_it.forward ()) {
      blob = blob_it.data ();
      blob_box = blob->bounding_box ();

      enhancement = 0;
      if (word->italic > 0 || (word->italic == 0 && row->italic > 0))
        enhancement |= EUC_ITALIC;
      if (word->bold > 0 || (word->bold == 0 && row->bold > 0))
        enhancement |= EUC_BOLD;
      if (tessedit_write_ratings)
        rating = (uinT32) (-word->best_choice->certainty () / 0.035);
      else if (tessedit_zero_rejection)
        rating = text[offset] == ' ' ? 100 : 0;
      else
        rating = word->reject_map[index].accepted ()? 0 : 100;
      if (rating > 255)
        rating = 255;
      if (word->font1_count > 2)
        font = word->font1;
      else if (row->font1_count > 8)
        font = row->font1;
      else
                                 //font index
        font = word->word->flag (W_DONT_CHOP) ? 0 : 1;

      lineend = word->word->flag (W_EOL) && index == length - 1;
      if (word->word->flag (W_EOL) && tessedit_zero_rejection
      && index < length - 1 && text[index + text_lengths[index]] == ' ') {
        for (index2 = index + 1, offset2 = offset + text_lengths[index];
             index2 < length && text[offset2] == ' ';
             offset2 += text_lengths[index2++]);
        if (index2 == length)
          lineend = TRUE;
      }

      if (!tessedit_zero_rejection || text[offset] != ' '
      || tessedit_word_for_word) {
                                 //confidence
        if (text[offset] == ' ') {
        ocr_append_char (unrecognised,
                         blob_box.left (), blob_box.right (),
                         page_image.get_ysize () - 1 - blob_box.top (),
                         page_image.get_ysize () - 1 - blob_box.bottom (),
                         font, (uinT8) rating,
                         ptsize,                //point size
                         blanks, enhancement,   //enhancement
                         OCR_CDIR_LEFT_RIGHT,
                         OCR_LDIR_DOWN_RIGHT,
                         lineend ? OCR_NL_NEWLINE : OCR_NL_NONE);
        } else {
          for (int suboffset = 0; suboffset < text_lengths[index]; ++suboffset)
            ocr_append_char (static_cast<unsigned char>(text[offset+suboffset]),
                             blob_box.left (), blob_box.right (),
                             page_image.get_ysize () - 1 - blob_box.top (),
                             page_image.get_ysize () - 1 - blob_box.bottom (),
                             font, (uinT8) rating,
                             ptsize,                //point size
                             blanks, enhancement,   //enhancement
                             OCR_CDIR_LEFT_RIGHT,
                             OCR_LDIR_DOWN_RIGHT,
                             lineend ? OCR_NL_NEWLINE : OCR_NL_NONE);
        }
        blanks = 0;
      }

    }
  }
  else if (tessedit_word_for_word) {
    blanks = word->word->space ();
    if (blanks == 0 && !word->word->flag (W_BOL))
      blanks = 1;
    blob_box = word->word->bounding_box ();

    enhancement = 0;
    if (word->italic > 0)
      enhancement |= EUC_ITALIC;
    if (word->bold > 0)
      enhancement |= EUC_BOLD;
    rating = 100;
    if (word->font1_count > 2)
      font = word->font1;
    else if (row->font1_count > 8)
      font = row->font1;
    else
                                 //font index
      font = word->word->flag (W_DONT_CHOP) ? 0 : 1;

    lineend = word->word->flag (W_EOL);

                                 //font index
    ocr_append_char (unrecognised,
                     blob_box.left (), blob_box.right (),
                     page_image.get_ysize () - 1 - blob_box.top (),
                     page_image.get_ysize () - 1 - blob_box.bottom (),
                     font,
                     rating,                    //confidence
                     ptsize,                    //point size
                     blanks, enhancement,       //enhancement
                     OCR_CDIR_LEFT_RIGHT,
                     OCR_LDIR_DOWN_RIGHT,
                     lineend ? OCR_NL_NEWLINE : OCR_NL_NONE);
  }
}


/**********************************************************************
 * write_map
 *
 * Write a map file of 0's and 1'a which associates characters from the .txt
 * file with those in the .etx file. 0 = .txt char was deleted. 1 = .txt char
 * is kept.  Note that there may be reject regions in the .etx file WITHOUT
 * .txt chars being rejected.  The map file should be the same length, and
 * the same number of lines as the .txt file
 *
 * The paramaterised input is because I thought I might be able to generate
 * multiple map files in a single run.  However, it didn't work because
 * newdiff needs etx files!
 **********************************************************************/

#if 0
void write_map(                //output a map file
               FILE *mapfile,  //mapfile to write to
               WERD_RES *word) {
  inT16 index;
  int status;
  STRING mapstr = "";

  if (word->best_choice->string ().length () > 0) {
    for (index = 0; index < word->word->space (); index++) {
      if (word->reject_spaces &&
        (suspect_level >= suspect_space_level) &&
        !tessedit_minimal_rejection && !tessedit_zero_rejection)
        /* Write rejected spaces to .map file ONLY. Newdiff converts these back to
        accepted spaces AFTER generating basic space stats but BEFORE using .etx */
        status = fprintf (mapfile, "0");
      else
        status = fprintf (mapfile, "1");
      if (status < 0)
        WRITEFAILED.error ("write_map", EXIT, "Space Errno: %d", errno);
    }

    if ((word->word->flag (W_REP_CHAR) && tessedit_write_rep_codes)) {
      for (index = 0; index < 5; index++)
        mapstr += '1';
    }
    else {
      ASSERT_HOST (word->reject_map.length () ==
        word->best_choice->string ().length ());

      for (index = 0; index < word->reject_map.length (); index++) {
        if (word->reject_map[index].accepted ())
          mapstr += '1';
        else
          mapstr += '0';
      }
    }
    status = fprintf (mapfile, "%s", mapstr.string ());
    if (status < 0)
      WRITEFAILED.error ("write_map", EXIT, "Map str Errno: %d", errno);
  }
  if (word->word->flag (W_EOL)) {
    status = fprintf (mapfile, "\n");
    if (status < 0)
      WRITEFAILED.error ("write_map", EXIT, "Newline Errno: %d", errno);
  }
  status = fflush (mapfile);
  if (status != 0)
    WRITEFAILED.error ("write_map", EXIT, "fflush Errno: %d", errno);
}
#endif


/*************************************************************************
 * open_file()
 *************************************************************************/
FILE *Tesseract::open_outfile(  //open .map & .unlv file
                   const char *extension) {
  STRING file_name;
  FILE *outfile;

  file_name = imagebasename + extension;
  if (!(outfile = fopen (file_name.string (), "w"))) {
    CANTOPENFILE.error ("open_outfile", EXIT, "%s %d",
      file_name.string (), errno);
  }
  return outfile;
}

#if 0
void write_unlv_text(WERD_RES *word) {
  const char *wordstr;

  char buff[512];                //string to output
  int i = 0;
  int j = 0;
  char unrecognised = STRING (unrecognised_char)[0];
  int status;
  char space_str[3];

  wordstr = word->best_choice->string ().string ();

  /* DONT need to do anything special for repeated char words - at this stage
  the repetition char has been identified and any other chars have been
  rejected.
  */

  for (; wordstr[i] != '\0'; i++) {
    if ((wordstr[i] == ' ') ||
      (wordstr[i] == '~') || (wordstr[i] == '^') || (wordstr[i] == '|'))
      buff[j++] = unrecognised;
    else {
      if (word->reject_map[i].rejected ())
        buff[j++] = '^';         //Add suspect marker
      buff[j++] = wordstr[i];
    }
  }
  buff[j] = '\0';

  if (strlen (wordstr) > 0) {
    if (word->reject_spaces &&
      (suspect_level >= suspect_space_level) &&
      !tessedit_minimal_rejection && !tessedit_zero_rejection)
      strcpy (space_str, "^ ");  //Suspect space
    else
      strcpy (space_str, " ");   //Certain space

    for (i = 0; i < word->word->space (); i++) {
      status = fprintf (unlv_file, "%s", space_str);
      if (status < 0)
        WRITEFAILED.error ("write_unlv_text", EXIT,
          "Space Errno: %d", errno);
    }

    status = fprintf (unlv_file, "%s", buff);
    if (status < 0)
      WRITEFAILED.error ("write_unlv_text", EXIT, "Word Errno: %d", errno);
  }
  if (word->word->flag (W_EOL)) {
    status = fprintf (unlv_file, "\n");
    if (status < 0)
      WRITEFAILED.error ("write_unlv_text", EXIT,
        "Newline Errno: %d", errno);
  }
  status = fflush (unlv_file);
  if (status != 0)
    WRITEFAILED.error ("write_unlv_text", EXIT, "Fflush Errno: %d", errno);
}
#endif


/*************************************************************************
 * get_rep_char()
 * Return the first accepted character from the repetition string. This is the
 * character which is repeated - as determined earlier by fix_rep_char()
 *************************************************************************/
UNICHAR_ID Tesseract::get_rep_char(WERD_RES *word) {  // what char is repeated?
  int i;
  for (i = 0; ((i < word->reject_map.length()) &&
               (word->reject_map[i].rejected())); ++i);

  if (i < word->reject_map.length()) {
    return word->best_choice->unichar_id(i);
  } else {
    return unicharset.unichar_to_id(unrecognised_char.string());
  }
}

void ensure_rep_chars_are_consistent(WERD_RES *word)
{
    Q_UNUSED(word);
#if 0
  char rep_char = get_rep_char (word);
  char *ptr;

  ptr = (char *) word->best_choice->string ().string ();
  for (; *ptr != '\0'; ptr++) {
    if (*ptr != rep_char)
      *ptr = rep_char;
  }
#endif

#if 0
  UNICHAR_ID rep_char = get_rep_char (word); //TODO(tkielbus) Reactivate
  int i;
  char *ptr;
  STRING consistent_string;
  STRING consistent_string_lengths;

  ptr = (char *) word->best_choice->string ().string ();
  for (i = 0; *ptr != '\0'; ptr += word->best_choice->lengths()[i++]) {
    consistent_string += unicharset.id_to_unichar(rep_char);
    consistent_string_lengths += strlen(unicharset.id_to_unichar(rep_char));
  }
  word->best_choice->string() = consistent_string;
  word->best_choice->lengths() = consistent_string_lengths;
#endif
}

/*************************************************************************
 * SUSPECT LEVELS
 *
 * 0 - dont reject ANYTHING
 * 1,2 - partial rejection
 * 3 - BEST
 *
 * NOTE: to reject JUST tess failures in the .map file set suspect_level 3 and
 * tessedit_minimal_rejection.
 *************************************************************************/
void Tesseract::set_unlv_suspects(WERD_RES *word_res) {
  int len = word_res->reject_map.length();
  const WERD_CHOICE &word = *(word_res->best_choice);
  int i;
  float rating_per_ch;

  if (suspect_level == 0) {
    for (i = 0; i < len; i++) {
      if (word_res->reject_map[i].rejected())
        word_res->reject_map[i].setrej_minimal_rej_accept();
    }
    return;
  }

  if (suspect_level >= 3)
    return;                      //Use defaults

  /* NOW FOR LEVELS 1 and 2 Find some stuff to unreject*/

  if (safe_dict_word(word) &&
      (count_alphas(word) > suspect_short_words)) {
    /* Unreject alphas in dictionary words */
    for (i = 0; i < len; ++i) {
      if (word_res->reject_map[i].rejected() &&
          unicharset.get_isalpha(word.unichar_id(i)))
        word_res->reject_map[i].setrej_minimal_rej_accept();
    }
  }

  rating_per_ch = word.rating() / word_res->reject_map.length();

  if (rating_per_ch >= suspect_rating_per_ch)
    return;                      //Dont touch bad ratings

  if ((word_res->tess_accepted) || (rating_per_ch < suspect_accept_rating)) {
    /* Unreject any Tess Acceptable word - but NOT tess reject chs*/
    for (i = 0; i < len; ++i) {
      if (word_res->reject_map[i].rejected() &&
          (!unicharset.eq(word.unichar_id(i), " ")))
        word_res->reject_map[i].setrej_minimal_rej_accept();
    }
  }

  for (i = 0; i < len; i++) {
    if (word_res->reject_map[i].rejected()) {
      if (word_res->reject_map[i].flag(R_DOC_REJ))
        word_res->reject_map[i].setrej_minimal_rej_accept();
      if (word_res->reject_map[i].flag(R_BLOCK_REJ))
        word_res->reject_map[i].setrej_minimal_rej_accept();
      if (word_res->reject_map[i].flag(R_ROW_REJ))
        word_res->reject_map[i].setrej_minimal_rej_accept();
    }
  }

  if (suspect_level == 2)
    return;

  if (!suspect_constrain_1Il ||
      (word_res->reject_map.length() <= suspect_short_words)) {
    for (i = 0; i < len; i++) {
      if (word_res->reject_map[i].rejected()) {
        if ((word_res->reject_map[i].flag(R_1IL_CONFLICT) ||
          word_res->reject_map[i].flag(R_POSTNN_1IL)))
          word_res->reject_map[i].setrej_minimal_rej_accept();

        if (!suspect_constrain_1Il &&
          word_res->reject_map[i].flag(R_MM_REJECT))
          word_res->reject_map[i].setrej_minimal_rej_accept();
      }
    }
  }

  if ((acceptable_word_string(word.unichar_string().string(),
                              word.unichar_lengths().string()) !=
       AC_UNACCEPTABLE) ||
      acceptable_number_string(word.unichar_string().string(),
                               word.unichar_lengths().string())) {
    if (word_res->reject_map.length() > suspect_short_words) {
      for (i = 0; i < len; i++) {
        if (word_res->reject_map[i].rejected() &&
          (!word_res->reject_map[i].perm_rejected() ||
           word_res->reject_map[i].flag (R_1IL_CONFLICT) ||
           word_res->reject_map[i].flag (R_POSTNN_1IL) ||
           word_res->reject_map[i].flag (R_MM_REJECT))) {
          word_res->reject_map[i].setrej_minimal_rej_accept();
        }
      }
    }
  }
}

inT16 Tesseract::count_alphas(const WERD_CHOICE &word) {
  int count = 0;
  for (int i = 0; i < word.length(); ++i) {
    if (unicharset.get_isalpha(word.unichar_id(i)))
      count++;
  }
  return count;
}


inT16 Tesseract::count_alphanums(const WERD_CHOICE &word) {
  int count = 0;
  for (int i = 0; i < word.length(); ++i) {
    if (unicharset.get_isalpha(word.unichar_id(i)) ||
        unicharset.get_isdigit(word.unichar_id(i)))
      count++;
  }
  return count;
}


BOOL8 Tesseract::acceptable_number_string(const char *s,
                                          const char *lengths) {
  BOOL8 prev_digit = FALSE;

  if (*lengths == 1 && *s == '(')
    s++;

  if (*lengths == 1 &&
      ((*s == '$') || (*s == '.') || (*s == '+') || (*s == '-')))
    s++;

  for (; *s != '\0'; s += *(lengths++)) {
    if (unicharset.get_isdigit (s, *lengths))
      prev_digit = TRUE;
    else if (prev_digit &&
             (*lengths == 1 && ((*s == '.') || (*s == ',') || (*s == '-'))))
      prev_digit = FALSE;
    else if (prev_digit && *lengths == 1 &&
             (*(s + *lengths) == '\0') && ((*s == '%') || (*s == ')')))
      return TRUE;
    else if (prev_digit &&
             *lengths == 1 && (*s == '%') &&
             (*(lengths + 1) == 1 && *(s + *lengths) == ')') &&
             (*(s + *lengths + *(lengths + 1)) == '\0'))
      return TRUE;
    else
      return FALSE;
  }
  return TRUE;
}
/////////////////////////////////////////////////////////////////output////////////////////////////////////////

/////////////////////////////////////////////////////////////////werdit////////////////////////////////////////
#define EXTERN

//EXTERN BOOL_VAR(wordit_linearc,FALSE,"Pass poly of linearc to Tess");

/**********************************************************************
 * WERDIT::start_page
 *
 * Get ready to iterate over the page by setting the iterators.
 **********************************************************************/

void WERDIT::start_page(                        //set iterators
                        BLOCK_LIST *block_list  //blocks to check
                       ) {
  block_it.set_to_list (block_list);
  block_it.mark_cycle_pt ();
  do {
    while (block_it.data ()->row_list ()->empty ()
    && !block_it.cycled_list ()) {
      block_it.forward ();
    }
    if (!block_it.data ()->row_list ()->empty ()) {
      row_it.set_to_list (block_it.data ()->row_list ());
      row_it.mark_cycle_pt ();
      while (row_it.data ()->word_list ()->empty ()
      && !row_it.cycled_list ()) {
        row_it.forward ();
      }
      if (!row_it.data ()->word_list ()->empty ()) {
        word_it.set_to_list (row_it.data ()->word_list ());
        word_it.mark_cycle_pt ();
      }
    }
  }
  while (!block_it.cycled_list () && row_it.data ()->word_list ()->empty ());
}


/**********************************************************************
 * WERDIT::forward
 *
 * Give the next word on the page, or NULL if none left.
 * This code assumes all rows to be non-empty, but blocks are allowed
 * to be empty as eventually we will have non-text blocks.
 * The output is always a copy and needs to be deleted by somebody.
 **********************************************************************/

WERD *WERDIT::forward() {  //use iterators
  WERD *word;                    //actual word
  //      WERD                                                    *larc_word;                                                     //linearc copy
  WERD *result;                  //output word
  ROW *row;                      //row of word

  if (word_it.cycled_list ()) {
    return NULL;                 //finished page
  }
  else {
    word = word_it.data ();
    row = row_it.data ();
    word_it.forward ();
    if (word_it.cycled_list ()) {
      row_it.forward ();         //finished row
      if (row_it.cycled_list ()) {
        do {
          block_it.forward ();   //finished block
          if (!block_it.cycled_list ()) {
            row_it.set_to_list (block_it.data ()->row_list ());
            row_it.mark_cycle_pt ();
          }
        }
                                 //find non-empty block
        while (!block_it.cycled_list ()
          && row_it.cycled_list ());
      }
      if (!row_it.cycled_list ()) {
        word_it.set_to_list (row_it.data ()->word_list ());
        word_it.mark_cycle_pt ();
      }
    }

    //              if (wordit_linearc && !word->flag(W_POLYGON))
    //              {
    //                      larc_word=word->larc_copy(row->x_height());
    //                      result=larc_word->poly_copy(row->x_height());
    //                      delete larc_word;
    //              }
    //              else
    result = word->poly_copy (row->x_height ());
    return result;
  }
}


/**********************************************************************
 * make_pseudo_word
 *
 * Make all the blobs inside a selection into a single word.
 * The word is always a copy and needs to be deleted.
 **********************************************************************/

WERD *make_pseudo_word(                         //make fake word
                       BLOCK_LIST *block_list,  //blocks to check //block of selection
                       TBOX &selection_box,
                       BLOCK *&pseudo_block,
                       ROW *&pseudo_row         //row of selection
                      ) {
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ROW_IT row_it;
  ROW *row;
  WERD_IT word_it;
  WERD *word;
  PBLOB_IT blob_it;
  PBLOB *blob;
  PBLOB_LIST new_blobs;          //list of gathered blobs
                                 //iterator
  PBLOB_IT new_blob_it = &new_blobs;
  WERD *pseudo_word;             //fabricated word
  WERD *poly_word;               //poly copy of word
  //      WERD                                                    *larc_word;                                                     //linearc copy

  for (block_it.mark_cycle_pt ();
  !block_it.cycled_list (); block_it.forward ()) {
    block = block_it.data ();
    if (block->bounding_box ().overlap (selection_box)) {
      pseudo_block = block;
      row_it.set_to_list (block->row_list ());
      for (row_it.mark_cycle_pt ();
      !row_it.cycled_list (); row_it.forward ()) {
        row = row_it.data ();
        if (row->bounding_box ().overlap (selection_box)) {
          word_it.set_to_list (row->word_list ());
          for (word_it.mark_cycle_pt ();
          !word_it.cycled_list (); word_it.forward ()) {
            word = word_it.data ();
            if (word->bounding_box ().overlap (selection_box)) {
              //                                                      if (wordit_linearc && !word->flag(W_POLYGON))
              //                                                      {
              //                                                              larc_word=word->larc_copy(row->x_height());
              //                                                              poly_word=larc_word->poly_copy(row->x_height());
              //                                                              delete larc_word;
              //                                                      }
              //                                                      else
              poly_word = word->poly_copy (row->x_height ());
              blob_it.set_to_list (poly_word->blob_list ());
              for (blob_it.mark_cycle_pt ();
              !blob_it.cycled_list (); blob_it.forward ()) {
                blob = blob_it.data ();
                if (blob->bounding_box ().
                overlap (selection_box)) {
                  new_blob_it.add_after_then_move (blob_it.
                    extract
                    ());
                                 //steal off list
                  pseudo_row = row;
                }
              }
              delete poly_word;  //get rid of it
            }
          }
        }
      }
    }
  }
  if (!new_blobs.empty ()) {
                                 //make new word
    pseudo_word = new WERD (&new_blobs, 1, NULL);
  }
  else
    pseudo_word = NULL;
  return pseudo_word;
}
/////////////////////////////////////////////////////////////////werdit////////////////////////////////////////

/////////////////////////////////////////////////////////////////fixxht////////////////////////////////////////
#define EXTERN

EXTERN double_VAR (x_ht_fraction_of_caps_ht, 0.7,
"Fract of cps ht est of xht");
EXTERN double_VAR (x_ht_variation, 0.35,
"Err band as fract of caps/xht dist");
EXTERN double_VAR (x_ht_sub_variation, 0.5,
"Err band as fract of caps/xht dist");
EXTERN BOOL_VAR (rej_trial_ambigs, TRUE,
"reject x-ht ambigs when under trial");
EXTERN BOOL_VAR (x_ht_conservative_ambigs, FALSE,
"Dont rely on ambigs + maxht");
EXTERN BOOL_VAR (x_ht_check_est, TRUE, "Cross check estimates");
EXTERN BOOL_VAR (x_ht_case_flip, FALSE, "Flip or reject suspect case");
EXTERN BOOL_VAR (x_ht_include_dodgy_blobs, TRUE,
"Include blobs with possible noise?");
EXTERN BOOL_VAR (x_ht_limit_flip_trials, TRUE,
"Dont do trial flips when ambigs are close to xht?");
EXTERN BOOL_VAR (rej_use_check_block_occ, TRUE,
"Analyse rejection behaviour");

EXTERN STRING_VAR (chs_non_ambig_caps_ht,
"!#$%&()/12346789?ABDEFGHIKLNQRT[]\\bdfhkl",
"Reliable ascenders");
EXTERN STRING_VAR (chs_x_ht, "acegmnopqrsuvwxyz", "X height chars");
EXTERN STRING_VAR (chs_non_ambig_x_ht, "aenqr", "reliable X height chars");
EXTERN STRING_VAR (chs_ambig_caps_x, "cCmMoO05sSuUvVwWxXzZ",
"X ht or caps ht chars");
EXTERN STRING_VAR (chs_bl_ambig_caps_x, "pPyY", " Caps or descender ambigs");

/* The following arent used in this module but are used in applybox.c */
EXTERN STRING_VAR (chs_caps_ht,
"!#$%&()/0123456789?ABCDEFGHIJKLMNOPQRSTUVWXYZ[]\\bdfhkl{|}",
"Ascender chars");
EXTERN STRING_VAR (chs_desc, "gjpqy", "Descender chars");
EXTERN STRING_VAR (chs_non_ambig_bl,
"!#$%&01246789?ABCDEFGHIKLMNORSTUVWXYZabcdehiklmnorstuvwxz",
"Reliable baseline chars");
EXTERN STRING_VAR (chs_odd_top, "ijt", "Chars with funny ascender region");
EXTERN STRING_VAR (chs_odd_bot, "()35JQ[]\\/{}|", "Chars with funny base");

/* The following arent used but are defined for completeness */
EXTERN STRING_VAR (chs_bl,
"!#$%&()/01246789?ABCDEFGHIJKLMNOPRSTUVWXYZ[]\\abcdefhiklmnorstuvwxz{}",
"Baseline chars");
EXTERN STRING_VAR (chs_non_ambig_desc, "gq", "Reliable descender chars");

/**
 * re_estimate_x_ht()
 *
 * Walk the blobs in the word together with the text string and reject map.
 * NOTE: All evaluation is done on the baseline normalised word. This is so that
 * the TBOX class can be used (integer). The reasons for this are:
 *   a) We must use the outword - ie the Tess result
 *   b) The outword is always converted to integer representation as that is how
 *      Tess works
 *   c) We would like to use the TBOX class, cos its there - this is integer
 *      precision.
 *   d) If we de-normed the outword we would get rounding errors and would find
 *      that integers are too imprecise (x-height around 15 pixels instead of a
 *      scale of 128 in bln form.
 *   CONVINCED?
 *
 * A) Try to re-estimatate x-ht and caps ht from confirmed pts in word.
 *
 * @verbatim
     FOR each non reject blob
        IF char is baseline posn ambiguous
            Remove ambiguity by comparing its posn with respect to baseline.
        IF char is a confirmed x-ht char
            Add x-ht posn to confirmed_x_ht pts for word
     IF char is a confirmed caps-ht char
            Add blob_ht to caps ht pts for word

     IF Std Dev of caps hts < 2  (AND # samples > 0)
        Use mean as caps ht estimate (Dont use median as we can expect a
            fair variation between the heights of the NON_AMBIG_CAPS_HT_CHS)
     IF Std Dev of caps hts >= 2  (AND # samples > 0)
            Suspect small caps font.
            Look for 2 clusters,	each with Std Dev < 2.
            IF 2 clusters found
            Pick the smaller median as the caps ht estimate of the smallcaps.

     IF failed to estimate a caps ht
        Use the median caps ht if there is one,
        ELSE use the caps ht estimate of the previous word. NO!!!


     IF there are confirmed x-height chars
            Estimate confirmed x-height as the median value
     ELSE IF there is a confirmed caps ht
            Estimate confirmed x-height as a fraction of confirmed caps ht value
        ELSE
            Use the value for the previous word or the row value if this is the
            first word in the block. NO!!!
   @endverbatim
 *
 * B) Add in case ambiguous blobs based on confirmed x-ht/caps ht, changing case
 *    as necessary. Reestimate caps ht and x-ht as in A, using the extended
 *    clusters.
 *
 * C) If word contains rejects, and x-ht estimate significantly differs from
 *    original estimate, return TRUE so that the word can be rematched
 */

void re_estimate_x_ht(                     //improve for 1 word
                      WERD_RES *word_res,  //word to do
                      float *trial_x_ht    //new match value
                     ) {
  PBLOB_IT blob_it;
  inT16 blob_ht_above_baseline;

  const char *word_str;
  inT16 i;
  inT16 offset;

  STATS all_blobs_ht (0, 300);   //every blob in word
  STATS x_ht (0, 300);           //confirmed pts in wd
  STATS caps_ht (0, 300);        //confirmed pts in wd
  STATS case_ambig (0, 300);     //lower case ambigs

  inT16 rej_blobs_count = 0;
  inT16 rej_blobs_max_height = 0;
  inT32 rej_blobs_max_area = 0;
  float x_ht_ok_variation;
  float max_blob_ht;
  float marginally_above_x_ht;

  TBOX blob_box;                  //blob bounding box
  float est_x_ht = 0.0;          //word estimate
  float est_caps_ht = 0.0;       //word estimate
                                 //based on hard data?
  BOOL8 est_caps_ht_certain = FALSE;
  BOOL8 est_x_ht_certain = FALSE;//based on hard data?
  BOOL8 trial = FALSE;           //Sepeculative values?
  BOOL8 no_comment = FALSE;      //No change in xht
  float ambig_lc_x_est;
  float ambig_uc_caps_est;
  inT16 x_ht_ambigs = 0;
  inT16 caps_ht_ambigs = 0;

  /* Calculate default variation of blob x_ht from bln x_ht for bln word */
  x_ht_ok_variation =
    (bln_x_height / x_ht_fraction_of_caps_ht - bln_x_height) * x_ht_variation;

  word_str = word_res->best_choice->unichar_string().string();
  /*
    Cycle blobs, allocating to one of the stats sets when possible.
  */
  blob_it.set_to_list (word_res->outword->blob_list ());
  for (blob_it.mark_cycle_pt (), i = 0, offset = 0;
  !blob_it.cycled_list (); blob_it.forward (),
           offset += word_res->best_choice->unichar_lengths()[i++]) {
    if (!dodgy_blob (blob_it.data ())) {
      blob_box = blob_it.data ()->bounding_box ();
      blob_ht_above_baseline = blob_box.top () - bln_baseline_offset;
      all_blobs_ht.add (blob_ht_above_baseline, 1);

      if (word_res->reject_map[i].rejected ()) {
        rej_blobs_count++;
        if (blob_box.height () > rej_blobs_max_height)
          rej_blobs_max_height = blob_box.height ();
        if (blob_box.area () > rej_blobs_max_area)
          rej_blobs_max_area = blob_box.area ();
      }
      else {
        if (STRING (chs_non_ambig_x_ht).contains (word_str[offset]))
          x_ht.add (blob_ht_above_baseline, 1);

        if (STRING (chs_non_ambig_caps_ht).contains (word_str[offset]))
          caps_ht.add (blob_ht_above_baseline, 1);

        if (STRING (chs_ambig_caps_x).contains (word_str[offset])) {
          case_ambig.add (blob_ht_above_baseline, 1);
          if (STRING (chs_x_ht).contains (word_str[offset]))
            x_ht_ambigs++;
          else
            caps_ht_ambigs++;
        }

        if (STRING (chs_bl_ambig_caps_x).contains (word_str[offset])) {
          if (STRING (chs_x_ht).contains (word_str[offset])) {
            /* confirm x_height provided > 15% total height below baseline */
            if ((bln_baseline_offset - blob_box.bottom ()) /
              (float) blob_box.height () > 0.15)
              x_ht.add (blob_ht_above_baseline, 1);
          }
          else {
            /* confirm caps_height provided < 5% total height below baseline */
            if ((bln_baseline_offset - blob_box.bottom ()) /
              (float) blob_box.height () < 0.05)
              caps_ht.add (blob_ht_above_baseline, 1);
          }
        }
      }
    }
  }
  est_caps_ht = estimate_from_stats (caps_ht);
  est_x_ht = estimate_from_stats (x_ht);
  est_ambigs(word_res, case_ambig, &ambig_lc_x_est, &ambig_uc_caps_est);
  max_blob_ht = all_blobs_ht.ile (0.9999);

  #ifndef SECURE_NAMES
  if (debug_x_ht_level >= 20) {
    tprintf ("Mode20:A: %s ", word_str);
    word_res->reject_map.print (debug_fp);
    tprintf (" XHT:%f CAP:%f MAX:%f AMBIG X:%f CAP:%f\n",
      est_x_ht, est_caps_ht, max_blob_ht,
      ambig_lc_x_est, ambig_uc_caps_est);
  }
  #endif
  if (!x_ht_conservative_ambigs &&
    (ambig_lc_x_est > 0) &&
    (ambig_lc_x_est == ambig_uc_caps_est) &&
  (max_blob_ht > ambig_lc_x_est + x_ht_ok_variation)) {
                                 //may be zero but believe xht
    ambig_uc_caps_est = est_caps_ht;
    #ifndef SECURE_NAMES
    if (debug_x_ht_level >= 20)
      tprintf ("Mode20:B: Fiddle ambig_uc_caps_est to %f\n",
        ambig_lc_x_est);
    #endif
  }

  /* Now make some estimates */

  if ((est_x_ht > 0) || (est_caps_ht > 0) ||
      ((ambig_lc_x_est > 0) && (ambig_lc_x_est != ambig_uc_caps_est))) {
    /* There is some sensible data to go on so make the most of it. */
    if (debug_x_ht_level >= 20)
      tprintf ("Mode20:C: Sensible Data\n", ambig_lc_x_est);
    if (est_x_ht > 0) {
      est_x_ht_certain = TRUE;
      if (est_caps_ht == 0) {
        if ((ambig_uc_caps_est > ambig_lc_x_est) &&
            (ambig_uc_caps_est > est_x_ht + x_ht_ok_variation))
          est_caps_ht = ambig_uc_caps_est;
        else
          est_caps_ht = est_x_ht / x_ht_fraction_of_caps_ht;
      }
      if (case_ambig.get_total () > 0)
        improve_estimate(word_res, est_x_ht, est_caps_ht, x_ht, caps_ht);
      est_caps_ht_certain = caps_ht.get_total () > 0;
      #ifndef SECURE_NAMES
      if (debug_x_ht_level >= 20)
        tprintf ("Mode20:D: Est from xht XHT:%f CAP:%f\n",
          est_x_ht, est_caps_ht);
      #endif
    }
    else if (est_caps_ht > 0) {
      est_caps_ht_certain = TRUE;
      if ((ambig_lc_x_est > 0) &&
        (ambig_lc_x_est < est_caps_ht - x_ht_ok_variation))
        est_x_ht = ambig_lc_x_est;
      else
        est_x_ht = est_caps_ht * x_ht_fraction_of_caps_ht;
      if (ambig_lc_x_est + ambig_uc_caps_est > 0)
        improve_estimate(word_res, est_x_ht, est_caps_ht, x_ht, caps_ht);
      est_x_ht_certain = x_ht.get_total () > 0;
      #ifndef SECURE_NAMES
      if (debug_x_ht_level >= 20)
        tprintf ("Mode20:E: Est from caps XHT:%f CAP:%f\n",
          est_x_ht, est_caps_ht);
      #endif
    }
    else {
      /* Do something based on case ambig chars alone - we have guessed that the
        ambigs are lower case. */
      est_x_ht = ambig_lc_x_est;
      est_x_ht_certain = TRUE;
      if (ambig_uc_caps_est > ambig_lc_x_est) {
        est_caps_ht = ambig_uc_caps_est;
        est_caps_ht_certain = TRUE;
      }
      else
        est_caps_ht = est_x_ht / x_ht_fraction_of_caps_ht;

      #ifndef SECURE_NAMES
      if (debug_x_ht_level >= 20)
        tprintf ("Mode20:F: Est from ambigs XHT:%f CAP:%f\n",
          est_x_ht, est_caps_ht);
      #endif
    }
    /* Check for sane interpretation of evidence:
      Try shifting caps ht if min certain caps ht is not significantly greater
      than the estimated x ht or the max certain x ht is not significantly less
      than the estimated caps ht. */
    if (x_ht_check_est) {
      if ((caps_ht.get_total () > 0) &&
      (est_x_ht + x_ht_ok_variation >= caps_ht.ile (0.0001))) {
        trial = TRUE;
        est_caps_ht = est_x_ht;
        est_x_ht = x_ht_fraction_of_caps_ht * est_caps_ht;

        #ifndef SECURE_NAMES
        if (debug_x_ht_level >= 20)
          tprintf ("Mode20:G: Trial XHT:%f CAP:%f\n",
            est_x_ht, est_caps_ht);
        #endif
      }
      else if ((x_ht.get_total () > 0) &&
      (est_caps_ht - x_ht_ok_variation <= x_ht.ile (0.9999))) {
        trial = TRUE;
        est_x_ht = est_caps_ht;
        est_caps_ht = est_x_ht / x_ht_fraction_of_caps_ht;
        #ifndef SECURE_NAMES
        if (debug_x_ht_level >= 20)
          tprintf ("Mode20:H: Trial XHT:%f CAP:%f\n",
            est_x_ht, est_caps_ht);
        #endif
      }
    }
  }

  else {
    /* There is no sensible data so we're in the dark. */

    marginally_above_x_ht = bln_x_height +
      x_ht_ok_variation * x_ht_sub_variation;
    /*
      If there are no rejects, or the only rejects have a narrow height, or have
      a small area compared to a normal char, then estimate the x-height as the
      original one. (I.e dont fiddle about if the only rejects look like
      punctuation) - we use max height as mean or median will be too low if
      there are only two blobs - Eg "F."
    */

    if (debug_x_ht_level >= 20)
      tprintf ("Mode20:I: In the dark\n");

    if ((rej_blobs_count == 0) ||
      (rej_blobs_max_height < 0.3 * max_blob_ht) ||
    (rej_blobs_max_area < 0.3 * max_blob_ht * max_blob_ht)) {
      no_comment = TRUE;
      if (debug_x_ht_level >= 20)
        tprintf ("Mode20:J: No comment due to no rejects\n");
    }
    else if (x_ht_limit_flip_trials &&
             ((max_blob_ht < marginally_above_x_ht) ||
             ((ambig_lc_x_est > 0) &&
             (ambig_lc_x_est == ambig_uc_caps_est) &&
             (ambig_lc_x_est < marginally_above_x_ht)))) {
      no_comment = TRUE;
      if (debug_x_ht_level >= 20)
        tprintf ("Mode20:K: No comment as close to xht %f < %f\n",
          ambig_lc_x_est, marginally_above_x_ht);
    }
    else if (x_ht_conservative_ambigs && (ambig_uc_caps_est > 0)) {
      trial = TRUE;
      est_caps_ht = ambig_lc_x_est;
      est_x_ht = x_ht_fraction_of_caps_ht * est_caps_ht;

      #ifndef SECURE_NAMES
      if (debug_x_ht_level >= 20)
        tprintf ("Mode20:L: Trial XHT:%f CAP:%f\n",
          est_x_ht, est_caps_ht);
      #endif
    }
    /*
      If the top of the word is nowhere near where we expect ascenders to be
      (less than half the x_ht -> caps_ht distance) - suspect an all caps word
      at the x-ht. Estimate x-ht accordingly - but only as a TRIAL!
      NOTE we do NOT check location of baseline. Commas can descend as much as
      real descenders so we would need to do something to make sure that any
      disqualifying descenders were not at the end.
    */
    else {
      if (max_blob_ht <
          (bln_x_height + bln_x_height / x_ht_fraction_of_caps_ht) / 2.0) {
        trial = TRUE;
        est_x_ht = x_ht_fraction_of_caps_ht * max_blob_ht;
        est_caps_ht = max_blob_ht;

        #ifndef SECURE_NAMES
        if (debug_x_ht_level >= 20)
          tprintf ("Mode20:M: Trial XHT:%f CAP:%f\n",
            est_x_ht, est_caps_ht);
        #endif
      }
      else {
        no_comment = TRUE;
        if (debug_x_ht_level >= 20)
          tprintf ("Mode20:N: No comment as nothing else matched\n");
      }
    }
  }

  /* Sanity check - reject word if fails */

  if (!no_comment &&
      ((est_x_ht > 2 * bln_x_height) ||
       (est_x_ht / word_res->denorm.scale () <= min_sane_x_ht_pixels) ||
       (est_caps_ht <= est_x_ht) || (est_caps_ht >= 2.5 * est_x_ht))) {
    no_comment = TRUE;
    if (!trial && rej_use_xht) {
      if (debug_x_ht_level >= 2) {
        tprintf ("Sanity check rejecting %s ", word_str);
        word_res->reject_map.print (debug_fp);
        tprintf ("\n");
      }
      word_res->reject_map.rej_word_xht_fixup ();

    }
    if (debug_x_ht_level >= 20)
      tprintf ("Mode20:O: No comment as nothing else matched\n");
  }

  if (no_comment || trial) {
    word_res->x_height = bln_x_height / word_res->denorm.scale ();
    word_res->guessed_x_ht = TRUE;
    word_res->caps_height = (bln_x_height / x_ht_fraction_of_caps_ht) /
      word_res->denorm.scale ();
    word_res->guessed_caps_ht = TRUE;
    /*
    Reject ambigs in the current word if we are uncertain and:
        there are rejects OR
        there is only one char which is an ambig OR
        there is conflict between the case of the ambigs even though there is
        no height separation Eg "Ms" recognised from "MS"
    */
    if (rej_trial_ambigs &&
      ((word_res->reject_map.reject_count () > 0) ||
      (word_res->reject_map.length () == 1) ||
    ((x_ht_ambigs > 0) && (caps_ht_ambigs > 0)))) {
      #ifndef SECURE_NAMES
      if (debug_x_ht_level >= 2) {
        tprintf ("TRIAL Rej Ambigs %s ", word_str);
        word_res->reject_map.print (debug_fp);
      }
      #endif
      reject_ambigs(word_res);
      if (debug_x_ht_level >= 2) {
        tprintf (" ");
        word_res->reject_map.print (debug_fp);
        tprintf ("\n");
      }
    }
  }
  else {
    word_res->x_height = est_x_ht / word_res->denorm.scale ();
    word_res->guessed_x_ht = !est_x_ht_certain;
    word_res->caps_height = est_caps_ht / word_res->denorm.scale ();
    word_res->guessed_caps_ht = !est_caps_ht_certain;
  }

  if (!no_comment && (fabs (est_x_ht - bln_x_height) > x_ht_ok_variation))
    *trial_x_ht = est_x_ht / word_res->denorm.scale ();
  else
    *trial_x_ht = 0.0;

  #ifndef SECURE_NAMES
  if (((*trial_x_ht > 0) && (debug_x_ht_level >= 3)) ||
      (debug_x_ht_level >= 5)) {
    tprintf ("%s ", word_str);
    word_res->reject_map.print (debug_fp);
    tprintf
      (" X:%0.2f Cps:%0.2f Mxht:%0.2f RJ MxHt:%d MxAr:%d Rematch:%c\n",
      est_x_ht, est_caps_ht, max_blob_ht, rej_blobs_max_height,
      rej_blobs_max_area, *trial_x_ht > 0 ? '*' : ' ');
  }
  #endif

}

/**
 * check_block_occ()
 * Checks word for coarse block occupancy, rejecting more chars and flipping
 * case of case ambiguous chars as required.
 */
void Tesseract::check_block_occ(WERD_RES *word_res) {
  PBLOB_IT blob_it;
  STRING new_string;
  STRING new_string_lengths(word_res->best_choice->unichar_lengths());
  REJMAP new_map = word_res->reject_map;
  WERD_CHOICE *new_choice;

  const char *word_str = word_res->best_choice->unichar_string().string();
  inT16 i;
  inT16 offset;
  inT16 reject_count = 0;
  char confirmed_char[UNICHAR_LEN + 1];
  char temp_char[UNICHAR_LEN + 1];
  float x_ht;
  float caps_ht;

  new_string_lengths[0] = 0;

  if (word_res->x_height > 0)
    x_ht = word_res->x_height * word_res->denorm.scale ();
  else
    x_ht = bln_x_height;

  if (word_res->caps_height > 0)
    caps_ht = word_res->caps_height * word_res->denorm.scale ();
  else
    caps_ht = x_ht / x_ht_fraction_of_caps_ht;

  blob_it.set_to_list (word_res->outword->blob_list ());

  for (blob_it.mark_cycle_pt (), i = 0, offset = 0;
  !blob_it.cycled_list (); blob_it.forward (),
           offset += word_res->best_choice->unichar_lengths()[i++]) {
    strncpy(temp_char, word_str + offset,
            word_res->best_choice->unichar_lengths()[i]); //default copy
    temp_char[(int)word_res->best_choice->unichar_lengths()[i]] = '\0';
    if (word_res->reject_map[i].accepted ()) {
      check_blob_occ (temp_char,
                      blob_it.data ()->bounding_box ().
                      top () - bln_baseline_offset, x_ht,
                      caps_ht, confirmed_char);

      if (strcmp(confirmed_char, "") == 0) {
        if (rej_use_check_block_occ) {
          new_map[i].setrej_xht_fixup ();
          reject_count++;
        }
      }
      else
        strcpy(temp_char, confirmed_char);
    }
    new_string += temp_char;
    new_string_lengths[i] = strlen(temp_char);
    new_string_lengths[i + 1] = 0;

  }
  if ((reject_count > 0) || (new_string != word_str)) {
    if (debug_x_ht_level >= 2) {
      tprintf ("Shape Verification: %s ", word_str);
      word_res->reject_map.print (debug_fp);
      tprintf (" -> %s ", new_string.string ());
      new_map.print (debug_fp);
      tprintf ("\n");
    }
    new_choice = new WERD_CHOICE(new_string.string(),
                                 new_string_lengths.string(),
                                 word_res->best_choice->rating(),
                                 word_res->best_choice->certainty(),
                                 word_res->best_choice->permuter(),
                                 unicharset);
    new_choice->populate_unichars(unicharset);
    delete word_res->best_choice;
    word_res->best_choice = new_choice;
    word_res->reject_map = new_map;
  }
}

/**
 * check_blob_occ()
 *
 * Checks blob for position relative to position above baseline
 * @return 0 for reject, or (possibly case shifted) confirmed char
 */

void check_blob_occ(char* proposed_char,
                    inT16 blob_ht_above_baseline,
                    float x_ht,
                    float caps_ht,
                    char* confirmed_char) {
  BOOL8 blob_definite_x_ht;
  BOOL8 blob_definite_caps_ht;
  float acceptable_variation;

  acceptable_variation = (caps_ht - x_ht) * x_ht_variation;
  /* ??? REJECT if expected descender and nothing significantly below BL */

  /* ??? REJECT if expected ascender and nothing significantly above x-ht */

  /*
    IF AMBIG_CAPS_X_CHS
      IF blob is definitely an ascender ( > xht + xht err )AND
        char is an x-ht char
      THEN
        flip case
      IF blob is defintiely an x-ht ( <= xht + xht err ) AND
        char is an ascender char
      THEN
        flip case
  */
  blob_definite_x_ht = blob_ht_above_baseline <= x_ht + acceptable_variation;
  blob_definite_caps_ht = blob_ht_above_baseline >=
    caps_ht - acceptable_variation;

  if (STRING (chs_ambig_caps_x).contains (*proposed_char)) {
    if ((!blob_definite_x_ht && !blob_definite_caps_ht) ||
        ((strcmp(proposed_char, "0") == 0) && !blob_definite_caps_ht) ||
        ((strcmp(proposed_char, "o") == 0) && !blob_definite_x_ht)) {
      strcpy(confirmed_char, "");
      return;
    }

    else if (blob_definite_caps_ht &&
    STRING (chs_x_ht).contains (*proposed_char)) {
      if (x_ht_case_flip) {
                                 //flip to upper case
        proposed_char[0] = (char) toupper (*proposed_char);
        return;
      } else {
        strcpy(confirmed_char, "");
        return;
      }
    }

    else if (blob_definite_x_ht &&
    !STRING (chs_x_ht).contains (*proposed_char)) {
      if (x_ht_case_flip) {
                                 //flip to lower case
        proposed_char[0] = (char) tolower (*proposed_char);
      } else {
        strcpy(confirmed_char, "");
        return;
      }
    }
  }
  else
  if ((STRING (chs_non_ambig_x_ht).contains (*proposed_char)
    && !blob_definite_x_ht)
    || (STRING (chs_non_ambig_caps_ht).contains (*proposed_char)
        && !blob_definite_caps_ht)) {
    strcpy(confirmed_char, "");
    return;
  }
  strcpy(confirmed_char, proposed_char);
  return;
}


float estimate_from_stats(STATS &stats) {
  if (stats.get_total () <= 0)
    return 0.0;
  else if (stats.get_total () >= 3)
    return stats.ile (0.5);      //median
  else
    return stats.mean ();
}


void improve_estimate(WERD_RES *word_res,
                      float &est_x_ht,
                      float &est_caps_ht,
                      STATS &x_ht,
                      STATS &caps_ht) {
  PBLOB_IT blob_it;
  inT16 blob_ht_above_baseline;

  const char *word_str;
  inT16 i;
  inT16 offset;
  TBOX blob_box;                  //blob bounding box
  char confirmed_char[UNICHAR_LEN + 1];
  char temp_char[UNICHAR_LEN + 1];
  float new_val;

  /* IMPROVE estimates here - if good estimates, and case ambig chars,
    rescan blobs to fix case ambig blobs, re-estimate hts  ??? maybe always do
    it after deciding x-height
  */

  blob_it.set_to_list (word_res->outword->blob_list ());
  word_str = word_res->best_choice->unichar_string().string();
  for (blob_it.mark_cycle_pt (), i = 0, offset = 0;
       !blob_it.cycled_list (); blob_it.forward (),
           offset += word_res->best_choice->unichar_lengths()[i++]) {
    if ((STRING (chs_ambig_caps_x).contains (word_str[offset])) &&
        (!dodgy_blob (blob_it.data ()))) {
      blob_box = blob_it.data ()->bounding_box ();
      blob_ht_above_baseline = blob_box.top () - bln_baseline_offset;
      strncpy(temp_char, word_str + offset,
              word_res->best_choice->unichar_lengths()[i]);
      temp_char[(int)word_res->best_choice->unichar_lengths()[i]] = '\0';
      check_blob_occ (temp_char,
                      blob_ht_above_baseline,
                      est_x_ht, est_caps_ht, confirmed_char);
      if (strcmp(confirmed_char, "") != 0) {
        if (STRING (chs_x_ht).contains (*confirmed_char))
          x_ht.add (blob_ht_above_baseline, 1);
        else
          caps_ht.add (blob_ht_above_baseline, 1);
      }
    }
  }
  new_val = estimate_from_stats (x_ht);
  if (new_val > 0)
    est_x_ht = new_val;
  new_val = estimate_from_stats (caps_ht);
  if (new_val > 0)
    est_caps_ht = new_val;
}


void reject_ambigs(  //rej any accepted xht ambig chars
                   WERD_RES *word) {
  const char *word_str;
  int i = 0;

  word_str = word->best_choice->unichar_string().string();
  while (*word_str != '\0') {
    if (STRING (chs_ambig_caps_x).contains (*word_str))
      word->reject_map[i].setrej_xht_fixup ();
    word_str += word->best_choice->unichar_lengths()[i++];
  }
}


void est_ambigs(                          //xht ambig ht stats
                WERD_RES *word_res,
                STATS &stats,
                float *ambig_lc_x_est,    //xht est
                float *ambig_uc_caps_est  //caps est
               ) {
  float x_ht_ok_variation;
  STATS short_ambigs (0, 300);
  STATS tall_ambigs (0, 300);
  PBLOB_IT blob_it;
  TBOX blob_box;                  //blob bounding box
  inT16 blob_ht_above_baseline;

  const char *word_str;
  inT16 i;
  inT16 offset;
  float min;                     //min ambig ch ht
  float max;                     //max ambig ch ht
  float short_limit;             // for lower case
  float tall_limit;              // for upper case

  x_ht_ok_variation =
    (bln_x_height / x_ht_fraction_of_caps_ht - bln_x_height) * x_ht_variation;

  if (stats.get_total () == 0) {
    *ambig_lc_x_est = 0;
    *ambig_uc_caps_est = 0;
  }
  else {
    min = stats.ile (0.0);
    max = stats.ile (0.99999);
    if ((max - min) < x_ht_ok_variation) {
      *ambig_lc_x_est = *ambig_uc_caps_est = stats.mean ();
      //close enough
    }
    else {
    /* Try reclustering into lower and upper case chars */
      short_limit = min + (max - min) * x_ht_variation;
      tall_limit = max - (max - min) * x_ht_variation;
      word_str = word_res->best_choice->unichar_string().string();
      blob_it.set_to_list (word_res->outword->blob_list ());
      for (blob_it.mark_cycle_pt (), i = 0, offset = 0;
      !blob_it.cycled_list (); blob_it.forward (),
               offset += word_res->best_choice->unichar_lengths()[i++]) {
        if (word_res->reject_map[i].accepted () &&
          STRING (chs_ambig_caps_x).contains (word_str[offset]) &&
        (!dodgy_blob (blob_it.data ()))) {
          blob_box = blob_it.data ()->bounding_box ();
          blob_ht_above_baseline =
            blob_box.top () - bln_baseline_offset;
          if (blob_ht_above_baseline <= short_limit)
            short_ambigs.add (blob_ht_above_baseline, 1);
          else if (blob_ht_above_baseline >= tall_limit)
            tall_ambigs.add (blob_ht_above_baseline, 1);
        }
      }
      *ambig_lc_x_est = short_ambigs.mean ();
      *ambig_uc_caps_est = tall_ambigs.mean ();
      /* Cop out if we havent got sensible clusters. */
      if (*ambig_uc_caps_est - *ambig_lc_x_est <= x_ht_ok_variation)
        *ambig_lc_x_est = *ambig_uc_caps_est = stats.mean ();
      //close enough
    }
  }
}


/**
 * dodgy_blob()
 * Returns true if the blob has more than one outline, one above the other.
 * These are dodgy as the top blob could be noise, causing the bounding box xht
 * to be misleading
 */

BOOL8 dodgy_blob(PBLOB *blob) {
  OUTLINE_IT outline_it = blob->out_list ();
  inT16 highest_bottom = -MAX_INT16;
  inT16 lowest_top = MAX_INT16;
  TBOX outline_box;

  if (x_ht_include_dodgy_blobs)
    return FALSE;                //no blob is ever dodgy
  for (outline_it.mark_cycle_pt ();
  !outline_it.cycled_list (); outline_it.forward ()) {
    outline_box = outline_it.data ()->bounding_box ();
    if (lowest_top > outline_box.top ())
      lowest_top = outline_box.top ();
    if (highest_bottom < outline_box.bottom ())
      highest_bottom = outline_box.bottom ();
  }
  return highest_bottom >= lowest_top;
}
/////////////////////////////////////////////////////////////////fixxht////////////////////////////////////////

/////////////////////////////////////////////////////////////////drawfx////////////////////////////////////////
#define FXDEMOWIN     "FXDemo"
#define FXDEMOXPOS      250
#define FXDEMOYPOS      0
#define FXDEMOXSIZE     600
#define FXDEMOYSIZE     256
#define BLN_MAX       512        //max coord for bln
#define WERDWIDTH       (BLN_MAX*20)
#define DECENT_WERD_WIDTH (5*bln_x_height)

//title of window
//#define DEBUG_WIN_NAME    "FXDebug"
#define DEBUG_XPOS      0
#define DEBUG_YPOS      120
#define DEBUG_XSIZE     80
#define DEBUG_YSIZE     32
#define YMAX        3508
#define XMAX        2550
#define MAXEDGELENGTH   1024     //max steps inoutline

#define EXTERN

EXTERN STRING_VAR (fx_debugfile, DEBUG_WIN_NAME, "Name of debugfile");

EXTERN ScrollView* fx_win = NULL;
EXTERN FILE *fx_debug = NULL;

/**********************************************************************
 * create_fx_win
 *
 * Create the fx window used to show the fit.
 **********************************************************************/

void create_fx_win() {  //make features win
  fx_win = new ScrollView (FXDEMOWIN,
    FXDEMOXPOS, FXDEMOYPOS, FXDEMOXSIZE, FXDEMOYSIZE,
    WERDWIDTH*2, BLN_MAX*2, true);
}


/**********************************************************************
 * clear_fx_win
 *
 * Clear the fx window and draw on the base/mean lines.
 **********************************************************************/

void clear_fx_win() {  //make features win
  fx_win->Clear();
  fx_win->Pen(64,64,64);
  fx_win->Line(-WERDWIDTH, bln_baseline_offset, WERDWIDTH, bln_baseline_offset);
  fx_win->Line(-WERDWIDTH, bln_x_height + bln_baseline_offset, WERDWIDTH, bln_x_height + bln_baseline_offset);
}

/**********************************************************************
 * create_fxdebug_win
 *
 * Create the fx window used to show the fit.
 **********************************************************************/

void create_fxdebug_win() {  //make gradients win
  //      if (strcmp(fx_debugfile.string(),DEBUG_WIN_NAME)==0)
  //              fx_debug=create_debug_window(fx_debugfile.string(),
  //                      DEBUG_XPOS,DEBUG_YPOS,
  //                      DEBUG_XSIZE,DEBUG_YSIZE);
  //      else
  //              fx_debug=fopen(fx_debugfile.string(),"w");
}
/////////////////////////////////////////////////////////////////drawfx////////////////////////////////////////

/////////////////////////////////////////////////////////////////expandblob////////////////////////////////////////
/***********************************************************************
free_blob(blob) frees the blob and everything it is connected to,
i.e. outlines, nodes, edgepts, bytevecs, ratings etc
*************************************************************************/
void free_blob(  /*blob to free */
               register TBLOB *blob) {
  if (blob == NULL)
    return;                      /*duff blob */
  free_tree (blob->outlines);    /*do the tree of outlines */
  oldblob(blob);  /*free the actual blob */
}


/***************************************************************************
free_tree(outline) frees the current outline
and then its sub-tree
*****************************************************************************/
void free_tree(  /*outline to draw */
               register TESSLINE *outline) {
  if (outline == NULL)
    return;                      /*duff outline */
  if (outline->next != NULL)
    free_tree (outline->next);
  if (outline->child != NULL)
    free_tree (outline->child);  /*and sub-tree */
  free_outline(outline);  /*free the outline */
}


/*******************************************************************************
free_outline(outline) frees an outline and anything connected to it
*********************************************************************************/
void free_outline(  /*outline to free */
                  register TESSLINE *outline) {
  if (outline->compactloop != NULL)
                                 /*no compact loop */
      memfree (outline->compactloop);

  if (outline->loop != NULL)
    free_loop (outline->loop);

  oldoutline(outline);
}


/*********************************************************************************
free_loop(startpt) frees all the elements of the closed loop
starting at startpt
***********************************************************************************/
void free_loop(  /*outline to free */
               register EDGEPT *startpt) {
  register EDGEPT *edgept;       /*current point */

  if (startpt == NULL)
    return;
  edgept = startpt;
  do {
    edgept = oldedgept (edgept); /*free it and move on */
  }
  while (edgept != startpt);
}
/////////////////////////////////////////////////////////////////expandblob////////////////////////////////////////

/////////////////////////////////////////////////////////////////efio////////////////////////////////////////
#define MAXERRORMESSAGE   256

/**----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
FILE *Efopen(const char *Name, const char *Mode) {
/*
 **	Parameters:
 **		Name	name of file to be opened
 **		Mode	mode to be used to open file
 **	Globals:
 **		None
 **	Operation:
 **		This routine attempts to open the specified file in the
 **		specified mode.  If the file can be opened, a pointer to
 **		the open file is returned.  If the file cannot be opened,
 **		an error is trapped.
 **	Return:
 **		Pointer to open file.
 **	Exceptions:
 **		FOPENERROR		unable to open specified file
 **	History:
 **		5/21/89, DSJ, Created.
 */
  FILE *File;
  char ErrorMessage[MAXERRORMESSAGE];

  File = fopen (Name, Mode);
  if (File == NULL) {
    sprintf (ErrorMessage, "Unable to open %s", Name);
    DoError(FOPENERROR, ErrorMessage);
    return (NULL);
  }
  else
    return (File);
}                                /* Efopen */
/////////////////////////////////////////////////////////////////efio////////////////////////////////////////

/////////////////////////////////////////////////////////////////flexfx////////////////////////////////////////
/**----------------------------------------------------------------------------
              Public Code
----------------------------------------------------------------------------**/
/*---------------------------------------------------------------------------*/
CHAR_DESC ExtractFlexFeatures(TBLOB *Blob, LINE_STATS *LineStats) {
/*
 **	Parameters:
 **		Blob		blob to extract features from
 **		LineStats	statistics about text line Blob is on
 **	Globals: none
 **	Operation: Allocate a new character descriptor and fill it in by
 **		calling all feature extractors which are enabled.
 **	Return: Structure containing features extracted from Blob.
 **	Exceptions: none
 **	History: Wed May 23 13:46:22 1990, DSJ, Created.
 */
  int Type;
  CHAR_DESC CharDesc;

  CharDesc = NewCharDescription ();

  for (Type = 0; Type < (int)CharDesc->NumFeatureSets; Type++)
    if (FeatureDefs.FeatureExtractors[Type] != NULL &&
        FeatureDefs.FeatureExtractors[Type]->Extractor != NULL) {
      CharDesc->FeatureSets[Type] =
        (FeatureDefs.FeatureExtractors[Type])->Extractor(Blob, LineStats);
      if (CharDesc->FeatureSets[Type] == NULL) {
        FreeCharDescription(CharDesc);
        return NULL;
      }
    }

  return (CharDesc);

}                                /* ExtractFlexFeatures */
/////////////////////////////////////////////////////////////////flexfx////////////////////////////////////////

/////////////////////////////////////////////////////////////////extract////////////////////////////////////////
typedef CHAR_FEATURES (*CF_FUNC) ();

/*-----------------------------------------------------------------------------
          Private Function Prototypes
-----------------------------------------------------------------------------*/
void ExtractorStub();

/*-----------------------------------------------------------------------------
        Global Data Definitions and Declarations
-----------------------------------------------------------------------------*/
/** tables to keep track of the different low level feature extractors */
#define NUM_FX        3
#define DEFAULT_FX      2

int CurrentFx = DEFAULT_FX;

/*-----------------------------------------------------------------------------
              Public Code
-----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/**
 * Extract features from Blob by calling the feature
 * extractor which is currently being used.  This routine
 * simply provides a high level interface to feature
 * extraction.  The caller can extract any type of features
 * from a blob without understanding any lower level details.
 *
 * @param Blob		blob to extract features from
 * @param LineStats	statistics about line blob is in
 *
 * @return The character features extracted from Blob.
 * @note Exceptions: none
 * @note History: Sun Jan 21 10:07:28 1990, DSJ, Created.
 */
CHAR_DESC ExtractBlobFeatures(TBLOB *Blob, LINE_STATS *LineStats) {
  return (ExtractFlexFeatures (Blob, LineStats));
}                                /* ExtractBlobFeatures */

/*-----------------------------------------------------------------------------
              Private Code
-----------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
void
ExtractorStub ()
/**
 * This routine is used to stub out feature extractors
 * that are no longer used.  It simply calls DoError.
 *
 * @note Exceptions: none
 * @note History: Wed Jan  2 14:16:49 1991, DSJ, Created.
 */
#define DUMMY_ERROR     1
{
  DoError (DUMMY_ERROR, "Selected feature extractor has been stubbed out!");
}                                /* ExtractorStub */
/////////////////////////////////////////////////////////////////extract////////////////////////////////////////

/////////////////////////////////////////////////////////////////blobclass////////////////////////////////////////
#define MAXFILENAME             80
#define MAXMATCHES              10

static const char kUnknownFontName[] = "UnknownFont";

STRING_VAR(classify_font_name, kUnknownFontName,
           "Default font name to be used in training");

/**----------------------------------------------------------------------------
        Global Data Definitions and Declarations
----------------------------------------------------------------------------**/
/* name of current image file being processed */
extern char imagefile[];

/**----------------------------------------------------------------------------
            Public Code
----------------------------------------------------------------------------**/

/*---------------------------------------------------------------------------*/
void LearnBlob(const STRING& filename,
               TBLOB * Blob, TEXTROW * Row, const char* BlobText) {
/*
 **      Parameters:
 **              Blob            blob whose micro-features are to be learned
 **              Row             row of text that blob came from
 **              BlobText        text that corresponds to blob
 **              TextLength      number of characters in blob
 **      Globals:
 **              imagefile       base filename of the page being learned
 **              classify_font_name
 **                              name of font currently being trained on
 **      Operation:
 **              Extract micro-features from the specified blob and append
 **              them to the appropriate file.
 **      Return: none
 **      Exceptions: none
 **      History: 7/28/89, DSJ, Created.
 */
#define TRAIN_SUFFIX    ".tr"
  static FILE *FeatureFile = NULL;
  STRING Filename(filename);

  // If no fontname was set, try to extract it from the filename
  STRING CurrFontName = classify_font_name;
  if (CurrFontName == kUnknownFontName) {
    // filename is expected to be of the form [lang].[fontname].exp[num]
    // The [lang], [fontname] and [num] fields should not have '.' characters.
    const char *basename = strrchr(filename.string(), '/');
    const char *firstdot = strchr(basename ? basename : filename.string(), '.');
    const char *lastdot  = strrchr(filename.string(), '.');
    if (firstdot != lastdot && firstdot != NULL && lastdot != NULL) {
      strncpy(&CurrFontName[0], firstdot + 1, lastdot - firstdot - 1);
      CurrFontName[lastdot - firstdot - 1] = '\0';
    }
  }

  // if a feature file is not yet open, open it
  // the name of the file is the name of the image plus TRAIN_SUFFIX
  if (FeatureFile == NULL) {
    Filename += TRAIN_SUFFIX;
    FeatureFile = Efopen(Filename.string(), "w");
    cprintf("TRAINING ... Font name = %s\n", CurrFontName.string());
  }

  LearnBlob(FeatureFile, Blob, Row, BlobText, CurrFontName.string());
}                                // LearnBlob

void LearnBlob(FILE* FeatureFile, TBLOB* Blob, TEXTROW* Row,
               const char* BlobText, const char* FontName) {
  CHAR_DESC CharDesc;
  LINE_STATS LineStats;

  EnterLearnMode;

  GetLineStatsFromRow(Row, &LineStats);

  CharDesc = ExtractBlobFeatures (Blob, &LineStats);
  if (CharDesc == NULL) {
    cprintf("LearnBLob: CharDesc was NULL. Aborting.\n");
    return;
  }

  // label the features with a class name and font name
  fprintf (FeatureFile, "\n%s %s ", FontName, BlobText);

  // write micro-features to file and clean up
  WriteCharDescription(FeatureFile, CharDesc);
  FreeCharDescription(CharDesc);

}                                // LearnBlob
/////////////////////////////////////////////////////////////////blobclass////////////////////////////////////////

/////////////////////////////////////////////////////////////////tfacepp////////////////////////////////////////
#define EXTERN
EXTERN BOOL_VAR (tessedit_override_permuter, TRUE, "According to dict_word");
#define MAX_UNDIVIDED_LENGTH 24
/**********************************************************************
 * recog_word
 *
 * Convert the word to tess form and pass it to the tess segmenter.
 * Convert the output back to editor form.
 **********************************************************************/
WERD_CHOICE *Tesseract::recog_word(                     //recog one owrd
                                   WERD *word,          //word to do
                                   DENORM *denorm,      //de-normaliser
                                                        //matcher function
                                   POLY_MATCHER matcher,
                                   POLY_TESTER tester,  //tester function
                                   POLY_TESTER trainer, //trainer function
                                   BOOL8 testing,       //true if answer driven
                                                        //raw result
                                   WERD_CHOICE *&raw_choice,
                                                        //list of blob lists
                                   BLOB_CHOICE_LIST_CLIST *blob_choices,
                                   WERD *&outword       //bln word output
                                  ) {
  WERD_CHOICE *word_choice;
  uinT8 perm_type;
  uinT8 real_dict_perm_type;

  if (word->blob_list ()->empty ()) {
    word_choice = new WERD_CHOICE("", NULL, 10.0f, -1.0f,
                                  TOP_CHOICE_PERM, unicharset);
    raw_choice = new WERD_CHOICE("", NULL, 10.0f, -1.0f,
                                 TOP_CHOICE_PERM, unicharset);
    outword = word->poly_copy (denorm->row ()->x_height ());
  }
  else
    word_choice = recog_word_recursive (word, denorm, matcher, tester,
      trainer, testing, raw_choice,
      blob_choices, outword);
  if ((word_choice->length() != outword->blob_list()->length()) ||
      (word_choice->length() != blob_choices->length())) {
    tprintf
      ("recog_word ASSERT FAIL String:\"%s\"; Strlen=%d; #Blobs=%d; #Choices=%d\n",
      word_choice->debug_string(unicharset).string(),
      word_choice->length(), outword->blob_list()->length(),
      blob_choices->length());
  }
  ASSERT_HOST(word_choice->length() == outword->blob_list()->length());
  ASSERT_HOST(word_choice->length() == blob_choices->length());

  /* Copy any reject blobs into the outword */
  outword->rej_blob_list()->deep_copy(word->rej_blob_list(), &PBLOB::deep_copy);

  if (tessedit_override_permuter) {
    /* Override the permuter type if a straight dictionary check disagrees. */
    perm_type = word_choice->permuter();
    if ((perm_type != SYSTEM_DAWG_PERM) &&
        (perm_type != FREQ_DAWG_PERM) && (perm_type != USER_DAWG_PERM)) {
      real_dict_perm_type = dict_word(*word_choice);
      if (((real_dict_perm_type == SYSTEM_DAWG_PERM) ||
           (real_dict_perm_type == FREQ_DAWG_PERM) ||
           (real_dict_perm_type == USER_DAWG_PERM)) &&
          (alpha_count(word_choice->unichar_string().string(),
                      word_choice->unichar_lengths().string()) > 0)) {
        word_choice->set_permuter (real_dict_perm_type);  // use dict perm
      }
    }
    if (tessedit_rejection_debug && perm_type != word_choice->permuter ()) {
      tprintf ("Permuter Type Flipped from %d to %d\n",
        perm_type, word_choice->permuter ());
    }
  }
  assert ((word_choice == NULL) == (raw_choice == NULL));
  return word_choice;
}


/**********************************************************************
 * recog_word_recursive
 *
 * Convert the word to tess form and pass it to the tess segmenter.
 * Convert the output back to editor form.
 **********************************************************************/
WERD_CHOICE *
Tesseract::recog_word_recursive(
    WERD *word,                            // word to do
    DENORM *denorm,                        // de-normaliser
    POLY_MATCHER matcher,                  // matcher function
    POLY_TESTER tester,                    // tester function
    POLY_TESTER trainer,                   // trainer function
    BOOL8 testing,                         // true if answer driven
    WERD_CHOICE *&raw_choice,              // raw result
    BLOB_CHOICE_LIST_CLIST *blob_choices,  // list of blob lists
    WERD *&outword                         // bln word output
    ) {
  inT32 initial_blob_choice_len;
  inT32 word_length;                      // no of blobs
  STRING word_string;                     // converted from tess
  STRING word_string_lengths;
  BLOB_CHOICE_LIST_VECTOR *tess_ratings;  // tess results
  TWERD *tessword;                        // tess format
  BLOB_CHOICE_LIST_C_IT blob_choices_it;  // iterator

  tess_matcher = matcher;           // install matcher
  tess_tester = testing ? tester : NULL;
  tess_trainer = testing ? trainer : NULL;
  tess_denorm = denorm;
  tess_word = word;
  //      blob_matchers[1]=call_matcher;
  if (word->blob_list ()->length () > MAX_UNDIVIDED_LENGTH) {
    return split_and_recog_word (word, denorm, matcher, tester, trainer,
      testing, raw_choice, blob_choices,
      outword);
  } else {
    UNICHAR_ID space_id = unicharset.unichar_to_id(" ");
    WERD_CHOICE *best_choice = new WERD_CHOICE();
    raw_choice = new WERD_CHOICE();
    initial_blob_choice_len = blob_choices->length();
    tessword = make_tess_word (word, NULL);
    tess_ratings = cc_recog(tessword, best_choice, raw_choice,
                            testing && tester != NULL,
                            testing && trainer != NULL,
                            word->flag(W_EOL));

    outword = make_ed_word (tessword, word);  // convert word
    if (outword == NULL) {
      outword = word->poly_copy (denorm->row ()->x_height ());
    }
    delete_word(tessword);  // get rid of it
    word_length = outword->blob_list()->length();  // no of blobs

    // Put BLOB_CHOICE_LISTs from tess_ratings into blob_choices.
    blob_choices_it.set_to_list(blob_choices);
    for (int i = 0; i < tess_ratings->length(); ++i) {
      blob_choices_it.add_to_end(tess_ratings->get(i));
    }
    delete tess_ratings;

    // Pad raw_choice with spaces if needed.
    if (raw_choice->length() < word_length) {
      while (raw_choice->length() < word_length) {
        raw_choice->append_unichar_id(space_id, 1, 0.0,
                                      raw_choice->certainty());
      }
      raw_choice->populate_unichars(unicharset);
    }

    // Do sanity checks and minor fixes on best_choice.
    if (best_choice->length() > word_length) {
      tprintf("recog_word: Discarded long string \"%s\""
              " (%d characters vs %d blobs)\n",
              best_choice->unichar_string().string (),
              best_choice->length(), word_length);
      best_choice->make_bad();  // should never happen
      tprintf("Word is at (%g,%g)\n",
              denorm->origin(),
              denorm->y(word->bounding_box().bottom(), 0.0));
    }
    if (blob_choices->length() - initial_blob_choice_len != word_length) {
      best_choice->make_bad();  // force rejection
      tprintf ("recog_word: Choices list len:%d; blob lists len:%d\n",
        blob_choices->length(), word_length);
      blob_choices_it.set_to_list(blob_choices);  // list of lists
      while (blob_choices->length() - initial_blob_choice_len < word_length) {
        blob_choices_it.add_to_end(new BLOB_CHOICE_LIST());  // add a fake one
        tprintf("recog_word: Added dummy choice list\n");
      }
      while (blob_choices->length() - initial_blob_choice_len > word_length) {
        blob_choices_it.move_to_last(); // should never happen
        delete blob_choices_it.extract();
        tprintf("recog_word: Deleted choice list\n");
      }
    }
    if (best_choice->length() < word_length) {
      while (best_choice->length() < word_length) {
        best_choice->append_unichar_id(space_id, 1, 0.0,
                                       best_choice->certainty());
      }
      best_choice->populate_unichars(unicharset);
    }

    return best_choice;
  }
}


/**********************************************************************
 * split_and_recog_word
 *
 * Convert the word to tess form and pass it to the tess segmenter.
 * Convert the output back to editor form.
 **********************************************************************/

WERD_CHOICE *
Tesseract::split_and_recog_word(                        //recog one owrd
                                WERD *word,             //word to do
                                DENORM *denorm,         //de-normaliser
                                POLY_MATCHER matcher,   //matcher function
                                POLY_TESTER tester,     //tester function
                                POLY_TESTER trainer,    //trainer function
                                BOOL8 testing,          //true if answer driven
                                                        //raw result
                                WERD_CHOICE *&raw_choice,
                                                        //list of blob lists
                                BLOB_CHOICE_LIST_CLIST *blob_choices,
                                WERD *&outword          //bln word output
                               ) {
  //   inT32                                                      outword1_len;
  //   inT32                                                      outword2_len;
  WERD *first_word;              //poly copy of word
  WERD *second_word;             //fabricated word
  WERD *outword2;                //2nd output word
  PBLOB *blob;
  WERD_CHOICE *result;           //return value
  WERD_CHOICE *result2;          //output of 2nd word
  WERD_CHOICE *raw_choice2;      //raw version of 2nd
  float gap;                     //blob gap
  float bestgap;                 //biggest gap
  PBLOB_LIST new_blobs;          //list of gathered blobs
  PBLOB_IT blob_it;
                                 //iterator
  PBLOB_IT new_blob_it = &new_blobs;

  first_word = word->poly_copy (denorm->row ()->x_height ());
  blob_it.set_to_list (first_word->blob_list ());
  bestgap = (float) -MAX_INT32;
  while (!blob_it.at_last ()) {
    blob = blob_it.data ();
                                 //gap to next
    gap = (float) blob_it.data_relative(1)->bounding_box().left() -
        blob->bounding_box().right();
    blob_it.forward ();
    if (gap > bestgap) {
      bestgap = gap;             //find biggest
      new_blob_it = blob_it;     //save position
    }
  }
                                 //take 2nd half
  new_blobs.assign_to_sublist (&new_blob_it, &blob_it);
                                 //make it a word
  second_word = new WERD (&new_blobs, 1, NULL);
  ASSERT_HOST (word->blob_list ()->length () ==
    first_word->blob_list ()->length () +
    second_word->blob_list ()->length ());

  result = recog_word_recursive (first_word, denorm, matcher,
    tester, trainer, testing, raw_choice,
    blob_choices, outword);
  delete first_word;             //done that one
  result2 = recog_word_recursive (second_word, denorm, matcher,
    tester, trainer, testing, raw_choice2,
    blob_choices, outword2);
  delete second_word;            //done that too
  *result += *result2;           //combine ratings
  delete result2;
  *raw_choice += *raw_choice2;
  delete raw_choice2;            //finished with it
  //   outword1_len= outword->blob_list()->length();
  //   outword2_len= outword2->blob_list()->length();
  outword->join_on (outword2);   //join words
  delete outword2;
  //   if ( outword->blob_list()->length() != outword1_len + outword2_len )
  //      tprintf( "Split&Recog: part1len=%d; part2len=%d; combinedlen=%d\n",
  //                                outword1_len, outword2_len, outword->blob_list()->length() );
  //   ASSERT_HOST( outword->blob_list()->length() == outword1_len + outword2_len );
  return result;
}
/**********************************************************************
 * call_tester
 *
 * Called from Tess with a blob in tess form.
 * Convert the blob to editor form.
 * Call the tester setup by the segmenter in tess_tester.
 **********************************************************************/
#if 0  // dead code
void call_tester(                     //call a tester
                 const STRING& filename,
                 TBLOB *tessblob,     //blob to test
                 BOOL8 correct_blob,  //true if good
                 char *text,          //source text
                 inT32 count,         //chars in text
                 LIST result          //output of matcher
                ) {
  PBLOB *blob;                   //converted blob
  BLOB_CHOICE_LIST ratings;      //matcher result

  blob = make_ed_blob (tessblob);//convert blob
  if (blob == NULL)
    return;
                                 //make it right type
  convert_choice_list(result, ratings);
  if (tess_tester != NULL)
    (*tess_tester) (filename, blob, tess_denorm, correct_blob, text, count, &ratings);
  delete blob;                   //don't need that now
}
#endif

/**********************************************************************
 * call_train_tester
 *
 * Called from Tess with a blob in tess form.
 * Convert the blob to editor form.
 * Call the trainer setup by the segmenter in tess_trainer.
 **********************************************************************/
#if 0  // dead code
void call_train_tester(                     //call a tester
                       const STRING& filename,
                       TBLOB *tessblob,     //blob to test
                       BOOL8 correct_blob,  //true if good
                       char *text,          //source text
                       inT32 count,         //chars in text
                       LIST result          //output of matcher
                      ) {
  PBLOB *blob;                   //converted blob
  BLOB_CHOICE_LIST ratings;      //matcher result

  blob = make_ed_blob (tessblob);//convert blob
  if (blob == NULL)
    return;
                                 //make it right type
  convert_choice_list(result, ratings);
  if (tess_trainer != NULL)
    (*tess_trainer) (filename, blob, tess_denorm, correct_blob, text, count, &ratings);
  delete blob;                   //don't need that now
}
#endif
/////////////////////////////////////////////////////////////////tfacepp////////////////////////////////////////

/////////////////////////////////////////////////////////////////tessbox////////////////////////////////////////
#define EXTERN
/**
 * @name tess_segment_pass1
 *
 * Segment a word using the pass1 conditions of the tess segmenter.
 * @param word bln word to do
 * @param denorm de-normaliser
 * @param matcher matcher function
 * @param raw_choice raw result
 * @param blob_choices list of blob lists
 * @param outword bln word output
 */
WERD_CHOICE *Tesseract::tess_segment_pass1(WERD *word,
                                           DENORM *denorm,
                                           POLY_MATCHER matcher,
                                           WERD_CHOICE *&raw_choice,
                                           BLOB_CHOICE_LIST_CLIST *blob_choices,
                                           WERD *&outword) {
  WERD_CHOICE *result;           //return value
  int saved_enable_assoc = 0;
  int saved_chop_enable = 0;

  if (word->flag (W_DONT_CHOP)) {
    saved_enable_assoc = wordrec_enable_assoc;
    saved_chop_enable = chop_enable;
    wordrec_enable_assoc.set_value(0);
    chop_enable.set_value(0);
    if (word->flag (W_REP_CHAR))
      permute_only_top = 1;
  }
  set_pass1();
  //      tprintf("pass1 chop on=%d, seg=%d, onlytop=%d",chop_enable,enable_assoc,permute_only_top);
  result = recog_word (word, denorm, matcher, NULL, NULL, FALSE,
    raw_choice, blob_choices, outword);
  if (word->flag (W_DONT_CHOP)) {
    wordrec_enable_assoc.set_value(saved_enable_assoc);
    chop_enable.set_value(saved_chop_enable);
    permute_only_top = 0;
  }
  return result;
}


/**
 * @name tess_segment_pass2
 *
 * Segment a word using the pass2 conditions of the tess segmenter.
 * @param word bln word to do
 * @param denorm de-normaliser
 * @param matcher matcher function
 * @param raw_choice raw result
 * @param blob_choices list of blob lists
 * @param outword bln word output
 */

WERD_CHOICE *Tesseract::tess_segment_pass2(WERD *word,
                                           DENORM *denorm,
                                           POLY_MATCHER matcher,
                                           WERD_CHOICE *&raw_choice,
                                           BLOB_CHOICE_LIST_CLIST *blob_choices,
                                           WERD *&outword) {
  WERD_CHOICE *result;           //return value
  int saved_enable_assoc = 0;
  int saved_chop_enable = 0;

  if (word->flag (W_DONT_CHOP)) {
    saved_enable_assoc = wordrec_enable_assoc;
    saved_chop_enable = chop_enable;
    wordrec_enable_assoc.set_value(0);
    chop_enable.set_value(0);
    if (word->flag (W_REP_CHAR))
      permute_only_top = 1;
  }
  set_pass2();
  result = recog_word (word, denorm, matcher, NULL, NULL, FALSE,
    raw_choice, blob_choices, outword);
  if (word->flag (W_DONT_CHOP)) {
    wordrec_enable_assoc.set_value(saved_enable_assoc);
    chop_enable.set_value(saved_chop_enable);
    permute_only_top = 0;
  }
  return result;
}


/**
 * @name correct_segment_pass2
 *
 * Segment a word correctly using the pass2 conditions of the tess segmenter.
 * Then call the tester with all the correctly segmented blobs.
 * If the correct segmentation cannot be found, the tester is called
 * with the segmentation found by tess and all the correct flags set to
 * false and all strings are NULL.
 * @param word bln word to do
 * @param denorm de-normaliser
 * @param matcher matcher function
 * @param tester tester function
 * @param raw_choice raw result
 * @param blob_choices list of blob lists
 * @param outword bln word output
 */

WERD_CHOICE *Tesseract::correct_segment_pass2(WERD *word,
                                              DENORM *denorm,
                                              POLY_MATCHER matcher,
                                              POLY_TESTER tester,
                                              WERD_CHOICE *&raw_choice,
                                              BLOB_CHOICE_LIST_CLIST *blob_choices,
                                              WERD *&outword) {
  set_pass2();
  return recog_word (word, denorm, matcher, NULL, tester, TRUE,
    raw_choice, blob_choices, outword);
}


/**
 * @name test_segment_pass2
 *
 * Segment a word correctly using the pass2 conditions of the tess segmenter.
 * Then call the tester on all words used by tess in its search.
 * Do this only on words where the correct segmentation could be found.
 * @param word bln word to do
 * @param denorm de-normaliser
 * @param matcher matcher function
 * @param tester tester function
 * @param raw_choice raw result
 * @param blob_choices list of blob lists
 * @param outword bln word output
 */
WERD_CHOICE *Tesseract::test_segment_pass2(WERD *word,
                                           DENORM *denorm,
                                           POLY_MATCHER matcher,
                                           POLY_TESTER tester,
                                           WERD_CHOICE *&raw_choice,
                                           BLOB_CHOICE_LIST_CLIST *blob_choices,
                                           WERD *&outword) {
  set_pass2();
  return recog_word (word, denorm, matcher, tester, NULL, TRUE,
    raw_choice, blob_choices, outword);
}


/**
 * @name tess_acceptable_word
 *
 * @return true if the word is regarded as "good enough".
 * @param word_choice after context
 * @param raw_choice before context
 */
BOOL8 Tesseract::tess_acceptable_word(WERD_CHOICE *word_choice,
                                      WERD_CHOICE *raw_choice) {
  return getDict().AcceptableResult(*word_choice, *raw_choice);
}


/**
 * @name tess_adaptable_word
 *
 * @return true if the word is regarded as "good enough".
 * @param word word to test
 * @param best_choice after context
 * @param raw_choice before context
 */
BOOL8 Tesseract::tess_adaptable_word(WERD *word,
                                     WERD_CHOICE *best_choice,
                                     WERD_CHOICE *raw_choice) {
  TWERD *tessword = make_tess_word(word, NULL);
  int result = (tessword && best_choice && raw_choice &&
                AdaptableWord(tessword, *best_choice, *raw_choice));
  delete_word(tessword);
  return result != 0;
}


/**
 * @name tess_cn_matcher
 *
 * Match a blob using the Tess Char Normalized (non-adaptive) matcher
 * only.
 * @param pblob previous blob
 * @param blob blob to match
 * @param nblob next blob
 * @param word word it came from
 * @param denorm de-normaliser
 * @param[out] ratings list of results
 * @param[out] cpresults may be null
 */

void Tesseract::tess_cn_matcher(PBLOB *pblob,
                                PBLOB *blob,
                                PBLOB *nblob,
                                WERD *word,
                                DENORM *denorm,
                                BLOB_CHOICE_LIST *ratings,
                                CLASS_PRUNER_RESULTS cpresults)
{
    Q_UNUSED(pblob);
    Q_UNUSED(nblob);
    Q_UNUSED(word);
  TBLOB *tessblob;               //converted blob
  TEXTROW tessrow;               //dummy row

  tess_cn_matching.set_value(true);       //turn it on
  tess_bn_matching.set_value(false);
                                 //convert blob
  tessblob = make_rotated_tess_blob(denorm, blob, true);
                                 //make dummy row
  make_tess_row(denorm, &tessrow);
                                 //classify
  AdaptiveClassifier(tessblob, NULL, &tessrow, ratings, cpresults);
  free_blob(tessblob);
}


/**
 * @name tess_bn_matcher
 *
 * Match a blob using the Tess Baseline Normalized (adaptive) matcher
 * only.
 * @param pblob previous blob
 * @param blob blob to match
 * @param nblob next blob
 * @param word word it came from
 * @param denorm de-normaliser
 * @param[out] ratings list of results
 */

void Tesseract::tess_bn_matcher(PBLOB *pblob,
                                PBLOB *blob,
                                PBLOB *nblob,
                                WERD *word,
                                DENORM *denorm,
                                BLOB_CHOICE_LIST *ratings)
{
    Q_UNUSED(pblob);
    Q_UNUSED(nblob);
    Q_UNUSED(word);
  TBLOB *tessblob;               //converted blob
  TEXTROW tessrow;               //dummy row

  tess_bn_matching.set_value(true);       //turn it on
  tess_cn_matching.set_value(false);
                                 //convert blob
  tessblob = make_rotated_tess_blob(denorm, blob, true);
                                 //make dummy row
  make_tess_row(denorm, &tessrow);
                                 //classify
  AdaptiveClassifier(tessblob, NULL, &tessrow, ratings, NULL);
  free_blob(tessblob);
}


/**
 * @name tess_default_matcher
 *
 * Match a blob using the default functionality of the Tess matcher.
 * @param pblob previous blob
 * @param blob blob to match
 * @param nblob next blob
 * @param word word it came from
 * @param denorm de-normaliser
 * @param[out] ratings list of results
 * @param script (unused)
 */

void Tesseract::tess_default_matcher(PBLOB *pblob,
                                     PBLOB *blob,
                                     PBLOB *nblob,
                                     WERD *word,
                                     DENORM *denorm,
                                     BLOB_CHOICE_LIST *ratings,
                                     const char* script)
{
    Q_UNUSED(pblob);
    Q_UNUSED(nblob);
    Q_UNUSED(word);
    Q_UNUSED(script);
  assert(ratings != NULL);
  TBLOB *tessblob;               //converted blob
  TEXTROW tessrow;               //dummy row

  tess_bn_matching.set_value(false);      //turn it off
  tess_cn_matching.set_value(false);
                                 //convert blob
  tessblob = make_rotated_tess_blob(denorm, blob, true);
                                 //make dummy row
  make_tess_row(denorm, &tessrow);
                                 //classify
  AdaptiveClassifier (tessblob, NULL, &tessrow, ratings, NULL);
  free_blob(tessblob);
}

/**
 * @name tess_training_tester
 *
 * Matcher tester function which actually trains tess.
 * @param filename filename to output
 * @param blob blob to match
 * @param denorm de-normaliser
 * @param correct ly segmented
 * @param text correct text
 * @param count chars in text
 * @param[out] ratings list of results
 */

void tess_training_tester(const STRING& filename,
                          PBLOB *blob,
                          DENORM *denorm,
                          BOOL8 correct,
                          char *text,
                          inT32 count,
                          BLOB_CHOICE_LIST *ratings)
{
    Q_UNUSED(count);
    Q_UNUSED(ratings);
  TBLOB *tessblob;               //converted blob
  TEXTROW tessrow;               //dummy row

  if (correct) {
    classify_norm_method.set_value(character); // force char norm spc 30/11/93
    tess_bn_matching.set_value(false);    //turn it off
    tess_cn_matching.set_value(false);
                                 //convert blob
    tessblob = make_tess_blob (blob, TRUE);
                                 //make dummy row
    make_tess_row(denorm, &tessrow);
                                 //learn it
    LearnBlob(filename, tessblob, &tessrow, text);
    free_blob(tessblob);
  }
}

/**
 * @name tess_adapter
 *
 * Adapt to the word using the Tesseract mechanism.
 * @param word bln word
 * @param denorm de-normalise
 * @param choice string for word
 * @param raw_choice before context
 * @param rejmap reject map
 */
void Tesseract::tess_adapter(WERD *word,
                             DENORM *denorm,
                             const WERD_CHOICE& choice,
                             const WERD_CHOICE& raw_choice,
                             const char *rejmap) {
  TWERD *tessword;               //converted word
  static TEXTROW tessrow;        //dummy row

                                 //make dummy row
  make_tess_row(denorm, &tessrow);
                                 //make a word
  tessword = make_tess_word (word, &tessrow);
  AdaptToWord(tessword, &tessrow, choice, raw_choice, rejmap);
  //adapt to it
  delete_word(tessword);  //free it
}


/**
 * @name tess_add_doc_word
 *
 * Add the given word to the document dictionary
 */
void Tesseract::tess_add_doc_word(WERD_CHOICE *word_choice) {
  getDict().add_document_word(*word_choice);
}
/////////////////////////////////////////////////////////////////tessbox////////////////////////////////////////



/////////////////////////////////////////////////////////////////control////////////////////////////////////////
#define MIN_FONT_ROW_COUNT  8
#define MAX_XHEIGHT_DIFF  3

#define EXTERN
//extern "C" {
//EXTERN BOOL_VAR(tessedit_small_match,FALSE,"Use small matrix matcher");

//extern FILE*                          matcher_fp;
//extern FILE*                          correct_fp;
//};
BOOL_VAR (tessedit_small_match, FALSE, "Use small matrix matcher");
EXTERN BOOL_VAR (tessedit_print_text, FALSE, "Write text to stdout");
EXTERN BOOL_VAR (tessedit_draw_words, FALSE, "Draw source words");
EXTERN BOOL_VAR (tessedit_draw_outwords, FALSE, "Draw output words");
EXTERN BOOL_VAR (tessedit_training_wiseowl, FALSE, "Call WO to learn blobs");
EXTERN BOOL_VAR (tessedit_training_tess, FALSE, "Call Tess to learn blobs");
EXTERN BOOL_VAR (tessedit_matcher_is_wiseowl, FALSE, "Call WO to classify");
EXTERN BOOL_VAR (tessedit_dump_choices, FALSE, "Dump char choices");
EXTERN BOOL_VAR (tessedit_fix_fuzzy_spaces, TRUE,"Try to improve fuzzy spaces");
EXTERN BOOL_VAR (tessedit_unrej_any_wd, FALSE,"Dont bother with word plausibility");
EXTERN BOOL_VAR (tessedit_fix_hyphens, TRUE, "Crunch double hyphens?");

EXTERN BOOL_VAR (tessedit_reject_fullstops, FALSE, "Reject all fullstops");
EXTERN BOOL_VAR (tessedit_reject_suspect_fullstops, FALSE,"Reject suspect fullstops");
EXTERN BOOL_VAR (tessedit_redo_xheight, TRUE, "Check/Correct x-height");
EXTERN BOOL_VAR (tessedit_cluster_adaption_on, TRUE, "Do our own adaption - ems only");
EXTERN BOOL_VAR (tessedit_enable_doc_dict, TRUE, "Add words to the document dictionary");
EXTERN BOOL_VAR (word_occ_first, FALSE, "Do word occ before re-est xht");
EXTERN BOOL_VAR (tessedit_debug_fonts, FALSE, "Output font info per char");
EXTERN BOOL_VAR (tessedit_xht_fiddles_on_done_wds, TRUE, "Apply xht fix up even if done");
EXTERN BOOL_VAR (tessedit_xht_fiddles_on_no_rej_wds, TRUE, "Apply xht fix up even in no rejects");
EXTERN INT_VAR (x_ht_check_word_occ, 2, "Check Char Block occupancy");
EXTERN INT_VAR (x_ht_stringency, 1, "How many confirmed a/n to accept?");
EXTERN BOOL_VAR (x_ht_quality_check, TRUE, "Dont allow worse quality");
EXTERN BOOL_VAR (tessedit_debug_block_rejection, FALSE, "Block and Row stats");
EXTERN INT_VAR (debug_x_ht_level, 0, "Reestimate debug");
EXTERN BOOL_VAR (rej_use_xht, TRUE, "Individual rejection control");
EXTERN BOOL_VAR (debug_acceptable_wds, FALSE, "Dump word pass/fail chk");

EXTERN STRING_VAR (chs_leading_punct, "('`\"", "Leading punctuation");
EXTERN STRING_VAR (chs_trailing_punct1, ").,;:?!", "1st Trailing punctuation");
EXTERN STRING_VAR (chs_trailing_punct2, ")'`\"", "2nd Trailing punctuation");

EXTERN double_VAR (quality_rej_pc, 0.08, "good_quality_doc lte rejection limit");
EXTERN double_VAR (quality_blob_pc, 0.0, "good_quality_doc gte good blobs limit");
EXTERN double_VAR (quality_outline_pc, 1.0, "good_quality_doc lte outline error limit");
EXTERN double_VAR (quality_char_pc, 0.95, "good_quality_doc gte good char limit");
EXTERN INT_VAR (quality_min_initial_alphas_reqd, 2, "alphas in a good word");

EXTERN BOOL_VAR (tessedit_tess_adapt_to_rejmap, FALSE, "Use reject map to control Tesseract adaption");
EXTERN INT_VAR (tessedit_tess_adaption_mode, 0x27, "Adaptation decision algorithm for tess");
EXTERN INT_VAR (tessedit_em_adaption_mode, 0, "Adaptation decision algorithm for ems matrix matcher");
EXTERN BOOL_VAR (tessedit_cluster_adapt_after_pass1, FALSE, "Adapt using clusterer after pass 1");
EXTERN BOOL_VAR (tessedit_cluster_adapt_after_pass2, FALSE, "Adapt using clusterer after pass 1");
EXTERN BOOL_VAR (tessedit_cluster_adapt_after_pass3, FALSE, "Adapt using clusterer after pass 1");
EXTERN BOOL_VAR (tessedit_cluster_adapt_before_pass1, FALSE, "Adapt using clusterer before Tess adaping during pass 1");
EXTERN INT_VAR (tessedit_cluster_adaption_mode, 0, "Adaptation decision algorithm for matrix matcher");
EXTERN BOOL_VAR (tessedit_adaption_debug, FALSE, "Generate and print debug information for adaption");
EXTERN BOOL_VAR (tessedit_minimal_rej_pass1, FALSE, "Do minimal rejection on pass 1 output");
EXTERN BOOL_VAR (tessedit_test_adaption, FALSE, "Test adaption criteria");
EXTERN BOOL_VAR (tessedit_global_adaption, FALSE, "Adapt to all docs over time");
EXTERN BOOL_VAR (tessedit_matcher_log, FALSE, "Log matcher activity");
EXTERN INT_VAR (tessedit_test_adaption_mode, 3, "Adaptation decision algorithm for tess");
EXTERN BOOL_VAR(save_best_choices, FALSE, "Save the results of the recognition step" " (blob_choices) within the corresponding WERD_CHOICE");

EXTERN BOOL_VAR (test_pt, FALSE, "Test for point");
EXTERN double_VAR (test_pt_x, 99999.99, "xcoord");
EXTERN double_VAR (test_pt_y, 99999.99, "ycoord");

extern int display_ratings;
extern int number_debug;
//FILE *choice_file = NULL;        // Choice file ptr cwj

CLISTIZEH (PBLOB) CLISTIZE (PBLOB)

/* DEBUGGING */
inT16 blob_count(WERD *w)
{
    return w->blob_list ()->length ();
}


/**
 * recog_pseudo_word
 *
 * Make a word from the selected blobs and run Tess on them.
 *
 * @param block_list recognise blobs
 * @param selection_box within this box
 */
void Tesseract::recog_pseudo_word(BLOCK_LIST *block_list, TBOX &selection_box)
{
    WERD *word;
    ROW *pseudo_row;               // row of word
    BLOCK *pseudo_block;           // block of word

    word = make_pseudo_word (block_list, selection_box, pseudo_block, pseudo_row);

    if (word != NULL)
    {
        recog_interactive(pseudo_block, pseudo_row, word);
        delete word;
    }
}


/**
 * recog_interactive
 *
 * Recognize a single word in interactive mode.
 *
 * @param block block
 * @param row row of word
 * @param word word to recognise
 */
BOOL8 Tesseract::recog_interactive(BLOCK *block, ROW *row, WERD *word)
{
    WERD_RES word_res(word);
    inT16 char_qual;
    inT16 good_char_qual;

    classify_word_pass2(&word_res, block, row);
#ifndef SECURE_NAMES
    if (tessedit_debug_quality_metrics)
    {
        word_char_quality(&word_res, row, &char_qual, &good_char_qual);
        tprintf
                ("\n%d chars;  word_blob_quality: %d;  outline_errs: %d; char_quality: %d; good_char_quality: %d\n",
                 word_res.reject_map.length (), word_blob_quality (&word_res, row),
                 word_outline_errs (&word_res), char_qual, good_char_qual);
    }
#endif

    return TRUE;
}


/**
 * recog_all_words()
 *
 * Walk the current block list applying the specified word processor function
 * to all words
 *
 * @param page_res page structure
 * @param monitor progress monitor
 * @param target_word_box specifies just to extract a rectangle
 * @param dopasses 0 - all, 1 just pass 1, 2 passes 2 and higher
 */

void Tesseract::recog_all_words(PAGE_RES *page_res, volatile ETEXT_DESC *monitor, TBOX *target_word_box, inT16 dopasses)
{
    // reset page iterator
    static PAGE_RES_IT page_res_it;
    inT16 chars_in_word;
    inT16 rejects_in_word;
    static CHAR_SAMPLES_LIST em_clusters;
    static CHAR_SAMPLE_LIST ems_waiting;
    static CHAR_SAMPLES_LIST char_clusters;
    static CHAR_SAMPLE_LIST chars_waiting;
    inT16 blob_quality = 0;
    inT16 outline_errs = 0;
    static inT16 doc_blob_quality = 0;
    static inT16 doc_outline_errs = 0;
    static inT16 doc_char_quality = 0;
    inT16 all_char_quality;
    inT16 accepted_all_char_quality;
    static inT16 good_char_count = 0;
    static inT16 doc_good_char_quality = 0;
    int i;


    inT32 tess_adapt_mode = 0;
    static inT32 word_count;       // count of words in doc
    inT32 word_index;              // current word
    static int dict_words;

    if (tessedit_minimal_rej_pass1)
    {
        tessedit_test_adaption.set_value (TRUE);
        tessedit_minimal_rejection.set_value (TRUE);
    }

    if (tessedit_cluster_adapt_before_pass1)
    {
        tess_adapt_mode = tessedit_tess_adaption_mode;
        tessedit_tess_adaption_mode.set_value (0);
        tessedit_tess_adapt_to_rejmap.set_value (TRUE);
    }


    if (dopasses==0 || dopasses==1)
    {
        page_res_it.page_res=page_res;
        page_res_it.restart_page();

        /* Pass 1 */
        word_count = 0;
        if (monitor != NULL)
        {
            monitor->ocr_alive = TRUE;
            while (page_res_it.word () != NULL)
            {
                word_count++;
                page_res_it.forward ();
            }
            page_res_it.restart_page ();
        }
        else
        {
            word_count = 1;
        }

        word_index = 0;

        em_clusters.clear();
        ems_waiting.clear();
        char_clusters.clear();
        chars_waiting.clear();
        dict_words = 0;
        doc_blob_quality = 0;
        doc_outline_errs = 0;
        doc_char_quality = 0;
        good_char_count = 0;
        doc_good_char_quality = 0;

        while (page_res_it.word () != NULL)
        {
            set_global_loc_code(LOC_PASS1);
            word_index++;

            if (monitor != NULL)
            {
                monitor->ocr_alive = TRUE;
                monitor->progress = 30 + 50 * word_index / word_count;
                if ((monitor->end_time != 0 && clock() > monitor->end_time) ||
                        (monitor->cancel != NULL && (*monitor->cancel)(monitor->cancel_this, dict_words)))
                {
                    return;
                }
            }

            classify_word_pass1(page_res_it.word(), page_res_it.row()->row, page_res_it.block()->block, FALSE, NULL, NULL);

            if (tessedit_dump_choices)
            {
                word_dumper(NULL, page_res_it.row()->row, page_res_it.word()->word);

                tprintf("Pass1: %s [%s]\n", page_res_it.word()->best_choice->unichar_string().string(),
                        page_res_it.word()->best_choice-> debug_string(unicharset).string());
            }

            if (tessedit_test_adaption && !tessedit_minimal_rejection)
            {
                if (!word_adaptable (page_res_it.word (), tessedit_test_adaption_mode))
                {
                    page_res_it.word ()->reject_map.rej_word_tess_failure();
                    // FAKE PERM REJ
                }
                else
                {
                    // Override rejection mechanisms for this word.
                    UNICHAR_ID space = unicharset.unichar_to_id(" ");

                    for (i = 0; i < page_res_it.word()->best_choice->length(); i++)
                    {
                        if ((page_res_it.word()->best_choice->unichar_id(i) != space) && page_res_it.word()->reject_map[i].rejected())
                        {
                            page_res_it.word ()->reject_map[i].setrej_minimal_rej_accept();
                        }
                    }
                }
            }

            if ((tessedit_cluster_adapt_after_pass1 ||
                 tessedit_cluster_adapt_after_pass3 ||
                 tessedit_cluster_adapt_before_pass1) &&
                    tessedit_cluster_adaption_mode != 0)
            {
                collect_characters_for_adaption (page_res_it.word (), &char_clusters, &chars_waiting);
            }

            // Count dict words.
            if (page_res_it.word()->best_choice->permuter() == USER_DAWG_PERM)
                ++dict_words;

            page_res_it.forward ();
        }

        if (tessedit_cluster_adapt_before_pass1)
        {
            tessedit_tess_adaption_mode.set_value (tess_adapt_mode);
        }

        page_res_it.restart_page ();
        while ((tessedit_cluster_adapt_after_pass1 || tessedit_cluster_adapt_before_pass1) && page_res_it.word () != NULL)
        {
            if (monitor != NULL)
            {
                monitor->ocr_alive = TRUE;
            }

            if (tessedit_cluster_adapt_after_pass1)
            {
                adapt_to_good_samples (page_res_it.word (), &char_clusters, &chars_waiting);
            }
            else
            {
                classify_word_pass1(page_res_it.word(), page_res_it.row()->row, page_res_it.block()->block, TRUE, &char_clusters, &chars_waiting);
            }

            page_res_it.forward ();
        }

        //
    }

    if (dopasses==1) return;

    /* Pass 2 */
    page_res_it.restart_page ();
    word_index = 0;

    while (!tessedit_test_adaption && page_res_it.word () != NULL)
    {
        set_global_loc_code(LOC_PASS2);
        word_index++;

        if (monitor != NULL)
        {
            monitor->ocr_alive = TRUE;
            monitor->progress = 80 + 10 * word_index / word_count;

            if ((monitor->end_time != 0 && clock() > monitor->end_time) ||
                    (monitor->cancel != NULL && (*monitor->cancel)(monitor->cancel_this, dict_words)))
            {
                return;
            }
        }
        //changed by jetsoft
        //specific to its needs to extract one word when need

        if (target_word_box)
        {

            TBOX current_word_box=page_res_it.word ()->word->bounding_box();
            FCOORD center_pt((current_word_box.right()+current_word_box.left())/2,(current_word_box.bottom()+current_word_box.top())/2);

            if (!target_word_box->contains(center_pt))
            {
                page_res_it.forward ();
                continue;
            }

        }
        //end jetsoft

        classify_word_pass2(page_res_it.word(), page_res_it.block()->block, page_res_it.row()->row);

        if (tessedit_dump_choices)
        {
            word_dumper(NULL, page_res_it.row()->row, page_res_it.word()->word);
            tprintf("Pass2: %s [%s]\n", page_res_it.word()->best_choice->unichar_string().string(),
                    page_res_it.word()->best_choice-> debug_string(unicharset).string());
        }

        if (tessedit_em_adaption_mode > 0)
        {
            collect_ems_for_adaption (page_res_it.word (), &em_clusters, &ems_waiting);
        }

        if (tessedit_cluster_adapt_after_pass2 && tessedit_cluster_adaption_mode != 0)
        {
            collect_characters_for_adaption (page_res_it.word (), &char_clusters, &chars_waiting);
        }

        page_res_it.forward ();
    }

    /* Another pass */
    set_global_loc_code(LOC_FUZZY_SPACE);

    if (!tessedit_test_adaption && tessedit_fix_fuzzy_spaces && !tessedit_word_for_word)
    {
        fix_fuzzy_spaces(monitor, word_count, page_res);
    }

    if (!tessedit_test_adaption && tessedit_em_adaption_mode != 0)
    {
        // Initially ems only
        print_em_stats(&em_clusters, &ems_waiting);
    }

    /* Pass 3 - used for checking confusion sets */
    page_res_it.restart_page();
    word_index = 0;

    while (!tessedit_test_adaption && page_res_it.word () != NULL)
    {
        set_global_loc_code(LOC_MM_ADAPT);
        word_index++;

        if (monitor != NULL)
        {
            monitor->ocr_alive = TRUE;
            monitor->progress = 95 + 5 * word_index / word_count;
        }
        check_debug_pt (page_res_it.word (), 70);
        /* Use good matches to sort out confusions */


        //changed by jetsoft
        //specific to its needs to extract one word when need

        if (target_word_box)
        {
            TBOX current_word_box=page_res_it.word ()->word->bounding_box();
            FCOORD center_pt((current_word_box.right()+current_word_box.left())/2,(current_word_box.bottom()+current_word_box.top())/2);

            if (!target_word_box->contains(center_pt))
            {
                page_res_it.forward ();
                continue;
            }
        }
        // end jetsoft

        if (tessedit_em_adaption_mode != 0)
        {
            adapt_to_good_ems (page_res_it.word (), &em_clusters, &ems_waiting);
        }

        if (tessedit_cluster_adapt_after_pass2 && tessedit_cluster_adaption_mode != 0)
        {
            adapt_to_good_samples (page_res_it.word (), &char_clusters, &chars_waiting);
        }

        UNICHAR_ID dot = unicharset.unichar_to_id(".");
        if (tessedit_reject_fullstops && page_res_it.word()->best_choice->contains_unichar_id(dot))
        {
            reject_all_fullstops (page_res_it.word ());
        }
        else if (tessedit_reject_suspect_fullstops && page_res_it.word()->best_choice->contains_unichar_id(dot))
        {
            reject_suspect_fullstops (page_res_it.word ());
        }

        page_res_it.rej_stat_word ();
        chars_in_word = page_res_it.word ()->reject_map.length ();
        rejects_in_word = page_res_it.word ()->reject_map.reject_count ();

        blob_quality = word_blob_quality (page_res_it.word (), page_res_it.row ()->row);
        doc_blob_quality += blob_quality;
        outline_errs = word_outline_errs (page_res_it.word ());
        doc_outline_errs += outline_errs;
        word_char_quality(page_res_it.word (), page_res_it.row ()->row, &all_char_quality, &accepted_all_char_quality);
        doc_char_quality += all_char_quality;
        uinT8 permuter_type = page_res_it.word ()->best_choice->permuter ();

        if ((permuter_type == SYSTEM_DAWG_PERM) || (permuter_type == FREQ_DAWG_PERM) || (permuter_type == USER_DAWG_PERM))
        {
            good_char_count += chars_in_word - rejects_in_word;
            doc_good_char_quality += accepted_all_char_quality;
        }

        check_debug_pt (page_res_it.word (), 80);
        if (tessedit_reject_bad_qual_wds && (blob_quality == 0) &&
                (outline_errs >= chars_in_word))
        {
            page_res_it.word ()->reject_map.rej_word_bad_quality ();
        }

        check_debug_pt (page_res_it.word (), 90);
        page_res_it.forward ();
    }

    page_res_it.restart_page ();
    while (!tessedit_test_adaption && tessedit_cluster_adapt_after_pass3 && page_res_it.word () != NULL)
    {
        if (monitor != NULL)
        {
            monitor->ocr_alive = TRUE;
        }

        //changed by jetsoft
        //specific to its needs to extract one word when need

        if (target_word_box)
        {
            TBOX current_word_box=page_res_it.word ()->word->bounding_box();
            FCOORD center_pt((current_word_box.right()+current_word_box.left())/2,(current_word_box.bottom()+current_word_box.top())/2);

            if (!target_word_box->contains(center_pt))
            {
                page_res_it.forward ();
                continue;
            }
        }

        //end jetsoft
        if (tessedit_cluster_adaption_mode != 0)
        {
            adapt_to_good_samples (page_res_it.word (), &char_clusters, &chars_waiting);
        }

        page_res_it.forward ();
    }

#ifndef SECURE_NAMES
    if (tessedit_debug_quality_metrics)
    {
        tprintf
                ("QUALITY: num_chs= %d  num_rejs= %d %5.3f blob_qual= %d %5.3f outline_errs= %d %5.3f char_qual= %d %5.3f good_ch_qual= %d %5.3f\n",
                 page_res->char_count, page_res->rej_count,
                 page_res->rej_count / (float) page_res->char_count, doc_blob_quality,
                 doc_blob_quality / (float) page_res->char_count, doc_outline_errs,
                 doc_outline_errs / (float) page_res->char_count, doc_char_quality,
                 doc_char_quality / (float) page_res->char_count,
                 doc_good_char_quality,
                 good_char_count >
                 0 ? doc_good_char_quality / (float) good_char_count : 0.0);
    }
#endif

    BOOL8 good_quality_doc =
            (page_res->rej_count / (float) page_res->char_count <= quality_rej_pc) &&
            (doc_blob_quality / (float) page_res->char_count >= quality_blob_pc) &&
            (doc_outline_errs / (float) page_res->char_count <= quality_outline_pc) &&
            (doc_char_quality / (float) page_res->char_count >= quality_char_pc);

    /* Do whole document or whole block rejection pass*/

    if (!tessedit_test_adaption)
    {
        set_global_loc_code(LOC_DOC_BLK_REJ);
        quality_based_rejection(page_res_it, good_quality_doc);
    }
    font_recognition_pass(page_res_it);

    /* Write results pass */
    set_global_loc_code(LOC_WRITE_RESULTS);
    // This is now redundant, but retained commented so show how to obtain
    // bounding boxes and style information.

    // changed by jetsoft
    // needed for dll to output memory structure
    if ((dopasses == 0 || dopasses == 2) && (monitor || tessedit_write_unlv))
    {
        output_pass(page_res_it, ocr_char_space() > 0, target_word_box);
        // end jetsoft
    }
}


/**
 * classify_word_pass1
 *
 * Baseline normalize the word and pass it to Tess.
 */

//recog one word                    //word to do
void Tesseract::classify_word_pass1(WERD_RES *word, ROW *row, BLOCK* block, BOOL8 cluster_adapt,
                                    CHAR_SAMPLES_LIST *char_clusters, CHAR_SAMPLE_LIST *chars_waiting)
{
    WERD *bln_word;                //baseline norm copy

    //detailed results
    BLOB_CHOICE_LIST_CLIST local_blob_choices;
    BLOB_CHOICE_LIST_CLIST *blob_choices;
    BOOL8 adapt_ok;
    const char *rejmap;
    inT16 index;
    STRING mapstr = "";
    char *match_string;
    char word_string[1024];

    if (save_best_choices)
    {
        blob_choices = new BLOB_CHOICE_LIST_CLIST();
    }
    else
    {
        blob_choices = &local_blob_choices;
    }

    if (matcher_fp != NULL)
    {
        fgets (word_string, 1023, correct_fp);

        if ((match_string = strchr(word_string, '\r')) != NULL)
        {
            *match_string = '\0';
        }

        if ((match_string = strchr(word_string, '\n')) != NULL)
        {
            *match_string = '\0';
        }

        if (word_string[0] != '\0')
        {
            word->word->set_text (word_string);
            word_answer = (char *) word->word->text ();
        }
        else
        {
            word_answer = NULL;
        }
    }

    check_debug_pt(word, 0);
    bln_word = make_bln_copy(word->word, row, block, word->x_height, &word->denorm);

    word->best_choice = tess_segment_pass1(bln_word, &word->denorm, &Tesseract::tess_default_matcher, word->raw_choice, blob_choices, word->outword);
    /*
     Test for TESS screw up on word. Recog_word has already ensured that the
     choice list, outword blob lists and best_choice string are the same
     length. A TESS screw up is indicated by a blank filled or 0 length string.
   */
    if ((word->best_choice->length() == 0) || (strspn(word->best_choice->unichar_string().string(), " ") == (size_t)word->best_choice->length()))
    {
        word->done = FALSE;          // Try again on pass2 - adaption may help.
        word->tess_failed = TRUE;
        word->reject_map.initialise(word->best_choice->length());
        word->reject_map.rej_word_tess_failure ();
    }
    else
    {
        word->tess_failed = FALSE;

        if ((word->best_choice->length() != word->outword->blob_list()->length()) || (word->best_choice->length() != blob_choices->length()))
        {
            tprintf
                    ("ASSERT FAIL String:\"%s\"; Strlen=%d; #Blobs=%d; #Choices=%d\n",
                     word->best_choice->debug_string(unicharset).string(),
                     word->best_choice->length(),
                     word->outword->blob_list()->length(),
                     blob_choices->length());
        }
        ASSERT_HOST(word->best_choice->length() == word->outword->blob_list()->length());
        ASSERT_HOST(word->best_choice->length() == blob_choices->length());

        /*
       The adaption step used to be here. It has been moved to after
       make_reject_map so that we know whether the word will be accepted in the
       first pass or not.   This move will PREVENT adaption to words containing
       double quotes because the word will not be identical to what tess thinks
       its best choice is. (See CurrentBestChoiceIs in
       danj/microfeatures/stopper.c which is used by AdaptableWord in
       danj/microfeatures/adaptmatch.c)
     */

        if (word->word->flag(W_REP_CHAR))
        {
            fix_rep_char(word);
        }
        else
        {
            // TODO(daria) delete these hacks when replaced by more generic code.
            // Convert '' (double single) to " (single double).
            fix_quotes(word->best_choice, word->outword, blob_choices);

            if (tessedit_fix_hyphens)  // turn -- to -
            {
                fix_hyphens(word->best_choice, word->outword, blob_choices);
            }
            record_certainty(word->best_choice->certainty(), 1);
            // accounting.

            word->tess_accepted = tess_acceptable_word(word->best_choice, word->raw_choice);

            word->tess_would_adapt = tess_adaptable_word(word->outword, word->best_choice, word->raw_choice);

            // Also sets word->done flag
            make_reject_map(word, blob_choices, row, 1);

            adapt_ok = word_adaptable(word, tessedit_tess_adaption_mode);

            if (cluster_adapt)
            {
                adapt_to_good_samples(word, char_clusters, chars_waiting);
            }

            if (adapt_ok || tessedit_tess_adapt_to_rejmap)
            {
                if (!tessedit_tess_adapt_to_rejmap)
                {
                    rejmap = NULL;
                }
                else
                {
                    ASSERT_HOST(word->reject_map.length() == word->best_choice->length());

                    for (index = 0; index < word->reject_map.length(); index++)
                    {
                        if (adapt_ok || word->reject_map[index].accepted())
                        {
                            mapstr += '1';
                        }
                        else
                        {
                            mapstr += '0';
                        }
                    }

                    rejmap = mapstr.string();
                }

                // adapt to it.
                tess_adapter(word->outword, &word->denorm, *word->best_choice, *word->raw_choice, rejmap);
            }

            if (tessedit_enable_doc_dict)
            {
                tess_add_doc_word(word->best_choice);
            }

            set_word_fonts(word, blob_choices);
        }
    }
#if 0
    if (tessedit_print_text)
    {
        write_cooked_text(bln_word, word->best_choice->string(), word->done, FALSE, stdout);
    }
#endif
    delete bln_word;

    // Save best choices in the WERD_CHOICE if needed
    if (blob_choices != &local_blob_choices)
    {
        word->best_choice->set_blob_choices(blob_choices);
    }
    else
    {
        blob_choices->deep_clear();
    }
}

/**
 * classify_word_pass2
 *
 * Control what to do with the word in pass 2
 */

void Tesseract::classify_word_pass2(WERD_RES *word, BLOCK* block, ROW *row)
{
    BOOL8 done_this_pass = FALSE;
    WERD_RES new_x_ht_word(word->word);
    float new_x_ht = 0.0;
    inT16 old_xht_reject_count;
    inT16 new_xht_reject_count;
    inT16 old_xht_accept_count;
    inT16 new_xht_accept_count;
    BOOL8 accept_new_x_ht = FALSE;
    inT16 old_chs_in_wd;
    inT16 new_chs_in_wd;
    inT16 old_word_quality;
    inT16 new_word_quality;
    inT16 dummy;

    set_global_subloc_code(SUBLOC_NORM);
    check_debug_pt(word, 30);

    if (!word->done || tessedit_training_tess || tessedit_training_wiseowl)
    {
        word->caps_height = 0.0;

        if (word->x_height == 0.0f)
        {
            word->x_height = row->x_height();
        }

        if (word->outword != NULL)
        {
            delete word->outword;      // get rid of junk
            delete word->best_choice;
            delete word->raw_choice;
        }

        match_word_pass2 (word, row, block, word->x_height);
        done_this_pass = TRUE;
        check_debug_pt (word, 40);
    }

    if (!word->tess_failed && !word->word->flag (W_REP_CHAR))
    {
        set_global_subloc_code(SUBLOC_FIX_XHT);

        if ((tessedit_xht_fiddles_on_done_wds || !word->done) && (tessedit_xht_fiddles_on_no_rej_wds || (word->reject_map.reject_count () > 0)))
        {
            if ((x_ht_check_word_occ >= 2) && word_occ_first)
            {
                check_block_occ(word);
            }

            if (tessedit_redo_xheight)
            {
                re_estimate_x_ht(word, &new_x_ht);
            }

            if (((x_ht_check_word_occ >= 2) && !word_occ_first) || ((x_ht_check_word_occ >= 1) && (new_x_ht > 0)))
            {
                check_block_occ(word);
            }
        }

        if (new_x_ht > 0)
        {
            old_chs_in_wd = word->reject_map.length ();

            /* Re-estimated x_ht error suggests a rematch is worthwhile. */
            new_x_ht_word.x_height = new_x_ht;
            new_x_ht_word.caps_height = 0.0;
            match_word_pass2(&new_x_ht_word, row, block, new_x_ht_word.x_height);

            if (!new_x_ht_word.tess_failed)
            {
                if ((x_ht_check_word_occ >= 1) && word_occ_first)
                {
                    check_block_occ(&new_x_ht_word);
                }

                re_estimate_x_ht(&new_x_ht_word, &new_x_ht);

                if ((x_ht_check_word_occ >= 1) && !word_occ_first)
                {
                    check_block_occ(&new_x_ht_word);
                }

                old_xht_reject_count = word->reject_map.reject_count ();
                old_xht_accept_count = old_chs_in_wd - old_xht_reject_count;
                new_xht_reject_count = new_x_ht_word.reject_map.reject_count ();
                new_chs_in_wd = new_x_ht_word.reject_map.length ();
                new_xht_accept_count = new_chs_in_wd - new_xht_reject_count;

                accept_new_x_ht =
                        ((new_xht_accept_count > old_xht_accept_count) ||
                         ((new_xht_accept_count == old_xht_accept_count) &&
                          (new_xht_accept_count > 0))) &&
                        (!new_x_ht_word.guessed_x_ht ||
                         !new_x_ht_word.guessed_caps_ht);

                if (accept_new_x_ht && x_ht_quality_check)
                {
                    word_char_quality(word, row, &old_word_quality, &dummy);
                    word_char_quality(&new_x_ht_word, row, &new_word_quality, &dummy);

                    if (old_word_quality > new_word_quality)
                    {
                        accept_new_x_ht = FALSE;
                    }
                }

                if (accept_new_x_ht && (x_ht_stringency > 0))
                {
                    accept_new_x_ht = (count_alphanums (&new_x_ht_word) > x_ht_stringency);

                    if (!accept_new_x_ht && rej_use_xht)
                    {
                        if (debug_x_ht_level >= 1)
                        {
                            tprintf ("Failed stringency test so reject original word\n");
                        }

                        word->reject_map.rej_word_xht_fixup ();
                    }
                }

#ifndef SECURE_NAMES
                if (debug_x_ht_level >= 1)
                {
                    tprintf ("New XHT Match:: %s ", word->best_choice->debug_string(unicharset).string());

                    word->reject_map.print (debug_fp);

                    tprintf (" -> %s ", new_x_ht_word.best_choice->debug_string( unicharset).string());
                    new_x_ht_word.reject_map.print (debug_fp);

                    tprintf (" %s->%s %s %s\n", word->guessed_x_ht ? "GUESS" : "CERT", new_x_ht_word.guessed_x_ht ? "GUESS" : "CERT",
                             new_x_ht > 0.1 ? "STILL DOUBT" : "OK", accept_new_x_ht ? "ACCEPTED" : "");
                }
#endif
            }

            if (accept_new_x_ht)
            {
                /*
           The new x_ht is deemed superior so put the final results in the real
           word and destroy the old results
         */
                delete word->outword;    //get rid of junk
                word->outword = new_x_ht_word.outword;
                word->denorm = new_x_ht_word.denorm;
                delete word->best_choice;
                word->best_choice = new_x_ht_word.best_choice;
                delete word->raw_choice;
                word->raw_choice = new_x_ht_word.raw_choice;
                word->reject_map = new_x_ht_word.reject_map;
                word->done = new_x_ht_word.done;
                done_this_pass = TRUE;
            }
            else
            {
                /*
         The new x_ht is no better, so destroy the copy word and put any
         uncertain x or cap ht estimate back to default. (I.e. dont blame
         me if its bad!) Conditionally, use any ammended block occ chars.
       */
                //get rid of junk
                delete new_x_ht_word.outword;
                delete new_x_ht_word.best_choice;
                delete new_x_ht_word.raw_choice;
            }

            //to keep new destructor happy
            new_x_ht_word.outword = NULL;

            //to keep new destructor happy
            new_x_ht_word.best_choice = NULL;

            //to keep new destructor happy
            new_x_ht_word.raw_choice = NULL;

            if (rej_mostly_reject_mode == 2)
            {
                reject_mostly_rejects(word);
                tprintf("Rejecting mostly rejects on %s ", word->best_choice->debug_string(unicharset).string());
            }
        }

        set_global_subloc_code(SUBLOC_NORM);

        if (done_this_pass && !word->done && tessedit_save_stats)
        {
            STRING word_str;
            word->best_choice->string_and_lengths(unicharset, &word_str, NULL);
            SaveBadWord(word_str.string(), word->best_choice->certainty());
        }
        record_certainty (word->best_choice->certainty(), 2);
        //accounting
    }
#ifndef GRAPHICS_DISABLED
    if (tessedit_draw_outwords)
    {
        if (fx_win == NULL)
        {
            create_fx_win();
        }
        clear_fx_win();

        word->outword->plot (fx_win);
        TBOX wbox = word->outword->bounding_box();
        fx_win->ZoomToRectangle(wbox.left(), wbox.top(), wbox.right(), wbox.bottom());

        //make_picture_current(fx_win);
        ScrollView::Update();
    }
#endif

    set_global_subloc_code(SUBLOC_NORM);
#if 0
    if (tessedit_print_text)
    {
        write_cooked_text (word->outword, word->best_choice->string (), word->done, done_this_pass, stdout);
    }
#endif
    check_debug_pt (word, 50);
}


/**
 * match_word_pass2
 *
 * Baseline normalize the word and pass it to Tess.
 */

//recog one word                 //word to do
void Tesseract::match_word_pass2(WERD_RES *word, ROW *row, BLOCK* block, float x_height)
{
    WERD *bln_word;                //baseline norm copy

    //detailed results
    BLOB_CHOICE_LIST_CLIST local_blob_choices;
    BLOB_CHOICE_LIST_CLIST *blob_choices;

    if (save_best_choices)
    {
        blob_choices = new BLOB_CHOICE_LIST_CLIST();
    }
    else
    {
        blob_choices = &local_blob_choices;
    }

    set_global_subsubloc_code(SUBSUBLOC_OTHER);

    if (matcher_fp != NULL)
    {
        word_answer = (char *) word->word->text ();

        if (word_answer != NULL && word_answer[0] == '\0')
        {
            word_answer = NULL;
        }
    }

    bln_word = make_bln_copy (word->word, row, block, x_height, &word->denorm);
    set_global_subsubloc_code(SUBSUBLOC_TESS);

    if (tessedit_training_tess)
    {
        word->best_choice = correct_segment_pass2(bln_word, &word->denorm, &Tesseract::tess_default_matcher,
                                                  tess_training_tester, word->raw_choice, blob_choices, word->outword);
    }
    else
    {
        word->best_choice = tess_segment_pass2(bln_word, &word->denorm, &Tesseract::tess_default_matcher,
                                               word->raw_choice, blob_choices, word->outword);
    }
    set_global_subsubloc_code(SUBSUBLOC_OTHER);

    /*
     Test for TESS screw up on word. Recog_word has already ensured that the
     choice list, outword blob lists and best_choice string are the same
     length. A TESS screw up is indicated by a blank filled or 0 length string.
   */
    if ((word->best_choice->length() == 0) || (strspn (word->best_choice->unichar_string().string (), " ") == (size_t)word->best_choice->length()))
    {
        word->tess_failed = TRUE;
        word->reject_map.initialise (word->best_choice->length());
        word->reject_map.rej_word_tess_failure ();
        //              tprintf("Empty word produced\n");
    }
    else
    {
        if ((word->best_choice->length() != word->outword->blob_list()->length ()) || (word->best_choice->length() != blob_choices->length()))
        {
            tprintf("ASSERT FAIL String:\"%s\"; Strlen=%d; #Blobs=%d; #Choices=%d\n", word->best_choice->debug_string(unicharset).string(),
                    word->best_choice->length(), word->outword->blob_list()->length(), blob_choices->length());
        }

        ASSERT_HOST (word->best_choice->length() == word->outword->blob_list()->length());
        ASSERT_HOST (word->best_choice->length() == blob_choices->length());

        word->tess_failed = FALSE;
        if (word->word->flag (W_REP_CHAR))
        {
            fix_rep_char(word);
        }
        else
        {
            fix_quotes(word->best_choice, word->outword, blob_choices);

            if (tessedit_fix_hyphens)
            {
                fix_hyphens (word->best_choice, word->outword, blob_choices);
            }

            /* Dont trust fix_quotes! - though I think I've fixed the bug */
            if ((word->best_choice->length() != word->outword->blob_list()->length()) || (word->best_choice->length() != blob_choices->length()))
            {
#ifndef SECURE_NAMES
                tprintf ("POST FIX_QUOTES FAIL String:\"%s\"; Strlen=%d; #Blobs=%d; #Choices=%d\n", word->best_choice->debug_string(unicharset).string(),
                         word->best_choice->length(), word->outword->blob_list()->length(), blob_choices->length());
#endif

            }
            ASSERT_HOST(word->best_choice->length() == word->outword->blob_list()->length());
            ASSERT_HOST(word->best_choice->length() == blob_choices->length());

            word->tess_accepted = tess_acceptable_word(word->best_choice, word->raw_choice);

            make_reject_map (word, blob_choices, row, 2);
        }
    }

    // Save best choices in the WERD_CHOICE if needed
    if (blob_choices != &local_blob_choices)
    {
        word->best_choice->set_blob_choices(blob_choices);
    }
    else
    {
        blob_choices->deep_clear();
    }

    delete bln_word;
    assert (word->raw_choice != NULL);
}

/**
 * fix_rep_char()
 * The word is a repeated char. Find the repeated char character. Make a reject
 * string which rejects any char other than the voted char. Set the word to done
 * to stop rematching it.
 *
 */
void Tesseract::fix_rep_char(WERD_RES *word_res)
{
    struct REP_CH
    {
        UNICHAR_ID unichar_id;
        int count;
    };

    const WERD_CHOICE &word = *(word_res->best_choice);
    REP_CH *rep_ch;        // array of char counts
    int rep_ch_count = 0;  // how many unique chs
    int i, j;
    int total = 0;
    int max = 0;
    UNICHAR_ID maxch_id = INVALID_UNICHAR_ID; // most common char
    UNICHAR_ID space = unicharset.unichar_to_id(" ");

    rep_ch = new REP_CH[word.length()];
    for (i = 0; i < word.length(); ++i)
    {
        for (j = 0; j < rep_ch_count && rep_ch[j].unichar_id != word.unichar_id(i); ++j)
        {
            if (j < rep_ch_count)
            {
                rep_ch[j].count++;
            }
            else
            {
                rep_ch[rep_ch_count].unichar_id = word.unichar_id(i);
                rep_ch[rep_ch_count].count = 1;
                rep_ch_count++;
            }
        }
    }

    for (j = 0; j < rep_ch_count; j++)
    {
        total += rep_ch[j].count;
        if ((rep_ch[j].count > max) && (rep_ch[j].unichar_id != space))
        {
            max = rep_ch[j].count;
            maxch_id = rep_ch[j].unichar_id;
        }
    }

    //      tprintf( "REPEATED CHAR %s len=%d total=%d choice=%c\n",
    //                        word_str, word_len, total, maxch );
    delete[] rep_ch;

    word_res->reject_map.initialise(word.length());
    for (i = 0; i < word.length(); ++i)
    {
        if (word.unichar_id(i) != maxch_id)
        {
            word_res->reject_map[i].setrej_bad_repetition(); // rej unrecognised blobs
        }
    }

    word_res->done = TRUE;
}

// TODO(tkielbus) Decide between keeping this behavior here or modifying the
// training data.

// Utility function for fix_quotes
// Return true if the next character in the string (given the UTF8 length in
// bytes) is a quote character.
static int is_simple_quote(const char* signed_str, int length)
{
    const unsigned char* str = reinterpret_cast<const unsigned char*>(signed_str);

    //standard 1 byte quotes
    return (length == 1 && (*str == '\'' || *str == '`')) ||//utf8 3 bytes curved quotes
            (length == 3 && ((*str == 0xe2 &&
                              *(str + 1) == 0x80 &&
                              *(str + 2) == 0x98) ||
                             (*str == 0xe2 &&
                              *(str + 1) == 0x80 &&
                              *(str + 2) == 0x99)));
}

/**
 * fix_quotes
 *
 * Change pairs of quotes to double quotes.
 */
//choice to fix                                 //word to do //char choices
void Tesseract::fix_quotes(WERD_CHOICE *choice, WERD *word, BLOB_CHOICE_LIST_CLIST *blob_choices)
{
    if (!unicharset.contains_unichar("\"") || !unicharset.get_enabled(unicharset.unichar_to_id("\"")))
    {
        return;  // Don't create it if it is disallowed.
    }

    PBLOB_IT blob_it = word->blob_list();  // blobs
    BLOB_CHOICE_LIST_C_IT blob_choices_it = blob_choices;  // choices
    BLOB_CHOICE_IT it1;  // first choices
    BLOB_CHOICE_IT it2;  // second choices

    int i;
    int modified = false;
    for (i = 0; i < choice->length()-1; ++i, blob_it.forward(), blob_choices_it.forward())
    {
        const char *ch = unicharset.id_to_unichar(choice->unichar_id(i));
        const char *next_ch = unicharset.id_to_unichar(choice->unichar_id(i+1));

        if (is_simple_quote(ch, strlen(ch)) && is_simple_quote(next_ch, strlen(next_ch)))
        {
            choice->set_unichar_id(unicharset.unichar_to_id("\""), i);
            choice->remove_unichar_id(i+1);
            modified = true;
            merge_blobs(blob_it.data(), blob_it.data_relative(1));
            blob_it.forward();
            delete blob_it.extract();  // get rid of spare

            it1.set_to_list(blob_choices_it.data());
            it2.set_to_list(blob_choices_it.data_relative(1));

            if (it1.data()->certainty() < it2.data()->certainty())
            {
                blob_choices_it.forward();
                delete blob_choices_it.extract();  // get rid of spare
            }
            else
            {
                delete blob_choices_it.extract();  // get rid of spare
                blob_choices_it.forward();
            }
        }
    }

    if (modified)
    {
        choice->populate_unichars(unicharset);
    }
}


/**
 * fix_hyphens
 *
 * Change pairs of hyphens to a single hyphen if the bounding boxes touch
 * Typically a long dash which has been segmented.
 */

//crunch double hyphens     //choice to fix        //word to do //char choices
void Tesseract::fix_hyphens(WERD_CHOICE *choice,   WERD *word, BLOB_CHOICE_LIST_CLIST *blob_choices)
{
    if (!unicharset.contains_unichar("-") || !unicharset.get_enabled(unicharset.unichar_to_id("-")))
    {
        return;  // Don't create it if it is disallowed.
    }

    PBLOB_IT blob_it = word->blob_list();
    BLOB_CHOICE_LIST_C_IT blob_choices_it = blob_choices;
    BLOB_CHOICE_IT it1;            // first choices
    BLOB_CHOICE_IT it2;            // second choices

    bool modified = false;
    for (int i = 0; i+1 < choice->length(); ++i, blob_it.forward (), blob_choices_it.forward ())
    {
        const char *ch = unicharset.id_to_unichar(choice->unichar_id(i));
        const char *next_ch = unicharset.id_to_unichar(choice->unichar_id(i+1));
        if (strlen(ch) != 1 || strlen(next_ch) != 1) continue;

        if ((*ch == '-' || *ch == '~') && (*next_ch == '-' || *next_ch == '~') &&
                (blob_it.data()->bounding_box().right() >= blob_it.data_relative(1)->bounding_box().left ()))
        {
            choice->set_unichar_id(unicharset.unichar_to_id("-"), i);
            choice->remove_unichar_id(i+1);
            modified = true;
            merge_blobs(blob_it.data(), blob_it.data_relative(1));
            blob_it.forward();
            delete blob_it.extract();  // get rid of spare

            it1.set_to_list(blob_choices_it.data());
            it2.set_to_list(blob_choices_it.data_relative(1));
            if (it1.data()->certainty() < it2.data()->certainty())
            {
                blob_choices_it.forward();
                delete blob_choices_it.extract();  // get rid of spare
            }
            else
            {
                delete blob_choices_it.extract();  // get rid of spare
                blob_choices_it.forward();
            }
        }
    }

    if (modified)
    {
        choice->populate_unichars(unicharset);
    }
}

/**
 * merge_blobs
 *
 * Add the outlines from blob2 to blob1. Blob2 is emptied but not deleted.
 */

//combine 2 blobs //dest blob    //source blob
void merge_blobs(PBLOB *blob1,   PBLOB *blob2)
{
    OUTLINE_IT outline_it = blob1->out_list ();
    //iterator

    outline_it.move_to_last ();    //go to end

    //do it
    outline_it.add_list_after (blob2->out_list ());
}


/**********************************************************************
 * choice_dump_tester
 *
 * Matcher tester function which generates .chc file entries.
 * Called via test_segment_pass2 for every blob tested by tess in a word.
 * (But only for words for which a correct segmentation could be found.)
 **********************************************************************/
/* DEADCODE
void choice_dump_tester(                           //dump chars in word
                        PBLOB *,                   //blob
                        DENORM *,                  //de-normaliser
                        BOOL8 correct,             //ly segmented
                        char *text,                //correct text
                        inT32 count,               //chars in text
                        BLOB_CHOICE_LIST *ratings  //list of results
                       ) {
  STRING choice_file_name;
  BLOB_CHOICE *blob_choice;
  BLOB_CHOICE_IT it;
  char source_chars[20];
  char correct_char[3];

  if (choice_file == NULL) {
    choice_file_name = imagebasename + ".chc";
    if (!(choice_file = fopen (choice_file_name.string (), "w"))) {
      CANTOPENFILE.error ("choice_dump_tester", EXIT, "%s %d",
        choice_file_name.string (), errno);
    }
  }

  if ((count == 0) || (text == NULL) || (text[0] == '\0')) {
    strcpy (source_chars, "$$");
    strcpy (correct_char, "$$");
  }
  else {
    strncpy(source_chars, text, count);
    source_chars[count] = '\0';
    if (correct) {
      correct_char[0] = text[0];
      correct_char[1] = '\0';
    }
    else {
      strcpy (correct_char, "$$");
    }
  }
  fprintf (choice_file, "%s\t%s", source_chars, correct_char);

  it.set_to_list (ratings);
  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
    blob_choice = it.data ();
    fprintf (choice_file, "\t%s\t%f\t%f",
             blob_choice->unichar (),
             blob_choice->rating (), blob_choice->certainty ());
  }
  fprintf (choice_file, "\n");
}
*/

/**
 * make_bln_copy()
 *
 * Generate a baseline normalised copy of the source word. The copy is done so
 * that whatever format the original word is in, a polygonal bln version is
 * generated as output.
 */

WERD *make_bln_copy(WERD *src_word, ROW *row, BLOCK* block,
                    float x_height, DENORM *denorm)
{
    WERD *result = src_word->poly_copy(row->x_height());

    result->baseline_normalise_x(row, x_height, denorm);

    if (block != NULL)
    {
        denorm->set_block(block);
    }

    return result;
}

ACCEPTABLE_WERD_TYPE Tesseract::acceptable_word_string(const char *s, const char *lengths)
{
    int i = 0;
    int offset = 0;
    int leading_punct_count;
    int upper_count = 0;
    int hyphen_pos = -1;
    ACCEPTABLE_WERD_TYPE word_type = AC_UNACCEPTABLE;

    if (strlen (lengths) > 20)
    {
        return word_type;
    }

    /* Single Leading punctuation char*/

    if ((s[offset] != '\0') && (STRING (chs_leading_punct).contains (s[offset])))
    {
        offset += lengths[i++];
    }
    leading_punct_count = i;

    /* Initial cap */
    while ((s[offset] != '\0') && unicharset.get_isupper(s + offset, lengths[i]))
    {
        offset += lengths[i++];
        upper_count++;
    }

    if (upper_count > 1)
    {
        word_type = AC_UPPER_CASE;
    }
    else
    {
        /* Lower case word, possibly with an initial cap */
        while ((s[offset] != '\0') && unicharset.get_islower (s + offset, lengths[i]))
        {
            offset += lengths[i++];
        }
        if (i - leading_punct_count < quality_min_initial_alphas_reqd)
        {
            goto not_a_word;
        }

        /*
    Allow a single hyphen in a lower case word
    - dont trust upper case - I've seen several cases of "H" -> "I-I"
    */
        if (lengths[i] == 1 && s[offset] == '-')
        {
            hyphen_pos = i;
            offset += lengths[i++];

            if (s[offset] != '\0')
            {
                while ((s[offset] != '\0') && unicharset.get_islower(s + offset, lengths[i]))
                {
                    offset += lengths[i++];
                }

                if (i < hyphen_pos + 3)
                {
                    goto not_a_word;
                }
            }
        }
        else
        {
            /* Allow "'s" in NON hyphenated lower case words */
            if (lengths[i] == 1 && (s[offset] == '\'') && lengths[i + 1] == 1 && (s[offset + lengths[i]] == 's'))
            {
                offset += lengths[i++];
                offset += lengths[i++];
            }
        }

        if (upper_count > 0)
        {
            word_type = AC_INITIAL_CAP;
        }
        else
        {
            word_type = AC_LOWER_CASE;
        }
    }

    /* Up to two different, constrained trailing punctuation chars */
    if (lengths[i] == 1 && (s[offset] != '\0') && (STRING (chs_trailing_punct1).contains (s[offset])))
    {
        offset += lengths[i++];
    }

    if (lengths[i] == 1 && (s[offset] != '\0') && i > 0 && (s[offset - lengths[i - 1]] != s[offset]) && (STRING (chs_trailing_punct2).contains (s[offset])))
    {
        offset += lengths[i++];
    }

    if (s[offset] != '\0')
    {
        word_type = AC_UNACCEPTABLE;
    }

not_a_word:

    if (word_type == AC_UNACCEPTABLE)
    {
        /* Look for abbreviation string */
        i = 0;
        offset = 0;

        if (s[0] != '\0' && unicharset.get_isupper (s, lengths[0]))
        {
            word_type = AC_UC_ABBREV;
            while ((s[offset] != '\0') && unicharset.get_isupper(s + offset, lengths[i]) && (lengths[i + 1] == 1 && s[offset + lengths[i]] == '.'))
            {
                offset += lengths[i++];
                offset += lengths[i++];
            }
        }
        else if (s[0] != '\0' && unicharset.get_islower (s, lengths[0]))
        {
            word_type = AC_LC_ABBREV;
            while ((s[offset] != '\0') && unicharset.get_islower(s + offset, lengths[i]) && (lengths[i + 1] == 1 && s[offset + lengths[i]] == '.'))
            {
                offset += lengths[i++];
                offset += lengths[i++];
            }
        }

        if (s[offset] != '\0')
        {
            word_type = AC_UNACCEPTABLE;
        }
    }

    return word_type;
}

/* DEBUGGING ROUTINE */

BOOL8 check_debug_pt(WERD_RES *word, int location)
{
    BOOL8 show_map_detail = FALSE;
    inT16 i;

#ifndef SECURE_NAMES
    if (!test_pt)
    {
        return FALSE;
    }

    tessedit_rejection_debug.set_value (FALSE);
    debug_x_ht_level.set_value (0);
    tessedit_cluster_debug.set_value (FALSE);
    nn_debug.set_value (FALSE);
    nn_reject_debug.set_value (FALSE);

    if (word->word->bounding_box ().contains (FCOORD (test_pt_x, test_pt_y)))
    {
        if (location < 0)
        {
            return TRUE;               //For breakpoint use
        }

        tessedit_rejection_debug.set_value (TRUE);
        debug_x_ht_level.set_value (20);
        tessedit_cluster_debug.set_value (TRUE);
        nn_debug.set_value (TRUE);
        nn_reject_debug.set_value (TRUE);
        tprintf ("\n\nTESTWD::");

        switch (location)
        {
        case 0:
            tprintf ("classify_word_pass1 start\n");
            word->word->print (debug_fp);
            break;
        case 10:
            tprintf ("make_reject_map: initial map");
            break;
        case 20:
            tprintf ("make_reject_map: after NN");
            break;
        case 30:
            tprintf ("classify_word_pass2 - START");
            break;
        case 40:
            tprintf ("classify_word_pass2 - Pre Xht");
            break;
        case 50:
            tprintf ("classify_word_pass2 - END");
            show_map_detail = TRUE;
            break;
        case 60:
            tprintf ("fixspace");
            break;
        case 70:
            tprintf ("MM pass START");
            break;
        case 80:
            tprintf ("MM pass END");
            break;
        case 90:
            tprintf ("After Poor quality rejection");
            break;
        case 100:
            tprintf ("unrej_good_quality_words - START");
            break;
        case 110:
            tprintf ("unrej_good_quality_words - END");
            break;
        case 120:
            tprintf ("Write results pass");
            show_map_detail = TRUE;
            break;
        }
        tprintf(" \"%s\" ", word->best_choice->unichar_string().string());
        word->reject_map.print (debug_fp);
        tprintf ("\n");

        if (show_map_detail)
        {
            tprintf ("\"%s\"\n", word->best_choice->unichar_string().string());

            for (i = 0; word->best_choice->unichar_string()[i] != '\0'; i++)
            {
                tprintf ("**** \"%c\" ****\n", word->best_choice->unichar_string()[i]);
                word->reject_map[i].full_print(debug_fp);
            }
        }

        tprintf ("Tess Accepted: %s\n", word->tess_accepted ? "TRUE" : "FALSE");
        tprintf ("Done flag: %s\n\n", word->done ? "TRUE" : "FALSE");

        return TRUE;
    }
    else
#endif
        return FALSE;
}


/**
 * set_word_fonts
 *
 * Get the fonts for the word.
 */
// word to adapt to   // detailed results
void Tesseract::set_word_fonts(WERD_RES *word,       BLOB_CHOICE_LIST_CLIST *blob_choices)
{
    inT32 index;                   // char id index
    UNICHAR_ID choice_char_id;     // char id from word
    inT8 config;                   // font of char

    // character iterator
    BLOB_CHOICE_LIST_C_IT char_it = blob_choices;
    BLOB_CHOICE_IT choice_it;      // choice iterator
    int fontinfo_size = get_fontinfo_table().size();
    int fontset_size = get_fontset_table().size();

    if (fontinfo_size == 0 || fontset_size == 0)
    {
        return;
    }

    STATS fonts(0, fontinfo_size);  // font counters

    word->italic = 0;
    word->bold = 0;

    for (char_it.mark_cycle_pt(), index = 0; !char_it.cycled_list(); ++index, char_it.forward())
    {
        choice_char_id = word->best_choice->unichar_id(index);
        choice_it.set_to_list(char_it.data());

        for (choice_it.mark_cycle_pt(); !choice_it.cycled_list(); choice_it.forward())
        {
            if (choice_it.data()->unichar_id() == choice_char_id)
            {
                config = choice_it.data()->config();
                int class_id = choice_it.data()->unichar_id();
                int font_set_id = PreTrainedTemplates->Class[class_id]->font_set_id;

                if (font_set_id >= 0 && config >= 0 && font_set_id < fontset_size)
                {
                    FontSet font_set = get_fontset_table().get(font_set_id);
                    if (tessedit_debug_fonts)
                    {
                        tprintf("%s(%d=%d%c%c)", unicharset.id_to_unichar(choice_char_id), config, (config & 31) >> 2, config & 2 ? 'N' : 'B', config & 1 ? 'N' : 'I');
                        const char* fontname;

                        if (config >= font_set.size)
                        {
                            fontname = "Unknown";
                        }
                        else
                        {
                            fontname = get_fontinfo_table().get(font_set.configs[config]).name;
                        }

                        tprintf("%s(%d,%d=%s)\n", unicharset.id_to_unichar(choice_it.data()->unichar_id()), font_set_id, config, fontname);
                    }

                    if (config < font_set.size)
                    {
                        int fontinfo_id = font_set.configs[config];

                        if (fontinfo_id < fontinfo_size)
                        {
                            FontInfo fi = get_fontinfo_table().get(fontinfo_id);
                            word->italic += fi.is_italic();
                            word->bold += fi.is_bold();
                            fonts.add(fontinfo_id, 1);
                        }
                    }
                }
                break;
            }
        }
    }

    find_modal_font(&fonts, &word->font1, &word->font1_count);
    find_modal_font(&fonts, &word->font2, &word->font2_count);

    if (tessedit_debug_fonts) tprintf("\n");

    if (word->font1_count > 0)
    {
        word->italic = word->bold = 0;

        for (char_it.mark_cycle_pt(), index = 0; !char_it.cycled_list();  char_it.forward(), ++index)
        {
            choice_char_id = word->best_choice->unichar_id(index);
            choice_it.set_to_list(char_it.data());

            for (choice_it.mark_cycle_pt(); !choice_it.cycled_list(); choice_it.forward())
            {
                if (choice_it.data()->unichar_id() == choice_char_id)
                {
                    config = choice_it.data()->config();
                    int class_id = choice_it.data()->unichar_id();
                    int font_set_id = PreTrainedTemplates->Class[class_id]->font_set_id;

                    if (font_set_id >= 0 && config >= 0 && font_set_id < fontset_size)
                    {
                        int fontinfo_id = get_fontset_table().get(font_set_id).configs[config];

                        if (fontinfo_id == word->font1 && fontinfo_id < fontinfo_size)
                        {
                            FontInfo fi = fontinfo_table_.get(fontinfo_id);
                            word->italic += fi.is_italic();
                            word->bold += fi.is_bold();
                        }
                    }

                    break;
                }
            }
        }
    }
}


/**
 * font_recognition_pass
 *
 * Smooth the fonts for the document.
 */

//good chars in word
void Tesseract::font_recognition_pass(PAGE_RES_IT &page_res_it)
{
    inT32 length;                  //of word
    inT32 count;                   //of a feature
    inT8 doc_font;                 //modal font
    inT8 doc_font_count;           //modal font
    inT32 doc_italic;              //total italics
    inT32 doc_bold;                //total bolds
    ROW_RES *row = NULL;           //current row
    WERD_RES *word;                //current word

    STATS fonts (0, get_fontinfo_table().size() ? get_fontinfo_table().size() : 32); // font counters
    STATS doc_fonts (0, get_fontinfo_table().size() ? get_fontinfo_table().size() : 32); // font counters

    doc_italic = 0;
    doc_bold = 0;
    page_res_it.restart_page ();

    while (page_res_it.word () != NULL)
    {
        if (row != page_res_it.row ())
        {
            if (row != NULL)
            {
                find_modal_font (&fonts, &row->font1, &row->font1_count);
                find_modal_font (&fonts, &row->font2, &row->font2_count);
            }

            row = page_res_it.row ();  //current row
            fonts.clear ();            //clear counters
            row->italic = 0;
            row->bold = 0;
        }

        word = page_res_it.word ();
        row->italic += word->italic;
        row->bold += word->bold;
        fonts.add (word->font1, word->font1_count);
        fonts.add (word->font2, word->font2_count);
        doc_italic += word->italic;
        doc_bold += word->bold;
        doc_fonts.add (word->font1, word->font1_count);
        doc_fonts.add (word->font2, word->font2_count);
        page_res_it.forward ();
    }

    if (row != NULL)
    {
        find_modal_font (&fonts, &row->font1, &row->font1_count);
        find_modal_font (&fonts, &row->font2, &row->font2_count);
    }
    find_modal_font(&doc_fonts, &doc_font, &doc_font_count);

    /*
    row=NULL;
    page_res_it.restart_page();
    while (page_res_it.word() != NULL)
    {
      if (row!=page_res_it.row())
      {
        row2=row;
        row=page_res_it.row();
        if (row->font1_count<MIN_FONT_ROW_COUNT)
        {
          fonts.clear();
          italic=0;
          bold=0;
          add_in_one_row(row,&fonts,&italic,&bold);
          if (row2!=NULL)
          {
            hdiff=row->row->x_height()-row2->row->x_height();
            if (hdiff<0)
              hdiff=-hdiff;
            if (hdiff<MAX_XHEIGHT_DIFF)
              add_in_one_row(row2,&fonts,&italic,&bold);
          }
          do
            page_res_it.forward();
          while (page_res_it.row()==row);
          row2=page_res_it.row();
          if (row2!=NULL)
          {
            hdiff=row->row->x_height()-row2->row->x_height();
            if (hdiff<0)
              hdiff=-hdiff;
            if (hdiff<MAX_XHEIGHT_DIFF)
              add_in_one_row(row2,&fonts,&italic,&bold);
          }
          row->italic=italic;
          row->bold=bold;
          find_modal_font(&fonts,&row->font1,&row->font1_count);
          find_modal_font(&fonts,&row->font2,&row->font2_count);
        }
        else
          page_res_it.forward();
      }
      else
        page_res_it.forward();
    }*/

    page_res_it.restart_page ();
    while (page_res_it.word () != NULL)
    {
        row = page_res_it.row ();    //current row
        word = page_res_it.word ();
        length = word->best_choice->length();

        count = word->italic;

        if (count < 0)
        {
            count = -count;
        }

        if (!(count == length || (length > 3 && count >= length * 3 / 4)))
        {
            word->italic = doc_italic > 0 ? 1 : -1;
        }

        count = word->bold;

        if (count < 0)
        {
            count = -count;
        }

        if (!(count == length || (length > 3 && count >= length * 3 / 4)))
        {
            word->bold = doc_bold > 0 ? 1 : -1;
        }

        count = word->font1_count;
        if (!(count == length || (length > 3 && count >= length * 3 / 4)))
        {
            word->font1 = doc_font;
            word->font1_count = doc_font_count;
        }

        page_res_it.forward ();
    }
}

/**
 * add_in_one_row
 *
 * Add into the stats for one row.
 */

//dead code?
void add_in_one_row(               //good chars in word
                                   ROW_RES *row,  //current row
                                   STATS *fonts,  //font stats
                                   inT8 *italic,  //output count
                                   inT8 *bold     //output count
                                   )
{
    WERD_RES *word;                //current word
    WERD_RES_IT word_it = &row->word_res_list;

    for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ())
    {
        word = word_it.data ();
        *italic += word->italic;
        *bold += word->bold;

        if (word->font1_count > 0)
        {
            fonts->add (word->font1, word->font1_count);
        }

        if (word->font2_count > 0)
        {
            fonts->add (word->font2, word->font2_count);
        }
    }
}


/**
 * find_modal_font
 *
 * Find the modal font and remove from the stats.
 */
//make static?
void find_modal_font(                  //good chars in word
                                       STATS *fonts,     //font stats
                                       inT8 *font_out,   //output font
                                       inT8 *font_count  //output count
                                       )
{
    inT8 font;                     //font index
    inT32 count;                   //pile couat

    if (fonts->get_total () > 0)
    {
        font = (inT8) fonts->mode ();
        *font_out = font;
        count = fonts->pile_count (font);
        *font_count = count < MAX_INT8 ? count : MAX_INT8;
        fonts->add (font, -*font_count);
    }
    else
    {
        *font_out = -1;
        *font_count = 0;
    }
}
/////////////////////////////////////////////////////////////////control////////////////////////////////////////

/////////////////////////////////////////////////////////////////boxread////////////////////////////////////////
// Box files are used ONLY DURING TRAINING, but by both processes of
// creating tr files with tesseract, and unicharset_extractor.
// read_next_box factors out the code to interpret a line of a box
// file so that applybox and unicharset_extractor interpret the same way.
// This function returns the next valid box file utf8 string and coords
// and returns true, or false on eof (and closes the file).
// It ignores the uft8 file signature, checks for valid utf-8 and allows
// space or tab between fields.
// utf8_str must be at least kBoxReadBufSize in length.
// If there are page numbers in the file, it reads them all.
bool read_next_box(FILE* box_file, char* utf8_str,
                   int* x_min, int* y_min, int* x_max, int* y_max) {
  return read_next_box(-1, box_file, utf8_str,
                       x_min, y_min, x_max, y_max);
}

// As read_next_box above, but get a specific page number. (0-based)
// Use -1 to read any page number. Files without page number all
// read as if they are page 0.
bool read_next_box(int target_page, FILE* box_file, char* utf8_str,
                   int* x_min, int* y_min, int* x_max, int* y_max) {
  static int line = 0;
  int count = 0;
  int page = 0;
  char buff[kBoxReadBufSize];                //boxfile read buffer
  char uch[kBoxReadBufSize];
  char *buffptr = buff;

  while (fgets(buff, sizeof(buff) - 1, box_file)) {
    line++;

    buffptr = buff;
    const unsigned char *ubuf = reinterpret_cast<const unsigned char*>(buffptr);
    if (ubuf[0] == 0xef && ubuf[1] == 0xbb && ubuf[2] == 0xbf)
      buffptr += 3;  // Skip unicode file designation.
    // Check for blank lines in box file
    while (*buffptr == ' ' || *buffptr == '\t')
      buffptr++;
    if (*buffptr != '\0') {
      // Read the unichar without messing up on Tibetan.
      int uch_len = 0;
      while (*buffptr != '\0' && *buffptr != ' ' && *buffptr != '\t')
        uch[uch_len++] = *buffptr++;
      uch[uch_len] = '\0';
      if (*buffptr != '\0') ++buffptr;
      count = sscanf(buffptr, "%d %d %d %d %d",
                     x_min, y_min, x_max, y_max, &page);
      if (count != 5) {
        if (target_page <= 0) {
          // If target_page is negative or zero, allow lines with no page number
          page = 0;
          count = sscanf(buffptr, "%d %d %d %d", x_min, y_min, x_max, y_max);
        } else {
          tprintf("Box file format error on line %i; ignored\n", line);
          continue;
        }
      }
      if (target_page >= 0 && target_page != page)
        continue;  // Not on the appropriate page.
      if (count >= 4) {
        // Validate UTF8 by making unichars with it.
        int used = 0;
        while (used < uch_len) {
          UNICHAR ch(uch + used, uch_len - used);
          int new_used = ch.utf8_len();
          if (new_used == 0) {
            tprintf("Bad UTF-8 str %s starts with 0x%02x at line %d, col %d\n",
                    uch + used, uch[used], line, used + 1);
            count = 0;
            break;
          }
          used += new_used;
        }
        if (uch_len > UNICHAR_LEN) {
          tprintf("utf-8 string too long at line %d\n", line);
          count = 0;
        }
      }
      if ((count < 5 && target_page > 0) || (count < 4 && target_page <= 0)) {
        tprintf("Box file format error on line %i ignored\n", line);
      } else {
        strcpy(utf8_str, uch);
        return true;  // Successfully read a box.
      }
    }
  }
  fclose(box_file);
  line = 0;
  return false;                  //EOF
}
/////////////////////////////////////////////////////////////////boxread////////////////////////////////////////

/////////////////////////////////////////////////////////////////applybox////////////////////////////////////////
#define EXTERN
EXTERN BOOL_VAR (applybox_rebalance, TRUE, "Drop dead");
EXTERN INT_VAR (applybox_debug, 5, "Debug level");
EXTERN INT_VAR (applybox_page, 0, "Page number to apply boxes from");
EXTERN STRING_VAR (applybox_test_exclusions, "", "Chars ignored for testing");
EXTERN double_VAR (applybox_error_band, 0.15, "Err band as fract of xht");

EXTERN STRING_VAR(exposure_pattern, ".exp",
                  "Exposure value follows this pattern in the image"
                  " filename. The name of the image files are expected"
                  " to be in the form [lang].[fontname].exp[num].tif");

EXTERN BOOL_VAR(learn_chars_and_char_frags_mode, FALSE,
                "Learn both character fragments (as is done in the"
                " special low exposure mode) as well as unfragmented"
                " characters.");

extern IMAGE page_image;

// The unicharset used during box training
static UNICHARSET unicharset_boxes;

static void clear_any_old_text(BLOCK_LIST *block_list);

// Register uch with unicharset_boxes.
static UNICHAR_ID register_char(const char *uch);

static BOOL8 read_next_box(int page, FILE* box_file, TBOX *box, UNICHAR_ID *uch_id);


/*************************************************************************
 * The code re-assigns outlines to form words each with ONE labelled blob.
 * Noise is left in UNLABELLED words. The chars on the page are checked crudely
 * for sensible position relative to baseline and xht. Failed boxes are
 * compensated for by duplicating other believable instances of the character.
 *
 * The box file is assumed to contain box definitions, one per line, of the
 * following format:
 *   <Char> <left> <bottom> <right> <top> <page> ... arbitrary trailing fields unused
 *
 * The approach taken is to search the WHOLE page for stuff overlapping each box.
 *  - This is not too inefficient and is SAFE.
 *    - We can detect overlapping blobs as we will be attempting to put a blob
 *      from a LABELLED word into the current word.
 *    - When all the boxes have been processed we can detect any stuff which is
 *      being ignored - it is the unlabelled words left on the page.
 *
 * A box should only overlap one row.
 *
 * A warning is given if the box is on the same row as the previous box, but NOT
 * on the same row as the previous blob.
 *
 * Any OUTLINE which overlaps the box is put into the new word.
 *
 * ascender chars must ascend above xht significantly
 * xht chars must not rise above row xht significantly
 * bl chars must not descend below baseline significantly
 * descender chars must descend below baseline significantly
 *
 * ?? Certain chars are DROPPED - to limit the training data.
 *
 *************************************************************************/                                            //real blocks
void Tesseract::apply_boxes(const STRING& fname, BLOCK_LIST *block_list)
{
  inT16 boxfile_lineno = 0;
  inT16 boxfile_charno = 0;
  TBOX box;                       //boxfile box
  UNICHAR_ID uch_id;             //correct ch from boxfile
  ROW *row;
  ROW *prev_row = NULL;
  inT16 prev_box_right = MAX_INT16;
  inT16 block_id;
  inT16 row_id;
  inT16 box_count = 0;
  inT16 box_failures = 0;
  inT16 labels_ok;
  inT16 rows_ok;
  inT16 bad_blobs;
  inT16 *tgt_char_counts = NULL; // No. of box samples
  inT16 i;
  inT16 rebalance_count = 0;
  UNICHAR_ID min_uch_id = INVALID_UNICHAR_ID;
  inT16 min_samples;
  inT16 final_labelled_blob_count;
  bool low_exposure = false;

  // Clean the unichar set
  unicharset_boxes.clear();
  // Space character needed to represent NIL classification
  unicharset_boxes.unichar_insert(" ");

  // Figure out whether this image file's exposure is less than 1, in which
  // case when learning we will only pay attention to character fragments.
  const char *ptr = strstr(imagefile.string(), exposure_pattern.string());
  if (ptr != NULL && strtol(ptr += strlen(exposure_pattern.string()), NULL, 10) < 0)
  {
      low_exposure = true;
  }

  FILE* box_file;
  STRING filename = fname;
  const char *lastdot;           //of name

  lastdot = strrchr (filename.string (), '.');
  if (lastdot != NULL) filename[lastdot - filename.string()] = '\0';

  filename += ".box";
  if (!(box_file = fopen (filename.string(), "r")))
  {
    CANTOPENFILE.error ("read_next_box", EXIT, "Cant open box file %s %d", filename.string(), errno);
  }

  tgt_char_counts = new inT16[MAX_NUM_CLASSES];
  for (i = 0; i < MAX_NUM_CLASSES; i++) tgt_char_counts[i] = 0;

  clear_any_old_text(block_list);
  while (read_next_box(applybox_page, box_file, &box, &uch_id))
  {
    box_count++;
    if (!low_exposure || learn_chars_and_char_frags_mode)
    {
      tgt_char_counts[uch_id]++;
    }

    row = find_row_of_box (block_list, box, block_id, row_id);
    if (box.left () < prev_box_right)
    {
      boxfile_lineno++;
      boxfile_charno = 1;
    }
    else
    {
      boxfile_charno++;
    }

    if (row == NULL)
    {
      box_failures++;
      report_failed_box (boxfile_lineno, boxfile_charno, box, unicharset_boxes.id_to_unichar(uch_id),
        "FAILURE! box overlaps no blobs or blobs in multiple rows");
    }
    else
    {
      if ((box.left () >= prev_box_right) && (row != prev_row))
      {
          report_failed_box (boxfile_lineno, boxfile_charno, box, unicharset_boxes.id_to_unichar(uch_id), "WARNING! false row break");
      }

      box_failures += resegment_box (row, box, uch_id, block_id, row_id, boxfile_lineno, boxfile_charno, tgt_char_counts, low_exposure, true);
      prev_row = row;
    }
    prev_box_right = box.right ();
  }

  tidy_up(block_list, labels_ok, rows_ok, bad_blobs, tgt_char_counts, rebalance_count,
          &min_uch_id, min_samples, final_labelled_blob_count, low_exposure, true);

  tprintf ("APPLY_BOXES:\n");
  tprintf ("   Boxes read from boxfile:  %6d\n", box_count);
  tprintf ("   Initially labelled blobs: %6d in %d rows\n", labels_ok, rows_ok);
  tprintf ("   Box failures detected:       %6d\n", box_failures);
  tprintf ("   Duped blobs for rebalance:%6d\n", rebalance_count);
  tprintf ("   \"%s\" has fewest samples:%6d\n", unicharset_boxes.id_to_unichar(min_uch_id), min_samples);
  tprintf ("                Total unlabelled words:   %6d\n", bad_blobs);
  tprintf ("                Final labelled words:     %6d\n", final_labelled_blob_count);

  // Clean up.
  delete[] tgt_char_counts;
}

int Tesseract::Boxes2BlockList(int box_cnt, TBOX *boxes, BLOCK_LIST *block_list, bool right2left)
{
  inT16 boxfile_lineno = 0;
  inT16 boxfile_charno = 0;
  TBOX box;
  ROW *row;
  inT16 prev_box_right = MAX_INT16;
  inT16 prev_box_left = 0;
  inT16 block_id;
  inT16 row_id;
  inT16 box_failures = 0;
  inT16 labels_ok;
  inT16 rows_ok;
  inT16 bad_blobs;
  inT16 rebalance_count = 0;
  UNICHAR_ID min_uch_id;
  inT16 min_samples;
  inT16 final_labelled_blob_count;

  clear_any_old_text(block_list);
  for (int box_idx = 0; box_idx < box_cnt; box_idx++)
  {
    box = boxes[box_idx];

    row = find_row_of_box(block_list, box, block_id, row_id);

    // check for a new row
    if ((right2left && box.right () > prev_box_left) || (!right2left && box.left () < prev_box_right))
    {
      boxfile_lineno++;
      boxfile_charno = 1;
    }
    else
    {
      boxfile_charno++;
    }

    if (row == NULL)
    {
      box_failures++;
    }
    else
    {
      box_failures += resegment_box(row, box, 0, block_id, row_id, boxfile_lineno, boxfile_charno, NULL, false, false);
    }

    prev_box_right = box.right ();
    prev_box_left = box.left ();
  }

  tidy_up(block_list, labels_ok, rows_ok, bad_blobs, NULL, rebalance_count,
          &min_uch_id, min_samples, final_labelled_blob_count, false, false);

  return box_failures;
}
                     //remove correct text   real blocks
static void clear_any_old_text(BLOCK_LIST *block_list)
{
  BLOCK_IT block_it(block_list);
  ROW_IT row_it;
  WERD_IT word_it;

  for (block_it.mark_cycle_pt ();
  !block_it.cycled_list (); block_it.forward ())
  {
    row_it.set_to_list (block_it.data ()->row_list ());
    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
      word_it.set_to_list (row_it.data ()->word_list ());
      for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ())
      {
        word_it.data ()->set_text ("");
      }
    }
  }
}

static UNICHAR_ID register_char(const char *uch)
{
  if (!unicharset_boxes.contains_unichar(uch))
  {
    unicharset_boxes.unichar_insert(uch);
    if (unicharset_boxes.size() > MAX_NUM_CLASSES)
    {
      tprintf("Error: Size of unicharset of boxes is " "greater than MAX_NUM_CLASSES (%d)\n", MAX_NUM_CLASSES);
      exit(1);
    }
  }

  return unicharset_boxes.unichar_to_id(uch);
}

static BOOL8 read_next_box(int page, FILE* box_file, TBOX *box, UNICHAR_ID *uch_id)
{
  int x_min;
  int y_min;
  int x_max;
  int y_max;
  char uch[kBoxReadBufSize];

  if (read_next_box(page, box_file, uch, &x_min, &y_min, &x_max, &y_max))
  {
    *uch_id = register_char(uch);
    *box = TBOX (ICOORD (x_min, y_min), ICOORD (x_max, y_max));

      return TRUE;  // read a box ok
  }
  else
  {
    return FALSE;  // EOF
  }
}

           //real blocks   from boxfile
ROW *find_row_of_box(BLOCK_LIST *block_list, const TBOX &box, inT16 &block_id, inT16 &row_id_to_process)
{
  BLOCK_IT block_it(block_list);
  BLOCK *block;
  ROW_IT row_it;
  ROW *row;
  ROW *row_to_process = NULL;
  inT16 row_id;
  WERD_IT word_it;
  WERD *word;
  BOOL8 polyg;
  PBLOB_IT blob_it;
  PBLOB *blob;
  OUTLINE_IT outline_it;
  OUTLINE *outline;

  /*
    Find row to process - error if box REALLY overlaps more than one row. (I.e
    it overlaps blobs in the row - not just overlaps the bounding box of the
    whole row.)
  */

  block_id = 0;
  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ())
  {
    block_id++;
    row_id = 0;
    block = block_it.data ();

    if (block->bounding_box ().overlap (box))
    {
      row_it.set_to_list (block->row_list ());

      for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
      {
        row_id++;
        row = row_it.data ();

        if (row->bounding_box ().overlap (box))
        {
          word_it.set_to_list (row->word_list ());
          for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ())
          {
            word = word_it.data ();
            polyg = word->flag (W_POLYGON);

            if (word->bounding_box ().overlap (box))
            {
              blob_it.set_to_list (word->gblob_list ());
              for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ())
              {
                blob = blob_it.data ();
                if (gblob_bounding_box (blob, polyg).overlap (box))
                {
                  outline_it.set_to_list (gblob_out_list(blob, polyg));
                  for (outline_it.mark_cycle_pt (); !outline_it.cycled_list (); outline_it.forward ())
                  {
                    outline = outline_it.data();
                    if (goutline_bounding_box(outline, polyg).major_overlap (box))
                    {
                      if ((row_to_process == NULL) || (row_to_process == row))
                      {
                        row_to_process = row;
                        row_id_to_process = row_id;
                      }
                      else
                      {
                        /* RETURN ERROR Box overlaps blobs in more than one row  */
                        return NULL;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return row_to_process;
}


inT16 resegment_box(ROW *row, TBOX &box, UNICHAR_ID uch_id, inT16 block_id, inT16 row_id,
                    inT16 boxfile_lineno, inT16 boxfile_charno, inT16 *tgt_char_counts, bool learn_char_fragments, bool learning)
{
  WERD_LIST new_word_list;
  WERD_IT word_it;
  WERD_IT new_word_it(&new_word_list);
  WERD *word = NULL;
  WERD *new_word = NULL;
  BOOL8 polyg = false;
  PBLOB_IT blob_it;
  PBLOB_IT new_blob_it;
  PBLOB *blob;
  PBLOB *new_blob;
  OUTLINE_IT outline_it;
  OUTLINE_LIST dummy;  // Just to initialize new_outline_it.
  OUTLINE_IT new_outline_it = &dummy;
  OUTLINE *outline;
  TBOX new_word_box;
  TBOX curr_outline_box;
  TBOX prev_outline_box;
  float word_x_centre;

  inT16 error_count = 0;         //number of chars lost
  STRING label;
  UNICHAR_ID fragment_uch_id;
  int fragment_index;
  int new_word_it_len;

  if (learning && applybox_debug > 6)
  {
    tprintf("\nAPPLY_BOX: in resegment_box() for %s(%d)\n", unicharset_boxes.id_to_unichar(uch_id), uch_id);
  }

  word_it.set_to_list (row->word_list ());

  for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ())
  {
    word = word_it.data ();
    polyg = word->flag (W_POLYGON);

    if (word->bounding_box ().overlap (box))
    {
      blob_it.set_to_list (word->gblob_list ());
      prev_outline_box = TBOX();  // clear prev_outline_box
      curr_outline_box = TBOX();  // clear curr_outline_box

      for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ())
      {
        blob = blob_it.data ();
        if (gblob_bounding_box (blob, polyg).overlap (box))
        {
          outline_it.set_to_list (gblob_out_list (blob, polyg));
          for (outline_it.mark_cycle_pt (); !outline_it.cycled_list (); outline_it.forward ())
          {
            outline = outline_it.data ();
            prev_outline_box += curr_outline_box;
            curr_outline_box = goutline_bounding_box(outline, polyg);
            if (curr_outline_box.major_overlap (box))
            {
              if (strlen (word->text ()) > 0)
              {
                if (error_count == 0)
                {
                  error_count = 1;
                  if (learning && applybox_debug > 4)
                  {
                      report_failed_box(boxfile_lineno, boxfile_charno, box, unicharset_boxes.id_to_unichar(uch_id),"FAILURE! box overlaps blob in labelled word");
                  }
                }

                if (learning && applybox_debug > 4)
                {
                    tprintf ("APPLY_BOXES: ALSO ignoring corrupted char" " blk:%d row:%d \"%s\"\n", block_id, row_id, word_it.data()->text());
                }

                word_it.data ()->set_text ("");  // UN label it
                error_count++;
              }

              // Do not learn from fragments of characters that are broken
              // into very small pieces to avoid picking up noise.
              if ((learn_char_fragments || learn_chars_and_char_frags_mode) && ((C_OUTLINE *)outline)->area() < kMinFragmentOutlineArea)
              {
                if (applybox_debug > 6)
                {
                  tprintf("APPLY_BOX: fragment outline area %d is too small" " - not recording fragments of this character\n", ((C_OUTLINE *)outline)->area());
                }

                error_count++;
              }

              if (error_count == 0)
              {
                if (applybox_debug > 6 )
                {
                  tprintf("APPLY_BOX: Previous ");
                  prev_outline_box.print();
                  tprintf("APPLY_BOX: Current area: %d ", ((C_OUTLINE *)outline)->area());
                  curr_outline_box.print();
                }

                // When learning character fragments is enabled, we put
                // outlines that do not overlap on x axis in separate WERDs.
                bool start_new_word = (learn_char_fragments || learn_chars_and_char_frags_mode) && !curr_outline_box.major_x_overlap(prev_outline_box);
                if (new_word == NULL || start_new_word)
                {
                  if (new_word != NULL)
                  {  // add prev new_word to new_word_list
                    new_word_it.add_to_end(new_word);
                  }

                  // Make a new word with a single blob.
                  new_word = word->shallow_copy();
                  new_word->set_flag(W_FUZZY_NON, false);
                  new_word->set_flag(W_FUZZY_SP, false);
                  if (polyg)
                  {
                    new_blob = new PBLOB;
                  }
                  else
                  {
                    new_blob = (PBLOB *) new C_BLOB;
                  }

                  new_blob_it.set_to_list(new_word->gblob_list());
                  new_blob_it.add_to_end(new_blob);
                  new_outline_it.set_to_list(gblob_out_list(new_blob, polyg));
                }

                new_outline_it.add_to_end(outline_it.extract());  // move blob
              }
            }
          }
          if (outline_it.empty())      // no outlines in blob
          {
            delete blob_it.extract();  // so delete blob
          }
        }
      }

      if (blob_it.empty())         // no blobs in word
      {
        delete word_it.extract();  // so delete word
      }
    }
  }

  if (new_word != NULL)
  {  // add prev new_word to new_word_list
    new_word_it.add_to_end(new_word);
  }
  new_word_it_len = new_word_it.length();

  // Check for failures.
  if (error_count > 0)   return error_count;

  if (learning && new_word_it_len <= 0)
  {
    report_failed_box(boxfile_lineno, boxfile_charno, box, unicharset_boxes.id_to_unichar(uch_id), "FAILURE! Couldn't find any blobs");

    return 1;  // failure
  }

  if (learning && new_word_it_len > CHAR_FRAGMENT::kMaxChunks)
  {
    tprintf("APPLY_BOXES: too many fragments (%d) for char %s\n", new_word_it_len, unicharset_boxes.id_to_unichar(uch_id));

    return 1;  // failure
  }

  // Add labelled character or character fragments to the word list.
  fragment_index = 0;
  new_word_it.move_to_first();
  for (new_word_it.mark_cycle_pt(); !new_word_it.cycled_list(); new_word_it.forward())
  {
    new_word = new_word_it.extract();
    if (new_word_it_len > 1)
    {  // deal with a fragment
      if (learning)
      {
        label = CHAR_FRAGMENT::to_string(unicharset_boxes.id_to_unichar(uch_id), fragment_index, new_word_it_len);
        fragment_uch_id = register_char(label.string());
        new_word->set_text(label.string());
        ++fragment_index;

        // For now we cheat by setting the expected number of char fragments
        // to the number of char fragments actually parsed and labelled.
        // TODO(daria): find out whether this can be improved.
        tgt_char_counts[fragment_uch_id]++;
      }
      else
      {
        // No learning involved, Just stick a place-holder string
        new_word->set_text("*");
      }

      if (applybox_debug > 5)
      {
        tprintf("APPLY_BOX: adding char fragment %s\n", label.string());
      }
    }
    else
    {  // deal with a regular character
      if (learning)
      {
        if (!learn_char_fragments || learn_chars_and_char_frags_mode)
        {
          new_word->set_text(unicharset_boxes.id_to_unichar(uch_id));
        }
        else
        {
          // not interested in non-fragmented chars if learning fragments, so
          // unlabel it.
          new_word->set_text("");
        }
      }
      else
      {
        // No learning involved here. Just stick a place holder string
        new_word->set_text("*");
      }
    }

    gblob_sort_list(new_word->gblob_list(), polyg);
    word_it.add_to_end(new_word);
    new_word_box = new_word->bounding_box();
    word_x_centre = (new_word_box.left() + new_word_box.right()) / 2.0f;
    row->base_line(word_x_centre);
  }

  // All done. Now check if the EOL, BOL flags are set correctly.
  word_it.move_to_first();
  for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward())
  {
    word = word_it.data();
    word->set_flag(W_BOL, false);
    word->set_flag(W_EOL, false);
  }

  word->set_flag(W_EOL, true);
  word_it.move_to_first();
  word_it.data()->set_flag(W_BOL, true);

  return 0;  //success

#if 0
    if (strlen(unicharset_boxes.id_to_unichar(uch_id)) == 1)
    {
      if (STRING (chs_caps_ht).contains (unicharset_boxes.id_to_unichar(uch_id)[0]) &&
         (new_word_box.top () < baseline + (1 + applybox_error_band) * row->x_height ()))
      {
        report_failed_box (boxfile_lineno, boxfile_charno, box, unicharset_boxes.id_to_unichar(uch_id), "FAILURE! caps-ht char didn't ascend");
        new_word->set_text ("");

        return 1;
      }

      if (STRING (chs_odd_top).contains (unicharset_boxes.id_to_unichar(uch_id)[0]) &&
         (new_word_box.top () < baseline + (1 - applybox_error_band) * row->x_height ()))
      {
        report_failed_box (boxfile_lineno, boxfile_charno, box, unicharset_boxes.id_to_unichar(uch_id), "FAILURE! Odd top char below xht");
        new_word->set_text ("");

        return 1;
      }

      if (STRING(chs_x_ht).contains (unicharset_boxes.id_to_unichar(uch_id)[0]) &&
              ((new_word_box.top () > baseline + (1 + applybox_error_band) * row->x_height ()) ||
               (new_word_box.top () < baseline + (1 - applybox_error_band) * row->x_height ())))
      {
        report_failed_box (boxfile_lineno, boxfile_charno, box, unicharset_boxes.id_to_unichar(uch_id), "FAILURE! x-ht char didn't have top near xht");
        new_word->set_text ("");

        return 1;
      }

      if (STRING (chs_non_ambig_bl).contains
          (unicharset_boxes.id_to_unichar(uch_id)[0]) &&
          ((new_word_box.bottom () <
            baseline - applybox_error_band * row->x_height ()) ||
           (new_word_box.bottom () >
            baseline + applybox_error_band * row->x_height ())))
      {
        report_failed_box (boxfile_lineno, boxfile_charno, box,
                           unicharset_boxes.id_to_unichar(uch_id),
                           "FAILURE! non ambig BL char didnt have bottom near baseline");
        new_word->set_text ("");
        return 1;
      }

      if (STRING (chs_odd_bot).contains (unicharset_boxes.id_to_unichar(uch_id)[0]) &&
          (new_word_box.bottom () >
           baseline + applybox_error_band * row->x_height ()))
      {
        report_failed_box (boxfile_lineno, boxfile_charno, box,
                           unicharset_boxes.id_to_unichar(uch_id),
                           "FAILURE! Odd bottom char above baseline");
        new_word->set_text ("");
        return 1;
      }

      if (STRING (chs_desc).contains (unicharset_boxes.id_to_unichar(uch_id)[0]) &&
          (new_word_box.bottom () >
           baseline - applybox_error_band * row->x_height ()))
      {
        report_failed_box (boxfile_lineno, boxfile_charno, box, unicharset_boxes.id_to_unichar(uch_id), "FAILURE! Descender doesn't descend");
        new_word->set_text ("");

        return 1;
      }
    }
#endif
}


/*************************************************************************
 * tidy_up()
 *   - report >1 block
 *   - sort the words in each row.
 *   - report any rows with no labelled words.
 *   - report any remaining unlabelled words
 *   - report total labelled words
 *
 *************************************************************************/

                         //real blocks
void tidy_up(BLOCK_LIST *block_list, inT16 &ok_char_count, inT16 &ok_row_count, inT16 &unlabelled_words,
             inT16 *tgt_char_counts, inT16 &rebalance_count, UNICHAR_ID *min_uch_id, inT16 &min_samples,
             inT16 &final_labelled_blob_count, bool learn_character_fragments, bool learning)
{
  BLOCK_IT block_it(block_list);
  ROW_IT row_it;
  ROW *row;
  WERD_IT word_it;
  WERD *word;
  WERD *duplicate_word;
  inT16 block_idx = 0;
  inT16 row_idx;
  inT16 all_row_idx = 0;
  BOOL8 row_ok;
  BOOL8 rebalance_needed = FALSE;
  inT16 *labelled_char_counts = NULL;  // num unique labelled samples
  inT16 i;
  UNICHAR_ID uch_id;
  UNICHAR_ID prev_uch_id = -1;
  BOOL8 at_dupe_of_prev_word;
  ROW *prev_row = NULL;
  inT16 left;
  inT16 prev_left = -1;

  labelled_char_counts = new inT16[MAX_NUM_CLASSES];
  for (i = 0; i < MAX_NUM_CLASSES; i++)
  {
    labelled_char_counts[i] = 0;
  }

  ok_char_count = 0;
  ok_row_count = 0;
  unlabelled_words = 0;

  if (learning && (applybox_debug > 4) && (block_it.length () != 1))
  {
    if (block_it.length() > 1)
    {
      tprintf("APPLY_BOXES: More than one block??\n");
    }
    else
    {
      tprintf("APPLY_BOXES: No blocks identified.\n");
    }
  }

  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ())
  {
    block_idx++;
    row_idx = 0;
    row_ok = FALSE;
    row_it.set_to_list (block_it.data ()->row_list ());

    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
      row_idx++;
      all_row_idx++;
      row = row_it.data ();
      word_it.set_to_list (row->word_list ());
      word_it.sort (word_comparator);
      for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ())
      {
        word = word_it.data ();
        if (strlen (word->text ()) == 0 || unicharset_boxes.unichar_to_id(word->text()) < 0)
        {
          unlabelled_words++;
          if (learning && applybox_debug > 4 && !learn_character_fragments)
          {
              tprintf("APPLY_BOXES: Unlabelled word blk:%d row:%d allrows:%d\n", block_idx, row_idx, all_row_idx);
          }
        }
        else
        {
          if (word->gblob_list ()->length () != 1)
          {
              tprintf ("APPLY_BOXES: FATALITY - MULTIBLOB Labelled word blk:%d" " row:%d allrows:%d\n", block_idx, row_idx, all_row_idx);
          }

          ok_char_count++;
          ++labelled_char_counts[unicharset_boxes.unichar_to_id(word->text())];
          row_ok = TRUE;
        }
      }

      if ((applybox_debug > 6) && (!row_ok))
      {
        tprintf("APPLY_BOXES: Row with no labelled words blk:%d row:%d" " allrows:%d\n", block_idx, row_idx, all_row_idx);
      }
      else
      {
        ok_row_count++;
      }
    }
  }

  min_samples = 9999;
  for (i = 0; i < unicharset_boxes.size(); i++)
  {
    if (tgt_char_counts[i] > labelled_char_counts[i])
    {
      if (labelled_char_counts[i] <= 1)
      {
        tprintf("APPLY_BOXES: FATALITY - %d labelled samples of \"%s\" -" " target is %d:\n",
                labelled_char_counts[i], unicharset_boxes.debug_str(i).string(), tgt_char_counts[i]);
      }
      else
      {
        rebalance_needed = TRUE;
        if (applybox_debug > 0) tprintf("APPLY_BOXES: REBALANCE REQD \"%s\" - target of" " %d from %d labelled samples\n",
                                        unicharset_boxes.debug_str(i).string(), tgt_char_counts[i], labelled_char_counts[i]);
      }
    }

    if ((min_samples > labelled_char_counts[i]) && (tgt_char_counts[i] > 0))
    {
      min_samples = labelled_char_counts[i];
      *min_uch_id = i;
    }
  }

  while (applybox_rebalance && rebalance_needed)
  {
    block_it.set_to_list (block_list);
    for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ())
    {
      row_it.set_to_list (block_it.data ()->row_list ());
      for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
      {
        row = row_it.data ();
        word_it.set_to_list (row->word_list ());
        for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ())
        {
          word = word_it.data ();
          left = word->bounding_box ().left ();

          if (*word->text () != '\0')
          {
              uch_id = unicharset_boxes.unichar_to_id(word->text ());
          }
          else
          {
            uch_id = -1;
          }

          at_dupe_of_prev_word = ((row == prev_row) && (left = prev_left) && (uch_id == prev_uch_id));
          if ((uch_id != -1) && (labelled_char_counts[uch_id] > 1) && (tgt_char_counts[uch_id] > labelled_char_counts[uch_id]) && (!at_dupe_of_prev_word))
          {
            /* Duplicate the word to rebalance the labelled samples */
            if (applybox_debug > 9)
            {
              tprintf ("Duping \"%s\" from ", unicharset_boxes.id_to_unichar(uch_id));
              word->bounding_box ().print ();
            }

            duplicate_word = new WERD;
            *duplicate_word = *word;
            word_it.add_after_then_move (duplicate_word);
            rebalance_count++;
            labelled_char_counts[uch_id]++;
          }

          prev_row = row;
          prev_left = left;
          prev_uch_id = uch_id;
        }
      }
    }

    rebalance_needed = FALSE;
    for (i = 0; i < unicharset_boxes.size(); i++)
    {
      if ((tgt_char_counts[i] > labelled_char_counts[i]) && (labelled_char_counts[i] > 1))
      {
        rebalance_needed = TRUE;
        break;
      }
    }
  }

  /* Now final check - count labeled blobs */
  final_labelled_blob_count = 0;
  block_it.set_to_list (block_list);
  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ())
  {
    row_it.set_to_list (block_it.data ()->row_list ());
    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
      row = row_it.data ();
      word_it.set_to_list (row->word_list ());
      word_it.sort (word_comparator);
      for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ())
      {
        word = word_it.data ();
        if ((strlen(word->text ()) > 0) && (word->gblob_list()->length() == 1))
        {
          final_labelled_blob_count++;
        }
        else
        {
          delete word_it.extract();
        }
      }

      // delete the row if empty
      if (row->word_list()->empty())
      {
        delete row_it.extract();
      }
    }
  }

  // Clean up.
  delete[] labelled_char_counts;
}


void report_failed_box(inT16 boxfile_lineno, inT16 boxfile_charno, TBOX box, const char *box_ch, const char *err_msg)
{
  if (applybox_debug > 4)
  {
      tprintf ("APPLY_BOXES: boxfile %1d/%1d/%s ((%1d,%1d),(%1d,%1d)): %s\n",
               boxfile_lineno, boxfile_charno, box_ch, box.left (), box.bottom (), box.right (), box.top (), err_msg);
  }
}


void apply_box_training(const STRING& filename, BLOCK_LIST *block_list)
{
  BLOCK_IT block_it(block_list);
  ROW_IT row_it;
  ROW *row;
  WERD_IT word_it;
  WERD *word;
  WERD *bln_word;
  WERD copy_outword;             // copy to denorm
  PBLOB_IT blob_it;
  DENORM denorm;
  inT16 count = 0;
  char unichar[UNICHAR_LEN + 1];

  unichar[UNICHAR_LEN] = '\0';
  tprintf ("Generating training data\n");

  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ())
  {
    row_it.set_to_list (block_it.data ()->row_list ());
    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
      row = row_it.data ();
      word_it.set_to_list (row->word_list ());
      for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ())
      {
        word = word_it.data ();
        if ((strlen (word->text ()) > 0) && (word->gblob_list ()->length () == 1))
        {
          // Here is a word with a single unichar label and a single blob so train on it.
          bln_word = make_bln_copy(word, row, NULL, row->x_height (), &denorm);
          blob_it.set_to_list (bln_word->blob_list ());
          strncpy(unichar, word->text (), UNICHAR_LEN);

                                         //single blob    //correct      //correct character  //character length
          tess_training_tester(filename, blob_it.data (), &denorm, TRUE, unichar,             strlen(unichar),      NULL);

          copy_outword = *(bln_word);
          copy_outword.baseline_denormalise (&denorm);
          blob_it.set_to_list (copy_outword.blob_list ());
          delete bln_word;

          count++;
        }
      }
    }
  }

  tprintf ("Generated training data for %d blobs\n", count);
}

void Tesseract::apply_box_testing(BLOCK_LIST *block_list)
{
  BLOCK_IT block_it(block_list);
  ROW_IT row_it;
  ROW *row;
  inT16 row_count = 0;
  WERD_IT word_it;
  WERD *word;
  WERD *bln_word;
  inT16 word_count = 0;
  PBLOB_IT blob_it;
  DENORM denorm;
  inT16 count = 0;
  char ch[2];
  WERD *outword;                 //bln best choice
  //segmentation
  WERD_CHOICE *best_choice;      //tess output
  WERD_CHOICE *raw_choice;       //top choice permuter
                                 //detailed results
  BLOB_CHOICE_LIST_CLIST blob_choices;
  inT16 char_count = 0;
  inT16 correct_count = 0;
  inT16 err_count = 0;
  inT16 rej_count = 0;


  char tess_rej_str[3];
  char tess_long_str[3];

  ch[1] = '\0';
  strcpy (tess_rej_str, "|A");
  strcpy (tess_long_str, "|B");

  for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ())
  {
    row_it.set_to_list (block_it.data ()->row_list ());
    for (row_it.mark_cycle_pt (); !row_it.cycled_list (); row_it.forward ())
    {
      row = row_it.data ();
      row_count++;
      word_count = 0;
      word_it.set_to_list (row->word_list ());
      for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ())
      {
        word = word_it.data ();
        word_count++;
        if ((strlen (word->text ()) == 1) && !STRING (applybox_test_exclusions).contains (*word->text ()) && (word->gblob_list ()->length () == 1))
        {
          // Here is a word with a single char label and a single blob so test it.
          bln_word = make_bln_copy(word, row, NULL, row->x_height (), &denorm);
          blob_it.set_to_list (bln_word->blob_list ());
          ch[0] = *word->text ();
          char_count++;
          best_choice = tess_segment_pass1 (bln_word, &denorm, &Tesseract::tess_default_matcher, raw_choice, &blob_choices, outword);

          /*
            Test for TESS screw up on word. Recog_word has already ensured that the
            choice list, outword blob lists and best_choice string are the same
            length. A TESS screw up is indicated by a blank filled or 0 length string.
          */
          if ((best_choice->length() == 0) || (strspn(best_choice->unichar_string().string(), " ") == (size_t)best_choice->unichar_string().length()))
          {
            rej_count++;
            tprintf ("%d:%d: \"%s\" -> TESS FAILED\n", row_count, word_count, ch);
          }
          else
          {
            if ((best_choice->length() != outword->blob_list()->length()) || (best_choice->length() != blob_choices.length()))
            {
              tprintf("ASSERT FAIL String:\"%s\"; Strlen=%d; #Blobs=%d; #Choices=%d\n", best_choice->unichar_string().string(),
                      best_choice->length(), outword->blob_list ()->length(), blob_choices.length());
            }
            ASSERT_HOST(best_choice->length() == outword->blob_list()->length());
            ASSERT_HOST(best_choice->length() == blob_choices.length());
            fix_quotes (best_choice,

                                 //turn to double
              outword, &blob_choices);
            if (strcmp (best_choice->unichar_string().string(), ch) != 0)
            {
              err_count++;
              tprintf ("%d:%d: \"%s\" -> \"%s\"\n", row_count, word_count, ch, best_choice->unichar_string().string());
            }
            else
            {
              correct_count++;
            }
          }

          delete bln_word;
          delete outword;
          delete best_choice;
          delete raw_choice;
          blob_choices.deep_clear ();
          count++;
        }
      }
    }
  }
}
/////////////////////////////////////////////////////////////////applybox////////////////////////////////////////

/////////////////////////////////////////////////////////////////tesseractclass////////////////////////////////////////
Tesseract::Tesseract()
    : BOOL_MEMBER(tessedit_resegment_from_boxes, false, "Take segmentation and labeling from box file"),
      BOOL_MEMBER(tessedit_train_from_boxes, false, "Generate training data from boxed chars"),
      BOOL_MEMBER(tessedit_dump_pageseg_images, false, "Dump itermediate images made during page segmentation"),

      // The default for pageseg_mode is the old behaviour, so as not to
      // upset anything that relies on that.
      INT_MEMBER(tessedit_pageseg_mode, 2, "Page seg mode: 0=auto, 1=col, 2=block, 3=line, 4=word, 6=char" " (Values from PageSegMode enum in baseapi.h)"),
      INT_MEMBER(tessedit_accuracyvspeed, 0, "Accuracy V Speed tradeoff: 0 fastest, 100 most accurate" " (Values from AccuracyVSpeed enum in baseapi.h)"),
      BOOL_MEMBER(tessedit_train_from_boxes_word_level, false, "Generate training data from boxed chars at word level."),
      STRING_MEMBER(tessedit_char_blacklist, "", "Blacklist of chars not to recognize"),
      STRING_MEMBER(tessedit_char_whitelist, "", "Whitelist of chars to recognize"),
      BOOL_MEMBER(global_tessedit_ambigs_training, false, "Perform training for ambiguities"),
      pix_binary_(NULL),
      deskew_(1.0f, 0.0f),
      reskew_(1.0f, 0.0f),
      hindi_image_(false)
{
}

Tesseract::~Tesseract()
{
    Clear();
}

void Tesseract::Clear()
{
#ifdef HAVE_LIBLEPT
    if (pix_binary_ != NULL)
        pixDestroy(&pix_binary_);
#endif
    deskew_ = FCOORD(1.0f, 0.0f);
    reskew_ = FCOORD(1.0f, 0.0f);
}

void Tesseract::SetBlackAndWhitelist()
{
    // Set the white and blacklists (if any)
    unicharset.set_black_and_whitelist(tessedit_char_blacklist.string(), tessedit_char_whitelist.string());
}

#define EXTERN

EXTERN BOOL_VAR (fixsp_check_for_fp_noise_space, TRUE,
"Try turning noise to space in fixed pitch");
EXTERN BOOL_VAR (fixsp_fp_eval, TRUE, "Use alternate evaluation for fp");
EXTERN BOOL_VAR (fixsp_noise_score_fixing, TRUE, "More sophisticated?");
EXTERN INT_VAR (fixsp_non_noise_limit, 1,
"How many non-noise blbs either side?");
EXTERN double_VAR (fixsp_small_outlines_size, 0.28, "Small if lt xht x this");

EXTERN BOOL_VAR (fixsp_ignore_punct, TRUE, "In uniform spacing calc");
EXTERN BOOL_VAR (fixsp_numeric_fix, TRUE, "Try to deal with numeric punct");
EXTERN BOOL_VAR (fixsp_prefer_joined_1s, TRUE, "Arbitrary boost");
EXTERN BOOL_VAR (tessedit_test_uniform_wd_spacing, FALSE,
"Limit context word spacing");
EXTERN BOOL_VAR (tessedit_prefer_joined_punct, FALSE,
"Reward punctation joins");
EXTERN INT_VAR (fixsp_done_mode, 1, "What constitues done for spacing");
EXTERN INT_VAR (debug_fix_space_level, 0, "Contextual fixspace debug");
EXTERN STRING_VAR (numeric_punctuation, ".,",
"Punct. chs expected WITHIN numbers");

#define PERFECT_WERDS   999
#define MAXSPACING      128      /*max expected spacing in pix */

/**
 * @name fix_fuzzy_spaces()
 * Walk over the page finding sequences of words joined by fuzzy spaces. Extract
 * them as a sublist, process the sublist to find the optimal arrangement of
 * spaces then replace the sublist in the ROW_RES.
 *
 * @param monitor progress monitor
 * @param word_count count of words in doc
 * @param[out] page_res
 */
void Tesseract::fix_fuzzy_spaces(volatile ETEXT_DESC *monitor,
                                 inT32 word_count,
                                 PAGE_RES *page_res) {
  BLOCK_RES_IT block_res_it;     //iterators
  ROW_RES_IT row_res_it;
  WERD_RES_IT word_res_it_from;
  WERD_RES_IT word_res_it_to;
  WERD_RES *word_res;
  WERD_RES_LIST fuzzy_space_words;
  inT16 new_length;
  BOOL8 prevent_null_wd_fixsp;   //DONT process blobless wds
  inT32 word_index;              //current word

  block_res_it.set_to_list (&page_res->block_res_list);
  word_index = 0;
  for (block_res_it.mark_cycle_pt ();
       !block_res_it.cycled_list (); block_res_it.forward ()) {
    row_res_it.set_to_list (&block_res_it.data ()->row_res_list);
    for (row_res_it.mark_cycle_pt ();
         !row_res_it.cycled_list (); row_res_it.forward ()) {
      word_res_it_from.set_to_list (&row_res_it.data ()->word_res_list);
      while (!word_res_it_from.at_last ()) {
        word_res = word_res_it_from.data ();
        while (!word_res_it_from.at_last () &&
               !(word_res->combination ||
               word_res_it_from.data_relative (1)->word->flag (W_FUZZY_NON) ||
               word_res_it_from.data_relative (1)->word->flag (W_FUZZY_SP))) {
          fix_sp_fp_word(word_res_it_from, row_res_it.data()->row,
                         block_res_it.data()->block);
          word_res = word_res_it_from.forward ();
          word_index++;
          if (monitor != NULL) {
            monitor->ocr_alive = TRUE;
            monitor->progress = 90 + 5 * word_index / word_count;
          }
        }

        if (!word_res_it_from.at_last ()) {
          word_res_it_to = word_res_it_from;
          prevent_null_wd_fixsp =
            word_res->word->gblob_list ()->empty ();
          if (check_debug_pt (word_res, 60))
            debug_fix_space_level.set_value (10);
          word_res_it_to.forward ();
          word_index++;
          if (monitor != NULL) {
            monitor->ocr_alive = TRUE;
            monitor->progress = 90 + 5 * word_index / word_count;
          }
          while (!word_res_it_to.at_last () &&
                 (word_res_it_to.data_relative (1)->word->flag (W_FUZZY_NON) ||
                 word_res_it_to.data_relative (1)->word->flag (W_FUZZY_SP))) {
            if (check_debug_pt (word_res, 60))
              debug_fix_space_level.set_value (10);
            if (word_res->word->gblob_list ()->empty ())
              prevent_null_wd_fixsp = TRUE;
            word_res = word_res_it_to.forward ();
          }
          if (check_debug_pt (word_res, 60))
            debug_fix_space_level.set_value (10);
          if (word_res->word->gblob_list ()->empty ())
            prevent_null_wd_fixsp = TRUE;
          if (prevent_null_wd_fixsp) {
            word_res_it_from = word_res_it_to;
          } else {
            fuzzy_space_words.assign_to_sublist(&word_res_it_from,
                                                &word_res_it_to);
            fix_fuzzy_space_list(fuzzy_space_words,
                                 row_res_it.data()->row,
                                 block_res_it.data()->block);
            new_length = fuzzy_space_words.length ();
            word_res_it_from.add_list_before (&fuzzy_space_words);
            for (; (!word_res_it_from.at_last () && (new_length > 0)); new_length--) {
              word_res_it_from.forward ();
            }
          }
          if (test_pt)
            debug_fix_space_level.set_value (0);
        }
        fix_sp_fp_word(word_res_it_from, row_res_it.data ()->row,
                       block_res_it.data()->block);
        //Last word in row
      }
    }
  }
}

void Tesseract::fix_fuzzy_space_list(WERD_RES_LIST &best_perm,
                                     ROW *row,
                                     BLOCK* block) {
  inT16 best_score;
  WERD_RES_LIST current_perm;
  inT16 current_score;
  BOOL8 improved = FALSE;

  best_score = eval_word_spacing(best_perm);  // default score
  dump_words (best_perm, best_score, 1, improved);

  if (best_score != PERFECT_WERDS)
    initialise_search(best_perm, current_perm);

  while ((best_score != PERFECT_WERDS) && !current_perm.empty ()) {
    match_current_words(current_perm, row, block);
    current_score = eval_word_spacing (current_perm);
    dump_words (current_perm, current_score, 2, improved);
    if (current_score > best_score) {
      best_perm.clear();
      best_perm.deep_copy(&current_perm, &WERD_RES::deep_copy);
      best_score = current_score;
      improved = TRUE;
    }
    if (current_score < PERFECT_WERDS)
      transform_to_next_perm(current_perm);
  }
  dump_words (best_perm, best_score, 3, improved);
}

void initialise_search(WERD_RES_LIST &src_list, WERD_RES_LIST &new_list) {
  WERD_RES_IT src_it(&src_list);
  WERD_RES_IT new_it(&new_list);
  WERD_RES *src_wd;
  WERD_RES *new_wd;

  for (src_it.mark_cycle_pt (); !src_it.cycled_list (); src_it.forward ()) {
    src_wd = src_it.data ();
    if (!src_wd->combination) {
      new_wd = new WERD_RES (*src_wd);
      new_wd->combination = FALSE;
      new_wd->part_of_combo = FALSE;
      new_it.add_after_then_move (new_wd);
    }
  }
}

void Tesseract::match_current_words(WERD_RES_LIST &words, ROW *row,
                                    BLOCK* block) {
  WERD_RES_IT word_it(&words);
  WERD_RES *word;

  for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ()) {
    word = word_it.data ();
    if ((!word->part_of_combo) && (word->outword == NULL))
      classify_word_pass2(word, block, row);
  }
}


/**
 * @name eval_word_spacing()
 * The basic measure is the number of characters in contextually confirmed
 * words. (I.e the word is done)
 * If all words are contextually confirmed the evaluation is deemed perfect.
 *
 * Some fiddles are done to handle "1"s as these are VERY frequent causes of
 * fuzzy spaces. The problem with the basic measure is that "561 63" would score
 * the same as "56163", though given our knowledge that the space is fuzzy, and
 * that there is a "1" next to the fuzzy space, we need to ensure that "56163"
 * is prefered.
 *
 * The solution is to NOT COUNT the score of any word which has a digit at one
 * end and a "1Il" as the character the other side of the space.
 *
 * Conversly, any character next to a "1" within a word is counted as a positive
 * score. Thus "561 63" would score 4 (3 chars in a numeric word plus 1 side of
 * the "1" joined).  "56163" would score 7 - all chars in a numeric word + 2
 * sides of a "1" joined.
 *
 * The joined 1 rule is applied to any word REGARDLESS of contextual
 * confirmation.  Thus "PS7a71 3/7a" scores 1 (neither word is contexutally
 * confirmed. The only score is from the joined 1. "PS7a713/7a" scores 2.
 *
 */
inT16 Tesseract::eval_word_spacing(WERD_RES_LIST &word_res_list) {
  WERD_RES_IT word_res_it(&word_res_list);
  inT16 total_score = 0;
  inT16 word_count = 0;
  inT16 done_word_count = 0;
  inT16 word_len;
  inT16 i;
  inT16 offset;
  WERD_RES *word;                //current word
  inT16 prev_word_score = 0;
  BOOL8 prev_word_done = FALSE;
  BOOL8 prev_char_1 = FALSE;     //prev ch a "1/I/l"?
  BOOL8 prev_char_digit = FALSE; //prev ch 2..9 or 0
  BOOL8 current_char_1 = FALSE;
  BOOL8 current_word_ok_so_far;
  STRING punct_chars = "!\"`',.:;";
  BOOL8 prev_char_punct = FALSE;
  BOOL8 current_char_punct = FALSE;
  BOOL8 word_done = FALSE;

  do {
    word = word_res_it.data ();
    word_done = fixspace_thinks_word_done (word);
    word_count++;
    if (word->tess_failed) {
      total_score += prev_word_score;
      if (prev_word_done)
        done_word_count++;
      prev_word_score = 0;
      prev_char_1 = FALSE;
      prev_char_digit = FALSE;
      prev_word_done = FALSE;
    }
    else {
      /*
        Can we add the prev word score and potentially count this word?
        Yes IF it didnt end in a 1 when the first char of this word is a digit
          AND it didnt end in a digit when the first char of this word is a 1
      */
      word_len = word->reject_map.length ();
      current_word_ok_so_far = FALSE;
      if (!((prev_char_1 &&
          digit_or_numeric_punct (word, 0)) ||
          (prev_char_digit &&
          ((word_done &&
          (word->best_choice->unichar_lengths().string()[0] == 1 &&
          word->best_choice->unichar_string()[0] == '1')) ||
          (!word_done &&
          STRING(conflict_set_I_l_1).contains(word->best_choice->unichar_string ()[0])))))) {
        total_score += prev_word_score;
        if (prev_word_done)
          done_word_count++;
        current_word_ok_so_far = word_done;
      }

      if ((current_word_ok_so_far) &&
          (!tessedit_test_uniform_wd_spacing ||
          ((word->best_choice->permuter () == NUMBER_PERM) ||
      uniformly_spaced (word)))) {
        prev_word_done = TRUE;
        prev_word_score = word_len;
      }
      else {
        prev_word_done = FALSE;
        prev_word_score = 0;
      }

      if (fixsp_prefer_joined_1s) {
        /* Add 1 to total score for every joined 1 regardless of context and
           rejtn */

        for (i = 0, prev_char_1 = FALSE; i < word_len; i++) {
          current_char_1 = word->best_choice->unichar_string()[i] == '1';
          if (prev_char_1 || (current_char_1 && (i > 0)))
            total_score++;
          prev_char_1 = current_char_1;
        }
      }

      /* Add 1 to total score for every joined punctuation regardless of context
        and rejtn */
      if (tessedit_prefer_joined_punct) {
        for (i = 0, offset = 0, prev_char_punct = FALSE; i < word_len;
             offset += word->best_choice->unichar_lengths()[i++]) {
          current_char_punct =
            punct_chars.contains (word->best_choice->unichar_string()[offset]);
          if (prev_char_punct || (current_char_punct && (i > 0)))
            total_score++;
          prev_char_punct = current_char_punct;
        }
      }
      prev_char_digit = digit_or_numeric_punct (word, word_len - 1);
      for (i = 0, offset = 0; i < word_len - 1;
           offset += word->best_choice->unichar_lengths()[i++]);
      prev_char_1 =
        ((word_done
        && (word->best_choice->unichar_string()[offset] == '1'))
        || (!word_done
        && STRING(conflict_set_I_l_1).contains(
            word->best_choice->unichar_string()[offset])));
    }
    /* Find next word */
    do
      word_res_it.forward ();
    while (word_res_it.data ()->part_of_combo);
  }
  while (!word_res_it.at_first ());
  total_score += prev_word_score;
  if (prev_word_done)
    done_word_count++;
  if (done_word_count == word_count)
    return PERFECT_WERDS;
  else
    return total_score;
}


BOOL8 Tesseract::digit_or_numeric_punct(WERD_RES *word, int char_position) {
  int i;
  int offset;

  for (i = 0, offset = 0; i < char_position;
       offset += word->best_choice->unichar_lengths()[i++]);
  return (unicharset.get_isdigit(word->best_choice->unichar_string().string() + offset,
                                 word->best_choice->unichar_lengths()[i]) ||
    (fixsp_numeric_fix &&
    (word->best_choice->permuter () == NUMBER_PERM) &&
    STRING (numeric_punctuation).contains
     (word->best_choice->unichar_string().string()[offset])));
}

/**
 * @name transform_to_next_perm()
 * Examines the current word list to find the smallest word gap size. Then walks
 * the word list closing any gaps of this size by either inserted new
 * combination words, or extending existing ones.
 *
 * The routine COULD be limited to stop it building words longer than N blobs.
 *
 * If there are no more gaps then it DELETES the entire list and returns the
 * empty list to cause termination.
 */
void transform_to_next_perm(WERD_RES_LIST &words) {
  WERD_RES_IT word_it(&words);
  WERD_RES_IT prev_word_it(&words);
  WERD_RES *word;
  WERD_RES *prev_word;
  WERD_RES *combo;
  WERD *copy_word;
  inT16 prev_right = -1;
  TBOX box;
  inT16 gap;
  inT16 min_gap = MAX_INT16;

  for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ()) {
    word = word_it.data ();
    if (!word->part_of_combo) {
      box = word->word->bounding_box ();
      if (prev_right >= 0) {
        gap = box.left () - prev_right;
        if (gap < min_gap)
          min_gap = gap;
      }
      prev_right = box.right ();
    }
  }
  if (min_gap < MAX_INT16) {
    prev_right = -1;             //back to start
    word_it.set_to_list (&words);
    //cant use cycle pt due to inserted combos at start of list
    for (; (prev_right < 0) || !word_it.at_first (); word_it.forward ()) {
      word = word_it.data ();
      if (!word->part_of_combo) {
        box = word->word->bounding_box ();
        if (prev_right >= 0) {
          gap = box.left () - prev_right;
          if (gap <= min_gap) {
            prev_word = prev_word_it.data ();
            if (prev_word->combination)
              combo = prev_word;
            else {
              /* Make a new combination and insert before the first word being joined */
              copy_word = new WERD;
              *copy_word = *(prev_word->word);
              //deep copy
              combo = new WERD_RES (copy_word);
              combo->combination = TRUE;
              combo->x_height = prev_word->x_height;
              prev_word->part_of_combo = TRUE;
              prev_word_it.add_before_then_move (combo);
            }
            combo->word->set_flag (W_EOL, word->word->flag (W_EOL));
            if (word->combination) {
              combo->word->join_on (word->word);
              //Move blbs to combo
                                 //old combo no longer needed
              delete word_it.extract ();
            }
            else {
                                 //Cpy current wd to combo
              combo->copy_on (word);
              word->part_of_combo = TRUE;
            }
            combo->done = FALSE;
            if (combo->outword != NULL) {
              delete combo->outword;
              delete combo->best_choice;
              delete combo->raw_choice;
              combo->outword = NULL;
              combo->best_choice = NULL;
              combo->raw_choice = NULL;
            }
          }
          else
                                 //catch up
              prev_word_it = word_it;
        }
        prev_right = box.right ();
      }
    }
  }
  else
    words.clear ();              //signal termination
}


void dump_words(WERD_RES_LIST &perm, inT16 score, inT16 mode, BOOL8 improved) {
  WERD_RES_IT word_res_it(&perm);
  static STRING initial_str;

  if (debug_fix_space_level > 0) {
    if (mode == 1) {
      initial_str = "";
      for (word_res_it.mark_cycle_pt ();
      !word_res_it.cycled_list (); word_res_it.forward ()) {
        if (!word_res_it.data ()->part_of_combo) {
          initial_str += word_res_it.data()->best_choice->unichar_string();
          initial_str += ' ';
        }
      }
    }

    #ifndef SECURE_NAMES
    if (debug_fix_space_level > 1) {
      switch (mode) {
        case 1:
          tprintf ("EXTRACTED (%d): \"", score);
          break;
        case 2:
          tprintf ("TESTED (%d): \"", score);
          break;
        case 3:
          tprintf ("RETURNED (%d): \"", score);
          break;
      }

      for (word_res_it.mark_cycle_pt ();
           !word_res_it.cycled_list (); word_res_it.forward ()) {
        if (!word_res_it.data ()->part_of_combo)
          tprintf("%s/%1d ",
                  word_res_it.data()->best_choice->unichar_string().string(),
                  (int)word_res_it.data()->best_choice->permuter());
      }
      tprintf ("\"\n");
    }
    else if (improved) {
      tprintf ("FIX SPACING \"%s\" => \"", initial_str.string ());
      for (word_res_it.mark_cycle_pt ();
           !word_res_it.cycled_list (); word_res_it.forward ()) {
        if (!word_res_it.data ()->part_of_combo)
          tprintf ("%s/%1d ",
                   word_res_it.data()->best_choice->unichar_string().string(),
                   (int)word_res_it.data()->best_choice->permuter());
      }
      tprintf ("\"\n");
    }
    #endif
  }
}


/**
 * @name uniformly_spaced()
 * Return true if one of the following are true:
 * - All inter-char gaps are the same width
 * - The largest gap is no larger than twice the mean/median of the others
 * - The largest gap is < 64/5 = 13 and all others are <= 0
 * **** REMEMBER - WE'RE NOW WORKING WITH A BLN WERD !!!
 */
BOOL8 uniformly_spaced(WERD_RES *word) {
  PBLOB_IT blob_it;
  TBOX box;
  inT16 prev_right = -MAX_INT16;
  inT16 gap;
  inT16 max_gap = -MAX_INT16;
  inT16 max_gap_count = 0;
  STATS gap_stats (0, MAXSPACING);
  BOOL8 result;
  const ROW *row = word->denorm.row ();
  float max_non_space;
  float normalised_max_nonspace;
  inT16 i = 0;
  inT16 offset = 0;
  STRING punct_chars = "\"`',.:;";

  blob_it.set_to_list (word->outword->blob_list ());

  for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ()) {
    box = blob_it.data ()->bounding_box ();
    if ((prev_right > -MAX_INT16) &&
        (!fixsp_ignore_punct ||
        (!punct_chars.contains (word->best_choice->unichar_string()
                                [offset - word->best_choice->unichar_lengths()[i - 1]]) &&
        !punct_chars.contains (word->best_choice->unichar_string()[offset])))) {
      gap = box.left () - prev_right;
      if (gap < max_gap)
        gap_stats.add (gap, 1);
      else if (gap == max_gap)
        max_gap_count++;
      else {
        if (max_gap_count > 0)
          gap_stats.add (max_gap, max_gap_count);
        max_gap = gap;
        max_gap_count = 1;
      }
    }
    prev_right = box.right ();
    offset += word->best_choice->unichar_lengths()[i++];
  }

  max_non_space = (row->space () + 3 * row->kern ()) / 4;
  normalised_max_nonspace = max_non_space * bln_x_height / row->x_height ();

  result = ((gap_stats.get_total () == 0) ||
    (max_gap <= normalised_max_nonspace) ||
    ((gap_stats.get_total () > 2) &&
    (max_gap <= 2 * gap_stats.median ())) ||
    ((gap_stats.get_total () <= 2) &&
    (max_gap <= 2 * gap_stats.mean ())));
  #ifndef SECURE_NAMES
  if ((debug_fix_space_level > 1)) {
    if (result)
      tprintf
        ("ACCEPT SPACING FOR: \"%s\" norm_maxnon = %f max=%d maxcount=%d total=%d mean=%f median=%f\n",
        word->best_choice->unichar_string().string (), normalised_max_nonspace,
        max_gap, max_gap_count, gap_stats.get_total (), gap_stats.mean (),
        gap_stats.median ());
    else
      tprintf
        ("REJECT SPACING FOR: \"%s\" norm_maxnon = %f max=%d maxcount=%d total=%d mean=%f median=%f\n",
        word->best_choice->unichar_string().string (), normalised_max_nonspace,
        max_gap, max_gap_count, gap_stats.get_total (), gap_stats.mean (),
        gap_stats.median ());
  }
  #endif

  return result;
}


BOOL8 fixspace_thinks_word_done(WERD_RES *word) {
  if (word->done)
    return TRUE;

  /*
    Use all the standard pass 2 conditions for mode 5 in set_done() in
    reject.c BUT DONT REJECT IF THE WERD IS AMBIGUOUS - FOR SPACING WE DONT
    CARE WHETHER WE HAVE of/at on/an etc.
  */
  if ((fixsp_done_mode > 0) &&
    (word->tess_accepted ||
    ((fixsp_done_mode == 2) &&
    (word->reject_map.reject_count () == 0)) ||
    (fixsp_done_mode == 3)) &&
    (strchr (word->best_choice->unichar_string().string (), ' ') == NULL) &&
    ((word->best_choice->permuter () == SYSTEM_DAWG_PERM) ||
    (word->best_choice->permuter () == FREQ_DAWG_PERM) ||
    (word->best_choice->permuter () == USER_DAWG_PERM) ||
    (word->best_choice->permuter () == NUMBER_PERM)))
    return TRUE;
  else
    return FALSE;
}

/**
 * @name fix_sp_fp_word()
 * Test the current word to see if it can be split by deleting noise blobs. If
 * so, do the business.
 * Return with the iterator pointing to the same place if the word is unchanged,
 * or the last of the replacement words.
 */
void Tesseract::fix_sp_fp_word(WERD_RES_IT &word_res_it, ROW *row,
                               BLOCK* block) {
  WERD_RES *word_res;
  WERD_RES_LIST sub_word_list;
  WERD_RES_IT sub_word_list_it(&sub_word_list);
  inT16 blob_index;
  inT16 new_length;
  float junk;

  word_res = word_res_it.data ();
  if (!fixsp_check_for_fp_noise_space ||
    word_res->word->flag (W_REP_CHAR) ||
    word_res->combination ||
    word_res->part_of_combo || !word_res->word->flag (W_DONT_CHOP))
    return;

  blob_index = worst_noise_blob (word_res, &junk);
  if (blob_index < 0)
    return;

  #ifndef SECURE_NAMES
  if (debug_fix_space_level > 1) {
    tprintf ("FP fixspace working on \"%s\"\n",
      word_res->best_choice->unichar_string().string());
  }
  #endif
  gblob_sort_list ((PBLOB_LIST *) word_res->word->rej_cblob_list (), FALSE);
  sub_word_list_it.add_after_stay_put (word_res_it.extract ());
  fix_noisy_space_list(sub_word_list, row, block);
  new_length = sub_word_list.length ();
  word_res_it.add_list_before (&sub_word_list);
  for (; (!word_res_it.at_last () && (new_length > 1)); new_length--) {
    word_res_it.forward ();
  }
}

void Tesseract::fix_noisy_space_list(WERD_RES_LIST &best_perm, ROW *row,
                                     BLOCK* block) {
  inT16 best_score;
  WERD_RES_IT best_perm_it(&best_perm);
  WERD_RES_LIST current_perm;
  WERD_RES_IT current_perm_it(&current_perm);
  WERD_RES *old_word_res;
  WERD_RES *new_word_res;
  inT16 current_score;
  BOOL8 improved = FALSE;

                                 //default score
  best_score = fp_eval_word_spacing (best_perm);

  dump_words (best_perm, best_score, 1, improved);

  new_word_res = new WERD_RES;
  old_word_res = best_perm_it.data ();
                                 //Kludge to force deep copy
  old_word_res->combination = TRUE;
  *new_word_res = *old_word_res; //deep copy
                                 //Undo kludge
  old_word_res->combination = FALSE;
                                 //Undo kludge
  new_word_res->combination = FALSE;
  current_perm_it.add_to_end (new_word_res);

  break_noisiest_blob_word(current_perm);

  while ((best_score != PERFECT_WERDS) && !current_perm.empty ()) {
    match_current_words(current_perm, row, block);
    current_score = fp_eval_word_spacing (current_perm);
    dump_words (current_perm, current_score, 2, improved);
    if (current_score > best_score) {
      best_perm.clear();
      best_perm.deep_copy(&current_perm, &WERD_RES::deep_copy);
      best_score = current_score;
      improved = TRUE;
    }
    if (current_score < PERFECT_WERDS)
      break_noisiest_blob_word(current_perm);
  }
  dump_words (best_perm, best_score, 3, improved);
}

/**
 * break_noisiest_blob_word()
 * Find the word with the blob which looks like the worst noise.
 * Break the word into two, deleting the noise blob.
 */
void break_noisiest_blob_word(WERD_RES_LIST &words) {
  WERD_RES_IT word_it(&words);
  WERD_RES_IT worst_word_it;
  float worst_noise_score = 9999;
  int worst_blob_index = -1;     //noisiest blb of noisiest wd
  int blob_index;                //of wds noisiest blb
  float noise_score;             //of wds noisiest blb
  WERD_RES *word_res;
  C_BLOB_IT blob_it;
  C_BLOB_IT rej_cblob_it;
  C_BLOB_LIST new_blob_list;
  C_BLOB_IT new_blob_it;
  C_BLOB_IT new_rej_cblob_it;
  WERD *new_word;
  inT16 start_of_noise_blob;
  inT16 i;

  for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ()) {
    blob_index = worst_noise_blob (word_it.data (), &noise_score);
    if ((blob_index > -1) && (worst_noise_score > noise_score)) {
      worst_noise_score = noise_score;
      worst_blob_index = blob_index;
      worst_word_it = word_it;
    }
  }
  if (worst_blob_index < 0) {
    words.clear ();              //signal termination
    return;
  }

  /* Now split the worst_word_it */

  word_res = worst_word_it.data ();

  /* Move blobs before noise blob to a new bloblist */

  new_blob_it.set_to_list (&new_blob_list);
  blob_it.set_to_list (word_res->word->cblob_list ());
  for (i = 0; i < worst_blob_index; i++, blob_it.forward ()) {
    new_blob_it.add_after_then_move (blob_it.extract ());
  }
  start_of_noise_blob = blob_it.data ()->bounding_box ().left ();
  delete blob_it.extract ();     //throw out noise blb

  new_word = new WERD (&new_blob_list, word_res->word);
  new_word->set_flag (W_EOL, FALSE);
  word_res->word->set_flag (W_BOL, FALSE);
  word_res->word->set_blanks (1);//After break

  new_rej_cblob_it.set_to_list (new_word->rej_cblob_list ());
  rej_cblob_it.set_to_list (word_res->word->rej_cblob_list ());
  for (;
    (!rej_cblob_it.empty () &&
    (rej_cblob_it.data ()->bounding_box ().left () <
  start_of_noise_blob)); rej_cblob_it.forward ()) {
    new_rej_cblob_it.add_after_then_move (rej_cblob_it.extract ());
  }

  worst_word_it.add_before_then_move (new WERD_RES (new_word));

  word_res->done = FALSE;
  if (word_res->outword != NULL) {
    delete word_res->outword;
    delete word_res->best_choice;
    delete word_res->raw_choice;
    word_res->outword = NULL;
    word_res->best_choice = NULL;
    word_res->raw_choice = NULL;
  }
}


inT16 worst_noise_blob(WERD_RES *word_res, float *worst_noise_score) {
  PBLOB_IT blob_it;
  inT16 blob_count;
  float noise_score[512];
  int i;
  int min_noise_blob;            //1st contender
  int max_noise_blob;            //last contender
  int non_noise_count;
  int worst_noise_blob;          //Worst blob
  float small_limit = bln_x_height * fixsp_small_outlines_size;
  float non_noise_limit = bln_x_height * 0.8;

  blob_it.set_to_list (word_res->outword->blob_list ());
  //normalised
  blob_count = blob_it.length ();
  ASSERT_HOST (blob_count <= 512);
  if (blob_count < 5)
    return -1;                   //too short to split
  /* Get the noise scores for all blobs */

  #ifndef SECURE_NAMES
  if (debug_fix_space_level > 5)
    tprintf ("FP fixspace Noise metrics for \"%s\": ",
      word_res->best_choice->unichar_string().string());
  #endif

  for (i = 0; i < blob_count; i++, blob_it.forward ()) {
    if (word_res->reject_map[i].accepted ())
      noise_score[i] = non_noise_limit;
    else
      noise_score[i] = blob_noise_score (blob_it.data ());

    if (debug_fix_space_level > 5)
      tprintf ("%1.1f ", noise_score[i]);
  }
  if (debug_fix_space_level > 5)
    tprintf ("\n");

  /* Now find the worst one which is far enough away from the end of the word */

  non_noise_count = 0;
  for (i = 0;
  (i < blob_count) && (non_noise_count < fixsp_non_noise_limit); i++) {
    if (noise_score[i] >= non_noise_limit)
      non_noise_count++;
  }
  if (non_noise_count < fixsp_non_noise_limit)
    return -1;
  min_noise_blob = i;

  non_noise_count = 0;
  for (i = blob_count - 1;
  (i >= 0) && (non_noise_count < fixsp_non_noise_limit); i--) {
    if (noise_score[i] >= non_noise_limit)
      non_noise_count++;
  }
  if (non_noise_count < fixsp_non_noise_limit)
    return -1;
  max_noise_blob = i;

  if (min_noise_blob > max_noise_blob)
    return -1;

  *worst_noise_score = small_limit;
  worst_noise_blob = -1;
  for (i = min_noise_blob; i <= max_noise_blob; i++) {
    if (noise_score[i] < *worst_noise_score) {
      worst_noise_blob = i;
      *worst_noise_score = noise_score[i];
    }
  }
  return worst_noise_blob;
}


float blob_noise_score(PBLOB *blob) {
  OUTLINE_IT outline_it;
  TBOX box;                       //BB of outline
  inT16 outline_count = 0;
  inT16 max_dimension;
  inT16 largest_outline_dimension = 0;

  outline_it.set_to_list (blob->out_list ());
  for (outline_it.mark_cycle_pt ();
  !outline_it.cycled_list (); outline_it.forward ()) {
    outline_count++;
    box = outline_it.data ()->bounding_box ();
    if (box.height () > box.width ())
      max_dimension = box.height ();
    else
      max_dimension = box.width ();

    if (largest_outline_dimension < max_dimension)
      largest_outline_dimension = max_dimension;
  }

  if (fixsp_noise_score_fixing) {
    if (outline_count > 5)
                                 //penalise LOTS of blobs
      largest_outline_dimension *= 2;

    box = blob->bounding_box ();

    if ((box.bottom () > bln_baseline_offset * 4) ||
      (box.top () < bln_baseline_offset / 2))
                                 //Lax blob is if high or low
      largest_outline_dimension /= 2;
  }
  return largest_outline_dimension;
}


void fixspace_dbg(WERD_RES *word) {
  TBOX box = word->word->bounding_box ();
  BOOL8 show_map_detail = FALSE;
  inT16 i;

  box.print ();
  #ifndef SECURE_NAMES
  tprintf (" \"%s\" ", word->best_choice->unichar_string().string ());
  tprintf ("Blob count: %d (word); %d/%d (outword)\n",
    word->word->gblob_list ()->length (),
    word->outword->gblob_list ()->length (),
    word->outword->rej_blob_list ()->length ());
  word->reject_map.print (debug_fp);
  tprintf ("\n");
  if (show_map_detail) {
    tprintf ("\"%s\"\n", word->best_choice->unichar_string().string ());
    for (i = 0; word->best_choice->unichar_string()[i] != '\0'; i++) {
      tprintf ("**** \"%c\" ****\n", word->best_choice->unichar_string()[i]);
      word->reject_map[i].full_print (debug_fp);
    }
  }

  tprintf ("Tess Accepted: %s\n", word->tess_accepted ? "TRUE" : "FALSE");
  tprintf ("Done flag: %s\n\n", word->done ? "TRUE" : "FALSE");
  #endif
}


/**
 * fp_eval_word_spacing()
 * Evaluation function for fixed pitch word lists.
 *
 * Basically, count the number of "nice" characters - those which are in tess
 * acceptable words or in dict words and are not rejected.
 * Penalise any potential noise chars
 */
inT16 Tesseract::fp_eval_word_spacing(WERD_RES_LIST &word_res_list) {
  WERD_RES_IT word_it(&word_res_list);
  WERD_RES *word;
  PBLOB_IT blob_it;
  inT16 score = 0;
  inT16 i;
  float small_limit = bln_x_height * fixsp_small_outlines_size;

  if (!fixsp_fp_eval)
    return (eval_word_spacing (word_res_list));

  for (word_it.mark_cycle_pt (); !word_it.cycled_list (); word_it.forward ()) {
    word = word_it.data ();
    if ((word->done ||
         word->tess_accepted) ||
        (word->best_choice->permuter() == SYSTEM_DAWG_PERM) ||
        (word->best_choice->permuter() == FREQ_DAWG_PERM) ||
        (word->best_choice->permuter() == USER_DAWG_PERM) ||
        (safe_dict_word(*(word->best_choice)) > 0)) {
      blob_it.set_to_list(word->outword->blob_list());
      UNICHAR_ID space = getDict().getUnicharset().unichar_to_id(" ");
      for (i = 0; i < word->best_choice->length(); ++i, blob_it.forward()) {
        if (word->best_choice->unichar_id(i) == space ||
            (blob_noise_score(blob_it.data()) < small_limit)) {
          score -= 1;  // penalise possibly erroneous non-space
        } else if (word->reject_map[i].accepted()) {
          score++;
        }
      }
    }
  }
  if (score < 0)
    score = 0;
  return score;
}
/////////////////////////////////////////////////////////////////tesseractclass////////////////////////////////////////

/////////////////////////////////////////////////////////////////statistc////////////////////////////////////////
#define SEED1       0x1234       //default seeds
#define SEED2       0x5678
#define SEED3       0x9abc

/**********************************************************************
 * STATS::STATS
 *
 * Construct a new stats element by allocating and zeroing the memory.
 **********************************************************************/
//constructor
STATS::STATS(inT32 min,  //min of range
             inT32 max   //max of range
            )
{

  if (max <= min)
  {
    /*		err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
            ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
            "Illegal range for stats, Min=%d, Max=%d",min,max);*/
    min = 0;
    max = 1;
  }

  rangemin = min;                //setup
  rangemax = max;
  buckets = (inT32 *) alloc_mem ((max - min) * sizeof (inT32));

  if (buckets != NULL)
  {
    this->clear ();              //zero it
  /*   else
     err.log(RESULT_NO_MEMORY,E_LOC,ERR_PRIMITIVES,
     ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
     "No memory for stats, Min=%d, Max=%d",min,max); */
  }
}


STATS::STATS()
{
  //constructor
  rangemax = 0;                  //empty
  rangemin = 0;
  buckets = NULL;
}


/**********************************************************************
 * STATS::set_range
 *
 * Alter the range on an existing stats element.
 **********************************************************************/
//constructor
bool STATS::set_range(inT32 min,  //min of range
                      inT32 max   //max of range
                     )
{

  if (max <= min)
  {
    return false;
  }

  rangemin = min;                //setup
  rangemax = max;

  if (buckets != NULL)
  {
    free_mem(buckets);  //no longer want it
  }

  buckets = (inT32 *) alloc_mem ((max - min) * sizeof (inT32));
  /*	if (buckets==NULL)
      return err.log(RESULT_NO_MEMORY,E_LOC,ERR_PRIMITIVES,
          ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
          "No memory for stats, Min=%d, Max=%d",min,max);*/

  this->clear ();                //zero it

  return true;
}


/**********************************************************************
 * STATS::clear
 *
 * Clear out the STATS class by zeroing all the buckets.
 **********************************************************************/

void STATS::clear()
{
  //clear out buckets
  total_count = 0;

  if (buckets != NULL)
  {
    memset (buckets, 0, (rangemax - rangemin) * sizeof (inT32));
  //zero it
  }
}


/**********************************************************************
 * STATS::~STATS
 *
 * Destructor for a stats class.
 **********************************************************************/
//destructor
STATS::~STATS()
{
  if (buckets != NULL)
  {
    free_mem(buckets);
    buckets = NULL;
  }
}


/**********************************************************************
 * STATS::add
 *
 * Add a set of samples to (or delete from) a pile.
 **********************************************************************/
//add sample
void STATS::add(inT32 value,  //bucket
                inT32 count   //no to add
               )
{
  if (buckets == NULL)
  {
    /*		err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
            ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
            "Empty stats");*/
    return;
  }

  if (value <= rangemin)
  {
    buckets[0] += count;         //silently clip to range
  }
  else if (value >= rangemax)
  {
    buckets[rangemax - rangemin - 1] += count;
  }
  else
  {
                                 //add count to cell
    buckets[value - rangemin] += count;
  }

  total_count += count;          //keep count of total
}


/**********************************************************************
 * STATS::mode
 *
 * Find the mode of a stats class.
 **********************************************************************/

inT32 STATS::mode()
{
  //get mode of samples
  inT32 index;                   //current index
  inT32 max;                     //max cell count
  inT32 maxindex;                //index of max

  if (buckets == NULL)
  {
    /*		err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
            ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
            "Empty stats");*/
    return rangemin;
  }

  for (max = 0, maxindex = 0, index = rangemax - rangemin - 1; index >= 0; index--)
  {
    if (buckets[index] > max)
    {
      max = buckets[index];      //find biggest
      maxindex = index;
    }
  }

  return maxindex + rangemin;    //index of biggest
}


/**********************************************************************
 * STATS::mean
 *
 * Find the mean of a stats class.
 **********************************************************************/

float STATS::mean()
{
  //get mean of samples
  inT32 index;                   //current index
  inT32 sum;                     //sum of cells

  if (buckets == NULL)
  {
    /*		err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
            ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
            "Empty stats");*/
    return (float) rangemin;
  }

  for (sum = 0, index = rangemax - rangemin - 1; index >= 0; index--)
  {
    //sum all buckets
    sum += index * buckets[index];
  }


  if (total_count > 0)//mean value
  {
    return (float) sum / total_count + rangemin;
  }
  else
  {
    return (float) rangemin;     //no mean
  }
}


/**********************************************************************
 * STATS::sd
 *
 * Find the standard deviation of a stats class.
 **********************************************************************/

float STATS::sd()
{
  //standard deviation
  inT32 index;                   //current index
  inT32 sum;                     //sum of cells
  inT32 sqsum;                   //sum of squares
  float variance;

  if (buckets == NULL)
  {
    /*     err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
       ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
       "Empty stats"); */
    return (float) 0.0;
  }

  for (sum = 0, sqsum = 0, index = rangemax - rangemin - 1; index >= 0; index--)
  {
    //sum all buckets
    sum += index * buckets[index];

    //and squares
    sqsum += index * index * buckets[index];
  }

  if (total_count > 0)
  {
    variance = sum / ((float) total_count);
    variance = sqsum / ((float) total_count) - variance * variance;

    return (float) sqrt (variance);
  }
  else
  {
    return (float) 0.0;
  }
}


/**********************************************************************
 * STATS::ile
 *
 * Find an arbitrary %ile of a stats class.
 **********************************************************************/
//percentile     //fraction to find
float STATS::ile(float frac)
{
  inT32 index;                   //current index
  inT32 sum;                     //sum of cells
  float target;                  //target value

  if (buckets == NULL)
  {
    /*     err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
       ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
       "Empty stats"); */
    return (float) rangemin;
  }

  target = frac * total_count;

  if (target <= 0)
  {
    target = (float) 1;
  }

  if (target > total_count)
  {
    target = (float) total_count;
  }

  for (sum = 0, index = 0; index < rangemax - rangemin && sum < target; sum += buckets[index], index++);
  if (index > 0)
  {
    return rangemin + index - (sum - target) / buckets[index - 1];
  //better than just ints
  }
  else
  {
    return (float) rangemin;
  }
}


/**********************************************************************
 * STATS::median
 *
 * Finds a more usefule estimate of median than ile(0.5).
 *
 * Overcomes a problem with ile() - if the samples are, for example,
 * 6,6,13,14 ile(0.5) return 7.0 - when a more useful value would be midway
 * between 6 and 13 = 9.5
 **********************************************************************/

float STATS::median()
{
  //get median
  float median;
  inT32 min_pile;
  inT32 median_pile;
  inT32 max_pile;

  if (buckets == NULL)
  {
    /*		err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
            ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
            "Empty stats");*/
    return (float) rangemin;
  }

  median = (float) ile ((float) 0.5);
  median_pile = (inT32) floor (median);

  if ((total_count > 1) && (pile_count (median_pile) == 0))
  {
    /* Find preceeding non zero pile */
    for (min_pile = median_pile; pile_count (min_pile) == 0; min_pile--);

    /* Find following non zero pile */
    for (max_pile = median_pile; pile_count (max_pile) == 0; max_pile++);

    median = (float) ((min_pile + max_pile) / 2.0);
  }

  return median;
}


/**********************************************************************
 * STATS::smooth
 *
 * Apply a triangular smoothing filter to the stats.
 * This makes the modes a bit more useful.
 * The factor gives the height of the triangle, i.e. the weight of the
 * centre.
 **********************************************************************/
//smooth samples   //size of triangle
void STATS::smooth(inT32 factor)
{
  inT32 entry;                   //bucket index
  inT32 offset;                  //from entry
  inT32 entrycount;              //no of entries
  inT32 bucket;                  //new smoothed pile

  //output stats
  STATS result(rangemin, rangemax);

  if (buckets == NULL)
  {
    /*     err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
       ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
       "Empty stats"); */
    return;
  }

  if (factor < 2) return;                      //is a no-op

  entrycount = rangemax - rangemin;

  for (entry = 0; entry < entrycount; entry++)
  {
    //centre weight
    bucket = buckets[entry] * factor;

    for (offset = 1; offset < factor; offset++)
    {
      if (entry - offset >= 0)
      {
        bucket += buckets[entry - offset] * (factor - offset);
      }

      if (entry + offset < entrycount)
      {
        bucket += buckets[entry + offset] * (factor - offset);
      }
    }

    result.add (entry + rangemin, bucket);
  }

  total_count = result.total_count;

  memcpy (buckets, result.buckets, entrycount * sizeof (inT32));
}


/**********************************************************************
 * STATS::cluster
 *
 * Cluster the samples into max_cluster clusters.
 * Each call runs one iteration. The array of clusters must be
 * max_clusters+1 in size as cluster 0 is used to indicate which samples
 * have been used.
 * The return value is the current number of clusters.
 **********************************************************************/

inT32 STATS::cluster(                     //cluster samples
                     float lower,         //thresholds
                     float upper,
                     float multiple,      //distance threshold
                     inT32 max_clusters,  //max no to make
                     STATS *clusters      //array of clusters
                    )
{
  BOOL8 new_cluster;             //added one
  float *centres;                //cluster centres
  inT32 entry;                   //bucket index
  inT32 cluster;                 //cluster index
  inT32 best_cluster;            //one to assign to
  inT32 new_centre = 0;          //residual mode
  inT32 new_mode;                //pile count of new_centre
  inT32 count;                   //pile to place
  float dist;                    //from cluster
  float min_dist;                //from best_cluster
  inT32 cluster_count;           //no of clusters

  if (max_clusters < 1) return 0;

  if (buckets == NULL)
  {
    /*		err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
            ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
            "Empty stats");*/
    return 0;
  }

  centres = (float *) alloc_mem ((max_clusters + 1) * sizeof (float));

  if (centres == NULL)
  {
    /*     err.log(RESULT_NO_MEMORY,E_LOC,ERR_PRIMITIVES,
       ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
       "No memory for centres"); */
    return 0;
  }

  for (cluster_count = 1; cluster_count <= max_clusters &&
       clusters[cluster_count].buckets != NULL && clusters[cluster_count].total_count > 0; cluster_count++)
  {
    centres[cluster_count] = (float) clusters[cluster_count].ile ((float) 0.5);
    new_centre = clusters[cluster_count].mode ();
    for (entry = new_centre - 1; centres[cluster_count] - entry < lower &&
         entry >= rangemin && pile_count (entry) <= pile_count (entry + 1); entry--)
    {
      count = pile_count (entry) - clusters[0].pile_count (entry);
      if (count > 0)
      {
        clusters[cluster_count].add (entry, count);
        clusters[0].add (entry, count);
      }
    }

    for (entry = new_centre + 1; entry - centres[cluster_count] < lower && entry < rangemax &&
         pile_count (entry) <= pile_count (entry - 1); entry++)
    {
      count = pile_count (entry) - clusters[0].pile_count (entry);

      if (count > 0)
      {
        clusters[cluster_count].add (entry, count);
        clusters[0].add (entry, count);
      }
    }
  }
  cluster_count--;

  if (cluster_count == 0)
  {
    clusters[0].set_range (rangemin, rangemax);
  }

  do
  {
    new_cluster = FALSE;
    new_mode = 0;

    for (entry = 0; entry < rangemax - rangemin; entry++)
    {
      count = buckets[entry] - clusters[0].buckets[entry];

      //remaining pile
      if (count > 0)
      {           //any to handle
        min_dist = (float) MAX_INT32;
        best_cluster = 0;

        for (cluster = 1; cluster <= cluster_count; cluster++)
        {
          dist = entry + rangemin - centres[cluster];

          //find distance
          if (dist < 0)
          {
            dist = -dist;
          }

          if (dist < min_dist)
          {
            min_dist = dist;     //find least
            best_cluster = cluster;
          }
        }

        //far enough for new
        if (min_dist > upper &&(best_cluster == 0 || entry + rangemin > centres[best_cluster] * multiple ||
                                entry + rangemin < centres[best_cluster] / multiple))
        {
          if (count > new_mode)
          {
            new_mode = count;
            new_centre = entry + rangemin;
          }
        }
      }
    }

    //need new and room
    if (new_mode > 0 && cluster_count < max_clusters)
    {
      cluster_count++;
      new_cluster = TRUE;

      if (!clusters[cluster_count].set_range (rangemin, rangemax)) return 0;

      centres[cluster_count] = (float) new_centre;
      clusters[cluster_count].add (new_centre, new_mode);
      clusters[0].add (new_centre, new_mode);

      for (entry = new_centre - 1; centres[cluster_count] - entry < lower && entry >= rangemin &&
           pile_count (entry) <= pile_count (entry + 1); entry--)
      {
        count = pile_count (entry) - clusters[0].pile_count (entry);

        if (count > 0)
        {
          clusters[cluster_count].add (entry, count);
          clusters[0].add (entry, count);
        }
      }

      for (entry = new_centre + 1; entry - centres[cluster_count] < lower &&
           entry < rangemax && pile_count (entry) <= pile_count (entry - 1); entry++)
      {
        count = pile_count (entry) - clusters[0].pile_count (entry);

        if (count > 0)
        {
          clusters[cluster_count].add (entry, count);
          clusters[0].add (entry, count);
        }
      }

      centres[cluster_count] = (float) clusters[cluster_count].ile ((float) 0.5);
    }
  }
  while (new_cluster && cluster_count < max_clusters);

  free_mem(centres);

  return cluster_count;
}


/**********************************************************************
 * STATS::local_min
 *
 * Return TRUE if this point is a local min.
 **********************************************************************/
//test minness         //of x
BOOL8 STATS::local_min(inT32 x)
{
  inT32 index;                   //table index

  if (buckets == NULL)
  {
    /*		err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
            ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
            "Empty stats");*/
    return FALSE;
  }

  if (x < rangemin)
  {
    x = rangemin;
  }

  if (x >= rangemax)
  {
    x = rangemax - 1;
  }

  x -= rangemin;

  if (buckets[x] == 0)
  {
    return TRUE;
  }

  for (index = x - 1; index >= 0 && buckets[index] == buckets[x]; index--);

  if (index >= 0 && buckets[index] < buckets[x])
  {
    return FALSE;
  }

  for (index = x + 1; index < rangemax - rangemin && buckets[index] == buckets[x]; index++);

  if (index < rangemax - rangemin && buckets[index] < buckets[x])
  {
    return FALSE;
  }
  else
  {
    return TRUE;
  }
}


/**********************************************************************
 * STATS::print
 *
 * Print a summary of the stats and optionally a dump of the table.
 **********************************************************************/

void STATS::print(            //print stats table
                  FILE *,     //Now uses tprintf instead
                  BOOL8 dump  //dump full table
                 )
{
  inT32 index;                   //table index

  if (buckets == NULL)
  {
    /*     err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
       ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
       "Empty stats"); */
    return;
  }

  if (dump)
  {
    for (index = 0; index < rangemax - rangemin; index++)
    {
      tprintf ("%4d:%-3d ", rangemin + index, buckets[index]);

      if (index % 8 == 7) tprintf ("\n");
    }

    tprintf ("\n");
  }

  tprintf("Total count=%d\n", total_count);
  tprintf("Min=%d\n", (inT32) (ile((float) 0.0)));
  tprintf("Lower quartile=%.2f\n", ile((float) 0.25));
  tprintf("Median=%.2f\n", ile((float) 0.5));
  tprintf("Upper quartile=%.2f\n", ile((float) 0.75));
  tprintf("Max=%d\n", (inT32)(ile((float)0.99999)));
  tprintf("Mean= %.2f\n", mean());
  tprintf("SD= %.2f\n", sd());
}


/**********************************************************************
 * STATS::min_bucket
 *
 * Find REAL minimum bucket - ile(0.0) isnt necessarily correct
 **********************************************************************/

inT32 STATS::min_bucket()
{
  //Find min
  inT32 min;

  if (buckets == NULL)
  {
    /*		err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
            ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
            "Empty stats");*/
    return rangemin;
  }

  for (min = 0; (min < rangemax - rangemin) && (buckets[min] == 0); min++);

  return rangemin + min;
}


/**********************************************************************
 * STATS::max_bucket
 *
 * Find REAL maximum bucket - ile(1.0) isnt necessarily correct
 **********************************************************************/

inT32 STATS::max_bucket()
{
  //Find max
  inT32 max;

  if (buckets == NULL)
  {
    /*		err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
            ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
            "Empty stats");*/
    return rangemin;
  }

  for (max = rangemax - rangemin - 1; (max > 0) && (buckets[max] == 0); max--);

  return rangemin + max;
}


/**********************************************************************
 * STATS::short_print
 *
 * Print a summary of the stats and optionally a dump of the table.
 * ( BUT ONLY THE PART OF THE TABLE BETWEEN MIN AND MAX)
 **********************************************************************/

void STATS::short_print(            //print stats table
                        FILE *,     //Now uses tprintf instead
                        BOOL8 dump  //dump full table
                       )
{
  inT32 index;                   //table index
  inT32 min = min_bucket ();
  inT32 max = max_bucket ();

  if (buckets == NULL)
  {
    /*     err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
       ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
       "Empty stats"); */
    return;
  }

  if (dump)
  {
    for (index = min; index <= max; index++)
    {
      tprintf ("%4d:%-3d ", rangemin + index, buckets[index]);

      if ((index - min) % 8 == 7) tprintf ("\n");
    }

    tprintf ("\n");
  }

  tprintf("Total count=%d\n", total_count);
  tprintf("Min=%d Really=%d\n", (inT32)(ile ((float)0.0)), min);
  tprintf("Max=%d Really=%d\n", (inT32)(ile ((float)1.1)), max);
  tprintf("Range=%d\n", max + 1 - min);
  tprintf("Lower quartile=%.2f\n", ile((float)0.25));
  tprintf("Median=%.2f\n", ile((float) 0.5));
  tprintf("Upper quartile=%.2f\n", ile((float)0.75));
  tprintf("Mean= %.2f\n", mean());
  tprintf("SD= %.2f\n", sd());
}


/**********************************************************************
 * STATS::plot
 *
 * Draw a histogram of the stats table.
 **********************************************************************/

#ifndef GRAPHICS_DISABLED
void STATS::plot(                //plot stats table
                 ScrollView* window,  //to draw in
                 float xorigin,  //bottom left
                 float yorigin,
                 float xscale,   //one x unit
                 float yscale,   //one y unit
                 ScrollView::Color colour   //colour to draw in
                )
{
  inT32 index;                   //table index

  if (buckets == NULL)
  {
    /*		err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
            ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
            "Empty stats");*/
    return;
  }

  window->Pen(colour);

  for (index = 0; index < rangemax - rangemin; index++)
  {
    window->Rectangle( xorigin + xscale * index, yorigin, xorigin + xscale * (index + 1), yorigin + yscale * buckets[index]);
  }
}
#endif


/**********************************************************************
 * STATS::plotline
 *
 * Draw a histogram of the stats table. (Line only
 **********************************************************************/

#ifndef GRAPHICS_DISABLED
void STATS::plotline(                //plot stats table
                     ScrollView* window,  //to draw in
                     float xorigin,  //bottom left
                     float yorigin,
                     float xscale,   //one x unit
                     float yscale,   //one y unit
                     ScrollView::Color colour   //colour to draw in
                    )
{
  inT32 index;                   //table index

  if (buckets == NULL)
  {
    /*     err.log(RESULT_LOGICAL_ERROR,E_LOC,ERR_PRIMITIVES,
       ERR_SCROLLING,ERR_CONTINUE,ERR_ERROR,
       "Empty stats"); */
    return;
  }
  window->Pen(colour);

  window->SetCursor(xorigin, yorigin + yscale * buckets[0]);

  for (index = 0; index < rangemax - rangemin; index++)
  {
    window->DrawTo(xorigin + xscale * index, yorigin + yscale * buckets[index]);
  }
}
#endif


/**********************************************************************
 * choose_nth_item
 *
 * Returns the index of what would b the nth item in the array
 * if the members were sorted, without actually sorting.
 **********************************************************************/

inT32 choose_nth_item(               //fast median
                             inT32 index,   //index to choose
                             float *array,  //array of items
                             inT32 count    //no of items
                            )
{
  static uinT16 seeds[3] = { SEED1, SEED2, SEED3 };

  //for nrand
  inT32 next_sample;             //next one to do
  inT32 next_lesser;             //space for new
  inT32 prev_greater;            //last one saved
  inT32 equal_count;             //no of equal ones
  float pivot;                   //proposed median
  float sample;                  //current sample

  if (count <= 1) return 0;

  if (count == 2)
  {
    if (array[0] < array[1])
    {
      return index >= 1 ? 1 : 0;
    }
    else
    {
      return index >= 1 ? 0 : 1;
    }
  }
  else
  {
    if (index < 0)
    {
      index = 0;                 //ensure lergal
    }
    else if (index >= count)
    {
      index = count - 1;
    }

    #ifdef __UNIX__
    equal_count = (inT32) (nrand48(seeds) % count);
    #else
    equal_count = (inT32) (rand () % count);
    #endif
    pivot = array[equal_count];

    //fill gap
    array[equal_count] = array[0];
    next_lesser = 0;
    prev_greater = count;
    equal_count = 1;

    for (next_sample = 1; next_sample < prev_greater;)
    {
      sample = array[next_sample];
      if (sample < pivot)
      {
        //shuffle
        array[next_lesser++] = sample;
        next_sample++;
      }
      else if (sample > pivot)
      {
        prev_greater--;

        //juggle
        array[next_sample] = array[prev_greater];
        array[prev_greater] = sample;
      }
      else
      {
        equal_count++;
        next_sample++;
      }
    }

    for (next_sample = next_lesser; next_sample < prev_greater;)
    {
      array[next_sample++] = pivot;
    }

    if (index < next_lesser)
    {
      return choose_nth_item (index, array, next_lesser);
    }
    else if (index < prev_greater)
    {
      return next_lesser;        //in equal bracket
    }
    else
    {
      return choose_nth_item (index - prev_greater, array + prev_greater, count - prev_greater) + prev_greater;
    }
  }
}


/**********************************************************************
 * choose_nth_item
 *
 * Returns the index of what would b the nth item in the array
 * if the members were sorted, without actually sorting.
 **********************************************************************/

inT32 choose_nth_item (                //fast median
inT32 index,                     //index to choose
void *array,                     //array of items
inT32 count,                     //no of items
size_t size,                     //element size
                                 //comparator
int (*compar) (const void *, const void *)
)
{
  static uinT16 seeds[3] = { SEED1, SEED2, SEED3 };

  //for nrand
  int result;                    //of compar
  inT32 next_sample;             //next one to do
  inT32 next_lesser;             //space for new
  inT32 prev_greater;            //last one saved
  inT32 equal_count;             //no of equal ones
  inT32 pivot;                   //proposed median

  if (count <= 1)
  {
    return 0;
  }

  if (count == 2)
  {
    if (compar (array, (char *) array + size) < 0)
    {
      return index >= 1 ? 1 : 0;
    }
    else
    {
      return index >= 1 ? 0 : 1;
    }
  }

  if (index < 0)
  {
    index = 0;                   //ensure lergal
  }
  else if (index >= count)
  {
    index = count - 1;
  }

  #ifdef __UNIX__
  pivot = (inT32) (nrand48 (seeds) % count);
  #else
  pivot = (inT32) (rand () % count);
  #endif
  swap_entries (array, size, pivot, 0);
  next_lesser = 0;
  prev_greater = count;
  equal_count = 1;

  for (next_sample = 1; next_sample < prev_greater;)
  {
    result = compar ((char *)array + size * next_sample, (char *)array + size * next_lesser);

    if (result < 0)
    {
      swap_entries (array, size, next_lesser++, next_sample++);
      //shuffle
    }
    else if (result > 0)
    {
      prev_greater--;
      swap_entries(array, size, prev_greater, next_sample);
    }
    else
    {
      equal_count++;
      next_sample++;
    }
  }

  if (index < next_lesser)
  {
    return choose_nth_item (index, array, next_lesser, size, compar);
  }
  else if (index < prev_greater)
  {
    return next_lesser;          //in equal bracket
  }
  else
    return choose_nth_item(index - prev_greater, (char *)array + size * prev_greater,
                           count - prev_greater, size, compar) + prev_greater;
}


/**********************************************************************
 * swap_entries
 *
 * Swap 2 entries of abitrary size in-place in a table.
 **********************************************************************/

void swap_entries(               //swap in place
                  void *array,   //array of entries
                  size_t size,   //size of entry
                  inT32 index1,  //entries to swap
                  inT32 index2)
{
  char tmp;
  char *ptr1;                    //to entries
  char *ptr2;
  size_t count;                  //of bytes

  ptr1 = (char *) array + index1 * size;
  ptr2 = (char *) array + index2 * size;

  for (count = 0; count < size; count++)
  {
    tmp = *ptr1;
    *ptr1++ = *ptr2;
    *ptr2++ = tmp;               //tedious!
  }
}
/////////////////////////////////////////////////////////////////statistc////////////////////////////////////////

/////////////////////////////////////////////////////////////////gradechop////////////////////////////////////////
/*----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------*/
#define CENTER_GRADE_CAP 25.0

/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
/**********************************************************************
 * find_bounds_loop
 *
 * This is a macro to be used by set_outline_bounds.
 **********************************************************************/

#define find_bounds_loop(point1,point2,x_min,x_max)     \
    x_min = point2->pos.x;                               \
    x_max = point2->pos.x;                               \
                                                                        \
    this_point = point1;                                 \
    do {                                                 \
        x_min = MIN (this_point->pos.x, x_min);           \
        x_max = MAX (this_point->pos.x, x_max);           \
        this_point = this_point->next;                    \
    }                                                    \
    while (this_point != point2 && this_point != point1) \


/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**********************************************************************
 * full_split_priority
 *
 * Assign a priority to this split based on the features that it has.
 * Part of the priority has already been calculated so just return the
 * additional amount for the bounding box type information.
 **********************************************************************/
PRIORITY full_split_priority(SPLIT *split, inT16 xmin, inT16 xmax) {
  BOUNDS_RECT rect;

  set_outline_bounds (split->point1, split->point2, rect);

  if (xmin < MIN (rect[0], rect[2]) && xmax > MAX (rect[1], rect[3]))
    return (999.0);

  return (grade_overlap (rect) +
    grade_center_of_blob (rect) + grade_width_change (rect));
}


/**********************************************************************
 * grade_center_of_blob
 *
 * Return a grade for the a split.  Rank it on closeness to the center
 * of the original blob
 *   0    =  "perfect"
 *   100  =  "no way jay"
 **********************************************************************/
PRIORITY grade_center_of_blob(register BOUNDS_RECT rect) {
  register PRIORITY grade;

  grade = (rect[1] - rect[0]) - (rect[3] - rect[2]);
  if (grade < 0)
    grade = -grade;

  grade *= chop_center_knob;
  grade = MIN (CENTER_GRADE_CAP, grade);
  return (MAX (0.0, grade));
}


/**********************************************************************
 * grade_overlap
 *
 * Return a grade for this split for the overlap of the resultant blobs.
 *   0    =  "perfect"
 *   100  =  "no way jay"
 **********************************************************************/
PRIORITY grade_overlap(register BOUNDS_RECT rect) {
  register PRIORITY grade;
  register inT16 width1;
  register inT16 width2;
  register inT16 overlap;

  width1 = rect[3] - rect[2];
  width2 = rect[1] - rect[0];

  overlap = MIN (rect[1], rect[3]) - MAX (rect[0], rect[2]);
  width1 = MIN (width1, width2);
  if (overlap == width1)
    return (100.0);              /* Total overlap */

  width1 = 2 * overlap - width1; /* Extra penalty for too */
  overlap += MAX (0, width1);    /* much overlap */

  grade = overlap * chop_overlap_knob;

  return (MAX (0.0, grade));
}


/**********************************************************************
 * grade_split_length
 *
 * Return a grade for the length of this split.
 *   0    =  "perfect"
 *   100  =  "no way jay"
 **********************************************************************/
PRIORITY grade_split_length(register SPLIT *split) {
  register PRIORITY grade;
  register float split_length;

  split_length = weighted_edgept_dist (split->point1, split->point2,
    chop_x_y_weight);

  if (split_length <= 0)
    grade = 0;
  else
    grade = sqrt (split_length) * chop_split_dist_knob;

  return (MAX (0.0, grade));
}


/**********************************************************************
 * grade_sharpness
 *
 * Return a grade for the sharpness of this split.
 *   0    =  "perfect"
 *   100  =  "no way jay"
 **********************************************************************/
PRIORITY grade_sharpness(register SPLIT *split) {
  register PRIORITY grade;

  grade = point_priority (split->point1) + point_priority (split->point2);

  if (grade < -360.0)
    grade = 0;
  else
    grade += 360.0;

  grade *= chop_sharpness_knob;       /* Values 0 to -360 */

  return (grade);
}


/**********************************************************************
 * grade_width_change
 *
 * Return a grade for the change in width of the resultant blobs.
 *   0    =  "perfect"
 *   100  =  "no way jay"
 **********************************************************************/
PRIORITY grade_width_change(register BOUNDS_RECT rect) {
  register PRIORITY grade;
  register inT32 width1;
  register inT32 width2;

  width1 = rect[3] - rect[2];
  width2 = rect[1] - rect[0];

  grade = 20 - (MAX (rect[1], rect[3])
    - MIN (rect[0], rect[2]) - MAX (width1, width2));

  grade *= chop_width_change_knob;

  return (MAX (0.0, grade));
}


/**********************************************************************
 * set_outline_bounds
 *
 * Set up the limits for the x coordinate of the outline.
 **********************************************************************/
void set_outline_bounds(register EDGEPT *point1,
                        register EDGEPT *point2,
                        BOUNDS_RECT rect) {
  register EDGEPT *this_point;
  register inT16 x_min;
  register inT16 x_max;

  find_bounds_loop(point1, point2, x_min, x_max);

  rect[0] = x_min;
  rect[1] = x_max;

  find_bounds_loop(point2, point1, x_min, x_max);

  rect[2] = x_min;
  rect[3] = x_max;
}
/////////////////////////////////////////////////////////////////gradechop////////////////////////////////////////

/////////////////////////////////////////////////////////////////findseam////////////////////////////////////////
/*----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------*/
#define SPLIT_CLOSENESS        20/* Difference in x value */
                                 /* How many to keep */
#define MAX_NUM_SEAMS          150
                                 /* How many to keep */
#define MAX_OLD_SEAMS          150
#define NO_FULL_PRIORITY       -1/* Special marker for pri. */
                                 /* Evalute right away */
#define BAD_PRIORITY           9999.0

/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
/**********************************************************************
 * add_seam_to_queue
 *
 * Add this seam value to the seam queue.  If the heap is already full
 * then nothing is done.
 **********************************************************************/

#define add_seam_to_queue(seams,seam,priority)  \
if (seam)\
{\
        if (HeapFull(seams))\
            junk_worst_seam(seams,seam,priority);\
        else\
            HeapPush (seams, priority, (char*) seam);\
    }

/**********************************************************************
 * best_seam_priority
 *
 * Return the best priority value on the queue.
 **********************************************************************/

#define best_seam_priority(seam_queue)   \
(HeapEmpty (seam_queue) ?              \
    NO_FULL_PRIORITY       :              \
    ((SEAM*) seam_queue_element(seam_queue, 0))->priority)

/**********************************************************************
 * create_seam_queue
 *
 * Create a new seam queue with no elements in it.
 **********************************************************************/

#define create_seam_queue(seam_queue)     \
(seam_queue = MakeHeap (MAX_NUM_SEAMS))

/**********************************************************************
 * create_seam_pile
 *
 * Create a new seam pile with no elements in it.
 **********************************************************************/

#define create_seam_pile(seam_pile)     \
(seam_pile = array_new (MAX_OLD_SEAMS))

/**********************************************************************
 * delete_seam_queue
 *
 * Delete a seam queue along with all the seam structures associated
 * with it.
 **********************************************************************/

#define delete_seam_queue(seam_queue)      \
(FreeHeapData (seam_queue, delete_seam), \
    seam_queue = NULL)                      \


/**********************************************************************
 * pop_next_seam
 *
 * Remove the next seam from the queue.  Put the seam and priority
 * values in the requested variables.  If there was nothing to pop
 * then return FALSE, else return TRUE.
 **********************************************************************/

#define pop_next_seam(seams,seam,priority)  \
(HeapPop (seams,&priority,&seam) == OK)   \


/**********************************************************************
 * seam_queue_element
 *
 * Return the element from the seam queue at the requested index.
 **********************************************************************/

#define seam_queue_element(seam_queue,index)  \
((index < SizeOfHeap (seam_queue)) ?        \
    HeapDataFor (seam_queue, index)   :        \
    NULL)                                      \


/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**********************************************************************
 * junk_worst_seam
 *
 * Delete the worst seam from the queue because it is full.
 **********************************************************************/
void junk_worst_seam(SEAM_QUEUE seams, SEAM *new_seam, float new_priority) {
  SEAM *seam;
  float priority;

  HeapPopWorst(seams, &priority, &seam);
  if (priority > new_priority) {
    delete_seam(seam);  /*get rid of it */
    HeapPush (seams, new_priority, (char *) new_seam);
  }
  else {
    delete_seam(new_seam);
    HeapPush (seams, priority, (char *) seam);
  }
}


/**********************************************************************
 * choose_best_seam
 *
 * Choose the best seam that can be created by assembling this a
 * collection of splits.  A queue of all the possible seams is
 * maintained.  Each new split received is placed in that queue with
 * its partial priority value.  These values in the seam queue are
 * evaluated and combined until a good enough seam is found.  If no
 * further good seams are being found then this function returns to the
 * caller, who will send more splits.  If this function is called with
 * a split of NULL, then no further splits can be supplied by the
 * caller.
 **********************************************************************/
void choose_best_seam(SEAM_QUEUE seam_queue,
                      SEAM_PILE *seam_pile,
                      SPLIT *split,
                      PRIORITY priority,
                      SEAM **seam_result,
                      TBLOB *blob) {
  SEAM *seam;
  TPOINT topleft;
  TPOINT botright;
  char str[80];
  float my_priority;
  /* Add seam of split */
  my_priority = priority;
  if (split != NULL) {
    seam = new_seam (my_priority,
      (split->point1->pos.x + split->point1->pos.x) / 2,
      split, NULL, NULL);
    if (chop_debug > 1)
      print_seam ("Partial priority    ", seam);
    add_seam_to_queue (seam_queue, seam, (float) my_priority);

    if (my_priority > chop_good_split)
      return;
  }

  blob_bounding_box(blob, &topleft, &botright);
  /* Queue loop */
  while (pop_next_seam (seam_queue, seam, my_priority)) {
    /* Set full priority */
    my_priority = seam_priority (seam, topleft.x, botright.x);
    if (chop_debug) {
      sprintf (str, "Full my_priority %0.0f,  ", my_priority);
      print_seam(str, seam);
    }

    if ((*seam_result == NULL || /* Replace answer */
    (*seam_result)->priority > my_priority) && my_priority < chop_ok_split) {
      /* No crossing */
      if (constrained_split (seam->split1, blob)) {
        delete_seam(*seam_result);
        clone_seam(*seam_result, seam);
        (*seam_result)->priority = my_priority;
      }
      else {
        delete_seam(seam);
        seam = NULL;
        my_priority = BAD_PRIORITY;
      }
    }

    if (my_priority < chop_good_split) {
      if (seam)
        delete_seam(seam);
      return;                    /* Made good answer */
    }

    if (seam) {
                                 /* Combine with others */
      if (array_count (*seam_pile) < MAX_NUM_SEAMS
      /*|| tessedit_truncate_chopper==0 */ ) {
        combine_seam(seam_queue, *seam_pile, seam);
        *seam_pile = array_push (*seam_pile, seam);
      }
      else
        delete_seam(seam);
    }

    my_priority = best_seam_priority (seam_queue);
    if ((my_priority > chop_ok_split) ||
      (my_priority > chop_good_split && split))
      return;
  }
}


/**********************************************************************
 * combine_seam
 *
 * Find other seams to combine with this one.  The new seams that result
 * from this union should be added to the seam queue.  The return value
 * tells whether or not any additional seams were added to the queue.
 **********************************************************************/
void combine_seam(SEAM_QUEUE seam_queue, SEAM_PILE seam_pile, SEAM *seam) {
  register inT16 x;
  register inT16 dist;
  inT16 bottom1, top1;
  inT16 bottom2, top2;

  SEAM *new_one;
  SEAM *this_one;

  bottom1 = seam->split1->point1->pos.y;
  if (seam->split1->point2->pos.y >= bottom1)
    top1 = seam->split1->point2->pos.y;
  else {
    top1 = bottom1;
    bottom1 = seam->split1->point2->pos.y;
  }
  if (seam->split2 != NULL) {
    bottom2 = seam->split2->point1->pos.y;
    if (seam->split2->point2->pos.y >= bottom2)
      top2 = seam->split2->point2->pos.y;
    else {
      top2 = bottom2;
      bottom2 = seam->split2->point2->pos.y;
    }
  }
  else {
    bottom2 = bottom1;
    top2 = top1;
  }
  array_loop(seam_pile, x) {
    this_one = (SEAM *) array_value (seam_pile, x);
    dist = seam->location - this_one->location;
    if (-SPLIT_CLOSENESS < dist &&
      dist < SPLIT_CLOSENESS &&
    seam->priority + this_one->priority < chop_ok_split) {
      inT16 split1_point1_y = this_one->split1->point1->pos.y;
      inT16 split1_point2_y = this_one->split1->point2->pos.y;
      inT16 split2_point1_y = 0;
      inT16 split2_point2_y = 0;
      if (this_one->split2) {
        split2_point1_y = this_one->split2->point1->pos.y;
        split2_point2_y = this_one->split2->point2->pos.y;
      }
      if (
        /*!tessedit_fix_sideways_chops || */
        (
          /* this_one->split1 always exists */
          (
            ((split1_point1_y >= top1 && split1_point2_y >= top1) ||
             (split1_point1_y <= bottom1 && split1_point2_y <= bottom1))
            &&
            ((split1_point1_y >= top2 && split1_point2_y >= top2) ||
             (split1_point1_y <= bottom2 && split1_point2_y <= bottom2))
          )
        )
        &&
        (
          this_one->split2 == NULL ||
          (
            ((split2_point1_y >= top1 && split2_point2_y >= top1) ||
             (split2_point1_y <= bottom1 && split2_point2_y <= bottom1))
            &&
            ((split2_point1_y >= top2 && split2_point2_y >= top2) ||
             (split2_point1_y <= bottom2 && split2_point2_y <= bottom2))
          )
        )
      ) {
        new_one = join_two_seams (seam, this_one);
        if (chop_debug > 1)
          print_seam ("Combo priority       ", new_one);
        add_seam_to_queue (seam_queue, new_one, new_one->priority);
      }
    }
  }
}


/**********************************************************************
 * constrained_split
 *
 * Constrain this split to obey certain rules.  It must not cross any
 * inner outline.  It must not cut off a small chunk of the outline.
 **********************************************************************/
inT16 constrained_split(SPLIT *split, TBLOB *blob) {
  TESSLINE *outline;

  if (is_little_chunk (split->point1, split->point2))
    return (FALSE);

  for (outline = blob->outlines; outline; outline = outline->next) {
    if (split_bounds_overlap (split, outline) &&
    crosses_outline (split->point1, split->point2, outline->loop)) {
      return (FALSE);
    }
  }
  return (TRUE);
}


/**********************************************************************
 * delete_seam_pile
 *
 * Delete the seams that are held in the seam pile.  Destroy the splits
 * that are referenced by these seams.
 **********************************************************************/
void delete_seam_pile(SEAM_PILE seam_pile) {
  inT16 x;

  array_loop(seam_pile, x) {
    delete_seam ((SEAM *) array_value (seam_pile, x));
  }
  array_free(seam_pile);
}


/**********************************************************************
 * pick_good_seam
 *
 * Find and return a good seam that will split this blob into two pieces.
 * Work from the outlines provided.
 **********************************************************************/
SEAM *pick_good_seam(TBLOB *blob) {
  SEAM_QUEUE seam_queue;
  SEAM_PILE seam_pile;
  POINT_GROUP point_heap;
  PRIORITY priority;
  EDGEPT *edge;
  EDGEPT *points[MAX_NUM_POINTS];
  SEAM *seam = NULL;
  TESSLINE *outline;
  inT16 num_points = 0;

#ifndef GRAPHICS_DISABLED
  if (chop_debug > 2)
    wordrec_display_splits.set_value(true);

  draw_blob_edges(blob);
#endif

  point_heap = MakeHeap (MAX_NUM_POINTS);
  for (outline = blob->outlines; outline; outline = outline->next)
    prioritize_points(outline, point_heap);

  while (HeapPop (point_heap, &priority, &edge) == OK) {
    if (num_points < MAX_NUM_POINTS)
      points[num_points++] = (EDGEPT *) edge;
  }
  FreeHeap(point_heap);

  /* Initialize queue & pile */
  create_seam_pile(seam_pile);
  create_seam_queue(seam_queue);

  try_point_pairs(points, num_points, seam_queue, &seam_pile, &seam, blob);

  try_vertical_splits(points, num_points, seam_queue, &seam_pile, &seam, blob);

  if (seam == NULL) {
    choose_best_seam(seam_queue, &seam_pile, NULL, BAD_PRIORITY, &seam, blob);
  }
  else if (seam->priority > chop_good_split) {
    choose_best_seam (seam_queue, &seam_pile, NULL, seam->priority,
      &seam, blob);
  }
  delete_seam_queue(seam_queue);
  delete_seam_pile(seam_pile);

  if (seam) {
    if (seam->priority > chop_ok_split) {
      delete_seam(seam);
      seam = NULL;
    }
#ifndef GRAPHICS_DISABLED
    else if (wordrec_display_splits) {
      if (seam->split1)
        mark_split (seam->split1);
      if (seam->split2)
        mark_split (seam->split2);
      if (seam->split3)
        mark_split (seam->split3);
      if (chop_debug > 2) {
        update_edge_window();
        edge_window_wait();
      }
    }
#endif
  }

  if (chop_debug)
    wordrec_display_splits.set_value(false);

  return (seam);
}


/**********************************************************************
 * seam_priority
 *
 * Assign a full priority value to the seam.
 **********************************************************************/
PRIORITY seam_priority(SEAM *seam, inT16 xmin, inT16 xmax) {
  PRIORITY priority;

  if (seam->split1 == NULL)
    priority = 0;

  else if (seam->split2 == NULL) {
    priority = (seam->priority +
      full_split_priority (seam->split1, xmin, xmax));
  }

  else if (seam->split3 == NULL) {
    split_outline (seam->split2->point1, seam->split2->point2);
    priority = (seam->priority +
      full_split_priority (seam->split1, xmin, xmax));
    unsplit_outlines (seam->split2->point1, seam->split2->point2);
  }

  else {
    split_outline (seam->split2->point1, seam->split2->point2);
    split_outline (seam->split3->point1, seam->split3->point2);
    priority = (seam->priority +
      full_split_priority (seam->split1, xmin, xmax));
    unsplit_outlines (seam->split3->point1, seam->split3->point2);
    unsplit_outlines (seam->split2->point1, seam->split2->point2);
  }

  return (priority);
}


/**********************************************************************
 * try_point_pairs
 *
 * Try all the splits that are produced by pairing critical points
 * together.  See if any of them are suitable for use.  Use a seam
 * queue and seam pile that have already been initialized and used.
 **********************************************************************/
void
try_point_pairs (EDGEPT * points[MAX_NUM_POINTS],
inT16 num_points,
SEAM_QUEUE seam_queue,
SEAM_PILE * seam_pile, SEAM ** seam, TBLOB * blob) {
  inT16 x;
  inT16 y;
  SPLIT *split;
  PRIORITY priority;

  for (x = 0; x < num_points; x++) {
    for (y = x + 1; y < num_points; y++) {

      if (points[y] &&
          weighted_edgept_dist(points[x], points[y],
                               chop_x_y_weight) < chop_split_length &&
          points[x] != points[y]->next &&
          points[y] != points[x]->next &&
          !is_exterior_point(points[x], points[y]) &&
          !is_exterior_point(points[y], points[x])) {
        split = new_split (points[x], points[y]);
        priority = partial_split_priority (split);

        choose_best_seam(seam_queue, seam_pile, split, priority, seam, blob);

        if (*seam && (*seam)->priority < chop_good_split)
          return;
      }
    }
  }

}


/**********************************************************************
 * try_vertical_splits
 *
 * Try all the splits that are produced by vertical projection to see
 * if any of them are suitable for use.  Use a seam queue and seam pile
 * that have already been initialized and used.
 **********************************************************************/
void
try_vertical_splits (EDGEPT * points[MAX_NUM_POINTS],
inT16 num_points,
SEAM_QUEUE seam_queue,
SEAM_PILE * seam_pile, SEAM ** seam, TBLOB * blob) {
  EDGEPT *vertical_point = NULL;
  SPLIT *split;
  inT16 x;
  PRIORITY priority;
  TESSLINE *outline;

  for (x = 0; x < num_points; x++) {

    if (*seam != NULL && (*seam)->priority < chop_good_split)
      return;

    vertical_point = NULL;
    for (outline = blob->outlines; outline; outline = outline->next) {
      vertical_projection_point (points[x],
        outline->loop, &vertical_point);
    }

    if (vertical_point &&
      points[x] != vertical_point->next &&
      vertical_point != points[x]->next &&
      weighted_edgept_dist(points[x], vertical_point,
                           chop_x_y_weight) < chop_split_length) {

      split = new_split (points[x], vertical_point);
      priority = partial_split_priority (split);

      choose_best_seam(seam_queue, seam_pile, split, priority, seam, blob);
    }
  }
}
/////////////////////////////////////////////////////////////////findseam////////////////////////////////////////

/////////////////////////////////////////////////////////////////makechop////////////////////////////////////////
/*----------------------------------------------------------------------
        Public Function Code
----------------------------------------------------------------------*/
/**********************************************************************
 * apply_seam
 *
 * Split this blob into two blobs by applying the splits included in
 * the seam description.
 **********************************************************************/
void apply_seam(TBLOB *blob, TBLOB *other_blob, SEAM *seam) {
  check_outline_mem();
  if (seam->split1 == NULL) {
    divide_blobs (blob, other_blob, seam->location);
  }
  else if (seam->split2 == NULL) {
    make_split_blobs(blob, other_blob, seam);
  }
  else if (seam->split3 == NULL) {
    make_double_split(blob, other_blob, seam);
  }
  else {
    make_triple_split(blob, other_blob, seam);
  }

  check_outline_mem();
}


/**********************************************************************
 * divide_blobs
 *
 * Create two blobs by grouping the outlines in the appropriate blob.
 * The outlines that are beyond the location point are moved to the
 * other blob.  The ones whose x location is less than that point are
 * retained in the original blob.
 **********************************************************************/
void divide_blobs(TBLOB *blob, TBLOB *other_blob, inT32 location) {
  TESSLINE *outline;
  TESSLINE *outline1 = NULL;
  TESSLINE *outline2 = NULL;

  outline = blob->outlines;
  blob->outlines = NULL;

  while (outline != NULL) {
    if ((outline->topleft.x + outline->botright.x) / 2 < location) {
      /* Outline is in 1st blob */
      if (outline1) {
        outline1->next = outline;
      }
      else {
        blob->outlines = outline;
      }
      outline1 = outline;
    }
    else {
      /* Outline is in 2nd blob */
      if (outline2) {
        outline2->next = outline;
      }
      else {
        other_blob->outlines = outline;
      }
      outline2 = outline;
    }

    outline = outline->next;
  }

  if (outline1)
    outline1->next = NULL;
  if (outline2)
    outline2->next = NULL;
}


/**********************************************************************
 * form_two_blobs
 *
 * Group the outlines from the first blob into both of them. Do so
 * according to the information about the split.
 **********************************************************************/
void form_two_blobs(TBLOB *blob, TBLOB *other_blob, inT32 location) {
  setup_blob_outlines(blob);

  divide_blobs(blob, other_blob, location);

  eliminate_duplicate_outlines(blob);
  eliminate_duplicate_outlines(other_blob);

  correct_blob_order(blob, other_blob);

#ifndef GRAPHICS_DISABLED
  if (chop_debug > 2) {
    display_blob(blob, Red);
    #ifdef __UNIX__
    sleep (1);
    #endif
    display_blob(other_blob, Cyan);
  }
#endif
}


/**********************************************************************
 * make_double_split
 *
 * Create two blobs out of one by splitting the original one in half.
 * Return the resultant blobs for classification.
 **********************************************************************/
void make_double_split(TBLOB *blob, TBLOB *other_blob, SEAM *seam) {
  make_single_split (blob->outlines, seam->split1);
  make_single_split (blob->outlines, seam->split2);
  form_two_blobs (blob, other_blob, seam->location);
}


/**********************************************************************
 * make_single_split
 *
 * Create two outlines out of one by splitting the original one in half.
 * Return the resultant outlines.
 **********************************************************************/
void make_single_split(TESSLINE *outlines, SPLIT *split) {
  assert (outlines != NULL);

  split_outline (split->point1, split->point2);

  while (outlines->next != NULL)
    outlines = outlines->next;

  outlines->next = newoutline ();
  outlines->next->loop = split->point1;
  outlines->next->child = NULL;
  setup_outline (outlines->next);

  outlines = outlines->next;

  outlines->next = newoutline ();
  outlines->next->loop = split->point2;
  outlines->next->child = NULL;
  setup_outline (outlines->next);

  outlines->next->next = NULL;
}


/**********************************************************************
 * make_split_blobs
 *
 * Create two blobs out of one by splitting the original one in half.
 * Return the resultant blobs for classification.
 **********************************************************************/
void make_split_blobs(TBLOB *blob, TBLOB *other_blob, SEAM *seam) {
  make_single_split (blob->outlines, seam->split1);

  form_two_blobs (blob, other_blob, seam->location);
}


/**********************************************************************
 * make_triple_split
 *
 * Create two blobs out of one by splitting the original one in half.
 * This splitting is accomplished by applying three separate splits on
 * the outlines. Three of the starting outlines will produce two ending
 * outlines. Return the resultant blobs for classification.
 **********************************************************************/
void make_triple_split(TBLOB *blob, TBLOB *other_blob, SEAM *seam) {
  make_single_split (blob->outlines, seam->split1);
  make_single_split (blob->outlines, seam->split2);
  make_single_split (blob->outlines, seam->split3);

  form_two_blobs (blob, other_blob, seam->location);
}


/**********************************************************************
 * undo_seam
 *
 * Remove the seam between these two blobs.  Produce one blob as a
 * result.  The seam may consist of one, two, or three splits.  Each
 * of these split must be removed from the outlines.
 **********************************************************************/
void undo_seam(TBLOB *blob, TBLOB *other_blob, SEAM *seam) {
  TESSLINE *outline;

  if (!seam)
    return;                      /* Append other blob outlines */
  if (blob->outlines == NULL) {
    blob->outlines = other_blob->outlines;
    other_blob->outlines = NULL;
  }

  outline = blob->outlines;
  while (outline->next)
    outline = outline->next;
  outline->next = other_blob->outlines;
  oldblob(other_blob);

  if (seam->split1 == NULL) {
  }
  else if (seam->split2 == NULL) {
    undo_single_split (blob, seam->split1);
  }
  else if (seam->split3 == NULL) {
    undo_single_split (blob, seam->split1);
    undo_single_split (blob, seam->split2);
  }
  else {
    undo_single_split (blob, seam->split3);
    undo_single_split (blob, seam->split2);
    undo_single_split (blob, seam->split1);
  }

  setup_blob_outlines(blob);
  eliminate_duplicate_outlines(blob);

  check_outline_mem();
}


/**********************************************************************
 * undo_single_split
 *
 * Undo a seam that is made by a single split.  Perform the correct
 * magic to reconstruct the appropriate set of outline data structures.
 **********************************************************************/
void undo_single_split(TBLOB *blob, SPLIT *split) {
  TESSLINE *outline1;
  TESSLINE *outline2;
  /* Modify edge points */
  unsplit_outlines (split->point1, split->point2);

  outline1 = newoutline ();
  outline1->next = blob->outlines;
  blob->outlines = outline1;
  outline1->loop = split->point1;
  outline1->child = NULL;

  outline2 = newoutline ();
  outline2->next = blob->outlines;
  blob->outlines = outline2;
  outline2->loop = split->point2;
  outline2->child = NULL;
}
/////////////////////////////////////////////////////////////////makechop////////////////////////////////////////

/////////////////////////////////////////////////////////////////chopper////////////////////////////////////////
// Include automatically generated configuration file if running autoconf.
#ifdef HAVE_CONFIG_H
#endif

INT_VAR (repair_unchopped_blobs, 1, "Fix blobs that aren't chopped");

//?extern int tessedit_dangambigs_chop;
double_VAR(tessedit_certainty_threshold, -2.25, "Good blob limit");

BOOL_VAR(fragments_guide_chopper, FALSE,
         "Use information from fragments to guide chopping process");

/*----------------------------------------------------------------------
          M a c r o s
----------------------------------------------------------------------*/
/**
 * @name bounds_inside
 *
 * Check to see if the bounding box of one thing is inside the
 * bounding box of another.
 */
#define bounds_inside(inner_tl,inner_br,outer_tl,outer_br)  \
((inner_tl.x >= outer_tl.x)	&& \
(inner_tl.y <= outer_tl.y)	&& \
(inner_br.x <= outer_br.x)   && \
(inner_br.y >= outer_br.y))     \

/*----------------------------------------------------------------------
          F u n c t i o n s
----------------------------------------------------------------------*/
/**
 * @name preserve_outline_tree
 *
 * Copy the list of outlines.
 */
void preserve_outline(EDGEPT *start) {
  EDGEPT *srcpt;

  if (start == NULL)
    return;
  srcpt = start;
  do {
    srcpt->flags[1] = 1;
    srcpt = srcpt->next;
  }
  while (srcpt != start);
  srcpt->flags[1] = 2;
}


/**************************************************************************/
void preserve_outline_tree(TESSLINE *srcline) {
  TESSLINE *outline;

  for (outline = srcline; outline != NULL; outline = outline->next) {
    preserve_outline (outline->loop);
  }
  if (srcline != NULL && srcline->child != NULL)
    preserve_outline_tree (srcline->child);
}


/**
 * @name restore_outline_tree
 *
 * Copy the list of outlines.
 */
EDGEPT *restore_outline(EDGEPT *start) {
  EDGEPT *srcpt;
  EDGEPT *real_start;
  EDGEPT *deadpt;

  if (start == NULL)
    return NULL;
  srcpt = start;
  do {
    if (srcpt->flags[1] == 2)
      break;
    srcpt = srcpt->next;
  }
  while (srcpt != start);
  real_start = srcpt;
  do {
    if (srcpt->flags[1] == 0) {
      deadpt = srcpt;
      srcpt = srcpt->next;
      srcpt->prev = deadpt->prev;
      deadpt->prev->next = srcpt;
      deadpt->prev->vec.x = srcpt->pos.x - deadpt->prev->pos.x;
      deadpt->prev->vec.y = srcpt->pos.y - deadpt->prev->pos.y;
      oldedgept(deadpt);
    }
    else
      srcpt = srcpt->next;
  }
  while (srcpt != real_start);
  return real_start;
}


/******************************************************************************/
void restore_outline_tree(TESSLINE *srcline) {
  TESSLINE *outline;

  for (outline = srcline; outline != NULL; outline = outline->next) {
    outline->loop = restore_outline (outline->loop);
    outline->start = outline->loop->pos;
  }
  if (srcline != NULL && srcline->child != NULL)
    restore_outline_tree (srcline->child);
}


/**
 * @name attempt_blob_chop
 *
 * Try to split the this blob after this one.  Check to make sure that
 * it was successful.
 */
SEAM *attempt_blob_chop(TWERD *word, inT32 blob_number, SEAMS seam_list) {
  TBLOB *blob;
  TBLOB *other_blob;
  SEAM *seam;
  TBLOB *next_blob;
  inT16 x;

  if (first_pass)
    chops_attempted1++;
  else
    chops_attempted2++;

  blob = word->blobs;
  for (x = 0; x < blob_number; x++) {
    blob = blob->next;
  }
  next_blob = blob->next;

  if (repair_unchopped_blobs)
    preserve_outline_tree (blob->outlines);
  other_blob = newblob ();       /* Make new blob */
  other_blob->next = blob->next;
  other_blob->outlines = NULL;
  blob->next = other_blob;

  seam = pick_good_seam (blob);
  if (chop_debug) {
    if (seam != NULL) {
      print_seam ("Good seam picked=", seam);
    }
    else
      cprintf ("\n** no seam picked *** \n");
  }
  if (seam) {
    apply_seam(blob, other_blob, seam);
  }

  if ((seam == NULL) ||
    (blob->outlines == NULL) ||
    (other_blob->outlines == NULL) ||
    total_containment (blob, other_blob) ||
    check_blob (other_blob) ||
    !(check_seam_order (blob, seam) &&
    check_seam_order (other_blob, seam)) ||
    any_shared_split_points (seam_list, seam) ||
    !test_insert_seam(seam_list, blob_number, blob, word->blobs)) {

    blob->next = next_blob;
    if (seam) {
      undo_seam(blob, other_blob, seam);
      delete_seam(seam);
#ifndef GRAPHICS_DISABLED
      if (chop_debug) {
        if (chop_debug >2)
          display_blob(blob, Red);
        cprintf ("\n** seam being removed ** \n");
      }
#endif
    }
    else {
      oldblob(other_blob);
    }

    if (repair_unchopped_blobs)
      restore_outline_tree (blob->outlines);
    return (NULL);
  }
  return (seam);
}


/**
 * @name any_shared_split_points
 *
 * Return true if any of the splits share a point with this one.
 */
int any_shared_split_points(SEAMS seam_list, SEAM *seam) {
  int length;
  int index;

  length = array_count (seam_list);
  for (index = 0; index < length; index++)
    if (shared_split_points ((SEAM *) array_value (seam_list, index), seam))
      return TRUE;
  return FALSE;
}


/**
 * @name check_blob
 *
 * @return true if blob has a non whole outline.
 */
int check_blob(TBLOB *blob) {
  TESSLINE *outline;
  EDGEPT *edgept;

  for (outline = blob->outlines; outline != NULL; outline = outline->next) {
    edgept = outline->loop;
    do {
      if (edgept == NULL)
        break;
      edgept = edgept->next;
    }
    while (edgept != outline->loop);
    if (edgept == NULL)
      return 1;
  }
  return 0;
}

/**
 * @name improve_one_blob
 *
 * Start with the current word of blobs and its classification.  Find
 * the worst blobs and try to divide it up to improve the ratings.
 */
bool Wordrec::improve_one_blob(TWERD *word,
                               BLOB_CHOICE_LIST_VECTOR *char_choices,
                               int fx,
                               inT32 *blob_number,
                               SEAMS *seam_list,
                               DANGERR *fixpt,
                               bool split_next_to_fragment)
{
    Q_UNUSED(fixpt);
    Q_UNUSED(fx);
  TBLOB *pblob;
  TBLOB *blob;
  inT16 x = 0;
  float rating_ceiling = MAX_FLOAT32;
  BLOB_CHOICE_LIST *answer;
  BLOB_CHOICE_IT answer_it;
  SEAM *seam;

  do {
    *blob_number = select_blob_to_split(*char_choices, rating_ceiling,
                                        split_next_to_fragment);
    if (chop_debug)
      cprintf("blob_number = %d\n", *blob_number);
    if (*blob_number == -1)
      return false;

    seam = attempt_blob_chop (word, *blob_number, *seam_list);
    if (seam != NULL)
      break;
    /* Must split null blobs */
    answer = char_choices->get(*blob_number);
    if (answer == NULL)
      return false;
    answer_it.set_to_list(answer);
    rating_ceiling = answer_it.data()->rating();  // try a different blob
  } while (!tord_blob_skip);
  /* Split OK */
  for (blob = word->blobs, pblob = NULL; x < *blob_number; x++) {
    pblob = blob;
    blob = blob->next;
  }

  *seam_list =
    insert_seam (*seam_list, *blob_number, seam, blob, word->blobs);

  delete char_choices->get(*blob_number);

  answer = classify_blob(pblob, blob, blob->next, NULL, "improve 1:", Red);
  char_choices->insert(answer, *blob_number);

  answer = classify_blob(blob, blob->next, blob->next->next, NULL,
                         "improve 2:", Yellow);
  char_choices->set(answer, *blob_number + 1);

  return true;
}

/**
 * @name modify_blob_choice
 *
 * Takes a blob and its chop index, converts that chop index to a
 * unichar_id, and stores the chop index in place of the blob's
 * original unichar_id.
 */
void Wordrec::modify_blob_choice(BLOB_CHOICE_LIST *answer,
                        int chop_index) {
  char chop_index_string[2];
  if (chop_index <= 9) {
    snprintf(chop_index_string, sizeof(chop_index_string), "%d", chop_index);
  } else {
    chop_index_string[0] = static_cast<char>('A' - 10 + chop_index);
    chop_index_string[1] = '\0';
  }
  UNICHAR_ID unichar_id = unicharset.unichar_to_id(chop_index_string);
  ASSERT_HOST(unichar_id!=INVALID_UNICHAR_ID);
  BLOB_CHOICE_IT answer_it(answer);
  BLOB_CHOICE *modified_blob = new BLOB_CHOICE(unichar_id,
                                             answer_it.data()->rating(),
                                             answer_it.data()->certainty(),
                                             answer_it.data()->config(),
                                             answer_it.data()->script_id());
  answer->clear();
  answer_it.set_to_list(answer);
  answer_it.add_after_then_move(modified_blob);
}

/**
 * @name chop_one_blob
 *
 * Start with the current one-blob word and its classification.  Find
 * the worst blobs and try to divide it up to improve the ratings.
 * Used for testing chopper.
 */
bool Wordrec::chop_one_blob(TWERD *word,
                               BLOB_CHOICE_LIST_VECTOR *char_choices,
                               inT32 *blob_number,
                               SEAMS *seam_list,
                               int *right_chop_index) {
  TBLOB *pblob;
  TBLOB *blob;
  inT16 x = 0;
  float rating_ceiling = MAX_FLOAT32;
  BLOB_CHOICE_LIST *answer;
  BLOB_CHOICE_IT answer_it;
  SEAM *seam;
  UNICHAR_ID unichar_id = 0;
  int left_chop_index = 0;

  do {
    *blob_number = select_blob_to_split(*char_choices, rating_ceiling,
                                        false);
    if (chop_debug)
      cprintf("blob_number = %d\n", *blob_number);
    if (*blob_number == -1)
      return false;
    seam = attempt_blob_chop(word, *blob_number, *seam_list);
    if (seam != NULL)
      break;
    /* Must split null blobs */
    answer = char_choices->get(*blob_number);
    if (answer == NULL)
      return false;
    answer_it.set_to_list(answer);
    rating_ceiling = answer_it.data()->rating();  // try a different blob
  } while (!tord_blob_skip);
  /* Split OK */
  for (blob = word->blobs, pblob = NULL; x < *blob_number; x++) {
    pblob = blob;
    blob = blob->next;
  }
  *seam_list =
    insert_seam(*seam_list, *blob_number, seam, blob, word->blobs);

  answer = char_choices->get(*blob_number);
  answer_it.set_to_list(answer);
  unichar_id = answer_it.data()->unichar_id();
  left_chop_index = atoi(unicharset.id_to_unichar(unichar_id));

  delete char_choices->get(*blob_number);
  // combine confidence w/ serial #
  answer = classify_blob(pblob, blob, blob->next, NULL, "improve 1:", Red);
  modify_blob_choice(answer, left_chop_index);
  char_choices->insert(answer, *blob_number);

  answer = classify_blob(blob, blob->next, blob->next->next, NULL,
                         "improve 2:", Yellow);
  modify_blob_choice(answer, ++*right_chop_index);
  char_choices->set(answer, *blob_number + 1);
  return true;
}

/**
 * @name check_seam_order
 *
 * Make sure that each of the splits in this seam match to outlines
 * in this blob.  If any of the splits could not correspond to this
 * blob then there is a problem (and FALSE should be returned to the
 * caller).
 */
inT16 check_seam_order(TBLOB *blob, SEAM *seam) {
  TESSLINE *outline;
  inT8 found_em[3];

  if (seam->split1 == NULL || seam->split1 == NULL || blob == NULL)
    return (TRUE);

  found_em[0] = found_em[1] = found_em[2] = FALSE;

  for (outline = blob->outlines; outline; outline = outline->next) {
    if (!found_em[0] &&
      ((seam->split1 == NULL) ||
    is_split_outline (outline, seam->split1))) {
      found_em[0] = TRUE;
    }
    if (!found_em[1] &&
      ((seam->split2 == NULL) ||
    is_split_outline (outline, seam->split2))) {
      found_em[1] = TRUE;
    }
    if (!found_em[2] &&
      ((seam->split3 == NULL) ||
    is_split_outline (outline, seam->split3))) {
      found_em[2] = TRUE;
    }
  }

  if (!found_em[0] || !found_em[1] || !found_em[2])
    return (FALSE);
  else
    return (TRUE);
}

/**
 * @name chop_word_main
 *
 * Classify the blobs in this word and permute the results.  Find the
 * worst blob in the word and chop it up.  Continue this process until
 * a good answer has been found or all the blobs have been chopped up
 * enough.  Return the word level ratings.
 */
BLOB_CHOICE_LIST_VECTOR *Wordrec::chop_word_main(register TWERD *word,
                                                 int fx,
                                                 WERD_CHOICE *best_choice,
                                                 WERD_CHOICE *raw_choice,
                                                 BOOL8 tester,
                                                 BOOL8 trainer) {
  TBLOB *pblob;
  TBLOB *blob;
  int index;
  int did_chopping;
  float rating_limit = 1000.0;
  STATE state;
  SEAMS seam_list = start_seam_list(word->blobs);
  BLOB_CHOICE_LIST *match_result;
  MATRIX *ratings = NULL;
  DANGERR fixpt;                 /*dangerous ambig */
  inT32 state_count;             //no of states
  inT32 bit_count;               //no of bits
  static STATE best_state;
  static STATE chop_states[64];  //in between states

  state_count = 0;
  best_choice->make_bad();
  raw_choice->make_bad();

  BLOB_CHOICE_LIST_VECTOR *char_choices = new BLOB_CHOICE_LIST_VECTOR();

  did_chopping = 0;
  for (blob = word->blobs, pblob = NULL, index = 0;
       blob != NULL; blob = blob->next, index++) {
    match_result = classify_blob(pblob, blob, blob->next, NULL,
                                 "chop_word:", Green);
    if (match_result == NULL)
      cprintf("Null classifier output!\n");
    *char_choices += match_result;
    pblob = blob;
  }
  bit_count = index - 1;
  getDict().permute_characters(*char_choices, rating_limit,
                               best_choice, raw_choice);
  set_n_ones(&state, char_choices->length() - 1);
  if (matcher_fp != NULL) {
    bits_in_states = bit_count;
    chop_states[state_count] = state;
    state_count++;
  }
  bool replaced = false;
  if (!getDict().AcceptableChoice(char_choices, best_choice, *raw_choice,
                                  &fixpt, CHOPPER_CALLER, &replaced) ||
      ((tester || trainer) &&
       strcmp(word->correct, best_choice->unichar_string().string()))) {
    if (replaced) update_blob_classifications(word, *char_choices);
    did_chopping = 1;
    if (first_pass)
      words_chopped1++;
    else
      words_chopped2++;

    if (chop_enable)
      improve_by_chopping(word,
                          char_choices,
                          fx,
                          &state,
                          best_choice,
                          raw_choice,
                          &seam_list,
                          &fixpt,
                          chop_states,
                          &state_count);
    if (chop_debug)
      print_seams ("Final seam list:", seam_list);

    // The force_word_assoc is almost redundant to enable_assoc.  However,
    // it is not conditioned on the dict behavior.  For CJK, we need to force
    // the associator to be invoked.  When we figure out the exact behavior
    // of dict on CJK, we can remove the flag if it turns out to be redundant.
    if ((wordrec_enable_assoc &&
         !getDict().AcceptableChoice(char_choices, best_choice, *raw_choice,
                                     NULL, CHOPPER_CALLER, &replaced)) ||
        force_word_assoc ||
        ((tester || trainer) &&
         strcmp(word->correct, best_choice->unichar_string().string()))) {
      ratings = word_associator (word->blobs, seam_list, &state, fx,
        best_choice, raw_choice, word->correct,
        /*0, */ &fixpt, &best_state);
    }
    bits_in_states = bit_count + state_count - 1;
  }
  if (replaced) update_blob_classifications(word, *char_choices);

  char_choices =
    rebuild_current_state(word->blobs, seam_list, &state, char_choices, fx,
                          (did_chopping || tester || trainer), *best_choice,
                          ratings);

  if (ratings != NULL) {
    ratings->delete_matrix_pointers();
    delete ratings;
  }
  if (seam_list != NULL)
    free_seam_list(seam_list);
  if (matcher_fp != NULL) {
    best_state = state;
  }
  getDict().FilterWordChoices();
  return char_choices;
}



/**
 * @name improve_by_chopping
 *
 * Start with the current word of blobs and its classification.  Find
 * the worst blobs and try to divide them up to improve the ratings.
 * As long as ratings are produced by the new blob splitting.  When
 * all the splitting has been accomplished all the ratings memory is
 * reclaimed.
 */
void Wordrec::improve_by_chopping(register TWERD *word,
                                  BLOB_CHOICE_LIST_VECTOR *char_choices,
                                  int fx,
                                  STATE *best_state,
                                  WERD_CHOICE *best_choice,
                                  WERD_CHOICE *raw_choice,
                                  SEAMS *seam_list,
                                  DANGERR *fixpt,
                                  STATE *chop_states,
                                  inT32 *state_count) {
  inT32 blob_number;
  inT32 index;                   //to states
  float old_best;
  int fixpt_valid = 1;
  bool replaced = false;

  do {  // improvement loop
    if (replaced) update_blob_classifications(word, *char_choices);
    if (!fixpt_valid)
      fixpt->index = -1;
    old_best = best_choice->rating();
    if (improve_one_blob(word, char_choices, fx, &blob_number, seam_list,
                         fixpt, (fragments_guide_chopper &&
                                 best_choice->fragment_mark()))) {
      getDict().LogNewSplit(blob_number);
      getDict().permute_characters(*char_choices, best_choice->rating(),
                                   best_choice, raw_choice);

      if (old_best > best_choice->rating()) {
        set_n_ones(best_state, char_choices->length() - 1);
        fixpt_valid = 1;
      }
      else {
        insert_new_chunk(best_state, blob_number, char_choices->length() - 2);
        fixpt_valid = 0;
      }
      if (*state_count > 0) {
        for (index = 0; index < *state_count; index++) {
          insert_new_chunk(&chop_states[index], blob_number,
                           char_choices->length() - 2);
        }
        set_n_ones(&chop_states[index], char_choices->length() - 1);
        (*state_count)++;
      }

      if (chop_debug)
        print_state ("best state = ",
          best_state, count_blobs (word->blobs) - 1);
      if (first_pass)
        chops_performed1++;
      else
        chops_performed2++;
    } else {
      break;
    }
  } while (!getDict().AcceptableChoice(char_choices, best_choice, *raw_choice,
                                       fixpt, CHOPPER_CALLER, &replaced) &&
           !tord_blob_skip && char_choices->length() < MAX_NUM_CHUNKS);
  if (replaced) update_blob_classifications(word, *char_choices);
  if (!fixpt_valid)
    fixpt->index = -1;
}


/**********************************************************************
 * select_blob_to_split
 *
 * These are the results of the last classification.  Find a likely
 * place to apply splits.
 **********************************************************************/
inT16 Wordrec::select_blob_to_split(const BLOB_CHOICE_LIST_VECTOR &char_choices,
                                    float rating_ceiling,
                                    bool split_next_to_fragment) {
  BLOB_CHOICE_IT blob_choice_it;
  BLOB_CHOICE *blob_choice;
  BLOB_CHOICE_IT temp_it;
  int x;
  float worst = -MAX_FLOAT32;
  int worst_index = -1;
  float worst_near_fragment = -MAX_FLOAT32;
  int worst_index_near_fragment = -1;
  const CHAR_FRAGMENT **fragments = NULL;

  if (chop_debug) {
    if (rating_ceiling < MAX_FLOAT32)
      cprintf("rating_ceiling = %8.4f\n", rating_ceiling);
    else
      cprintf("rating_ceiling = No Limit\n");
  }

  if (split_next_to_fragment && char_choices.length() > 0) {
    fragments = new const CHAR_FRAGMENT *[char_choices.length()];
    if (char_choices.get(0) != NULL) {
      temp_it.set_to_list(char_choices.get(0));
      fragments[0] = getDict().getUnicharset().get_fragment(
          temp_it.data()->unichar_id());
    } else {
      fragments[0] = NULL;
    }
  }

  for (x = 0; x < char_choices.length(); ++x) {
    if (char_choices.get(x) == NULL) {
      if (fragments != NULL) {
        delete[] fragments;
      }
      return x;
    } else {
      blob_choice_it.set_to_list(char_choices.get(x));
      blob_choice = blob_choice_it.data();
      // Populate fragments for the following position.
      if (split_next_to_fragment && x+1 < char_choices.length()) {
        if (char_choices.get(x+1) != NULL) {
          temp_it.set_to_list(char_choices.get(x+1));
          fragments[x+1] = getDict().getUnicharset().get_fragment(
              temp_it.data()->unichar_id());
        } else {
          fragments[x+1] = NULL;
        }
      }
      if (blob_choice->rating() < rating_ceiling &&
          blob_choice->certainty() < tessedit_certainty_threshold) {
        // Update worst and worst_index.
        if (blob_choice->rating() > worst) {
          worst_index = x;
          worst = blob_choice->rating();
        }
        if (split_next_to_fragment) {
          // Update worst_near_fragment and worst_index_near_fragment.
          bool expand_following_fragment =
            (x + 1 < char_choices.length() &&
             fragments[x+1] != NULL && !fragments[x+1]->is_beginning());
          bool expand_preceding_fragment =
            (x > 0 && fragments[x-1] != NULL && !fragments[x-1]->is_ending());
          if ((expand_following_fragment || expand_preceding_fragment) &&
              blob_choice->rating() > worst_near_fragment) {
            worst_index_near_fragment = x;
            worst_near_fragment = blob_choice->rating();
            if (chop_debug) {
              cprintf("worst_index_near_fragment=%d"
                      " expand_following_fragment=%d"
                      " expand_preceding_fragment=%d\n",
                      worst_index_near_fragment,
                      expand_following_fragment,
                      expand_preceding_fragment);
            }
          }
        }
      }
    }
  }
  if (fragments != NULL) {
    delete[] fragments;
  }
  // TODO(daria): maybe a threshold of badness for
  // worst_near_fragment would be useful.
  return worst_index_near_fragment != -1 ?
    worst_index_near_fragment : worst_index;
}

/**********************************************************************
 * start_seam_list
 *
 * Initialize a list of seams that match the original number of blobs
 * present in the starting segmentation.  Each of the seams created
 * by this routine have location information only.
 **********************************************************************/
SEAMS start_seam_list(TBLOB *blobs) {
  TBLOB *blob;
  SEAMS seam_list;
  TPOINT topleft;
  TPOINT botright;
  int location;
  /* Seam slot per char */
  seam_list = new_seam_list ();

  for (blob = blobs; blob->next != NULL; blob = blob->next) {

    blob_bounding_box(blob, &topleft, &botright);
    location = botright.x;
    blob_bounding_box (blob->next, &topleft, &botright);
    location += topleft.x;
    location /= 2;

    seam_list = add_seam (seam_list,
      new_seam (0.0, location, NULL, NULL, NULL));
  }

  return (seam_list);
}


/**********************************************************************
 * total_containment
 *
 * Check to see if one of these outlines is totally contained within
 * the bounding box of the other.
 **********************************************************************/
inT16 total_containment(TBLOB *blob1, TBLOB *blob2) {
  TPOINT topleft1;
  TPOINT botright1;
  TPOINT topleft2;
  TPOINT botright2;

  blob_bounding_box(blob1, &topleft1, &botright1);
  blob_bounding_box(blob2, &topleft2, &botright2);

  return (bounds_inside (topleft1, botright1, topleft2, botright2) ||
    bounds_inside (topleft2, botright2, topleft1, botright1));
}


/**********************************************************************
 * word_associator
 *
 * Reassociate and classify the blobs in a word.  Continue this process
 * until a good answer is found or all the possibilities have been tried.
 **********************************************************************/
MATRIX *Wordrec::word_associator(TBLOB *blobs,
                                 SEAMS seams,
                                 STATE *state,
                                 int fxid,
                                 WERD_CHOICE *best_choice,
                                 WERD_CHOICE *raw_choice,
                                 char *correct,
                                 DANGERR *fixpt,
                                 STATE *best_state)
{
    Q_UNUSED(correct);
  CHUNKS_RECORD chunks_record;
  BLOB_WEIGHTS blob_weights;
  int x;
  int num_chunks;
  BLOB_CHOICE_IT blob_choice_it;

  num_chunks = array_count (seams) + 1;

  chunks_record.chunks = blobs;
  chunks_record.splits = seams;
  chunks_record.ratings = record_piece_ratings (blobs);
  chunks_record.char_widths = blobs_widths (blobs);
  chunks_record.chunk_widths = blobs_widths (blobs);
  chunks_record.fx = fxid;
  /* Save chunk weights */
  for (x = 0; x < num_chunks; x++) {
    BLOB_CHOICE_LIST* choices = get_piece_rating(chunks_record.ratings,
                                                 blobs, seams, x, x);
    blob_choice_it.set_to_list(choices);
    //This is done by Jetsoft. Divide by zero is possible.
    if (blob_choice_it.data()->certainty() == 0) {
      blob_weights[x]=0;
    } else {
      blob_weights[x] =
        -(inT16) (10 * blob_choice_it.data()->rating() /
                  blob_choice_it.data()->certainty());
    }
  }
  chunks_record.weights = blob_weights;

  if (chop_debug)
    chunks_record.ratings->print(getDict().getUnicharset());

  best_first_search(&chunks_record,
                    best_choice,
                    raw_choice,
                    state,
                    fixpt,
                    best_state);

  free_widths (chunks_record.chunk_widths);
  free_widths (chunks_record.char_widths);
  return chunks_record.ratings;
}
/////////////////////////////////////////////////////////////////chopper////////////////////////////////////////

/////////////////////////////////////////////////////////////////bbgrid////////////////////////////////////////
#ifdef HAVE_LIBLEPT
// Make a Pix of the correct scaled size for the TraceOutline functions.
Pix* GridReducedPix(const TBOX& box, int gridsize,
                    ICOORD bleft, int* left, int* bottom) {
  // Compute grid bounds of the outline and pad all round by 1.
  int grid_left = (box.left() - bleft.x()) / gridsize - 1;
  int grid_bottom = (box.bottom() - bleft.y()) / gridsize - 1;
  int grid_right = (box.right() - bleft.x()) / gridsize + 1;
  int grid_top = (box.top() - bleft.y()) / gridsize + 1;
  *left = grid_left;
  *bottom = grid_bottom;
  return pixCreate(grid_right - grid_left + 1,
                   grid_top - grid_bottom + 1,
                   1);
}

// Helper function to return a scaled Pix with one pixel per grid cell,
// set (black) where the given outline enters the corresponding grid cell,
// and clear where the outline does not touch the grid cell.
// Also returns the grid coords of the bottom-left of the Pix, in *left
// and *bottom, which corresponds to (0, 0) on the Pix.
// Note that the Pix is used upside-down, with (0, 0) being the bottom-left.
Pix* TraceOutlineOnReducedPix(C_OUTLINE* outline, int gridsize,
                              ICOORD bleft, int* left, int* bottom) {
  TBOX box = outline->bounding_box();
  Pix* pix = GridReducedPix(box, gridsize, bleft, left, bottom);
  int wpl = pixGetWpl(pix);
  l_uint32* data = pixGetData(pix);
  int length = outline->pathlength();
  ICOORD pos = outline->start_pos();
  for (int i = 0; i < length; ++i) {
    int grid_x = (pos.x() - bleft.x()) / gridsize - *left;
    int grid_y = (pos.y() - bleft.y()) / gridsize - *bottom;
    SET_DATA_BIT(data + grid_y * wpl, grid_x);
    pos += outline->step(i);
  }
  return pix;
}
#if 0  // Example code shows how to use TraceOutlineOnReducedPix.
  C_OUTLINE_IT ol_it(blob->cblob()->out_list());
  int grid_left, grid_bottom;
  Pix* pix = TraceOutlineOnReducedPix(ol_it.data(), gridsize_, bleft_,
                                      &grid_left, &grid_bottom);
  grid->InsertPixPtBBox(grid_left, grid_bottom, pix, blob);
  pixDestroy(&pix);
#endif

// As TraceOutlineOnReducedPix above, but on a BLOCK instead of a C_OUTLINE.
Pix* TraceBlockOnReducedPix(BLOCK* block, int gridsize,
                            ICOORD bleft, int* left, int* bottom) {
  TBOX box = block->bounding_box();
  Pix* pix = GridReducedPix(box, gridsize, bleft, left, bottom);
  int wpl = pixGetWpl(pix);
  l_uint32* data = pixGetData(pix);
  ICOORDELT_IT it(block->poly_block()->points());
  for (it.mark_cycle_pt(); !it.cycled_list();) {
    ICOORD pos = *it.data();
    it.forward();
    ICOORD next_pos = *it.data();
    ICOORD line_vector = next_pos - pos;
    int major, minor;
    ICOORD major_step, minor_step;
    line_vector.setup_render(&major_step, &minor_step, &major, &minor);
    int accumulator = major / 2;
    while (pos != next_pos) {
      int grid_x = (pos.x() - bleft.x()) / gridsize - *left;
      int grid_y = (pos.y() - bleft.y()) / gridsize - *bottom;
      SET_DATA_BIT(data + grid_y * wpl, grid_x);
      pos += major_step;
      accumulator += minor;
      if (accumulator >= major) {
        accumulator -= major;
        pos += minor_step;
      }
    }
  }
  return pix;
}
#endif
/////////////////////////////////////////////////////////////////bbgrid////////////////////////////////////////

/////////////////////////////////////////////////////////////////alignedblob////////////////////////////////////////
INT_VAR(textord_debug_tabfind, 0, "Debug tab finding");
INT_VAR(textord_debug_bugs, 0, "Turn on output related to bugs in tab finding");
INT_VAR(textord_testregion_left, -1, "Left edge of debug reporting rectangle");
INT_VAR(textord_testregion_top, -1, "Top edge of debug reporting rectangle");
INT_VAR(textord_testregion_right, MAX_INT32, "Right edge of debug rectangle");
INT_VAR(textord_testregion_bottom, MAX_INT32, "Bottom edge of debug rectangle");
BOOL_VAR(textord_debug_images, false, "Use greyed image background for debug");
BOOL_VAR(textord_debug_printable, false, "Make debug windows printable");

// Fraction of resolution used as alignment tolerance for aligned tabs.
//const double kAlignedFraction = 0.03125;
// Fraction of resolution used as alignment tolerance for ragged tabs.
const double kRaggedFraction = 0.5;
// Fraction of height used as a minimum gutter gap for aligned blobs.
//const double kAlignedGapFraction = 0.75;
// Fraction of height used as a minimum gutter gap for ragged tabs.
const double kRaggedGapFraction = 3.0;
// Constant number of pixels used as alignment tolerance for line finding.
const int kVLineAlignment = 3;
// Constant number of pixels used as gutter gap tolerance for line finding.
const int kVLineGutter = 1;
// Constant number of pixels used as the search size for line finding.
const int kVLineSearchSize = 150;
// Min number of points to accept for a ragged tab stop.
const int kMinRaggedTabs = 5;
// Min number of points to accept for an aligned tab stop.
const int kMinAlignedTabs = 4;
// Constant number of pixels minimum height of a vertical line.
const int kVLineMinLength = 500;
// Tolerance to skew on top of current estimate of skew. Divide x or y length
// by kMaxSkewFactor to get the y or x skew distance.
// If the angle is small, the angle in degrees is roughly 60/kMaxSkewFactor.
const int kMaxSkewFactor = 15;

// Constant part of textord_debug_pix_.
const char* kTextordDebugPix = "psdebug_pix";

// Name of image file to use if textord_debug_images is true.
STRING AlignedBlob::textord_debug_pix_ = kTextordDebugPix;
// Index to image file to use if textord_debug_images is true.
int AlignedBlob::debug_pix_index_ = 0;

// Increment the serial number counter and set the string to use
// for a filename if textord_debug_images is true.
void AlignedBlob::IncrementDebugPix()
{
    ++debug_pix_index_;
    textord_debug_pix_ = kTextordDebugPix;
    char numbuf[32];
    snprintf(numbuf, sizeof(numbuf), "%d", debug_pix_index_);
    textord_debug_pix_ += numbuf;
    textord_debug_pix_ += ".pix";
}

// Constructor to set the parameters for finding aligned and ragged tabs.
// Vertical_x and vertical_y are the current estimates of the true vertical
// direction (up) in the image. Height is the height of the starter blob.
// v_gap_multiple is the multiple of height that will be used as a limit
// on vertical gap before giving up and calling the line ended.
// resolution is the original image resolution, and align0 indicates the
// type of tab stop to be found.
AlignedBlobParams::AlignedBlobParams(int vertical_x, int vertical_y, int height, int v_gap_multiple, int resolution, TabAlignment align0)
    : right_tab(align0 == TA_RIGHT_RAGGED || align0 == TA_RIGHT_ALIGNED), ragged(align0 == TA_LEFT_RAGGED || align0 == TA_RIGHT_RAGGED),
      alignment(align0), confirmed_type(TT_CONFIRMED), min_length(0)
{
    // Set the tolerances according to the type of line sought.
    // For tab search, these are based on the image resolution for most, or
    // the height of the starting blob for the maximum vertical gap.
    max_v_gap = height * v_gap_multiple;
    if (ragged)
    {
        // In the case of a ragged edge, we are much more generous with the
        // inside alignment fraction, but also require a much bigger gutter.
        gutter_fraction = kRaggedGapFraction;
        if (alignment == TA_RIGHT_RAGGED)
        {
            l_align_tolerance = static_cast<int>(resolution * kRaggedFraction + 0.5);
            r_align_tolerance = static_cast<int>(resolution * kAlignedFraction + 0.5);
        }
        else
        {
            l_align_tolerance = static_cast<int>(resolution * kAlignedFraction + 0.5);
            r_align_tolerance = static_cast<int>(resolution * kRaggedFraction + 0.5);
        }

        min_points = kMinRaggedTabs;
    }
    else
    {
        gutter_fraction = kAlignedGapFraction;
        l_align_tolerance = static_cast<int>(resolution * kAlignedFraction + 0.5);
        r_align_tolerance = static_cast<int>(resolution * kAlignedFraction + 0.5);

        min_points = kMinAlignedTabs;
    }

    min_gutter = static_cast<int>(height * gutter_fraction + 0.5);

    // Fit the vertical vector into an ICOORD, which is 16 bit.
    set_vertical(vertical_x, vertical_y);
}

// Constructor to set the parameters for finding vertical lines.
// Vertical_x and vertical_y are the current estimates of the true vertical
// direction (up) in the image. Width is the width of the starter blob.
AlignedBlobParams::AlignedBlobParams(int vertical_x, int vertical_y, int width) : gutter_fraction(0.0), right_tab(false), ragged(false),
    alignment(TA_SEPARATOR), confirmed_type(TT_VLINE), max_v_gap(kVLineSearchSize), min_gutter(kVLineGutter), min_points(1), min_length(kVLineMinLength)
{
    // Compute threshold for left and right alignment.
    l_align_tolerance = MAX(kVLineAlignment, width);
    r_align_tolerance = MAX(kVLineAlignment, width);

    // Fit the vertical vector into an ICOORD, which is 16 bit.
    set_vertical(vertical_x, vertical_y);
}

// Fit the vertical vector into an ICOORD, which is 16 bit.
void AlignedBlobParams::set_vertical(int vertical_x, int vertical_y)
{
    int factor = 1;
    if (vertical_y > MAX_INT16) factor = vertical_y / MAX_INT16 + 1;

    vertical.set_x(vertical_x / factor);
    vertical.set_y(vertical_y / factor);
}


AlignedBlob::AlignedBlob(int gridsize, const ICOORD& bleft, const ICOORD& tright) : BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT>(gridsize, bleft, tright)
{
}

AlignedBlob::~AlignedBlob()
{
}

// Return true if the given coordinates are within the test rectangle
// and the debug level is at least the given detail level.
bool AlignedBlob::WithinTestRegion(int detail_level, int x, int y)
{
    if (textord_debug_tabfind < detail_level) return false;

    return x >= textord_testregion_left && x <= textord_testregion_right && y <= textord_testregion_top && y >= textord_testregion_bottom;
}

// Display the tab codes of the BLOBNBOXes in this grid.
ScrollView* AlignedBlob::DisplayTabs(const char* window_name, ScrollView* tab_win)
{
#ifndef GRAPHICS_DISABLED
    if (tab_win == NULL) tab_win = MakeWindow(0, 50, window_name);

    // For every tab in the grid, display it.
    GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> gsearch(this);
    gsearch.StartFullSearch();
    BLOBNBOX* bbox;

    while ((bbox = gsearch.NextFullSearch()) != NULL)
    {
        TBOX box = bbox->bounding_box();
        int left_x = box.left();
        int right_x = box.right();
        int top_y = box.top();
        int bottom_y = box.bottom();
        TabType tabtype = bbox->left_tab_type();

        if (tabtype != TT_NONE)
        {
            if (tabtype == TT_UNCONFIRMED)
            {
                tab_win->Pen(ScrollView::BLUE);
            }
            else if (tabtype == TT_CONFIRMED)
            {
                tab_win->Pen(ScrollView::GREEN);
            }
            else if (tabtype == TT_FAKE)
            {
                tab_win->Pen(ScrollView::YELLOW);
            }
            else
            {
                tab_win->Pen(ScrollView::GREY);
            }

            tab_win->Line(left_x, top_y, left_x, bottom_y);
        }

        tabtype = bbox->right_tab_type();

        if (tabtype != TT_NONE)
        {
            if (tabtype == TT_UNCONFIRMED)
            {
                tab_win->Pen(ScrollView::MAGENTA);
            }
            else if (tabtype == TT_CONFIRMED)
            {
                tab_win->Pen(ScrollView::RED);
            }
            else if (tabtype == TT_FAKE)
            {
                tab_win->Pen(ScrollView::ORANGE);
            }
            else
            {
                tab_win->Pen(ScrollView::GREY);
            }

            tab_win->Line(right_x, top_y, right_x, bottom_y);
        }
    }
    tab_win->Update();
#endif
    return tab_win;
}

// Finds a vector corresponding to a set of vertically aligned blob edges
// running through the given box. The type of vector returned and the
// search parameters are determined by the AlignedBlobParams.
// vertical_x and y are updated with an estimate of the real
// vertical direction. (skew finding.)
// Returns NULL if no decent vector can be found.
TabVector* AlignedBlob::FindVerticalAlignment(AlignedBlobParams align_params, BLOBNBOX* bbox, int* vertical_x, int* vertical_y)
{
    int ext_start_y, ext_end_y;
    BLOBNBOX_CLIST good_points;

    // Search up and then down from the starting bbox.
    int pt_count = AlignTabs(align_params, false, bbox, &good_points, &ext_end_y);
    pt_count += AlignTabs(align_params, true, bbox, &good_points, &ext_start_y);
    BLOBNBOX_C_IT it(&good_points);
    it.move_to_last();

    int end_y = it.data()->bounding_box().top();
    it.move_to_first();

    int start_y = it.data()->bounding_box().bottom();

    if (pt_count >= align_params.min_points && end_y - start_y >= align_params.min_length)
    {
        int confirmed_points = 0;

        // Count existing confirmed points to see if vector is acceptable.
        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
        {
            bbox = it.data();

            if (align_params.right_tab)
            {
                if (bbox->right_tab_type() == align_params.confirmed_type)
                {
                    ++confirmed_points;
                }
            }
            else
            {
                if (bbox->left_tab_type() == align_params.confirmed_type)
                {
                    ++confirmed_points;
                }
            }
        }

        // Ragged vectors are not allowed to use too many already used points.
        if (!align_params.ragged || confirmed_points + confirmed_points < pt_count)
        {
            const TBOX& box = bbox->bounding_box();
            if (WithinTestRegion(2, box.left(), box.bottom()))
            {
                tprintf("Confirming tab vector of %d pts starting at %d,%d\n", pt_count, box.left(), box.bottom());
            }

            // Flag all the aligned neighbours as confirmed .
            for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
            {
                bbox = it.data();

                if (align_params.right_tab)
                {
                    bbox->set_right_tab_type(align_params.confirmed_type);
                }
                else
                {
                    bbox->set_left_tab_type(align_params.confirmed_type);
                }
            }

            // Now make the vector and return it.
            TabVector* result = TabVector::FitVector(align_params.alignment, align_params.vertical, ext_start_y, ext_end_y, &good_points, vertical_x, vertical_y);
            if (WithinTestRegion(2, box.left(), box.bottom()))
            {
                result->Print("After fitting");
            }

            return result;
        }
    }

    return NULL;
}

// Find a set of blobs that are aligned in the given vertical
// direction with the given blob. Returns a list of aligned
// blobs and the number in the list.
// For other parameters see FindAlignedBlob below.
int AlignedBlob::AlignTabs(const AlignedBlobParams& params, bool top_to_bottom, BLOBNBOX* bbox, BLOBNBOX_CLIST* good_points, int* end_y)
{
    int ptcount = 0;
    BLOBNBOX_C_IT it(good_points);

    TBOX box = bbox->bounding_box();
    int x_start = params.right_tab ? box.right() : box.left();

    while (bbox != NULL)
    {
        // Add the blob to the list if the appropriate side is a tab candidate,
        // or if we are working on a ragged tab.
        if (((params.right_tab && bbox->right_tab_type() != TT_NONE) || (!params.right_tab && bbox->left_tab_type() != TT_NONE) ||
             params.ragged) && (it.empty() || it.data() != bbox))
        {
            if (top_to_bottom)
            {
                it.add_before_then_move(bbox);
            }
            else
            {
                it.add_after_then_move(bbox);
            }

            ++ptcount;
        }

        // Find the next blob that is aligned with the current one.
        // FindAlignedBlob guarantees that forward progress will be made in the
        // top_to_bottom direction, and therefore eventually it will return NULL,
        // making this while (bbox != NULL) loop safe.
        bbox = FindAlignedBlob(params, top_to_bottom, bbox, x_start, end_y);

        if (bbox != NULL)
        {
            box = bbox->bounding_box();
            if (!params.ragged)
            {
                x_start = params.right_tab ? box.right() : box.left();
            }
        }
    }

    return ptcount;
}

// Search vertically for a blob that is aligned with the input bbox.
// The search parameters are determined by AlignedBlobParams.
// top_to_bottom tells whether to search down or up.
// The return value is NULL if nothing was found in the search box
// or if a blob was found in the gutter. On a NULL return, end_y
// is set to the edge of the search box or the leading edge of the
// gutter blob if one was found.
BLOBNBOX* AlignedBlob::FindAlignedBlob(const AlignedBlobParams& p, bool top_to_bottom, BLOBNBOX* bbox,int x_start, int* end_y)
{
    TBOX box = bbox->bounding_box();

    // If there are separator lines, get the column edges.
    int left_column_edge = bbox->left_rule();
    int right_column_edge = bbox->right_rule();

    // start_y is used to guarantee that forward progress is made and the
    // search does not go into an infinite loop. New blobs must extend the
    // line beyond start_y.
    int start_y = top_to_bottom ? box.bottom() : box.top();
    if (WithinTestRegion(2, x_start, start_y))
    {
        tprintf("Column edges for blob at (%d,%d)->(%d,%d) are [%d, %d]\n", box.left(), box.top(), box.right(), box.bottom(), left_column_edge, right_column_edge);
    }

    // Compute skew tolerance.
    int skew_tolerance = p.max_v_gap / kMaxSkewFactor;

    // Calculate xmin and xmax of the search box so that it contains
    // all possibly relevant boxes upto p.max_v_gap above or below accoording
    // to top_to_bottom.
    // Start with a notion of vertical with the current estimate.
    int x2 = (p.max_v_gap * p.vertical.x() + p.vertical.y()/2) / p.vertical.y();
    if (top_to_bottom)
    {
        x2 = x_start - x2;
        *end_y = start_y - p.max_v_gap;
    }
    else
    {
        x2 = x_start + x2;
        *end_y = start_y + p.max_v_gap;
    }

    // Expand the box by an additional skew tolerance
    int xmin = MIN(x_start, x2) - skew_tolerance;
    int xmax = MAX(x_start, x2) + skew_tolerance;

    // Now add direction-specific tolerances.
    if (p.right_tab)
    {
        xmax += p.min_gutter;
        xmin -= p.l_align_tolerance;
    }
    else
    {
        xmax += p.r_align_tolerance;
        xmin -= p.min_gutter;
    }

    // Setup a vertical search for an aligned blob.
    GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> vsearch(this);
    if (WithinTestRegion(2, x_start, start_y))
    {
        tprintf("Starting %s %s search at %d-%d,%d, search_size=%d, gutter=%d\n", p.ragged ? "Ragged" : "Aligned",
                p.right_tab ? "Right" : "Left", xmin, xmax, start_y, p.max_v_gap, p.min_gutter);
    }

    vsearch.StartVerticalSearch(xmin, xmax, start_y);

    // result stores the best real return value.
    BLOBNBOX* result = NULL;

    // The backup_result is not a tab candidate and can be used if no
    // real tab candidate result is found.
    BLOBNBOX* backup_result = NULL;

    // neighbour is the blob that is currently being investigated.
    BLOBNBOX* neighbour = NULL;

    while ((neighbour = vsearch.NextVerticalSearch(top_to_bottom)) != NULL)
    {
        if (neighbour == bbox) continue;

        TBOX nbox = neighbour->bounding_box();
        int n_y = (nbox.top() + nbox.bottom()) / 2;

        if ((!top_to_bottom && n_y > start_y + p.max_v_gap) || (top_to_bottom && n_y < start_y - p.max_v_gap))
        {
            if (WithinTestRegion(2, x_start, start_y)) tprintf("Neighbour too far at (%d,%d)->(%d,%d)\n", nbox.left(), nbox.bottom(), nbox.right(), nbox.top());
            {
                break;  // Gone far enough.
            }
        }

        // It is CRITICAL to ensure that forward progress is made, (strictly
        // in/decreasing n_y) or the caller could loop infinitely, while
        // waiting for a sequence of blobs in a line to end.
        // NextVerticalSearch alone does not guarantee this, as there may be
        // more than one blob in a grid cell. See comment in AlignTabs.
        if ((n_y < start_y) != top_to_bottom || n_y == start_y) continue;  // Only look in the required direction.

        if (result != NULL && ((top_to_bottom && n_y < result->bounding_box().bottom()) || (!top_to_bottom && n_y > result->bounding_box().top())))
        {
            return result;  // This result is clear.
        }

        if (backup_result != NULL && p.ragged && ((top_to_bottom && n_y < backup_result->bounding_box().bottom()) || (!top_to_bottom && n_y > backup_result->bounding_box().top())))
        {
            return backup_result;  // This result is clear.
        }

        // If the neighbouring blob is the wrong side of a separator line, then it
        // "doesn't exist" as far as we are concerned.
        int x_at_n_y = x_start + (n_y - start_y) * p.vertical.x() / p.vertical.y();
        if (x_at_n_y < neighbour->left_crossing_rule() || x_at_n_y > neighbour->right_crossing_rule())
        {
            continue;  // Separator line in the way.
        }

        int n_left = nbox.left();
        int n_right = nbox.right();
        int n_x = p.right_tab ? n_right : n_left;
        if (WithinTestRegion(2, x_start, start_y))
        {
            tprintf("neighbour at (%d,%d)->(%d,%d), n_x=%d, n_y=%d, xatn=%d\n", nbox.left(), nbox.bottom(), nbox.right(), nbox.top(), n_x, n_y, x_at_n_y);
        }

        if (p.right_tab && n_left < x_at_n_y + p.min_gutter && n_right > x_at_n_y + p.r_align_tolerance &&
                (p.ragged || n_left < x_at_n_y + p.gutter_fraction * nbox.height()))
        {
            // In the gutter so end of line.
            if (bbox->right_tab_type() >= TT_UNCONFIRMED)
            {
                bbox->set_right_tab_type(TT_DELETED);
            }

            *end_y = top_to_bottom ? nbox.top() : nbox.bottom();

            if (WithinTestRegion(2, x_start, start_y)) tprintf("gutter\n");

            return NULL;
        }

        if (!p.right_tab && n_left < x_at_n_y - p.l_align_tolerance && n_right > x_at_n_y - p.min_gutter &&
                (p.ragged || n_right > x_at_n_y - p.gutter_fraction * nbox.height()))
        {
            // In the gutter so end of line.
            if (bbox->left_tab_type() >= TT_UNCONFIRMED)
            {
                bbox->set_left_tab_type(TT_DELETED);
            }

            *end_y = top_to_bottom ? nbox.top() : nbox.bottom();

            if (WithinTestRegion(2, x_start, start_y))  tprintf("gutter\n");

            return NULL;
        }

        if (n_x <= x_at_n_y + p.r_align_tolerance && n_x >= x_at_n_y - p.l_align_tolerance)
        {
            // Aligned so keep it. If it is a marked tab save it as result,
            // otherwise keep it as backup_result to return in case of later failure.
            if (WithinTestRegion(2, x_start, start_y))
            {
                tprintf("aligned, seeking%d, l=%d, r=%d\n", p.right_tab, neighbour->left_tab_type(), neighbour->right_tab_type());
            }

            if ((p.right_tab && neighbour->right_tab_type() != TT_NONE) || (!p.right_tab && neighbour->left_tab_type() != TT_NONE))
            {
                if (result == NULL)
                {
                    result = neighbour;
                }
                else
                {
                    // Keep the closest neighbour.
                    int old_y = (result->bounding_box().top() + result->bounding_box().bottom()) / 2;

                    if (abs(n_y - start_y) < abs(old_y - start_y))
                    {
                        result = neighbour;
                    }
                }
            }
            else if (backup_result == NULL)
            {
                if (WithinTestRegion(2, x_start, start_y)) tprintf("Backup\n");
                backup_result = neighbour;
            }
            else
            {
                TBOX backup_box = backup_result->bounding_box();
                if ((p.right_tab && backup_box.right() < nbox.right()) || (!p.right_tab && backup_box.left() > nbox.left()))
                {
                    if (WithinTestRegion(2, x_start, start_y)) tprintf("Better backup\n");
                    {
                        backup_result = neighbour;
                    }
                }
            }
        }
    }

    return result != NULL ? result : backup_result;
}
/////////////////////////////////////////////////////////////////alignedblob////////////////////////////////////////

/////////////////////////////////////////////////////////////////detlinefit////////////////////////////////////////
// The number of points to consider at each end.
const int kNumEndPoints = 3;

DetLineFit::DetLineFit() {
}

DetLineFit::~DetLineFit() {
}

// Delete all Added points.
void DetLineFit::Clear() {
  pt_list_.clear();
}

// Add a new point. Takes a copy - the pt doesn't need to stay in scope.
void DetLineFit::Add(const ICOORD& pt) {
  ICOORDELT_IT it = &pt_list_;
  ICOORDELT* new_pt = new ICOORDELT(pt);
  it.add_to_end(new_pt);
}

// Fit a line to the points, returning the fitted line as a pair of
// points, and the upper quartile error.
double DetLineFit::Fit(ICOORD* pt1, ICOORD* pt2) {
  ICOORDELT_IT it(&pt_list_);
  // Do something sensible with no points.
  if (pt_list_.empty()) {
    pt1->set_x(0);
    pt1->set_y(0);
    *pt2 = *pt1;
    return 0.0;
  }
  // Count the points and find the first and last kNumEndPoints.
  ICOORD* starts[kNumEndPoints];
  ICOORD* ends[kNumEndPoints];
  int pt_count = 0;
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    if (pt_count < kNumEndPoints) {
      starts[pt_count] = it.data();
      ends[pt_count] = starts[pt_count];
    } else {
      for (int i = 1; i < kNumEndPoints; ++i)
        ends[i - 1] = ends[i];
      ends[kNumEndPoints - 1] = it.data();
    }
    ++pt_count;
  }
  // 1 or 2 points need special treatment.
  if (pt_count <= 2) {
    *pt1 = *starts[0];
    if (pt_count > 1)
      *pt2 = *starts[1];
    else
      *pt2 = *pt1;
    return 0.0;
  }
  int end_count = MIN(pt_count, kNumEndPoints);
  int* distances = new int[pt_count];
  double best_uq = -1.0;
  // Iterate each pair of points and find the best fitting line.
  for (int i = 0; i < end_count; ++i) {
    ICOORD* start = starts[i];
    for (int j = 0; j < end_count; ++j) {
      ICOORD* end = ends[j];
      if (start != end) {
        // Compute the upper quartile error from the line.
        double dist = ComputeErrors(*start, *end, distances);
        if (dist < best_uq || best_uq < 0.0) {
          best_uq = dist;
          *pt1 = *start;
          *pt2 = *end;
        }
      }
    }
  }
  delete [] distances;
  // Finally compute the square root to return the true distance.
  return best_uq > 0.0 ? sqrt(best_uq) : best_uq;
}

// Comparator function used by the nth_item funtion.
static int CompareInts(const void *p1, const void *p2) {
  const int* i1 = reinterpret_cast<const int*>(p1);
  const int* i2 = reinterpret_cast<const int*>(p2);

  return *i1 - *i2;
}

// Compute all the cross product distances of the points from the line
// and return the true squared upper quartile distance.
double DetLineFit::ComputeErrors(const ICOORD start, const ICOORD end,
                                 int* distances) {
  ICOORDELT_IT it(&pt_list_);
  ICOORD line_vector = end;
  line_vector -= start;
  // Compute the distance of each point from the line.
  int pt_index = 0;
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ICOORD pt_vector = *it.data();
    pt_vector -= start;
    // Compute |line_vector||pt_vector|sin(angle between)
    int dist = line_vector * pt_vector;
    if (dist < 0)
      dist = -dist;
    distances[pt_index++] = dist;
  }
  // Now get the upper quartile distance.
  int index = choose_nth_item(3 * pt_index / 4, distances, pt_index,
                              sizeof(distances[0]), CompareInts);
  double dist = distances[index];
  // The true distance is the square root of the dist squared / the
  // squared length of line_vector (which is the dot product with itself)
  // Don't bother with the square root. Just return the square distance.
  return dist * dist / (line_vector % line_vector);
}
/////////////////////////////////////////////////////////////////detlinefit////////////////////////////////////////

/////////////////////////////////////////////////////////////////tabfind///////////////////////////////////////
BOOL_VAR(textord_tabfind_show_initialtabs, false, "Show tab candidates");
BOOL_VAR(textord_tabfind_show_finaltabs, false, "Show tab vectors");
BOOL_VAR(textord_tabfind_vertical_text, true, "Enable vertical detection");

TabFind::TabFind(int gridsize, const ICOORD& bleft, const ICOORD& tright,
                 TabVector_LIST* vlines, int vertical_x, int vertical_y)
  : AlignedBlob(gridsize, bleft, tright),
    image_origin_(0, tright.y() - 1),
    tab_grid_(new BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT>(gridsize,
                                                                  bleft,
                                                                  tright)) {
  resolution_ = 0;
  width_cb_ = NULL;
  v_it_.set_to_list(&vectors_);
  v_it_.add_list_after(vlines);
  SetVerticalSkewAndParellelize(vertical_x, vertical_y);
  width_cb_ = NewPermanentCallback(this, &TabFind::CommonWidth);
}

TabFind::~TabFind() {
  delete tab_grid_;
  if (width_cb_ != NULL)
    delete width_cb_;
}

///////////////// PUBLIC functions (mostly used by TabVector). //////////////

// Insert a list of blobs into the given grid (not necessarily this).
// If take_ownership is true, then the blobs are removed from the source list.
// See InsertBlob for the other arguments.
void TabFind::InsertBlobList(bool h_spread, bool v_spread, bool large,
                             BLOBNBOX_LIST* blobs, bool take_ownership,
                             BBGrid<BLOBNBOX, BLOBNBOX_CLIST,
                                    BLOBNBOX_C_IT>* grid) {
  BLOBNBOX_IT blob_it(blobs);
  int b_count = 0;
  int reject_count = 0;
  for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
    BLOBNBOX* blob = blob_it.data();
    if (InsertBlob(h_spread, v_spread, large, blob, grid)) {
      ++b_count;
    } else {
      ++reject_count;
    }
    if (take_ownership)
      blob_it.extract();
  }
  if (textord_debug_tabfind) {
    if (large)
      tprintf("Inserted %d large blobs into grid, %d rejected\n",
              b_count, reject_count);
    else
      tprintf("Inserted %d normal blobs into grid\n", b_count);
  }
}

// Insert a single blob into the given grid (not necessarily this).
// If h_spread, then all cells covered horizontally by the box are
// used, otherwise, just the bottom-left. Similarly for v_spread.
// If large, then insert only if the bounding box doesn't intersect
// anything else already in the grid. Returns true if the blob was inserted.
// A side effect is that the left and right rule edges of the blob are
// set according to the tab vectors in this (not grid).
bool TabFind::InsertBlob(bool h_spread, bool v_spread, bool large,
                         BLOBNBOX* blob,
                         BBGrid<BLOBNBOX, BLOBNBOX_CLIST,
                                BLOBNBOX_C_IT>* grid) {
  TBOX box = blob->bounding_box();
  blob->set_left_rule(LeftEdgeForBox(box, false, false));
  blob->set_right_rule(RightEdgeForBox(box, false, false));
  blob->set_left_crossing_rule(LeftEdgeForBox(box, true, false));
  blob->set_right_crossing_rule(RightEdgeForBox(box, true, false));
  if (large) {
    // Search the grid to see what intersects it.
    // Setup a Rectangle search for overlapping this blob.
    GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> rsearch(grid);
    rsearch.StartRectSearch(box);
    BLOBNBOX* neighbour = rsearch.NextRectSearch();
    if (neighbour != NULL && box.major_overlap(neighbour->bounding_box())) {
      if (textord_debug_tabfind) {
        TBOX n_box = neighbour->bounding_box();
        tprintf("Blob at (%d,%d)->(%d,%d) significantly overlaps blob"
                " at (%d,%d)->(%d,%d)\n",
                box.left(), box.top(), box.right(), box.bottom(),
                n_box.left(), n_box.top(), n_box.right(), n_box.bottom());
      }
      return false;
    }
  }
  grid->InsertBBox(h_spread, v_spread, blob);
  return true;
}

// Find the gutter width and distance to inner neighbour for the given blob.
void TabFind::GutterWidthAndNeighbourGap(int tab_x, int mean_height,
                                         int max_gutter, bool left,
                                         BLOBNBOX* bbox, int* gutter_width,
                                         int* neighbour_gap )
{
    Q_UNUSED(mean_height);
  const TBOX& box = bbox->bounding_box();
  int height = box.height();
  // The gutter and internal sides of the box.
  int gutter_x = left ? box.left() : box.right();
  int internal_x = left ? box.right() : box.left();
  // On ragged edges, the gutter side of the box is away from the tabstop.
  int tab_gap = left ? gutter_x - tab_x : tab_x - gutter_x;
  *gutter_width = max_gutter;
  // If the box is away from the tabstop, we need to increase
  // the allowed gutter width.
  if (tab_gap > 0)
    *gutter_width += tab_gap;
  // Find the nearest blob on the outside of the column.
  BLOBNBOX* gutter_bbox = AdjacentBlob(bbox, left, *gutter_width);
  if (gutter_bbox != NULL) {
    TBOX gutter_box = gutter_bbox->bounding_box();
    *gutter_width = left ? tab_x - gutter_box.right()
                        : gutter_box.left() - tab_x;
  }
  if (*gutter_width >= max_gutter) {
    // If there is no box because a tab was in the way, get the tab coord.
    TBOX gutter_box(box);
    if (left) {
      gutter_box.set_left(tab_x - max_gutter - 1);
      gutter_box.set_right(tab_x - max_gutter);
      int tab_gutter = RightEdgeForBox(gutter_box, true, false);
      if (tab_gutter < tab_x - 1)
        *gutter_width = tab_x - tab_gutter;
    } else {
      gutter_box.set_left(tab_x + max_gutter);
      gutter_box.set_right(tab_x + max_gutter + 1);
      int tab_gutter = LeftEdgeForBox(gutter_box, true, false);
      if (tab_gutter > tab_x + 1)
        *gutter_width = tab_gutter - tab_x;
    }
  }
  if (*gutter_width > max_gutter)
    *gutter_width = max_gutter;
  // Now look for a neighbour on the inside.
  BLOBNBOX* neighbour = AdjacentBlob(bbox, !left, *gutter_width);
  int neighbour_edge = left ? RightEdgeForBox(box, true, false)
                            : LeftEdgeForBox(box, true, false);
  if (neighbour != NULL) {
    TBOX n_box = neighbour->bounding_box();
    if (!DifferentSizes(height, n_box.height())) {
      if (left && n_box.left() < neighbour_edge)
        neighbour_edge = n_box.left();
      else if (!left && n_box.right() > neighbour_edge)
        neighbour_edge = n_box.right();
    }
  }
  *neighbour_gap = left ? neighbour_edge - internal_x
                        : internal_x - neighbour_edge;
}

// Find the next adjacent (to left or right) blob on this text line,
// with the constraint that it must vertically significantly overlap
// the input box.
BLOBNBOX* TabFind::AdjacentBlob(const BLOBNBOX* bbox,
                                bool right_to_left, int gap_limit) {
  const TBOX& box = bbox->bounding_box();
  return AdjacentBlob(bbox, right_to_left, false, gap_limit,
                      box.top(), box.bottom());
}

// Compute and return, but do not set the type as being BRT_TEXT or
// BRT_UNKNOWN according to how well it forms a text line.
BlobRegionType TabFind::ComputeBlobType(BLOBNBOX* blob) {
  // Check the text line width.
  TBOX box = blob->bounding_box();
  int blob_count;
  int total_blobs;
  int width = FindTextlineWidth(true, blob, &total_blobs);
  width += FindTextlineWidth(false, blob, &blob_count);
  total_blobs += blob_count - 1;
  int target_ratio = kMaxTextLineBlobRatio - (total_blobs - 1);
  if (target_ratio < kMinTextLineBlobRatio)
    target_ratio = kMinTextLineBlobRatio;
  BlobRegionType blob_type = (width >= box.height() * target_ratio)
                           ? BRT_TEXT : BRT_UNKNOWN;
  if (WithinTestRegion(3, box.left(), box.bottom()))
    tprintf("Line width = %d, target = %d, result = %d\n",
            width, box.height() * target_ratio, blob_type);
  return blob_type;
}

// Return the x-coord that corresponds to the right edge for the given
// box. If there is a rule line to the right that vertically overlaps it,
// then return the x-coord of the rule line, otherwise return the right
// edge of the page. For details see RightTabForBox below.
int TabFind::RightEdgeForBox(const TBOX& box, bool crossing, bool extended) {
  TabVector* v = RightTabForBox(box, crossing, extended);
  return v == NULL ? tright_.x() : v->XAtY((box.top() + box.bottom()) / 2);
}
// As RightEdgeForBox, but finds the left Edge instead.
int TabFind::LeftEdgeForBox(const TBOX& box, bool crossing, bool extended) {
  TabVector* v = LeftTabForBox(box, crossing, extended);
  return v == NULL ? bleft_.x() : v->XAtY((box.top() + box.bottom()) / 2);
}

// Return true if the given width is close to one of the common
// widths in column_widths_.
bool TabFind::CommonWidth(int width) {
  width /= kColumnWidthFactor;
  ICOORDELT_IT it(&column_widths_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ICOORDELT* w = it.data();
    if (NearlyEqual<int>(width, w->x(), 1))
      return true;
  }
  return false;
}

// Return true if the sizes are more than a
// factor of 2 different.
bool TabFind::DifferentSizes(int size1, int size2) {
  return size1 > size2 * 2 || size2 > size1 * 2;
}

///////////////// PROTECTED functions (used by ColumnFinder). //////////////

// Top-level function to find TabVectors in an input page block.
void TabFind::FindTabVectors(int resolution, TabVector_LIST* hlines,
                             BLOBNBOX_LIST* image_blobs, TO_BLOCK* block,
                             FCOORD* reskew, FCOORD* rerotate) {
  resolution_ = resolution;
  *rerotate = FCOORD(1.0f, 0.0f);
  FindInitialTabVectors(image_blobs, block);
  if (textord_tabfind_vertical_text && TextMostlyVertical()) {
    ResetForVerticalText(hlines, image_blobs, block, rerotate);
    FindInitialTabVectors(image_blobs, block);
  }
  TabVector::MergeSimilarTabVectors(vertical_skew_, &vectors_, this);
  SortVectors();
  CleanupTabs();
  Deskew(hlines, image_blobs, block, reskew);
  ApplyTabConstraints();
  if (textord_tabfind_show_finaltabs) {
    ScrollView* tab_win = MakeWindow(640, 50, "FinalTabs");
    if (textord_debug_images) {
      tab_win->Image(AlignedBlob::textord_debug_pix().string(),
                     image_origin_.x(), image_origin_.y());
    } else {
      DisplayBoxes(tab_win);
      DisplayTabs("FinalTabs", tab_win);
    }
    tab_win = DisplayTabVectors(tab_win);
  }
}

// Top-level function to not find TabVectors in an input page block,
// but setup for single column mode.
void TabFind::DontFindTabVectors(int resolution, BLOBNBOX_LIST* image_blobs,
                                 TO_BLOCK* block, FCOORD* reskew) {
  resolution_ = resolution;
  InsertBlobList(false, false, false, image_blobs, false, this);
  InsertBlobList(true, false, false, &block->blobs, false, this);
  ComputeBlobGoodness();
  reskew->set_x(1);
  reskew->set_y(0);
}

// This comment documents how this function works.
// For its purpose and arguments, see the comment in tabfind.h.
// TabVectors are stored sorted by perpendicular distance of middle from
// the global mean vertical vector. Since the individual vectors can have
// differing directions, their XAtY for a given y is not necessarily in the
// right order. Therefore the search has to be run with a margin.
// The middle of a vector that passes through (x,y) cannot be higher than
// halfway from y to the top, or lower than halfway from y to the bottom
// of the coordinate range; therefore, the search margin is the range of
// sort keys between these halfway points. Any vector with a sort key greater
// than the upper margin must be to the right of x at y, and likewise any
// vector with a sort key less than the lower margin must pass to the left
// of x at y.
TabVector* TabFind::RightTabForBox(const TBOX& box, bool crossing,
                                   bool extended) {
  if (v_it_.empty())
    return NULL;
  int top_y = box.top();
  int bottom_y = box.bottom();
  int mid_y = (top_y + bottom_y) / 2;
  int right = crossing ? (box.left() + box.right()) / 2 : box.right();
  int min_key, max_key;
  SetupTabSearch(right, mid_y, &min_key, &max_key);
  // Position the iterator at the first TabVector with sort_key >= min_key.
  while (!v_it_.at_first() && v_it_.data()->sort_key() >= min_key)
    v_it_.backward();
  while (!v_it_.at_last() && v_it_.data()->sort_key() < min_key)
    v_it_.forward();
  // Find the leftmost tab vector that overlaps and has XAtY(mid_y) >= right.
  TabVector* best_v = NULL;
  int best_x = -1;
  int key_limit = -1;
  do {
    TabVector* v = v_it_.data();
    int x = v->XAtY(mid_y);
    if (x >= right &&
        (v->VOverlap(top_y, bottom_y) > 0 ||
         (extended && v->ExtendedOverlap(top_y, bottom_y) > 0))) {
      if (best_v == NULL || x < best_x) {
        best_v = v;
        best_x = x;
        // We can guarantee that no better vector can be found if the
        // sort key exceeds that of the best by max_key - min_key.
        key_limit = v->sort_key() + max_key - min_key;
      }
    }
    // Break when the search is done to avoid wrapping the iterator and
    // thereby potentially slowing the next search.
    if (v_it_.at_last() ||
        (best_v != NULL && v->sort_key() > key_limit))
      break;  // Prevent restarting list for next call.
    v_it_.forward();
  } while (!v_it_.at_first());
  return best_v;
}

// As RightTabForBox, but finds the left TabVector instead.
TabVector* TabFind::LeftTabForBox(const TBOX& box, bool crossing,
                                  bool extended) {
  if (v_it_.empty())
    return NULL;
  int top_y = box.top();
  int bottom_y = box.bottom();
  int mid_y = (top_y + bottom_y) / 2;
  int left = crossing ? (box.left() + box.right()) / 2 : box.left();
  int min_key, max_key;
  SetupTabSearch(left, mid_y, &min_key, &max_key);
  // Position the iterator at the last TabVector with sort_key <= max_key.
  while (!v_it_.at_last() && v_it_.data()->sort_key() <= max_key)
    v_it_.forward();
  while (!v_it_.at_first() && v_it_.data()->sort_key() > max_key) {
    v_it_.backward();
  }
  // Find the rightmost tab vector that overlaps and has XAtY(mid_y) <= left.
  TabVector* best_v = NULL;
  int best_x = -1;
  int key_limit = -1;
  do {
    TabVector* v = v_it_.data();
    int x = v->XAtY(mid_y);
    if (x <= left &&
        (v->VOverlap(top_y, bottom_y) > 0 ||
         (extended && v->ExtendedOverlap(top_y, bottom_y) > 0))) {
      if (best_v == NULL || x > best_x) {
        best_v = v;
        best_x = x;
        // We can guarantee that no better vector can be found if the
        // sort key is less than that of the best by max_key - min_key.
        key_limit = v->sort_key() - (max_key - min_key);
      }
    }
    // Break when the search is done to avoid wrapping the iterator and
    // thereby potentially slowing the next search.
    if (v_it_.at_first() ||
        (best_v != NULL && v->sort_key() < key_limit))
      break;  // Prevent restarting list for next call.
    v_it_.backward();
  } while (!v_it_.at_last());
  return best_v;
}

// Helper function to setup search limits for *TabForBox.
void TabFind::SetupTabSearch(int x, int y, int* min_key, int* max_key) {
  int key1 = TabVector::SortKey(vertical_skew_, x, (y + tright_.y()) / 2);
  int key2 = TabVector::SortKey(vertical_skew_, x, (y + bleft_.y()) / 2);
  *min_key = MIN(key1, key2);
  *max_key = MAX(key1, key2);
}

ScrollView* TabFind::DisplayTabVectors(ScrollView* tab_win) {
#ifndef GRAPHICS_DISABLED
  // For every vector, display it.
  TabVector_IT it(&vectors_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    TabVector* vector = it.data();
    vector->Display(tab_win);
  }
  tab_win->Update();
#endif
  return tab_win;
}

// PRIVATE CODE.
//
// First part of FindTabVectors, which may be used twice if the text
// is mostly of vertical alignment.
void TabFind::FindInitialTabVectors(BLOBNBOX_LIST* image_blobs,
                                    TO_BLOCK* block) {
  if (textord_tabfind_show_initialtabs) {
    ScrollView* line_win = MakeWindow(0, 0, "VerticalLines");
    line_win = DisplayTabVectors(line_win);
  }
  // Prepare the grid.
  InsertBlobList(false, false, false, image_blobs, false, this);
  InsertBlobList(true, false, false, &block->blobs, false, this);
  ScrollView* initial_win = FindTabBoxes();
  FindAllTabVectors();
  if (textord_tabfind_show_initialtabs)
    initial_win = DisplayTabVectors(initial_win);

  TabVector::MergeSimilarTabVectors(vertical_skew_, &vectors_, this);
  SortVectors();
  EvaluateTabs();
  ComputeColumnWidths(initial_win);
  if (textord_tabfind_vertical_text)
    MarkVerticalText();
}

// For each box in the grid, decide whether it is a candidate tab-stop,
// and if so add it to the tab_grid_.
ScrollView* TabFind::FindTabBoxes() {
  // For every bbox in the grid, determine whether it uses a tab on an edge.
  GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> gsearch(this);
  gsearch.StartFullSearch();
  BLOBNBOX* bbox;
  while ((bbox = gsearch.NextFullSearch()) != NULL) {
    if (TestBoxForTabs(bbox)) {
      // If it is any kind of tab, insert it into the tab grid.
      tab_grid_->InsertBBox(false, false, bbox);
    }
  }
  ScrollView* tab_win = NULL;
  if (textord_tabfind_show_initialtabs) {
    tab_win = tab_grid_->MakeWindow(0, 100, "InitialTabs");
    tab_grid_->DisplayBoxes(tab_win);
    tab_win = DisplayTabs("Tabs", tab_win);
  }
  return tab_win;
}

bool TabFind::TestBoxForTabs(BLOBNBOX* bbox) {
  GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> radsearch(this);
  TBOX box = bbox->bounding_box();
  // If there are separator lines, get the column edges.
  int left_column_edge = bbox->left_rule();
  int right_column_edge = bbox->right_rule();
  // The edges of the bounding box of the blob being processed.
  int left_x = box.left();
  int right_x = box.right();
  int top_y = box.top();
  int bottom_y = box.bottom();
  int height = box.height();
  bool debug = WithinTestRegion(3, left_x, top_y);
  if (debug) {
    tprintf("Column edges for blob at (%d,%d)->(%d,%d) are [%d, %d]\n",
            left_x, top_y, right_x, bottom_y,
            left_column_edge, right_column_edge);
  }
  // Compute a search radius based on a multiple of the height.
  int radius = (height * kTabRadiusFactor + gridsize_ - 1) / gridsize_;
  radsearch.StartRadSearch((left_x + right_x)/2, (top_y + bottom_y)/2, radius);
  int target_right = left_x - height * kAlignedGapFraction;
  int target_left = right_x + height * kAlignedGapFraction;
  // We will be evaluating whether the left edge could be a left tab, and
  // whether the right edge could be a right tab.
  // A box can be a tab if its bool is_(left/right)_tab remains true, meaning
  // that no blobs have been found in the gutter during the radial search.
  // A box can also be a tab if there are objects in the gutter only above
  // or only below, and there are aligned objects on the opposite side, but
  // not too many unaligned objects. The maybe_(left/right)_tab_up counts
  // aligned objects above and negatively counts unaligned objects above,
  // and is set to -MAX_INT32 if a gutter object is found above.
  // The other 3 maybe ints work similarly for the other sides.
  bool is_left_tab = true;
  bool is_right_tab = true;
  int maybe_left_tab_up = 0;
  int maybe_right_tab_up = 0;
  int maybe_left_tab_down = 0;
  int maybe_right_tab_down = 0;
  int alignment_tolerance = static_cast<int>(resolution_ * kAlignedFraction);
  BLOBNBOX* neighbour = NULL;
  while ((neighbour = radsearch.NextRadSearch()) != NULL) {
    if (neighbour == bbox)
      continue;
    TBOX nbox = neighbour->bounding_box();
    int n_left = nbox.left();
    int n_right = nbox.right();
    if (debug)
      tprintf("Neighbour at (%d,%d)->(%d,%d)\n",
              n_left, nbox.bottom(), n_right, nbox.top());
    // If the neighbouring blob is the wrong side of a separator line, then it
    // "doesn't exist" as far as we are concerned.
    if (n_right > right_column_edge || n_left < left_column_edge ||
        left_x < neighbour->left_rule() || right_x > neighbour->right_rule())
      continue;  // Separator line in the way.
    int n_mid_x = (n_left + n_right) / 2;
    int n_mid_y = (nbox.top() + nbox.bottom()) / 2;
    if (n_mid_x <= left_x && n_right >= target_right) {
      if (debug)
        tprintf("Not a left tab\n");
      is_left_tab = false;
      if (n_mid_y < top_y)
        maybe_left_tab_down = -MAX_INT32;
      if (n_mid_y > bottom_y)
        maybe_left_tab_up = -MAX_INT32;
    } else if (NearlyEqual(left_x, n_left, alignment_tolerance)) {
      if (debug)
        tprintf("Maybe a left tab\n");
      if (n_mid_y > top_y && maybe_left_tab_up > -MAX_INT32)
        ++maybe_left_tab_up;
      if (n_mid_y < bottom_y && maybe_left_tab_down > -MAX_INT32)
        ++maybe_left_tab_down;
    } else if (n_left < left_x && n_right >= left_x) {
      // Overlaps but not aligned so negative points on a maybe.
      if (debug)
        tprintf("Maybe Not a left tab\n");
      if (n_mid_y > top_y && maybe_left_tab_up > -MAX_INT32)
        --maybe_left_tab_up;
      if (n_mid_y < bottom_y && maybe_left_tab_down > -MAX_INT32)
        --maybe_left_tab_down;
    }
    if (n_mid_x >= right_x && n_left <= target_left) {
      if (debug)
        tprintf("Not a right tab\n");
      is_right_tab = false;
      if (n_mid_y < top_y)
        maybe_right_tab_down = -MAX_INT32;
      if (n_mid_y > bottom_y)
        maybe_right_tab_up = -MAX_INT32;
    } else if (NearlyEqual(right_x, n_right, alignment_tolerance)) {
      if (debug)
        tprintf("Maybe a right tab\n");
      if (n_mid_y > top_y && maybe_right_tab_up > -MAX_INT32)
        ++maybe_right_tab_up;
      if (n_mid_y < bottom_y && maybe_right_tab_down > -MAX_INT32)
        ++maybe_right_tab_down;
    } else if (n_right > right_x && n_left <= right_x) {class DetLineFit {
        public:
         DetLineFit();
         ~DetLineFit();

         // Delete all Added points.
         void Clear();

         // Add a new point. Takes a copy - the pt doesn't need to stay in scope.
         // Add must be called on points in sequence along the line.
         void Add(const ICOORD& pt);

         // Fit a line to the points, returning the fitted line as a pair of
         // points, and the upper quartile error.
         double Fit(ICOORD* pt1, ICOORD* pt2);

        private:
         double ComputeErrors(const ICOORD start, const ICOORD end, int* distances);

         ICOORDELT_LIST pt_list_;  // All the added points.
       };
      // Overlaps but not aligned so negative points on a maybe.
      if (debug)
        tprintf("Maybe Not a right tab\n");
      if (n_mid_y > top_y && maybe_right_tab_up > -MAX_INT32)
        --maybe_right_tab_up;
      if (n_mid_y < bottom_y && maybe_right_tab_down > -MAX_INT32)
        --maybe_right_tab_down;
    }
    if (maybe_left_tab_down == -MAX_INT32 && maybe_left_tab_up == -MAX_INT32 &&
        maybe_right_tab_down == -MAX_INT32 && maybe_right_tab_up == -MAX_INT32)
      break;
  }
  if (is_left_tab || maybe_left_tab_up > 1 || maybe_left_tab_down > 1) {
    if (debug)
      tprintf("Setting left tab\n");
    bbox->set_left_tab_type(TT_UNCONFIRMED);
  }
  if (is_right_tab || maybe_right_tab_up > 1 || maybe_right_tab_down > 1) {
    if (debug)
      tprintf("Setting right tab\n");
    bbox->set_right_tab_type(TT_UNCONFIRMED);
  }
  return bbox->left_tab_type() != TT_NONE || bbox->right_tab_type() != TT_NONE;
}

void TabFind::FindAllTabVectors() {
  // A list of vectors that will be created in estimating the skew.
  TabVector_LIST dummy_vectors;
  // An estimate of the vertical direction, revised as more lines are added.
  int vertical_x = 0;
  int vertical_y = 1;
  // Find an estimate of the vertical direction by finding some tab vectors.
  // Slowly up the search size until we get some vectors.
  for (int search_size = kMinVerticalSearch; search_size < kMaxVerticalSearch;
       search_size += kMinVerticalSearch) {
    int vector_count = FindTabVectors(search_size, TA_LEFT_ALIGNED,
                                      &dummy_vectors,
                                      &vertical_x, &vertical_y);
    vector_count += FindTabVectors(search_size, TA_RIGHT_ALIGNED,
                                   &dummy_vectors,
                                   &vertical_x, &vertical_y);
    if (vector_count > 0)
      break;
  }
  // Get rid of the test vectors and reset the types of the tabs.
  dummy_vectors.clear();
  GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> tsearch(tab_grid_);
  BLOBNBOX* bbox;
  tsearch.StartFullSearch();
  while ((bbox = tsearch.NextFullSearch()) != NULL) {
    if (bbox->left_tab_type() == TT_CONFIRMED)
      bbox->set_left_tab_type(TT_UNCONFIRMED);
    if (bbox->right_tab_type() == TT_CONFIRMED)
      bbox->set_right_tab_type(TT_UNCONFIRMED);
  }
  if (textord_debug_tabfind) {
    tprintf("Beginning real tab search with vertical = %d,%d...\n",
            vertical_x, vertical_y);
  }
  // Now do the real thing ,but keep the vectors in the dummy_vectors list
  // until they are all done, so we don't get the tab vectors confused with
  // the rule line vectors.
  FindTabVectors(kMaxVerticalSearch, TA_LEFT_ALIGNED,
                 &dummy_vectors, &vertical_x, &vertical_y);
  FindTabVectors(kMaxVerticalSearch, TA_RIGHT_ALIGNED,
                 &dummy_vectors, &vertical_x, &vertical_y);
  FindTabVectors(kMaxRaggedSearch, TA_LEFT_RAGGED,
                 &dummy_vectors, &vertical_x, &vertical_y);
  FindTabVectors(kMaxRaggedSearch, TA_RIGHT_RAGGED,
                 &dummy_vectors, &vertical_x, &vertical_y);
  // Now add the vectors to the vectors_ list.
  TabVector_IT v_it(&vectors_);
  v_it.add_list_after(&dummy_vectors);
  // Now use the summed (mean) vertical vector as the direction for everything.
  SetVerticalSkewAndParellelize(vertical_x, vertical_y);
}

// Helper for FindAllTabVectors finds the vectors of a particular type.
int TabFind::FindTabVectors(int search_size_multiple, TabAlignment alignment,
                            TabVector_LIST* vectors,
                            int* vertical_x, int* vertical_y) {
  TabVector_IT vector_it(vectors);
  int vector_count = 0;
  // Search the entire tab grid, looking for tab vectors.
  GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> tsearch(tab_grid_);
  BLOBNBOX* bbox;
  tsearch.StartFullSearch();
  bool right = alignment == TA_RIGHT_ALIGNED || alignment == TA_RIGHT_RAGGED;
  while ((bbox = tsearch.NextFullSearch()) != NULL) {
    if ((!right && bbox->left_tab_type() == TT_UNCONFIRMED) ||
        (right && bbox->right_tab_type() == TT_UNCONFIRMED)) {
      TabVector* vector = FindTabVector(search_size_multiple, alignment,
                                        bbox, vertical_x, vertical_y);
      if (vector != NULL) {
        ++vector_count;
        vector_it.add_to_end(vector);
        ICOORD merged_vector = vector->endpt();
        merged_vector -= vector->startpt();
        if (abs(merged_vector.x()) > 100) {
          vector->Debug("Garbage result of FindTabVector?");
        }
      }
    }
  }
  return vector_count;
}

// Finds a vector corresponding to a tabstop running through the
// given box of the given alignment type.
// search_size_multiple is a multiple of height used to control
// the size of the search.
// vertical_x and y are updated with an estimate of the real
// vertical direction. (skew finding.)
// Returns NULL if no decent tabstop can be found.
TabVector* TabFind::FindTabVector(int search_size_multiple,
                                  TabAlignment alignment,
                                  BLOBNBOX* bbox,
                                  int* vertical_x, int* vertical_y) {
  AlignedBlobParams align_params(*vertical_x, *vertical_y,
                                 bbox->bounding_box().height(),
                                 search_size_multiple, resolution_,
                                 alignment);
  // FindVerticalAlignment is in the parent (AlignedBlob) class.
  return FindVerticalAlignment(align_params, bbox, vertical_x, vertical_y);
}

// Set the vertical_skew_ member from the given vector and refit
// all vectors parallel to the skew vector.
void TabFind::SetVerticalSkewAndParellelize(int vertical_x, int vertical_y) {
  // Fit the vertical vector into an ICOORD, which is 16 bit.
  vertical_skew_.set_with_shrink(vertical_x, vertical_y);
  if (textord_debug_tabfind)
    tprintf("Vertical skew vector=(%d,%d)\n",
            vertical_skew_.x(), vertical_skew_.y());
  v_it_.set_to_list(&vectors_);
  for (v_it_.mark_cycle_pt(); !v_it_.cycled_list(); v_it_.forward()) {
    TabVector* v = v_it_.data();
    v->Fit(vertical_skew_, true);
  }
  // Now sort the vectors as their direction has potentially changed.
  SortVectors();
}

// Sort all the current vectors using the given vertical direction vector.
void TabFind::SortVectors() {
  vectors_.sort(TabVector::SortVectorsByKey);
  v_it_.set_to_list(&vectors_);
}

// Evaluate all the current tab vectors.
void TabFind::EvaluateTabs() {
  TabVector_IT rule_it(&vectors_);
  for (rule_it.mark_cycle_pt(); !rule_it.cycled_list(); rule_it.forward()) {
    TabVector* tab = rule_it.data();
    if (!tab->IsSeparator()) {
      tab->Evaluate(vertical_skew_, this);
      if (tab->BoxCount() < kMinEvaluatedTabs) {
        if (textord_debug_tabfind > 2)
          tab->Print("Too few boxes");
        delete rule_it.extract();
        v_it_.set_to_list(&vectors_);
      } else if (WithinTestRegion(3, tab->startpt().x(), tab->startpt().y())) {
        tab->Print("Evaluated tab");
      }
    }
  }
}

// Trace textlines from one side to the other of each tab vector, saving
// the most frequent column widths found in a list so that a given width
// can be tested for being a common width with a simple callback function.
void TabFind::ComputeColumnWidths(ScrollView* tab_win) {
  // Set the aligned_text_ member of each blob, so text lines traces
  // get terminated where there is a change from text to image.
  ComputeBlobGoodness();
  if (tab_win != NULL)
    tab_win->Pen(ScrollView::WHITE);
  // Accumulate column sections into a STATS
  int col_widths_size = (tright_.x() - bleft_.x()) /kColumnWidthFactor;
  STATS col_widths(0, col_widths_size + 1);
  // For every bbox in the tab grid, search for an opposite
  // to estimate column width and skew..
  GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> gsearch(tab_grid_);
  gsearch.StartFullSearch();
  BLOBNBOX* bbox;
  while ((bbox = gsearch.NextFullSearch()) != NULL) {
    ICOORD start_pt, end_pt;
    if (bbox->left_tab_type() != TT_CONFIRMED &&
        bbox->right_tab_type() != TT_CONFIRMED)
      continue;
    int line_left, line_right;
    if (TraceTextline(bbox, &start_pt, &end_pt, &line_left, &line_right)) {
      int left_y = (line_left - start_pt.x()) * (end_pt.y() - start_pt.y()) /
               (end_pt.x() - start_pt.x()) + start_pt.y();
      int right_y = (line_right - start_pt.x()) * (end_pt.y() - start_pt.y()) /
                (end_pt.x() - start_pt.x()) + start_pt.y();
      if (start_pt.x() != end_pt.x()) {
        if (WithinTestRegion(3, start_pt.x(), start_pt.y()))
          tprintf("Baseline from (%d,%d) to (%d,%d), started at (%d,%d)\n",
                  line_left, left_y, line_right, right_y,
                  bbox->bounding_box().left(), bbox->bounding_box().bottom());
        if (tab_win != NULL)
          tab_win->Line(line_left, left_y, line_right, right_y);
        // If line scan was successful, add to STATS of measurements.
        int width = line_right - line_left;
        if (width >= kMinColumnWidth) {
          col_widths.add(width / kColumnWidthFactor, 1);
        }
      }
    }
  }
  if (tab_win != NULL) {
    tab_win->Update();
  }
  // Now make a list of column widths.
  ICOORDELT_IT w_it(&column_widths_);
  int total_col_count = col_widths.get_total();
  while (col_widths.get_total() > 0) {
    int width = col_widths.mode();
    int col_count = col_widths.pile_count(width);
    col_widths.add(width, -col_count);
    // Get the entire peak.
    for (int left = width - 1; left > 0 &&
         col_widths.pile_count(left) > 0;
         --left) {
      int new_count = col_widths.pile_count(left);
      col_count += new_count;
      col_widths.add(left, -new_count);
    }
    for (int right = width + 1; right < col_widths_size &&
         col_widths.pile_count(right) > 0;
         ++right) {
      int new_count = col_widths.pile_count(right);
      col_count += new_count;
      col_widths.add(right, -new_count);
    }
    if (col_count > kMinLinesInColumn &&
        col_count > kMinFractionalLinesInColumn * total_col_count) {
      ICOORDELT* w = new ICOORDELT(width, col_count);
      w_it.add_after_then_move(w);
      if (textord_debug_tabfind)
        tprintf("Column of width %d has %d = %.2f%% lines\n",
              width * kColumnWidthFactor, col_count,
              100.0 * col_count / total_col_count);
    }
  }
}

// Set the region_type_ member for all the blobs in the grid.
void TabFind::ComputeBlobGoodness() {
  GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> gsearch(this);
  gsearch.StartFullSearch();
  BLOBNBOX* bbox;
  while ((bbox = gsearch.NextFullSearch()) != NULL) {
    SetBlobRegionType(bbox);
  }
}

// Set the region_type_ member of the blob, if not already known.
void TabFind::SetBlobRegionType(BLOBNBOX* blob) {
  // If already set, just return the result.
  BlobRegionType blob_type = blob->region_type();
  if (blob_type != BRT_UNKNOWN)
    return;

  // Check for overlapping image blob or other blob already set to image.
  TBOX box = blob->bounding_box();
  GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> rectsearch(this);
  rectsearch.StartRectSearch(box);
  int rect_overlap = 0;
  int poly_overlap = 0;
  int text_overlap = 0;
  BLOBNBOX* neighbour;
  while ((neighbour = rectsearch.NextRectSearch()) != NULL) {
    if (neighbour != blob &&
        (blob_type = neighbour->region_type()) != BRT_UNKNOWN) {
      TBOX nbox = neighbour->bounding_box();
      nbox -= box;  // This is box intersection, not subtraction.
      int area = nbox.area();
      if (blob_type == BRT_RECTIMAGE) {
        rect_overlap += area;
      } else if (blob_type == BRT_POLYIMAGE) {
        poly_overlap += area;
      } else if (blob_type == BRT_TEXT) {
        text_overlap += area;
      }
    }
  }
  int area = box.area();
  rect_overlap -= text_overlap;
  poly_overlap -= text_overlap;
  if (rect_overlap >= area || poly_overlap >= area) {
    blob->set_region_type(BRT_NOISE);  // Make it disappear
  } else if (rect_overlap > area * kMinImageArea) {
    blob->set_region_type(BRT_RECTIMAGE);
  } else if (poly_overlap > area * kMinImageArea) {
    blob->set_region_type(BRT_POLYIMAGE);
  } else {
    // Actually check the text line width.
    blob->set_region_type(ComputeBlobType(blob));
  }
}

// Mark blobs as being in a vertical text line where that is the case.
// Returns true if the majority of the image is vertical text lines.
void TabFind::MarkVerticalText() {
  TabVector_IT it(&vectors_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    TabVector* v = it.data();
    TabVector* partner = v->VerticalTextlinePartner();
    if (partner != NULL) {
      TabVector* left = v->IsLeftTab() ? v : partner;
      TabVector* right = v->IsLeftTab() ? partner : v;
      // Setup a rectangle search to mark the text as vertical.
      TBOX box;
      box.set_left(MIN(left->startpt().x(), left->endpt().x()));
      box.set_right(MAX(right->startpt().x(), right->endpt().x()));
      box.set_bottom(MIN(left->startpt().y(), right->startpt().y()));
      box.set_top(MAX(left->endpt().y(), right->endpt().y()));

      GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> rsearch(this);
      rsearch.StartRectSearch(box);
      BLOBNBOX* blob = NULL;
      while ((blob = rsearch.NextRectSearch()) != NULL) {
        if (blob->region_type() < BRT_UNKNOWN)
          continue;
        const TBOX& blob_box = blob->bounding_box();
        if ((LeftTabForBox(blob_box, false, false) == left ||
             LeftTabForBox(blob_box, true, false) == left) &&
            (RightTabForBox(blob_box, false, false) == right ||
             RightTabForBox(blob_box, true, false) == right)) {
          blob->set_region_type(BRT_VERT_TEXT);
        }
      }
    }
  }
}

// Returns true if the majority of the image is vertical text lines.
bool TabFind::TextMostlyVertical() {
  int vertical_boxes = 0;
  int horizontal_boxes = 0;
  // Count vertical bboxes in the grid.
  GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> gsearch(this);
  gsearch.StartFullSearch();
  BLOBNBOX* bbox;
  while ((bbox = gsearch.NextFullSearch()) != NULL) {
    if (bbox->region_type() == BRT_VERT_TEXT)
      ++vertical_boxes;
    else
      ++horizontal_boxes;
  }
  return vertical_boxes > horizontal_boxes;
}

// If this box looks like it is on a textline in the given direction,
// return the width of the textline-like group of blobs, and the number
// of blobs found.
// For more detail see FindTextlineSegment below.
int TabFind::FindTextlineWidth(bool right_to_left, BLOBNBOX* bbox,
                               int* blob_count) {
  ICOORD start_pt, end_pt;
  BLOBNBOX* left_blob;
  BLOBNBOX* right_blob;
  return FindTextlineSegment(right_to_left, true, bbox, blob_count,
                             &start_pt, &end_pt, NULL, NULL,
                             &left_blob, &right_blob);
}

// Search from the given tabstop bbox to the next opposite
// tabstop bbox on the same text line, which may be itself.
// Returns true if the search is successful, and sets
// start_pt, end_pt to the fitted baseline, width to the measured
// width of the text line (column width estimate.)
bool TabFind::TraceTextline(BLOBNBOX* bbox, ICOORD* start_pt, ICOORD* end_pt,
                            int* left_edge, int* right_edge) {
  bool right_to_left = bbox->left_tab_type() != TT_CONFIRMED;
  const TBOX& box = bbox->bounding_box();
  TabVector* left_vector = NULL;
  TabVector* right_vector = NULL;
  if (right_to_left) {
    right_vector = RightTabForBox(box, true, false);
    if (right_vector == NULL || right_vector->IsLeftTab())
      return false;
  } else {
    left_vector = LeftTabForBox(box, true, false);
    if (left_vector == NULL || left_vector->IsRightTab())
      return false;
  }

  BLOBNBOX* left_blob;
  BLOBNBOX* right_blob;
  int blob_count;
  if (FindTextlineSegment(right_to_left, false, bbox, &blob_count,
                          start_pt, end_pt, &left_vector, &right_vector,
                          &left_blob, &right_blob)) {
    AddPartnerVector(left_blob, right_blob, left_vector, right_vector);
    *left_edge = left_vector->XAtY(left_blob->bounding_box().bottom());
    *right_edge = right_vector->XAtY(right_blob->bounding_box().bottom());
    return true;
  }
  return false;
}

// Search from the given bbox in the given direction until the next tab
// vector is found or a significant horizontal gap is found.
// Returns the width of the line if the search is successful, (defined
// as good coverage of the width and a good fitting baseline) and sets
// start_pt, end_pt to the fitted baseline, left_blob, right_blob to
// the ends of the line. Returns zero otherwise.
// Sets blob_count to the number of blobs found on the line.
// On input, either both left_vector and right_vector should be NULL,
// indicating a basic search, or both left_vector and right_vector should
// be not NULL and one of *left_vector and *right_vector should be not NULL,
// in which case the search is strictly between tab vectors and will return
// zero if a gap is found before the opposite tab vector is reached, or a
// conflicting tab vector is found.
// If ignore_images is true, then blobs with aligned_text() < 0 are treated
// as if they do not exist.
int TabFind::FindTextlineSegment(bool right_to_left, bool ignore_images,
                                 BLOBNBOX* bbox, int* blob_count,
                                 ICOORD* start_pt, ICOORD* end_pt,
                                 TabVector** left_vector,
                                 TabVector** right_vector,
                                 BLOBNBOX** left_blob, BLOBNBOX** right_blob) {
  // Bounding box of the current blob.
  TBOX box = bbox->bounding_box();
  // The estimates of top and bottom of the current line move in an
  // alpha-smoothed manner, but in lock-step.
  int top_y = box.top();
  int bottom_y = box.bottom();
  // Left and right of the current blob.
  int left = box.left();
  int right = box.right();
  // Returning the leftmost and rightmost blob used.
  *left_blob = bbox;
  *right_blob = bbox;
  // Coverage measurement as goodness metric.
  int coverage = 0;
  // Approximation of the baseline.
  DetLineFit linepoints;
  // Calculation of the mean height on this line segment.
  double total_height = 0.0;
  int height_count = 0;
  // Starter point for the approximation.
  ICOORD first_pt(right_to_left ? right : left, box.bottom());
  linepoints.Add(first_pt);
  // Last point for the approximation.
  ICOORD last_pt = first_pt;
  // End coordinate that we must not pass.
  int end_coord = right_to_left ? bleft_.x() : tright_.x();
  *blob_count = 0;

  // Maximum gap allowed before abandoning the search for the other edge.
  int gap_limit = static_cast<int>(kMaxHorizontalGap * box.height());
  if (WithinTestRegion(3, first_pt.x(), first_pt.y())) {
    tprintf("Starting %s line search at (%d, %d-%d)\n",
            right_to_left ? "RTL" : "LTR",
            left, bottom_y, top_y);
  }
  while (bbox != NULL) {
    int mid_x = (left + right) / 2;
    if (right_to_left) {
      TabVector* v = LeftTabForBox(box, true, false);
      if ((right_vector != NULL && v == *right_vector) ||
          (v != NULL && bbox == *right_blob && v->IsRightTab()))
        v = LeftTabForBox(box, false, false);
      if (right <= end_coord) {
        if (WithinTestRegion(3, first_pt.x(), first_pt.y()))
          v->Print("Passed through end vector");
        break;
      }
      // No break, so this is a good box.
      linepoints.Add(ICOORD(mid_x, box.bottom()));
      coverage += box.width();
      total_height += box.height();
      ++height_count;
      // In case this is the last one...
      *left_blob = bbox;
      last_pt.set_x(left);
      last_pt.set_y(box.bottom());
      if (v != NULL && (right_vector == NULL || v != *right_vector) &&
          (bbox != *right_blob || v->IsLeftTab())) {
        // The vector is not the starting vector. See if it is within range.
        int x_at_y = v->XAtY(bottom_y);
        if (x_at_y > left - gap_limit) {
          // Once we cross the end_coord, the search will stop.
          if (x_at_y > end_coord)
            end_coord = x_at_y;
          // If this vector is not the correct polarity, then strict searches
          // will fail.
          if (v->IsLeftTab()) {
            if (WithinTestRegion(3, first_pt.x(), first_pt.y()))
              v->Print("Hit End Vector!");
            if (left_vector != NULL)
              *left_vector = v;
          } else {
            if (WithinTestRegion(3, first_pt.x(), first_pt.y()))
              v->Print("Collided with like tab vector");
          }
        }
      }
      if (bbox->left_tab_type() == TT_CONFIRMED) {
        if (WithinTestRegion(3, first_pt.x(), first_pt.y()))
          tprintf("Hit another tab pt\n");
        break;
      }
    } else {
      TabVector* v = RightTabForBox(box, true, false);
      if ((left_vector != NULL && v == *left_vector) ||
          (v != NULL && bbox == *left_blob && v->IsLeftTab()))
        v = RightTabForBox(box, false, false);
      if (left >= end_coord) {
        if (WithinTestRegion(3, first_pt.x(), first_pt.y())) {
          tprintf("left=%d, end_coord=%d\n", left, end_coord);
          v->Print("Passed through end vector");
        }
        break;
      }
      // No break, so this is a good box.
      linepoints.Add(ICOORD(mid_x, box.bottom()));
      coverage += box.width();
      total_height += box.height();
      ++height_count;
      // In case this is the last one...
      *right_blob = bbox;
      last_pt.set_x(right);
      last_pt.set_y(box.bottom());
      if (v != NULL && (left_vector == NULL || v != *left_vector) &&
          (bbox != *left_blob || v->IsRightTab())) {
        // The vector is not the starting vector. See if it is within range.
        int x_at_y = v->XAtY(bottom_y);
        if (x_at_y < right + gap_limit) {
          // Once we cross the end_coord, the search will stop.
          if (x_at_y < end_coord)
            end_coord = x_at_y;
          // If this vector is not the correct polarity, then strict searches
          // will fail.
          if (v->IsRightTab()) {
            if (WithinTestRegion(3, first_pt.x(), first_pt.y()))
              v->Print("Hit End Vector!");
            if (right_vector != NULL)
              *right_vector = v;
          } else {
            if (WithinTestRegion(3, first_pt.x(), first_pt.y()))
              v->Print("Collided with like tab vector");
          }
        }
      }
      if (bbox->right_tab_type() == TT_CONFIRMED) {
        if (WithinTestRegion(3, first_pt.x(), first_pt.y()))
          tprintf("Hit another tab pt\n");
        break;
      }
    }
    // Force the top and bottom to stay the same distance apart by
    // computing the mean alpha smoothing factor of the top and bottom.
    double top_delta = (box.top() - top_y) * kSmoothFactor;
    double bottom_delta = (box.bottom() - bottom_y) * kSmoothFactor;
    int mean_delta = static_cast<int>((top_delta + bottom_delta) / 2.0);
    top_y += mean_delta;
    bottom_y += mean_delta;
    bbox = AdjacentBlob(bbox, right_to_left, ignore_images,
                        gap_limit, top_y, bottom_y);
    if (bbox != NULL && bbox->region_type() < BRT_UNKNOWN) {
      if (WithinTestRegion(3, first_pt.x(), first_pt.y()))
        tprintf("Next box is image region\n");
      bbox = NULL;
    }
    if (bbox != NULL) {
      box = bbox->bounding_box();
      left = box.left();
      right = box.right();
      if (WithinTestRegion(3, first_pt.x(), first_pt.y()))
        tprintf("Next box is at %d, %d\n", left, box.bottom());
    }
  }
  // Either none or both vectors should be NULL.
  if (height_count > 0 &&
      (left_vector == NULL || *left_vector == NULL) ==
      (right_vector == NULL || *right_vector == NULL)) {
    linepoints.Add(last_pt);
    // Maximum median error allowed to be a good text line.
    double max_error = kMaxBaselineError * total_height / height_count;
    double error = linepoints.Fit(start_pt, end_pt);
    int width = (*right_blob)->bounding_box().right()
              - (*left_blob)->bounding_box().left();
    bool good_fit = error < max_error && end_pt->x() != start_pt->x() &&
                    coverage >= kMinBaselineCoverage * width;
    if (WithinTestRegion(3, first_pt.x(), first_pt.y())) {
      tprintf("Found end! good=%d, error=%g/%g, coverage=%g%%"
              " on line (%d, %d) to (%d,%d)\n",
              good_fit, error, max_error, 100.0 * coverage / width,
              start_pt->x(), start_pt->y(), end_pt->x(), end_pt->y());
      tprintf("width=%d, L/R blob=%d/%d, first/last=%d/%d, start/end=%d/%d\n",
              width, (*left_blob)->bounding_box().left(),
              (*right_blob)->bounding_box().right(),
              first_pt.x(), last_pt.x(), start_pt->x(), end_pt->x());
    }
    *blob_count = height_count;
    return good_fit ? width : 0;
  }
  return 0;
}

// Find the next adjacent (to left or right) blob on this text line,
// with the constraint that it must vertically significantly overlap
// the [top_y, bottom_y] range.
// If ignore_images is true, then blobs with aligned_text() < 0 are treated
// as if they do not exist.
BLOBNBOX* TabFind::AdjacentBlob(const BLOBNBOX* bbox,
                                bool right_to_left, bool ignore_images,
                                int gap_limit, int top_y, int bottom_y) {
  GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> sidesearch(this);
  const TBOX& box = bbox->bounding_box();
  int left = box.left();
  int right = box.right();
  int mid_x = (left + right) / 2;
  sidesearch.StartSideSearch(mid_x, bottom_y, top_y);
  int best_gap = 0;
  BLOBNBOX* result = NULL;
  BLOBNBOX* neighbour = NULL;
  while ((neighbour = sidesearch.NextSideSearch(right_to_left)) != NULL) {
    if (neighbour == bbox ||
        (ignore_images && neighbour->region_type() < BRT_UNKNOWN))
      continue;
    const TBOX& nbox = neighbour->bounding_box();
    int n_top_y = nbox.top();
    int n_bottom_y = nbox.bottom();
    int v_overlap = MIN(n_top_y, top_y) - MAX(n_bottom_y, bottom_y);
    int height = top_y - bottom_y;
    int n_height = n_top_y - n_bottom_y;
    if (v_overlap > kCharVerticalOverlapFraction * MIN(height, n_height) &&
        !DifferentSizes(height, n_height)) {
      int n_left = nbox.left();
      int n_right = nbox.right();
      int h_gap = MAX(n_left, left) - MIN(n_right, right);
      int n_mid_x = (n_left + n_right) / 2;
      if (right_to_left == (n_mid_x < mid_x) && n_mid_x != mid_x) {
        if (h_gap > gap_limit) {
          // Hit a big gap before next tab so don't return anything.
          if (WithinTestRegion(3, left, n_top_y))
            tprintf("Giving up due to big gap = %d vs %d\n",
                    h_gap, gap_limit);
          return result;
        }
        if ((right_to_left ? neighbour->right_tab_type()
                           : neighbour->left_tab_type()) >= TT_FAKE) {
          // Hit a tab facing the wrong way. Stop in case we are crossing
          // the column boundary.
          if (WithinTestRegion(3, left, n_top_y))
            tprintf("Collision with like tab of type %d at %d,%d\n",
                    right_to_left ? neighbour->right_tab_type()
                                  : neighbour->left_tab_type(),
                    n_left, nbox.bottom());
          return result;
        }
        // This is a good fit to the line. Continue with this
        // neighbour as the bbox if the best gap.
        if (result == NULL || h_gap < best_gap) {
          if (WithinTestRegion(3, left, n_top_y))
            tprintf("Good result\n");
          result = neighbour;
          best_gap = h_gap;
        } else {
          // The new one is worse, so we probably already have the best result.
          return result;
        }
      }
    }
  }
  if (WithinTestRegion(3, left, box.top()))
    tprintf("Giving up due to end of search\n");
  return result;  // Hit the edge and found nothing.
}

// Add a bi-directional partner relationship between the left
// and the right. If one (or both) of the vectors is a separator,
// extend a nearby extendable vector or create a new one of the
// correct type, using the given left or right blob as a guide.
void TabFind::AddPartnerVector(BLOBNBOX* left_blob, BLOBNBOX* right_blob,
                               TabVector* left, TabVector* right) {
  const TBOX& left_box = left_blob->bounding_box();
  const TBOX& right_box = right_blob->bounding_box();
  if (left->IsSeparator()) {
    // Try to find a nearby left edge to extend.
    TabVector* v = LeftTabForBox(left_box, true, true);
    if (v != NULL && v != left && v->IsLeftTab() &&
        v->XAtY(left_box.top()) > left->XAtY(left_box.top())) {
      left = v;  // Found a good replacement.
      left->ExtendToBox(left_blob);
    } else {
      // Fake a vector.
      left = new TabVector(*left, TA_LEFT_RAGGED, vertical_skew_, left_blob);
      vectors_.add_sorted(TabVector::SortVectorsByKey, left);
      v_it_.move_to_first();
    }
  }
  if (right->IsSeparator()) {
    // Try to find a nearby left edge to extend.
    if (WithinTestRegion(3, right_box.right(), right_box.bottom())) {
      tprintf("Box edge (%d,%d-%d)",
              right_box.right(), right_box.bottom(), right_box.top());
      right->Print(" looking for improvement for");
    }
    TabVector* v = RightTabForBox(right_box, true, true);
    if (v != NULL && v != right && v->IsRightTab() &&
        v->XAtY(right_box.top()) < right->XAtY(right_box.top())) {
      right = v;  // Found a good replacement.
      right->ExtendToBox(right_blob);
      if (WithinTestRegion(3, right_box.right(), right_box.bottom())) {
        right->Print("Extended vector");
      }
    } else {
      // Fake a vector.
      right = new TabVector(*right, TA_RIGHT_RAGGED, vertical_skew_,
                            right_blob);
      vectors_.add_sorted(TabVector::SortVectorsByKey, right);
      v_it_.move_to_first();
      if (WithinTestRegion(3, right_box.right(), right_box.bottom())) {
        right->Print("Created new vector");
      }
    }
  }
  left->AddPartner(right);
  right->AddPartner(left);
}

// Remove separators and unused tabs from the main vectors_ list
// to the dead_vectors_ list.
void TabFind::CleanupTabs() {
  // TODO(rays) Before getting rid of separators and unused vectors, it
  // would be useful to try moving ragged vectors outwards to see if this
  // allows useful extension. Could be combined with checking ends of partners.
  TabVector_IT it(&vectors_);
  TabVector_IT dead_it(&dead_vectors_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    TabVector* v = it.data();
    if (v->IsSeparator() || v->Partnerless()) {
      dead_it.add_after_then_move(it.extract());
      v_it_.set_to_list(&vectors_);
    } else {
      v->FitAndEvaluateIfNeeded(vertical_skew_, this);
    }
  }
}

static void RotateBlobList(const FCOORD& rotation, BLOBNBOX_LIST* blobs) {
  BLOBNBOX_IT it(blobs);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    it.data()->rotate_box(rotation);
  }
}

// Recreate the grid with deskewed BLOBNBOXes.
void TabFind::Deskew(TabVector_LIST* hlines, BLOBNBOX_LIST* image_blobs,
                     TO_BLOCK* block, FCOORD* reskew) {
  FCOORD deskew;
  ComputeDeskewVectors(&deskew, reskew);
  RotateBlobList(deskew, image_blobs);
  RotateBlobList(deskew, &block->blobs);
  RotateBlobList(deskew, &block->small_blobs);
  RotateBlobList(deskew, &block->noise_blobs);
#ifdef HAVE_LIBLEPT
  if (textord_debug_images) {
    // Rotate the debug pix and arrange for it to be drawn at the correct
    // pixel offset.
    Pix* pix_grey = pixRead(AlignedBlob::textord_debug_pix().string());
    int width = pixGetWidth(pix_grey);
    int height = pixGetHeight(pix_grey);
    float angle = atan2(deskew.y(), deskew.x());
    // Positive angle is clockwise to pixRotate.
    Pix* pix_rot = pixRotate(pix_grey, -angle, L_ROTATE_AREA_MAP,
                             L_BRING_IN_WHITE, width, height);
    // The image must be translated by the rotation of its center, since it
    // has just been rotated about its center.
    ICOORD center_offset(width / 2, height / 2);
    ICOORD new_center_offset(center_offset);
    new_center_offset.rotate(deskew);
    image_origin_ += new_center_offset - center_offset;
    // The image grew as it was rotated, so offset the (top/left) origin
    // by half the change in size. y is opposite to x because it is drawn
    // at ist top/left, not bottom/left.
    ICOORD corner_offset((width - pixGetWidth(pix_rot)) / 2,
                         (pixGetHeight(pix_rot) - height) / 2);
    image_origin_ += corner_offset;
    pixWrite(AlignedBlob::textord_debug_pix().string(), pix_rot, IFF_PNG);
    pixDestroy(&pix_grey);
    pixDestroy(&pix_rot);
  }
#endif  // HAVE_LIBLEPT

  // Rotate the horizontal vectors. The vertical vectors don't need
  // rotating as they can just be refitted.
  TabVector_IT h_it(hlines);
  for (h_it.mark_cycle_pt(); !h_it.cycled_list(); h_it.forward()) {
    TabVector* h = h_it.data();
    h->Rotate(deskew);
  }
  SetVerticalSkewAndParellelize(0, 1);
  // Rebuild the grid to the new size.
  TBOX grid_box(bleft_, tright_);
  grid_box.rotate_large(deskew);
  Init(gridsize(), grid_box.botleft(), grid_box.topright());
  InsertBlobList(false, false, false, image_blobs, false, this);
  InsertBlobList(true, false, false, &block->blobs, false, this);
}

static void ResetBlobList(BLOBNBOX_LIST* blobs) {
  BLOBNBOX_IT it(blobs);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    BLOBNBOX* blob = it.data();
    blob->set_left_tab_type(TT_NONE);
    blob->set_right_tab_type(TT_NONE);
    blob->set_region_type(BRT_UNKNOWN);
  }
}

// Restart everything and rotate the input blobs ready for vertical text.
void TabFind::ResetForVerticalText(TabVector_LIST* hlines,
                                   BLOBNBOX_LIST* image_blobs,
                                   TO_BLOCK* block, FCOORD* rerotate) {
  // Rotate anti-clockwise, so vertical CJK text is still in reading order.
  FCOORD derotate(0.0f, 1.0f);
  *rerotate = FCOORD(0.0f, -1.0f);
  RotateBlobList(derotate, image_blobs);
  RotateBlobList(derotate, &block->blobs);
  RotateBlobList(derotate, &block->small_blobs);
  RotateBlobList(derotate, &block->noise_blobs);
  ResetBlobList(&block->blobs);

  // Rotate the horizontal and vertical vectors and swap them over.
  // Only the separators are kept, and existing tabs are deleted.
  // Note that to retain correct relative orientation, vertical and
  // horizontal lines must be rotated in opposite directions!
  TabVector_LIST ex_verticals;
  TabVector_IT ex_v_it(&ex_verticals);
  while (!v_it_.empty()) {
    TabVector* v = v_it_.extract();
    if (v->IsSeparator()) {
      v->Rotate(*rerotate);
      ex_v_it.add_after_then_move(v);
    } else {
      delete v;
    }
    v_it_.forward();
  }
  TabVector_IT h_it(hlines);
  for (h_it.mark_cycle_pt(); !h_it.cycled_list(); h_it.forward()) {
    TabVector* h = h_it.data();
    h->Rotate(derotate);
  }
  v_it_.add_list_after(hlines);
  v_it_.move_to_first();
  h_it.set_to_list(hlines);
  h_it.add_list_after(&ex_verticals);

  // Rebuild the grid to the new size.
  TBOX grid_box(bleft_, tright_);
  grid_box.rotate_large(derotate);
  Init(gridsize(), grid_box.botleft(), grid_box.topright());
  column_widths_.clear();
}

// Compute the rotation required to deskew, and its inverse rotation.
void TabFind::ComputeDeskewVectors(FCOORD* deskew, FCOORD* reskew) {
  double length = vertical_skew_ % vertical_skew_;
  length = sqrt(length);
  deskew->set_x(vertical_skew_.y() / length);
  deskew->set_y(vertical_skew_.x() / length);
  reskew->set_x(deskew->x());
  reskew->set_y(-deskew->y());
}

// Compute and apply constraints to the end positions of TabVectors so
// that where possible partners end at the same y coordinate.
void TabFind::ApplyTabConstraints() {
  TabVector_IT it(&vectors_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    TabVector* v = it.data();
    v->SetupConstraints();
  }
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    TabVector* v = it.data();
    // With the first and last partner, we want a common bottom and top,
    // respectively, and for each change of partner, we want a common
    // top of first with bottom of next.
    v->SetupPartnerConstraints();
  }
  // TODO(rays) The back-to-back pairs should really be done like the
  // front-to-front pairs, but there is no convenient way of producing the
  // list of partners like there is with the front-to-front.
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    TabVector* v = it.data();
    if (!v->IsRightTab())
      continue;
    // For each back-to-back pair of vectors, try for common top and bottom.
    TabVector_IT partner_it(it);
    for (partner_it.forward(); !partner_it.at_first(); partner_it.forward()) {
      TabVector* partner = partner_it.data();
      if (!partner->IsLeftTab() || !v->VOverlap(*partner))
        continue;
      v->SetupPartnerConstraints(partner);
    }
  }
  // Now actually apply the constraints to get common start/end points.
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    TabVector* v = it.data();
    if (!v->IsSeparator())
      v->ApplyConstraints();
  }
  // TODO(rays) Where constraint application fails, it would be good to try
  // checking the ends to see if they really should be moved.
}
/////////////////////////////////////////////////////////////////tabfind////////////////////////////////////////

/////////////////////////////////////////////////////////////////workingpartset/////////////////////////////////
ELISTIZE(WorkingPartSet)

// Add the partition to this WorkingPartSet. Unrelated partitions are
// stored in the order in which they are received, but if the partition
// has a SingletonPartner, make sure that it stays with its partner.
void WorkingPartSet::AddPartition(ColPartition* part) {
  ColPartition* partner = part->SingletonPartner(true);
  if (partner != NULL) {
    ASSERT_HOST(partner->SingletonPartner(false) == part);
  }
  if (latest_part_ == NULL || partner == NULL) {
    // This partition goes at the end of the list
    part_it_.move_to_last();
  } else if (latest_part_->SingletonPartner(false) != part) {
    // Reposition the iterator to the correct partner, or at the end.
    for (part_it_.move_to_first(); !part_it_.at_last() &&
         part_it_.data() != partner;
         part_it_.forward());
  }
  part_it_.add_after_then_move(part);
  latest_part_ = part;
}

// Make blocks out of any partitions in this WorkingPartSet, and append
// them to the end of the blocks list. bleft, tright and resolution give
// the bounds and resolution of the source image, so that blocks can be
// made to fit in the bounds.
// All ColPartitions go in the used_parts list, as they need to be kept
// around, but are no longer needed.
void WorkingPartSet::ExtractCompletedBlocks(const ICOORD& bleft,
                                            const ICOORD& tright,
                                            int resolution,
                                            ColPartition_LIST* used_parts,
                                            BLOCK_LIST* blocks,
                                            TO_BLOCK_LIST* to_blocks) {
  MakeBlocks(bleft, tright, resolution, used_parts);
  BLOCK_IT block_it(blocks);
  block_it.move_to_last();
  block_it.add_list_after(&completed_blocks_);
  TO_BLOCK_IT to_block_it(to_blocks);
  to_block_it.move_to_last();
  to_block_it.add_list_after(&to_blocks_);
}

// Insert the given blocks at the front of the completed_blocks_ list so
// they can be kept in the correct reading order.
void WorkingPartSet::InsertCompletedBlocks(BLOCK_LIST* blocks,
                                           TO_BLOCK_LIST* to_blocks) {
  BLOCK_IT block_it(&completed_blocks_);
  block_it.add_list_before(blocks);
  TO_BLOCK_IT to_block_it(&to_blocks_);
  to_block_it.add_list_before(to_blocks);
}

// Make a block using lines parallel to the given vector that fit between
// the min and max coordinates specified by the ColPartitions.
// Construct a block from the given list of partitions.
void WorkingPartSet::MakeBlocks(const ICOORD& bleft, const ICOORD& tright,
                                int resolution, ColPartition_LIST* used_parts) {
  part_it_.move_to_first();
  while (!part_it_.empty()) {
    // Gather a list of ColPartitions in block_parts that will be split
    // by linespacing into smaller blocks.
    ColPartition_LIST block_parts;
    ColPartition_IT block_it(&block_parts);
    ColPartition* next_part = NULL;
    bool text_block = false;
    do {
      ColPartition* part = part_it_.extract();
      if (part->blob_type() == BRT_UNKNOWN || part->blob_type() == BRT_TEXT)
        text_block = true;
      part->set_working_set(NULL);
      part_it_.forward();
      block_it.add_after_then_move(part);
      next_part = part->SingletonPartner(false);
      if (part_it_.empty() || next_part != part_it_.data()) {
        // Sequences of partitions can get split by titles.
        next_part = NULL;
      }
      // Merge adjacent blocks that are of the same type and let the
      // linespacing determine the real boundaries.
      if (next_part == NULL && !part_it_.empty()) {
        ColPartition* next_block_part = part_it_.data();
        const TBOX& part_box = part->bounding_box();
        const TBOX& next_box = next_block_part->bounding_box();
        // In addition to the same type, the next box must not be above the
        // current box, nor (if image) too far below.
        if (next_block_part->type() == part->type() &&
            next_box.bottom() <= part_box.top() &&
            (text_block ||
             part_box.bottom() - next_box.top() < part_box.height()))
          next_part = next_block_part;
      }
    } while (!part_it_.empty() && next_part != NULL);
    if (!text_block) {
      TO_BLOCK* to_block = ColPartition::MakeBlock(bleft, tright,
                                                   &block_parts, used_parts);
      if (to_block != NULL) {
        TO_BLOCK_IT to_block_it(&to_blocks_);
        to_block_it.add_to_end(to_block);
        BLOCK_IT block_it(&completed_blocks_);
        block_it.add_to_end(to_block->block);
      }
    } else {
      // Further sub-divide text blocks where linespacing changes.
      ColPartition::LineSpacingBlocks(bleft, tright, resolution, &block_parts,
                                      used_parts,
                                      &completed_blocks_, &to_blocks_);
    }
  }
  part_it_.set_to_list(&part_set_);
  latest_part_ = NULL;
  ASSERT_HOST(completed_blocks_.length() == to_blocks_.length());
}
/////////////////////////////////////////////////////////////////workingpartset/////////////////////////////////

/////////////////////////////////////////////////////////////////colpartition////////////////////////////////////////
ELIST2IZE(ColPartition)
CLISTIZE(ColPartition)

//////////////// ColPartition Implementation ////////////////

// If multiple partners survive the partner depth test beyond this level,
// then arbitrarily pick one.
const int kMaxPartnerDepth = 4;
// Maximum change in spacing (in inches) to ignore.
const double kMaxSpacingDrift = 1.0 / 72;  // 1/72 is one point.
// Maximum fraction of line height used as an additional allowance
// for top spacing.
const double kMaxTopSpacingFraction = 0.25;
// Maximum ratio of sizes for lines to be considered the same size.
const double kMaxSizeRatio = 1.5;

// blob_type is the blob_region_type_ of the blobs in this partition.
// Vertical is the direction of logical vertical on the possibly skewed image.
ColPartition::ColPartition(BlobRegionType blob_type, const ICOORD& vertical)
  : left_margin_(MIN_INT32), right_margin_(MAX_INT32),
    median_bottom_(MAX_INT32), median_top_(MIN_INT32), median_size_(0),
    blob_type_(blob_type),
    good_width_(false), good_column_(false),
    left_key_tab_(false), right_key_tab_(false),
    left_key_(0), right_key_(0), type_(PT_UNKNOWN), vertical_(vertical),
    working_set_(NULL), block_owned_(false),
    first_column_(-1), last_column_(-1), column_set_(NULL),
    side_step_(0), top_spacing_(0), bottom_spacing_(0),
    type_before_table_(PT_UNKNOWN), inside_table_column_(false),
    nearest_neighbor_above_(NULL), nearest_neighbor_below_(NULL),
    space_above_(0), space_below_(0), space_to_left_(0), space_to_right_(0) {
}

// Constructs a fake ColPartition with a single fake BLOBNBOX, all made
// from a single TBOX.
// WARNING: Despite being on C_LISTs, the BLOBNBOX owns the C_BLOB and
// the ColPartition owns the BLOBNBOX!!!
// Call DeleteBoxes before deleting the ColPartition.
ColPartition* ColPartition::FakePartition(const TBOX& box) {
  ColPartition* part = new ColPartition(BRT_UNKNOWN, ICOORD(0, 1));
  part->AddBox(new BLOBNBOX(C_BLOB::FakeBlob(box)));
  part->set_left_margin(box.left());
  part->set_right_margin(box.right());
  part->ComputeLimits();
  return part;
}

ColPartition::~ColPartition() {
  // Remove this as a partner of all partners, as we don't want them
  // referring to a deleted object.
  ColPartition_C_IT it(&upper_partners_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    it.data()->RemovePartner(false, this);
  }
  it.set_to_list(&lower_partners_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    it.data()->RemovePartner(true, this);
  }
}

// Constructs a fake ColPartition with no BLOBNBOXes.
// Used for making horizontal line ColPartitions and types it accordingly.
ColPartition::ColPartition(const ICOORD& vertical,
                           int left, int bottom, int right, int top)
  : left_margin_(MIN_INT32), right_margin_(MAX_INT32),
    bounding_box_(left, bottom, right, top),
    median_bottom_(bottom), median_top_(top), median_size_(top - bottom),
    blob_type_(BRT_HLINE),
    good_width_(false), good_column_(false),
    left_key_tab_(false), right_key_tab_(false),
    type_(PT_UNKNOWN), vertical_(vertical),
    working_set_(NULL), block_owned_(false),
    first_column_(-1), last_column_(-1), column_set_(NULL),
    side_step_(0), top_spacing_(0), bottom_spacing_(0),
    type_before_table_(PT_UNKNOWN), inside_table_column_(false),
    nearest_neighbor_above_(NULL), nearest_neighbor_below_(NULL),
    space_above_(0), space_below_(0), space_to_left_(0), space_to_right_(0) {
  left_key_ = BoxLeftKey();
  right_key_ = BoxRightKey();
}


// Adds the given box to the partition, updating the partition bounds.
// The list of boxes in the partition is updated, ensuring that no box is
// recorded twice, and the boxes are kept in increasing left position.
void ColPartition::AddBox(BLOBNBOX* bbox) {
  boxes_.add_sorted(SortByBoxLeft<BLOBNBOX>, true, bbox);
  TBOX box = bbox->bounding_box();
  // Update the partition limits.
  bounding_box_ += box;
  if (!left_key_tab_)
    left_key_ = BoxLeftKey();
  if (!right_key_tab_)
    right_key_ = BoxRightKey();
  if (TabFind::WithinTestRegion(2, box.left(), box.bottom()))
    tprintf("Added box (%d,%d)->(%d,%d) left_blob_x_=%d, right_blob_x_ = %d\n",
            box.left(), box.bottom(), box.right(), box.top(),
            bounding_box_.left(), bounding_box_.right());
}

// Claims the boxes in the boxes_list by marking them with a this owner
// pointer. If a box is already owned, then run Unique on it.
void ColPartition::ClaimBoxes(WidthCallback* cb) {
  bool completed = true;
  do {
    completed = true;
    BLOBNBOX_C_IT bb_it(&boxes_);
    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
      BLOBNBOX* bblob = bb_it.data();
      ColPartition* other = bblob->owner();
      if (other == NULL) {
        // Normal case: ownership is available.
        bblob->set_owner(this);
      } else if (other != this) {
        // bblob already has an owner, so resolve the dispute with Unique.
        // Null everything owned by this upto, but not including bblob, as
        // they will all be up for grabs in Unique.
        for (bb_it.move_to_first(); bb_it.data() != bblob; bb_it.forward()) {
          ASSERT_HOST(bb_it.data()->owner() == this);
          bb_it.data()->set_owner(NULL);
        }
        // Null the owners of all other's blobs. They should all be
        // still owned by other.
        BLOBNBOX_C_IT other_it(&other->boxes_);
        for (other_it.mark_cycle_pt(); !other_it.cycled_list();
             other_it.forward()) {
          ASSERT_HOST(other_it.data()->owner() == other);
          other_it.data()->set_owner(NULL);
        }
        Unique(other, cb);
        // Now we need to run ClaimBoxes on other, as it may have obtained
        // a box from this (beyond bbox) that is owned by a third party.
        other->ClaimBoxes(cb);
        // Scan our own list for bblob. If bblob is still in it and owned by
        // other, there is trouble. Otherwise we can just restart to finish
        // the blob list.
        bb_it.set_to_list(&boxes_);
        for (bb_it.mark_cycle_pt();
             !bb_it.cycled_list() && bb_it.data() != bblob;
             bb_it.forward());
        ASSERT_HOST(bb_it.cycled_list() || bblob->owner() == NULL);
        completed = false;
        break;
      }
    }
  } while (!completed);
}

// Delete the boxes that this partition owns.
void ColPartition::DeleteBoxes() {
  // Although the boxes_ list is a C_LIST, in some cases it owns the
  // BLOBNBOXes, as the ColPartition takes ownership from the grid,
  // and the BLOBNBOXes own the underlying C_BLOBs.
  for (BLOBNBOX_C_IT bb_it(&boxes_); !bb_it.empty(); bb_it.forward()) {
    BLOBNBOX* bblob = bb_it.extract();
    delete bblob->cblob();
    delete bblob;
  }
}

// Returns true if this is a legal partition - meaning that the conditions
// left_margin <= bounding_box left
// left_key <= bounding box left key
// bounding box left <= bounding box right
// and likewise for right margin and key
// are all met.
bool ColPartition::IsLegal() {
  if (bounding_box_.left() > bounding_box_.right()) {
    if (textord_debug_bugs) {
      tprintf("Bounding box invalid\n");
      Print();
    }
    return false;  // Bounding box invalid.
  }
  if (left_margin_ > bounding_box_.left() ||
      right_margin_ < bounding_box_.right()) {
    if (textord_debug_bugs) {
      tprintf("Margins invalid\n");
      Print();
    }
    return false;  // Margins invalid.
  }
  if (left_key_ > BoxLeftKey() || right_key_ < BoxRightKey()) {
    if (textord_debug_bugs) {
      tprintf("Key inside box: %d v %d or %d v %d\n",
              left_key_, BoxLeftKey(), right_key_, BoxRightKey());
      Print();
    }
    return false;  // Keys inside the box.
  }
  return true;
}

// Returns true if the left and right edges are approximately equal.
bool ColPartition::MatchingColumns(const ColPartition& other) const {
  int y = (MidY() + other.MidY()) / 2;
  if (!NearlyEqual(other.LeftAtY(y) / kColumnWidthFactor,
                   LeftAtY(y) / kColumnWidthFactor, 1))
    return false;
  if (!NearlyEqual(other.RightAtY(y) / kColumnWidthFactor,
                   RightAtY(y) / kColumnWidthFactor, 1))
    return false;
  return true;
}

// Sets the sort key using either the tab vector, or the bounding box if
// the tab vector is NULL. If the tab_vector lies inside the bounding_box,
// use the edge of the box as a key any way.
void ColPartition::SetLeftTab(const TabVector* tab_vector) {
  if (tab_vector != NULL) {
    left_key_ = tab_vector->sort_key();
    left_key_tab_ = left_key_ <= BoxLeftKey();
  } else {
    left_key_tab_ = false;
  }
  if (!left_key_tab_)
    left_key_ = BoxLeftKey();
}

// As SetLeftTab, but with the right.
void ColPartition::SetRightTab(const TabVector* tab_vector) {
  if (tab_vector != NULL) {
    right_key_ = tab_vector->sort_key();
    right_key_tab_ = right_key_ >= BoxRightKey();
  } else {
    right_key_tab_ = false;
  }
  if (!right_key_tab_)
    right_key_ = BoxRightKey();
}

// Copies the left/right tab from the src partition, but if take_box is
// true, copies the box instead and uses that as a key.
void ColPartition::CopyLeftTab(const ColPartition& src, bool take_box) {
  left_key_tab_ = take_box ? false : src.left_key_tab_;
  if (left_key_tab_) {
    left_key_ = src.left_key_;
  } else {
    bounding_box_.set_left(XAtY(src.BoxLeftKey(), MidY()));
    left_key_ = BoxLeftKey();
  }
  if (left_margin_ > bounding_box_.left())
    left_margin_ = src.left_margin_;
}

// As CopyLeftTab, but with the right.
void ColPartition::CopyRightTab(const ColPartition& src, bool take_box) {
  right_key_tab_ = take_box ? false : src.right_key_tab_;
  if (right_key_tab_) {
    right_key_ = src.right_key_;
  } else {
    bounding_box_.set_right(XAtY(src.BoxRightKey(), MidY()));
    right_key_ = BoxRightKey();
  }
  if (right_margin_ < bounding_box_.right())
    right_margin_ = src.right_margin_;
}

// Add a partner above if upper, otherwise below.
// Add them uniquely and keep the list sorted by box left.
// Partnerships are added symmetrically to partner and this.
void ColPartition::AddPartner(bool upper, ColPartition* partner) {
  if (upper) {
    partner->lower_partners_.add_sorted(SortByBoxLeft<ColPartition>,
                                        true, this);
    upper_partners_.add_sorted(SortByBoxLeft<ColPartition>, true, partner);
  } else {
    partner->upper_partners_.add_sorted(SortByBoxLeft<ColPartition>,
                                        true, this);
    lower_partners_.add_sorted(SortByBoxLeft<ColPartition>, true, partner);
  }
}

// Removes the partner from this, but does not remove this from partner.
// This asymmetric removal is so as not to mess up the iterator that is
// working on partner's partner list.
void ColPartition::RemovePartner(bool upper, ColPartition* partner) {
  ColPartition_C_IT it(upper ? &upper_partners_ : &lower_partners_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    if (it.data() == partner) {
      it.extract();
      break;
    }
  }
}

// Returns the partner if the given partner is a singleton, otherwise NULL.
ColPartition* ColPartition::SingletonPartner(bool upper) {
  ColPartition_CLIST* partners = upper ? &upper_partners_ : &lower_partners_;
  if (!partners->singleton())
    return NULL;
  ColPartition_C_IT it(partners);
  return it.data();
}

// Merge with the other partition and delete it.
void ColPartition::Absorb(ColPartition* other, WidthCallback* cb) {
  if (TabFind::WithinTestRegion(2, bounding_box_.left(),
                                bounding_box_.bottom()) ||
      TabFind::WithinTestRegion(2, other->bounding_box_.left(),
                                other->bounding_box_.bottom())) {
    tprintf("Merging:");
    Print();
    other->Print();
  }
  // Merge the two sorted lists.
  BLOBNBOX_C_IT it(&boxes_);
  BLOBNBOX_C_IT it2(&other->boxes_);
  for (; !it2.empty(); it2.forward()) {
    BLOBNBOX* bbox2 = it2.extract();
    ColPartition* prev_owner = bbox2->owner();
    ASSERT_HOST(prev_owner == other || prev_owner == NULL);
    if (prev_owner == other)
      bbox2->set_owner(this);
    bbox2->set_region_type(blob_type_);
    TBOX box2 = bbox2->bounding_box();
    int left2 = box2.left();
    while (!it.at_last() && it.data()->bounding_box().left() <= left2) {
      if (it.data() == bbox2)
        break;
      it.forward();
    }
    if (!it.empty() && it.data() == bbox2)
      continue;
    if (it.empty() || (it.at_last() &&
                       it.data()->bounding_box().left() <= left2)) {
      it.add_after_then_move(bbox2);
    } else {
      it.add_before_then_move(bbox2);
    }
  }
  left_margin_ = MIN(left_margin_, other->left_margin_);
  right_margin_ = MAX(right_margin_, other->right_margin_);
  if (other->left_key_ < left_key_) {
    left_key_ = other->left_key_;
    left_key_tab_ = other->left_key_tab_;
  }
  if (other->right_key_ > right_key_) {
    right_key_ = other->right_key_;
    right_key_tab_ = other->right_key_tab_;
  }
  delete other;
  ComputeLimits();
  if (cb != NULL) {
    SetColumnGoodness(cb);
  }
}

// Shares out any common boxes amongst the partitions, ensuring that no
// box stays in both. Returns true if anything was done.
bool ColPartition::Unique(ColPartition* other, WidthCallback* cb) {
  bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
                                         bounding_box_.bottom()) ||
               TabFind::WithinTestRegion(2, other->bounding_box_.left(),
                                         other->bounding_box_.bottom());
  if (debug) {
    tprintf("Running Unique:");
    Print();
    other->Print();
  }
  BLOBNBOX_C_IT it(&boxes_);
  BLOBNBOX_C_IT it2(&other->boxes_);
  it.mark_cycle_pt();
  it2.mark_cycle_pt();
  bool any_moved = false;
  while (!it.cycled_list() && !it2.cycled_list()) {
    BLOBNBOX* bbox = it.data();
    BLOBNBOX* bbox2 = it2.data();
    TBOX box = bbox->bounding_box();
    TBOX box2 = bbox2->bounding_box();
    if (box.left() < box2.left()) {
      it.forward();
    } else if (box.left() > box2.left()) {
      it2.forward();
    } else if (bbox == bbox2) {
      // Separate out most frequent case for efficiency.
      if (debug) {
        tprintf("Keeping box (%d,%d)->(%d,%d) only in %s\n",
                box.left(), box.bottom(), box.right(), box.top(),
                ThisPartitionBetter(bbox, *other) ? "This" : "Other");
      }
      if (ThisPartitionBetter(bbox, *other))
        it2.extract();
      else
        it.extract();
      it.forward();
      it2.forward();
      any_moved = true;
    } else {
      // Lefts are equal, but boxes may be in any order.
      BLOBNBOX_C_IT search_it(it2);
      for (search_it.forward(); !search_it.at_first() &&
           search_it.data() != bbox &&
           search_it.data()->bounding_box().left() == box.left();
           search_it.forward());
      if (search_it.data() == bbox) {
        // Found a match.
        if (ThisPartitionBetter(bbox, *other)) {
          search_it.extract();
          // We just (potentially) invalidated it2, so reposition at bbox2.
          it2.move_to_first();
          for (it2.mark_cycle_pt(); it2.data() != bbox2; it2.forward());
        } else {
          it.extract();
        }
        it.forward();
        any_moved = true;
      } else {
        // No match to bbox in list2. Just move first it forward.
        it.forward();
      }
    }
  }
  // Now check to see if there are any in either list that would be better
  // off in the other.
  if (!it.empty()) {
    it.move_to_first();
    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
      BLOBNBOX* bbox = it.data();
      if (!ThisPartitionBetter(bbox, *other)) {
        other->AddBox(it.extract());
        TBOX box = bbox->bounding_box();
        if (debug) {
          tprintf("Moved box (%d,%d)->(%d,%d) from this to other:\n",
                  box.left(), box.bottom(), box.right(), box.top());
        }
        any_moved = true;
      }
    }
  }
  if (!it2.empty()) {
    it2.move_to_first();
    for (it2.mark_cycle_pt(); !it2.cycled_list(); it2.forward()) {
      BLOBNBOX* bbox2 = it2.data();
      if (ThisPartitionBetter(bbox2, *other)) {
        AddBox(it2.extract());
        TBOX box = bbox2->bounding_box();
        if (debug) {
          tprintf("Moved box (%d,%d)->(%d,%d) from other to this:\n",
                  box.left(), box.bottom(), box.right(), box.top());
        }
        any_moved = true;
      }
    }
  }
  if (any_moved) {
    if (debug)
      tprintf("Unique did something!\n");
    ComputeLimits();
    other->ComputeLimits();
    if (cb != NULL) {
      SetColumnGoodness(cb);
      other->SetColumnGoodness(cb);
    }
  }
  return any_moved;
}

// Split this partition at the given x coordinate, returning the right
// half and keeping the left half in this.
ColPartition* ColPartition::SplitAt(int split_x) {
  if (split_x <= bounding_box_.left() || split_x >= bounding_box_.right())
    return NULL;  // There will be no change.
  ColPartition* split_part = ShallowCopy();
  BLOBNBOX_C_IT it(&boxes_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    BLOBNBOX* bbox = it.data();
    ColPartition* prev_owner = bbox->owner();
    ASSERT_HOST(prev_owner == this || prev_owner == NULL);
    const TBOX& box = bbox->bounding_box();
    if (box.left() >= split_x) {
      split_part->AddBox(it.extract());
      if (prev_owner != NULL)
        bbox->set_owner(split_part);
    }
  }
  ASSERT_HOST(!it.empty());
  if (split_part->IsEmpty()) {
    // Split part ended up with nothing. Possible if split_x passes
    // through the last blob.
    delete split_part;
    return NULL;
  }
  right_key_tab_ = false;
  split_part->left_key_tab_ = false;
  right_margin_ = split_x;
  split_part->left_margin_ = split_x;
  ComputeLimits();
  split_part->ComputeLimits();
  return split_part;
}

// Recalculates all the coordinate limits of the partition.
void ColPartition::ComputeLimits() {
  bounding_box_ = TBOX();  // Clear it
  BLOBNBOX_C_IT it(&boxes_);
  BLOBNBOX* bbox = NULL;
  if (it.empty()) {
    bounding_box_.set_left(left_margin_);
    bounding_box_.set_right(right_margin_);
    bounding_box_.set_bottom(0);
    bounding_box_.set_top(0);
  } else {
    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
      bbox = it.data();
      bounding_box_ += bbox->bounding_box();
    }
  }
  if (!left_key_tab_)
    left_key_ = BoxLeftKey();
  if (left_key_ > BoxLeftKey() && textord_debug_bugs) {
    // TODO(rays) investigate the causes of these error messages, to find
    // out if they are genuinely harmful, or just indicative of junk input.
    tprintf("Computed left-illegal partition\n");
    Print();
  }
  if (!right_key_tab_)
    right_key_ = BoxRightKey();
  if (right_key_ < BoxRightKey() && textord_debug_bugs) {
    tprintf("Computed right-illegal partition\n");
    Print();
  }
  if (it.empty())
    return;
  STATS top_stats(bounding_box_.bottom(), bounding_box_.top() + 1);
  STATS bottom_stats(bounding_box_.bottom(), bounding_box_.top() + 1);
  STATS size_stats(0, bounding_box_.height() + 1);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    bbox = it.data();
    TBOX box = bbox->bounding_box();
    top_stats.add(box.top(), 1);
    bottom_stats.add(box.bottom(), 1);
    size_stats.add(box.height(), 1);
  }
  median_top_ = static_cast<int>(top_stats.median() + 0.5);
  median_bottom_ = static_cast<int>(bottom_stats.median() + 0.5);
  median_size_ = static_cast<int>(size_stats.median() + 0.5);

  if (right_margin_ < bounding_box_.right() && textord_debug_bugs) {
    tprintf("Made partition with bad right coords");
    Print();
  }
  if (left_margin_ > bounding_box_.left() && textord_debug_bugs) {
    tprintf("Made partition with bad left coords");
    Print();
  }
  if (TabFind::WithinTestRegion(2, bounding_box_.left(),
                                bounding_box_.bottom())) {
    tprintf("Recomputed box for partition %p\n", this);
    Print();
  }
}

// Computes and sets the type_ and first_colum_, last_column_ and column_set_.
void ColPartition::SetPartitionType(ColPartitionSet* columns) {
  int first_spanned_col = -1;
  int last_spanned_col = -1;
  type_ = columns->SpanningType(blob_type_,
                                bounding_box_.left(), bounding_box_.right(),
                                MidY(), left_margin_, right_margin_,
                                &first_column_, &last_column_,
                                &first_spanned_col, &last_spanned_col);
  column_set_ = columns;
  if (first_column_ != last_column_ &&
      (type_ == PT_PULLOUT_TEXT || type_ == PT_PULLOUT_IMAGE ||
       type_ == PT_PULLOUT_LINE)) {
    // Unequal columns may indicate that the pullout spans one of the columns
    // it lies in, so force it to be allocated to just that column.
    if (first_spanned_col >= 0) {
      first_column_ = first_spanned_col;
      last_column_ = first_spanned_col;
    } else {
      if ((first_column_ & 1) == 0)
        last_column_ = first_column_;
      else if ((last_column_ & 1) == 0)
        first_column_ = last_column_;
      else
        first_column_ = last_column_ = (first_column_ + last_column_) / 2;
    }
  }
}

// Returns the first and last column touched by this partition.
void ColPartition::ColumnRange(ColPartitionSet* columns,
                               int* first_col, int* last_col) {
  int first_spanned_col = -1;
  int last_spanned_col = -1;
  type_ = columns->SpanningType(blob_type_,
                                bounding_box_.left(), bounding_box_.right(),
                                MidY(), left_margin_, right_margin_,
                                first_col, last_col,
                                &first_spanned_col, &last_spanned_col);
}

// Sets the internal flags good_width_ and good_column_.
void ColPartition::SetColumnGoodness(WidthCallback* cb) {
  int y = MidY();
  int width = RightAtY(y) - LeftAtY(y);
  good_width_ = cb->Run(width);
  good_column_ = blob_type_ == BRT_TEXT && left_key_tab_ && right_key_tab_;
}

// Adds this ColPartition to a matching WorkingPartSet if one can be found,
// otherwise starts a new one in the appropriate column, ending the previous.
void ColPartition::AddToWorkingSet(const ICOORD& bleft, const ICOORD& tright,
                                   int resolution,
                                   ColPartition_LIST* used_parts,
                                   WorkingPartSet_LIST* working_sets) {
  if (block_owned_)
    return;  // Done it already.
  block_owned_ = true;
  WorkingPartSet_IT it(working_sets);
  // If there is an upper partner use its working_set_ directly.
  ColPartition* partner = SingletonPartner(true);
  if (partner != NULL && partner->working_set_ != NULL) {
    working_set_ = partner->working_set_;
    working_set_->AddPartition(this);
    return;
  }
  if (partner != NULL && textord_debug_bugs) {
    tprintf("Partition with partner has no working set!:");
    Print();
    partner->Print();
  }
  // Search for the column that the left edge fits in.
  WorkingPartSet* work_set = NULL;
  it.move_to_first();
  int col_index = 0;
  for (it.mark_cycle_pt(); !it.cycled_list() &&
       col_index != first_column_;
        it.forward(), ++col_index);
  if (textord_debug_tabfind >= 2) {
    tprintf("Match is %s for:", (col_index & 1) ? "Real" : "Between");
    Print();
  }
  if (it.cycled_list() && textord_debug_bugs) {
    tprintf("Target column=%d, only had %d\n", first_column_, col_index);
  }
  ASSERT_HOST(!it.cycled_list());
  work_set = it.data();
  // If last_column_ != first_column, then we need to scoop up all blocks
  // between here and the last_column_ and put back in work_set.
  if (!it.cycled_list() && last_column_ != first_column_) {
    // Find the column that the right edge falls in.
    BLOCK_LIST completed_blocks;
    TO_BLOCK_LIST to_blocks;
    for (; !it.cycled_list() && col_index <= last_column_;
         it.forward(), ++col_index) {
      WorkingPartSet* end_set = it.data();
      end_set->ExtractCompletedBlocks(bleft, tright, resolution, used_parts,
                                      &completed_blocks, &to_blocks);
    }
    work_set->InsertCompletedBlocks(&completed_blocks, &to_blocks);
  }
  working_set_ = work_set;
  work_set->AddPartition(this);
}

// From the given block_parts list, builds one or more BLOCKs and
// corresponding TO_BLOCKs, such that the line spacing is uniform in each.
// Created blocks are appended to the end of completed_blocks and to_blocks.
// The used partitions are put onto used_parts, as they may still be referred
// to in the partition grid. bleft, tright and resolution are the bounds
// and resolution of the original image.
void ColPartition::LineSpacingBlocks(const ICOORD& bleft, const ICOORD& tright,
                                     int resolution,
                                     ColPartition_LIST* block_parts,
                                     ColPartition_LIST* used_parts,
                                     BLOCK_LIST* completed_blocks,
                                     TO_BLOCK_LIST* to_blocks) {
  int page_height = tright.y() - bleft.y();
  // Compute the initial spacing stats.
  ColPartition_IT it(block_parts);
  int part_count = 0;
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColPartition* part = it.data();
    ASSERT_HOST(!part->boxes()->empty());
    STATS side_steps(0, part->bounding_box().height());
    BLOBNBOX_C_IT blob_it(part->boxes());
    int prev_bottom = blob_it.data()->bounding_box().bottom();
    for (blob_it.forward(); !blob_it.at_first(); blob_it.forward()) {
      BLOBNBOX* blob = blob_it.data();
      int bottom = blob->bounding_box().bottom();
      int step = bottom - prev_bottom;
      if (step < 0)
        step = -step;
      side_steps.add(step, 1);
      prev_bottom = bottom;
    }
    part->set_side_step(static_cast<int>(side_steps.median() + 0.5));
    if (!it.at_last()) {
      ColPartition* next_part = it.data_relative(1);
      part->set_bottom_spacing(part->median_bottom() -
                               next_part->median_bottom());
      part->set_top_spacing(part->median_top() - next_part->median_top());
    } else {
      part->set_bottom_spacing(page_height);
      part->set_top_spacing(page_height);
    }
    if (textord_debug_tabfind) {
      part->Print();
      tprintf("side step = %.2f, top spacing = %d, bottom spacing=%d\n",
              side_steps.median(), part->top_spacing(), part->bottom_spacing());
    }
    ++part_count;
  }
  if (part_count == 0)
    return;

  SmoothSpacings(resolution, page_height, block_parts);

  // Move the partitions into individual block lists and make the blocks.
  BLOCK_IT block_it(completed_blocks);
  TO_BLOCK_IT to_block_it(to_blocks);
  ColPartition_LIST spacing_parts;
  ColPartition_IT sp_block_it(&spacing_parts);
  for (it.mark_cycle_pt(); !it.empty();) {
    ColPartition* part = it.extract();
    sp_block_it.add_to_end(part);
    it.forward();
    if (it.empty() || !part->SpacingsEqual(*it.data(), resolution)) {
      // There is a spacing boundary. Check to see if it.data() belongs
      // better in the current block or the next one.
      if (!it.empty()) {
        ColPartition* next_part = it.data();
        // If there is a size match one-way, then the middle line goes with
        // its matched size, otherwise it goes with the smallest spacing.
        ColPartition* third_part = it.at_last() ? NULL : it.data_relative(1);
        if (textord_debug_tabfind)
          tprintf("Spacings unequal: upper:%d/%d, lower:%d/%d,"
                  " sizes %d %d %d\n",
                  part->top_spacing(), part->bottom_spacing(),
                  next_part->top_spacing(), next_part->bottom_spacing(),
                  part->median_size(), next_part->median_size(),
                  third_part != NULL ? third_part->median_size() : 0);
        // If spacing_diff ends up positive, then next_part goes in the
        // current block.
        int spacing_diff = next_part->bottom_spacing() - part->bottom_spacing();
        if (part->SizesSimilar(*next_part) &&
            (third_part == NULL || !next_part->SizesSimilar(*third_part))) {
          // Sizes overrule.
          spacing_diff = 1;
        } else if (!part->SizesSimilar(*next_part) && third_part != NULL &&
                   next_part->SizesSimilar(*third_part)) {
          // Sizes overrule.
          spacing_diff = -1;
        }
        if (spacing_diff > 0) {
          sp_block_it.add_to_end(it.extract());
          it.forward();
        }
      }
      TO_BLOCK* to_block = MakeBlock(bleft, tright, &spacing_parts, used_parts);
      if (to_block != NULL) {
        to_block_it.add_to_end(to_block);
        block_it.add_to_end(to_block->block);
      }
      sp_block_it.set_to_list(&spacing_parts);
    }
  }
}

// Helper function to clip the input pos to the given bleft, tright bounds.
static void ClipCoord(const ICOORD& bleft, const ICOORD& tright, ICOORD* pos) {
  if (pos->x() < bleft.x())
    pos->set_x(bleft.x());
  if (pos->x() > tright.x())
    pos->set_x(tright.x());
  if (pos->y() < bleft.y())
    pos->set_y(bleft.y());
  if (pos->y() > tright.y())
    pos->set_y(tright.y());
}

// Constructs a block from the given list of partitions.
// Arguments are as LineSpacingBlocks above.
TO_BLOCK* ColPartition::MakeBlock(const ICOORD& bleft, const ICOORD& tright,
                                  ColPartition_LIST* block_parts,
                                  ColPartition_LIST* used_parts) {
  if (block_parts->empty())
    return NULL;  // Nothing to do.
  ColPartition_IT it(block_parts);
  ColPartition* part = it.data();
  int line_spacing = part->bottom_spacing();
  if (line_spacing < part->median_size())
    line_spacing = part->bounding_box().height();
  PolyBlockType type = it.data()->type();
  bool text_type = it.data()->IsTextType();
  ICOORDELT_LIST vertices;
  ICOORDELT_IT vert_it(&vertices);
  ICOORD start, end;
  int min_x = MAX_INT32;
  int max_x = MIN_INT32;
  int min_y = MAX_INT32;
  int max_y = MIN_INT32;
  int iteration = 0;
  do {
    if (iteration == 0)
      ColPartition::LeftEdgeRun(&it, &start, &end);
    else
      ColPartition::RightEdgeRun(&it, &start, &end);
    ClipCoord(bleft, tright, &start);
    ClipCoord(bleft, tright, &end);
    vert_it.add_after_then_move(new ICOORDELT(start));
    vert_it.add_after_then_move(new ICOORDELT(end));
    min_x = MIN(min_x, start.x());
    min_x = MIN(min_x, end.x());
    max_x = MAX(max_x, start.x());
    max_x = MAX(max_x, end.x());
    min_y = MIN(min_y, start.y());
    min_y = MIN(min_y, end.y());
    max_y = MAX(max_y, start.y());
    max_y = MAX(max_y, end.y());
    if ((iteration == 0 && it.at_first()) ||
        (iteration == 1 && it.at_last())) {
      ++iteration;
      it.move_to_last();
    }
  } while (iteration < 2);
  if (textord_debug_tabfind)
    tprintf("Making block at (%d,%d)->(%d,%d)\n",
            min_x, min_y, max_x, max_y);
  BLOCK* block = new BLOCK("", true, 0, 0, min_x, min_y, max_x, max_y);
  block->set_poly_block(new POLY_BLOCK(&vertices, type));
  // Make a matching TO_BLOCK and put all the BLOBNBOXes from the parts in it.
  // Move all the parts to a done list as they are no longer needed, except
  // that have have to continue to exist until the part grid is deleted.
  // Compute the median blob size as we go, as the block needs to know.
  STATS heights(0, max_y + 1 - min_y);
  TO_BLOCK* to_block = new TO_BLOCK(block);
  BLOBNBOX_IT blob_it(&to_block->blobs);
  ColPartition_IT used_it(used_parts);
  for (it.move_to_first(); !it.empty(); it.forward()) {
    ColPartition* part = it.extract();
    if (text_type) {
      // Only transfer blobs from text regions to the output blocks.
      // The rest stay behind and get deleted with the ColPartitions.
      for (BLOBNBOX_C_IT bb_it(part->boxes()); !bb_it.empty();
           bb_it.forward()) {
        BLOBNBOX* bblob = bb_it.extract();
        ASSERT_HOST(bblob->owner() == part);
        ASSERT_HOST(bblob->region_type() >= BRT_UNKNOWN);
        C_OUTLINE_IT ol_it(bblob->cblob()->out_list());
        ASSERT_HOST(ol_it.data()->pathlength() > 0);
        heights.add(bblob->bounding_box().height(), 1);
        blob_it.add_after_then_move(bblob);
      }
    }
    used_it.add_to_end(part);
  }
  if (text_type && blob_it.empty()) {
    delete block;
    delete to_block;
    return NULL;
  }
  to_block->line_size = heights.median();
  int block_height = block->bounding_box().height();
  if (block_height < line_spacing)
    line_spacing = block_height;
  to_block->line_spacing = line_spacing;
  to_block->max_blob_size = block_height + 1;
  if (type == PT_VERTICAL_TEXT) {
    // This block will get rotated 90 deg clockwise so record the inverse.
    FCOORD rotation(0.0f, 1.0f);
    block->set_re_rotation(rotation);
  }
  return to_block;
}

// Returns a copy of everything except the list of boxes. The resulting
// ColPartition is only suitable for keeping in a column candidate list.
ColPartition* ColPartition::ShallowCopy() const {
  ColPartition* part = new ColPartition(blob_type_, vertical_);
  part->left_margin_ = left_margin_;
  part->right_margin_ = right_margin_;
  part->bounding_box_ = bounding_box_;
  part->median_bottom_ = median_bottom_;
  part->median_top_ = median_top_;
  part->median_size_ = median_size_;
  part->good_width_ = good_width_;
  part->good_column_ = good_column_;
  part->left_key_tab_ = left_key_tab_;
  part->right_key_tab_ = right_key_tab_;
  part->type_ = type_;
  part->left_key_ = left_key_;
  part->right_key_ = right_key_;
  return part;
}

// Provides a color for BBGrid to draw the rectangle.
// Must be kept in sync with PolyBlockType.
ScrollView::Color  ColPartition::BoxColor() const {
  return POLY_BLOCK::ColorForPolyBlockType(type_);
}

// Keep in sync with BlobRegionType.
static char kBlobTypes[BRT_COUNT + 1] = "NHRIUVT";

// Prints debug information on this.
void ColPartition::Print() {
  int y = MidY();
  tprintf("ColPart:%c(M%d-%c%d-B%d,%d/%d)->(%dB-%d%c-%dM,%d/%d)"
          " w-ok=%d, v-ok=%d, type=%d%c, fc=%d, lc=%d, boxes=%d"
          " ts=%d bs=%d ls=%d rs=%d\n",
          boxes_.empty() ? 'E' : ' ',
          left_margin_, left_key_tab_ ? 'T' : 'B', LeftAtY(y),
          bounding_box_.left(), median_bottom_, bounding_box_.bottom(),
          bounding_box_.right(), RightAtY(y), right_key_tab_ ? 'T' : 'B',
          right_margin_, median_top_, bounding_box_.top(),
          good_width_, good_column_, type_,
          kBlobTypes[blob_type_],
          first_column_, last_column_, boxes_.length(),
          space_above_, space_below_, space_to_left_, space_to_right_);
}

// Sets the types of all partitions in the run to be the max of the types.
void ColPartition::SmoothPartnerRun(int working_set_count) {
  STATS left_stats(0, working_set_count);
  STATS right_stats(0, working_set_count);
  PolyBlockType max_type = type_;
  ColPartition* partner;
  for (partner = SingletonPartner(false); partner != NULL;
       partner = partner->SingletonPartner(false)) {
    if (partner->type_ > max_type)
      max_type = partner->type_;
    if (column_set_ == partner->column_set_) {
      left_stats.add(partner->first_column_, 1);
      right_stats.add(partner->last_column_, 1);
    }
  }
  type_ = max_type;
  first_column_ = left_stats.mode();
  last_column_ = right_stats.mode();
  if (last_column_ < first_column_)
    last_column_ = first_column_;

  for (partner = SingletonPartner(false); partner != NULL;
       partner = partner->SingletonPartner(false)) {
    partner->type_ = max_type;
    if (column_set_ == partner->column_set_) {
      partner->first_column_ = first_column_;
      partner->last_column_ = last_column_;
    }
  }
}

// Cleans up the partners of the given type so that there is at most
// one partner. This makes block creation simpler.
void ColPartition::RefinePartners(PolyBlockType type) {
  if (type_ == type) {
    RefinePartnersInternal(true);
    RefinePartnersInternal(false);
  } else if (type == PT_COUNT) {
    // This is the final pass. Make sure only the correctly typed
    // partners surivive, however many there are.
    RefinePartnersByType(true, &upper_partners_);
    RefinePartnersByType(false, &lower_partners_);
  }
}

////////////////// PRIVATE CODE /////////////////////////////

// Cleans up the partners above if upper is true, else below.
void ColPartition::RefinePartnersInternal(bool upper) {
  ColPartition_CLIST* partners = upper ? &upper_partners_ : &lower_partners_;
  if (!partners->empty() && !partners->singleton()) {
    RefinePartnersByType(upper, partners);
    if (!partners->empty() && !partners->singleton()) {
      // Check for transitive partnerships and break the cycle.
      RefinePartnerShortcuts(upper, partners);
      if (!partners->empty() && !partners->singleton()) {
        // Types didn't fix it. Flowing text keeps the one with the longest
        // sequence of singleton matching partners. All others max overlap.
        if (type_ == PT_FLOWING_TEXT)
          RefineFlowingTextPartners(upper, partners);
        else
          RefinePartnersByOverlap(upper, partners);
      }
    }
  }
}

// Restricts the partners to only desirable types. For text and BRT_HLINE this
// means the same type_ , and for image types it means any image type.
void ColPartition::RefinePartnersByType(bool upper,
                                        ColPartition_CLIST* partners) {
  if (TabFind::WithinTestRegion(2, bounding_box_.left(),
                                bounding_box_.bottom())) {
    tprintf("Refining %s partners by type for:\n", upper ? "Upper" : "Lower");
    Print();
  }
  ColPartition_C_IT it(partners);
  // Purify text by type.
  if (blob_type_ > BRT_UNKNOWN || blob_type_ == BRT_HLINE) {
    // Keep only partners matching type_.
    // Exception: PT_VERTICAL_TEXT is allowed to stay with the other
    // text types if it is the only partner.
    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
      ColPartition* partner = it.data();
      if (partner->type_ != type_ &&
          (!partners->singleton() ||
           (type_ != PT_VERTICAL_TEXT && partner->type_ != PT_VERTICAL_TEXT) ||
            !IsTextType() || !partner->IsTextType())) {
        partner->RemovePartner(!upper, this);
        it.extract();
      } else if (TabFind::WithinTestRegion(2, bounding_box_.left(),
                                           bounding_box_.bottom())) {
        tprintf("Keeping partner:");
        partner->Print();
      }
    }
  } else {
    // Keep only images with images, but not being fussy about type.
    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
      ColPartition* partner = it.data();
      if (partner->blob_type_ > BRT_UNKNOWN ||
          partner->blob_type_ == BRT_HLINE) {
        partner->RemovePartner(!upper, this);
        it.extract();
      } else if (TabFind::WithinTestRegion(2, bounding_box_.left(),
                                           bounding_box_.bottom())) {
        tprintf("Keeping partner:");
        partner->Print();
      }
    }
  }
}

// Remove transitive partnerships: this<->a, and a<->b and this<->b.
// Gets rid of this<->b, leaving a clean chain.
// Also if we have this<->a and a<->this, then gets rid of this<->a, as
// this has multiple partners.
void ColPartition::RefinePartnerShortcuts(bool upper,
                                          ColPartition_CLIST* partners) {
  bool done_any = false;
  do {
    done_any = false;
    ColPartition_C_IT it(partners);
    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
      ColPartition* a = it.data();
      // Check for a match between all of a's partners (it1/b1) and all
      // of this's partners (it2/b2).
      ColPartition_C_IT it1(upper ? &a->upper_partners_ : &a->lower_partners_);
      for (it1.mark_cycle_pt(); !it1.cycled_list(); it1.forward()) {
        ColPartition* b1 = it1.data();
        if (b1 == this) {
          done_any = true;
          it.extract();
          a->RemovePartner(!upper, this);
          break;
        }
        ColPartition_C_IT it2(partners);
        for (it2.mark_cycle_pt(); !it2.cycled_list(); it2.forward()) {
          ColPartition* b2 = it2.data();
          if (b1 == b2) {
            // Jackpot! b2 should not be a partner of this.
            it2.extract();
            b2->RemovePartner(!upper, this);
            done_any = true;
            // That potentially invalidated all the iterators, so break out
            // and start again.
            break;
          }
        }
        if (done_any)
          break;
      }
      if (done_any)
        break;
    }
  } while (done_any && !partners->empty() && !partners->singleton());
}

// Keeps the partner with the longest sequence of singleton matching partners.
// Converts all others to pullout.
void ColPartition::RefineFlowingTextPartners(bool upper,
                                             ColPartition_CLIST* partners) {
  ColPartition_C_IT it(partners);
  ColPartition* best_partner = it.data();
  // Nasty iterative algorithm.
  int depth = 1;
  int survivors = 0;
  do {
    survivors = 0;
    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
      ColPartition* partner = it.data();
      // See if it survives a chase to depth levels.
      for (int i = 0; i < depth && partner != NULL; ++i) {
        partner = partner->SingletonPartner(upper);
        if (partner != NULL && partner->type_ != PT_FLOWING_TEXT)
          partner = NULL;
      }
      if (partner != NULL) {
        ++survivors;
        best_partner = it.data();
      }
    }
    ++depth;
  } while (survivors > 1 && depth <= kMaxPartnerDepth);
  // Keep only the best partner.
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColPartition* partner = it.data();
    if (partner != best_partner) {
      partner->RemovePartner(!upper, this);
      it.extract();
      // Change the types of partner to be PT_PULLOUT_TEXT.
      while (partner != NULL && partner->type_ == PT_FLOWING_TEXT) {
        partner->type_ = PT_PULLOUT_TEXT;
        partner = partner->SingletonPartner(upper);
      }
    }
  }
}

// Keep the partner with the biggest overlap.
void ColPartition::RefinePartnersByOverlap(bool upper,
                                           ColPartition_CLIST* partners) {
  ColPartition_C_IT it(partners);
  ColPartition* best_partner = it.data();
  // Find the partner with the best overlap.
  int best_overlap = 0;
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColPartition* partner = it.data();
    int overlap = MIN(bounding_box_.right(), partner->bounding_box_.right())
                - MAX(bounding_box_.left(), partner->bounding_box_.left());
    if (overlap > best_overlap) {
      best_overlap = overlap;
      best_partner = partner;
    }
  }
  // Keep only the best partner.
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColPartition* partner = it.data();
    if (partner != best_partner) {
      partner->RemovePartner(!upper, this);
      it.extract();
    }
  }
}

// Return true if bbox belongs better in this than other.
bool ColPartition::ThisPartitionBetter(BLOBNBOX* bbox,
                                       const ColPartition& other) {
  TBOX box = bbox->bounding_box();
  // Margins take priority.
  int left = box.left();
  int right = box.right();
  if (left < left_margin_ || right > right_margin_)
    return false;
  if (left < other.left_margin_ || right > other.right_margin_)
    return true;
  int top = box.top();
  int bottom = box.bottom();
  int this_overlap = MIN(top, median_top_) - MAX(bottom, median_bottom_);
  int other_overlap = MIN(top, other.median_top_) -
                      MAX(bottom, other.median_bottom_);
  int this_miss = median_top_ - median_bottom_ - this_overlap;
  int other_miss = other.median_top_ - other.median_bottom_ - other_overlap;
  if (TabFind::WithinTestRegion(3, box.left(), box.bottom())) {
    tprintf("Unique on (%d,%d)->(%d,%d) overlap %d/%d, miss %d/%d, mt=%d/%d\n",
            box.left(), box.bottom(), box.right(), box.top(),
            this_overlap, other_overlap, this_miss, other_miss,
            median_top_, other.median_top_);
  }
  if (this_miss < other_miss)
    return true;
  if (this_miss > other_miss)
    return false;
  if (this_overlap > other_overlap)
    return true;
  if (this_overlap < other_overlap)
    return false;
  return median_top_ >= other.median_top_;
}

// Returns the median line-spacing between the current position and the end
// of the list.
// The iterator is passed by value so the iteration does not modify the
// caller's iterator.
static int MedianSpacing(int page_height, ColPartition_IT it) {
  STATS stats(0, page_height);
  while (!it.cycled_list()) {
    ColPartition* part = it.data();
    it.forward();
    stats.add(part->bottom_spacing(), 1);
    stats.add(part->top_spacing(), 1);
  }
  return static_cast<int>(stats.median() + 0.5);
}

// Smoothes the spacings in the list into groups of equal linespacing.
// resolution is the resolution of the original image, used as a basis
// for thresholds in change of spacing. page_height is in pixels.
void ColPartition::SmoothSpacings(int resolution, int page_height,
                                  ColPartition_LIST* parts) {
  // The task would be trivial if we didn't have to allow for blips -
  // occasional offsets in spacing caused by anomolous text, such as all
  // caps, groups of descenders, joined words, Arabic etc.
  // The neighbourhood stores a consecutive group of partitions so that
  // blips can be detected correctly, yet conservatively enough to not
  // mistake genuine spacing changes for blips. See example below.
  ColPartition* neighbourhood[PN_COUNT];
  ColPartition_IT it(parts);
  it.mark_cycle_pt();
  // Although we know nothing about the spacings is this list, the median is
  // used as an approximation to allow blips.
  // If parts of this block aren't spaced to the median, then we can't
  // accept blips in those parts, but we'll recalculate it each time we
  // split the block, so the median becomes more likely to match all the text.
  int median_space = MedianSpacing(page_height, it);
  ColPartition_IT start_it(it);
  ColPartition_IT end_it(it);
  for (int i = 0; i < PN_COUNT; ++i) {
    if (i < PN_UPPER || it.cycled_list()) {
      neighbourhood[i] = NULL;
    } else {
      if (i == PN_LOWER)
        end_it = it;
      neighbourhood[i] = it.data();
      it.forward();
    }
  }
  while (neighbourhood[PN_UPPER] != NULL) {
    // Test for end of a group. Normally SpacingsEqual is true within a group,
    // but in the case of a blip, it will be false. Here is an example:
    // Line enum   Spacing below (spacing between tops of lines)
    //  1   ABOVE2    20
    //  2   ABOVE1    20
    //  3   UPPER     15
    //  4   LOWER     25
    //  5   BELOW1    20
    //  6   BELOW2    20
    // Line 4 is all in caps (regular caps), so the spacing between line 3
    // and line 4 (looking at the tops) is smaller than normal, and the
    // spacing between line 4 and line 5 is larger than normal, but the
    // two of them add to twice the normal spacing.
    // The following if has to accept unequal spacings 3 times to pass the
    // blip (20/15, 15/25 and 25/20)
    // When the blip is in the middle, OKSpacingBlip tests that one of
    // ABOVE1 and BELOW1 matches the median.
    // The first time, everything is shifted down 1, so we present
    // OKSpacingBlip with neighbourhood+1 and check that PN_UPPER is median.
    // The last time, everything is shifted up 1, so we present OKSpacingBlip
    // with neighbourhood-1 and check that PN_LOWER matches the median.
    if (neighbourhood[PN_LOWER] == NULL ||
        (!neighbourhood[PN_UPPER]->SpacingsEqual(*neighbourhood[PN_LOWER], resolution) &&
         !OKSpacingBlip(resolution, median_space, neighbourhood) &&
         (!OKSpacingBlip(resolution, median_space, neighbourhood - 1) ||
          !neighbourhood[PN_LOWER]->SpacingEqual(median_space, resolution)) &&
         (!OKSpacingBlip(resolution, median_space, neighbourhood + 1) ||
          !neighbourhood[PN_UPPER]->SpacingEqual(median_space, resolution)))) {
      // The group has ended. PN_UPPER is the last member.
      // Compute the mean spacing over the group.
      ColPartition_IT sum_it(start_it);
      ColPartition* last_part = neighbourhood[PN_UPPER];
      double total_bottom = 0.0;
      double total_top = 0.0;
      int total_count = 0;
      ColPartition* upper = sum_it.data();

      // We do not process last_part, as its spacing is different.
      while (upper != last_part) {
        total_bottom += upper->bottom_spacing();
        total_top += upper->top_spacing();
        ++total_count;
        sum_it.forward();
        upper = sum_it.data();
      }
      if (total_count > 0) {
        // There were at least 2 lines, so set them all to the mean.
        int top_spacing = static_cast<int>(total_top / total_count + 0.5);
        int bottom_spacing = static_cast<int>(total_bottom / total_count + 0.5);
        if (textord_debug_tabfind) {
          tprintf("Spacing run ended. Cause:");
          if (neighbourhood[PN_LOWER] == NULL) {
            tprintf("No more lines\n");
          } else {
            tprintf("Spacing change. Spacings:\n");
            for (int i = 0; i < PN_COUNT; ++i) {
              if (neighbourhood[i] == NULL) {
                tprintf("NULL\n");
              } else {
                tprintf("Top = %d, bottom = %d\n",
                        neighbourhood[i]->top_spacing(),
                        neighbourhood[i]->bottom_spacing());
              }
            }
          }
          tprintf("Mean spacing = %d/%d\n", top_spacing, bottom_spacing);
        }
        sum_it = start_it;
        upper = sum_it.data();
        while (upper != last_part) {
          upper->set_top_spacing(top_spacing);
          upper->set_bottom_spacing(bottom_spacing);
          if (textord_debug_tabfind) {
            tprintf("Setting mean on:");
            upper->Print();
          }
          sum_it.forward();
          upper = sum_it.data();
        }
      }
      // PN_LOWER starts the next group and end_it is the next start_it.
      start_it = end_it;
      // Recalculate the median spacing to maximize the chances of detecting
      // spacing blips.
      median_space = MedianSpacing(page_height, end_it);
    }
    // Shuffle pointers.
    for (int j = 1; j < PN_COUNT; ++j) {
      neighbourhood[j - 1] = neighbourhood[j];
    }
    if (it.cycled_list()) {
      neighbourhood[PN_COUNT - 1] = NULL;
    } else {
      neighbourhood[PN_COUNT - 1] = it.data();
      it.forward();
    }
    end_it.forward();
  }
}

// Returns true if the parts array of pointers to partitions matches the
// condition for a spacing blip. See SmoothSpacings for what this means
// and how it is used.
bool ColPartition::OKSpacingBlip(int resolution, int median_spacing,
                                 ColPartition** parts) {
  if (parts[PN_UPPER] == NULL || parts[PN_LOWER] == NULL)
    return false;
  // The blip is OK if upper and lower sum to an OK value and at least
  // one of above1 and below1 is equal to the median.
  return parts[PN_UPPER]->SummedSpacingOK(*parts[PN_LOWER],
                                          median_spacing, resolution) &&
         ((parts[PN_ABOVE1] != NULL &&
           parts[PN_ABOVE1]->SpacingEqual(median_spacing, resolution)) ||
          (parts[PN_BELOW1] != NULL &&
           parts[PN_BELOW1]->SpacingEqual(median_spacing, resolution)));
}

// Returns true if both the top and bottom spacings of this match the given
// spacing to within suitable margins dictated by the image resolution.
bool ColPartition::SpacingEqual(int spacing, int resolution) const {
  int bottom_error = BottomSpacingMargin(resolution);
  int top_error = TopSpacingMargin(resolution);
  return NearlyEqual(bottom_spacing_, spacing, bottom_error) &&
         NearlyEqual(top_spacing_, spacing, top_error);
}

// Returns true if both the top and bottom spacings of this and other
// match to within suitable margins dictated by the image resolution.
bool ColPartition::SpacingsEqual(const ColPartition& other,
                                 int resolution) const {
  int bottom_error = MAX(BottomSpacingMargin(resolution),
                         other.BottomSpacingMargin(resolution));
  int top_error = MAX(TopSpacingMargin(resolution),
                      other.TopSpacingMargin(resolution));
  return NearlyEqual(bottom_spacing_, other.bottom_spacing_, bottom_error) &&
         (NearlyEqual(top_spacing_, other.top_spacing_, top_error) ||
          NearlyEqual(top_spacing_ + other.top_spacing_, bottom_spacing_ * 2,
                      bottom_error));
}

// Returns true if the sum spacing of this and other match the given
// spacing (or twice the given spacing) to within a suitable margin dictated
// by the image resolution.
bool ColPartition::SummedSpacingOK(const ColPartition& other,
                                   int spacing, int resolution) const {
  int bottom_error = MAX(BottomSpacingMargin(resolution),
                         other.BottomSpacingMargin(resolution));
  int top_error = MAX(TopSpacingMargin(resolution),
                      other.TopSpacingMargin(resolution));
  int bottom_total = bottom_spacing_ + other.bottom_spacing_;
  int top_total = top_spacing_ + other.top_spacing_;
  return (NearlyEqual(spacing, bottom_total, bottom_error) &&
          NearlyEqual(spacing, top_total, top_error)) ||
         (NearlyEqual(spacing * 2, bottom_total, bottom_error) &&
          NearlyEqual(spacing * 2, top_total, top_error));
}

// Returns a suitable spacing margin that can be applied to bottoms of
// text lines, based on the resolution and the stored side_step_.
int ColPartition::BottomSpacingMargin(int resolution) const {
  return static_cast<int>(kMaxSpacingDrift * resolution + 0.5) + side_step_;
}

// Returns a suitable spacing margin that can be applied to tops of
// text lines, based on the resolution and the stored side_step_.
int ColPartition::TopSpacingMargin(int resolution) const {
  return static_cast<int>(kMaxTopSpacingFraction * median_size_ + 0.5) +
         BottomSpacingMargin(resolution);
}

// Returns true if the median text sizes of this and other agree to within
// a reasonable multiplicative factor.
bool ColPartition::SizesSimilar(const ColPartition& other) const {
  return median_size_ <= other.median_size_ * kMaxSizeRatio &&
         other.median_size_ <= median_size_ * kMaxSizeRatio;
}

// Computes and returns in start, end a line segment formed from a
// forwards-iterated group of left edges of partitions that satisfy the
// condition that the rightmost left margin is to the left of the
// leftmost left bounding box edge.
// TODO(rays) Not good enough. Needs improving to tightly wrap text in both
// directions, and to loosely wrap images.
void ColPartition::LeftEdgeRun(ColPartition_IT* part_it,
                               ICOORD* start, ICOORD* end) {
  ColPartition* part = part_it->data();
  int start_y = part->bounding_box_.top();
  if (!part_it->at_first() &&
      part_it->data_relative(-1)->bounding_box_.bottom() > start_y)
    start_y = (start_y + part_it->data_relative(-1)->bounding_box_.bottom())/2;
  int end_y = part->bounding_box_.bottom();
  int min_right = MAX_INT32;
  int max_left = MIN_INT32;
  do {
    part = part_it->data();
    int top = part->bounding_box_.top();
    int bottom = part->bounding_box_.bottom();
    int tl_key = part->SortKey(part->left_margin_, top);
    int tr_key = part->SortKey(part->bounding_box_.left(), top);
    int bl_key = part->SortKey(part->left_margin_, bottom);
    int br_key = part->SortKey(part->bounding_box_.left(), bottom);
    int left_key = MAX(tl_key, bl_key);
    int right_key = MIN(tr_key, br_key);
    if (left_key <= min_right && right_key >= max_left) {
      // This part is good - let's keep it.
      min_right = MIN(min_right, right_key);
      max_left = MAX(max_left, left_key);
      end_y = bottom;
      part_it->forward();
      if (!part_it->at_first() && part_it->data()->bounding_box_.top() < end_y)
        end_y = (end_y + part_it->data()->bounding_box_.top()) / 2;
    } else {
      if (textord_debug_tabfind)
        tprintf("Sum key %d/%d, new %d/%d\n",
                max_left, min_right, left_key, right_key);
      break;
    }
  } while (!part_it->at_first());
  start->set_y(start_y);
  start->set_x(part->XAtY(min_right, start_y));
  end->set_y(end_y);
  end->set_x(part->XAtY(min_right, end_y));
  if (textord_debug_tabfind && !part_it->at_first())
    tprintf("Left run from y=%d to %d terminated with sum %d-%d, new %d-%d\n",
            start_y, end_y, part->XAtY(max_left, end_y),
            end->x(), part->left_margin_, part->bounding_box_.left());
}

// Computes and returns in start, end a line segment formed from a
// backwards-iterated group of right edges of partitions that satisfy the
// condition that the leftmost right margin is to the right of the
// rightmost right bounding box edge.
// TODO(rays) Not good enough. Needs improving to tightly wrap text in both
// directions, and to loosely wrap images.
void ColPartition::RightEdgeRun(ColPartition_IT* part_it,
                                ICOORD* start, ICOORD* end) {
  ColPartition* part = part_it->data();
  int start_y = part->bounding_box_.bottom();
  if (!part_it->at_first() &&
      part_it->data_relative(1)->bounding_box_.top() < start_y)
    start_y = (start_y + part_it->data_relative(1)->bounding_box_.top()) / 2;
  int end_y = part->bounding_box_.top();
  int min_right = MAX_INT32;
  int max_left = MIN_INT32;
  do {
    part = part_it->data();
    int top = part->bounding_box_.top();
    int bottom = part->bounding_box_.bottom();
    int tl_key = part->SortKey(part->bounding_box_.right(), top);
    int tr_key = part->SortKey(part->right_margin_, top);
    int bl_key = part->SortKey(part->bounding_box_.right(), bottom);
    int br_key = part->SortKey(part->right_margin_, bottom);
    int left_key = MAX(tl_key, bl_key);
    int right_key = MIN(tr_key, br_key);
    if (left_key <= min_right && right_key >= max_left) {
      // This part is good - let's keep it.
      min_right = MIN(min_right, right_key);
      max_left = MAX(max_left, left_key);
      end_y = top;
      part_it->backward();
      if (!part_it->at_last() &&
          part_it->data()->bounding_box_.bottom() > end_y)
        end_y = (end_y + part_it->data()->bounding_box_.bottom()) / 2;
    } else {
      if (textord_debug_tabfind)
        tprintf("Sum cross %d/%d, new %d/%d\n",
                max_left, min_right, left_key, right_key);
      break;
    }
  } while (!part_it->at_last());
  start->set_y(start_y);
  start->set_x(part->XAtY(max_left, start_y));
  end->set_y(end_y);
  end->set_x(part->XAtY(max_left, end_y));
  if (textord_debug_tabfind && !part_it->at_last())
    tprintf("Right run from y=%d to %d terminated with sum %d-%d, new %d-%d\n",
            start_y, end_y, end->x(), part->XAtY(min_right, end_y),
            part->bounding_box_.right(), part->right_margin_);
}
/////////////////////////////////////////////////////////////////colpartition////////////////////////////////////////

/////////////////////////////////////////////////////////////////colpartitionset////////////////////////////////////////
ELISTIZE(ColPartitionSet)

ColPartitionSet::ColPartitionSet(ColPartition_LIST* partitions) {
  ColPartition_IT it(&parts_);
  it.add_list_after(partitions);
  ComputeCoverage();
}

ColPartitionSet::ColPartitionSet(ColPartition* part) {
  ColPartition_IT it(&parts_);
  it.add_after_then_move(part);
  ComputeCoverage();
}

ColPartitionSet::~ColPartitionSet() {
}

// Return an element of the parts_ list from its index.
ColPartition* ColPartitionSet::GetColumnByIndex(int index) {
  ColPartition_IT it(&parts_);
  it.mark_cycle_pt();
  for (int i = 0; i < index && !it.cycled_list(); ++i, it.forward());
  if (it.cycled_list())
    return NULL;
  return it.data();
}

// Return the ColPartition that contains the given coords, if any, else NULL.
ColPartition* ColPartitionSet::ColumnContaining(int x, int y) {
  ColPartition_IT it(&parts_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColPartition* part = it.data();
    if (part->ColumnContains(x, y))
      return part;
  }
  return NULL;
}

// Insert the ColPartitions in our list into the given grid.
void ColPartitionSet::ReturnParts(ColPartition_LIST* parts) {
  ColPartition_IT it(parts);
  it.add_list_before(&parts_);
}

// Merge any significantly overlapping partitions within the this and other,
// and unique the boxes so that no two partitions use the same box.
// Return true if any changes were made to either set.
bool ColPartitionSet::MergeOverlaps(ColPartitionSet* other, WidthCallback* cb) {
  bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
                                         bounding_box_.bottom()) ||
               TabFind::WithinTestRegion(2, other->bounding_box_.left(),
                                         other->bounding_box_.bottom());
  if (debug) {
    tprintf("Considering merge on:\n");
    Print();
    other->Print();
  }
  ColPartition_IT it1(&parts_);
  ColPartition_IT it2(&other->parts_);
  bool any_merged = false;
  it1.mark_cycle_pt();
  it2.mark_cycle_pt();
  // Iterate the two lists in parallel, using the fact that they are
  // sorted by x-coord to keep the iterators in sync.
  while (!it1.cycled_list() && !it2.cycled_list()) {
    any_merged = false;
    ColPartition* part1 = it1.data();
    ColPartition* part2 = it2.data();
    if (debug) {
      tprintf("Vover=%d, HOver=%d, Hcompatible=%d, typesmatch=%d\n",
              part1->VOverlaps(*part2), part1->HOverlaps(*part2),
              part1->HCompatible(*part2), part1->TypesMatch(*part2));
    }
    if (part1->VOverlaps(*part2) &&
        part1->HCompatible(*part2) && part1->TypesMatch(*part2)) {
      // Partitions seem to be mergeable, so absorb part1 into part2.
      part1->Absorb(it2.extract(), cb);
      any_merged = true;
      it1.forward();
      it2.forward();
    } else if (part1->HOverlaps(*part2) && part1->TypesMatch(*part2) &&
               part1->Unique(part2, cb)) {
      // Unique moved some boxes, so check to see in either partition was
      // left empty. If not, any_merged is not set true.
      if (part1->IsEmpty()) {
        any_merged = true;
        delete it1.extract();
        it1.forward();
        continue;
      }
      if (part2->IsEmpty()) {
        any_merged = true;
        delete it2.extract();
        it2.forward();
        continue;
      }
    }
    if (!any_merged) {
      // Move on the iterator that point to the leftmost partition.
      if (part1->IsLeftOf(*part2)) {
        it1.forward();
      } else {
        it2.forward();
      }
    }
  }
  if (any_merged) {
    ComputeCoverage();
    other->ComputeCoverage();
  }
  return any_merged;
}

// Attempt to improve this by adding partitions or expanding partitions.
void ColPartitionSet::ImproveColumnCandidate(WidthCallback* cb,
                                             PartSetVector* src_sets) {
  int set_size = src_sets->size();
  // Iterate over the provided column sets, as each one may have something
  // to improve this.
  for (int i = 0; i < set_size; ++i) {
    ColPartitionSet* column_set = src_sets->get(i);
    if (column_set == NULL)
      continue;
    // Iterate over the parts in this and column_set, adding bigger or
    // new parts in column_set to this.
    ColPartition_IT part_it(&parts_);
    ASSERT_HOST(!part_it.empty());
    int prev_right = MIN_INT32;
    part_it.mark_cycle_pt();
    ColPartition_IT col_it(&column_set->parts_);
    for (col_it.mark_cycle_pt(); !col_it.cycled_list(); col_it.forward()) {
      ColPartition* col_part = col_it.data();
      if (col_part->blob_type() < BRT_UNKNOWN)
        continue;  // Ignore image partitions.
      int col_left = col_part->left_key();
      int col_right = col_part->right_key();
      // Sync-up part_it (in this) so it matches the col_part in column_set.
      ColPartition* part = part_it.data();
      while (!part_it.at_last() && part->right_key() < col_left) {
        prev_right = part->right_key();
        part_it.forward();
        part = part_it.data();
      }
      int part_left = part->left_key();
      int part_right = part->right_key();
      if (part_right < col_left || col_right < part_left) {
        // There is no overlap so this is a new partition.
        AddPartition(col_part->ShallowCopy(), &part_it);
        continue;
      }
      // Check the edges of col_part to see if they can improve part.
      bool part_width_ok = cb->Run(part->KeyWidth(part_left, part_right));
      if (col_left < part_left && col_left > prev_right) {
        // The left edge of the column is better and it doesn't overlap,
        // so we can potentially expand it.
        int col_box_left = col_part->BoxLeftKey();
        bool tab_width_ok = cb->Run(part->KeyWidth(col_left, part_right));
        bool box_width_ok = cb->Run(part->KeyWidth(col_box_left, part_right));
        if (tab_width_ok || (!part_width_ok )) {
          // The tab is leaving the good column metric at least as good as
          // it was before, so use the tab.
          part->CopyLeftTab(*col_part, false);
          part->SetColumnGoodness(cb);
        } else if (col_box_left < part_left &&
                   (box_width_ok || !part_width_ok)) {
          // The box is leaving the good column metric at least as good as
          // it was before, so use the box.
          part->CopyLeftTab(*col_part, true);
          part->SetColumnGoodness(cb);
        }
        part_left = part->left_key();
      }
      if (col_right > part_right &&
          (part_it.at_last() ||
           part_it.data_relative(1)->left_key() > col_right)) {
        // The right edge is better, so we can possibly expand it.
        int col_box_right = col_part->BoxRightKey();
        bool tab_width_ok = cb->Run(part->KeyWidth(part_left, col_right));
        bool box_width_ok = cb->Run(part->KeyWidth(part_left, col_box_right));
        if (tab_width_ok || (!part_width_ok )) {
          // The tab is leaving the good column metric at least as good as
          // it was before, so use the tab.
          part->CopyRightTab(*col_part, false);
          part->SetColumnGoodness(cb);
        } else if (col_box_right > part_right &&
                   (box_width_ok || !part_width_ok)) {
          // The box is leaving the good column metric at least as good as
          // it was before, so use the box.
          part->CopyRightTab(*col_part, true);
          part->SetColumnGoodness(cb);
        }
      }
    }
  }
  ComputeCoverage();
}

// If this set is good enough to represent a new partitioning into columns,
// add it to the vector of sets, otherwise delete it.
void ColPartitionSet::AddToColumnSetsIfUnique(PartSetVector* column_sets,
                                              WidthCallback* cb) {
  bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
                                         bounding_box_.bottom());
  if (debug) {
    tprintf("Considering new column candidate:\n");
    Print();
  }
  if (!LegalColumnCandidate()) {
    if (debug) {
      tprintf("Not a legal column candidate:\n");
      Print();
    }
    delete this;
    return;
  }
  for (int i = 0; i < column_sets->size(); ++i) {
    ColPartitionSet* columns = column_sets->get(i);
    // In ordering the column set candidates, total_coverage_ is king,
    // followed by good_column_count_ and then total column_count.
    bool better = total_coverage_ > columns->total_coverage_;
    if (total_coverage_ == columns->total_coverage_) {
      better = good_column_count_ > columns->good_column_count_;
      if (good_column_count_ == columns->good_column_count_) {
          better = parts_.length() > columns->parts_.length();
      }
    }
    if (better) {
      // The new one is better so add it.
      if (debug)
        tprintf("Good one\n");
      column_sets->insert(this, i);
      return;
    }
    if (columns->CompatibleColumns(false, this, cb)) {
      if (debug)
        tprintf("Duplicate\n");
      delete this;
      return;  // It is not unique.
    }
  }
  if (debug)
    tprintf("Added to end\n");
  column_sets->push_back(this);
}

// Return true if the partitions in other are all compatible with the columns
// in this.
bool ColPartitionSet::CompatibleColumns(bool debug, ColPartitionSet* other,
                                        WidthCallback* cb) {
  if (debug) {
    tprintf("CompatibleColumns testing compability\n");
    Print();
    other->Print();
  }
  if (other->parts_.empty()) {
    if (debug)
      tprintf("CompatibleColumns true due to empty other\n");
    return true;
  }
  ColPartition_IT it(&other->parts_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColPartition* part = it.data();
    if (part->blob_type() < BRT_UNKNOWN) {
      if (debug) {
        tprintf("CompatibleColumns ignoring image partition\n");
        part->Print();
      }
      continue;  // Image partitions are irrelevant to column compability.
    }
    int y = part->MidY();
    int left = part->bounding_box().left();
    int right = part->bounding_box().right();
    ColPartition* left_col = ColumnContaining(left, y);
    ColPartition* right_col = ColumnContaining(right, y);
    if (right_col == NULL || left_col == NULL) {
      if (debug) {
        tprintf("CompatibleColumns false due to partition edge outside\n");
        part->Print();
      }
      return false;  // A partition edge lies outside of all columns
    }
    if (right_col != left_col && cb->Run(right - left)) {
      if (debug) {
        tprintf("CompatibleColumns false due to good width in multiple cols\n");
        part->Print();
      }
      return false;  // Partition with a good width must be in a single column.
    }

    ColPartition_IT it2= it;
    while (!it2.at_last()) {
      it2.forward();
      ColPartition* next_part = it2.data();
      if (next_part->blob_type() <= BRT_UNKNOWN)
        continue;  // Image partitions are irrelevant.
      int next_left = next_part->bounding_box().left();
      if (next_left == right) {
        break;  // They share the same edge, so one must be a pull-out.
      }
      // Search to see if right and next_left fall within a single column.
      ColPartition* next_left_col = ColumnContaining(next_left, y);
      if (right_col == next_left_col) {
        // There is a column break in this column.
        // Check for the difference between different column layout and
        // a pull-out block.
        int part_box_width = part->bounding_box().width();
        int part_margin_width = part->right_margin() - part->left_margin();
        int next_box_width = next_part->bounding_box().width();
        int next_margin_width = next_part->right_margin() -
                                next_part->left_margin();
        int next_right = next_part->bounding_box().right();
        if (part_box_width < next_margin_width &&
            next_box_width < part_margin_width) {
          if (debug) {
            tprintf("CompatibleColumns false due to equal sized columns\n");
            tprintf("part1 %d-%d = %d, part2 %d-%d = %d\n",
                    left, right, part->ColumnWidth(),
                    next_left, next_right, next_part->ColumnWidth());
            right_col->Print();
          }
          return false;  // Must be a new column layout as they are equal size.
        }
        ColPartition* next_right_col = ColumnContaining(next_right, y);
        if (left_col == right_col && next_right_col == next_left_col) {
          // Column completely contains both. Not allowed.
          if (debug) {
            tprintf("CompatibleColumns false due to containing 2 partitions\n");
            tprintf("part1 %d-%d, part2 %d-%d\n",
                    left, right, next_left, next_right);
            right_col->Print();
          }
          return false;
        }
      }
      break;
    }
  }
  if (debug)
    tprintf("CompatibleColumns true!\n");
  return true;
}

// Return true if this ColPartitionSet makes a legal column candidate by
// having legal individual partitions and non-overlapping adjacent pairs.
bool ColPartitionSet::LegalColumnCandidate() {
  ColPartition_IT it(&parts_);
  if (it.empty())
    return false;
  int any_text_parts = false;
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColPartition* part = it.data();
    if (part->blob_type() > BRT_UNKNOWN) {
      if (!part->IsLegal())
        return false;  // Individual partition is illegal.
      any_text_parts = true;
    }
    if (!it.at_last()) {
      ColPartition* next_part = it.data_relative(1);
      if (next_part->left_key() < part->right_key()) {
        return false;
      }
    }
  }
  return any_text_parts;
}

// Return a copy of this. If good_only will only copy the Good ColPartitions.
ColPartitionSet* ColPartitionSet::Copy(bool good_only) {
  ColPartition_LIST copy_parts;
  ColPartition_IT src_it(&parts_);
  ColPartition_IT dest_it(&copy_parts);
  for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
    ColPartition* part = src_it.data();
    if (part->blob_type() > BRT_UNKNOWN &&
        (!good_only || part->good_width() || part->good_column()))
      dest_it.add_after_then_move(part->ShallowCopy());
  }
  if (dest_it.empty())
    return NULL;
  return new ColPartitionSet(&copy_parts);
}

// Return the bounding boxes of columns at the given y-range
void ColPartitionSet::GetColumnBoxes(int y_bottom, int y_top,
                                     ColSegment_LIST *segments) {
  ColPartition_IT it(&parts_);
  ColSegment_IT col_it(segments);
  col_it.move_to_last();
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColPartition* part = it.data();
    ICOORD bot_left(part->LeftAtY(y_top), y_bottom);
    ICOORD top_right(part->RightAtY(y_bottom), y_top);
    ColSegment *col_seg = new ColSegment();
    col_seg->InsertBox(TBOX(bot_left, top_right));
    col_it.add_after_then_move(col_seg);
  }
}

// Display the edges of the columns at the given y coords.
void ColPartitionSet::DisplayColumnEdges(int y_bottom, int y_top,
                                         ScrollView* win) {
  ColPartition_IT it(&parts_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColPartition* part = it.data();
    win->Line(part->LeftAtY(y_top), y_top, part->LeftAtY(y_bottom), y_bottom);
    win->Line(part->RightAtY(y_top), y_top, part->RightAtY(y_bottom), y_bottom);
  }
}

// Return the PolyBlockType that best explains the columns overlapped
// by the given coords(left,right,y), with the given margins.
// Also return the first and last column index touched by the coords and
// the leftmost and rightmost spanned columns.
// Column indices are 2n + 1 for real colums (0 based) and even values
// represent the gaps in between columns, with 0 being left of the leftmost.
PolyBlockType ColPartitionSet::SpanningType(BlobRegionType type,
                                            int left, int right, int y,
                                            int left_margin, int right_margin,
                                            int* first_col, int* last_col,
                                            int* first_spanned_col,
                                            int* last_spanned_col) {
  *first_col = -1;
  *last_col = -1;
  *first_spanned_col = -1;
  *last_spanned_col = -1;
  int columns_spanned = 0;
  ColPartition_IT it(&parts_);
  int col_index = 1;
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward(), col_index += 2) {
    ColPartition* part = it.data();
    if (part->ColumnContains(left, y)) {
      // In the default case, first_col is set, but columns_spanned remains
      // zero, so first_col will get reset in the first column genuinely
      // spanned, but we can tell the difference from a noise partition
      // that touches no column.
      *first_col = col_index;
      if (part->ColumnContains(right, y)) {
        // Both within a single column.
        *last_col = col_index;
        if (type == BRT_HLINE)
          return PT_FLOWING_LINE;
        else if (type > BRT_UNKNOWN)
          return type == BRT_VERT_TEXT ? PT_VERTICAL_TEXT : PT_FLOWING_TEXT;
        else
          return PT_FLOWING_IMAGE;
      }
      if (left_margin <= part->LeftAtY(y)) {
        // It completely spans this column.
        *last_col = col_index;
        *first_spanned_col = col_index;
        *last_spanned_col = col_index;
        columns_spanned = 1;
      }
    } else if (part->ColumnContains(right, y)) {
      if (*first_col < 0) {
        // It started in-between.
        *first_col = col_index - 1;
      }
      if (right_margin >= part->RightAtY(y)) {
        // It completely spans this column.
        if (columns_spanned == 0)
          *first_spanned_col = col_index;
        *last_spanned_col = col_index;
        ++columns_spanned;
      }
      *last_col = col_index;
      break;
    } else if (left < part->LeftAtY(y) && right > part->RightAtY(y)) {
      // Neither left nor right are contained within, so it spans this
      // column.
      if (columns_spanned == 0) {
        *first_col = col_index;
        *first_spanned_col = col_index;
      }
      *last_col = col_index;
      *last_spanned_col = col_index;
      ++columns_spanned;
    } else if (right < part->LeftAtY(y)) {
      // We have gone past the end.
      *last_col = col_index - 1;
      if (*first_col < 0) {
        // It must lie completely between columns =>noise.
        *first_col = col_index - 1;
      }
      break;
    }
  }
  if (*first_col < 0)
    *first_col = col_index - 1;  // The last in-between.
  if (*last_col < 0)
    *last_col = col_index - 1;  // The last in-between.
  ASSERT_HOST(*first_col >= 0 && *last_col >= 0);
  ASSERT_HOST(*first_col <= *last_col);
  if (columns_spanned == 0 && *first_col == *last_col) {
    // Neither end was in a column, and it didn't span any, so it lies
    // entirely between columns, therefore noise.
    return PT_NOISE;
  } else if (columns_spanned <= 1) {
    // It is a pullout, as left and right were not in the same column.
    if (type == BRT_HLINE)
      return PT_PULLOUT_LINE;
    else if (type > BRT_UNKNOWN)
      return type == BRT_VERT_TEXT ? PT_VERTICAL_TEXT : PT_PULLOUT_TEXT;
    else
      return PT_PULLOUT_IMAGE;
  }
  // It completely spanned more than one column. Always a heading.
  if (type == BRT_HLINE)
    return PT_HEADING_LINE;
  else if (type > BRT_UNKNOWN)
    return type == BRT_VERT_TEXT ? PT_VERTICAL_TEXT : PT_HEADING_TEXT;
  else
    return PT_HEADING_IMAGE;
}

// The column_set has changed. Close down all in-progress WorkingPartSets in
// columns that do not match and start new ones for the new columns in this.
// As ColPartitions are turned into BLOCKs, the used ones are put in
// used_parts, as they still need to be referenced in the grid.
void ColPartitionSet::ChangeWorkColumns(const ICOORD& bleft,
                                        const ICOORD& tright,
                                        int resolution,
                                        ColPartition_LIST* used_parts,
                                        WorkingPartSet_LIST* working_set_list) {
  // Move the input list to a temporary location so we can delete its elements
  // as we add them to the output working_set.
  WorkingPartSet_LIST work_src;
  WorkingPartSet_IT src_it(&work_src);
  src_it.add_list_after(working_set_list);
  src_it.move_to_first();
  WorkingPartSet_IT dest_it(working_set_list);
  // Completed blocks and to_blocks are accumulated and given to the first new
  // one  whenever we keep a column, or at the end.
  BLOCK_LIST completed_blocks;
  TO_BLOCK_LIST to_blocks;
  WorkingPartSet* first_new_set = NULL;
  WorkingPartSet* working_set = NULL;
  ColPartition_IT col_it(&parts_);
  for (col_it.mark_cycle_pt(); !col_it.cycled_list(); col_it.forward()) {
    ColPartition* column = col_it.data();
    // Any existing column to the left of column is completed.
    while (!src_it.empty() &&
           ((working_set = src_it.data())->column() == NULL ||
            working_set->column()->right_key() <= column->left_key())) {
      src_it.extract();
      working_set->ExtractCompletedBlocks(bleft, tright, resolution,
                                          used_parts, &completed_blocks,
                                          &to_blocks);
      delete working_set;
      src_it.forward();
    }
    // Make a new between-column WorkingSet for before the current column.
    working_set = new WorkingPartSet(NULL);
    dest_it.add_after_then_move(working_set);
    if (first_new_set == NULL)
      first_new_set = working_set;
    // A matching column gets to stay, and first_new_set gets all the
    // completed_sets.
    working_set = src_it.empty() ? NULL : src_it.data();
    if (working_set != NULL &&
        working_set->column()->MatchingColumns(*column)) {
      working_set->set_column(column);
      dest_it.add_after_then_move(src_it.extract());
      src_it.forward();
      first_new_set->InsertCompletedBlocks(&completed_blocks, &to_blocks);
      first_new_set = NULL;
    } else {
      // Just make a new working set for the current column.
      working_set = new WorkingPartSet(column);
      dest_it.add_after_then_move(working_set);
    }
  }
  // Complete any remaining src working sets.
  while (!src_it.empty()) {
    working_set = src_it.extract();
    working_set->ExtractCompletedBlocks(bleft, tright, resolution,
                                        used_parts, &completed_blocks,
                                        &to_blocks);
    delete working_set;
    src_it.forward();
  }
  // Make a new between-column WorkingSet for after the last column.
  working_set = new WorkingPartSet(NULL);
  dest_it.add_after_then_move(working_set);
  if (first_new_set == NULL)
    first_new_set = working_set;
  // The first_new_set now gets any accumulated completed_parts/blocks.
  first_new_set->InsertCompletedBlocks(&completed_blocks, &to_blocks);
}

// Accumulate the widths and gaps into the given variables.
void ColPartitionSet::AccumulateColumnWidthsAndGaps(int* total_width,
                                                    int* width_samples,
                                                    int* total_gap,
                                                    int* gap_samples) {
  ColPartition_IT it(&parts_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColPartition* part = it.data();
    *total_width += part->ColumnWidth();
    ++*width_samples;
    if (!it.at_last()) {
      ColPartition* next_part = it.data_relative(1);
      int gap = part->KeyWidth(part->right_key(), next_part->left_key());
      *total_gap += gap;
      ++*gap_samples;
    }
  }
}

// Provide debug output for this ColPartitionSet and all the ColPartitions.
void ColPartitionSet::Print() {
  ColPartition_IT it(&parts_);
  tprintf("Partition set of %d parts, %d good, coverage=%d (%d,%d)->(%d,%d)\n",
          it.length(), good_column_count_, total_coverage_,
          bounding_box_.left(), bounding_box_.bottom(),
          bounding_box_.right(), bounding_box_.top());
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColPartition* part = it.data();
    part->Print();
  }
}

// PRIVATE CODE.

// Add the given partition to the list in the appropriate place.
void ColPartitionSet::AddPartition(ColPartition* new_part,
                                   ColPartition_IT* it) {
  bounding_box_ += new_part->bounding_box();
  if (new_part->good_column() || new_part->good_width()) {
    total_coverage_ += new_part->ColumnWidth();
    ++good_column_count_;
    if (new_part->good_width())
      ++good_column_count_;
  }
  int new_right = new_part->right_key();
  if (it->data()->left_key() >= new_right)
    it->add_before_stay_put(new_part);
  else
    it->add_after_stay_put(new_part);
}

// Compute the coverage and good column count.
void ColPartitionSet::ComputeCoverage() {
  // Count the number of good columns and sum their width.
  ColPartition_IT it(&parts_);
  good_column_count_ = 0;
  total_coverage_ = 0;
  bounding_box_ = TBOX();
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColPartition* part = it.data();
    bounding_box_ += part->bounding_box();
    if (part->good_column() || part->good_width()) {
      total_coverage_ += part->ColumnWidth();
      ++good_column_count_;
      if (part->good_width())
        ++good_column_count_;
    }
  }
}
/////////////////////////////////////////////////////////////////colpartitionset////////////////////////////////////////

/////////////////////////////////////////////////////////////////tablefind////////////////////////////////////////
// Maximum vertical spacing between neighbor partitions
const int kMaxVerticalSpacing = 500;

// Minimum number of components in a text partition. A partition having fewer
// components than that is more likely a data partition and is a candidate
// table cell.
const int kMinBoxesInTextPartition = 10;

// Maximum number of components that a data partition can have
const int kMaxBoxesInDataPartition = 20;

// Maximum allowed gap in a text partitions as a multiple of its median size.
const double kMaxGapInTextPartition = 4.0;

// Minimum value that the maximum gap in a text partition should have as a
// factor of its median size.
const double kMinMaxGapInTextPartition = 0.5;

// Maximum x-height a table partition can have as a multiple of global
// median x-height
const double kMaxTableCellXheight = 2.0;

// Maximum line spacing between a table column header and column contents
// for merging the two
const int kMaxColumnHeaderDistance = 100;

// Minimum ratio of num_table_partitions to num_text_partitions in a column
// block to be called it a table column
const double kTableColumnThreshold = 3.0;

// Search for horizontal ruling lines within the vertical margin as a
// multiple of grid size
const int kRulingVerticalMargin = 3;

// Minimum overlap that a colpartition must have with a table region
// to become part of that table
const double kMinOverlapWithTable = 0.6;

// Maximum side space (distance from column boundary) that a typical
// text-line in flowing text should have as a multiple of its x-height
// (Median size).
const int kSideSpaceMargin = 10;

// Fraction of the peak of x-projection of a table region to set the
// threshold for the x-projection histogram
const double kProjectionThreshold = 0.35;

// Minmimum number of rows in a table
const int kMinRowsInTable = 3;

BOOL_VAR(textord_dump_table_images, false, "Paint table detection output");
BOOL_VAR(textord_show_tables, false, "Show table regions");

ELISTIZE(ColSegment)
CLISTIZE(ColSegment)

// Copy cleaned partitions from part_grid_ to clean_part_grid_ and
// insert dot-like noise into period_grid_
void ColumnFinder::GetCleanPartitions(TO_BLOCK* block) {
  double min_dim = block->line_size/3.0;
  // Initialize clean partitions list and grid
  clean_part_grid_.Init(gridsize(), bleft(), tright());
  period_grid_.Init(gridsize(), bleft(), tright());
  // Iterate the ColPartitions in the grid.
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&part_grid_);
  gsearch.StartFullSearch();
  ColPartition* part;
  while ((part = gsearch.NextFullSearch()) != NULL) {
    ColPartition* clean_part = part->ShallowCopy();
    // Insert all non-text partitions to clean_parts
    if (!part->IsTextType()) {
      clean_part_grid_.InsertBBox(true, true, clean_part);
      continue;
    }
    // Insert text colpartitions after removing noisy components from them
    BLOBNBOX_CLIST* part_boxes = part->boxes();
    BLOBNBOX_C_IT pit(part_boxes);
    for (pit.mark_cycle_pt(); !pit.cycled_list(); pit.forward()) {
      BLOBNBOX *pblob = pit.data();
      if (!pblob->noise_flag()) {
        clean_part->AddBox(pblob);
      } else {
        TBOX blob_box = pblob->bounding_box();
        if (blob_box.height() < min_dim && blob_box.width() < 2*min_dim) {
          period_grid_.InsertBBox(false, false, pblob);
        }
      }
    }
    if (!clean_part->IsEmpty())
      clean_part_grid_.InsertBBox(true, true, clean_part);
    else
      delete clean_part;
  }

// TODO(rays) This is the previous period blob code. Neither is completely
// satisfactory, as a more disciplined approach to noise removal would be
// better, so revisit this choice and decide what to keep when the earlier
// stages do a better job of noise removal.
#if 0
  BLOBNBOX_IT sit(&block->small_blobs);
  BLOBNBOX_IT nit(&block->noise_blobs);
  BLOBNBOX_IT it(&period_blobs_);
  // Insert dot sized boxes from small_blobs into period_blobs_
  for (sit.mark_cycle_pt(); !sit.cycled_list(); sit.forward()) {
    BLOBNBOX * blob = sit.data();
    TBOX blob_box = blob->bounding_box();
    if (blob_box.height() < min_dim && blob_box.width() < 2*min_dim) {
      it.add_after_then_move(sit.extract());
    }
  }
  // Insert dot sized boxes from noise_blobs into period_blobs_
  for (nit.mark_cycle_pt(); !nit.cycled_list(); nit.forward()) {
    BLOBNBOX * blob = nit.data();
    TBOX blob_box = blob->bounding_box();
    if (blob_box.height() < min_dim && blob_box.width() < 2*min_dim) {
      it.add_after_then_move(nit.extract());
    }
  }
  InsertBlobList(false, false, false, &period_blobs_, false, &period_grid_);
#endif
}

// High level function to perform table detection
void ColumnFinder::LocateTables() {
  // Make single-column blocks from good_columns_ partitions. col_segments are
  // moved to a grid later which takes the ownership
  ColSegment_LIST column_blocks;
  GetColumnBlocks(&column_blocks);

  SetPartitionSpacings();

  // Mark ColPartitions as being candidate table partition depending on
  // the inter-word spacing
  GridMarkTablePartitions();
  FilterFalseAlarms();
  SmoothTablePartitionRuns();

  // Set the ratio of candidate table partitions in each column
  SetColumnsType(&column_blocks);

  // Move column segments to col_seg_grid_
  MoveColSegmentsToGrid(&column_blocks, &col_seg_grid_);

  // Detect split in column layout that might have occured due to the
  // presence of a table. In such a case, merge the corresponding columns.
  GridMergeColumnBlocks();

  // Group horizontally overlapping table partitions into table columns.
  // table_columns created here get deleted at the end of this method.
  ColSegment_LIST table_columns;
  GetTableColumns(&table_columns);

  // Within each column, mark the range table regions occupy based on the
  // table columns detected. table_regions are moved to a grid later which
  // takes the ownership
  ColSegment_LIST table_regions;
  GetTableRegions(&table_columns, &table_regions);

  // Merge table regions across columns for tables spanning multiple
  // columns
  MoveColSegmentsToGrid(&table_regions, &table_grid_);
  GridMergeTableRegions();

  // Adjust table boundaries by including nearby horizontal lines and left
  // out column headers
  AdjustTableBoundaries();
  GridMergeTableRegions();

  // Remove false alarms consiting of a single column
  DeleteSingleColumnTables();

  if (textord_show_tables) {
    ScrollView* table_win = MakeWindow(1500, 300, "Detected Tables");
    DisplayColPartitions(table_win, ScrollView::BLUE);
    DisplayColSegments(&table_columns, table_win, ScrollView::GREEN);
    table_grid_.DisplayBoxes(table_win);
  }

  if (textord_dump_table_images)
    WriteToPix();

  // Merge all colpartitions in table regions to make them a single
  // colpartition and revert types of isolated table cells not
  // assigned to any table to their original types.
  MakeTableBlocks();
}

// Make single-column blocks from good_columns_ partitions.
void ColumnFinder::GetColumnBlocks(ColSegment_LIST* column_blocks) {
  for (int i = 0; i < gridheight_; ++i) {
    ColPartitionSet* columns = best_columns_[i];
    if (columns != NULL) {
      ColSegment_LIST new_blocks;
      // Get boxes from the current vertical position on the grid
      columns->GetColumnBoxes(i*gridsize_, (i + 1) * gridsize_, &new_blocks);
      // Merge the new_blocks boxes into column_blocks if they are well-aligned
      GroupColumnBlocks(&new_blocks, column_blocks);
    }
  }
}

// Merge column segments into the current list if they are well aligned.
void ColumnFinder::GroupColumnBlocks(ColSegment_LIST* new_blocks,
                                     ColSegment_LIST* column_blocks) {
  ColSegment_IT src_it(new_blocks);
  ColSegment_IT dest_it(column_blocks);
  // iterate through the source list
  for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
    ColSegment* src_seg = src_it.data();
    TBOX src_box = src_seg->bounding_box();
    bool match_found = false;
    // iterate through the destination list to find a matching column block
    for (dest_it.mark_cycle_pt(); !dest_it.cycled_list(); dest_it.forward()) {
      ColSegment* dest_seg = dest_it.data();
      TBOX dest_box = dest_seg->bounding_box();
      if (ConsecutiveBoxes(src_box, dest_box)) {
        // If matching block is found, insert the current block into it
        // and delete the soure block
        dest_seg->InsertBox(src_box);
        match_found = true;
        delete src_it.extract();
        break;
      }
    }
    // If no match is found, just append the source block to column_blocks
    if (!match_found) {
      dest_it.add_after_then_move(src_it.extract());
    }
  }
}

// are the two boxes immediate neighbors along the vertical direction
bool ColumnFinder::ConsecutiveBoxes(const TBOX &b1, const TBOX &b2) {
  int x_margin = 20;
  int y_margin = 5;
  return (abs(b1.left() - b2.left()) < x_margin) &&
      (abs(b1.right() - b2.right()) < x_margin) &&
      (abs(b1.top()-b2.bottom()) < y_margin ||
       abs(b2.top()-b1.bottom()) < y_margin);
}

// Set left, right and top, bottom spacings of each colpartition.
void ColumnFinder::SetPartitionSpacings() {
  // Iterate the ColPartitions in the grid.
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&clean_part_grid_);
  gsearch.StartFullSearch();
  ColPartition* part;
  while ((part = gsearch.NextFullSearch()) != NULL) {
    ColPartitionSet* columns = best_columns_[gsearch.GridY()];
    TBOX box = part->bounding_box();
    int y = part->MidY();
    ColPartition* left_column = columns->ColumnContaining(box.left(), y);
    ColPartition* right_column = columns->ColumnContaining(box.right(), y);
    // set distance from left column as space to the left
    if (left_column) {
      int left_space = MAX(0, box.left() - left_column->LeftAtY(y));
      part->set_space_to_left(left_space);
    }
    // set distance from right column as space to the right
    if (right_column) {
      int right_space = MAX(0, right_column->RightAtY(y) - box.right());
      part->set_space_to_right(right_space);
    }
    SetVerticalSpacing(part);
  }
  SetGlobalSpacings();
}

// Set spacing and closest neighbors above and below a given colpartition.
void ColumnFinder::SetVerticalSpacing(ColPartition* part) {
  TBOX box = part->bounding_box();
  int top_range = MIN(box.top() + kMaxVerticalSpacing, tright().y());
  int bottom_range = MAX(box.bottom() - kMaxVerticalSpacing, bleft().y());
  box.set_top(top_range);
  box.set_bottom(bottom_range);

  TBOX part_box = part->bounding_box();
  // Start a rect search
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
      rectsearch(&clean_part_grid_);
  rectsearch.StartRectSearch(box);
  ColPartition* neighbor;
  int min_space_above = kMaxVerticalSpacing;
  int min_space_below = kMaxVerticalSpacing;
  ColPartition* above_neighbor = NULL;
  ColPartition* below_neighbor = NULL;
  while ((neighbor = rectsearch.NextRectSearch()) != NULL) {
    if (neighbor == part)
      continue;
    TBOX neighbor_box = neighbor->bounding_box();
    if (neighbor_box.major_x_overlap(part_box)) {
      int gap = abs(part->median_bottom() - neighbor->median_bottom());
      // If neighbor is below current partition
      if (neighbor_box.top() < part_box.bottom() &&
          gap < min_space_below) {
        min_space_below = gap;
        below_neighbor = neighbor;
      }  // If neighbor is above current partition
      else if (part_box.top() < neighbor_box.bottom() &&
               gap < min_space_above) {
        min_space_above = gap;
        above_neighbor = neighbor;
       }
    }
  }
  part->set_space_above(min_space_above);
  part->set_space_below(min_space_below);
  part->set_nearest_neighbor_above(above_neighbor);
  part->set_nearest_neighbor_below(below_neighbor);
}

// Set global spacing and x-height estimates
void ColumnFinder::SetGlobalSpacings() {
  STATS xheight_stats(0, kMaxVerticalSpacing + 1);
  STATS ledding_stats(0, kMaxVerticalSpacing + 1);
  // Iterate the ColPartitions in the grid.
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&clean_part_grid_);
  gsearch.StartFullSearch();
  ColPartition* part;
  while ((part = gsearch.NextFullSearch()) != NULL) {
    if (part->IsTextType()) {
      xheight_stats.add(part->median_size(), 1);
      ledding_stats.add(part->space_above(), 1);
      ledding_stats.add(part->space_below(), 1);
    }
  }
  // Set estimates based on median of statistics obtained
  global_median_xheight_ = static_cast<int>(xheight_stats.median() + 0.5);
  global_median_ledding_ = static_cast<int>(ledding_stats.median() + 0.5);
  if (textord_show_tables) {
    ScrollView* stats_win = MakeWindow(500, 10,
                                       "X-height and ledding histograms");
    xheight_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::GREEN);
    ledding_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::RED);
  }
}

// Three types of partitions are maked as table partitions:
//  1- Partitions that have at lease one large gap between words
//  2- Partitions that consist of only one word (no significant gap
//     between components)
//  3- Partitions that vertically overlap with other partitions within the
//     same column.
void ColumnFinder::GridMarkTablePartitions() {
  // Iterate the ColPartitions in the grid.
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&clean_part_grid_);
  gsearch.StartFullSearch();
  ColPartition* part;
  while ((part = gsearch.NextFullSearch()) != NULL) {
    if (!part->IsTextType())  // Only consider text partitions
      continue;
    // Only consider partitions in dominant font size or smaller
    if (part->median_size() > kMaxTableCellXheight * global_median_xheight_)
      continue;
    // Mark partitions with a large gap, or no significant gap as
    // table partitions.
    // Comments: It produces several false alarms at:
    //  - last line of a paragraph
    //  - single word section headings
    //  - page headers and footers
    //  - numbered equations
    //  - line drawing regions
    // TODO(faisal): detect and fix above-mentioned cases
    if (HasWideOrNoInterWordGap(part)) {
      part->set_table_type();
    }
  }
}

// Check if the partition has at lease one large gap between words or no
// significant gap at all
bool ColumnFinder::HasWideOrNoInterWordGap(ColPartition* part) {
  BLOBNBOX_CLIST* part_boxes = part->boxes();
  BLOBNBOX_C_IT pit(part_boxes);

  if (part->bounding_box().width() <
      kMinBoxesInTextPartition * part->median_size() &&
      pit.length() < kMinBoxesInTextPartition)
    return true;

  // Make a copy of the components in the current partition and insert periods
  // into it to compute gaps while taking periods into account.
  BLOBNBOX_CLIST boxes;
  BLOBNBOX_C_IT it(&boxes);
  for (pit.mark_cycle_pt(); !pit.cycled_list(); pit.forward()) {
    BLOBNBOX *pblob = pit.data();
    it.add_after_then_move(pblob);
  }
  // Start rectangular search to find periods in this partition
  GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> rectsearch(&period_grid_);
  TBOX part_box = part->bounding_box();
  rectsearch.StartRectSearch(part_box);
  BLOBNBOX* period;
  while ((period = rectsearch.NextRectSearch()) != NULL) {
    // Insert a period only if it lies in a gap between two consecutive boxes
    if (LiesInGap(period, &boxes))
      boxes.add_sorted(SortByBoxLeft<BLOBNBOX>, true, period);
  }

  int current_x0;
  int current_x1;
  int previous_x1 = -1;
  int max_partition_gap = -1;
  double max_gap = kMaxGapInTextPartition * part->median_size();
  double min_gap = kMinMaxGapInTextPartition * part->median_size();

  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    BLOBNBOX *blob = it.data();
    current_x0 = blob->bounding_box().left();
    current_x1 = blob->bounding_box().right();
    if (previous_x1 != -1) {
      int gap = current_x0 - previous_x1;
      // If a large enough gap is found, mark it as a table cell (return true)
      if (gap > max_gap)
        return true;
      if (gap > max_partition_gap)
        max_partition_gap = gap;
    }
    previous_x1 = current_x1;
  }
  // Since no large gap was found, return false if the partition is too
  // long to be a data cell
  if (part->bounding_box().width() >
      kMaxBoxesInDataPartition * part->median_size() ||
      pit.length() > kMaxBoxesInDataPartition)
    return false;

  // return true if the maximum gap found is smaller than the minimum allowed
  // max_gap in a text partition
  return (max_partition_gap < min_gap);
}

// Check if the period lies in a gap between consecutive boxes
bool ColumnFinder::LiesInGap(BLOBNBOX* period, BLOBNBOX_CLIST* boxes) {
  BLOBNBOX_C_IT it(boxes);
  TBOX period_box = period->bounding_box();
  int num_boxes = it.length();
  // skip the first element since it has no gap to its left.
  it.forward();
  for (int i = 1; i < num_boxes; i++) {
    TBOX box = it.data()->bounding_box();
    TBOX previous_blob = it.data_relative(-1)->bounding_box();
    TBOX gap_box = TBOX(previous_blob.botright(), box.topleft());
    if (gap_box.major_overlap(period_box)) {
      return true;
    }
    it.forward();
  }
  return false;
}

// Filter individual text partitions marked as table partitions
// consisting of paragraph endings, small section headings, and
// headers and footers.
void ColumnFinder::FilterFalseAlarms() {
  // Detect last line of paragraph
  // Iterate the ColPartitions in the grid.
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&clean_part_grid_);
  gsearch.StartFullSearch();
  ColPartition* part;
  while ((part = gsearch.NextFullSearch()) != NULL) {
    if (part->type() != PT_TABLE)
      continue;  // Consider only table partitions

    // Paragraph ending should have flowing text above it.
    ColPartition* upper_part = part->nearest_neighbor_above();
    if (!upper_part)
      continue;
    if (upper_part->type() != PT_FLOWING_TEXT)
      continue;
    if (upper_part->bounding_box().width() <
        2 * part->bounding_box().width())
      continue;
    // Paragraph ending should be left-aligned to text line above it.
    if (abs(part->bounding_box().left() - upper_part->bounding_box().left())
        > global_median_xheight_)
      continue;
    // Ledding above the line should be less than ledding below
    if (part->space_above() < part->space_below() &&
        part->space_above() <= 2 * global_median_ledding_)
      part->clear_table_type();
  }
  // Consider top-most text colpartition as header and bottom most as footer
  ColPartition* header = NULL;
  ColPartition* footer = NULL;
  int max_top = -MAX_INT32;
  int min_bottom = MAX_INT32;
  gsearch.StartFullSearch();
  while ((part = gsearch.NextFullSearch()) != NULL) {
    if (!part->IsTextType())
      continue;  // Consider only text partitions
    int top = part->bounding_box().top();
    int bottom = part->bounding_box().bottom();
    if (top > max_top) {
      max_top = top;
      header = part;
    }
    if (bottom < min_bottom) {
      min_bottom = bottom;
      footer = part;
    }
  }
  if (header)
    header->clear_table_type();
  if (footer)
    footer->clear_table_type();
}

// Mark all ColPartitions as table cells that have a table cell above
// and below them
// TODO(faisal): This is too aggressive at the moment. The method needs to
// consider spacing and alignment as well. Detection of false alarm table cells
// should also be done as part of it.
void ColumnFinder::SmoothTablePartitionRuns() {
  // Iterate the ColPartitions in the grid.
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&clean_part_grid_);
  gsearch.StartFullSearch();
  ColPartition* part;
  while ((part = gsearch.NextFullSearch()) != NULL) {
    if (part->type() >= PT_TABLE)
      continue;  // Consider only text partitions
    ColPartition* upper_part = part->nearest_neighbor_above();
    ColPartition* lower_part = part->nearest_neighbor_below();
    if (!upper_part || !lower_part)
      continue;
    if (upper_part->type() == PT_TABLE && lower_part->type() == PT_TABLE)
      part->set_table_type();
  }
}

// Set the type of a column segment based on the ratio of table to text cells
void ColumnFinder::SetColumnsType(ColSegment_LIST* column_blocks) {
  ColSegment_IT it(column_blocks);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColSegment* seg = it.data();
    TBOX box = seg->bounding_box();
    int num_table_cells = 0;
    int num_text_cells = 0;
    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
        rsearch(&clean_part_grid_);
    rsearch.StartRectSearch(box);
    ColPartition* part;
    while ((part = rsearch.NextRectSearch()) != NULL) {
      if (!rsearch.ReturnedSeedElement())
        continue;  // Consider each partition only once
      if (part->type() == PT_TABLE) {
        num_table_cells++;
      } else if (part->type() == PT_FLOWING_TEXT) {
        num_text_cells++;
      }
    }
    // If a column block has no text or table partition in it, it is not needed
    // for table detection.
    if (!num_table_cells && !num_text_cells) {
      delete it.extract();
    } else {
      seg->set_num_table_cells(num_table_cells);
      seg->set_num_text_cells(num_text_cells);
      // set column type based on the ratio of table to text cells
      seg->set_type();
    }
  }
}

// Move column blocks to grid
void ColumnFinder::MoveColSegmentsToGrid(ColSegment_LIST *segments,
                                         ColSegmentGrid *col_seg_grid) {
  col_seg_grid->Init(gridsize(), bleft(), tright());
  ColSegment_IT it(segments);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColSegment* seg = it.extract();
    col_seg_grid->InsertBBox(true, true, seg);
  }
}

// Merge column blocks if a split is detected due to the presence of a
// table. A text block is considered split if it has multiple
// neighboring blocks above/below it, and at least one of the
// neighboring blocks is of table type (has a high density of table
// partitions). In this case neighboring blocks in the direction
// (above/below) of the table block are merged with the text block.

// Comment: This method does not handle split due to a full page table
// since table columns in this case do not have a text column on which
// split decision can be based.
void ColumnFinder::GridMergeColumnBlocks() {
  int margin = gridsize_;

  // Iterate the Column Blocks in the grid.
  GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT>
    gsearch(&col_seg_grid_);
  gsearch.StartFullSearch();
  ColSegment* seg;
  while ((seg = gsearch.NextFullSearch()) != NULL) {
    if (seg->type() != COL_TEXT)
      continue;  // only consider text blocks for split detection
    bool neighbor_found = false;
    bool modified = false;  // Modified at least once
    // keep expanding current box as long as neighboring table columns
    // are found above or below it.
    do {
      TBOX box = seg->bounding_box();
      // slightly expand the search region vertically
      int top_range = MIN(box.top() + margin, tright().y());
      int bottom_range = MAX(box.bottom() - margin, bleft().y());
      box.set_top(top_range);
      box.set_bottom(bottom_range);
      neighbor_found = false;
      GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT>
          rectsearch(&col_seg_grid_);
      rectsearch.StartRectSearch(box);
      ColSegment* neighbor;
      while ((neighbor = rectsearch.NextRectSearch()) != NULL) {
        if (neighbor == seg)
          continue;
        TBOX neighbor_box = neighbor->bounding_box();
        // If the neighbor box significantly overlaps with the current
        // box (due to the expansion of the current box in the
        // previous iteration of this loop), remove the neighbor box
        // and expand the current box to include it.
        if (neighbor_box.overlap_fraction(box) >= 0.9) {
          seg->InsertBox(neighbor_box);
          modified = true;
          rectsearch.RemoveBBox();
          gsearch.RepositionIterator();
          delete neighbor;
          continue;
        }
        // Only expand if the neighbor box is of table type
        if (neighbor->type() != COL_TABLE)
          continue;
        // Insert the neighbor box into the current column block
        if (neighbor_box.major_x_overlap(box) &&
            !box.contains(neighbor_box)) {
          seg->InsertBox(neighbor_box);
          neighbor_found = true;
          modified = true;
          rectsearch.RemoveBBox();
          gsearch.RepositionIterator();
          delete neighbor;
        }
      }
    } while (neighbor_found);
    if (modified) {
      // Because the box has changed, it has to be removed first.
      gsearch.RemoveBBox();
      col_seg_grid_.InsertBBox(true, true, seg);
      gsearch.RepositionIterator();
    }
  }
}

// Group horizontally overlapping table partitions into table columns.
// TODO(faisal): This is too aggressive at the moment. The method should
// consider more attributes to group table partitions together. Some common
// errors are:
//  1- page number is merged with a table column above it even
//      if there is a large vertical gap between them.
//  2- column headers go on to catch one of the columns arbitrarily
//  3- an isolated noise blob near page top or bottom merges with the table
//     column below/above it
//  4- cells from two vertically adjacent tables merge together to make a
//     single column resulting in merging of the two tables
void ColumnFinder::GetTableColumns(ColSegment_LIST *table_columns) {
  ColSegment_IT it(table_columns);
  // Iterate the ColPartitions in the grid.
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&clean_part_grid_);
  gsearch.StartFullSearch();
  ColPartition* part;
  while ((part = gsearch.NextFullSearch()) != NULL) {
    if (part->inside_table_column() || part->type() != PT_TABLE)
      continue;  // prevent a partition to be assigned to multiple columns
    TBOX box = part->bounding_box();
    ColSegment* col = new ColSegment();
    col->InsertBox(box);
    part->set_inside_table_column(true);
    // Start a search below the current cell to find bottom neighbours
    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
        vsearch(&clean_part_grid_);
    vsearch.StartVerticalSearch(box.left(), box.right(), box.bottom());
    ColPartition* neighbor;
    bool found_neighbours = false;
    while ((neighbor = vsearch.NextVerticalSearch(true)) != NULL) {
      // only consider neighbors not assigned to any column yet
      if (neighbor->inside_table_column())
        continue;

      // presence of a non-table neighbor marks the end of current
      // table column
      if (neighbor->type() != PT_TABLE) {
        // Horizontal lines should not break the flow
        if (neighbor->IsLineType())
          continue;
        else
          break;
      }
      TBOX neighbor_box = neighbor->bounding_box();
      col->InsertBox(neighbor_box);
      neighbor->set_inside_table_column(true);
      found_neighbours = true;
    }
    if (found_neighbours) {
      it.add_after_then_move(col);
    } else {
      part->set_inside_table_column(false);
      delete col;
    }
  }
}

// Mark regions in a column that are x-bounded by the column boundaries and
// y-bounded by the table columns' projection on the y-axis as table regions
void ColumnFinder::GetTableRegions(ColSegment_LIST* table_columns,
                                   ColSegment_LIST* table_regions) {
  ColSegment_IT cit(table_columns);
  ColSegment_IT rit(table_regions);
  // Iterate through column blocks
  GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT>
      gsearch(&col_seg_grid_);
  gsearch.StartFullSearch();
  ColSegment* part;
  int page_height = tright().y() - bleft().y();
  ASSERT_HOST(page_height > 0);
  // create a bool array to hold projection on y-axis
  bool* table_region = new bool[page_height];
  while ((part = gsearch.NextFullSearch()) != NULL) {
    TBOX part_box = part->bounding_box();
    // reset the projection array
    for (int i = 0; i < page_height; i++) {
      table_region[i] = false;
    }
    // iterate through all table columns to find regions in the current
    // page column block
    cit.move_to_first();
    for (cit.mark_cycle_pt(); !cit.cycled_list(); cit.forward()) {
      TBOX col_box = cit.data()->bounding_box();
      // find intersection region of table column and page column
      TBOX intersection_box = col_box.intersection(part_box);
      // project table column on the y-axis
      for (int i = intersection_box.bottom(); i < intersection_box.top(); i++) {
        table_region[i - bleft().y()] = true;
      }
    }
    // set x-limits of table regions to page column width
    TBOX current_table_box;
    current_table_box.set_left(part_box.left());
    current_table_box.set_right(part_box.right());
    // go through the y-axis projection to find runs of table
    // regions. Each run makes one table region.
    for (int i = 1; i < page_height; i++) {
      // detect start of a table region
      if (!table_region[i - 1] && table_region[i]) {
        current_table_box.set_bottom(i + bleft().y());
      }
      // detect end of a table region
      if (table_region[i - 1] && !table_region[i]) {
        current_table_box.set_top(i + bleft().y());
        if (!current_table_box.null_box()) {
          ColSegment* seg = new ColSegment();
          seg->InsertBox(current_table_box);
          rit.add_after_then_move(seg);
        }
      }
    }
  }
  delete[] table_region;
}

// Merge table regions corresponding to tables spanning multiple columns if
// there is a colpartition (horizontal ruling line or normal text) that
// touches both regions.
// TODO(faisal): A rare error occurs if there are two horizontally adjacent
// tables with aligned ruling lines. In this case, line finder returns a
// single line and hence the tables get merged together
void ColumnFinder::GridMergeTableRegions() {
  // Iterate the table regions in the grid.
  GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT>
      gsearch(&table_grid_);
  gsearch.StartFullSearch();
  ColSegment* seg;
  while ((seg = gsearch.NextFullSearch()) != NULL) {
    bool neighbor_found = false;
    bool modified = false;  // Modified at least once
    do {
      // Start a rectangle search x-bounded by the image and y by the table
      TBOX box = seg->bounding_box();
      TBOX search_region(box);
      search_region.set_left(bleft().x());
      search_region.set_right(tright().x());
      neighbor_found = false;
      GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT>
          rectsearch(&table_grid_);
      rectsearch.StartRectSearch(search_region);
      ColSegment* neighbor;
      while ((neighbor = rectsearch.NextRectSearch()) != NULL) {
        if (neighbor == seg)
          continue;
        TBOX neighbor_box = neighbor->bounding_box();
        // Check if a neighbor box has a large overlap with the table
        // region.  This may happen as a result of merging two table
        // regions in the previous iteration.
        if (neighbor_box.overlap_fraction(box) >= 0.9) {
          seg->InsertBox(neighbor_box);
          rectsearch.RemoveBBox();
          gsearch.RepositionIterator();
          delete neighbor;
          modified = true;
          continue;
        }
        // Check if two table regions belong together based on a common
        // horizontal ruling line
        if (BelongToOneTable(box, neighbor_box)) {
          seg->InsertBox(neighbor_box);
          neighbor_found = true;
          modified = true;
        }
      }
    } while (neighbor_found);
    if (modified) {
      // Because the box has changed, it has to be removed first.
      gsearch.RemoveBBox();
      table_grid_.InsertBBox(true, true, seg);
      gsearch.RepositionIterator();
    }
  }
}

// Decide if two table regions belong to one table based on a common
// horizontal ruling line or another colpartition
bool ColumnFinder::BelongToOneTable(const TBOX &box1, const TBOX &box2) {
  // Check for ColPartitions spanning both table regions
  TBOX bbox = box1.bounding_union(box2);
  // Start a rect search on bbox
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
      rectsearch(&clean_part_grid_);
  rectsearch.StartRectSearch(bbox);
  ColPartition* part;
  while ((part = rectsearch.NextRectSearch()) != NULL) {
    TBOX part_box = part->bounding_box();
    // return true if a colpartition spanning both table regions is found
    if (part_box.overlap(box1) && part_box.overlap(box2))
      return true;
  }
  return false;
}

// Adjust table boundaries by:
//  - building a tight bounding box around all ColPartitions contained in it.
//  - expanding table boundaries to include all colpartitions that overlap the
//    table by more than half of their area
//  - expanding table boundaries to include nearby horizontal rule lines
//  - expanding table vertically to include left out column headers
// TODO(faisal): Expansion of table boundaries is quite aggressive. It usually
//               makes following errors:
//  1- horizontal lines consisting of underlines are included in the table if
//     they are close enough
//  2- horizontal lines originating from noise tend to get merged with a table
//     near the top of the page
//  3- the criteria for including horizontal lines is very generous. Many times
//     horizontal lines separating headers and footers get merged with a
//     single-column table in a multi-column page thereby including text
//     from the neighboring column inside the table
//  4- the criteria for including left out column headers also tends to
//     occasionally include text-lines above the tables, typically from
//     table caption
void ColumnFinder::AdjustTableBoundaries() {
  // Iterate the table regions in the grid
  ColSegment_CLIST adjusted_tables;
  ColSegment_C_IT it(&adjusted_tables);
  GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT>
      gsearch(&table_grid_);
  gsearch.StartFullSearch();
  ColSegment* table;
  // search for horizontal ruling lines within the vertical margin
  int vertical_margin = kRulingVerticalMargin * gridsize_;
  while ((table = gsearch.NextFullSearch()) != NULL) {
    TBOX table_box = table->bounding_box();
    TBOX search_box = table_box;
    int top = MIN(search_box.top() + vertical_margin, tright().y());
    int bottom = MAX(search_box.bottom() - vertical_margin, bleft().y());
    search_box.set_top(top);
    search_box.set_bottom(bottom);
    TBOX box;
    // Start a rect search on table_box
    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
        rectsearch(&clean_part_grid_);
    rectsearch.StartRectSearch(search_box);
    ColPartition* part;
    while ((part = rectsearch.NextRectSearch()) != NULL) {
     // Do not consider image partitions
      if (part->IsImageType())
        continue;
      TBOX part_box = part->bounding_box();
      // Include partition in the table if more than half of it
      // is covered by the table
      if (part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
        box = box.bounding_union(part_box);
        continue;
      }
      // Include a partially overlapping horizontal line only if the
      // extra ColPartitions that will be included due to expansion
      // have large side spacing w.r.t. columns containing them.
      if (HLineBelongsToTable(part, table_box)) {
        box = box.bounding_union(part_box);
      }
    }
    IncludeLeftOutColumnHeaders(box);
    // To prevent a table from expanding again, do not insert the
    // modified box back to the grid. Instead move it to a list and
    // and remove it from the grid. The list is moved later back to the grid.
    if (!box.null_box()) {
      ColSegment* col = new ColSegment();
      col->InsertBox(box);
      it.add_after_then_move(col);
    }
    gsearch.RemoveBBox();
    delete table;
  }
  // clear table grid to move final tables in it
  table_grid_.Clear();
  it.move_to_first();
  // move back final tables to table_grid_
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColSegment* seg = it.extract();
    table_grid_.InsertBBox(true, true, seg);
  }
}

// Checks whether the horizontal line belong to the table by looking at the
// side spacing of extra ColParitions that will be included in the table
// due to expansion
bool ColumnFinder::HLineBelongsToTable(ColPartition* part,
                                       const TBOX& table_box) {
  TBOX part_box = part->bounding_box();
  if (!part->IsLineType() || !part_box.major_x_overlap(table_box))
    return false;
  // Do not consider top-most horizontal line since it usually
  // originates from noise
  if (!part->nearest_neighbor_above())
    return false;
  TBOX bbox = part_box.bounding_union(table_box);
  // Start a rect search on bbox
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
      rectsearch(&clean_part_grid_);
  rectsearch.StartRectSearch(bbox);
  ColPartition* extra_part;
  int num_extra_partitions = 0;
  int extra_space_to_right = 0;
  int extra_space_to_left = 0;
  while ((extra_part = rectsearch.NextRectSearch()) != NULL) {
    if (!rectsearch.ReturnedSeedElement())
      continue;
    TBOX extra_part_box = extra_part->bounding_box();
    if (extra_part_box.overlap_fraction(table_box) > 0.6)
      continue;  // ColPartition already in table
    if (extra_part->IsImageType())  // Non-text ColPartitions do not contribute
      continue;
    num_extra_partitions++;
    // presense of a table cell is a strong hint, so just increment the scores
    // without looking at the spacing.
    if (extra_part->type() == PT_TABLE || extra_part->IsLineType()) {
      extra_space_to_right++;
      extra_space_to_left++;
      continue;
    }
    int space_threshold = kSideSpaceMargin * part->median_size();
    if (extra_part->space_to_right() > space_threshold)
      extra_space_to_right++;
    if (extra_part->space_to_left() > space_threshold)
      extra_space_to_left++;
  }
  // tprintf("%d %d %d\n",
  // num_extra_partitions,extra_space_to_right,extra_space_to_left);
  return (extra_space_to_right > num_extra_partitions / 2) ||
      (extra_space_to_left > num_extra_partitions / 2);
}

// Look for isolated column headers above the given table box and
// include them in the table
void ColumnFinder::IncludeLeftOutColumnHeaders(TBOX& table_box) {
  // Start a search above the current table to look for column headers
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
      vsearch(&clean_part_grid_);
  vsearch.StartVerticalSearch(table_box.left(), table_box.right(),
                              table_box.top());
  ColPartition* neighbor;
  ColPartition* previous_neighbor = NULL;
  while ((neighbor = vsearch.NextVerticalSearch(false)) != NULL) {
    int table_top = table_box.top();
    TBOX box = neighbor->bounding_box();
    // Do not continue if the next box is way above
    // TODO(faisal): make the threshold some factor of line spacing
    if (box.bottom() - table_top > kMaxColumnHeaderDistance)
      break;
    // Unconditionally include partitions of type TABLE or LINE
    // TODO(faisal): add some reasonable conditions here
    if (neighbor->type() == PT_TABLE || neighbor->IsLineType()) {
      table_box.set_top(box.top());
      previous_neighbor = NULL;
      continue;
    }
    // If there are two text partitions, one above the other, without a table
    // cell on their left or right side, consider them a barrier and quit
    if (previous_neighbor == NULL) {
      previous_neighbor = neighbor;
    } else {
      TBOX previous_box = previous_neighbor->bounding_box();
      if (!box.major_y_overlap(previous_box))
        break;
    }
  }
}

// Remove false alarms consiting of a single column based on their
// projection on the x-axis. Projection of a real table on the x-axis
// should have at least one zero-valley larger than the global median
// x-height of the page.
void ColumnFinder::DeleteSingleColumnTables() {
  int page_width = tright().x() - bleft().x();
  ASSERT_HOST(page_width > 0);
  // create an integer array to hold projection on x-axis
  int* table_xprojection = new int[page_width];
  // Iterate through all tables in the table grid
  GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT>
      table_search(&table_grid_);
  table_search.StartFullSearch();
  ColSegment* table;
  while ((table = table_search.NextFullSearch()) != NULL) {
    TBOX table_box = table->bounding_box();
    // reset the projection array
    for (int i = 0; i < page_width; i++) {
      table_xprojection[i] = 0;
    }
    // Start a rect search on table_box
    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
        rectsearch(&clean_part_grid_);
    rectsearch.StartRectSearch(table_box);
    ColPartition* part;
    while ((part = rectsearch.NextRectSearch()) != NULL) {
      if (!rectsearch.ReturnedSeedElement())
        continue;  // Consider each partition only once
      if (!part->IsTextType())
        continue;  // Do not consider non-text partitions
      TBOX part_box = part->bounding_box();
      // Do not consider partitions partially covered by the table
      if (part_box.overlap_fraction(table_box) < kMinOverlapWithTable)
        continue;
      BLOBNBOX_CLIST* part_boxes = part->boxes();
      BLOBNBOX_C_IT pit(part_boxes);
      for (pit.mark_cycle_pt(); !pit.cycled_list(); pit.forward()) {
        BLOBNBOX *pblob = pit.data();
        // ignore blob height for the purpose of projection since we
        // are only interested in finding valleys
        int xstart = pblob->bounding_box().left();
        int xend = pblob->bounding_box().right();
        for (int i = xstart; i < xend; i++)
          table_xprojection[i - bleft().x()]++;
      }
    }
    // Find largest valley between two reasonable peaks in the table
    if (!GapInXProjection(table_xprojection, page_width)) {
      table_search.RemoveBBox();
      delete table;
    }
  }
  delete[] table_xprojection;
}

// Return true if at least one gap larger than the global x-height
// exists in the horizontal projection
bool ColumnFinder::GapInXProjection(int* xprojection, int length) {
  // Find peak value of the histogram
  int peak_value = 0;
  for (int i = 0; i < length; i++) {
    if (xprojection[i] > peak_value) {
      peak_value = xprojection[i];
    }
  }
  // Peak value represents the maximum number of horizontally
  // overlapping colpartitions, so this can be considered as the
  // number of rows in the table
  if (peak_value < kMinRowsInTable)
    return false;
  double projection_threshold = kProjectionThreshold * peak_value;
  // Threshold the histogram
  for (int i = 0; i < length; i++) {
    xprojection[i] = (xprojection[i] > projection_threshold) ? 1 : 0;
  }
  // Find the largest run of zeros between two ones
  int largest_gap = 0;
  int run_start = -1;
  for (int i = 1; i < length; i++) {
    // detect start of a run of zeros
    if (xprojection[i - 1] && !xprojection[i]) {
      run_start = i;
    }
    // detect end of a run of zeros and update the value of largest gap
    if (run_start != -1 && !xprojection[i - 1] && xprojection[i]) {
      int gap = i - run_start;
      if (gap > largest_gap)
        largest_gap = gap;
      run_start = -1;
    }
  }
  return (largest_gap > global_median_xheight_);
}

// Displays the column segments in some window.
void ColumnFinder::DisplayColSegments(ColSegment_LIST *segments,
                                      ScrollView* win,
                                      ScrollView::Color color) {
#ifndef GRAPHICS_DISABLED
  win->Pen(color);
  win->Brush(ScrollView::NONE);
  ColSegment_IT it(segments);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColSegment *col = it.data();
    TBOX box = col->bounding_box();
    int left_x = box.left();
    int right_x = box.right();
    int top_y = box.top();
    int bottom_y = box.bottom();
    win->Rectangle(left_x, bottom_y, right_x, top_y);
  }
  win->Update();
#endif
}

// Displays the colpartitions using a new coloring on an existing window.
// Note: This method is only for debug purpose during development and
// would not be part of checked in code
void ColumnFinder::DisplayColPartitions(ScrollView* win,
                                        ScrollView::Color default_color) {
#ifndef GRAPHICS_DISABLED
  // Iterate the ColPartitions in the grid.
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&clean_part_grid_);
  gsearch.StartFullSearch();
  ColPartition* part;
  win->Brush(ScrollView::NONE);
  ScrollView::Color color;
  while ((part = gsearch.NextFullSearch()) != NULL) {
    color = default_color;
    TBOX box = part->bounding_box();
//     ColPartition* upper_part = part->nearest_neighbor_above();
//     ColPartition* lower_part = part->nearest_neighbor_below();
//     if (!upper_part && !lower_part)
//       color = ScrollView::ORANGE;
//     else if (upper_part && !lower_part)
//       color = ScrollView::CYAN;
//     else if (!upper_part && lower_part)
//       color = ScrollView::MAGENTA;
    if (part->type() == PT_TABLE)
      color = ScrollView::YELLOW;

    int left_x = box.left();
    int right_x = box.right();
    int top_y = box.top();
    int bottom_y = box.bottom();
    win->Pen(color);
    win->Rectangle(left_x, bottom_y, right_x, top_y);
  }
  win->Update();
#endif
}

// Write debug image and text file.
// Note: This method is only for debug purpose during development and
// would not be part of checked in code
void ColumnFinder::WriteToPix() {
#ifdef HAVE_LIBLEPT
  // Input file must be named test1.tif
  PIX* pix = pixRead("test1.tif");
  if (!pix) {
    tprintf("Input file test1.tif not found.\n");
    return;
  }
  int img_height = pixGetHeight(pix);
  int img_width = pixGetWidth(pix);
  // Maximum number of text or table partitions
  int num_boxes = 10;
  BOXA* text_box_array = boxaCreate(num_boxes);
  BOXA* table_box_array = boxaCreate(num_boxes);
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&clean_part_grid_);
  gsearch.StartFullSearch();
  ColPartition* part;
  // load colpartitions into text_box_array and table_box_array
  while ((part = gsearch.NextFullSearch()) != NULL) {
    TBOX box = part->bounding_box();
    box.rotate_large(reskew_);
    BOX* lept_box = boxCreate(box.left(), img_height - box.top(),
                              box.right() - box.left(),
                              box.top() - box.bottom());
    if (part->type() == PT_TABLE)
      boxaAddBox(table_box_array, lept_box, L_INSERT);
    else
      boxaAddBox(text_box_array, lept_box, L_INSERT);
  }
  // draw colpartitions on the output image
  PIX* out = pixDrawBoxa(pix, text_box_array, 3, 0xff000000);
  out = pixDrawBoxa(out, table_box_array, 3, 0x0000ff00);

  BOXA* table_array = boxaCreate(num_boxes);
  // text file containing detected table bounding boxes
  FILE* fptr = fopen("tess-table.txt", "w");
  GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT>
      table_search(&table_grid_);
  table_search.StartFullSearch();
  ColSegment* table;
  // load table boxes to table_array and write them to text file as well
  while ((table = table_search.NextFullSearch()) != NULL) {
    TBOX box = table->bounding_box();
    box.rotate_large(reskew_);
    // Since deskewing introduces negative coordinates, reskewing
    // might not completely recover from that since both steps enlarge
    // the actual box. Hence a box that undergoes deskewing/reskewing
    // may go out of image boundaries. Crop a table box if needed to
    // contain it inside the image dimensions.
    box = box.intersection(TBOX(0, 0, img_width - 1, img_height - 1));
    BOX* lept_box = boxCreate(box.left(), img_height - box.top(),
                              box.right() - box.left(),
                              box.top() - box.bottom());
    boxaAddBox(table_array, lept_box, L_INSERT);
    fprintf(fptr, "%d %d %d %d TABLE\n", box.left(),
            img_height - box.top(), box.right(), img_height - box.bottom());
  }
  fclose(fptr);
  // paint table boxes on the debug image
  out = pixDrawBoxa(out, table_array, 5, 0x7fff0000);

  pixWrite("out.png", out, IFF_PNG);
  // memory cleanup
  boxaDestroy(&text_box_array);
  boxaDestroy(&table_box_array);
  boxaDestroy(&table_array);
  pixDestroy(&pix);
  pixDestroy(&out);
#endif
}

// Merge all colpartitions in table regions to make them a single
// colpartition and revert types of isolated table cells not
// assigned to any table to their original types.
void ColumnFinder::MakeTableBlocks() {
  // Since we have table blocks already, remove table tags from all
  // colpartitions
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&part_grid_);
  gsearch.StartFullSearch();
  ColPartition* part;
  while ((part = gsearch.NextFullSearch()) != NULL) {
    if (part->type() == PT_TABLE) {
      part->clear_table_type();
    }
  }
  // Now make a single colpartition out of each table block and remove
  // all colpartitions contained within a table
  GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT>
      table_search(&table_grid_);
  table_search.StartFullSearch();
  ColSegment* table;
  while ((table = table_search.NextFullSearch()) != NULL) {
    TBOX table_box = table->bounding_box();
    // Start a rect search on table_box
    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
        rectsearch(&part_grid_);
    rectsearch.StartRectSearch(table_box);
    ColPartition* part;
    ColPartition* table_partition = NULL;
    while ((part = rectsearch.NextRectSearch()) != NULL) {
     // Do not consider image partitions
      if (!part->IsTextType())
        continue;
      TBOX part_box = part->bounding_box();
      // Include partition in the table if more than half of it
      // is covered by the table
      if (part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
        rectsearch.RemoveBBox();
        if (table_partition) {
          table_partition->Absorb(part, WidthCB());
        } else {
          table_partition = part;
        }
      }
    }
    // Insert table colpartition back to part_grid_
    if (table_partition) {
      table_partition->SetPartitionType(best_columns_[table_search.GridY()]);
      table_partition->set_table_type();
      part_grid_.InsertBBox(true, true, table_partition);
    }
  }
}

// Provides a color for BBGrid to draw the rectangle.
ScrollView::Color  ColSegment::BoxColor() const {
  const ScrollView::Color kBoxColors[PT_COUNT] = {
    ScrollView::YELLOW,
    ScrollView::BLUE,
    ScrollView::YELLOW,
    ScrollView::MAGENTA,
  };
  return kBoxColors[type_];
}

// Insert a box into this column segment
void ColSegment::InsertBox(const TBOX& other) {
  bounding_box_ = bounding_box_.bounding_union(other);
}

// Set column segment type based on the ratio of text and table partitions
// in it.
void ColSegment::set_type() {
  if (num_table_cells_ > kTableColumnThreshold * num_text_cells_)
    type_ = COL_TABLE;
  else if (num_text_cells_ > num_table_cells_)
    type_ = COL_TEXT;
  else
    type_ = COL_MIXED;
}
/////////////////////////////////////////////////////////////////tablefind////////////////////////////////////////

/////////////////////////////////////////////////////////////////strokewidth///////////////////////////////////
/** Allowed proportional change in stroke width to be the same font. */
const double kStrokeWidthFractionTolerance = 0.125;
/**
 * Allowed constant change in stroke width to be the same font.
 * Really 1.5 pixels.
 */
const double kStrokeWidthTolerance = 1.5;
/** Maximum height in inches of the largest possible text. */
const double kMaxTextSize = 2.0;

StrokeWidth::StrokeWidth(int gridsize,
                         const ICOORD& bleft, const ICOORD& tright)
  : BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT>(gridsize, bleft, tright) {
}

StrokeWidth::~StrokeWidth() {
}

/** Puts the block blobs (normal and large) into the grid. */
void StrokeWidth::InsertBlobs(TO_BLOCK* block, TabFind* line_grid) {
  // Insert the blobs into this grid using the separator lines in line_grid.
  line_grid->InsertBlobList(true, false, false, &block->blobs, false, this);
  line_grid->InsertBlobList(true, false, true, &block->large_blobs,
                            false, this);
}

/**
 * Moves the large blobs that have good stroke-width neighbours to the normal
 * blobs list.
 */
void StrokeWidth::MoveGoodLargeBlobs(int resolution, TO_BLOCK* block) {
  BLOBNBOX_IT large_it = &block->large_blobs;
  BLOBNBOX_IT blob_it = &block->blobs;
  int max_height = static_cast<int>(resolution * kMaxTextSize);
  int b_count = 0;
  for (large_it.mark_cycle_pt(); !large_it.cycled_list(); large_it.forward()) {
    BLOBNBOX* large_blob = large_it.data();
    if (large_blob->bounding_box().height() <= max_height &&
        GoodTextBlob(large_blob)) {
      blob_it.add_to_end(large_it.extract());
      ++b_count;
    }
  }
  if (textord_debug_tabfind) {
    tprintf("Moved %d large blobs to normal list\n",
            b_count);
  }
}

/** Displays the blobs green or red according to whether they are good or not. */
ScrollView* StrokeWidth::DisplayGoodBlobs(const char* window_name,
                                          ScrollView* window) {
#ifndef GRAPHICS_DISABLED
  if (window == NULL)
    window = MakeWindow(0, 0, window_name);
  // For every blob in the grid, display it.
  window->Brush(ScrollView::NONE);

  // For every bbox in the grid, display it.
  GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> gsearch(this);
  gsearch.StartFullSearch();
  BLOBNBOX* bbox;
  while ((bbox = gsearch.NextFullSearch()) != NULL) {
    TBOX box = bbox->bounding_box();
    int left_x = box.left();
    int right_x = box.right();
    int top_y = box.top();
    int bottom_y = box.bottom();
    if (textord_debug_printable || GoodTextBlob(bbox))
      window->Pen(ScrollView::GREEN);
    else
      window->Pen(ScrollView::RED);
    window->Rectangle(left_x, bottom_y, right_x, top_y);
  }
  window->Update();
#endif
  return window;
}

/** Handles a click event in a display window. */
void StrokeWidth::HandleClick(int x, int y) {
  BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT>::HandleClick(x, y);
  // Run a radial search for blobs that overlap.
  GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> radsearch(this);
  radsearch.StartRadSearch(x, y, 1);
  BLOBNBOX* neighbour;
  FCOORD click(x, y);
  while ((neighbour = radsearch.NextRadSearch()) != NULL) {
    TBOX nbox = neighbour->bounding_box();
    if (nbox.contains(click) && neighbour->cblob() != NULL) {
      SetBlobStrokeWidth(true, neighbour);
      tprintf("Box (%d,%d)->(%d,%d): h-width=%.1f, v-width=%.1f p-width=%1.f\n",
              nbox.left(), nbox.bottom(), nbox.right(), nbox.top(),
              neighbour->horz_stroke_width(), neighbour->vert_stroke_width(),
              2.0 * neighbour->cblob()->area()/neighbour->cblob()->perimeter());
    }
  }
}

/**
 * Returns true if there is at least one side neighbour that has a similar
 * stroke width and is not on the other side of a rule line.
 */
bool StrokeWidth::GoodTextBlob(BLOBNBOX* blob) {
  double h_width = blob->horz_stroke_width();
  double v_width = blob->vert_stroke_width();
  // The perimeter-based width is used as a backup in case there is
  // no information in the blob.
  double p_width = 2.0f * blob->cblob()->area();
  p_width /= blob->cblob()->perimeter();
  double h_tolerance = h_width * kStrokeWidthFractionTolerance
                     + kStrokeWidthTolerance;
  double v_tolerance = v_width * kStrokeWidthFractionTolerance
                     + kStrokeWidthTolerance;
  double p_tolerance = p_width * kStrokeWidthFractionTolerance
                     + kStrokeWidthTolerance;

  // Run a radial search for neighbours that overlap.
  TBOX box = blob->bounding_box();
  int radius = box.height() / gridsize_ + 2;
  GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> radsearch(this);
  radsearch.StartRadSearch((box.left() + box.right()) / 2, box.bottom(),
                           radius);
  int top = box.top();
  int bottom = box.bottom();
  int min_overlap = (top - bottom) / 2;
  BLOBNBOX* neighbour;
  while ((neighbour = radsearch.NextRadSearch()) != NULL) {
    TBOX nbox = neighbour->bounding_box();
    if (neighbour == blob) {
      continue;
    }
    // In finding a suitable neighbour, do not cross rule lines.
    if (nbox.right() > blob->right_rule() || nbox.left() < blob->left_rule()) {
      continue;  // Can't use it.
    }
    int overlap = MIN(nbox.top(), top) - MAX(nbox.bottom(), bottom);
    if (overlap >= min_overlap &&
        !TabFind::DifferentSizes(box.height(), nbox.height())) {
      double n_h_width = neighbour->horz_stroke_width();
      double n_v_width = neighbour->vert_stroke_width();
      double n_p_width = 2.0f * neighbour->cblob()->area();
      n_p_width /= neighbour->cblob()->perimeter();
      bool h_zero = h_width == 0.0f || n_h_width == 0.0f;
      bool v_zero = v_width == 0.0f || n_v_width == 0.0f;
      bool h_ok = !h_zero && NearlyEqual(h_width, n_h_width, h_tolerance);
      bool v_ok = !v_zero && NearlyEqual(v_width, n_v_width, v_tolerance);
      bool p_ok = h_zero && v_zero &&
                  NearlyEqual(p_width, n_p_width, p_tolerance);
      // For a match, at least one of the horizontal and vertical widths
      // must match, and the other one must either match or be zero.
      // Only if both are zero will we look at the perimeter metric.
      if (p_ok || ((v_ok || h_ok) && (h_ok || h_zero) && (v_ok || v_zero))) {
        return true;
      }
    }
  }
  return false;
}
/////////////////////////////////////////////////////////////////strokewidth///////////////////////////////////

/////////////////////////////////////////////////////////////////colfind////////////////////////////////////////
// Minimum width to be considered when making columns.
//const int kMinColumnWidth = 100;
// When assigning columns, the max number of misfits that can be ignored.
const int kMaxIncompatibleColumnCount = 2;
// Max vertical distance of neighbouring ColPartition for it to be a partner.
const double kMaxPartitionSpacing = 1.75;
// Min fraction of ColPartition height to be overlapping for margin purposes.
const double kMarginOverlapFraction = 0.25;
// Max fraction of mean_column_gap_ for the gap between two partitions within a
// column to allow them to merge.
const double kHorizontalGapMergeFraction = 0.5;
// Min fraction of grid size to not be considered likely noise.
const double kMinNonNoiseFraction = 0.5;
// Search radius to use for finding large neighbours of smaller blobs.
const int kSmallBlobSearchRadius = 2;

BOOL_VAR(textord_tabfind_show_strokewidths, false, "Show stroke widths");
BOOL_VAR(textord_tabfind_show_initial_partitions,
         false, "Show partition bounds");
INT_VAR(textord_tabfind_show_partitions, 0,
        "Show partition bounds, waiting if >1");
BOOL_VAR(textord_tabfind_show_columns, false, "Show column bounds");
BOOL_VAR(textord_tabfind_show_blocks, false, "Show final block bounds");

ScrollView* ColumnFinder::blocks_win_ = NULL;

// Gridsize is an estimate of the text size in the image. A suitable value
// is in TO_BLOCK::line_size after find_components has been used to make
// the blobs.
// bleft and tright are the bounds of the image (or rectangle) being processed.
// vlines is a (possibly empty) list of TabVector and vertical_x and y are
// the sum logical vertical vector produced by LineFinder::FindVerticalLines.
ColumnFinder::ColumnFinder(int gridsize,
                           const ICOORD& bleft, const ICOORD& tright,
                           TabVector_LIST* vlines, TabVector_LIST* hlines,
                           int vertical_x, int vertical_y)
  : TabFind(gridsize, bleft, tright, vlines, vertical_x, vertical_y),
    mean_column_gap_(tright.x() - bleft.x()),
    global_median_xheight_(0), global_median_ledding_(0),
    reskew_(1.0f, 0.0f), rerotate_(1.0f, 0.0f),
    best_columns_(NULL) {
  TabVector_IT h_it(&horizontal_lines_);
  h_it.add_list_after(hlines);
}

// Templated helper function used to create destructor callbacks for the
// BBGrid::ClearGridData() method.
template <typename T> void DeleteObject(T *object) {
  delete object;
}

ColumnFinder::~ColumnFinder() {
  column_sets_.delete_data_pointers();
  if (best_columns_ != NULL) {
    delete [] best_columns_;
  }
  // ColPartitions and ColSegments created by this class for storage in grids
  // need to be deleted explicitly.
  clean_part_grid_.ClearGridData(&DeleteObject<ColPartition>);
  col_seg_grid_.ClearGridData(&DeleteObject<ColSegment>);

  // The ColPartitions are destroyed automatically, but any boxes in
  // the noise_parts_ list are owned and need to be deleted explicitly.
  ColPartition_IT part_it(&noise_parts_);
  for (part_it.mark_cycle_pt(); !part_it.cycled_list(); part_it.forward()) {
    ColPartition* part = part_it.data();
    part->DeleteBoxes();
  }
  // Likewise any boxes in the good_parts_ list need to be deleted.
  // These are just the image parts. Text parts have already given their
  // boxes on to the TO_BLOCK, and have empty lists.
  part_it.set_to_list(&good_parts_);
  for (part_it.mark_cycle_pt(); !part_it.cycled_list(); part_it.forward()) {
    ColPartition* part = part_it.data();
    part->DeleteBoxes();
  }
  // Also, any blobs on the image_bblobs_ list need to have their cblobs
  // deleted. This only happens if there has been an early return from
  // FindColumns, as in a normal return, the blobs go into the grid and
  // end up in noise_parts_, good_parts_ or the output blocks.
  BLOBNBOX_IT bb_it(&image_bblobs_);
  for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
    BLOBNBOX* bblob = bb_it.data();
    delete bblob->cblob();
  }
}

// Finds the text and image blocks, returning them in the blocks and to_blocks
// lists. (Each TO_BLOCK points to the basic BLOCK and adds more information.)
// If boxa and pixa are not NULL, they are assumed to be the output of
// ImageFinder::FindImages, and are used to generate image blocks.
// The input boxa and pixa are destroyed.
// Imageheight and resolution should be the pixel height and resolution in
// pixels per inch of the original image.
// The input block is the result of a call to find_components, and contains
// the blobs found in the image. These blobs will be removed and placed
// in the output blocks, while unused ones will be deleted.
// If single_column is true, the input is treated as single column, but
// it is still divided into blocks of equal line spacing/text size.
// Returns -1 if the user requested retry with more debug info.
int ColumnFinder::FindBlocks(int imageheight, int resolution,
                             bool single_column, TO_BLOCK* block,
                             Boxa* boxa, Pixa* pixa,
                             BLOCK_LIST* blocks, TO_BLOCK_LIST* to_blocks)
{
    Q_UNUSED(imageheight);
    Q_UNUSED(boxa);
    Q_UNUSED(pixa);
#ifdef HAVE_LIBLEPT
  if (boxa != NULL) {
    // Convert the boxa/pixa to fake blobs aligned on the grid.
    ExtractImageBlobs(imageheight, boxa, pixa);
    boxaDestroy(&boxa);
    pixaDestroy(&pixa);
  }
#endif
  // Decide which large blobs should be included in the grid as potential
  // characters.
  // A subsidiary grid used to decide which large blobs to use.
  StrokeWidth* stroke_width = new StrokeWidth(gridsize(), bleft(), tright());
  stroke_width->InsertBlobs(block, this);
  if (textord_tabfind_show_strokewidths) {
    stroke_width->DisplayGoodBlobs("GoodStrokewidths", NULL);
  }
  stroke_width->MoveGoodLargeBlobs(resolution, block);
  delete stroke_width;

  if (single_column) {
    // No tab stops needed. Just the grid that FindTabVectors makes.
    DontFindTabVectors(resolution, &image_bblobs_, block, &reskew_);
  } else {
    // Find the tab stops.
    FindTabVectors(resolution, &horizontal_lines_, &image_bblobs_, block,
                   &reskew_, &rerotate_);
  }

  // Find the columns.
  if (MakeColumnPartitions() == 0)
    return 0;  // This is an empty page.
  // Make the initial column candidates from the part_sets_.
  MakeColumnCandidates(single_column);
  if (textord_debug_tabfind)
    PrintColumnCandidates("Column candidates");
  // Improve the column candidates against themselves.
  ImproveColumnCandidates(&column_sets_, &column_sets_);
  if (textord_debug_tabfind)
    PrintColumnCandidates("Improved columns");
  // Improve the column candidates using the part_sets_.
  ImproveColumnCandidates(&part_sets_, &column_sets_);
  if (textord_debug_tabfind)
    PrintColumnCandidates("Final Columns");
  // Divide the page into sections of uniform column layout.
  AssignColumns();
  if (textord_tabfind_show_columns) {
    DisplayColumnBounds(&part_sets_);
  }
  ComputeMeanColumnGap();

  // Refill the grid using rectangular spreading, and get the benefit
  // of the completed tab vectors marking the rule edges of each blob.
  Clear();
  InsertBlobList(false, false, false, &image_bblobs_, true, this);
  InsertBlobList(true, true, false, &block->blobs, true, this);

  // Insert all the remaining small and noise blobs into the grid and also
  // make an unknown partition for each. Ownership is taken by the grid.
  InsertSmallBlobsAsUnknowns(true, &block->small_blobs);
  InsertSmallBlobsAsUnknowns(true, &block->noise_blobs);

  // Ownership of the ColPartitions moves from part_sets_ to part_grid_ here,
  // and ownership of the BLOBNBOXes moves to the ColPartitions.
  // (They were previously owned by the block or the image_bblobs list,
  // but they both gave up ownership to the grid at the InsertBlobList above.)
  MovePartitionsToGrid();
  // Split and merge the partitions by looking at local neighbours.
  GridSplitPartitions();
  // Resolve unknown partitions by adding to an existing partition, fixing
  // the type, or declaring them noise.
  GridFindMargins();
  ListFindMargins(&unknown_parts_);
  GridInsertUnknowns();
  GridMergePartitions();
  // Add horizontal line separators as partitions.
  GridInsertHLinePartitions();
  // Recompute margins based on a local neighbourhood search.
  GridFindMargins();
  SetPartitionTypes();
  if (textord_tabfind_show_initial_partitions) {
    ScrollView* part_win = MakeWindow(100, 300, "InitialPartitions");
    part_grid_.DisplayBoxes(part_win);
    DisplayTabVectors(part_win);
  }

  // Copy cleaned partitions from part_grid_ to clean_part_grid_ and
  // insert dot-like noise into period_grid_
  GetCleanPartitions(block);

  // Get Table Regions
  LocateTables();

  // Build the partitions into chains that belong in the same block and
  // refine into one-to-one links, then smooth the types within each chain.
  FindPartitionPartners();
  RefinePartitionPartners();
  SmoothPartnerRuns();
  if (textord_tabfind_show_partitions) {
    ScrollView* window = MakeWindow(400, 300, "Partitions");
    if (textord_debug_images)
      window->Image(AlignedBlob::textord_debug_pix().string(),
                    image_origin().x(), image_origin().y());
    part_grid_.DisplayBoxes(window);
    if (!textord_debug_printable)
      DisplayTabVectors(window);
    if (window != NULL && textord_tabfind_show_partitions > 1) {
      delete window->AwaitEvent(SVET_DESTROY);
    }
  }
  part_grid_.AssertNoDuplicates();
  // Ownership of the ColPartitions moves from part_grid_ to good_parts_ and
  // noise_parts_ here. In text blocks, ownership of the BLOBNBOXes moves
  // from the ColPartitions to the output TO_BLOCK. In non-text, the
  // BLOBNBOXes stay with the ColPartitions and get deleted in the destructor.
  TransformToBlocks(blocks, to_blocks);
  if (textord_debug_tabfind) {
    tprintf("Found %d blocks, %d to_blocks\n",
            blocks->length(), to_blocks->length());
  }

  DisplayBlocks(blocks);
//  MoveSmallBlobs(&block->small_blobs, to_blocks);
//  MoveSmallBlobs(&block->noise_blobs, to_blocks);
//  MoveSmallBlobs(&period_blobs_, to_blocks);
  RotateAndReskewBlocks(to_blocks);
  int result = 0;
  if (blocks_win_ != NULL) {
    bool waiting = false;
    do {
      waiting = false;
      SVEvent* event = blocks_win_->AwaitEvent(SVET_ANY);
      if (event->type == SVET_INPUT && event->parameter != NULL) {
        if (*event->parameter == 'd')
          result = -1;
        else
          blocks->clear();
      } else if (event->type == SVET_DESTROY) {
        blocks_win_ = NULL;
      } else {
        waiting = true;
      }
      delete event;
    } while (waiting);
  }
  return result;
}

//////////////// PRIVATE CODE /////////////////////////

// Displays the blob and block bounding boxes in a window called Blocks.
void ColumnFinder::DisplayBlocks(BLOCK_LIST* blocks) {
#ifndef GRAPHICS_DISABLED
  if (textord_tabfind_show_blocks) {
    if (blocks_win_ == NULL)
      blocks_win_ = MakeWindow(700, 300, "Blocks");
    else
      blocks_win_->Clear();
    if (textord_debug_images)
      blocks_win_->Image(AlignedBlob::textord_debug_pix().string(),
                         image_origin().x(), image_origin().y());
    else
      DisplayBoxes(blocks_win_);
    BLOCK_IT block_it(blocks);
    int serial = 1;
    for (block_it.mark_cycle_pt(); !block_it.cycled_list();
         block_it.forward()) {
      BLOCK* block = block_it.data();
      block->plot(blocks_win_, serial++,
                  textord_debug_printable ? ScrollView::BLUE
                                          : ScrollView::GREEN);
    }
    blocks_win_->Update();
  }
#endif
}

// Displays the column edges at each grid y coordinate defined by
// best_columns_.
void ColumnFinder::DisplayColumnBounds(PartSetVector* sets)
{
    Q_UNUSED(sets);
#ifndef GRAPHICS_DISABLED
  ScrollView* col_win = MakeWindow(50, 300, "Columns");
  if (textord_debug_images)
    col_win->Image(AlignedBlob::textord_debug_pix().string(),
                   image_origin().x(), image_origin().y());
  else
    DisplayBoxes(col_win);
  col_win->Pen(textord_debug_printable ? ScrollView::BLUE : ScrollView::GREEN);
  for (int i = 0; i < gridheight_; ++i) {
    ColPartitionSet* columns = best_columns_[i];
    if (columns != NULL)
      columns->DisplayColumnEdges(i * gridsize_, (i + 1) * gridsize_, col_win);
  }
#endif
}

// Converts the arrays of Box/Pix to a list of C_OUTLINE, and then to blobs.
// The output is a list of C_BLOBs for the images, but the C_OUTLINEs
// contain no data.
void ColumnFinder::ExtractImageBlobs(int image_height, Boxa* boxa, Pixa* pixa)
{
    Q_UNUSED(image_height);
    Q_UNUSED(boxa);
    Q_UNUSED(pixa);
#ifdef HAVE_LIBLEPT
  BLOBNBOX_IT bb_it(&image_bblobs_);
  // Iterate the connected components in the image regions mask.
  int nboxes = boxaGetCount(boxa);
  for (int i = 0; i < nboxes; ++i) {
    l_int32 x, y, width, height;
    boxaGetBoxGeometry(boxa, i, &x, &y, &width, &height);
    Pix* pix = pixaGetPix(pixa, i, L_CLONE);
    // Special case set in FindImages:
    // The image is a rectangle if its width doesn't match the box width.
    bool rectangle = width != pixGetWidth(pix);
    // For each grid cell in the pix, find the bounding box of the black
    // pixels within the cell.
    int grid_xmin, grid_ymin, grid_xmax, grid_ymax;
    GridCoords(x, image_height - (y + height), &grid_xmin, &grid_ymin);
    GridCoords(x + width - 1, image_height - 1 - y, &grid_xmax, &grid_ymax);
    for (int grid_y = grid_ymin; grid_y <= grid_ymax; ++grid_y) {
      for (int grid_x = grid_xmin; grid_x <= grid_xmax; ++grid_x) {
        // Compute bounds of grid cell in sub-image.
        int x_start = grid_x * gridsize_ + bleft_.x() - x;
        int y_end = image_height - (grid_y * gridsize_ + bleft_.y()) - y;
        int x_end = x_start + gridsize_;
        int y_start = y_end - gridsize_;
        ImageFinder::BoundsWithinRect(pix, &x_start, &y_start, &x_end, &y_end);
        // If the box is not degenerate, make a blob.
        if (x_end > x_start && y_end > y_start) {
          C_OUTLINE_LIST outlines;
          C_OUTLINE_IT ol_it = &outlines;
          // Make a C_OUTLINE from the bounds. This is a bit of a hack,
          // as there is no outline, just a bounding box, but with some very
          // small changes to coutln.cpp, it works nicely.
          ICOORD top_left(x_start + x, image_height - (y_start + y));
          ICOORD bot_right(x_end + x, image_height - (y_end + y));
          CRACKEDGE startpt;
          startpt.pos = top_left;
          C_OUTLINE* outline = new C_OUTLINE(&startpt, top_left, bot_right, 0);
          ol_it.add_after_then_move(outline);
          C_BLOB* blob = new C_BLOB(&outlines);
          // Although a BLOBNBOX doesn't normally think it owns the blob,
          // these will all end up in a ColPartition, which deletes the
          // C_BLOBs of all its BLOBNBOXes in its destructor to match the
          // fact that the rest get moved to a block later.
          BLOBNBOX* bblob = new BLOBNBOX(blob);
          bblob->set_region_type(rectangle ? BRT_RECTIMAGE : BRT_POLYIMAGE);
          bb_it.add_after_then_move(bblob);
        }
      }
    }
    pixDestroy(&pix);
  }
#endif  // HAVE_LIBLEPT
}

////// Functions involved in making the initial ColPartitions. /////

// Creates the initial ColPartitions, and puts them in a ColPartitionSet
// for each grid y coordinate, storing the ColPartitionSets in part_sets_.
// After creating the ColPartitonSets, attempts to merge them where they
// overlap and unique the BLOBNBOXes within.
// The return value is the number of ColPartitionSets made.
int ColumnFinder::MakeColumnPartitions() {
  part_sets_.reserve(gridheight_);
  for (int grid_y = 0; grid_y < gridheight_; ++grid_y) {
    ColPartitionSet* line_set = PartitionsAtGridY(grid_y);
    part_sets_.push_back(line_set);
  }
  // Now merge neighbouring partitions that overlap significantly.
  int part_set_count = 0;
  for (int i = 0; i < gridheight_; ++i) {
    ColPartitionSet* line_set = part_sets_.get(i);
    if (line_set == NULL)
      continue;
    bool merged_any = false;
    for (int j = i + 1; j < gridheight_; ++j) {
      ColPartitionSet* line_set2 = part_sets_.get(j);
      if (line_set2 == NULL)
        continue;
      if (line_set->MergeOverlaps(line_set2, WidthCB())) {
        merged_any = true;
        if (line_set2->Empty()) {
          delete line_set2;
          part_sets_.set(NULL, j);
        }
        if (line_set->Empty()) {
          delete line_set;
          part_sets_.set(NULL, i);
          merged_any = false;
          break;
        }
      } else {
        break;
      }
    }
    if (merged_any)
      --i;  // Try this one again.
    else
      ++part_set_count;
  }
  return part_set_count;
}

// Partition the BLOBNBOXES horizontally at the given grid y, creating a
// ColPartitionSet which is returned. NULL is returned if there are no
// BLOBNBOXES at the given grid y.
ColPartitionSet* ColumnFinder::PartitionsAtGridY(int grid_y) {
  ColPartition_LIST partitions;
  ColPartition_IT part_it(&partitions);
  // Setup a search of all the grid cells at the given y.
  GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> rectsearch(this);
  int y = grid_y * gridsize_ + bleft_.y();
  ICOORD botleft(bleft_.x(), y);
  ICOORD topright(tright_.x(), y + gridsize_ - 1);
  TBOX line_box(botleft, topright);
  rectsearch.StartRectSearch(line_box);
  BLOBNBOX* bbox = rectsearch.NextRectSearch();
  // Each iteration round this while loop finds a set of boxes between
  // tabvectors (or a change of aligned_text type) and places them in
  // a ColPartition.
  int page_edge = line_box.right() + kColumnWidthFactor;
  int prev_margin = line_box.left() - kColumnWidthFactor;
  // Runs of unknown blobs (not certainly text or image) go in a special
  // unk_part, following the same rules as known blobs, but need a
  // separate set of variables to hold the margin/edge information.
  ColPartition_IT unk_part_it(&unknown_parts_);
  ColPartition* unk_partition = NULL;
  TabVector* unk_right_line = NULL;
  int unk_right_margin = page_edge;
  int unk_prev_margin = prev_margin;
  bool unk_edge_is_left = false;
  while (bbox != NULL) {
    TBOX box = bbox->bounding_box();
    if (WithinTestRegion(2, box.left(), box.bottom()))
      tprintf("Starting partition on grid y=%d with box (%d,%d)->(%d,%d)\n",
              grid_y, box.left(), box.bottom(), box.right(), box.top());
    if (box.left() < prev_margin + 1 && textord_debug_bugs) {
      tprintf("Starting box too far left at %d vs %d:",
              box.left(), prev_margin + 1);
      part_it.data()->Print();
    }
    int right_margin = page_edge;
    BlobRegionType start_type = bbox->region_type();
    if (start_type == BRT_NOISE) {
      // Ignore blobs that have been overruled by image blobs.
      // TODO(rays) Possible place to fix inverse text.
      bbox = rectsearch.NextRectSearch();
      continue;
    }
    if (start_type == BRT_UNKNOWN) {
      // Keep unknown blobs in a special partition.
      ProcessUnknownBlob(page_edge, bbox, &unk_partition, &unk_part_it,
                         &unk_right_line, &unk_right_margin,
                         &unk_prev_margin, &unk_edge_is_left);
      bbox = rectsearch.NextRectSearch();
      continue;
    }
    if (unk_partition != NULL)
      unk_prev_margin = CompletePartition(false, page_edge,
                                          unk_right_line, &unk_right_margin,
                                          &unk_partition, &unk_part_it);
    TabVector* right_line = NULL;
    bool edge_is_left = false;
    ColPartition* partition = StartPartition(start_type, prev_margin + 1, bbox,
                                             &right_line, &right_margin,
                                             &edge_is_left);
    // Search for the right edge of this partition.
    while ((bbox = rectsearch.NextRectSearch()) != NULL) {
      TBOX box = bbox->bounding_box();
      int left = box.left();
      int right = box.right();
      int edge = edge_is_left ? left : right;
      BlobRegionType next_type = bbox->region_type();
      if (next_type == BRT_NOISE)
        continue;
      if (next_type == BRT_UNKNOWN) {
        // Keep unknown blobs in a special partition.
        ProcessUnknownBlob(page_edge, bbox, &unk_partition, &unk_part_it,
                           &unk_right_line, &unk_right_margin,
                           &unk_prev_margin, &unk_edge_is_left);
        continue;  // Deal with them later.
      }
      if (unk_partition != NULL)
        unk_prev_margin = CompletePartition(false, page_edge,
                                            unk_right_line, &unk_right_margin,
                                            &unk_partition, &unk_part_it);
      if (ColPartition::TypesMatch(next_type, start_type) &&
          edge < right_margin) {
        // Still within the region and it is still the same type.
        partition->AddBox(bbox);
      } else {
        // This is the first blob in the next set. It gives us the absolute
        // max right coord of the block. (The right margin.)
        right_margin = left - 1;
        if (WithinTestRegion(2, box.left(), box.bottom()))
          tprintf("Box (%d,%d)->(%d,%d) ended partition at %d\n",
                  box.left(), box.bottom(), box.right(), box.top(),
                  right_margin);
        break;
      }
    }
    prev_margin = CompletePartition(bbox == NULL, page_edge,
                                    right_line, &right_margin,
                                    &partition, &part_it);
  }
  if (unk_partition != NULL)
    CompletePartition(true, page_edge, unk_right_line, &unk_right_margin,
                      &unk_partition, &unk_part_it);
  return partitions.empty() ? NULL : new ColPartitionSet(&partitions);
}

// Insert the blobs in the given list into the main grid and for
// each one also make it a separate unknown partition.
// If filter is true, use only the blobs that are above a threshold in
// size or a non-isolated.
void ColumnFinder::InsertSmallBlobsAsUnknowns(bool filter,
                                              BLOBNBOX_LIST* blobs) {
  double noise_blob_size = gridsize() * kMinNonNoiseFraction;
  ColPartition_IT unk_part_it(&unknown_parts_);
  BLOBNBOX_IT blob_it(blobs);
  for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
    BLOBNBOX* blob = blob_it.data();
    TBOX box = blob->bounding_box();
    bool good_blob = !filter ||
                     box.width() > noise_blob_size ||
                     box.height() > noise_blob_size;
    if (!good_blob) {
      // Search the vicinity for a bigger blob.
      GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> radsearch(this);
      radsearch.StartRadSearch((box.left() + box.right()) / 2,
                               (box.bottom() + box.top()) / 2,
                               kSmallBlobSearchRadius);
      BLOBNBOX* neighbour;
      while ((neighbour = radsearch.NextRadSearch()) != NULL) {
        TBOX nbox = neighbour->bounding_box();
        // Neighbours must be bigger than the noise size limit to prevent
        // the seed effect of starting with one noise object near a real
        // object, and it then allowing all its neighbours to be accepted.
        if (nbox.height() > noise_blob_size || nbox.width() > noise_blob_size)
          break;
      }
      if (neighbour != NULL)
        good_blob = true;
    }
    if (good_blob) {
      blob_it.extract();
      blob->set_noise_flag(true);
      InsertBlob(true, true, false, blob, this);
      if (WithinTestRegion(2, box.left(), box.bottom()))
        tprintf("Starting small partition with box (%d,%d)->(%d,%d)\n",
                box.left(), box.bottom(), box.right(), box.top());

      int unk_right_margin = tright().x();
      TabVector* unk_right_line = NULL;
      bool unk_edge_is_left = false;
      ColPartition* unk_partition = StartPartition(BRT_TEXT, bleft().x(), blob,
                                                   &unk_right_line,
                                                   &unk_right_margin,
                                                   &unk_edge_is_left);
      CompletePartition(false, tright().x(), unk_right_line,
                        &unk_right_margin, &unk_partition, &unk_part_it);
    }
  }
}

// Helper function for PartitionsAtGridY, with a long argument list.
// This bbox is of unknown type, so it is added to an unk_partition.
// If the edge is past the unk_right_margin then unk_partition has to be
// completed and a new one made. See CompletePartition and StartPartition
// for the other args.
void ColumnFinder::ProcessUnknownBlob(int page_edge,
                                      BLOBNBOX* bbox,
                                      ColPartition** unk_partition,
                                      ColPartition_IT* unk_part_it,
                                      TabVector** unk_right_line,
                                      int* unk_right_margin,
                                      int* unk_prev_margin,
                                      bool* unk_edge_is_left) {
  if (*unk_partition != NULL) {
    const TBOX& box = bbox->bounding_box();
    int edge = *unk_edge_is_left ? box.left() : box.right();
    if (edge >= *unk_right_margin)
      *unk_prev_margin = CompletePartition(false, page_edge,
                                           *unk_right_line, unk_right_margin,
                                           unk_partition, unk_part_it);
  }
  if (*unk_partition == NULL) {
    *unk_partition = StartPartition(BRT_TEXT, *unk_prev_margin + 1, bbox,
                                    unk_right_line,
                                    unk_right_margin,
                                    unk_edge_is_left);
  } else {
    (*unk_partition)->AddBox(bbox);
  }
}

// Creates and returns a new ColPartition of the given start_type
// and adds the given bbox to it.
// Also finds the left and right tabvectors that bound the textline, setting
// the members of the returned ColPartition appropriately:
// If the left tabvector is less constraining than the input left_margin
// (assumed to be the right edge of the previous partition), then the
// tabvector is ignored and the left_margin used instead.
// If the right tabvector is more constraining than the input *right_margin,
// (probably the right edge of the page), then the *right_margin is adjusted
// to use the tabvector.
// *edge_is_left is set to true if the right tabvector is good and used as the
// margin, so we can include blobs that overhang the tabvector in this
// partition.
ColPartition* ColumnFinder::StartPartition(BlobRegionType start_type,
                                           int left_margin, BLOBNBOX* bbox,
                                           TabVector** right_line,
                                           int* right_margin,
                                           bool* edge_is_left) {
  ColPartition* partition = new ColPartition(start_type, vertical_skew_);
  partition->AddBox(bbox);
  // Find the tabs that bound it.
  TBOX box = bbox->bounding_box();
  int mid_y = (box.bottom() + box.top()) / 2;
  TabVector* left_line = LeftTabForBox(box, true, false);
  // If the overlapping line is not a left tab, try for non-overlapping.
  if (left_line != NULL && !left_line->IsLeftTab())
    left_line = LeftTabForBox(box, false, false);
  if (left_line != NULL) {
    int left_x = left_line->XAtY(mid_y);
    left_x += left_line->IsLeftTab() ? -kColumnWidthFactor : 1;
    // If the left line is not a genuine left or is less constraining
    // than the previous blob, then don't store it in the partition.
    if (left_x < left_margin || !left_line->IsLeftTab())
      left_line = NULL;
    if (left_x > left_margin)
      left_margin = left_x;
    if (WithinTestRegion(2, box.left(), box.bottom()))
      tprintf("Left x =%d, left margin = %d\n",
              left_x, left_margin);
  }
  partition->set_left_margin(left_margin);
  *right_line = RightTabForBox(box, true, false);
  // If the overlapping line is not a right tab, try for non-overlapping.
  if (*right_line != NULL && !(*right_line)->IsRightTab())
    *right_line = RightTabForBox(box, false, false);
  *edge_is_left = false;
  if (*right_line != NULL) {
    int right_x = (*right_line)->XAtY(box.bottom());
    if (right_x < *right_margin) {
      *right_margin = right_x;
      if ((*right_line)->IsRightTab())
        *edge_is_left = true;
    }
    if (WithinTestRegion(3, box.left(), box.bottom()))
      tprintf("Right x =%d, right_max = %d\n",
              right_x, *right_margin);
  }
  partition->set_right_margin(*right_margin);
  partition->ComputeLimits();
  partition->SetLeftTab(left_line);
  partition->SetRightTab(*right_line);
  return partition;
}

// Completes the given partition, and adds it to the given iterator.
// The right_margin on input is the left edge of the next blob if there is
// one. The right tab vector plus a margin is used as the right margin if
// it is more constraining than the next blob, but if there are no more
// blobs, we want the right margin to make it to the page edge.
// The return value is the next left margin, being the right edge of the
// bounding box of blobs.
int ColumnFinder::CompletePartition(bool no_more_blobs,
                                    int page_edge,
                                    TabVector* right_line,
                                    int* right_margin,
                                    ColPartition** partition,
                                    ColPartition_IT* part_it) {
  ASSERT_HOST(partition !=NULL && *partition != NULL);
  // If we have a right line, it is possible that its edge is more
  // constraining than the next blob.
  if (right_line != NULL && right_line->IsRightTab()) {
    int mid_y = (*partition)->MidY();
    int right_x = right_line->XAtY(mid_y) + kColumnWidthFactor;
    if (right_x < *right_margin)
      *right_margin = right_x;
    else if (no_more_blobs)
      *right_margin = MAX(right_x, page_edge);
    else if (right_line->XAtY(mid_y) > *right_margin)
      right_line = NULL;
  } else {
    right_line = NULL;
  }
  // Now we can complete the partition and add it to the list.
  (*partition)->set_right_margin(*right_margin);
  (*partition)->ComputeLimits();
  (*partition)->SetRightTab(right_line);
  (*partition)->SetColumnGoodness(WidthCB());
  part_it->add_after_then_move(*partition);
  // Setup ready to start the next one.
  *right_margin = page_edge;
  int next_left_margin = (*partition)->bounding_box().right();
  *partition = NULL;
  return next_left_margin;
}

// Makes an ordered list of candidates to partition the width of the page
// into columns using the part_sets_.
// See AddToColumnSetsIfUnique for the ordering.
// If single_column, then it just makes a single page-wide fake column.
void ColumnFinder::MakeColumnCandidates(bool single_column) {
  if (!single_column) {
    // Try using only the good parts first.
    bool good_only = true;
    do {
      for (int i = 0; i < gridheight_; ++i) {
        ColPartitionSet* line_set = part_sets_.get(i);
        if (line_set != NULL && line_set->LegalColumnCandidate()) {
          ColPartitionSet* column_candidate = line_set->Copy(good_only);
          if (column_candidate != NULL)
            column_candidate->AddToColumnSetsIfUnique(&column_sets_, WidthCB());
        }
      }
      good_only = !good_only;
    } while (column_sets_.empty() && !good_only);
  }
  if (column_sets_.empty()) {
    // The page contains only image or is single column.
    // Make a fake page-wide column.
    ColPartition* fake_part = new ColPartition(BRT_TEXT, vertical_skew_);
    fake_part->set_left_margin(bleft_.x());
    fake_part->set_right_margin(tright_.x());
    fake_part->ComputeLimits();
    fake_part->SetColumnGoodness(WidthCB());
    ColPartitionSet* column_candidate = new ColPartitionSet(fake_part);
    column_candidate->AddToColumnSetsIfUnique(&column_sets_, WidthCB());
  }
}

// Attempt to improve the column_candidates by expanding the columns
// and adding new partitions from the partition sets in src_sets.
// Src_sets may be equal to column_candidates, in which case it will
// use them as a source to improve themselves.
void ColumnFinder::ImproveColumnCandidates(PartSetVector* src_sets,
                                           PartSetVector* column_sets) {
  PartSetVector temp_cols;
  temp_cols.move(column_sets);
  if (src_sets == column_sets)
    src_sets = &temp_cols;
  int set_size = temp_cols.size();
  // Try using only the good parts first.
  bool good_only = true;
  do {
    for (int i = 0; i < set_size; ++i) {
      ColPartitionSet* column_candidate = temp_cols.get(i);
      ASSERT_HOST(column_candidate != NULL);
      ColPartitionSet* improved = column_candidate->Copy(good_only);
      if (improved != NULL) {
        improved->ImproveColumnCandidate(WidthCB(), src_sets);
        improved->AddToColumnSetsIfUnique(column_sets, WidthCB());
      }
    }
    good_only = !good_only;
  } while (column_sets->empty() && !good_only);
  if (column_sets->empty())
    column_sets->move(&temp_cols);
  else
    temp_cols.delete_data_pointers();
}

// Prints debug information on the column candidates.
void ColumnFinder::PrintColumnCandidates(const char* title) {
  int set_size =  column_sets_.size();
  tprintf("Found %d %s:\n", set_size, title);
  if (textord_debug_tabfind >= 3) {
    for (int i = 0; i < set_size; ++i) {
      ColPartitionSet* column_set = column_sets_.get(i);
      column_set->Print();
    }
  }
}

// Finds the optimal set of columns that cover the entire image with as
// few changes in column partition as possible.
// NOTE: this could be thought of as an optimization problem, but a simple
// greedy algorithm is used instead. The algorithm repeatedly finds the modal
// compatible column in an unassigned region and uses that with the extra
// tweak of extending the modal region over small breaks in compatibility.
void ColumnFinder::AssignColumns() {
  int set_count = part_sets_.size();
  ASSERT_HOST(set_count == gridheight());
  // Allocate and init the best_columns_.
  best_columns_ = new ColPartitionSet*[set_count];
  for (int y = 0; y < set_count; ++y)
    best_columns_[y] = NULL;
  int column_count = column_sets_.size();
  // possible_column_sets[part_sets_ index][column_sets_ index] is
  // true if the partition set is compatible with the column set.
  // assigned_column_sets[part_sets_ index][column_sets_ index] is true
  // if the partition set has been assigned the column. (Multiple bits
  // true is possible.)
  // any_columns_possible[part_sets_ index] is true if any of
  // possible_column_sets[part_sets_ index][*] is true.
  // On return the best_columns_ member is set.
  bool* any_columns_possible = new bool[set_count];
  bool** possible_column_sets = new bool*[set_count];
  bool** assigned_column_sets = new bool*[set_count];
  // Set possible column_sets to indicate whether each set is compatible
  // with each column.
  for (int part_i = 0; part_i < set_count; ++part_i) {
    ColPartitionSet* line_set = part_sets_.get(part_i);
    bool debug = line_set != NULL &&
                 WithinTestRegion(2, line_set->bounding_box().left(),
                                  line_set->bounding_box().bottom());
    possible_column_sets[part_i] = new bool[column_count];
    assigned_column_sets[part_i] = new bool[column_count];
    any_columns_possible[part_i] = false;
    for (int col_i = 0; col_i < column_count; ++col_i) {
      assigned_column_sets[part_i][col_i] = false;
      if (line_set != NULL &&
          column_sets_.get(col_i)->CompatibleColumns(debug, line_set,
                                                     WidthCB())) {
        possible_column_sets[part_i][col_i] = true;
        any_columns_possible[part_i] = true;
      } else {
        possible_column_sets[part_i][col_i] = false;
      }
    }
  }
  // Assign a column set to each vertical grid position.
  // While there is an unassigned range, find its mode.
  int start, end;
  while (BiggestUnassignedRange(any_columns_possible, &start, &end)) {
    if (textord_debug_tabfind >= 2)
      tprintf("Biggest unassigned range = %d- %d\n", start, end);
    // Find the modal column_set_id in the range.
    int column_set_id = RangeModalColumnSet(possible_column_sets, start, end);
    if (textord_debug_tabfind >= 2) {
      tprintf("Range modal column id = %d\n", column_set_id);
      column_sets_.get(column_set_id)->Print();
    }
    // Now find the longest run of the column_set_id in the range.
    ShrinkRangeToLongestRun(possible_column_sets, any_columns_possible,
                            column_set_id, &start, &end);
    if (textord_debug_tabfind >= 2)
      tprintf("Shrunk range = %d- %d\n", start, end);
    // Extend the start and end past the longest run, while there are
    // only small gaps in compatibility that can be overcome by larger
    // regions of compatibility beyond.
    ExtendRangePastSmallGaps(possible_column_sets, any_columns_possible,
                             column_set_id, -1, -1, &start);
    --end;
    ExtendRangePastSmallGaps(possible_column_sets, any_columns_possible,
                             column_set_id, 1, set_count, &end);
    ++end;
    if (textord_debug_tabfind)
      tprintf("Column id %d applies to range = %d - %d\n",
              column_set_id, start, end);
    // Assign the column to the range, which now may overlap with other ranges.
    AssignColumnToRange(column_set_id, start, end,
                        assigned_column_sets);
  }
  // If anything remains unassigned, the whole lot is unassigned, so
  // arbitrarily assign id 0.
  if (best_columns_[0] == NULL) {
    AssignColumnToRange(0, 0, gridheight_, assigned_column_sets);
  }
  // Free memory.
  for (int i = 0; i < set_count; ++i) {
    delete [] possible_column_sets[i];
    delete [] assigned_column_sets[i];
  }
  delete [] any_columns_possible;
  delete [] possible_column_sets;
  delete [] assigned_column_sets;
  // TODO(rays) Now resolve overlapping assignments.
}

// Finds the biggest range in part_sets_ that has no assigned column, but
// column assignment is possible.
bool ColumnFinder::BiggestUnassignedRange(const bool* any_columns_possible,
                                          int* best_start, int* best_end) {
  int set_count = part_sets_.size();
  int best_range_size = 0;
  *best_start = set_count;
  *best_end = set_count;
  int end = set_count;
  for (int start = 0; start < gridheight_; start = end) {
    // Find the first unassigned index in start.
    while (start < set_count) {
      if (best_columns_[start] == NULL && any_columns_possible[start])
        break;
      ++start;
    }
    // Find the first past the end and count the good ones in between.
    int range_size = 1;  // Number of non-null, but unassigned line sets.
    end = start + 1;
    while (end < set_count) {
      if (best_columns_[end] != NULL)
        break;
      if (any_columns_possible[end])
        ++range_size;
      ++end;
    }
    if (start < set_count && range_size > best_range_size) {
      best_range_size = range_size;
      *best_start = start;
      *best_end = end;
    }
  }
  return *best_start < *best_end;
}

// Finds the modal compatible column_set_ index within the given range.
int ColumnFinder::RangeModalColumnSet(bool** possible_column_sets,
                                      int start, int end) {
  int column_count = column_sets_.size();
  STATS column_stats(0, column_count);
  for (int part_i = start; part_i < end; ++part_i) {
    for (int col_j = 0; col_j < column_count; ++col_j) {
      if (possible_column_sets[part_i][col_j])
        column_stats.add(col_j, 1);
    }
  }
  ASSERT_HOST(column_stats.get_total() > 0);
  return column_stats.mode();
}

// Given that there are many column_set_id compatible columns in the range,
// shrinks the range to the longest contiguous run of compatibility, allowing
// gaps where no columns are possible, but not where competing columns are
// possible.
void ColumnFinder::ShrinkRangeToLongestRun(bool** possible_column_sets,
                                           const bool* any_columns_possible,
                                           int column_set_id,
                                           int* best_start, int* best_end) {
  // orig_start and orig_end are the maximum range we will look at.
  int orig_start = *best_start;
  int orig_end = *best_end;
  int best_range_size = 0;
  *best_start = orig_end;
  *best_end = orig_end;
  int end = orig_end;
  for (int start = orig_start; start < orig_end; start = end) {
    // Find the first possible
    while (start < orig_end) {
      if (possible_column_sets[start][column_set_id] ||
          !any_columns_possible[start])
        break;
      ++start;
    }
    // Find the first past the end.
    end = start + 1;
    while (end < orig_end) {
      if (!possible_column_sets[end][column_set_id] &&
          any_columns_possible[end])
          break;
      ++end;
    }
    if (start < orig_end && end - start > best_range_size) {
      best_range_size = end - start;
      *best_start = start;
      *best_end = end;
    }
  }
}

// Moves start in the direction of step, upto, but not including end while
// the only incompatible regions are no more than kMaxIncompatibleColumnCount
// in size, and the compatible regions beyond are bigger.
void ColumnFinder::ExtendRangePastSmallGaps(bool** possible_column_sets,
                                            const bool* any_columns_possible,
                                            int column_set_id,
                                            int step, int end, int* start) {
  if (textord_debug_tabfind > 2)
    tprintf("Starting expansion at %d, step=%d, limit=%d\n",
            *start, step, end);
  if (*start == end)
    return;  // Cannot be expanded.

  int barrier_size = 0;
  int good_size = 0;
  do {
    // Find the size of the incompatible barrier.
    barrier_size = 0;
    int i;
    for (i = *start + step; i != end; i += step) {
      if (possible_column_sets[i][column_set_id])
        break;  // We are back on.
      // Locations where none are possible don't count.
      if (any_columns_possible[i])
        ++barrier_size;
    }
    if (textord_debug_tabfind > 2)
      tprintf("At %d, Barrier size=%d\n", i, barrier_size);
    if (barrier_size > kMaxIncompatibleColumnCount)
      return;  // Barrier too big.
    if (i == end) {
      // We can't go any further, but the barrier was small, so go to the end.
      *start = i - step;
      return;
    }
    // Now find the size of the good region on the other side.
    good_size = 1;
    for (i += step; i != end; i += step) {
      if (possible_column_sets[i][column_set_id])
        ++good_size;
      else if (any_columns_possible[i])
        break;
    }
    if (textord_debug_tabfind > 2)
      tprintf("At %d, good size = %d\n", i, good_size);
    // If we had enough good ones we can extend the start and keep looking.
    if (good_size > barrier_size)
      *start = i - step;
  } while (good_size > barrier_size);
}

// Assigns the given column_set_id to the given range.
void ColumnFinder::AssignColumnToRange(int column_set_id, int start, int end,
                                       bool** assigned_column_sets) {
  ColPartitionSet* column_set = column_sets_.get(column_set_id);
  for (int i = start; i < end; ++i) {
    assigned_column_sets[i][column_set_id] = true;
    best_columns_[i] = column_set;
  }
}

// Computes the mean_column_gap_.
void ColumnFinder::ComputeMeanColumnGap() {
  int total_gap = 0;
  int total_width = 0;
  int gap_samples = 0;
  int width_samples = 0;
  for (int i = 0; i < gridheight_; ++i) {
    ASSERT_HOST(best_columns_[i] != NULL);
    best_columns_[i]->AccumulateColumnWidthsAndGaps(&total_width,
                                                    &width_samples,
                                                    &total_gap,
                                                    &gap_samples);
  }
  mean_column_gap_ = gap_samples > 0 ? total_gap / gap_samples
                                     : total_width / width_samples;
}

//////// Functions that manipulate ColPartitions in the part_grid_ /////
//////// to split, merge, find margins, and find types.  //////////////

// Removes the ColPartitions from part_sets_, the ColPartitionSets that
// contain them, and puts them in the part_grid_ after ensuring that no
// BLOBNBOX is owned by more than one of them.
void ColumnFinder::MovePartitionsToGrid() {
  // Remove the parts from the part_sets_ and put them in the parts list.
  part_grid_.Init(gridsize(), bleft(), tright());
  ColPartition_LIST parts;
  for (int i = 0; i < gridheight_; ++i) {
    ColPartitionSet* line_set = part_sets_.get(i);
    if (line_set != NULL) {
      line_set->ReturnParts(&parts);
      delete line_set;
      part_sets_.set(NULL, i);
    }
  }
  // Make each part claim ownership of its own boxes uniquely.
  ColPartition_IT it(&parts);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColPartition* part = it.data();
    part->ClaimBoxes(WidthCB());
  }
  // Unknowns must be uniqued too.
  it.set_to_list(&unknown_parts_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColPartition* part = it.data();
    part->ClaimBoxes(WidthCB());
  }
  // Put non-empty parts into the grid and delete empty ones.
  for (it.set_to_list(&parts); !it.empty(); it.forward()) {
    ColPartition* part = it.extract();
    if (part->IsEmpty())
      delete part;
    else
      part_grid_.InsertBBox(true, true, part);
  }
}

// Splits partitions that cross columns where they have nothing in the gap.
void ColumnFinder::GridSplitPartitions() {
  // Iterate the ColPartitions in the grid.
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&part_grid_);
  gsearch.StartFullSearch();
  ColPartition* dont_repeat = NULL;
  ColPartition* part;
  while ((part = gsearch.NextFullSearch()) != NULL) {
    if (part->blob_type() < BRT_UNKNOWN || part == dont_repeat)
      continue;  // Only applies to text partitions.
    ColPartitionSet* column_set = best_columns_[gsearch.GridY()];
    int first_col = -1;
    int last_col = -1;
    // Find which columns the partition spans.
    part->ColumnRange(column_set, &first_col, &last_col);
    if (first_col > 0)
      --first_col;
    // Convert output column indices to physical column indices.
    first_col /= 2;
    last_col /= 2;
    // We will only consider cases where a partition spans two columns,
    // since a heading that spans more columns than that is most likely
    // genuine.
    if (last_col != first_col + 1)
      continue;
    if (textord_debug_tabfind) {
      tprintf("Considering partition for GridSplit:");
      part->Print();
    }
    // Set up a rectangle search x-bounded by the column gap and y by the part.
    int y = part->MidY();
    TBOX margin_box = part->bounding_box();
    ColPartition* column = column_set->GetColumnByIndex(first_col);
    if (column == NULL)
      continue;
    margin_box.set_left(column->RightAtY(y) + 2);
    column = column_set->GetColumnByIndex(last_col);
    if (column == NULL)
      continue;
    margin_box.set_right(column->LeftAtY(y) - 2);
    // TODO(rays) Decide whether to keep rectangular filling or not in the
    // main grid and therefore whether we need a fancier search here.
    // Now run the rect search on the main blob grid.
    GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> rectsearch(this);
    if (textord_debug_tabfind) {
      tprintf("Searching box (%d,%d)->(%d,%d)\n",
              margin_box.left(), margin_box.bottom(),
              margin_box.right(), margin_box.top());
      part->Print();
    }
    rectsearch.StartRectSearch(margin_box);
    BLOBNBOX* bbox;
    while ((bbox = rectsearch.NextRectSearch()) != NULL) {
      if (bbox->bounding_box().overlap(margin_box))
        break;
    }
    if (bbox == NULL) {
      // There seems to be nothing in the hole, so split the partition.
      gsearch.RemoveBBox();
      int x_middle = (margin_box.left() + margin_box.right()) / 2;
      if (textord_debug_tabfind) {
        tprintf("Splitting part at %d:", x_middle);
        part->Print();
      }
      ColPartition* split_part = part->SplitAt(x_middle);
      if (split_part != NULL) {
        if (textord_debug_tabfind) {
          tprintf("Split result:");
          part->Print();
          split_part->Print();
        }
        part_grid_.InsertBBox(true, true, split_part);
      } else {
        // Split had no effect
        if (textord_debug_tabfind)
          tprintf("Split had no effect\n");
        dont_repeat = part;
      }
      part_grid_.InsertBBox(true, true, part);
      gsearch.RepositionIterator();
    } else if (textord_debug_tabfind) {
      tprintf("Part cannot be split: blob (%d,%d)->(%d,%d) in column gap\n",
              bbox->bounding_box().left(), bbox->bounding_box().bottom(),
              bbox->bounding_box().right(), bbox->bounding_box().top());
    }
  }
}

// Merges partitions where there is vertical overlap, within a single column,
// and the horizontal gap is small enough.
void ColumnFinder::GridMergePartitions() {
  // Iterate the ColPartitions in the grid.
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&part_grid_);
  gsearch.StartFullSearch();
  ColPartition* part;
  while ((part = gsearch.NextFullSearch()) != NULL) {
    // Set up a rectangle search x-bounded by the column and y by the part.
    ColPartitionSet* columns = best_columns_[gsearch.GridY()];
    TBOX box = part->bounding_box();
    int y = part->MidY();
    ColPartition* left_column = columns->ColumnContaining(box.left(), y);
    ColPartition* right_column = columns->ColumnContaining(box.right(), y);
    if (left_column == NULL || right_column != left_column)
      continue;
    box.set_left(left_column->LeftAtY(y));
    box.set_right(right_column->RightAtY(y));
    // Now run the rect search.
    bool modified_box = false;
    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
      rsearch(&part_grid_);
    rsearch.StartRectSearch(box);
    ColPartition* neighbour;

    while ((neighbour = rsearch.NextRectSearch()) != NULL) {
      if (neighbour == part)
        continue;
      const TBOX& neighbour_box = neighbour->bounding_box();
      if (neighbour_box.right() < box.left() ||
          neighbour_box.left() > box.right())
        continue;  // Not within the same column.
      if (part->VOverlaps(*neighbour) && part->TypesMatch(*neighbour)) {
        // There is vertical overlap and the gross types match, but only
        // merge if the horizontal gap is small enough, as one of the
        // partitions may be a figure caption within a column.
        // If there is only one column, then the mean_column_gap_ is large
        // enough to allow almost any merge, by being the mean column width.
        const TBOX& part_box = part->bounding_box();
        int h_gap = MAX(part_box.left(), neighbour_box.left()) -
                    MIN(part_box.right(), neighbour_box.right());
        if (h_gap < mean_column_gap_ * kHorizontalGapMergeFraction ||
            part_box.width() < mean_column_gap_ ||
            neighbour_box.width() < mean_column_gap_) {
          if (textord_debug_tabfind) {
            tprintf("Running grid-based merge between:\n");
            part->Print();
            neighbour->Print();
          }
          rsearch.RemoveBBox();
          gsearch.RepositionIterator();
          part->Absorb(neighbour, WidthCB());
          modified_box = true;
        }
      }
    }
    if (modified_box) {
      // We modified the box of part, so re-insert it into the grid.
      // This does no harm in the current cell, as it already exists there,
      // but it needs to exist in all the cells covered by its bounding box,
      // or it will never be found by a full search.
      // Because the box has changed, it has to be removed first, otherwise
      // add_sorted may fail to keep a single copy of the pointer.
      gsearch.RemoveBBox();
      part_grid_.InsertBBox(true, true, part);
      gsearch.RepositionIterator();
    }
  }
}

// Helper function to compute the total pairwise area overlap of a list of
// Colpartitions. If box_this matches an element in the list, the test_box
// is used in place of its box.
static int TotalPairwiseOverlap(const ColPartition* box_this,
                                const TBOX& test_box,
                                ColPartition_CLIST* parts) {
  if (parts->singleton())
    return 0;
  int total_area = 0;
  for (ColPartition_C_IT it(parts); !it.at_last(); it.forward()) {
    ColPartition* part = it.data();
    TBOX part_box = part == box_this ? test_box : part->bounding_box();
    ColPartition_C_IT it2(it);
    for (it2.forward(); !it2.at_first(); it2.forward()) {
      ColPartition* part2 = it2.data();
      TBOX part_box2 = part2 == box_this ? test_box : part2->bounding_box();
      total_area += part_box.intersection(part_box2).area();
    }
  }
  return total_area;
}

// Helper function to compute the total area of a list of Colpartitions.
// If box_this matches an element in the list, the test_box
// is used in place of its box.
static int TotalArea(const ColPartition* box_this, const TBOX& test_box,
                     ColPartition_CLIST* parts) {
  int total_area = 0;
  ColPartition_C_IT it(parts);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColPartition* part = it.data();
    TBOX part_box = part == box_this ? test_box : part->bounding_box();
    total_area += part_box.area();
  }
  return total_area;
}

// Resolves unknown partitions from the unknown_parts_ list by merging them
// with a close neighbour, inserting them into the grid with a known type,
// or declaring them to be noise.
void ColumnFinder::GridInsertUnknowns() {
  ColPartition_IT noise_it(&noise_parts_);
  for (ColPartition_IT it(&unknown_parts_); !it.empty(); it.forward()) {
    ColPartition* part = it.extract();
    if (part->IsEmpty()) {
      // Claiming ownership left this one empty.
      delete part;
      continue;
    }
    const TBOX& part_box = part->bounding_box();
    int left_limit = LeftEdgeForBox(part_box, false, false);
    int right_limit = RightEdgeForBox(part_box, false, false);
    TBOX search_box = part_box;
    int y = part->MidY();
    int grid_x, grid_y;
    GridCoords(part_box.left(), y, &grid_x, &grid_y);
    // Set up a rectangle search x-bounded by the column and y by the part.
    ColPartitionSet* columns = best_columns_[grid_y];
    int first_col = -1;
    int last_col = -1;
    // Find which columns the partition spans.
    part->ColumnRange(columns, &first_col, &last_col);
    // Convert output column indices to physical column indices.
    // Twiddle with first and last_col to get the desired effect with
    // in-between columns:
    // As returned by ColumnRange, the indices are even for in-betweens and
    // odd for real columns (being 2n+1 the real column index).
    // Subtract 1 from first col, so we can use left edge of first_col/2 if it
    // is even, and the right edge of first_col/2 if it is odd.
    // With last_col unchanged, we can use the right edge of last_col/2 if it
    // is odd and the left edge of last_col/2 if it is even.
    // with first_col, we have to special-case to pretend that the first
    // in-between is actually the first column, and with last_col, we have to
    // pretend that the last in-between is actually the last column.
    if (first_col > 0)
      --first_col;
    ColPartition* first_column = columns->GetColumnByIndex(first_col / 2);
    ColPartition* last_column = columns->GetColumnByIndex(last_col / 2);
    if (last_column == NULL && last_col > first_col + 1)
      last_column = columns->GetColumnByIndex(last_col / 2 - 1);
    // Do not accept the case of both being in the first or last in-between.
    if (last_col > 0 && first_column != NULL && last_column != NULL) {
      search_box.set_left((first_col & 1) ? first_column->RightAtY(y)
                                          : first_column->LeftAtY(y));
      search_box.set_right((last_col & 1) ? last_column->RightAtY(y)
                                          : last_column->LeftAtY(y));
      // Expand the search vertically.
      int height = search_box.height();
      search_box.set_top(search_box.top() + height);
      search_box.set_bottom(search_box.bottom() - height);
      // Keep valid neighbours in a list.
      ColPartition_CLIST neighbours;
      // Now run the rect search.
      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
        rsearch(&part_grid_);
      rsearch.StartRectSearch(search_box);
      ColPartition* neighbour;
      while ((neighbour = rsearch.NextRectSearch()) != NULL) {
        const TBOX& n_box = neighbour->bounding_box();
        if (n_box.left() > right_limit || n_box.right() < left_limit)
          continue;  // Other side of a tab vector.
        if (neighbour->blob_type() == BRT_RECTIMAGE) {
          continue;  // Rectangle images aren't allowed to acquire anything.
        }
        // We can't merge with a partition where it would go beyond the margin
        // of the partition.
        if ((part_box.left() < neighbour->left_margin() ||
            part_box.right() > neighbour->right_margin()) &&
            !n_box.contains(part_box)) {
          continue;  // This would create an overlap with another partition.
        }
        // Candidates must be within a reasonable vertical distance.
        int v_dist = -part->VOverlap(*neighbour);
        if (v_dist >= MAX(part_box.height(), n_box.height()) / 2)
          continue;
        // Unique elements as they arrive.
        neighbours.add_sorted(SortByBoxLeft<ColPartition>, true, neighbour);
      }
      // The best neighbour to merge with is the one that causes least
      // total pairwise overlap among all the candidates.
      // If more than one offers the same total overlap, choose the one
      // with the least total area.
      ColPartition* best_neighbour = NULL;
      ColPartition_C_IT n_it(&neighbours);
      if (neighbours.singleton()) {
        best_neighbour = n_it.data();
      } else if (!neighbours.empty()) {
        int best_overlap = MAX_INT32;
        int best_area = 0;
        for (n_it.mark_cycle_pt(); !n_it.cycled_list(); n_it.forward()) {
          neighbour = n_it.data();
          TBOX merged_box = neighbour->bounding_box();
          merged_box += part_box;
          int overlap = TotalPairwiseOverlap(neighbour, merged_box,
                                             &neighbours);
          if (best_neighbour == NULL || overlap < best_overlap) {
            best_neighbour = neighbour;
            best_overlap = overlap;
            best_area = TotalArea(neighbour, merged_box, &neighbours);
          } else if (overlap == best_overlap) {
            int area = TotalArea(neighbour, merged_box, &neighbours);
            if (area < best_area) {
              best_area = area;
              best_neighbour = neighbour;
            }
          }
        }
      }
      if (best_neighbour != NULL) {
        // It was close enough to an existing partition to merge it.
        if (textord_debug_tabfind) {
          tprintf("Merging unknown partition:\n");
          part->Print();
          best_neighbour->Print();
        }
        // Because the box is about to be resized, it must be removed and
        // then re-inserted to prevent duplicates in the grid lists.
        part_grid_.RemoveBBox(best_neighbour);
        best_neighbour->Absorb(part, WidthCB());
        // We modified the box of best_neighbour, so re-insert it into the grid.
        part_grid_.InsertBBox(true, true, best_neighbour);
      } else {
        // It was inside a column, so just add it to the grid.
        if (textord_debug_tabfind)
          tprintf("Inserting unknown partition:\n");
        part_grid_.InsertBBox(true, true, part);
      }
    } else {
      if (textord_debug_tabfind) {
        tprintf("Unknown partition at (%d,%d)->(%d,%d) not in any column\n",
                part_box.left(), part_box.bottom(), part_box.right(),
                part_box.top());
        tprintf("first_col = %d->%p, last_col=%d->%p\n",
                first_col, first_column, last_col, last_column);
      }
      noise_it.add_to_end(part);
    }
  }
}

// Add horizontal line separators as partitions.
void ColumnFinder::GridInsertHLinePartitions() {
  TabVector_IT hline_it(&horizontal_lines_);
  for (hline_it.mark_cycle_pt(); !hline_it.cycled_list(); hline_it.forward()) {
    TabVector* hline = hline_it.data();
    int top = MAX(hline->startpt().y(), hline->endpt().y());
    int bottom = MIN(hline->startpt().y(), hline->endpt().y());
    if (top == bottom) {
      if (bottom > 0)
        --bottom;
      else
        ++top;
    }
    ColPartition* part = new ColPartition(vertical_skew_,
                                          hline->startpt().x(), bottom,
                                          hline->endpt().x(), top);
    part_grid_.InsertBBox(true, true, part);
  }
}

// Improves the margins of the ColPartitions in the grid by calling
// FindPartitionMargins on each.
void ColumnFinder::GridFindMargins() {
  // Iterate the ColPartitions in the grid.
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&part_grid_);
  gsearch.StartFullSearch();
  ColPartition* part;
  while ((part = gsearch.NextFullSearch()) != NULL) {
    // Set up a rectangle search x-bounded by the column and y by the part.
    ColPartitionSet* columns = best_columns_[gsearch.GridY()];
    FindPartitionMargins(columns, part);
  }
}

// Improves the margins of the ColPartitions in the list by calling
// FindPartitionMargins on each.
void ColumnFinder::ListFindMargins(ColPartition_LIST* parts) {
  ColPartition_IT part_it(parts);
  for (part_it.mark_cycle_pt(); !part_it.cycled_list(); part_it.forward()) {
    ColPartition* part = part_it.data();
    TBOX part_box = part->bounding_box();
    // Get the columns from the y grid coord.
    int grid_x, grid_y;
    GridCoords(part_box.left(), part_box.bottom(), &grid_x, &grid_y);
    ColPartitionSet* columns = best_columns_[grid_y];
    FindPartitionMargins(columns, part);
  }
}

// Improves the margins of the ColPartition by searching for
// neighbours that vertically overlap significantly.
void ColumnFinder::FindPartitionMargins(ColPartitionSet* columns,
                                        ColPartition* part) {
  // Set up a rectangle search x-bounded by the column and y by the part.
  ASSERT_HOST(columns != NULL);
  TBOX box = part->bounding_box();
  int y = part->MidY();
  // Initial left margin is based on the column, if there is one.
  ColPartition* column = columns->ColumnContaining(box.left(), y);
  int left_margin = column != NULL ? column->LeftAtY(y) : bleft_.x();
  left_margin -= kColumnWidthFactor;
  // Search for ColPartitions that reduce the margin.
  left_margin = FindMargin(box.left()+ box.height(), true, left_margin,
                           box.bottom(), box.top(), part);
  part->set_left_margin(left_margin);
  column = columns->ColumnContaining(box.right(), y);
  int right_margin = column != NULL ? column->RightAtY(y) : tright_.x();
  right_margin += kColumnWidthFactor;
  // Search for ColPartitions that reduce the margin.
  right_margin = FindMargin(box.right() - box.height(), false, right_margin,
                            box.bottom(), box.top(), part);
  part->set_right_margin(right_margin);
}

// Starting at x, and going in the specified direction, upto x_limit, finds
// the margin for the given y range by searching sideways,
// and ignoring not_this.
int ColumnFinder::FindMargin(int x, bool right_to_left, int x_limit,
                             int y_bottom, int y_top,
                             const ColPartition* not_this) {
  int height = y_top - y_bottom;
  int target_overlap = static_cast<int>(height * kMarginOverlapFraction);
  // Iterate the ColPartitions in the grid.
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    side_search(&part_grid_);
  side_search.StartSideSearch(x, y_bottom, y_top);
  ColPartition* part;
  while ((part = side_search.NextSideSearch(right_to_left)) != NULL) {
    // Ignore itself.
    if (part == not_this)
      continue;
    // Must overlap by enough.
    TBOX box = part->bounding_box();
    int y_overlap = MIN(y_top, box.top()) - MAX(y_bottom, box.bottom());
    if (y_overlap < target_overlap)
      continue;
    // Must be going the right way.
    int x_edge = right_to_left ? box.right() : box.left();
    if ((x_edge < x) != right_to_left)
      continue;
    // If we have gone past x_limit, then x_limit will do.
    if ((x_edge < x_limit) == right_to_left)
      break;
    // It reduces x limit, so save the new one.
    x_limit = x_edge;
  }
  return x_limit;
}

// For every ColPartition in the grid, sets its type based on position
// in the columns.
void ColumnFinder::SetPartitionTypes() {
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&part_grid_);
  gsearch.StartFullSearch();
  ColPartition* part;
  while ((part = gsearch.NextFullSearch()) != NULL) {
    part->SetPartitionType(best_columns_[gsearch.GridY()]);
  }
}

//////// Functions that manipulate ColPartitions in the part_grid_ /////
//////// to find chains of partner partitions of the same type.  ///////

// For every ColPartition in the grid, finds its upper and lower neighbours.
void ColumnFinder::FindPartitionPartners() {
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&part_grid_);
  gsearch.StartFullSearch();
  ColPartition* part;
  while ((part = gsearch.NextFullSearch()) != NULL) {
    FindPartitionPartners(true, part);
    FindPartitionPartners(false, part);
  }
}

// Finds the best partner in the given direction for the given partition.
// Stores the result with AddPartner.
void ColumnFinder::FindPartitionPartners(bool upper, ColPartition* part) {
  if (part->type() == PT_NOISE)
    return;  // Noise is not allowed to partner anything.
  const TBOX& box = part->bounding_box();
  int top = part->median_top();
  int bottom = part->median_bottom();
  int height = top - bottom;
  int mid_y = (bottom + top) / 2;
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    vsearch(&part_grid_);
  // Search down for neighbour below
  vsearch.StartVerticalSearch(box.left(), box.right(), part->MidY());
  ColPartition* neighbour;
  ColPartition* best_neighbour = NULL;
  int best_dist = MAX_INT32;
  while ((neighbour = vsearch.NextVerticalSearch(!upper)) != NULL) {
    if (neighbour == part || neighbour->type() == PT_NOISE)
      continue;  // Noise is not allowed to partner anything.
    int neighbour_bottom = neighbour->median_bottom();
    int neighbour_top = neighbour->median_top();
    int neighbour_y = (neighbour_bottom + neighbour_top) / 2;
    if (upper != (neighbour_y > mid_y))
      continue;
    if (!part->HOverlaps(*neighbour) && !part->HCompatible(*neighbour))
      continue;
    if (!part->TypesMatch(*neighbour)) {
      if (best_neighbour == NULL)
        best_neighbour = neighbour;
      continue;
    }
    int dist = upper ? neighbour_bottom - top : bottom - neighbour_top;
    if (dist <= kMaxPartitionSpacing * height) {
      if (dist < best_dist) {
        best_dist = dist;
        best_neighbour = neighbour;
      }
    } else {
      break;
    }
  }
  if (best_neighbour != NULL)
    part->AddPartner(upper, best_neighbour);
}

// For every ColPartition with multiple partners in the grid, reduces the
// number of partners to 0 or 1.
void ColumnFinder::RefinePartitionPartners() {
  // Refine in type order so that chasing multple partners can be done
  // before eliminating type mis-matching partners.
  for (int type = PT_UNKNOWN + 1; type <= PT_COUNT; type++) {
    // Iterate the ColPartitions in the grid.
    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
      gsearch(&part_grid_);
    gsearch.StartFullSearch();
    ColPartition* part;
    while ((part = gsearch.NextFullSearch()) != NULL) {
      part->RefinePartners(static_cast<PolyBlockType>(type));
    }
  }
}

// Only images remain with multiple types in a run of partners.
// Sets the type of all in the group to the maximum of the group.
void ColumnFinder::SmoothPartnerRuns() {
  // Iterate the ColPartitions in the grid.
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&part_grid_);
  gsearch.StartFullSearch();
  ColPartition* part;
  while ((part = gsearch.NextFullSearch()) != NULL) {
    ColPartition* partner = part->SingletonPartner(true);
    if (partner != NULL) {
      ASSERT_HOST(partner->SingletonPartner(false) == part);
    } else if (part->SingletonPartner(false) != NULL) {
      ColPartitionSet* column_set = best_columns_[gsearch.GridY()];
      int column_count = column_set->ColumnCount();
      part->SmoothPartnerRun(column_count * 2 + 1);
    }
  }
}

// Helper functions for TransformToBlocks.
// Add the part to the temp list in the correct order.
void ColumnFinder::AddToTempPartList(ColPartition* part,
                                     ColPartition_CLIST* temp_list) {
  int mid_y = part->MidY();
  ColPartition_C_IT it(temp_list);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    ColPartition* test_part = it.data();
    if (part->type() == PT_NOISE || test_part->type() == PT_NOISE)
      continue;  // Noise stays in sequence.
    if (test_part == part->SingletonPartner(false))
      break;  // Insert before its lower partner.
    int neighbour_bottom = test_part->median_bottom();
    int neighbour_top = test_part->median_top();
    int neighbour_y = (neighbour_bottom + neighbour_top) / 2;
    if (neighbour_y < mid_y)
      break;  // part is above test_part so insert it.
    if (!part->HOverlaps(*test_part) && !part->HCompatible(*test_part))
      continue;  // Incompatibles stay in order
  }
  if (it.cycled_list()) {
    it.add_to_end(part);
  } else {
    it.add_before_stay_put(part);
  }
}

// Add everything from the temp list to the work_set assuming correct order.
void ColumnFinder::EmptyTempPartList(ColPartition_CLIST* temp_list,
                                     WorkingPartSet_LIST* work_set) {
  ColPartition_C_IT it(temp_list);
  while (!it.empty()) {
    it.extract()->AddToWorkingSet(bleft_, tright_, resolution_,
                          &good_parts_, work_set);
    it.forward();
  }
}

// Transform the grid of partitions to the output blocks.
void ColumnFinder::TransformToBlocks(BLOCK_LIST* blocks,
                                     TO_BLOCK_LIST* to_blocks) {
  WorkingPartSet_LIST work_set;
  ColPartitionSet* column_set = NULL;
  ColPartition_IT noise_it(&noise_parts_);
  // The temp_part_list holds a list of parts at the same grid y coord
  // so they can be added in the correct order. This prevents thin objects
  // like horizontal lines going before the text lines above them.
  ColPartition_CLIST temp_part_list;
  // Iterate the ColPartitions in the grid. It starts at the top
  GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>
    gsearch(&part_grid_);
  gsearch.StartFullSearch();
  int prev_grid_y = -1;
  ColPartition* part;
  while ((part = gsearch.NextFullSearch()) != NULL) {
    int grid_y = gsearch.GridY();
    if (grid_y != prev_grid_y) {
      EmptyTempPartList(&temp_part_list, &work_set);
      prev_grid_y = grid_y;
    }
    if (best_columns_[grid_y] != column_set) {
      column_set = best_columns_[grid_y];
      // Every line should have a non-null best column.
      ASSERT_HOST(column_set != NULL);
      column_set->ChangeWorkColumns(bleft_, tright_, resolution_,
                                    &good_parts_, &work_set);
      if (textord_debug_tabfind)
        tprintf("Changed column groups at grid index %d\n", gsearch.GridY());
    }
    if (part->type() == PT_NOISE) {
      noise_it.add_to_end(part);
    } else {
      AddToTempPartList(part, &temp_part_list);
    }
  }
  EmptyTempPartList(&temp_part_list, &work_set);
  // Now finish all working sets and transfer ColPartitionSets to block_sets.
  WorkingPartSet_IT work_it(&work_set);
  while (!work_it.empty()) {
    WorkingPartSet* working_set = work_it.extract();
    working_set->ExtractCompletedBlocks(bleft_, tright_, resolution_,
                                        &good_parts_, blocks, to_blocks);
    delete working_set;
    work_it.forward();
  }
}

// Reskew the completed blocks to put them back to the original coords.
// (Blob outlines are not corrected for skew.)
// Rotate blobs and blocks individually so text line direction is
// horizontal. Record appropriate inverse transformations and required
// classifier transformation in the blocks.
void ColumnFinder::RotateAndReskewBlocks(TO_BLOCK_LIST* blocks) {
  TO_BLOCK_IT it(blocks);
  int block_index = 1;
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    TO_BLOCK* to_block = it.data();
    BLOCK* block = to_block->block;
    block->set_index(block_index++);
    BLOBNBOX_IT blob_it(&to_block->blobs);
    // ColPartition::MakeBlock stored the inverse rotation that must be
    // applied to small vertical blocks to go back to the original image
    // coords at the end of recognition, but did not actually do any rotations,
    // so now blocks must actually be rotated to make them horizontal by the
    // inverse of that stored inverse rotation. This is of course a no-op
    // for normal blocks.
    FCOORD block_rotation = block->re_rotation();
    block_rotation.set_y(-block_rotation.y());
    block->poly_block()->rotate(block_rotation);
    // The final stored inverse coordinate rotation (block->re_rotation_)
    // is the sum of rerotate_ (for gross vertical pages) and the current
    // block->re_rotation_ (for small vertical text regions).
    // We will execute the inverse of that on all the blobs.
    FCOORD blob_rotation = block->re_rotation();
    blob_rotation.rotate(rerotate_);
    block->set_re_rotation(blob_rotation);
    blob_rotation.set_y(-blob_rotation.y());
    // TODO(rays) determine classify rotation by orientation detection.
    // In the mean time, it works for Chinese and English photo credits
    // to set a classify rotation to the stored block rerotation only if
    // the block rotation to do (before skew) is 0.
    if (block_rotation.y() == 0.0f) {
      block->set_classify_rotation(block->re_rotation());
    }
    // Blocks must also be rotated back by the skew angle.
    block->rotate(reskew_);
    // Save the skew in the block.
    block->set_skew(reskew_);
    // Rotate all the blobs if needed and recompute the bounding boxes.
    // Compute the block median blob width and height as we go.
    STATS widths(0, block->bounding_box().width());
    STATS heights(0, block->bounding_box().height());
    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
      BLOBNBOX* blob = blob_it.data();
      if (blob_rotation.y() != 0.0f) {
        blob->cblob()->rotate(blob_rotation);
      }
      blob->compute_bounding_box();
      widths.add(blob->bounding_box().width(), 1);
      heights.add(blob->bounding_box().height(), 1);
    }
    block->set_median_size(static_cast<int>(widths.median() + 0.5),
                           static_cast<int>(heights.median() + 0.5));
    if (textord_debug_tabfind > 1)
      tprintf("Block median size = (%d, %d)\n",
              block->median_size().x(), block->median_size().y());
  }
}

// TransformToBlocks leaves all the small and noise blobs untouched in the
// source TO_BLOCK. MoveSmallBlobs moves them into the main blobs list of
// the block from the to_blocks list that contains them.
// TODO(rays) This is inefficient with a large number of blocks. A more
// efficient implementation is possible using a BBGrid.
void ColumnFinder::MoveSmallBlobs(BLOBNBOX_LIST* bblobs,
                                  TO_BLOCK_LIST* to_blocks) {
  for (BLOBNBOX_IT bb_it(bblobs); !bb_it.empty(); bb_it.forward()) {
    BLOBNBOX* bblob = bb_it.extract();
    const TBOX& bbox = bblob->bounding_box();
    // Find the centre of the blob.
    ICOORD centre = bbox.botleft();
    centre += bbox.topright();
    centre /= 2;
    // Find the TO_BLOCK that contains the centre and put the blob in
    // its main blobs list.
    TO_BLOCK_IT to_it(to_blocks);
    for (to_it.mark_cycle_pt(); !to_it.cycled_list(); to_it.forward()) {
      TO_BLOCK* to_block = to_it.data();
      BLOCK* block = to_block->block;
      if (block->contains(centre)) {
        BLOBNBOX_IT blob_it(&to_block->blobs);
        blob_it.add_to_end(bblob);
        bblob = NULL;
        break;
      }
    }
    if (bblob != NULL) {
      delete bblob->cblob();
      delete bblob;
    }
  }
}
/////////////////////////////////////////////////////////////////colfind////////////////////////////////////////

/////////////////////////////////////////////////////////////////osdetect////////////////////////////////////////
extern IMAGE page_image;

const int kMinCharactersToTry = 50;
const int kMaxCharactersToTry = 5 * kMinCharactersToTry;

const float kSizeRatioToReject = 2.0;

const float kOrientationAcceptRatio = 1.3;
const float kScriptAcceptRatio = 1.3;

const float kHanRatioInKorean = 0.7;
const float kHanRatioInJapanese = 0.3;

const float kLatinRationInFraktur = 0.7;

const float kNonAmbiguousMargin = 1.0;

// General scripts
static const char* han_script = "Han";
static const char* latin_script = "Latin";
static const char* katakana_script = "Katakana";
static const char* hiragana_script = "Hiragana";
static const char* hangul_script = "Hangul";

// Pseudo-scripts Name
const char* ScriptDetector::korean_script_ = "Korean";
const char* ScriptDetector::japanese_script_ = "Japanese";
const char* ScriptDetector::fraktur_script_ = "Fraktur";

//CLISTIZEH(BLOBNBOX)
CLISTIZE(BLOBNBOX)

// Find connected components in the page and process a subset until finished or
// a stopping criterion is met.
// Returns true if the page was successfully processed.
bool orientation_and_script_detection(STRING& filename,
                                      OSResults* osr,
                                      Tesseract* tess) {
  STRING name = filename;        //truncated name
  const char *lastdot;           //of name
  TO_BLOCK_LIST land_blocks, port_blocks;
  BLOCK_LIST blocks;
  TBOX page_box;

  lastdot = strrchr (name.string (), '.');
  if (lastdot != NULL)
    name[lastdot-name.string()] = '\0';
  if (!read_unlv_file(name, page_image.get_xsize(), page_image.get_ysize(),
                     &blocks))
    FullPageBlock(page_image.get_xsize(), page_image.get_ysize(), &blocks);
  find_components(&blocks, &land_blocks, &port_blocks, &page_box);
  return os_detect(&port_blocks, osr, tess);
}

// Filter and sample the blobs.
// Returns true if the page was successfully processed, or false if the page had
// too few characters to be reliable
bool os_detect(TO_BLOCK_LIST* port_blocks, OSResults* osr,
               Tesseract* tess) {
  int blobs_total = 0;
  OSResults osr_;
  if (osr == NULL)
    osr = &osr_;

  osr->unicharset = &tess->unicharset;
  OrientationDetector o(osr);
  ScriptDetector s(osr, tess);

  TO_BLOCK_IT block_it;
  block_it.set_to_list(port_blocks);

  BLOBNBOX_CLIST filtered_list;
  BLOBNBOX_C_IT filtered_it(&filtered_list);

  for (block_it.mark_cycle_pt(); !block_it.cycled_list();
       block_it.forward ()) {
    TO_BLOCK* block = block_it.data();
    BLOBNBOX_IT bbox_it;
    bbox_it.set_to_list(&block->blobs);
    for (bbox_it.mark_cycle_pt (); !bbox_it.cycled_list ();
         bbox_it.forward ()) {
      BLOBNBOX* bbox = bbox_it.data();
      C_BLOB*   blob = bbox->cblob();
      TBOX      box = blob->bounding_box();
      ++blobs_total;

      float y_x = fabs((box.height() * 1.0) / box.width());
      float x_y = 1.0f / y_x;
      // Select a >= 1.0 ratio
      float ratio = x_y > y_x ? x_y : y_x;
      // Blob is ambiguous
      if (ratio > kSizeRatioToReject) continue;
      if (box.height() < 10) continue;
      filtered_it.add_to_end(bbox);
    }
  }
  if (filtered_it.length() > 0)
    filtered_it.move_to_first();

  int real_max = MIN(filtered_it.length(), kMaxCharactersToTry);
   printf("Total blobs found = %d\n", blobs_total);
   printf("Number of blobs post-filtering = %d\n", filtered_it.length());
   printf("Number of blobs to try = %d\n", real_max);

  // If there are too few characters, skip this page entirely.
  if (real_max < kMinCharactersToTry / 2) {
    printf("Too few characters. Skipping this page\n");
    return false;
  }

  BLOBNBOX** blobs = new BLOBNBOX*[filtered_it.length()];
  int number_of_blobs = 0;
  for (filtered_it.mark_cycle_pt (); !filtered_it.cycled_list ();
       filtered_it.forward ()) {
    blobs[number_of_blobs++] = (BLOBNBOX*)filtered_it.data();
  }
  QRSequenceGenerator sequence(number_of_blobs);
  for (int i = 0; i < real_max; ++i) {
    if (os_detect_blob(blobs[sequence.GetVal()], &o, &s, osr, tess)
        && i > kMinCharactersToTry) {
      break;
    }
  }
  delete [] blobs;

  // Make sure the best_result is up-to-date
  int orientation = o.get_orientation();
  s.update_best_script(orientation);
  return true;
}

// Processes a single blob to estimate script and orientation.
// Return true if estimate of orientation and script satisfies stopping
// criteria.
bool os_detect_blob(BLOBNBOX* bbox, OrientationDetector* o,
                    ScriptDetector* s, OSResults* osr,
                    Tesseract* tess)
{
    Q_UNUSED(osr);
  C_BLOB*   blob = bbox->cblob();
  TBOX      box = blob->bounding_box();

  int       x_mid = (box.left() + box.right()) / 2.0f;
  int       y_mid = (box.bottom() + box.top()) / 2.0f;

  PBLOB     pblob(blob, box.height());

  BLOB_CHOICE_LIST ratings[4];
  // Test the 4 orientations
  for (int i = 0; i < 4; ++i) {
    // normalize the blob
    pblob.move(FCOORD(-x_mid, -box.bottom()));
    pblob.scale(static_cast<float>(bln_x_height) / box.height());
    pblob.move(FCOORD(0.0f, bln_baseline_offset));

    {
      // List of choices given by the classifier
      TBLOB *tessblob;               //converted blob
      TEXTROW tessrow;               //dummy row

      tess_cn_matching.set_value(true); // turn it on
      tess_bn_matching.set_value(false);
      //convert blob
      tessblob = make_tess_blob (&pblob, TRUE);
      //make dummy row
      make_tess_row(NULL, &tessrow);
      //classify
      tess->AdaptiveClassifier (tessblob, NULL, &tessrow, ratings + i, NULL);
      free_blob(tessblob);
    }
    // undo normalize
    pblob.move(FCOORD(0.0f, -bln_baseline_offset));
    pblob.scale(1.0f / (static_cast<float>(bln_x_height) / box.height()));
    pblob.move(FCOORD(x_mid, box.bottom()));

    // center the blob
    pblob.move(FCOORD(-x_mid, -y_mid));

    // Rotate it
    pblob.rotate();

    // Re-compute the mid
    box = pblob.bounding_box();
    x_mid = (box.left() + box.right()) / 2;
    y_mid = (box.top() + box.bottom()) / 2;

    // re-center in the new mid
    pblob.move(FCOORD(x_mid, y_mid));
  }

  bool stop = o->detect_blob(ratings);
  s->detect_blob(ratings);
  int orientation = o->get_orientation();
  stop = s->must_stop(orientation) && stop;
  return stop;
}


OrientationDetector::OrientationDetector(OSResults* osr) {
  osr_ = osr;
}

// Score the given blob and return true if it is now sure of the orientation
// after adding this block.
bool OrientationDetector::detect_blob(BLOB_CHOICE_LIST* scores) {
  for (int i = 0; i < 4; ++i) {
    BLOB_CHOICE_IT choice_it;
    choice_it.set_to_list(scores + i);

    if (!choice_it.empty()) {
      osr_->orientations[i] += (100 + choice_it.data()->certainty());
    }
  }

  float first = -1;
  float second = -1;

  for (int i = 0; i < 4; ++i) {
    if (osr_->orientations[i] > first) {
      second = first;
      first = osr_->orientations[i];
    } else if (osr_->orientations[i] > second) {
      second = osr_->orientations[i];
    }
  }

  return first / second > kOrientationAcceptRatio;
}

void OrientationDetector::update_best_orientation() {
  float first = osr_->orientations[0];
  float second = osr_->orientations[1];

  if (first < second) {
    second = first;
    first = osr_->orientations[1];
  }

  osr_->best_result.orientation = 0;
  osr_->best_result.oconfidence = 0;

  for (int i = 0; i < 4; ++i) {
    if (osr_->orientations[i] > first) {
      second = first;
      first = osr_->orientations[i];
      osr_->best_result.orientation = i;
    } else if (osr_->orientations[i] > second) {
      second = osr_->orientations[i];
    }
  }

  osr_->best_result.oconfidence =
      (first / second - 1.0) / (kOrientationAcceptRatio - 1.0);
}

int OrientationDetector::get_orientation() {
  update_best_orientation();
  return osr_->best_result.orientation;
}


ScriptDetector::ScriptDetector(OSResults* osr, Tesseract* tess) {
  osr_ = osr;
  tess_ = tess;
  katakana_id_ = tess_->unicharset.add_script(katakana_script);
  hiragana_id_ = tess_->unicharset.add_script(hiragana_script);
  han_id_ = tess_->unicharset.add_script(han_script);
  hangul_id_ = tess_->unicharset.add_script(hangul_script);
  japanese_id_ = tess_->unicharset.add_script(japanese_script_);
  korean_id_ = tess_->unicharset.add_script(korean_script_);
  latin_id_ = tess_->unicharset.add_script(latin_script);
  fraktur_id_ = tess_->unicharset.add_script(fraktur_script_);
}


// Score the given blob and return true if it is now sure of the script after
// adding this blob.
void ScriptDetector::detect_blob(BLOB_CHOICE_LIST* scores) {
  bool done[kMaxNumberOfScripts];
  for (int i = 0; i < 4; ++i) {
    for (int j = 0; j < kMaxNumberOfScripts; ++j)
      done[j] = false;

    BLOB_CHOICE_IT choice_it;
    choice_it.set_to_list(scores + i);

    float prev_score = -1;
    int script_count = 0;
    int prev_id = -1;
    int prev_class_id = -1;
    int prev_config = -1;
    const char* prev_unichar = "";
    const char* unichar = "";

    for (choice_it.mark_cycle_pt(); !choice_it.cycled_list();
         choice_it.forward()) {
      BLOB_CHOICE* choice = choice_it.data();
      int id = choice->script_id();
      // Script already processed before.
      if (done[id]) continue;
      done[id] = true;

      unichar = tess_->unicharset.id_to_unichar(choice->unichar_id());
      // Save data from the first match
      if (prev_score < 0) {
        prev_score = -choice->certainty();
        script_count = 1;
        prev_id = id;
        prev_unichar = unichar;
        prev_class_id = choice->unichar_id();
        prev_config = choice->config();
      } else if (-choice->certainty() < prev_score + kNonAmbiguousMargin) {
        script_count++;
      }

      if (strlen(prev_unichar) == 1)
        if (unichar[0] >= '0' && unichar[0] <= '9')
          break;

      // if script_count is >= 2, character is ambiguous, skip other matches
      // since they are useless.
      if (script_count >= 2)
        break;
    }
    // Character is non ambiguous
    if (script_count == 1) {
      // Update the score of the winning script
      osr_->scripts_na[i][prev_id] += 1;

      // Workaround for Fraktur
      if (prev_id == latin_id_) {
        int font_set_id = tess_->PreTrainedTemplates->
            Class[prev_class_id]->font_set_id;
        if (font_set_id >= 0 && prev_config >= 0) {
          FontInfo fi = tess_->get_fontinfo_table().get(
              tess_->get_fontset_table().get(font_set_id).configs[prev_config]);
          //printf("Font: %s i:%i b:%i f:%i s:%i k:%i (%s)\n", fi.name,
          //       fi.is_italic(), fi.is_bold(), fi.is_fixed_pitch(),
          //       fi.is_serif(), fi.is_fraktur(),
          //       prev_unichar);
          if (fi.is_fraktur()) {
            osr_->scripts_na[i][prev_id] -= 1;
            osr_->scripts_na[i][fraktur_id_] += 1;
          }
        }
      }

      // Update Japanese / Korean pseudo-scripts
      if (prev_id == katakana_id_)
        osr_->scripts_na[i][japanese_id_] += 1;
      if (prev_id == hiragana_id_)
        osr_->scripts_na[i][japanese_id_] += 1;
      if (prev_id == hangul_id_)
        osr_->scripts_na[i][korean_id_] += 1;
      if (prev_id == han_id_)
        osr_->scripts_na[i][korean_id_] += kHanRatioInKorean;
      if (prev_id == han_id_)
        osr_->scripts_na[i][japanese_id_] += kHanRatioInJapanese;
    }
  }  // iterate over each orientation
}

bool ScriptDetector::must_stop(int orientation) {
  update_best_script(orientation);
  return osr_->best_result.sconfidence > 1;
}


void ScriptDetector::update_best_script(int orientation) {
  float first = -1;
  float second = -1;

  // i = 1 -> ignore Common scripts
  for (int i = 1; i < kMaxNumberOfScripts; ++i) {
    if (osr_->scripts_na[orientation][i] > first) {
      osr_->best_result.script =
          tess_->unicharset.get_script_from_script_id(i);
      second = first;
      first = osr_->scripts_na[orientation][i];
    } else if (osr_->scripts_na[orientation][i] > second) {
      second = osr_->scripts_na[orientation][i];
    }
  }

  osr_->best_result.sconfidence =
      (first / second - 1.0) / (kOrientationAcceptRatio - 1.0);
}
/////////////////////////////////////////////////////////////////osdetect////////////////////////////////////////

/////////////////////////////////////////////////////////////////basedir////////////////////////////////////////
/**********************************************************************
 * getpath
 *
 * Find the directory of the given executable using the usual path rules.
 * This enables data to be located relative to the code.
 **********************************************************************/

//get dir name of code  //executable to locate  //output path name
inT8 getpath(const char *code,           STRING &path)
{
    char directory[MAX_PATH];      //main directory
    #ifdef __UNIX__
    inT16 dirind;                  //index in directory
    register char *pathlist;       //$PATH
    int fd;                        //file descriptor

    strcpy(directory, code);  //get demo directory
    dirind = strlen (directory);
    while (dirind > 0 && directory[dirind - 1] != '/') dirind--; //look back for dirname

    directory[dirind] = '\0';      //end at directory
    if (dirind != 0)
    {
        path = directory;            //had it in arg
        return 0;
    }

    pathlist = getenv ("PATH");    //find search path
    while (pathlist != NULL && *pathlist)
    {
        //copy a directory
        for (dirind = 0; *pathlist != '\0' && *pathlist != ':';)
        {
            directory[dirind++] = *pathlist++;
        }

        if (*pathlist == ':') pathlist++;

        if (dirind == 0) continue;
//        if (directory[dirind - 1] != '/');

        directory[dirind++] = '/';   //add ending slash
        directory[dirind++] = '\0';
        path = directory;            //try this path
        strcat(directory, code);
        fd = open (directory, 0);

        if (fd >= 0)
        {
            close(fd);  //found it
            return 0;
        }
    }

    strcpy (directory, "./");
    path = directory;              //in current?
    strcat(directory, code);
    fd = open (directory, 0);
    if (fd >= 0)
    {
        close(fd);
        return 0;                    //in current after all
    }
    return -1;
    #endif
    #ifdef __MSW32__
    char *path_end;                //end of dir

    if (code == NULL)
    {
        // Attempt to get the path of the most relevant module. If the dll
        // is being used, this will be the dll. Otherwise GetModuleHandle will
        // return NULL and default to the path of the executable.
        if (GetModuleFileName(GetModuleHandle(tessedit_module_name.string()), directory, MAX_PATH - 1) == 0)
        {
            return -1;
        }
    }
    else
    {
        strncpy(directory, code, MAX_PATH - 1);
    }

    while ((path_end = strchr (directory, '\\')) != NULL) *path_end = '/';
    path_end = strrchr (directory, '/');

    if (path_end != NULL)
    {
        path_end[1] = '\0';
    }
    else
    {
        strcpy (directory, "./");
    }

    path = directory;
    return 0;
    #endif
}
/////////////////////////////////////////////////////////////////basedir////////////////////////////////////////

/////////////////////////////////////////////////////////////////mainblk////////////////////////////////////
#define VARDIR        "configs/" /*variables files */
#define EXTERN

/*
EXTERN DLLSYM STRING datadir;    //dir for data files
                                 //name of image
EXTERN DLLSYM STRING imagebasename;
EXTERN BOOL_VAR (m_print_variables, FALSE,
"Print initial values of all variables");
EXTERN STRING_VAR (m_data_sub_dir, "tessdata/", "Directory for data files");
EXTERN INT_VAR (memgrab_size, 0, "Preallocation size for batch use");*/


const ERRCODE NO_PATH = "Warning:explicit path for executable will not be used for configs";
static const ERRCODE USAGE = "Usage";
/**********************************************************************
 * main_setup
 *
 * Main for mithras demo program. Read the arguments and set up globals.
 **********************************************************************/

void CCUtil::main_setup(                 /*main demo program */
                                         const char *argv0,       //program name
                                         const char *basename     //name of image
                                         )
{
    imagebasename = basename;      /*name of image */

    // TESSDATA_PREFIX Environment variable overrules everything.
    // Compiled in -DTESSDATA_PREFIX is next.
    // NULL goes to current directory.
    // An actual value of argv0 is used if getpath is successful.
    if (!getenv("TESSDATA_PREFIX"))
    {
#ifdef TESSDATA_PREFIX
#define _STR(a) #a
#define _XSTR(a) _STR(a)
        datadir = _XSTR(TESSDATA_PREFIX);
#undef _XSTR
#undef _STR
#else
        if (argv0 != NULL)
        {
            if (getpath(argv0, datadir) < 0)
#ifdef __UNIX__
                CANTOPENFILE.error("main", ABORT, "%s to get path", argv0);
#else
                NO_PATH.error("main", DBG, NULL);
#endif
        }
        else
        {
            datadir = "./";
        }
#endif
    } else
    {
        datadir = getenv("TESSDATA_PREFIX");
    }

    datadir += m_data_sub_dir;     /*data directory */
}
/////////////////////////////////////////////////////////////////mainblk////////////////////////////////////

/////////////////////////////////////////////////////////////////tessedit////////////////////////////////////
#define VARDIR        "configs/" /*variables files */
//config under api
#define API_CONFIG      "configs/api_config"
#define EXTERN

EXTERN BOOL_EVAR (tessedit_write_vars, FALSE, "Write all vars to file");

ETEXT_DESC *global_monitor1 = NULL;  // progress monitor
// Read a "config" file containing a set of variable, value pairs.
// Searches the standard places: tessdata/configs, tessdata/tessconfigs
// and also accepts a relative or absolute path name.
void Tesseract::read_config_file(const char *filename, bool global_only)
{
    STRING path = datadir;
    path += "configs/";
    path += filename;
    FILE* fp;

    if ((fp = fopen(path.string(), "r")) != NULL)
    {
        fclose(fp);
    }
    else
    {
        path = datadir;
        path += "tessconfigs/";
        path += filename;

        if ((fp = fopen(path.string(), "r")) != NULL)
        {
            fclose(fp);
        }
        else
        {
            path = filename;
        }
    }

    read_variables_file(path.string(), global_only);
}

// Returns false if a unicharset file for the specified language was not found
// or was invalid.
// This function initializes TessdataManager. After TessdataManager is
// no longer needed, TessdataManager::End() should be called.
bool Tesseract::init_tesseract_lang_data( const char *arg0, const char *textbase,
                                          const char *language, char **configs,
                                          int configs_size, bool configs_global_only)
{
    FILE *var_file;
    static char c_path[MAX_PATH];  //path for c code

    // Set the basename, compute the data directory.
    main_setup(arg0, textbase);
    debug_window_on.set_value (FALSE);

    if (tessedit_write_vars)
    {
        var_file = fopen ("edited.cfg", "w");

        if (var_file != NULL)
        {
            print_variables(var_file);
            fclose(var_file);
        }
    }

    strcpy(c_path, datadir.string());
    c_path[strlen(c_path) - strlen(m_data_sub_dir.string ())] = '\0';
    demodir = c_path;

    // Set the language data path prefix
    lang = language != NULL ? language : "eng";
    language_data_path_prefix = datadir;
    language_data_path_prefix += lang;
    language_data_path_prefix += ".";

    // Load tesseract variables from config files.
    for (int i = 0; i < configs_size; ++i)
    {
        read_config_file(configs[i], configs_global_only);
    }

    // Initialize TessdataManager.
    STRING tessdata_path = language_data_path_prefix + kTrainedDataSuffix;
    tessdata_manager.Init(tessdata_path.string());

    // If a language specific config file (lang.config) exists, load it in.
    if (tessdata_manager.SeekToStart(TESSDATA_LANG_CONFIG))
    {
        read_variables_from_fp(tessdata_manager.GetDataFilePtr(), tessdata_manager.GetEndOffset(TESSDATA_LANG_CONFIG), false);
        if (global_tessdata_manager_debug_level)
        {
            tprintf("Loaded language config file\n");
        }
    }

    // Load the unicharset
    if (!tessdata_manager.SeekToStart(TESSDATA_UNICHARSET) || !unicharset.load_from_file(tessdata_manager.GetDataFilePtr()))
    {
        return false;
    }

    if (unicharset.size() > MAX_NUM_CLASSES)
    {
        tprintf("Error: Size of unicharset is greater than MAX_NUM_CLASSES\n");
        return false;
    }

    if (global_tessdata_manager_debug_level) tprintf("Loaded unicharset\n");

    if (!global_tessedit_ambigs_training && tessdata_manager.SeekToStart(TESSDATA_AMBIGS))
    {
        unichar_ambigs.LoadUnicharAmbigs(tessdata_manager.GetDataFilePtr(), tessdata_manager.GetEndOffset(TESSDATA_AMBIGS), &unicharset);

        if (global_tessdata_manager_debug_level)
        {
            tprintf("Loaded ambigs\n");
        }
    }

    return true;
}

int Tesseract::init_tesseract(const char *arg0, const char *textbase, const char *language, char **configs, int configs_size, bool configs_global_only)
{
    if (!init_tesseract_lang_data(arg0, textbase, language, configs, configs_size, configs_global_only))
    {
        return -1;
    }

    start_recog(textbase);
    tessdata_manager.End();

    return 0;                      //Normal exit
}

// Init everything except the language model
int Tesseract::init_tesseract_classifier(const char *arg0, const char *textbase, const char *language,
                                         char **configs, int configs_size, bool configs_global_only)
{
    if (!init_tesseract_lang_data (arg0, textbase, language, configs, configs_size, configs_global_only))
    {
        return -1;
    }

    // Dont initialize the permuter.
    program_editup(textbase, false);
    tessdata_manager.End();

    return 0;
}

// init the LM component
int Tesseract::init_tesseract_lm(const char *arg0, const char *textbase, const char *language)
{
    init_tesseract_lang_data(arg0, textbase, language, NULL, 0, false);
    getDict().init_permute();
    tessdata_manager.End();

    return 0;
}

void Tesseract::end_tesseract()
{
    end_recog();
}

/* Define command type identifiers */

enum CMD_EVENTS1
{
    ACTION_1_CMD_EVENT,
    RECOG_WERDS1,
    RECOG_PSEUDO1,
    ACTION_2_CMD_EVENT
};

#ifdef _TIFFIO_
void read_tiff_image(TIFF* tif, IMAGE* image)
{
    tdata_t buf;
    uint32 image_width, image_height;
    uint16 photometric;
    inT16 bpp;
    inT16 samples_per_pixel = 0;
    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &image_width);
    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &image_height);

    if (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp)) bpp = 1;  // Binary is default if no value provided.

    TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel);
    TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric);

    if (samples_per_pixel > 1) bpp *= samples_per_pixel;

    // Tesseract's internal representation is 0-is-black,
    // so if the photometric is 1 (min is black) then high-valued pixels
    // are 1 (white), otherwise they are 0 (black).
    uinT8 high_value = photometric == 1;
    image->create(image_width, image_height, bpp);
    IMAGELINE line;
    line.init(image_width);

    buf = _TIFFmalloc(TIFFScanlineSize(tif));
    int bytes_per_line = (image_width*bpp + 7)/8;
    uinT8* dest_buf = image->get_buffer();

    // This will go badly wrong with one of the more exotic tiff formats,
    // but the majority will work OK.
    for (int y = 0; y < image_height; ++y)
    {
        TIFFReadScanline(tif, buf, y);
        memcpy(dest_buf, buf, bytes_per_line);
        dest_buf += bytes_per_line;
    }

    if (high_value == 0) invert_image(image);

    _TIFFfree(buf);
}
#endif
/////////////////////////////////////////////////////////////////tessedit////////////////////////////////////

/////////////////////////////////////////////////////////////////ambigsrecog////////////////////////////////////
// Sets flags necessary for ambigs training mode.
// Opens and returns the pointer to the output file.
FILE *Tesseract::init_ambigs_training(const STRING &fname) {
  permute_only_top = 1;                        // use only top choice permuter
  tessedit_tess_adaption_mode.set_value(0);    // turn off adaption
  tessedit_ok_mode.set_value(0);               // turn off context checking
  tessedit_enable_doc_dict.set_value(0);       // turn off document dictionary
  save_best_choices.set_value(1);              // save individual char choices
  stopper_no_acceptable_choices.set_value(1);  // explore all segmentations
  save_raw_choices.set_value(1);               // save raw choices

  // Open ambigs output file.
  STRING output_fname = fname;
  const char *lastdot = strrchr(output_fname.string(), '.');
  if (lastdot != NULL) {
    output_fname[lastdot - output_fname.string()] = '\0';
  }
  output_fname += ".txt";
  FILE *output_file;
  if (!(output_file = fopen(output_fname.string(), "a+"))) {
    CANTOPENFILE.error("ambigs_training", EXIT,
                       "Can't open box file %s\n", output_fname.string());
  }
  return output_file;
}

// This function takes tif/box pair of files and runs recognition on the image,
// while making sure that the word bounds that tesseract identified roughly
// match to those specified by the input box file. For each word (ngram in a
// single bounding box from the input box file) it outputs the ocred result,
// the correct label, rating and certainty.
void Tesseract::ambigs_training_segmented(const STRING &fname,
                                          PAGE_RES *page_res,
                                          volatile ETEXT_DESC *monitor,
                                          FILE *output_file)
{
    Q_UNUSED(monitor);
  STRING box_fname = fname;
  const char *lastdot = strrchr(box_fname.string(), '.');
  if (lastdot != NULL) {
    box_fname[lastdot - box_fname.string()] = '\0';
  }
  box_fname += ".box";
  FILE *box_file;
  if (!(box_file = fopen(box_fname.string(), "r"))) {
    CANTOPENFILE.error("ambigs_training", EXIT,
                       "Can't open box file %s\n", box_fname.string());
  }

  static PAGE_RES_IT page_res_it;
  page_res_it.page_res = page_res;
  page_res_it.restart_page();
  int x_min, y_min, x_max, y_max;
  char label[UNICHAR_LEN * 10];

  // Process all the words on this page.
  while (page_res_it.word() != NULL &&
         read_next_box(applybox_page, box_file, label,
                       &x_min, &y_min, &x_max, &y_max)) {
    // Init bounding box of the current word bounding box and from box file.
    TBOX box = TBOX(ICOORD(x_min, y_min), ICOORD(x_max, y_max));
    TBOX word_box(page_res_it.word()->word->bounding_box());
    bool one_word = true;
    // Check whether the bounding box of the next word overlaps with the
    // current box from box file.
    while (page_res_it.next_word() != NULL &&
           box.x_overlap(page_res_it.next_word()->word->bounding_box())) {
      word_box = word_box.bounding_union(
          page_res_it.next_word()->word->bounding_box());
      page_res_it.forward();
      one_word = false;
    }
    if (!word_box.major_overlap(box)) {
      if (!word_box.x_overlap(box)) {
        // We must be looking at the word that belongs in the "next" bounding
        // box from the box file. The ngram that was supposed to appear in
        // the current box read from the box file must have been dropped by
        // tesseract as noise.
        tprintf("Word %s was dropped as noise.\n", label);
        continue;  // stay on this blob, but read next box from box file
      } else {
        tprintf("Error: Insufficient overlap for word box"
                " and box from file for %s\n", label);
        word_box.print();
        box.print();
        exit(1);
      }
    }
    // Skip recognizing the ngram if tesseract is sure it's not
    // one word, otherwise run one recognition pass on this word.
    if (!one_word) {
      tprintf("Tesseract segmented %s as multiple words\n", label);
    } else {
      ambigs_classify_and_output(&page_res_it, label, output_file);
    }
    page_res_it.forward();
  }
  fclose(box_file);
}

// Run classify_word_pass1() on the current word. Output tesseract's raw choice
// as a result of the classification. For words labeled with a single unichar
// also output all alternatives from blob_choices of the best choice.
void Tesseract::ambigs_classify_and_output(PAGE_RES_IT *page_res_it,
                                           const char *label,
                                           FILE *output_file) {
  int offset;
  // Classify word.
  classify_word_pass1(page_res_it->word(), page_res_it->row()->row,
                      page_res_it->block()->block,
                      FALSE, NULL, NULL);
  WERD_CHOICE *best_choice = page_res_it->word()->best_choice;
  ASSERT_HOST(best_choice != NULL);
  ASSERT_HOST(best_choice->blob_choices() != NULL);

  // Compute the number of unichars in the label.
  int label_num_unichars = 0;
  int step = 1;  // should be non-zero on the first iteration
  for (offset = 0; label[offset] != '\0' && step > 0;
       step = getDict().getUnicharset().step(label + offset),
       offset += step, ++label_num_unichars);
  if (step == 0) {
    tprintf("Not outputting illegal unichar %s\n", label);
    return;
  }

  // Output all classifier choices for the unigrams (1-1 classifications).
  if (label_num_unichars == 1 && best_choice->blob_choices()->length() == 1) {
    BLOB_CHOICE_LIST_C_IT outer_blob_choice_it;
    outer_blob_choice_it.set_to_list(best_choice->blob_choices());
    BLOB_CHOICE_IT blob_choice_it;
    blob_choice_it.set_to_list(outer_blob_choice_it.data());
    for (blob_choice_it.mark_cycle_pt();
         !blob_choice_it.cycled_list();
         blob_choice_it.forward()) {
      BLOB_CHOICE *blob_choice = blob_choice_it.data();
      if (blob_choice->unichar_id() != INVALID_UNICHAR_ID) {
        fprintf(output_file, "%s\t%s\t%.4f\t%.4f\n",
               unicharset.id_to_unichar(blob_choice->unichar_id()),
               label, blob_choice->rating(), blob_choice->certainty());
      }
    }
  }
  // Output the raw choice for succesful non 1-1 classifications.
  getDict().PrintAmbigAlternatives(output_file, label, label_num_unichars);
}
/////////////////////////////////////////////////////////////////ambigsrecog////////////////////////////////////
int DictT::valid_word(const char *string) {
  WERD_CHOICE word(string, getUnicharset());
  return valid_word(word);
}

void DictT::LogNewWordChoice(A_CHOICE *a_choice,
                            FLOAT32 adjust_factor,
                            const float certainties[],
                            const UNICHARSET &unicharset) {
  WERD_CHOICE word_choice(strlen(a_choice->lengths));
  convert_to_word_choice(a_choice, unicharset, &word_choice);
  LogNewChoice(word_choice, adjust_factor, certainties, false);
}

// Fills in the given WERD_CHOICE with information from the given A_CHOICE.
// Assumes that word_choice pointer is not NULL.
void convert_to_word_choice(const A_CHOICE *a_choice,
                            const UNICHARSET &current_unicharset,
                            WERD_CHOICE *word_choice) {
  if (a_choice == NULL) return;
  const char *string = a_choice->string;
  const char *lengths = a_choice->lengths;
  const char *fragment_lengths = a_choice->fragment_lengths;
  int offset = 0;
  for (int x = 0; x < (int)strlen(a_choice->lengths); ++x) {
    UNICHAR_ID unichar_id =
      current_unicharset.unichar_to_id(string + offset, lengths[x]);
    word_choice->append_unichar_id(unichar_id, fragment_lengths[x], 0.0, 0.0);
    offset += lengths[x];
  }
  word_choice->set_rating(a_choice->rating);
  word_choice->set_certainty(a_choice->certainty);
  word_choice->set_permuter(a_choice->permuter);
  word_choice->set_fragment_mark(a_choice->fragment_mark);
}

// Returns the best of two choices and deletes the other (worse) choice.
// A choice is better if it has a non-empty string and has a lower
// rating than the other choice. If the ratings are the same,
// a_choice is preferred over choice.
// If the best choice is in the A_CHOICE form, copies it to a new
// WERD_CHOICE and deletes A_CHOICE.
WERD_CHOICE *get_best_delete_other(const UNICHARSET &current_unicharset,
                                   WERD_CHOICE *choice,
                                   A_CHOICE *a_choice) {
  if (!a_choice) return choice;
  if (choice != NULL &&
      (choice->rating() < a_choice->rating || a_choice->string == NULL)) {
    free_choice(a_choice);
    return choice;
  } else {
    delete choice;
    WERD_CHOICE *word_choice = new WERD_CHOICE();
    convert_to_word_choice(a_choice, current_unicharset, word_choice);
    free_choice(a_choice);
    return word_choice;
  }
}

// Convert BLOB_CHOICE_LIST_VECTOR to CHOICES_LIST.
// The caller is responsible for deleting the returned CHOICES_LIST.
CHOICES_LIST convert_to_choices_list(
    const BLOB_CHOICE_LIST_VECTOR &char_choices,
    const UNICHARSET &current_unicharset) {
  CHOICES_LIST old_char_choices = new_choice_list();
  int x;
  BLOB_CHOICE_IT it;
  BLOB_CHOICE *blob_choice;
  char choice_lengths[2] = {0, 0};
  char unichar[UNICHAR_LEN + 1];
  for (x = 0; x < char_choices.length(); ++x) {
    it.set_to_list(char_choices.get(x));
    LIST result = NIL;
    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
      blob_choice = it.data();
      strcpy(unichar,
             current_unicharset.id_to_unichar(blob_choice->unichar_id()));
      choice_lengths[0] = strlen(unichar);
      result = append_char_choice(result, unichar, choice_lengths,
                                  blob_choice->rating(),
                                  blob_choice->certainty(),
                                  blob_choice->config(), 0);
    }
    old_char_choices = array_push(old_char_choices, result);
  }
  return old_char_choices;
}
/////////////////////////////////////////////////////////////////conversion////////////////////////////////////////

/////////////////////////////////////////////////////////////////pagesegmain////////////////////////////////////
/// Minimum believable resolution.
const int kMinCredibleResolution = 70;
/// Default resolution used if input in not believable.
const int kDefaultResolution = 300;

/**
 * Segment the page according to the current value of tessedit_pageseg_mode.
 * If the pix_binary_ member is not NULL, it is used as the source image,
 * and copied to image, otherwise it just uses image as the input.
 * On return the blocks list owns all the constructed page layout.
 */
int Tesseract::SegmentPage(const STRING* input_file, IMAGE* image, BLOCK_LIST* blocks)
{
    int width = image->get_xsize();
    int height = image->get_ysize();
    int resolution = image->get_res();
    #ifdef HAVE_LIBLEPT
    if (pix_binary_ != NULL)
    {
        width = pixGetWidth(pix_binary_);
        height = pixGetHeight(pix_binary_);
        resolution = pixGetXRes(pix_binary_);
    }
    #endif

    // Zero resolution messes up the albbb2.bmpgorithms, so make sure it is credible.
    if (resolution < kMinCredibleResolution) resolution = kDefaultResolution;

    // Get page segmentation mode.
    PageSegMode pageseg_mode = static_cast<PageSegMode>(static_cast<int>(tessedit_pageseg_mode));

    // If a UNLV zone file can be found, use that instead of segmentation.
    if (pageseg_mode != PSM_AUTO && input_file != NULL && input_file->length() > 0)
    {
        STRING name = *input_file;
        const char* lastdot = strrchr(name.string(), '.');

        if (lastdot != NULL) name[lastdot - name.string()] = '\0';
        read_unlv_file(name, width, height, blocks);
    }

    bool single_column = pageseg_mode > PSM_AUTO;
    if (blocks->empty())
    {
        // No UNLV file present. Work according to the PageSegMode.
        // First make a single block covering the whole image.
        BLOCK_IT block_it(blocks);
        BLOCK* block = new BLOCK("", TRUE, 0, 0, 0, 0, width, height);
        block_it.add_to_end(block);
    }
    else
    {
        // UNLV file present. Use PSM_SINGLE_COLUMN.
        pageseg_mode = PSM_SINGLE_COLUMN;
    }

    TO_BLOCK_LIST land_blocks, port_blocks;
    TBOX page_box;
    if (pageseg_mode <= PSM_SINGLE_COLUMN)
    {
        if (AutoPageSeg(width, height, resolution, single_column, image, blocks, &port_blocks) < 0)
        {
            return -1;
        }

        // To create blobs from the image region bounds uncomment this line:
        //  port_blocks.clear();  // Uncomment to go back to the old mode.
    }
    else
    {
        #if HAVE_LIBLEPT
        image->FromPix(pix_binary_);
        #endif
        deskew_ = FCOORD(1.0f, 0.0f);
        reskew_ = FCOORD(1.0f, 0.0f);
    }

    if (blocks->empty())
    {
        tprintf("Empty page\n");
        return 0;  // AutoPageSeg found an empty page.
    }

    if (port_blocks.empty())
    {
        // AutoPageSeg was not used, so we need to find_components first.
        find_components(blocks, &land_blocks, &port_blocks, &page_box);
    }
    else
    {
        // AutoPageSeg does not need to find_components as it did that already.
        page_box.set_left(0);
        page_box.set_bottom(0);
        page_box.set_right(width);
        page_box.set_top(height);

        // Filter_blobs sets up the TO_BLOCKs the same as find_components does.
        filter_blobs(page_box.topright(), &port_blocks, true);
    }

    TO_BLOCK_IT to_block_it(&port_blocks);
    ASSERT_HOST(!port_blocks.empty());
    TO_BLOCK* to_block = to_block_it.data();

    if (pageseg_mode <= PSM_SINGLE_BLOCK || to_block->line_size < 2)
    {
        // For now, AUTO, SINGLE_COLUMN and SINGLE_BLOCK all map to the old
        // textord. The difference is the number of blocks and how the are made.
        textord_page(page_box.topright(), blocks, &land_blocks, &port_blocks, this);
    }
    else
    {
        // SINGLE_LINE, SINGLE_WORD and SINGLE_CHAR all need a single row.
        float gradient = make_single_row(page_box.topright(), to_block, &port_blocks, this);

        if (pageseg_mode == PSM_SINGLE_LINE)
        {
            // SINGLE_LINE uses the old word maker on the single line.
            make_words(page_box.topright(), gradient, blocks, &land_blocks, &port_blocks, this);
        }
        else
        {
            // SINGLE_WORD and SINGLE_CHAR cram all the blobs into a
            // single word, and in SINGLE_CHAR mode, all the outlines
            // go in a single blob.
            make_single_word(pageseg_mode == PSM_SINGLE_CHAR, to_block->get_rows(), to_block->block->row_list());
        }
    }

    return 0;
}

/**
 * Auto page segmentation. Divide the page image into blocks of uniform
 * text linespacing and images.
 *
 * Width, height and resolution are derived from the input image.
 *
 * If the pix is non-NULL, then it is assumed to be the input, and it is
 * copied to the image, otherwise the image is used directly.
 *
 * The output goes in the blocks list with corresponding TO_BLOCKs in the
 * to_blocks list.
 *
 * If single_column is true, then no attempt is made to divide the image
 * into columns, but multiple blocks are still made if the text is of
 * non-uniform linespacing.
 */
int Tesseract::AutoPageSeg(int width, int height, int resolution, bool single_column, IMAGE* image, BLOCK_LIST* blocks, TO_BLOCK_LIST* to_blocks)
{
    Q_UNUSED(width);
    Q_UNUSED(image);
    int vertical_x = 0;
    int vertical_y = 1;
    TabVector_LIST v_lines;
    TabVector_LIST h_lines;
    ICOORD bleft(0, 0);
    Boxa* boxa = NULL;
    Pixa* pixa = NULL;
    // The blocks made by the ColumnFinder. Moved to blocks before return.
    BLOCK_LIST found_blocks;

#ifdef HAVE_LIBLEPT
    if (pix_binary_ != NULL)
    {
        if (textord_debug_images)
        {
            Pix* grey_pix = pixCreate(width, height, 8);

            // Printable images are light grey on white, but for screen display
            // they are black on dark grey so the other colors show up well.
            if (textord_debug_printable)
            {
                pixSetAll(grey_pix);
                pixSetMasked(grey_pix, pix_binary_, 192);
            }
            else
            {
                pixSetAllArbitrary(grey_pix, 64);
                pixSetMasked(grey_pix, pix_binary_, 0);
            }

            AlignedBlob::IncrementDebugPix();
            pixWrite(AlignedBlob::textord_debug_pix().string(), grey_pix, IFF_PNG);
            pixDestroy(&grey_pix);
        }

        if (tessedit_dump_pageseg_images) pixWrite("tessinput.png", pix_binary_, IFF_PNG);

        // Leptonica is used to find the lines and image regions in the input.
        LineFinder::FindVerticalLines(resolution, pix_binary_, &vertical_x, &vertical_y, &v_lines);
        LineFinder::FindHorizontalLines(resolution, pix_binary_, &h_lines);

        if (tessedit_dump_pageseg_images) pixWrite("tessnolines.png", pix_binary_, IFF_PNG);
        ImageFinder::FindImages(pix_binary_, &boxa, &pixa);

        if (tessedit_dump_pageseg_images) pixWrite("tessnoimages.png", pix_binary_, IFF_PNG);

        // Copy the Pix to the IMAGE.
        image->FromPix(pix_binary_);
        if (single_column) v_lines.clear();
    }
#endif
    TO_BLOCK_LIST land_blocks, port_blocks;
    TBOX page_box;
    // The rest of the algorithm uses the usual connected components.
    find_components(blocks, &land_blocks, &port_blocks, &page_box);

    TO_BLOCK_IT to_block_it(&port_blocks);
    ASSERT_HOST(!to_block_it.empty());
    for (to_block_it.mark_cycle_pt(); !to_block_it.cycled_list(); to_block_it.forward())
    {
        TO_BLOCK* to_block = to_block_it.data();
        TBOX blkbox = to_block->block->bounding_box();

        if (to_block->line_size >= 2)
        {
            // Note: if there are multiple blocks, then v_lines, boxa, and pixa
            // are empty on the next iteration, but in this case, we assume
            // that there aren't any interesting line separators or images, since
            // it means that we have a pre-defined unlv zone file.
            ColumnFinder finder(static_cast<int>(to_block->line_size), blkbox.botleft(), blkbox.topright(), &v_lines, &h_lines, vertical_x, vertical_y);
            if (finder.FindBlocks(height, resolution, single_column, to_block, boxa, pixa, &found_blocks, to_blocks) < 0) return -1;

            finder.ComputeDeskewVectors(&deskew_, &reskew_);
            boxa = NULL;
            pixa = NULL;
        }
    }
#ifdef HAVE_LIBLEPT
    boxaDestroy(&boxa);
    pixaDestroy(&pixa);
#endif
    blocks->clear();
    BLOCK_IT block_it(blocks);
    // Move the found blocks to the input/output blocks.
    block_it.add_list_after(&found_blocks);

    if (textord_debug_images)
    {
        // The debug image is no longer needed so delete it.
        unlink(AlignedBlob::textord_debug_pix().string());
    }

    return 0;
}
/////////////////////////////////////////////////////////////////pagesegmain////////////////////////////////////

/////////////////////////////////////////////////////////////////tabvector////////////////////////////////////////
// Multiple of height used as a gutter for evaluation search.
const int kGutterMultiple = 4;
// Multiple of neighbour gap that we expect the gutter gap to be at minimum.
const int kGutterToNeighbourRatio = 3;
// Pixel distance for tab vectors to be considered the same.
const int kSimilarVectorDist = 10;
// Pixel distance for ragged tab vectors to be considered the same if there
// is nothing in the overlap box
const int kSimilarRaggedDist = 50;
// Max multiple of height to allow filling in between blobs when evaluating.
const int kMaxFillinMultiple = 11;
// Min fraction of mean gutter size to allow a gutter on a good tab blob.
const double kMinGutterFraction = 0.5;
// Max fraction of mean blob width allowed for vertical gaps in vertical text.
const double kVerticalTextGapFraction = 0.5;

ELISTIZE(TabConstraint)

// Create a constraint for the top or bottom of this TabVector.
void TabConstraint::CreateConstraint(TabVector* vector, bool is_top) {
  TabConstraint* constraint = new TabConstraint(vector, is_top);
  TabConstraint_LIST* constraints = new TabConstraint_LIST;
  TabConstraint_IT it(constraints);
  it.add_to_end(constraint);
  if (is_top)
    vector->set_top_constraints(constraints);
  else
    vector->set_bottom_constraints(constraints);
}

// Test to see if the constraints are compatible enough to merge.
bool TabConstraint::CompatibleConstraints(TabConstraint_LIST* list1,
                                          TabConstraint_LIST* list2) {
  if (list1 == list2)
    return false;
  int y_min = -MAX_INT32;
  int y_max = MAX_INT32;
  if (textord_debug_tabfind > 3)
    tprintf("Testing constraint compatibility\n");
  GetConstraints(list1, &y_min, &y_max);
  GetConstraints(list2, &y_min, &y_max);
  if (textord_debug_tabfind > 3)
    tprintf("Resulting range = [%d,%d]\n", y_min, y_max);
  return y_max >= y_min;
}

// Merge the lists of constraints and update the TabVector pointers.
// The second list is deleted.
void TabConstraint::MergeConstraints(TabConstraint_LIST* list1,
                                     TabConstraint_LIST* list2) {
  if (list1 == list2)
    return;
  TabConstraint_IT it(list2);
  if (textord_debug_tabfind > 3)
    tprintf("Merging constraints\n");
  // The vectors of all constraints on list2 are now going to be on list1.
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    TabConstraint* constraint = it.data();
    if (textord_debug_tabfind> 3)
      constraint->vector_->Print("Merge");
    if (constraint->is_top_)
      constraint->vector_->set_top_constraints(list1);
    else
      constraint->vector_->set_bottom_constraints(list1);
  }
  it = list1;
  it.add_list_before(list2);
  delete list2;
}

// Set all the tops and bottoms as appropriate to a mean of the
// constrained range. Delete all the constraints and list.
void TabConstraint::ApplyConstraints(TabConstraint_LIST* constraints) {
  int y_min = -MAX_INT32;
  int y_max = MAX_INT32;
  GetConstraints(constraints, &y_min, &y_max);
  int y = (y_min + y_max) / 2;
  TabConstraint_IT it(constraints);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    TabConstraint* constraint = it.data();
    TabVector* v = constraint->vector_;
    if (constraint->is_top_) {
      v->SetYEnd(y);
      v->set_top_constraints(NULL);
    } else {
      v->SetYStart(y);
      v->set_bottom_constraints(NULL);
    }
  }
  delete constraints;
}

TabConstraint::TabConstraint(TabVector* vector, bool is_top)
  : vector_(vector), is_top_(is_top) {
  if (is_top) {
    y_min_ = vector->endpt().y();
    y_max_ = vector->extended_ymax();
  } else {
    y_max_ = vector->startpt().y();
    y_min_ = vector->extended_ymin();
  }
}

// Get the max of the mins and the min of the maxes.
void TabConstraint::GetConstraints(TabConstraint_LIST* constraints,
                                   int* y_min, int* y_max) {
  TabConstraint_IT it(constraints);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    TabConstraint* constraint = it.data();
    if (textord_debug_tabfind > 3) {
      tprintf("Constraint is [%d,%d]", constraint->y_min_, constraint->y_max_);
      constraint->vector_->Print(" for");
    }
    *y_min = MAX(*y_min, constraint->y_min_);
    *y_max = MIN(*y_max, constraint->y_max_);
  }
}

ELIST2IZE(TabVector)
CLISTIZE(TabVector)

// The constructor is private. See the bottom of the file...

TabVector::~TabVector() {
}


// Public factory to build a TabVector from a list of boxes.
// The TabVector will be of the given alignment type.
// The input vertical vector is used in fitting, and the output
// vertical_x, vertical_y have the resulting line vector added to them
// if the alignment is not ragged.
// The extended_start_y and extended_end_y are the maximum possible
// extension to the line segment that can be used to align with others.
// The input CLIST of BLOBNBOX good_points is consumed and taken over.
TabVector* TabVector::FitVector(TabAlignment alignment, ICOORD vertical,
                                int  extended_start_y, int extended_end_y,
                                BLOBNBOX_CLIST* good_points,
                                int* vertical_x, int* vertical_y) {
  TabVector* vector = new TabVector(extended_start_y, extended_end_y,
                                    alignment, good_points);
  if (!vector->Fit(vertical, false)) {
    delete vector;
    return NULL;
  }
  if (!vector->IsRagged()) {
    vertical = vector->endpt_ - vector->startpt_;
    int weight = vector->BoxCount();
    *vertical_x += vertical.x() * weight;
    *vertical_y += vertical.y() * weight;
  }
  return vector;
}

// Build a ragged TabVector by copying another's direction, shifting it
// to match the given blob, and making its initial extent the height
// of the blob, but its extended bounds from the bounds of the original.
TabVector::TabVector(const TabVector& src, TabAlignment alignment,
                     const ICOORD& vertical_skew, BLOBNBOX* blob)
  : extended_ymin_(src.extended_ymin_), extended_ymax_(src.extended_ymax_),
    sort_key_(0), percent_score_(0),
    needs_refit_(true), needs_evaluation_(true), alignment_(alignment),
    top_constraints_(NULL), bottom_constraints_(NULL) {
  BLOBNBOX_C_IT it(&boxes_);
  it.add_to_end(blob);
  TBOX box = blob->bounding_box();
  if (IsLeftTab()) {
    startpt_ = box.botleft();
    endpt_ = box.topleft();
  } else {
    startpt_ = box.botright();
    endpt_ = box.topright();
  }
  sort_key_ = SortKey(vertical_skew,
                      (startpt_.x() + endpt_.x()) / 2,
                      (startpt_.y() + endpt_.y()) / 2);
  if (textord_debug_tabfind > 3)
    Print("Constructed a new tab vector:");
}

// Extend this vector to include the supplied blob if it doesn't
// already have it.
void TabVector::ExtendToBox(BLOBNBOX* new_blob) {
  TBOX new_box = new_blob->bounding_box();
  BLOBNBOX_C_IT it(&boxes_);
  if (!it.empty()) {
    BLOBNBOX* blob = it.data();
    TBOX box = blob->bounding_box();
    while (!it.at_last() && box.top() <= new_box.top()) {
      if (blob == new_blob)
        return;  // We have it already.
      it.forward();
      blob = it.data();
      box = blob->bounding_box();
    }
    if (box.top() >= new_box.top()) {
      it.add_before_stay_put(new_blob);
      needs_refit_ = true;
      return;
    }
  }
  needs_refit_ = true;
  it.add_after_stay_put(new_blob);
}

// Set the ycoord of the start and move the xcoord to match.
void TabVector::SetYStart(int start_y) {
  startpt_.set_x(XAtY(start_y));
  startpt_.set_y(start_y);
}
// Set the ycoord of the end and move the xcoord to match.
void TabVector::SetYEnd(int end_y) {
  endpt_.set_x(XAtY(end_y));
  endpt_.set_y(end_y);
}

// Rotate the ends by the given vector.
void TabVector::Rotate(const FCOORD& rotation) {
  startpt_.rotate(rotation);
  endpt_.rotate(rotation);
}

// Setup the initial constraints, being the limits of
// the vector and the extended ends.
void TabVector::SetupConstraints() {
  TabConstraint::CreateConstraint(this, false);
  TabConstraint::CreateConstraint(this, true);
}

// Setup the constraints between the partners of this TabVector.
void TabVector::SetupPartnerConstraints() {
  // With the first and last partner, we want a common bottom and top,
  // respectively, and for each change of partner, we want a common
  // top of first with bottom of next.
  TabVector_C_IT it(&partners_);
  TabVector* prev_partner = NULL;
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    TabVector* partner = it.data();
    if (partner->top_constraints_ == NULL ||
        partner->bottom_constraints_ == NULL) {
      partner->Print("Impossible: has no constraints");
      Print("This vector has it as a partner");
      continue;
    }
    if (prev_partner == NULL) {
      // This is the first partner, so common bottom.
      if (TabConstraint::CompatibleConstraints(bottom_constraints_,
                                               partner->bottom_constraints_))
        TabConstraint::MergeConstraints(bottom_constraints_,
                                        partner->bottom_constraints_);
    } else {
      // We need prev top to be common with partner bottom.
      if (TabConstraint::CompatibleConstraints(prev_partner->top_constraints_,
                                               partner->bottom_constraints_))
        TabConstraint::MergeConstraints(prev_partner->top_constraints_,
                                        partner->bottom_constraints_);
    }
    prev_partner = partner;
    if (it.at_last()) {
      // This is the last partner, so common top.
      if (TabConstraint::CompatibleConstraints(top_constraints_,
                                               partner->top_constraints_))
        TabConstraint::MergeConstraints(top_constraints_,
                                        partner->top_constraints_);
    }
  }
}

// Setup the constraints between this and its partner.
void TabVector::SetupPartnerConstraints(TabVector* partner) {
  if (TabConstraint::CompatibleConstraints(bottom_constraints_,
                                           partner->bottom_constraints_))
    TabConstraint::MergeConstraints(bottom_constraints_,
                                    partner->bottom_constraints_);
  if (TabConstraint::CompatibleConstraints(top_constraints_,
                                           partner->top_constraints_))
    TabConstraint::MergeConstraints(top_constraints_,
                                    partner->top_constraints_);
}

// Use the constraints to modify the top and bottom.
void TabVector::ApplyConstraints() {
  if (top_constraints_ != NULL)
    TabConstraint::ApplyConstraints(top_constraints_);
  if (bottom_constraints_ != NULL)
    TabConstraint::ApplyConstraints(bottom_constraints_);
}

// Merge close tab vectors of the same side that overlap.
void TabVector::MergeSimilarTabVectors(const ICOORD& vertical,
                                       TabVector_LIST* vectors,
                                       BlobGrid* grid) {
  TabVector_IT it1(vectors);
  for (it1.mark_cycle_pt(); !it1.cycled_list(); it1.forward()) {
    TabVector* v1 = it1.data();
    TabVector_IT it2(it1);
    for (it2.forward(); !it2.at_first(); it2.forward()) {
      TabVector* v2 = it2.data();
      if (v2->SimilarTo(vertical, *v1, grid)) {
        // Merge into the forward one, in case the combined vector now
        // overlaps one in between.
        if (textord_debug_tabfind) {
          v2->Print("Merging");
          v1->Print("by deleting");
        }
        v2->MergeWith(vertical, it1.extract());
        ICOORD merged_vector = v2->endpt();
        merged_vector -= v2->startpt();
        if (abs(merged_vector.x()) > 100) {
          v2->Print("Garbage result of merge?");
        }
        break;
      }
    }
  }
}

// Return true if this vector is the same side, overlaps, and close
// enough to the other to be merged.
bool TabVector::SimilarTo(const ICOORD& vertical,
                          const TabVector& other, BlobGrid* grid) const {
  if ((IsRightTab() && other.IsRightTab()) ||
      (IsLeftTab() && other.IsLeftTab())) {
    // If they don't overlap, at least in extensions, then there is no chance.
    if (ExtendedOverlap(other.extended_ymax_, other.extended_ymin_) < 0)
      return false;
    // A fast approximation to the scale factor of the sort_key_.
    int v_scale = abs(vertical.y());
    if (v_scale == 0)
      v_scale = 1;
    // If they are close enough, then OK.
    if (sort_key_ + kSimilarVectorDist * v_scale >= other.sort_key_ &&
        sort_key_ - kSimilarVectorDist * v_scale <= other.sort_key_)
      return true;
    // Ragged tabs get a bigger threshold.
    if (!IsRagged() || !other.IsRagged() ||
        sort_key_ + kSimilarRaggedDist * v_scale < other.sort_key_ ||
        sort_key_ - kSimilarRaggedDist * v_scale > other.sort_key_)
      return false;
    if (grid == NULL) {
      // There is nothing else to test!
      return true;
    }
    // If there is nothing in the rectangle between the vector that is going to
    // move, and the place it is moving to, then they can be merged.
    // Setup a vertical search for any blob.
    const TabVector* mover = (IsRightTab() &&
       sort_key_ < other.sort_key_) ? this : &other;
    int top_y = mover->endpt_.y();
    int bottom_y = mover->startpt_.y();
    int left = MIN(mover->XAtY(top_y), mover->XAtY(bottom_y));
    int right = MAX(mover->XAtY(top_y), mover->XAtY(bottom_y));
    int shift = abs(sort_key_ - other.sort_key_) / v_scale;
    if (IsRightTab()) {
      right += shift;
    } else {
      left -= shift;
    }

    GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> vsearch(grid);
    vsearch.StartVerticalSearch(left, right, top_y);
    BLOBNBOX* blob;
    while ((blob = vsearch.NextVerticalSearch(true)) != NULL) {
      TBOX box = blob->bounding_box();
      if (box.top() > bottom_y)
        return true;  // Nothing found.
      if (box.bottom() < top_y)
        continue;  // Doesn't overlap.
      int left_at_box = XAtY(box.bottom());
      int right_at_box = left_at_box;
      if (IsRightTab())
        right_at_box += shift;
      else
        left_at_box -= shift;
      if (MIN(right_at_box, box.right()) > MAX(left_at_box, box.left()))
        return false;
    }
    return true;  // Nothing found.
  }
  return false;
}

// Eat the other TabVector into this and delete it.
void TabVector::MergeWith(const ICOORD& vertical, TabVector* other) {
  extended_ymin_ = MIN(extended_ymin_, other->extended_ymin_);
  extended_ymax_ = MAX(extended_ymax_, other->extended_ymax_);
  if (other->IsRagged()) {
    alignment_ = other->alignment_;
  }
  // Merge sort the two lists of boxes.
  BLOBNBOX_C_IT it1(&boxes_);
  BLOBNBOX_C_IT it2(&other->boxes_);
  while (!it2.empty()) {
    BLOBNBOX* bbox2 = it2.extract();
    it2.forward();
    TBOX box2 = bbox2->bounding_box();
    BLOBNBOX* bbox1 = it1.data();
    TBOX box1 = bbox1->bounding_box();
    while (box1.bottom() < box2.bottom() && !it1.at_last()) {
      it1.forward();
      bbox1 = it1.data();
      box1 = bbox1->bounding_box();
    }
    if (box1.bottom() < box2.bottom()) {
      it1.add_to_end(bbox2);
    } else if (bbox1 != bbox2) {
      it1.add_before_stay_put(bbox2);
    }
  }
  Fit(vertical, true);
  other->Delete(this);
}

// Add a new element to the list of partner TabVectors.
// Partners must be added in order of increasing y coordinate of the text line
// that makes them partners.
// Groups of identical partners are merged into one.
void TabVector::AddPartner(TabVector* partner) {
  if (IsSeparator() || partner->IsSeparator())
    return;
  TabVector_C_IT it(&partners_);
  if (!it.empty()) {
    it.move_to_last();
    if (it.data() == partner)
      return;
  }
  it.add_after_then_move(partner);
}

// Return true if other is a partner of this.
bool TabVector::IsAPartner(const TabVector* other) {
  TabVector_C_IT it(&partners_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    if (it.data() == other)
      return true;
  }
  return false;
}

// These names must be synced with the TabAlignment enum in tabvector.h.
const char* kAlignmentNames[] = {
  "Left Aligned",
  "Left Ragged",
  "Center",
  "Right Aligned",
  "Right Ragged",
  "Separator"
};

// Print basic information about this tab vector.
void TabVector::Print(const char* prefix) {
  if (this == NULL) {
    tprintf("%s <null>\n", prefix);
  } else {
    tprintf("%s %s (%d,%d)->(%d,%d) s=%d, sort key=%d, boxes=%d, partners=%d\n",
            prefix, kAlignmentNames[alignment_],
            startpt_.x(), startpt_.y(), endpt_.x(), endpt_.y(),
            percent_score_, sort_key_,
            boxes_.length(), partners_.length());
  }
}

// Print basic information about this tab vector and every box in it.
void TabVector::Debug(const char* prefix) {
  Print(prefix);
  BLOBNBOX_C_IT it(&boxes_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    BLOBNBOX* bbox = it.data();
    const TBOX& box = bbox->bounding_box();
    tprintf("Box at (%d,%d)->(%d,%d)\n",
            box.left(), box.bottom(), box.right(), box.top());
  }
}

// Draw this tabvector in place in the given window.
void TabVector::Display(ScrollView* tab_win) {
#ifndef GRAPHICS_DISABLED
  if (textord_debug_printable)
    tab_win->Pen(ScrollView::BLUE);
  else if (alignment_ == TA_LEFT_ALIGNED)
    tab_win->Pen(ScrollView::LIME_GREEN);
  else if (alignment_ == TA_LEFT_RAGGED)
    tab_win->Pen(ScrollView::DARK_GREEN);
  else if (alignment_ == TA_RIGHT_ALIGNED)
    tab_win->Pen(ScrollView::PINK);
  else if (alignment_ == TA_RIGHT_RAGGED)
    tab_win->Pen(ScrollView::CORAL);
  else
    tab_win->Pen(ScrollView::WHITE);
  tab_win->Line(startpt_.x(), startpt_.y(), endpt_.x(), endpt_.y());
  tab_win->Pen(ScrollView::GREY);
  tab_win->Line(startpt_.x(), startpt_.y(), startpt_.x(), extended_ymin_);
  tab_win->Line(endpt_.x(), extended_ymax_, endpt_.x(), endpt_.y());
  char score_buf[64];
  snprintf(score_buf, sizeof(score_buf), "%d", percent_score_);
  tab_win->TextAttributes("Times", 50, false, false, false);
  tab_win->Text(startpt_.x(), startpt_.y(), score_buf);
#endif
}

// Refit the line and/or re-evaluate the vector if the dirty flags are set.
void TabVector::FitAndEvaluateIfNeeded(const ICOORD& vertical,
                                       TabFind* finder) {
  if (needs_refit_)
    Fit(vertical, true);
  if (needs_evaluation_)
    Evaluate(vertical, finder);
}

// Evaluate the vector in terms of coverage of its length by good-looking
// box edges. A good looking box is one where its nearest neighbour on the
// inside is nearer than half the distance its nearest neighbour on the
// outside of the putative column. Bad boxes are removed from the line.
// A second pass then further filters boxes by requiring that the gutter
// width be a minimum fraction of the mean gutter along the line.
void TabVector::Evaluate(const ICOORD& vertical, TabFind* finder) {
  needs_evaluation_ = false;
  int length = endpt_.y() - startpt_.y();
  if (length == 0 || boxes_.empty()) {
    percent_score_ = 0;
    Print("Zero length in evaluate");
    return;
  }
  // Compute the mean box height.
  BLOBNBOX_C_IT it(&boxes_);
  int mean_height = 0;
  int height_count = 0;
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    BLOBNBOX* bbox = it.data();
    const TBOX& box = bbox->bounding_box();
    int height = box.height();
    mean_height += height;
    ++height_count;
  }
  mean_height /= height_count;

  // Evaluate the boxes for their goodness, calculating the coverage as we go.
  // Remove boxes that are not good and shorten the list to the first and
  // last good boxes.
  bool deleted_a_box = false;
  int mean_gutter = 0;
  int gutter_count = 0;
  int good_length = 0;
  const TBOX* prev_good_box = NULL;
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    BLOBNBOX* bbox = it.data();
    const TBOX& box = bbox->bounding_box();
    int mid_y = (box.top() + box.bottom()) / 2;
    // A good box is one where the nearest neighbour on the inside is closer
    // than half the distance to the nearest neighbour on the outside
    // (of the putative column).
    bool left = IsLeftTab();
    int tab_x = XAtY(mid_y);
    int max_gutter = kGutterMultiple * mean_height;
    if (IsRagged()) {
      // Ragged edges face a tougher test in that the gap must always be within
      // the height of the blob.
      max_gutter = kGutterToNeighbourRatio * mean_height;
    }
    int gutter_width;
    int neighbour_gap;
    finder->GutterWidthAndNeighbourGap(tab_x, mean_height, max_gutter, left,
                                       bbox, &gutter_width, &neighbour_gap);
    if (TabFind::WithinTestRegion(2, tab_x, mid_y)) {
      tprintf("Box (%d,%d)->(%d,%d) has gutter %d, ndist %d\n",
              box.left(), box.bottom(), box.right(), box.top(),
              gutter_width, neighbour_gap);
    }
    // Now we can make the test.
    if (neighbour_gap * kGutterToNeighbourRatio <= gutter_width) {
      // A good box contributes its height to the good_length.
      good_length += box.top() - box.bottom();
      mean_gutter += gutter_width;
      ++gutter_count;
      // Two good boxes together contribute the gap between them
      // to the good_length as well, as long as the gap is not
      // too big.
      if (prev_good_box != NULL) {
        int vertical_gap = box.bottom() - prev_good_box->top();
        double size1 = sqrt(static_cast<double>(prev_good_box->area()));
        double size2 = sqrt(static_cast<double>(box.area()));
        if (vertical_gap < kMaxFillinMultiple * MIN(size1, size2))
          good_length += vertical_gap;
        if (TabFind::WithinTestRegion(2, tab_x, mid_y))
          tprintf("Box and prev good, gap=%d, target %g, goodlength=%d\n",
                  vertical_gap, kMaxFillinMultiple * MIN(size1, size2),
                  good_length);
      } else {
        // Adjust the start to the first good box.
        SetYStart(box.bottom());
      }
      prev_good_box = &box;
    } else {
      // Get rid of boxes that are not good.
      if (TabFind::WithinTestRegion(2, tab_x, mid_y)) {
        tprintf("Bad Box (%d,%d)->(%d,%d) with gutter %d, ndist %d\n",
                box.left(), box.bottom(), box.right(), box.top(),
                gutter_width, neighbour_gap);
      }
      it.extract();
      deleted_a_box = true;
    }
  }
  // If there are any good boxes, do it again, except this time get rid of
  // boxes that have a gutter that is a small fraction of the mean gutter.
  // This filters out ends that run into a coincidental gap in the text.
  if (gutter_count > 0) {
    mean_gutter /= gutter_count;
    prev_good_box = NULL;
    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
      BLOBNBOX* bbox = it.data();
      const TBOX& box = bbox->bounding_box();
      int mid_y = (box.top() + box.bottom()) / 2;
      // A good box is one where the gutter width is at least some constant
      // fraction of the mean gutter width.
      bool left = IsLeftTab();
      int tab_x = XAtY(mid_y);
      int max_gutter = kGutterMultiple * mean_height;
      if (IsRagged()) {
        // Ragged edges face a tougher test in that the gap must always be
        // within the height of the blob.
        max_gutter = kGutterToNeighbourRatio * mean_height;
      }
      int gutter_width;
      int neighbour_gap;
      finder->GutterWidthAndNeighbourGap(tab_x, mean_height, max_gutter, left,
                                         bbox, &gutter_width, &neighbour_gap);
      // Now we can make the test.
      if (gutter_width >= mean_gutter * kMinGutterFraction) {
        if (prev_good_box == NULL) {
          // Adjust the start to the first good box.
          SetYStart(box.bottom());
        }
        prev_good_box = &box;
      } else {
        // Get rid of boxes that are not good.
        if (TabFind::WithinTestRegion(2, tab_x, mid_y)) {
          tprintf("Bad Box (%d,%d)->(%d,%d) with gutter %d, mean gutter %d\n",
                  box.left(), box.bottom(), box.right(), box.top(),
                  gutter_width, mean_gutter);
        }
        it.extract();
        deleted_a_box = true;
      }
    }
  }
  // If there has been a good box, adjust the end.
  if (prev_good_box != NULL) {
    SetYEnd(prev_good_box->top());
    // Compute the percentage of the vector that is occupied by good boxes.
    int length = endpt_.y() - startpt_.y();
    percent_score_ = 100 * good_length / length;
    if (deleted_a_box) {
      needs_refit_ = true;
      FitAndEvaluateIfNeeded(vertical, finder);
    }
  } else {
    // There are no good boxes left, so score is 0.
    percent_score_ = 0;
  }
}

// (Re)Fit a line to the stored points. Returns false if the line
// is degenerate.
bool TabVector::Fit(ICOORD vertical, bool force_parallel) {
  needs_refit_ = false;
  if (boxes_.empty() && !force_parallel) {
    // Don't refit something with no boxes, as that only happens
    // in Evaluate, and we don't want to end up with a zero vector.
    // If we are forcing parallel, then that is OK.
    return false;
  }
  if (!force_parallel && !IsRagged()) {
    // Use a fitted line as the vertical.
    DetLineFit linepoints;
    BLOBNBOX_C_IT it(&boxes_);
    // Fit a line to all the boxes in the list.
    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
      BLOBNBOX* bbox = it.data();
      TBOX box = bbox->bounding_box();
      int x1 = IsRightTab() ? box.right() : box.left();
      ICOORD boxpt(x1, box.bottom());
      linepoints.Add(boxpt);
      if (it.at_last()) {
        ICOORD top_pt(x1, box.top());
        linepoints.Add(top_pt);
      }
    }
    linepoints.Fit(&startpt_, &endpt_);
    if (startpt_.y() != endpt_.y()) {
      vertical = endpt_;
      vertical -= startpt_;
    }
  }
  int start_y = startpt_.y();
  int end_y = endpt_.y();
  sort_key_ = IsLeftTab() ? MAX_INT32 : -MAX_INT32;
  BLOBNBOX_C_IT it(&boxes_);
  // Choose a line parallel to the vertical such that all boxes are on the
  // correct side of it.
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    BLOBNBOX* bbox = it.data();
    TBOX box = bbox->bounding_box();
    int x1 = IsRightTab() ? box.right() : box.left();
    // Test both the bottom and the top, as one will be more extreme, depending
    // on the direction of skew.
    int bottom_y = box.bottom();
    int top_y = box.top();
    int key = SortKey(vertical, x1, bottom_y);
    if (IsLeftTab() == (key < sort_key_)) {
      sort_key_ = key;
      startpt_ = ICOORD(x1, bottom_y);
    }
    key = SortKey(vertical, x1, top_y);
    if (IsLeftTab() == (key < sort_key_)) {
      sort_key_ = key;
      startpt_ = ICOORD(x1, top_y);
    }
    if (it.at_first())
      start_y = bottom_y;
    if (it.at_last())
      end_y = top_y;
  }
  if (boxes_.empty()) {
    ICOORD midpt = startpt_;
    midpt += endpt_;
    midpt /= 2;
    sort_key_ = SortKey(vertical, midpt.x(), midpt.y());
  }
  endpt_ = startpt_ + vertical;
  needs_evaluation_ = true;
  if (start_y != end_y) {
    // Set the ends of the vector to fully include the first and last blobs.
    startpt_.set_x(XAtY(vertical, sort_key_, start_y));
    startpt_.set_y(start_y);
    endpt_.set_x(XAtY(vertical, sort_key_, end_y));
    endpt_.set_y(end_y);
    return true;
  }
  return false;
}

// Return the partner of this TabVector if the vector qualifies as
// being a vertical text line, otherwise NULL.
TabVector* TabVector::VerticalTextlinePartner() {
  if (!partners_.singleton())
    return NULL;
  TabVector_C_IT partner_it(&partners_);
  TabVector* partner = partner_it.data();
  BLOBNBOX_C_IT box_it1(&boxes_);
  BLOBNBOX_C_IT box_it2(&partner->boxes_);
  // Count how many boxes are also in the other list.
  // At the same time, gather the mean width and median vertical gap.
  int num_matched = 0;
  int num_unmatched = 0;
  int total_widths = 0;
  int width = startpt().x() - partner->startpt().x();
  if (width < 0)
    width = -width;
  STATS gaps(0, width * 2);
  BLOBNBOX* prev_bbox = NULL;
  box_it2.mark_cycle_pt();
  for (box_it1.mark_cycle_pt(); !box_it1.cycled_list(); box_it1.forward()) {
    BLOBNBOX* bbox = box_it1.data();
    TBOX box = bbox->bounding_box();
    if (prev_bbox != NULL) {
      gaps.add(box.bottom() - prev_bbox->bounding_box().top(), 1);
    }
    while (!box_it2.cycled_list() && box_it2.data() != bbox &&
           box_it2.data()->bounding_box().bottom() < box.bottom()) {
      box_it2.forward();
    }
    if (!box_it2.cycled_list() && box_it2.data() == bbox &&
        bbox->region_type() >= BRT_UNKNOWN &&
        (prev_bbox == NULL || prev_bbox->region_type() >= BRT_UNKNOWN))
      ++num_matched;
    else
      ++num_unmatched;
    total_widths += box.width();
    prev_bbox = bbox;
  }
  if (textord_debug_tabfind > 1) {
    Print("Testing for vertical text");
    tprintf("gaps=%d, matched=%d, unmatched=%d, median gap=%.2f, width=%.2f\n",
            gaps.get_total(), num_matched, num_unmatched,
            gaps.median(),
            total_widths * 1.0 / (num_unmatched + num_matched));
  }
  if (gaps.get_total() == 0 || num_matched <= num_unmatched) {
    return NULL;
  }
  // It qualifies if the median gap is less than kVerticalTextGapFraction *
  // mean width.
  if (gaps.median() >= total_widths * kVerticalTextGapFraction /
      (num_unmatched + num_matched)) {
    return NULL;
  }
  if (textord_debug_tabfind > 1) {
    tprintf("Vertical text found\n");
  }
  return partner;
}

// The constructor is private.
TabVector::TabVector(int extended_ymin, int extended_ymax,
                     TabAlignment alignment, BLOBNBOX_CLIST* boxes)
  : extended_ymin_(extended_ymin), extended_ymax_(extended_ymax),
    sort_key_(0), percent_score_(0),
    needs_refit_(true), needs_evaluation_(true), alignment_(alignment),
    top_constraints_(NULL), bottom_constraints_(NULL) {
  BLOBNBOX_C_IT it(&boxes_);
  it.add_list_after(boxes);
}

// Delete this, but first, repoint all the partners to point to
// replacement. If replacement is NULL, then partner relationships
// are removed.
void TabVector::Delete(TabVector* replacement) {
  TabVector_C_IT it(&partners_);
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
    TabVector* partner = it.data();
    TabVector_C_IT p_it(&partner->partners_);
    // If partner already has replacement in its list, then make
    // replacement null, and just remove this TabVector when we find it.
    TabVector* partner_replacement = replacement;
    for (p_it.mark_cycle_pt(); !p_it.cycled_list(); p_it.forward()) {
      TabVector* p_partner = p_it.data();
      if (p_partner == partner_replacement) {
        partner_replacement = NULL;
        break;
      }
    }
    // Remove all references to this, and replace with replacement if not NULL.
    for (p_it.mark_cycle_pt(); !p_it.cycled_list(); p_it.forward()) {
      TabVector* p_partner = p_it.data();
      if (p_partner == this) {
        p_it.extract();
        if (partner_replacement != NULL)
          p_it.add_before_stay_put(partner_replacement);
      }
    }
    if (partner_replacement != NULL) {
      partner_replacement->AddPartner(partner);
    }
  }
  delete this;
}
/////////////////////////////////////////////////////////////////tabvector////////////////////////////////////////

/////////////////////////////////////////////////////////////////TessBaseAPI////////////////////////////////////
// Include automatically generated configuration file if running autoconf.
#ifdef HAVE_CONFIG_H
#endif

#ifdef HAVE_LIBLEPT
#endif

// Minimum sensible image size to be worth running tesseract.
const int kMinRectSize = 10;
// Character returned when Tesseract couldn't recognize as anything.
const char kTesseractReject = '~';
// Character used by UNLV error counter as a reject.
const char kUNLVReject = '~';
// Character used by UNLV as a suspect marker.
const char kUNLVSuspect = '^';
// Filename used for input image file, from which to derive a name to search
// for a possible UNLV zone file, if none is specified by SetInputName.
const char* kInputFile = "noname.tif";

TessBaseAPI::TessBaseAPI()
    : tesseract_(NULL),
      // Thresholder is initialized to NULL here, but will be set before use by:
      // A constructor of a derived API,  SetThresholder(), or
      // created implicitly when used in InternalSetImage.
      thresholder_(NULL),
      threshold_done_(false),
      block_list_(NULL),
      page_res_(NULL),
      input_file_(NULL),
      output_file_(NULL),
      datapath_(NULL),
      language_(NULL),
      rect_left_(0), rect_top_(0), rect_width_(0), rect_height_(0),
      image_width_(0), image_height_(0)
{
}

TessBaseAPI::~TessBaseAPI()
{
    End();
}

// Set the name of the input file. Needed only for training and
// loading a UNLV zone file.
void TessBaseAPI::SetInputName(const char* name)
{
    if (input_file_ == NULL)
    {
        input_file_ = new STRING(name);
    }
    else
    {
        *input_file_ = name;
    }
}

// Set the name of the output files. Needed only for debugging.
void TessBaseAPI::SetOutputName(const char* name)
{
    if (output_file_ == NULL)
    {
        output_file_ = new STRING(name);
    }
    else
    {
        *output_file_ = name;
    }
}

// Set the value of an internal "variable" (of either old or new types).
// Supply the name of the variable and the value as a string, just as
// you would in a config file.
// Returns false if the name lookup failed.
// SetVariable may be used before Init, to set things that control
// initialization, but note that on End all settings are lost and
// the next Init will use the defaults unless SetVariable is used again.
bool TessBaseAPI::SetVariable(const char* variable, const char* value)
{
    if (tesseract_ == NULL) tesseract_ = new Tesseract;

    return set_variable(variable, value);
}

// The datapath must be the name of the data directory (no ending /) or
// some other file in which the data directory resides (for instance argv[0].)
// The language is (usually) an ISO 639-3 string or NULL will default to eng.
// If numeric_mode is true, then only digits and Roman numerals will
// be returned.
// Returns 0 on success and -1 on initialization failure.
int TessBaseAPI::Init(const char* datapath, const char* language,
                      char **configs, int configs_size, bool configs_global_only)
{
    // If the datapath or the language have changed, then start again.
    // Note that the language_ field stores the last requested language that was
    // initialized successfully, while tesseract_->lang stores the language
    // actually used. They differ only if the requested language was NULL, in
    // which case tesseract_->lang is set to the Tesseract default ("eng").
    if (tesseract_ != NULL &&
        (datapath_ == NULL ||
         language_ == NULL ||
         *datapath_ != datapath ||
         (*language_ != language && tesseract_->lang != language)))
    {
        tesseract_->end_tesseract();
        delete tesseract_;
        tesseract_ = NULL;
    }

    bool reset_classifier = true;
    if (tesseract_ == NULL)
    {
        reset_classifier = false;
        tesseract_ = new Tesseract;
        if (tesseract_->init_tesseract(datapath, output_file_ != NULL ? output_file_->string() : NULL,
                                       language, configs, configs_size, configs_global_only) != 0)
        {
            return -1;
        }
    }

    // Update datapath and language requested for the last valid initialization.
    if (datapath_ == NULL)
    {
        datapath_ = new STRING(datapath);
    }
    else
    {
        *datapath_ = datapath;
    }

    if (language_ == NULL)
    {
        language_ = new STRING(language);
    }
    else
    {
        *language_ = language;
    }
    //        SetInputName(datapath);

    // For same language and datapath, just reset the adaptive classifier.
    if (reset_classifier) tesseract_->ResetAdaptiveClassifier();

    return 0;
}

// Init only the lang model component of Tesseract. The only functions
// that work after this init are SetVariable and IsValidWord.
// WARNING: temporary! This function will be removed from here and placed
// in a separate API at some future time.
int TessBaseAPI::InitLangMod(const char* datapath, const char* language)
{
    if (tesseract_ == NULL) tesseract_ = new Tesseract;

    return tesseract_->init_tesseract_lm(datapath, NULL, language);
}

// Init only the classifer component of Tesseract. Used to initialize the
// specified language when no dawg models are available.
int TessBaseAPI::InitWithoutLangModel(const char* datapath, const char* language)
{
    // If the datapath or the language have changed, then start again.
    if (tesseract_ != NULL && (datapath_ == NULL || language_ == NULL ||
                               *datapath_ != datapath || *language_ != language))
    {
        tesseract_->end_tesseract();
        delete tesseract_;
        tesseract_ = NULL;
    }

    if (datapath_ == NULL)
    {
        datapath_ = new STRING(datapath);
    }
    else
    {
        *datapath_ = datapath;
    }

    if (language_ == NULL)
    {
        language_ = new STRING(language);
    }
    else
    {
        *language_ = language;
    }

    if (tesseract_ == NULL)
    {
        tesseract_ = new Tesseract;

        return tesseract_->init_tesseract_classifier( datapath, output_file_ != NULL ? output_file_->string() : NULL, language, NULL, 0, false);
    }

    // For same language and datapath, just reset the adaptive classifier.
    tesseract_->ResetAdaptiveClassifier();

    return 0;
}

// Read a "config" file containing a set of variable, value pairs.
// Searches the standard places: tessdata/configs, tessdata/tessconfigs
// and also accepts a relative or absolute path name.
void TessBaseAPI::ReadConfigFile(const char* filename, bool global_only)
{
    tesseract_->read_config_file(filename, global_only);
}

// Set the current page segmentation mode. Defaults to PSM_AUTO.
// The mode is stored as an INT_VARIABLE so it can also be modified by
// ReadConfigFile or SetVariable("tessedit_pageseg_mode", mode as string).
void TessBaseAPI::SetPageSegMode(PageSegMode mode)
{
    if (tesseract_ == NULL)  tesseract_ = new Tesseract;

    tesseract_->tessedit_pageseg_mode.set_value(mode);
}

// Return the current page segmentation mode.
PageSegMode TessBaseAPI::GetPageSegMode() const
{
    if (tesseract_ == NULL)  return PSM_SINGLE_BLOCK;

    return static_cast<PageSegMode>(static_cast<int>(tesseract_->tessedit_pageseg_mode));
}

// Set the hint for trading accuracy against speed.
// Default is AVS_FASTEST, which is the old behaviour.
// Note that this is only a hint. Depending on the language and/or
// build configuration, speed and accuracy may not be tradeable.
// Also note that despite being an enum, any value in the range
// AVS_FASTEST to AVS_MOST_ACCURATE can be provided, and may or may not
// have an effect, depending on the implementation.
// The mode is stored as an INT_VARIABLE so it can also be modified by
// ReadConfigFile or SetVariable("tessedit_accuracyvspeed", mode as string).
void TessBaseAPI::SetAccuracyVSpeed(AccuracyVSpeed mode)
{
    if (tesseract_ == NULL) tesseract_ = new Tesseract;

    tesseract_->tessedit_accuracyvspeed.set_value(mode);
}

// Recognize a rectangle from an image and return the result as a string.
// May be called many times for a single Init.
// Currently has no error checking.
// Greyscale of 8 and color of 24 or 32 bits per pixel may be given.
// Palette color images will not work properly and must be converted to
// 24 bit.
// Binary images of 1 bit per pixel may also be given but they must be
// byte packed with the MSB of the first byte being the first pixel, and a
// one pixel is WHITE. For binary images set bytes_per_pixel=0.
// The recognized text is returned as a char* which is coded
// as UTF8 and must be freed with the delete [] operator.
char* TessBaseAPI::TesseractRect(const unsigned char* imagedata, int bytes_per_pixel,
                                 int bytes_per_line, int left, int top, int width, int height)
{
    if (tesseract_ == NULL || width < kMinRectSize || height < kMinRectSize) return NULL;  // Nothing worth doing.

    // Since this original api didn't give the exact size of the image,
    // we have to invent a reasonable value.
    int bits_per_pixel = bytes_per_pixel == 0 ? 1 : bytes_per_pixel * 8;

    SetImage(imagedata, bytes_per_line * 8 / bits_per_pixel, height + top, bytes_per_pixel, bytes_per_line);
    SetRectangle(left, top, width, height);

    return GetUTF8Text();
}

// Call between pages or documents etc to free up memory and forget
// adaptive data.
void TessBaseAPI::ClearAdaptiveClassifier()
{
    if (tesseract_ == NULL) return;

    tesseract_->ResetAdaptiveClassifier();
}

// Provide an image for Tesseract to recognize. Format is as
// TesseractRect above. Does not copy the image buffer, or take
// ownership. The source image may be destroyed after Recognize is called,
// either explicitly or implicitly via one of the Get*Text functions.
// SetImage clears all recognition results, and sets the rectangle to the
// full image, so it may be followed immediately by a GetUTF8Text, and it
// will automatically perform recognition.
void TessBaseAPI::SetImage(const unsigned char* imagedata, int width, int height,
                           int bytes_per_pixel, int bytes_per_line)
{
    if (InternalSetImage()) thresholder_->SetImage(imagedata, width, height,  bytes_per_pixel, bytes_per_line);
}

// Provide an image for Tesseract to recognize. As with SetImage above,
// Tesseract doesn't take a copy or ownership or pixDestroy the image, so
// it must persist until after Recognize.
// Pix vs raw, which to use?
// Use Pix where possible. A future version of Tesseract may choose to use Pix
// as its internal representation and discard IMAGE altogether.
// Because of that, an implementation that sources and targets Pix may end up
// with less copies than an implementation that does not.
void TessBaseAPI::SetImage(const Pix* pix)
{
    Q_UNUSED(pix);
#ifdef HAVE_LIBLEPT
    if (InternalSetImage()) thresholder_->SetImage(pix);
#endif
}

// Restrict recognition to a sub-rectangle of the image. Call after SetImage.
// Each SetRectangle clears the recogntion results so multiple rectangles
// can be recognized with the same image.
void TessBaseAPI::SetRectangle(int left, int top, int width, int height)
{
    if (thresholder_ == NULL) return;

    thresholder_->SetRectangle(left, top, width, height);
    ClearResults();
}

// ONLY available if you have Leptonica installed.
// Get a copy of the internal thresholded image from Tesseract.
Pix* TessBaseAPI::GetThresholdedImage()
{
#ifdef HAVE_LIBLEPT
    if (tesseract_ == NULL) return NULL;

    if (tesseract_->pix_binary() == NULL) Threshold(tesseract_->mutable_pix_binary());

    return pixClone(tesseract_->pix_binary());
#endif
    return NULL;
}

// Get the result of page layout analysis as a leptonica-style
// Boxa, Pixa pair, in reading order.
// Can be called before or after Recognize.
// For now only gets text regions.
Boxa* TessBaseAPI::GetRegions(Pixa** pixa)
{
    Q_UNUSED(pixa);
#ifdef HAVE_LIBLEPT
    if (block_list_ == NULL || block_list_->empty())
    {
        FindLines();
    }

    int im_height = pixGetHeight(tesseract_->pix_binary());
    Boxa* boxa = boxaCreate(block_list_->length());

    if (pixa != NULL)
    {
        *pixa = pixaCreate(boxaGetCount(boxa));
    }

    BLOCK_IT it(block_list_);

    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
    {
        BLOCK* block = it.data();
        POLY_BLOCK* poly = block->poly_block();
        TBOX box;

        if (poly != NULL)
        {
            if (!poly->IsText()) continue;  // Use only text blocks.
            POLY_BLOCK image_block(poly->points(), poly->isA());
            image_block.rotate(block->re_rotation());
            box = *image_block.bounding_box();

            if (pixa != NULL)
            {
                Pix* pix = pixCreate(box.width(), box.height(), 1);
                PB_LINE_IT *lines;

                // Block outline is a polygon, so use a PC_LINE_IT to get the
                // rasterized interior. (Runs of interior pixels on a line.)
                lines = new PB_LINE_IT(&image_block);
                for (int y = box.bottom(); y < box.top(); ++y)
                {
                    ICOORDELT_LIST* segments = lines->get_line(y);

                    if (!segments->empty())
                    {
                        ICOORDELT_IT s_it(segments);

                        // Each element of segments is a start x and x size of the
                        // run of interior pixels.
                        for (s_it.mark_cycle_pt(); !s_it.cycled_list(); s_it.forward())
                        {
                            int start = s_it.data()->x();
                            int xext = s_it.data()->y();

                            // Copy the run from the source image to the block image.
                            pixRasterop(pix, start - box.left(), box.height() - 1 - (y - box.bottom()),
                                        xext, 1, PIX_SRC, tesseract_->pix_binary(), start, im_height - 1 - y);
                        }
                    }

                    delete segments;
                }

                delete lines;
                pixaAddPix(*pixa, pix, L_INSERT);
            }
        } else
        {
            if (!block_list_->singleton()) continue;  // A null poly block can only be used if it is the only block.
            box = block->bounding_box();

            if (pixa != NULL)
            {
                Pix* pix = pixCreate(box.width(), box.height(), 1);

                // Just copy the whole block as there is only a bounding box.
                pixRasterop(pix, 0, 0, box.width(), box.height(), PIX_SRC, tesseract_->pix_binary(),
                            box.left(), im_height - box.top());

                pixaAddPix(*pixa, pix, L_INSERT);
            }
        }

        Box* lbox = boxCreate(box.left(), im_height - box.top(),
                              box.width(), box.height());
        boxaAddBox(boxa, lbox, L_INSERT);
    }

    return boxa;
#endif
    return NULL;
}

// Get the textlines as a leptonica-style
// Boxa, Pixa pair, in reading order.
// Can be called before or after Recognize.
// If blockids is not NULL, the block-id of each line is also returned as an
// array of one element per line. delete [] after use.
Boxa* TessBaseAPI::GetTextlines(Pixa** pixa, int** blockids)
{
    Q_UNUSED(pixa);
    Q_UNUSED(blockids);
#ifdef HAVE_LIBLEPT
    if (block_list_ == NULL || block_list_->empty())
    {
        FindLines();
    }

    // A local PAGE_RES prevents the clear if Recognize is called after.
    PAGE_RES page_res(block_list_);
    PAGE_RES_IT page_res_it(page_res_ != NULL ? page_res_ : &page_res);

    // Count the lines to get a size for the arrays.
    int line_count = 0;
    for (page_res_it.restart_page(); page_res_it.word() != NULL; page_res_it.forward())
    {
        if (page_res_it.row() != page_res_it.next_row())
        {
            ++line_count;
        }
    }

    int im_height = pixGetHeight(tesseract_->pix_binary());
    Boxa* boxa = boxaCreate(line_count);

    if (pixa != NULL) *pixa = pixaCreate(line_count);
    if (blockids != NULL) *blockids = new int[line_count];

    int blockid = 0;
    int lineindex = 0;
    for (page_res_it.restart_page(); page_res_it.word() != NULL; page_res_it.forward(), ++lineindex)
    {
        WERD_RES *word = page_res_it.word();
        BLOCK* block = page_res_it.block()->block;

        // Get the line bounding box.
        PAGE_RES_IT word_it(page_res_it);  // Save start of line.
        TBOX line_box = word->word->bounding_box();

        while (page_res_it.next_row() == page_res_it.row())
        {
            page_res_it.forward();
            word = page_res_it.word();
            TBOX word_box = word->word->bounding_box();
            word_box.rotate(block->re_rotation());
            line_box += word_box;
        }

        Box* lbox = boxCreate(line_box.left(), im_height - line_box.top(), line_box.width(), line_box.height());
        boxaAddBox(boxa, lbox, L_INSERT);

        if (pixa != NULL)
        {
            Pix* pix = pixCreate(line_box.width(), line_box.height(), 1);

            // Copy all the words to the output pix.
            while (word_it.row() == page_res_it.row())
            {
                word = word_it.word();
                TBOX word_box = word->word->bounding_box();
                word_box.rotate(block->re_rotation());
                pixRasterop(pix, word_box.left() - line_box.left(), line_box.top() - word_box.top(), word_box.width(),
                            word_box.height(), PIX_SRC, tesseract_->pix_binary(), word_box.left(), im_height - word_box.top());

                word_it.forward();
            }

            pixaAddPix(*pixa, pix, L_INSERT);
            pixaAddBox(*pixa, lbox, L_CLONE);
        }

        if (blockids != NULL)
        {
            (*blockids)[lineindex] = blockid;

            if (page_res_it.block() != page_res_it.next_block()) ++blockid;
        }
    }
    s
            return boxa;
#endif
    return NULL;
}

// Get the words as a leptonica-style
// Boxa, Pixa pair, in reading order.
// Can be called before or after Recognize.
Boxa* TessBaseAPI::GetWords(Pixa** pixa)
{
    Q_UNUSED(pixa);
#ifdef HAVE_LIBLEPT
    if (block_list_ == NULL || block_list_->empty())
    {
        FindLines();
    }

    // A local PAGE_RES prevents the clear if Recognize is called after.
    PAGE_RES page_res(block_list_);
    PAGE_RES_IT page_res_it(page_res_ != NULL ? page_res_ : &page_res);

    // Count the words to get a size for the arrays.
    int word_count = 0;
    for (page_res_it.restart_page(); page_res_it.word () != NULL; page_res_it.forward()) ++word_count;

    int im_height = pixGetHeight(tesseract_->pix_binary());
    Boxa* boxa = boxaCreate(word_count);

    if (pixa != NULL)
    {
        *pixa = pixaCreate(word_count);
    }

    for (page_res_it.restart_page(); page_res_it.word () != NULL; page_res_it.forward())
    {
        WERD_RES *word = page_res_it.word();
        BLOCK* block = page_res_it.block()->block;
        TBOX box = word->word->bounding_box();
        box.rotate(block->re_rotation());

        Box* lbox = boxCreate(box.left(), im_height - box.top(), box.width(), box.height());
        boxaAddBox(boxa, lbox, L_INSERT);

        if (pixa != NULL)
        {
            Pix* pix = pixCreate(box.width(), box.height(), 1);

            // Copy the whole word bounding box to the output pix.
            pixRasterop(pix, 0, 0, box.width(), box.height(), PIX_SRC, tesseract_->pix_binary(), box.left(), im_height - box.top());
            pixaAddPix(*pixa, pix, L_INSERT);
            pixaAddBox(*pixa, lbox, L_CLONE);
        }
    }

    return boxa;
#endif  // HAVE_LIBLEPT
   return NULL;
}

// Dump the internal binary image to a PGM file.
void TessBaseAPI::DumpPGM(const char* filename)
{
    if (tesseract_ == NULL) return;

    IMAGELINE line;
    line.init(page_image.get_xsize());
    FILE *fp = fopen(filename, "w");
    fprintf(fp, "P5 " INT32FORMAT " " INT32FORMAT " 255\n", page_image.get_xsize(), page_image.get_ysize());

    for (int j = page_image.get_ysize()-1; j >= 0 ; --j)
    {
        page_image.get_line(0, j, page_image.get_xsize(), &line, 0);

        for (int i = 0; i < page_image.get_xsize(); ++i)
        {
            uinT8 b = line.pixels[i] ? 255 : 0;
            fwrite(&b, 1, 1, fp);
        }
    }

    fclose(fp);
}

// Recognize the tesseract global image and return the result as Tesseract
// internal structures.
int TessBaseAPI::Recognize(struct ETEXT_STRUCT* monitor)
{
    if (tesseract_ == NULL) return -1;

    if (thresholder_ == NULL || thresholder_->IsEmpty())
    {
        tprintf("Please call SetImage before attempting recognition.");
        return -1;
    }

    if (page_res_ != NULL) ClearResults();

    if (FindLines() != 0) return -1;

    if (tesseract_->tessedit_resegment_from_boxes) tesseract_->apply_boxes(*input_file_, block_list_);
    tesseract_->SetBlackAndWhitelist();

    page_res_ = new PAGE_RES(block_list_);
    int result = 0;

    if (interactive_mode)
    {
        tesseract_->pgeditor_main(block_list_);

        // The page_res is invalid after an interactive session, so cleanup
        // in a way that lets us continue to the next page without crashing.
        delete page_res_;
        page_res_ = NULL;

        return -1;
    }
    else if (tesseract_->tessedit_train_from_boxes)
    {
        apply_box_training(*output_file_, block_list_);
    }
    else if (tesseract_->global_tessedit_ambigs_training)
    {
        FILE *ambigs_output_file = tesseract_->init_ambigs_training(*input_file_);

        // OCR the page segmented into words by tesseract.
        tesseract_->ambigs_training_segmented(*input_file_, page_res_, monitor, ambigs_output_file);
        fclose(ambigs_output_file);
    }
    else
    {
        // Now run the main recognition.
        // Running base tesseract if the inttemp for the current language loaded.
        if (tesseract_->inttemp_loaded_)
        {
            tesseract_->recog_all_words(page_res_, monitor);
        }
    }

    return result;
}

// Tests the chopper by exhaustively running chop_one_blob.
int TessBaseAPI::RecognizeForChopTest(struct ETEXT_STRUCT* monitor)
{
    Q_UNUSED(monitor);
    if (tesseract_ == NULL) return -1;
    if (thresholder_ == NULL || thresholder_->IsEmpty())
    {
        tprintf("Please call SetImage before attempting recognition.");
        return -1;
    }

    if (page_res_ != NULL) ClearResults();
    if (FindLines() != 0) return -1;

    // Additional conditions under which chopper test cannot be run
    if (tesseract_->tessedit_train_from_boxes_word_level || interactive_mode) return -1;
    ASSERT_HOST(tesseract_->inttemp_loaded_);

    page_res_ = new PAGE_RES(block_list_);

    PAGE_RES_IT page_res_it(page_res_);

    tesseract_->tess_matcher = &Tesseract::tess_default_matcher;
    tesseract_->tess_tester = NULL;
    tesseract_->tess_trainer = NULL;

    while (page_res_it.word() != NULL)
    {
        WERD_RES *word_res = page_res_it.word();
        WERD *word = word_res->word;
        if (word->cblob_list()->empty())
        {
            page_res_it.forward();
            continue;
        }

        WERD *bln_word = make_bln_copy(word, page_res_it.row()->row, page_res_it.block()->block,
                                       word_res->x_height, &word_res->denorm);

        ASSERT_HOST(!bln_word->blob_list()->empty());
        TWERD *tessword = make_tess_word(bln_word, NULL);

        if (tessword->blobs == NULL)
        {
            make_tess_word(bln_word, NULL);
        }

        TBLOB *pblob;
        TBLOB *blob;
        init_match_table();
        BLOB_CHOICE_LIST *match_result;
        BLOB_CHOICE_LIST_VECTOR *char_choices = new BLOB_CHOICE_LIST_VECTOR();
        tesseract_->tess_denorm = &word_res->denorm;
        tesseract_->tess_word = bln_word;

        ASSERT_HOST(tessword->blobs != NULL);
        for (blob = tessword->blobs, pblob = NULL; blob != NULL; blob = blob->next)
        {
            match_result = tesseract_->classify_blob(pblob, blob, blob->next, NULL, "chop_word:", Green);
            if (match_result == NULL) tprintf("Null classifier output!\n");

            tesseract_->modify_blob_choice(match_result, 0);
            ASSERT_HOST(!match_result->empty());

            *char_choices += match_result;
            pblob = blob;
        }

        inT32 blob_number;
        SEAMS seam_list = start_seam_list(tessword->blobs);
        int right_chop_index = 0;
        while (tesseract_->chop_one_blob(tessword, char_choices,  &blob_number, &seam_list, &right_chop_index))
        {
        }

        word_res->best_choice = new WERD_CHOICE();
        word_res->raw_choice = new WERD_CHOICE();
        word_res->best_choice->make_bad();
        word_res->raw_choice->make_bad();
        tesseract_->getDict().permute_characters(*char_choices, 1000.0, word_res->best_choice, word_res->raw_choice);

        word_res->outword = make_ed_word(tessword, bln_word);
        page_res_it.forward();
    }

    return 0;
}

// Make a text string from the internal data structures.
char* TessBaseAPI::GetUTF8Text()
{
    if (tesseract_ == NULL || (page_res_ == NULL && Recognize(NULL) < 0)) return NULL;

    int total_length = TextLength(NULL);
    PAGE_RES_IT page_res_it(page_res_);
    char* result = new char[total_length];
    char* ptr = result;

    for (page_res_it.restart_page(); page_res_it.word() != NULL; page_res_it.forward())
    {
        WERD_RES *word = page_res_it.word();
        WERD_CHOICE* choice = word->best_choice;

        if (choice != NULL)
        {
            strcpy(ptr, choice->unichar_string().string());
            ptr += choice->unichar_string().length();

            if (word->word->flag(W_EOL))
            {
                *ptr++ = '\n';
            }
            else
            {
                *ptr++ = ' ';
            }
        }
    }
    *ptr++ = '\n';
    *ptr = '\0';

    return result;
}

// Helper returns true if there is a paragraph break between bbox_cur,
// and bbox_prev.
// TODO(rays) improve and incorporate deeper into tesseract, so other
// output methods get the benefit.
static bool IsParagraphBreak(TBOX bbox_cur, TBOX bbox_prev, int right, int line_height)
{
    // Check if the distance between lines is larger than the normal leading,
    if (fabs((float)(bbox_cur.bottom() - bbox_prev.bottom())) > line_height * 2) return true;

    // Check if the distance between left bounds of the two lines is nearly the
    // same as between their right bounds (if so, then both lines probably belong
    // to the same paragraph, maybe a centered one).
    if (fabs((float)((bbox_cur.left() - bbox_prev.left()) - (bbox_prev.right() - bbox_cur.right()))) < line_height)
        return false;

    // Check if there is a paragraph indent at this line (either -ve or +ve).
    if (fabs((float)(bbox_cur.left() - bbox_prev.left())) > line_height)
        return true;

    // Check if both current and previous line don't reach the right bound of the
    // block, but the distance is different. This will cause all lines in a verse
    // to be treated as separate paragraphs, but most probably will not split
    // block-quotes to separate lines (at least if the text is justified).
    if (fabs((float)(bbox_cur.right() - bbox_prev.right())) > line_height &&
            right - bbox_cur.right() > line_height && right - bbox_prev.right() > line_height)
        return true;

    return false;
}

// Helper to add the hOCR for a box to the given hocr_str.
static void AddBoxTohOCR(const TBOX& box, int image_height, STRING* hocr_str)
{
    hocr_str->add_str_int("' title=\"bbox ", box.left());
    hocr_str->add_str_int(" ", image_height - box.top());
    hocr_str->add_str_int(" ", box.right());
    hocr_str->add_str_int(" ", image_height - box.bottom());

    *hocr_str += "\">";
}

// Make a HTML-formatted string with hOCR markup from the internal
// data structures.
// STL removed from original patch submission and refactored by rays.
// page_id is 1-based and will appear in the output.
char* TessBaseAPI::GetHOCRText(int page_id)
{
    if (tesseract_ == NULL || (page_res_ == NULL && Recognize(NULL) < 0)) return NULL;

    PAGE_RES_IT page_res_it(page_res_);
    ROW_RES *row = NULL;           // current row
    ROW *real_row = NULL, *prev_row = NULL;
    BLOCK_RES *block = NULL;       // current row
    BLOCK *real_block = NULL;
    int lcnt = 1, bcnt = 1, wcnt = 1;

    STRING hocr_str;

    hocr_str.add_str_int("<div class='ocr_page' id='page_", page_id);
    hocr_str += "' title='image \"";
    hocr_str += *input_file_;
    hocr_str.add_str_int("\"; bbox ", rect_left_);
    hocr_str.add_str_int(" ", rect_top_);
    hocr_str.add_str_int(" ", rect_width_);
    hocr_str.add_str_int(" ", rect_height_);
    hocr_str += "'>\n";

    for (page_res_it.restart_page(); page_res_it.word () != NULL; page_res_it.forward())
    {
        if (block != page_res_it.block ())
        {

            if (block != NULL)
            {
                hocr_str += "</span>\n</p>\n</div>\n";
            }

            block = page_res_it.block ();  // current row
            real_block = block->block;
            real_row = NULL;
            row = NULL;

            hocr_str.add_str_int("<div class='ocr_carea' id='block_", page_id);
            hocr_str.add_str_int("_", bcnt++);
            AddBoxTohOCR(real_block->bounding_box(), image_height_, &hocr_str);
            hocr_str += "\n<p class='ocr_par'>\n";
        }

        if (row != page_res_it.row ())
        {
            if (row != NULL)
            {
                hocr_str += "</span>\n";
            }
            prev_row = real_row;

            row = page_res_it.row ();  // current row
            real_row = row->row;

            if (prev_row != NULL &&
                    IsParagraphBreak(real_row->bounding_box(), prev_row->bounding_box(),
                                     real_block->bounding_box().right(),
                                     real_row->x_height() + real_row->ascenders()))
            {
                hocr_str += "</p>\n<p class='ocr_par'>\n";
            }

            hocr_str.add_str_int("<span class='ocr_line' id='line_", page_id);
            hocr_str.add_str_int("_", lcnt++);
            AddBoxTohOCR(real_row->bounding_box(), image_height_, &hocr_str);
        }

        WERD_RES *word = page_res_it.word();
        WERD_CHOICE* choice = word->best_choice;
        if (choice != NULL)
        {
            hocr_str.add_str_int("<span class='ocr_word' id='word_", page_id);
            hocr_str.add_str_int("_", wcnt);
            AddBoxTohOCR(word->word->bounding_box(), image_height_, &hocr_str);
            hocr_str.add_str_int("<span class='xocr_word' id='xword_", page_id);
            hocr_str.add_str_int("_", wcnt++);
            hocr_str.add_str_int("' title=\"x_wconf ", choice->certainty());
            hocr_str += "\">";

            if (word->bold > 0) hocr_str += "<strong>";
            if (word->italic > 0) hocr_str += "<em>";
            hocr_str += choice->unichar_string();

            if (word->italic > 0) hocr_str += "</em>";
            if (word->bold > 0) hocr_str += "</strong>";

            hocr_str += "</span></span>";

            if (!word->word->flag(W_EOL))hocr_str += " ";
        }
    }

    hocr_str += "</span>\n</p>\n";
    hocr_str += "</div>\n</div>\n";
    char *ret = new char[hocr_str.length() + 1];
    strcpy(ret, hocr_str.string());

    return ret;
}

static int ConvertWordToBoxText(WERD_RES *word, ROW_RES* row, int left, int bottom, int image_width,
                                int image_height, int page_number,char* word_str)
{
    Q_UNUSED(row);
    // Copy the output word and denormalize it back to image coords.
    WERD copy_outword;
    copy_outword = *(word->outword);
    copy_outword.baseline_denormalise(&word->denorm);
    PBLOB_IT blob_it;
    blob_it.set_to_list(copy_outword.blob_list());
    int length = copy_outword.blob_list()->length();
    int output_size = 0;

    if (length > 0)
    {
        for (int index = 0, offset = 0; index < length; offset += word->best_choice->unichar_lengths()[index++], blob_it.forward())
        {
            PBLOB* blob = blob_it.data();
            TBOX blob_box = blob->bounding_box();
            if (word->tess_failed || blob_box.left() < 0 || blob_box.right() > image_width || blob_box.bottom() < 0 || blob_box.top() > image_height)
            {
                // Bounding boxes can be illegal when tess fails on a word.
                blob_box = word->word->bounding_box();  // Use original word as backup.
                tprintf("Using substitute bounding box at (%d,%d)->(%d,%d)\n", blob_box.left(), blob_box.bottom(), blob_box.right(), blob_box.top());
            }

            // A single classification unit can be composed of several UTF-8
            // characters. Append each of them to the result.
            for (int sub = 0; sub < word->best_choice->unichar_lengths()[index]; ++sub)
            {
                char ch = word->best_choice->unichar_string()[offset + sub];
                // Tesseract uses space for recognition failure. Fix to a reject
                // character, kTesseractReject so we don't create illegal box files.

                if (ch == ' ') ch = kTesseractReject;

                word_str[output_size++] = ch;
            }

            sprintf(word_str + output_size, " %d %d %d %d %d\n",blob_box.left() + left,
                    blob_box.bottom() + bottom,blob_box.right() + left, blob_box.top() + bottom, page_number);

            output_size += strlen(word_str + output_size);
        }
    }

    return output_size;
}

// Multiplier for max expected textlength assumes typically 5 numbers @
// (5 digits and a space) plus the newline = 5*(5+1)+1. Add to this the
// orginal UTF8 characters, and one kMaxCharsPerChar.
const int kCharsPerChar = 31;
// A maximal single box could occupy 5 numbers at 20 digits (for 64 bit) and a
// space plus the newline 5*(20+1)+1 and the maximum length of a UNICHAR.
// Test against this on each iteration for safety.
const int kMaxCharsPerChar = 106 + UNICHAR_LEN;

// The recognized text is returned as a char* which is coded
// as a UTF8 box file and must be freed with the delete [] operator.
// page_number is a 0-base page index that will appear in the box file.
char* TessBaseAPI::GetBoxText(int page_number)
{
    int bottom = image_height_ - (rect_top_ + rect_height_);

    if (tesseract_ == NULL || (page_res_ == NULL && Recognize(NULL) < 0)) return NULL;

    int blob_count;
    int utf8_length = TextLength(&blob_count);
    int total_length = blob_count*kCharsPerChar + utf8_length + kMaxCharsPerChar;

    PAGE_RES_IT   page_res_it(page_res_);
    char* result = new char[total_length];
    char* ptr = result;
    for (page_res_it.restart_page(); page_res_it.word () != NULL; page_res_it.forward())
    {
        WERD_RES *word = page_res_it.word();
        ptr += ConvertWordToBoxText(word, page_res_it.row(), rect_left_, bottom, image_width_, image_height_, page_number, ptr);

        // Just in case...
        if (ptr - result + kMaxCharsPerChar > total_length) break;
    }

    *ptr = '\0';

    return result;
}

// Conversion table for non-latin characters.
// Maps characters out of the latin set into the latin set.
// TODO(rays) incorporate this translation into unicharset.
const int kUniChs[] =
{
    0x20ac, 0x201c, 0x201d, 0x2018, 0x2019, 0x2022, 0x2014, 0
};

// Latin chars corresponding to the unicode chars above.
const int kLatinChs[] =
{
    0x00a2, 0x0022, 0x0022, 0x0027, 0x0027, 0x00b7, 0x002d, 0
};

// The recognized text is returned as a char* which is coded
// as UNLV format Latin-1 with specific reject and suspect codes
// and must be freed with the delete [] operator.
char* TessBaseAPI::GetUNLVText()
{
    if (tesseract_ == NULL || (page_res_ == NULL && Recognize(NULL) < 0)) return NULL;
    bool tilde_crunch_written = false;
    bool last_char_was_newline = true;
    bool last_char_was_tilde = false;

    int total_length = TextLength(NULL);
    PAGE_RES_IT   page_res_it(page_res_);
    char* result = new char[total_length];
    char* ptr = result;

    for (page_res_it.restart_page(); page_res_it.word () != NULL; page_res_it.forward())
    {
        WERD_RES *word = page_res_it.word();

        // Process the current word.
        if (word->unlv_crunch_mode != CR_NONE)
        {
            if (word->unlv_crunch_mode != CR_DELETE && (!tilde_crunch_written ||
                                                        (word->unlv_crunch_mode == CR_KEEP_SPACE && word->word->space() > 0 &&
                                                         !word->word->flag(W_FUZZY_NON) && !word->word->flag(W_FUZZY_SP))))
            {
                if (!word->word->flag(W_BOL) && word->word->space() > 0 && !word->word->flag(W_FUZZY_NON) && !word->word->flag(W_FUZZY_SP))
                {
                    /* Write a space to separate from preceeding good text */
                    *ptr++ = ' ';
                    last_char_was_tilde = false;
                }

                if (!last_char_was_tilde)
                {
                    // Write a reject char.
                    last_char_was_tilde = true;
                    *ptr++ = kUNLVReject;
                    tilde_crunch_written = true;
                    last_char_was_newline = false;
                }
            }
        }
        else
        {
            // NORMAL PROCESSING of non tilde crunched words.
            tilde_crunch_written = false;

            if (word->word->flag(W_REP_CHAR) && tessedit_consistent_reps) ensure_rep_chars_are_consistent(word);

            tesseract_->set_unlv_suspects(word);
            const char* wordstr = word->best_choice->unichar_string().string();
            const STRING& lengths = word->best_choice->unichar_lengths();
            int length = lengths.length();
            int i = 0;
            int offset = 0;

            if (last_char_was_tilde && word->word->space() == 0 && wordstr[offset] == ' ')
            {
                // Prevent adjacent tilde across words - we know that adjacent tildes
                // within words have been removed.
                // Skip the first character.
                offset = lengths[i++];
            }

            if (i < length && wordstr[offset] != 0)
            {
                if (!last_char_was_newline)
                {
                    *ptr++ = ' ';
                }
                else
                {
                    last_char_was_newline = false;
                }

                for (; i < length; offset += lengths[i++])
                {
                    if (wordstr[offset] == ' ' || wordstr[offset] == kTesseractReject)
                    {
                        *ptr++ = kUNLVReject;
                        last_char_was_tilde = true;
                    }
                    else
                    {
                        if (word->reject_map[i].rejected()) *ptr++ = kUNLVSuspect;
                        UNICHAR ch(wordstr + offset, lengths[i]);
                        int uni_ch = ch.first_uni();

                        for (int j = 0; kUniChs[j] != 0; ++j)
                        {
                            if (kUniChs[j] == uni_ch)
                            {
                                uni_ch = kLatinChs[j];
                                break;
                            }
                        }

                        if (uni_ch <= 0xff)
                        {
                            *ptr++ = static_cast<char>(uni_ch);
                            last_char_was_tilde = false;
                        }
                        else
                        {
                            *ptr++ = kUNLVReject;
                            last_char_was_tilde = true;
                        }
                    }
                }
            }
        }

        if (word->word->flag(W_EOL) && !last_char_was_newline)
        {
            /* Add a new line output */
            *ptr++ = '\n';
            tilde_crunch_written = false;
            last_char_was_newline = true;
            last_char_was_tilde = false;
        }
    }

    *ptr++ = '\n';
    *ptr = '\0';

    return result;
}

// Returns the average word confidence for Tesseract page result.
int TessBaseAPI::MeanTextConf()
{
    int* conf = AllWordConfidences();
    if (!conf) return 0;
    int sum = 0;
    int *pt = conf;

    while (*pt >= 0) sum += *pt++;
    if (pt != conf) sum /= pt - conf;

    delete [] conf;

    return sum;
}

// Returns an array of all word confidences, terminated by -1.
int* TessBaseAPI::AllWordConfidences()
{
    if (tesseract_ == NULL || (page_res_ == NULL && Recognize(NULL) < 0)) return NULL;
    int n_word = 0;

    PAGE_RES_IT res_it(page_res_);
    for (res_it.restart_page(); res_it.word() != NULL; res_it.forward()) n_word++;

    int* conf = new int[n_word+1];
    n_word = 0;

    for (res_it.restart_page(); res_it.word() != NULL; res_it.forward())
    {
        WERD_RES *word = res_it.word();
        WERD_CHOICE* choice = word->best_choice;
        int w_conf = static_cast<int>(100 + 5 * choice->certainty());
        // This is the eq for converting Tesseract confidence to 1..100

        if (w_conf < 0) w_conf = 0;
        if (w_conf > 100) w_conf = 100;
        conf[n_word++] = w_conf;
    }
    conf[n_word] = -1;

    return conf;
}

// Free up recognition results and any stored image data, without actually
// freeing any recognition data that would be time-consuming to reload.
// Afterwards, you must call SetImage or TesseractRect before doing
// any Recognize or Get* operation.
void TessBaseAPI::Clear()
{
    if (thresholder_ != NULL) thresholder_->Clear();

    ClearResults();
    page_image.destroy();
}

// Close down tesseract and free up all memory. End() is equivalent to
// destructing and reconstructing your TessBaseAPI.
// Once End() has been used, none of the other API functions may be used
// other than Init and anything declared above it in the class definition.
void TessBaseAPI::End()
{
    if (thresholder_ != NULL)
    {
        delete thresholder_;
        thresholder_ = NULL;
    }

    if (page_res_ != NULL)
    {
        delete page_res_;
        page_res_ = NULL;
    }

    if (block_list_ != NULL)
    {
        delete block_list_;
        block_list_ = NULL;
    }

    if (tesseract_ != NULL)
    {
        tesseract_->end_tesseract();
        delete tesseract_;
        tesseract_ = NULL;
    }

    if (input_file_ != NULL)
    {
        delete input_file_;
        input_file_ = NULL;
    }

    if (output_file_ != NULL)
    {
        delete output_file_;
        output_file_ = NULL;
    }

    if (datapath_ != NULL)
    {
        delete datapath_;
        datapath_ = NULL;
    }

    if (language_ != NULL)
    {
        delete language_;
        language_ = NULL;
    }
}

// Check whether a word is valid according to Tesseract's language model
// returns 0 if the word is invalid, non-zero if valid
int TessBaseAPI::IsValidWord(const char *word)
{
    return tesseract_->getDict().valid_word(word);
}


bool TessBaseAPI::GetTextDirection(int* out_offset, float* out_slope)
{
    if (page_res_ == NULL) FindLines();

    if (block_list_->length() < 1)
    {
        return false;
    }

    // Get first block
    BLOCK_IT block_it(block_list_);
    block_it.move_to_first();
    ROW_LIST* rows = block_it.data()->row_list();

    if (rows->length() != 1)
    {
        return false;
    }

    // Get first line of block
    ROW_IT row_it(rows);
    row_it.move_to_first();
    ROW* row = row_it.data();

    // Calculate offset and slope (NOTE: Kind of ugly)
    *out_offset = static_cast<int>(row->base_line(0.0));
    *out_slope = row->base_line(1.0) - row->base_line(0.0);

    return true;
}

// Set the letter_is_okay function to point somewhere else.
void TessBaseAPI::SetDictFunc(DictFunc f)
{
    if (tesseract_ != NULL)
    {
        tesseract_->getDict().letter_is_okay_ = f;
    }
}

// Common code for setting the image.
bool TessBaseAPI::InternalSetImage()
{
    if (tesseract_ == NULL)
    {
        tprintf("Please call Init before attempting to send an image.");
        return false;
    }

    if (thresholder_ == NULL) thresholder_ = new ImageThresholder;
    ClearResults();

    return true;
}

// Run the thresholder to make the thresholded image. If pix is not NULL,
// the source is thresholded to pix instead of the internal IMAGE.
void TessBaseAPI::Threshold(Pix** pix)
{
    Q_UNUSED(pix);
    #ifdef HAVE_LIBLEPT
    if (pix != NULL)
    {
        thresholder_->ThresholdToPix(pix);
    }
    else
    {
        thresholder_->ThresholdToIMAGE(&page_image);
    }
    #else
    thresholder_->ThresholdToIMAGE(&page_image);
    #endif
    thresholder_->GetImageSizes(&rect_left_, &rect_top_, &rect_width_, &rect_height_, &image_width_, &image_height_);
    threshold_done_ = true;
}

// Find lines from the image making the BLOCK_LIST.
int TessBaseAPI::FindLines()
{
    if (!block_list_->empty())
    {
        return 0;
    }

    if (tesseract_ == NULL)
    {
        tesseract_ = new Tesseract;
        tesseract_->InitAdaptiveClassifier();
    }

    #ifdef HAVE_LIBLEPT
    if (tesseract_->pix_binary() == NULL) Threshold(tesseract_->mutable_pix_binary());
    #endif
    if (!threshold_done_) Threshold(NULL);

    if (tesseract_->SegmentPage(input_file_, &page_image, block_list_) < 0) return -1;

    ASSERT_HOST(page_image.get_xsize() == rect_width_ ||page_image.get_xsize() == rect_width_ - 1);
    ASSERT_HOST(page_image.get_ysize() == rect_height_ ||page_image.get_ysize() == rect_height_ - 1);

    return 0;
}

// Delete the pageres and clear the block list ready for a new page.
void TessBaseAPI::ClearResults()
{
    threshold_done_ = false;
    if (tesseract_ != NULL) tesseract_->Clear();
    if (page_res_ != NULL)
    {
        delete page_res_;
        page_res_ = NULL;
    }

    if (block_list_ == NULL)
    {
        block_list_ = new BLOCK_LIST;
    }
    else
    {
        block_list_->clear();
    }
}

// Return the length of the output text string, as UTF8, assuming
// one newline per line and one per block, with a terminator,
// and assuming a single character reject marker for each rejected character.
// Also return the number of recognized blobs in blob_count.
int TessBaseAPI::TextLength(int* blob_count)
{
    if (tesseract_ == NULL || page_res_ == NULL) return 0;

    PAGE_RES_IT   page_res_it(page_res_);
    int total_length = 2;
    int total_blobs = 0;

    // Iterate over the data structures to extract the recognition result.
    for (page_res_it.restart_page(); page_res_it.word () != NULL; page_res_it.forward())
    {
        WERD_RES *word = page_res_it.word();
        WERD_CHOICE* choice = word->best_choice;

        if (choice != NULL)
        {
            total_blobs += choice->length() + 1;
            total_length += choice->unichar_string().length() + 1;

            for (int i = 0; i < word->reject_map.length(); ++i)
            {
                if (word->reject_map[i].rejected()) ++total_length;
            }
        }
    }
    if (blob_count != NULL) *blob_count = total_blobs;

    return total_length;
}

// Estimates the Orientation And Script of the image.
// Returns true if the image was processed successfully.
bool TessBaseAPI::DetectOS(OSResults* osr)
{
    if (tesseract_ == NULL) return false;
    ClearResults();
    Threshold(NULL);

    if (input_file_ == NULL) input_file_ = new STRING(kInputFile);

    return orientation_and_script_detection(*input_file_, osr, tesseract_);
}

// ____________________________________________________________________________
// Ocropus add-ons.

// Find lines from the image making the BLOCK_LIST.
BLOCK_LIST* TessBaseAPI::FindLinesCreateBlockList()
{
    FindLines();
    BLOCK_LIST* result = block_list_;
    block_list_ = NULL;
    return result;
}

// Delete a block list.
// This is to keep BLOCK_LIST pointer opaque
// and let go of including the other headers.
void TessBaseAPI::DeleteBlockList(BLOCK_LIST *block_list)
{
    delete block_list;
}


static ROW *make_tess_ocrrow(float baseline, float xheight,float descender, float ascender)
{
    inT32 xstarts[] = {-32000};
    double quad_coeffs[] = {0, 0, baseline};

    return new ROW(1, xstarts, quad_coeffs, xheight, ascender - (baseline + xheight), descender - baseline, 0, 0);
}

// Almost a copy of make_tess_row() from ccmain/tstruct.cpp.
static void fill_dummy_row(float baseline, float xheight, float descender, float ascender, TEXTROW* tessrow)
{
    tessrow->baseline.segments = 1;
    tessrow->baseline.xstarts[0] = -32767;
    tessrow->baseline.xstarts[1] = 32767;
    tessrow->baseline.quads[0].a = 0;
    tessrow->baseline.quads[0].b = 0;
    tessrow->baseline.quads[0].c = bln_baseline_offset;
    tessrow->xheight.segments = 1;
    tessrow->xheight.xstarts[0] = -32767;
    tessrow->xheight.xstarts[1] = 32767;
    tessrow->xheight.quads[0].a = 0;
    tessrow->xheight.quads[0].b = 0;
    tessrow->xheight.quads[0].c = bln_baseline_offset + bln_x_height;
    tessrow->lineheight = bln_x_height;
    tessrow->ascrise = bln_x_height * (ascender - (xheight + baseline)) / xheight;
    tessrow->descdrop = bln_x_height * (descender - baseline) / xheight;
}


// Return a TBLOB * from the whole page_image.
// To be freed later with free_blob().
TBLOB *make_tesseract_blob(float baseline, float xheight, float descender, float ascender)
{
    BLOCK *block = new BLOCK("a character", TRUE, 0, 0, 0, 0, page_image.get_xsize(), page_image.get_ysize());

    // Create C_BLOBs from the page
    extract_edges(NULL, &page_image, &page_image, ICOORD(page_image.get_xsize(), page_image.get_ysize()), block);

    // Create one PBLOB from all C_BLOBs
    C_BLOB_LIST *list = block->blob_list();
    C_BLOB_IT c_blob_it(list);
    PBLOB *pblob = new PBLOB;  // will be (hopefully) deleted by the pblob_list

    for (c_blob_it.mark_cycle_pt(); !c_blob_it.cycled_list(); c_blob_it.forward())
    {
        C_BLOB *c_blob = c_blob_it.data();
        PBLOB c_as_p(c_blob, baseline + xheight);
        merge_blobs(pblob, &c_as_p);
    }

    PBLOB_LIST *pblob_list = new PBLOB_LIST;  // will be deleted by the word
    PBLOB_IT pblob_it(pblob_list);
    pblob_it.add_after_then_move(pblob);

    // Normalize PBLOB
    WERD word(pblob_list, 0, " ");
    ROW *row = make_tess_ocrrow(baseline, xheight, descender, ascender);
    word.baseline_normalise(row);
    delete row;

    // Create a TBLOB from PBLOB
    return make_tess_blob(pblob, /* flatten: */ TRUE);
}


// Adapt to recognize the current image as the given character.
// The image must be preloaded and be just an image of a single character.
void TessBaseAPI::AdaptToCharacter(const char *unichar_repr, int length, float baseline, float xheight, float descender, float ascender)
{
    UNICHAR_ID id = tesseract_->unicharset.unichar_to_id(unichar_repr, length);
    LINE_STATS LineStats;
    TEXTROW row;
    fill_dummy_row(baseline, xheight, descender, ascender, &row);
    GetLineStatsFromRow(&row, &LineStats);

    TBLOB *blob = make_tesseract_blob(baseline, xheight, descender, ascender);
    float threshold;
    UNICHAR_ID best_class = 0;
    float best_rating = -100;

    // Classify to get a raw choice.
    BLOB_CHOICE_LIST choices;
    tesseract_->AdaptiveClassifier(blob, NULL, &row, &choices, NULL);
    BLOB_CHOICE_IT choice_it;
    choice_it.set_to_list(&choices);

    for (choice_it.mark_cycle_pt(); !choice_it.cycled_list(); choice_it.forward())
    {
        if (choice_it.data()->rating() > best_rating)
        {
            best_rating = choice_it.data()->rating();
            best_class = choice_it.data()->unichar_id();
        }
    }

    if (id == best_class)
    {
        threshold = matcher_good_threshold;
    }
    else
    {
        /* the blob was incorrectly classified - find the rating threshold
           needed to create a template which will correct the error with
           some margin.  However, don't waste time trying to make
           templates which are too tight. */
        threshold = tesseract_->GetBestRatingFor(blob, &LineStats, id);
        threshold *= .9;
        const float max_threshold = .125;
        const float min_threshold = .02;

        if (threshold > max_threshold) threshold = max_threshold;

        // I have cuddled the following line to set it out of the strike
        // of the coverage testing tool. I have no idea how to trigger
        // this situation nor I have any necessity to do it. --mezhirov
        if (threshold < min_threshold) threshold = min_threshold;
    }

    if (blob->outlines) tesseract_->AdaptToChar(blob, &LineStats, id, threshold);
    free_blob(blob);
}


PAGE_RES* TessBaseAPI::RecognitionPass1(BLOCK_LIST* block_list)
{
    PAGE_RES *page_res = new PAGE_RES(block_list);
    tesseract_->recog_all_words(page_res, NULL, NULL, 1);

    return page_res;
}

PAGE_RES* TessBaseAPI::RecognitionPass2(BLOCK_LIST* block_list, PAGE_RES* pass1_result)
{
    if (!pass1_result) pass1_result = new PAGE_RES(block_list);
    tesseract_->recog_all_words(pass1_result, NULL, NULL, 2);

    return pass1_result;
}

struct TESS_CHAR : ELIST_LINK
{
    char *unicode_repr;
    int length;  // of unicode_repr
    float cost;
    TBOX box;

    TESS_CHAR(float _cost, const char *repr, int len = -1) : cost(_cost)
    {
        length = (len == -1 ? strlen(repr) : len);
        unicode_repr = new char[length + 1];
        strncpy(unicode_repr, repr, length);
    }

    TESS_CHAR()
    {  // Satisfies ELISTIZE.
    }

    ~TESS_CHAR()
    {
        delete [] unicode_repr;
    }
};

ELISTIZEH(TESS_CHAR)
ELISTIZE(TESS_CHAR)

static void add_space(TESS_CHAR_IT* it)
{
    TESS_CHAR *t = new TESS_CHAR(0, " ");
    it->add_after_then_move(t);
}

static float rating_to_cost(float rating)
{
    rating = 100 + 5*rating;
    // cuddled that to save from coverage profiler
    // (I have never seen ratings worse than -100,
    //  but the check won't hurt)
    if (rating < 0) rating = 0;

    return rating;
}


// Extract the OCR results, costs (penalty points for uncertainty),
// and the bounding boxes of the characters.
static void extract_result(TESS_CHAR_IT* out, PAGE_RES* page_res)
{
    PAGE_RES_IT page_res_it(page_res);
    int word_count = 0;

    while (page_res_it.word() != NULL)
    {
        WERD_RES *word = page_res_it.word();
        const char *str = word->best_choice->unichar_string().string();
        const char *len = word->best_choice->unichar_lengths().string();

        if (word_count) add_space(out);
        TBOX bln_rect;
        PBLOB_LIST *blobs = word->outword->blob_list();
        PBLOB_IT it(blobs);
        int n = strlen(len);
        TBOX** boxes_to_fix = new TBOX*[n];

        for (int i = 0; i < n; i++)
        {
            PBLOB *blob = it.data();
            TBOX current = blob->bounding_box();
            bln_rect = bln_rect.bounding_union(current);
            TESS_CHAR *tc = new TESS_CHAR(rating_to_cost(word->best_choice->certainty()), str, *len);
            tc->box = current;
            boxes_to_fix[i] = &tc->box;

            out->add_after_then_move(tc);
            it.forward();
            str += *len;
            len++;
        }

        // Find the word bbox before normalization.
        // Here we can't use the C_BLOB bboxes directly,
        // since connected letters are not yet cut.
        TBOX real_rect = word->word->bounding_box();

        // Denormalize boxes by transforming the bbox of the whole bln word
        // into the denorm bbox (`real_rect') of the whole word.
        double x_stretch = static_cast<double>(real_rect.width()) / bln_rect.width();
        double y_stretch = static_cast<double>(real_rect.height()) / bln_rect.height();

        for (int j = 0; j < n; j++)
        {
            TBOX *box = boxes_to_fix[j];
            int x0 = static_cast<int>(real_rect.left() + x_stretch * (box->left() - bln_rect.left()) + 0.5);
            int x1 = static_cast<int>(real_rect.left() + x_stretch * (box->right() - bln_rect.left()) + 0.5);
            int y0 = static_cast<int>(real_rect.bottom() +y_stretch * (box->bottom() - bln_rect.bottom()) + 0.5);
            int y1 = static_cast<int>(real_rect.bottom() +y_stretch * (box->top() - bln_rect.bottom()) + 0.5);
            *box = TBOX(ICOORD(x0, y0), ICOORD(x1, y1));
        }
        delete [] boxes_to_fix;

        page_res_it.forward();
        word_count++;
    }
}


// Extract the OCR results, costs (penalty points for uncertainty),
// and the bounding boxes of the characters.
int TessBaseAPI::TesseractExtractResult(char** text, int** lengths, float** costs, int** x0, int** y0, int** x1,int** y1, PAGE_RES* page_res)
{
    TESS_CHAR_LIST tess_chars;
    TESS_CHAR_IT tess_chars_it(&tess_chars);
    extract_result(&tess_chars_it, page_res);
    tess_chars_it.move_to_first();

    int n = tess_chars.length();
    int text_len = 0;
    *lengths = new int[n];
    *costs = new float[n];
    *x0 = new int[n];
    *y0 = new int[n];
    *x1 = new int[n];
    *y1 = new int[n];

    int i = 0;
    for (tess_chars_it.mark_cycle_pt(); !tess_chars_it.cycled_list(); tess_chars_it.forward(), i++)
    {
        TESS_CHAR *tc = tess_chars_it.data();
        text_len += (*lengths)[i] = tc->length;
        (*costs)[i] = tc->cost;
        (*x0)[i] = tc->box.left();
        (*y0)[i] = tc->box.bottom();
        (*x1)[i] = tc->box.right();
        (*y1)[i] = tc->box.top();
    }
    char *p = *text = new char[text_len];

    tess_chars_it.move_to_first();
    for (tess_chars_it.mark_cycle_pt(); !tess_chars_it.cycled_list(); tess_chars_it.forward())
    {
        TESS_CHAR *tc = tess_chars_it.data();
        strncpy(p, tc->unicode_repr, tc->length);
        p += tc->length;
    }

    return n;
}

// This method returns the features associated with the current image.
// Make sure setimage has been called before calling this method.
void TessBaseAPI::GetFeatures(INT_FEATURE_ARRAY int_features, int* num_features)
{
    if (page_res_ != NULL) ClearResults();
    if (!threshold_done_) Threshold(NULL);

    // We have only one block, which is of the size of the page.
    BLOCK_LIST* blocks = new BLOCK_LIST;
    BLOCK *block = new BLOCK("",                       // filename.
                             TRUE,                     // proportional.
                             0,                        // kerning.
                             0,                        // spacing.
                             0,                        // Left.
                             0,                        // Bottom.
                             page_image.get_xsize(),   // Right.
                             page_image.get_ysize());  // Top.

    ICOORD bleft, tright;
    block->bounding_box (bleft, tright);

    BLOCK_IT block_it_add = blocks;
    block_it_add.add_to_end(block);

    ICOORD page_tr(page_image.get_xsize(), page_image.get_ysize());
    TEXTROW tessrow;

    // Denormalizer.    // Output row.
    make_tess_row(NULL,               &tessrow);

    LINE_STATS line_stats;
    GetLineStatsFromRow(&tessrow, &line_stats);

    // Perform a CC analysis to detect the blobs.
    BLOCK_IT block_it = blocks;
    for (block_it.mark_cycle_pt (); !block_it.cycled_list (); block_it.forward ())
    {
        BLOCK* block = block_it.data();

#ifndef GRAPHICS_DISABLED
        extract_edges(NULL,         // Scrollview window.
                      &page_image,  // Image.
                      &page_image,  // Thresholded image.
                      page_tr,      // corner of page.
                      block);       // block.
#else
        extract_edges(&page_image,  // Image.
                      &page_image,  // Thresholded image.
                      page_tr,      // corner of page.
                      block);       // block.
#endif
        C_BLOB_IT blob_it = block->blob_list();
        PBLOB *pblob = new PBLOB;

        // Iterate over all blobs found and get their features.
        for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward())
        {
            C_BLOB* blob = blob_it.data();
            blob = blob;
            PBLOB c_as_p(blob, page_image.get_ysize());
            merge_blobs(pblob, &c_as_p);
        }

        PBLOB_LIST *pblob_list = new PBLOB_LIST;
        PBLOB_IT pblob_it(pblob_list);
        pblob_it.add_after_then_move(pblob);

        // Blob list. // Blanks in front. // Correct text.
        WERD word(pblob_list,   0,                  " ");

        ROW *row = make_tess_ocrrow(0,                       // baseline.
                                    page_image.get_ysize(),  // xheight.
                                    0,                       // ascent.
                                    0);                      // descent.

        word.baseline_normalise(row);
        delete row;

        if (pblob->out_list () == NULL)
        {
            tprintf("Blob list is empty");
        }
        // Blob.  // Flatten.
        TBLOB* tblob = make_tess_blob(pblob,    TRUE);

        CLASS_NORMALIZATION_ARRAY norm_array;
        inT32 len;

        *num_features = tesseract_->GetCharNormFeatures(tblob, &line_stats, tesseract_->PreTrainedTemplates, int_features, norm_array, &len);
    }

    delete blocks;
}

// Return the pointer to the i-th dawg loaded into tesseract_ object.
const Dawg *TessBaseAPI::GetDawg(int i) const
{
    if (tesseract_ == NULL || i >= NumDawgs()) return NULL;

    return tesseract_->getDict().GetDawg(i);
}

// Return the number of dawgs loaded into tesseract_ object.
int TessBaseAPI::NumDawgs() const
{
    return tesseract_ == NULL ? 0 : tesseract_->getDict().NumDawgs();
}

// Return the language used in the last valid initialization.
const char* TessBaseAPI::GetLastInitLanguage() const
{
    return (tesseract_ == NULL || tesseract_->lang.string() == NULL) ?"" : tesseract_->lang.string();
}
/////////////////////////////////////////////////////////////////TessBaseAPI/////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////TessdataManager/////////////////////////////////
BOOL_VAR(global_load_system_dawg, true, "Load system word dawg.");
BOOL_VAR(global_load_freq_dawg, true, "Load frequent word dawg.");
BOOL_VAR(global_load_punc_dawg, true, "Load dawg with punctuation patterns.");
BOOL_VAR(global_load_number_dawg, true, "Load dawg with number patterns.");

INT_VAR(global_tessdata_manager_debug_level, 0, "Debug level for TessdataManager functions.");

void TessdataManager::Init(const char *data_file_name)
{
    int i;
    data_file_ = fopen(data_file_name, "rb");
    if (data_file_ == NULL)
    {
        tprintf("Error openning data file %s\n", data_file_name);
        exit(1);
    }

    fread(&actual_tessdata_num_entries_, sizeof(inT32), 1, data_file_);
    bool swap = (actual_tessdata_num_entries_ > kMaxNumTessdataEntries);

    if (swap)
    {
        actual_tessdata_num_entries_ = reverse32(actual_tessdata_num_entries_);
    }

    ASSERT_HOST(actual_tessdata_num_entries_ <= TESSDATA_NUM_ENTRIES);
    fread(offset_table_, sizeof(inT64), actual_tessdata_num_entries_, data_file_);
    if (swap)
    {
        for (i = 0 ; i < actual_tessdata_num_entries_; ++i)
        {
            offset_table_[i] = reverse64(offset_table_[i]);
        }
    }

    if (global_tessdata_manager_debug_level)
    {
        tprintf("TessdataManager loaded %d types of tesseract data files.\n", actual_tessdata_num_entries_);

        for (i = 0; i < actual_tessdata_num_entries_; ++i)
        {
            tprintf("Offset for type %d is %lld\n", i, offset_table_[i]);
        }
    }
}

void TessdataManager::CopyFile(FILE *input_file, FILE *output_file, bool newline_end, inT64 num_bytes_to_copy)
{
    if (num_bytes_to_copy == 0) return;
    int buffer_size = 1024;

    if (num_bytes_to_copy > 0 && buffer_size > num_bytes_to_copy)
    {
        buffer_size = num_bytes_to_copy;
    }

    inT64 num_bytes_copied = 0;
    char *chunk = new char[buffer_size];
    int bytes_read;
    char last_char = 0x0;

    while ((bytes_read = fread(chunk, sizeof(char), buffer_size, input_file)))
    {
        fwrite(chunk, sizeof(char), bytes_read, output_file);
        last_char = chunk[bytes_read-1];

        if (num_bytes_to_copy > 0)
        {
            num_bytes_copied += bytes_read;
            if (num_bytes_copied == num_bytes_to_copy) break;

            if (num_bytes_copied + buffer_size > num_bytes_to_copy)
            {
                buffer_size = num_bytes_to_copy - num_bytes_copied;
            }
        }
    }

    if (newline_end) ASSERT_HOST(last_char == '\n');

    delete[] chunk;
}

void TessdataManager::WriteMetadata(inT64 *offset_table, FILE *output_file)
{
    fseek(output_file, 0, SEEK_SET);
    inT32 num_entries = TESSDATA_NUM_ENTRIES;
    fwrite(&num_entries, sizeof(inT32), 1, output_file);
    fwrite(offset_table, sizeof(inT64), TESSDATA_NUM_ENTRIES, output_file);
    fclose(output_file);

    tprintf("TessdataManager combined tesseract data files.\n");

    for (int i = 0; i < TESSDATA_NUM_ENTRIES; ++i)
    {
        tprintf("Offset for type %d is %lld\n", i, offset_table[i]);
    }
}

bool TessdataManager::CombineDataFiles( const char *language_data_path_prefix, const char *output_filename)
{
    int i;
    inT64 offset_table[TESSDATA_NUM_ENTRIES];
    for (i = 0; i < TESSDATA_NUM_ENTRIES; ++i) offset_table[i] = -1;
    FILE *output_file = fopen(output_filename, "wb");

    if (output_file == NULL)
    {
        tprintf("Error opening %s for writing\n", output_filename);

        return false;
    }
    // Leave some space for recording the offset_table.
    fseek(output_file, sizeof(inT32) + sizeof(inT64) * TESSDATA_NUM_ENTRIES, SEEK_SET);

    TessdataType type;
    bool text_file;
    FILE *file_ptr[TESSDATA_NUM_ENTRIES];

    // Load individual tessdata components from files.
    for (i = 0; i < TESSDATA_NUM_ENTRIES; ++i)
    {
        ASSERT_HOST(TessdataTypeFromFileSuffix(kTessdataFileSuffixes[i], &type, &text_file));

        STRING filename = language_data_path_prefix;
        filename += kTessdataFileSuffixes[i];
        file_ptr[i] =  fopen(filename.string(), text_file ? "r" : "rb");

        if (file_ptr[i] != NULL)
        {
            offset_table[type] = ftell(output_file);
            CopyFile(file_ptr[i], output_file, text_file, -1);
            fclose(file_ptr[i]);
        }
    }

    // Make sure that the required components are present.
    if (file_ptr[TESSDATA_UNICHARSET] == NULL)
    {
        tprintf("Error opening unicharset file\n");
        fclose(output_file);

        return false;
    }

    if (file_ptr[TESSDATA_INTTEMP] != NULL && (file_ptr[TESSDATA_PFFMTABLE] == NULL || file_ptr[TESSDATA_NORMPROTO] == NULL))
    {
        tprintf("Error opening pffmtable and/or normproto files" " while inttemp file was present\n");
        fclose(output_file);

        return false;
    }

    WriteMetadata(offset_table, output_file);

    return true;
}

bool TessdataManager::OverwriteComponents(const char *new_traineddata_filename, char **component_filenames, int num_new_components)
{
    int i;
    inT64 offset_table[TESSDATA_NUM_ENTRIES];
    TessdataType type;
    bool text_file;
    FILE *file_ptr[TESSDATA_NUM_ENTRIES];

    for (i = 0; i < TESSDATA_NUM_ENTRIES; ++i)
    {
        offset_table[i] = -1;
        file_ptr[i] = NULL;
    }

    FILE *output_file = fopen(new_traineddata_filename, "wb");
    if (output_file == NULL)
    {
        tprintf("Error opening %s for writing\n", new_traineddata_filename);

        return false;
    }

    // Leave some space for recording the offset_table.
    fseek(output_file, sizeof(inT32) + sizeof(inT64) * TESSDATA_NUM_ENTRIES, SEEK_SET);

    // Open the files with the new components.
    for (i = 0; i < num_new_components; ++i)
    {
        TessdataTypeFromFileName(component_filenames[i], &type, &text_file);
        file_ptr[type] = fopen(component_filenames[i], text_file ? "r" : "rb");
    }

    // Write updated data to the output traineddata file.
    for (i = 0; i < TESSDATA_NUM_ENTRIES; ++i)
    {
        if (file_ptr[i] != NULL)
        {
            // Get the data from the opened component file.
            offset_table[i] = ftell(output_file);
            CopyFile(file_ptr[i], output_file, kTessdataFileIsText[i], -1);
            fclose(file_ptr[i]);
        }
        else
        {
            // Get this data component from the loaded data file.
            if (SeekToStart(static_cast<TessdataType>(i)))
            {
                offset_table[i] = ftell(output_file);
                CopyFile(data_file_, output_file, kTessdataFileIsText[i], GetEndOffset(static_cast<TessdataType>(i)) - ftell(data_file_) + 1);
            }
        }
    }

    WriteMetadata(offset_table, output_file);

    return true;
}

bool TessdataManager::TessdataTypeFromFileSuffix(const char *suffix, TessdataType *type, bool *text_file)
{
    for (int i = 0; i < TESSDATA_NUM_ENTRIES; ++i)
    {
        if (strcmp(kTessdataFileSuffixes[i], suffix) == 0)
        {
            *type = static_cast<TessdataType>(i);
            *text_file = kTessdataFileIsText[i];

            return true;
        }
    }

    printf("TessdataManager can't determine which tessdata" " component is represented by %s\n", suffix);

    return false;
}

bool TessdataManager::TessdataTypeFromFileName(const char *filename, TessdataType *type, bool *text_file)
{
    // Get the file suffix (extension)
    const char *suffix = strrchr(filename, '.');
    if (suffix == NULL || *(++suffix) == '\0') return false;

    return TessdataTypeFromFileSuffix(suffix, type, text_file);
}

bool TessdataManager::ExtractToFile(const char *filename)
{
    TessdataType type;
    bool text_file;
    ASSERT_HOST(TessdataManager::TessdataTypeFromFileName(filename, &type, &text_file));
    if (!SeekToStart(type)) return false;

    FILE *output_file = fopen(filename, "wb");
    if (output_file == NULL)
    {
        printf("Error openning %s\n", filename);
        exit(1);
    }

    inT64 begin_offset = ftell(GetDataFilePtr());
    inT64 end_offset = GetEndOffset(type);
    TessdataManager::CopyFile(GetDataFilePtr(), output_file, text_file, end_offset - begin_offset + 1);
    fclose(output_file);

    return true;
}
/////////////////////////////////////////////////////////////////TessdataManager/////////////////////////////////

/////////////////////////////////////////////////////////////////unichar/////////////////////////////////
#define UNI_MAX_LEGAL_UTF32 0x0010FFFF

// Construct from a utf8 string. If len<0 then the string is null terminated.
// If the string is too long to fit in the UNICHAR then it takes only what
// will fit. Checks for illegal input and stops at an illegal sequence.
// The resulting UNICHAR may be empty.
UNICHAR::UNICHAR(const char* utf8_str, int len) {
  int total_len = 0;
  int step = 0;
  if (len < 0) {
    for (len = 0; utf8_str[len] != 0 && len < UNICHAR_LEN; ++len);
  }
  for (total_len = 0; total_len < len; total_len += step) {
    step = utf8_step(utf8_str + total_len);
    if (total_len + step > UNICHAR_LEN)
      break;  // Too long.
    if (step == 0)
      break;  // Illegal first byte.
    int i;
    for (i = 1; i < step; ++i)
      if ((utf8_str[total_len + i] & 0xc0) != 0x80)
        break;
    if (i < step)
      break;  // Illegal surrogate
  }
  memcpy(chars, utf8_str, total_len);
  if (total_len < UNICHAR_LEN) {
    chars[UNICHAR_LEN - 1] = total_len;
    while (total_len < UNICHAR_LEN - 1)
      chars[total_len++] = 0;
  }
}

// Construct from a single UCS4 character. Illegal values are ignored,
// resulting in an empty UNICHAR.
UNICHAR::UNICHAR(int unicode) {
  const int bytemask = 0xBF;
  const int bytemark = 0x80;

  if (unicode < 0x80) {
    chars[UNICHAR_LEN - 1] = 1;
    chars[2] = 0;
    chars[1] = 0;
    chars[0] = static_cast<char>(unicode);
  } else if (unicode < 0x800) {
    chars[UNICHAR_LEN - 1] = 2;
    chars[2] = 0;
    chars[1] = static_cast<char>((unicode | bytemark) & bytemask);
    unicode >>= 6;
    chars[0] = static_cast<char>(unicode | 0xc0);
  } else if (unicode < 0x10000) {
    chars[UNICHAR_LEN - 1] = 3;
    chars[2] = static_cast<char>((unicode | bytemark) & bytemask);
    unicode >>= 6;
    chars[1] = static_cast<char>((unicode | bytemark) & bytemask);
    unicode >>= 6;
    chars[0] = static_cast<char>(unicode | 0xe0);
  } else if (unicode <= UNI_MAX_LEGAL_UTF32) {
    chars[UNICHAR_LEN - 1] = 4;
    chars[3] = static_cast<char>((unicode | bytemark) & bytemask);
    unicode >>= 6;
    chars[2] = static_cast<char>((unicode | bytemark) & bytemask);
    unicode >>= 6;
    chars[1] = static_cast<char>((unicode | bytemark) & bytemask);
    unicode >>= 6;
    chars[0] = static_cast<char>(unicode | 0xf0);
  } else {
    memset(chars, 0, UNICHAR_LEN);
  }
}

// Get the first character as UCS-4.
int UNICHAR::first_uni() const {
  static const int utf8_offsets[5] = {
    0, 0, 0x3080, 0xE2080, 0x3C82080
  };
  int uni = 0;
  int len = utf8_step(chars);
  const char* src = chars;

  switch (len) {
  default:
    break;
  case 4:
    uni += static_cast<unsigned char>(*src++);
    uni <<= 6;
  case 3:
    uni += static_cast<unsigned char>(*src++);
    uni <<= 6;
  case 2:
    uni += static_cast<unsigned char>(*src++);
    uni <<= 6;
  case 1:
    uni += static_cast<unsigned char>(*src++);
  }
  uni -= utf8_offsets[len];
  return uni;
}

// Get a terminated UTF8 string: Must delete[] it after use.
char* UNICHAR::utf8_str() const {
  int len = utf8_len();
  char* str = new char[len + 1];
  memcpy(str, chars, len);
  str[len] = 0;
  return str;
}

// Get the number of bytes in the first character of the given utf8 string.
int UNICHAR::utf8_step(const char* utf8_str) {
  static const char utf8_bytes[256] = {
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3, 4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0
  };

  return utf8_bytes[static_cast<unsigned char>(*utf8_str)];
}
/////////////////////////////////////////////////////////////////unichar/////////////////////////////////

/////////////////////////////////////////////////////////////////UNICHARMAP/////////////////////////////////
UNICHARMAP::UNICHARMAP() :
nodes(0) {
}

UNICHARMAP::~UNICHARMAP() {
  if (nodes != 0)
    delete[] nodes;
}

// Search the given unichar representation in the tree. Each character in the
// string is interpreted as an index in an array of nodes.
UNICHAR_ID UNICHARMAP::unichar_to_id(const char* const unichar_repr) const {
  const char* current_char = unichar_repr;
  UNICHARMAP_NODE* current_nodes = nodes;

  assert(*unichar_repr != '\0');

  do {
    if (*(current_char + 1) == '\0')
      return current_nodes[static_cast<unsigned char>(*current_char)].id;
    current_nodes =
        current_nodes[static_cast<unsigned char>(*current_char)].children;
    ++current_char;
  } while (true);
}

// Search the given unichar representation in the tree, using length characters
// from it maximum. Each character in the string is interpreted as an index in
// an array of nodes.
UNICHAR_ID UNICHARMAP::unichar_to_id(const char* const unichar_repr,
                                     int length) const {
  const char* current_char = unichar_repr;
  UNICHARMAP_NODE* current_nodes = nodes;

  assert(*unichar_repr != '\0');
  assert(length > 0 && length <= UNICHAR_LEN);

  do {
    if (length == 1 || *(current_char + 1) == '\0')
      return current_nodes[static_cast<unsigned char>(*current_char)].id;
    current_nodes =
        current_nodes[static_cast<unsigned char>(*current_char)].children;
    ++current_char;
    --length;
  } while (true);
}

// Search the given unichar representation in the tree, creating the possibly
// missing nodes. Once the right place has been found, insert the given id and
// update the inserted flag to keep track of the insert. Each character in the
// string is interpreted as an index in an array of nodes.
void UNICHARMAP::insert(const char* const unichar_repr, UNICHAR_ID id) {
  const char* current_char = unichar_repr;
  UNICHARMAP_NODE** current_nodes_pointer = &nodes;

  assert(*unichar_repr != '\0');
  assert(id >= 0);

  do {
    if (*current_nodes_pointer == 0)
      *current_nodes_pointer = new UNICHARMAP_NODE[256];
    if (*(current_char + 1) == '\0') {
      (*current_nodes_pointer)
          [static_cast<unsigned char>(*current_char)].id = id;
      return;
    }
    current_nodes_pointer =
        &((*current_nodes_pointer)
          [static_cast<unsigned char>(*current_char)].children);
    ++current_char;
  } while (true);
}

// Search the given unichar representation in the tree. Each character in the
// string is interpreted as an index in an array of nodes. Stop once the tree
// does not have anymore nodes or once we found the right unichar_repr.
bool UNICHARMAP::contains(const char* const unichar_repr) const {
  const char* current_char = unichar_repr;
  UNICHARMAP_NODE* current_nodes = nodes;

  assert(*unichar_repr != '\0');

  while (current_nodes != 0 && *(current_char + 1) != '\0') {
    current_nodes =
        current_nodes[static_cast<unsigned char>(*current_char)].children;
    ++current_char;
  }
  return current_nodes != 0 && *(current_char + 1) == '\0' &&
      current_nodes[static_cast<unsigned char>(*current_char)].id >= 0;
}

// Search the given unichar representation in the tree, using length characters
// from it maximum. Each character in the string is interpreted as an index in
// an array of nodes. Stop once the tree does not have anymore nodes or once we
// found the right unichar_repr.
bool UNICHARMAP::contains(const char* const unichar_repr,
                          int length) const {
  const char* current_char = unichar_repr;
  UNICHARMAP_NODE* current_nodes = nodes;

  assert(*unichar_repr != '\0');
  assert(length > 0 && length <= UNICHAR_LEN);

  while (current_nodes != 0 && (length > 1 && *(current_char + 1) != '\0')) {
    current_nodes =
        current_nodes[static_cast<unsigned char>(*current_char)].children;
    --length;
    ++current_char;
  }
  return current_nodes != 0 && (length == 1 || *(current_char + 1) == '\0') &&
      current_nodes[static_cast<unsigned char>(*current_char)].id >= 0;
}

// Return the minimum number of characters that must be used from this string
// to obtain a match in the UNICHARMAP.
int UNICHARMAP::minmatch(const char* const unichar_repr) const {
  const char* current_char = unichar_repr;
  UNICHARMAP_NODE* current_nodes = nodes;

  while (current_nodes != NULL && *current_char != '\0') {
    if (current_nodes[static_cast<unsigned char>(*current_char)].id >= 0)
      return current_char + 1 - unichar_repr;
    current_nodes =
        current_nodes[static_cast<unsigned char>(*current_char)].children;
    ++current_char;
  }
  return 0;
}

void UNICHARMAP::clear() {
  if (nodes != 0)
  {
    delete[] nodes;
    nodes = 0;
  }
}

UNICHARMAP::UNICHARMAP_NODE::UNICHARMAP_NODE() :
children(0),
id(-1) {
}

// Recursively delete the children
UNICHARMAP::UNICHARMAP_NODE::~UNICHARMAP_NODE() {
  if (children != 0) {
    delete[] children;
  }
}
/////////////////////////////////////////////////////////////////UNICHARMAP/////////////////////////////////

/////////////////////////////////////////////////////////////////UNICHARSET/////////////////////////////////
static const int ISALPHA_MASK = 0x1;
static const int ISLOWER_MASK = 0x2;
static const int ISUPPER_MASK = 0x4;
static const int ISDIGIT_MASK = 0x8;
static const int ISPUNCTUATION_MASK = 0x10;

UNICHARSET::UNICHARSET() :
    unichars(NULL),
    ids(),
    size_used(0),
    size_reserved(0),
    script_table(0),
    script_table_size_used(0),
    script_table_size_reserved(0),
    null_script("NULL"),
    null_sid_(0),
    common_sid_(0),
    latin_sid_(0),
    cyrillic_sid_(0),
    greek_sid_(0),
    han_sid_(0) {}

UNICHARSET::~UNICHARSET()
{
    if (size_reserved > 0)
    {
        for (int i = 0; i < script_table_size_used; ++i)
            delete[] script_table[i];

        delete[] script_table;
        delete_pointers_in_unichars();

        delete[] unichars;
    }
}

void UNICHARSET::reserve(int unichars_number)
{
    if (unichars_number > size_reserved)
    {
        UNICHAR_SLOT* unichars_new = new UNICHAR_SLOT[unichars_number];
        for (int i = 0; i < size_used; ++i)
            memcpy(&unichars_new[i], &unichars[i], sizeof(UNICHAR_SLOT));

        for (int j = size_used; j < unichars_number; ++j)
        {
            unichars_new[j].properties.script_id = add_script(null_script);
            unichars_new[j].properties.fragment = NULL;
        }
        delete[] unichars;

        unichars = unichars_new;
        size_reserved = unichars_number;
    }
}

UNICHAR_ID UNICHARSET::unichar_to_id(const char* const unichar_repr) const
{
    return ids.contains(unichar_repr) ? ids.unichar_to_id(unichar_repr) : INVALID_UNICHAR_ID;
}

UNICHAR_ID UNICHARSET::unichar_to_id(const char* const unichar_repr, int length) const
{
    assert(length > 0 && length <= UNICHAR_LEN);
    return ids.contains(unichar_repr, length) ? ids.unichar_to_id(unichar_repr, length) : INVALID_UNICHAR_ID;
}

// Return the minimum number of bytes that matches a legal UNICHAR_ID,
// while leaving a legal UNICHAR_ID afterwards. In other words, if there
// is both a short and a long match to the string, return the length that
// ensures there is a legal match after it.
int UNICHARSET::step(const char* str) const
{
    // Find the length of the first matching unicharset member.
    int minlength = ids.minmatch(str);
    if (minlength == 0) return 0;  // Empty string or illegal char.

    int goodlength = minlength;
    while (goodlength <= UNICHAR_LEN)
    {
        if (str[goodlength] == '\0' || ids.minmatch(str + goodlength) > 0) return goodlength;  // This length works!

        // The next char is illegal so find the next usable length.
        do
        {
            ++goodlength;
        } while (str[goodlength] != '\0' && goodlength <= UNICHAR_LEN && !ids.contains(str, goodlength));
    }

    // Search to find a subsequent legal char failed so return the minlength.
    return minlength;
}

char* UNICHARSET::id_to_unichar(UNICHAR_ID id) const
{
    QString sINVALID_UNICHAR("__INVALID_UNICHAR__");
    if (id == INVALID_UNICHAR_ID)
    {
        return sINVALID_UNICHAR.toLatin1().data();
    }
    assert(id < this->size());

    return unichars[id].representation;
}

// Return a STRING that reformats the utf8 str into the str followed
// by its hex unicodes.
STRING UNICHARSET::debug_utf8_str(const char* str)
{
    STRING result = str;
    result += " [";
    int step = 1;

    // Chop into unicodes and code each as hex.
    for (int i = 0; str[i] != '\0'; i += step)
    {
        char hex[sizeof(int) * 2 + 1];
        step = UNICHAR::utf8_step(str + i);

        if (step == 0)
        {
            step = 1;
            sprintf(hex, "%x", str[i]);
        }
        else
        {
            UNICHAR ch(str + i, step);
            sprintf(hex, "%x", ch.first_uni());
        }

        result += hex;
        result += " ";
    }
    result += "]";

    return result;
}

// Return a STRING containing debug information on the unichar, including
// the id_to_unichar, its hex unicodes and the properties.
STRING UNICHARSET::debug_str(UNICHAR_ID id) const
{
    const CHAR_FRAGMENT *fragment = this->get_fragment(id);

    if (fragment)
    {
        STRING base = debug_str(fragment->get_unichar());
        return CHAR_FRAGMENT::to_string(base.string(), fragment->get_pos(), fragment->get_total());
    }

    const char* str = id_to_unichar(id);
    if (id == INVALID_UNICHAR_ID) return STRING(str);
    STRING result = debug_utf8_str(str);

    // Append a for lower alpha, A for upper alpha, and x if alpha but neither.
    if (get_isalpha(id))
    {
        if (get_islower(id))
        {
            result += "a";
        }
        else if (get_isupper(id))
        {
            result += "A";
        }
        else
        {
            result += "x";
        }
    }

    // Append 0 if a digit.
    if (get_isdigit(id))
    {
        result += "0";
    }

    // Append p is a punctuation symbol.
    if (get_ispunctuation(id))
    {
        result += "p";
    }

    return result;
}

void UNICHARSET::unichar_insert(const char* const unichar_repr)
{
    if (!ids.contains(unichar_repr))
    {
        if (strlen(unichar_repr) > UNICHAR_LEN)
        {
            fprintf(stderr, "Utf8 buffer too big, size=%d for %s\n", int(strlen(unichar_repr)), unichar_repr);
            return;
        }

        if (size_used == size_reserved)
        {
            if (size_used == 0)
            {
                reserve(8);
            }
            else
            {
                reserve(2 * size_used);
            }
        }

        strcpy(unichars[size_used].representation, unichar_repr);
        this->set_isalpha(size_used, false);
        this->set_islower(size_used, false);
        this->set_isupper(size_used, false);
        this->set_isdigit(size_used, false);
        this->set_ispunctuation(size_used, false);
        this->set_isngram(size_used, false);
        this->set_script(size_used, null_script);

        // If the given unichar_repr represents a fragmented character, set
        // fragment property to a pointer to CHAR_FRAGMENT class instance with
        // information parsed from the unichar representation. Use the script
        // of the base unichar for the fragmented character if possible.
        CHAR_FRAGMENT *frag = CHAR_FRAGMENT::parse_from_string(unichar_repr);
        this->unichars[size_used].properties.fragment = frag;

        if (frag != NULL && this->contains_unichar(frag->get_unichar()))
        {
            this->unichars[size_used].properties.script_id =
                    this->get_script(frag->get_unichar());
        }

        this->unichars[size_used].properties.enabled = true;
        ids.insert(unichar_repr, size_used);
        ++size_used;
    }
}

bool UNICHARSET::contains_unichar(const char* const unichar_repr) const
{
    return ids.contains(unichar_repr);
}

bool UNICHARSET::contains_unichar(const char* const unichar_repr, int length) const
{
    if (length == 0)
    {
        return false;
    }

    return ids.contains(unichar_repr, length);
}

bool UNICHARSET::eq(UNICHAR_ID unichar_id, const char* const unichar_repr) const
{
    return strcmp(this->id_to_unichar(unichar_id), unichar_repr) == 0;
}

bool UNICHARSET::save_to_file(FILE *file) const
{
    fprintf(file, "%d\n", this->size());
    for (UNICHAR_ID id = 0; id < this->size(); ++id)
    {
        unsigned int properties = 0;

        if (this->get_isalpha(id))
        {
            properties |= ISALPHA_MASK;
        }

        if (this->get_islower(id))
        {
            properties |= ISLOWER_MASK;
        }

        if (this->get_isupper(id))
        {
            properties |= ISUPPER_MASK;
        }

        if (this->get_isdigit(id))
        {
            properties |= ISDIGIT_MASK;
        }

        if (this->get_ispunctuation(id))
        {
            properties |= ISPUNCTUATION_MASK;
        }

        if (strcmp(this->id_to_unichar(id), " ") == 0)
        {
            fprintf(file, "%s %x %s %d\n", "NULL", properties, this->get_script_from_script_id(this->get_script(id)), this->get_other_case(id));
        }
        else
        {
            fprintf(file, "%s %x %s %d\n", this->id_to_unichar(id), properties, this->get_script_from_script_id(this->get_script(id)), this->get_other_case(id));
        }
    }

    return true;
}

bool UNICHARSET::load_from_file(FILE *file)
{
    int unicharset_size;
    char buffer[256];

    this->clear();
    if (fgets(buffer, sizeof (buffer), file) == NULL || sscanf(buffer, "%d", &unicharset_size) != 1)
    {
        return false;
    }

    this->reserve(unicharset_size);
    for (UNICHAR_ID id = 0; id < unicharset_size; ++id)
    {
        char unichar[256];
        unsigned int properties;
        char script[64];

        strcpy(script, null_script);
        this->unichars[id].properties.other_case = id;
        if (fgets(buffer, sizeof (buffer), file) == NULL ||
                (sscanf(buffer, "%s %x %63s %d", unichar, &properties, script, &(this->unichars[id].properties.other_case)) != 4 &&
                 sscanf(buffer, "%s %x %63s", unichar, &properties, script) != 3 && sscanf(buffer, "%s %x", unichar, &properties) != 2))
        {
            return false;
        }

        if (strcmp(unichar, "NULL") == 0)
        {
            this->unichar_insert(" ");
        }
        else
        {
            this->unichar_insert(unichar);
        }

        this->set_isalpha(id, (properties & ISALPHA_MASK) != 0);
        this->set_islower(id, (properties & ISLOWER_MASK) != 0);
        this->set_isupper(id, (properties & ISUPPER_MASK) != 0);
        this->set_isdigit(id, (properties & ISDIGIT_MASK) != 0);
        this->set_ispunctuation(id, (properties & ISPUNCTUATION_MASK) != 0);
        this->set_isngram(id, false);
        this->set_script(id, script);
        this->unichars[id].properties.enabled = true;
    }

    null_sid_ = get_script_id_from_name(null_script);
    ASSERT_HOST(null_sid_ == 0);
    common_sid_ = get_script_id_from_name("Common");
    latin_sid_ = get_script_id_from_name("Latin");
    cyrillic_sid_ = get_script_id_from_name("Cyrillic");
    greek_sid_ = get_script_id_from_name("Greek");
    han_sid_ = get_script_id_from_name("Han");
    return true;
}

// Set a whitelist and/or blacklist of characters to recognize.
// An empty or NULL whitelist enables everything (minus any blacklist).
// An empty or NULL blacklist disables nothing.
void UNICHARSET::set_black_and_whitelist(const char* blacklist, const char* whitelist)
{
    bool def_enabled = whitelist == NULL || whitelist[0] == '\0';
    // Set everything to default

    for (int ch = 0; ch < size_used; ++ch)
    {
        unichars[ch].properties.enabled = def_enabled;
    }

    int ch_step;
    if (!def_enabled)
    {
        // Enable the whitelist.
        for (int w_ind = 0; whitelist[w_ind] != '\0'; w_ind += ch_step)
        {
            ch_step = step(whitelist + w_ind);
            if (ch_step > 0)
            {
                UNICHAR_ID u_id = unichar_to_id(whitelist + w_ind, ch_step);
                unichars[u_id].properties.enabled = true;
            }
            else
            {
                ch_step = 1;
            }
        }
    }

    if (blacklist != NULL && blacklist[0] != '\0')
    {
        // Disable the blacklist.
        for (int b_ind = 0; blacklist[b_ind] != '\0'; b_ind += ch_step)
        {
            ch_step = step(blacklist + b_ind);
            if (ch_step > 0)
            {
                UNICHAR_ID u_id = unichar_to_id(blacklist + b_ind, ch_step);
                unichars[u_id].properties.enabled = false;
            }
            else
            {
                ch_step = 1;
            }
        }
    }
}

int UNICHARSET::add_script(const char* script)
{
    for (int i = 0; i < script_table_size_used; ++i)
    {
        if (strcmp(script, script_table[i]) == 0) return i;
    }

    if (script_table_size_reserved == 0)
    {
        script_table_size_reserved = 8;
        script_table = new char*[script_table_size_reserved];
    }

    if (script_table_size_used + 1 >= script_table_size_reserved)
    {
        char** new_script_table = new char*[script_table_size_reserved * 2];
        memcpy(new_script_table, script_table, script_table_size_reserved * sizeof(char*));
        delete[] script_table;

        script_table = new_script_table;
        script_table_size_reserved = 2 * script_table_size_reserved;
    }

    script_table[script_table_size_used] = new char[strlen(script) + 1];
    strcpy(script_table[script_table_size_used], script);

    return script_table_size_used++;
}

CHAR_FRAGMENT *CHAR_FRAGMENT::parse_from_string(const char *string)
{
    const char *ptr = string;
    int len = strlen(string);

    if (len < kMinLen || *ptr != kSeparator)
    {
        return NULL;  // this string can not represent a fragment
    }

    ptr++;  // move to the next character
    int step = 0;
    while ((ptr + step) < (string + len) && *(ptr + step) != kSeparator)
    {
        step += UNICHAR::utf8_step(ptr + step);
    }

    if (step == 0 || step > UNICHAR_LEN)
    {
        return NULL;  // no character for unichar or the character is too long
    }

    char unichar[UNICHAR_LEN + 1];
    strncpy(unichar, ptr, step);
    unichar[step] = '\0';  // null terminate unichar
    ptr += step;  // move to the next fragment separator
    int pos = 0;
    int total = 0;
    char *end_ptr = NULL;

    for (int i = 0; i < 2; i++)
    {
        if (ptr > string + len || *ptr != kSeparator)
        {
            return NULL;  // failed to parse fragment representation
        }

        ptr++;  // move to the next character
        i == 0 ? pos = static_cast<int>(strtol(ptr, &end_ptr, 10)) : total = static_cast<int>(strtol(ptr, &end_ptr, 10));
        ptr = end_ptr;
    }

    if (ptr != string + len)
    {
        return NULL;  // malformed fragment representation
    }

    CHAR_FRAGMENT *fragment = new CHAR_FRAGMENT();
    fragment->set_all(unichar, pos, total);

    return fragment;
}

int UNICHARSET::get_script_id_from_name(const char* script_name) const
{
    for (int i = 0; i < script_table_size_used; ++i)
    {
        if (strcmp(script_name, script_table[i]) == 0) return i;
    }

    return 0;  // 0 is always the null_script
}
/////////////////////////////////////////////////////////////////UNICHARSET/////////////////////////////////

//////////////////////////////////////////////////////////////polyvert/////////////////////////////////////////////
ELIST2IZE_S (POLYPT)
//////////////////////////////////////////////////////////////polyvert/////////////////////////////////////////////

//////////////////////////////////////////////////////////////normalis/////////////////////////////////////////////
/**********************************************************************
 * DENORM::binary_search_segment
 *
 * Find the segment to use for the given x.
 **********************************************************************/

const DENORM_SEG *DENORM::binary_search_segment(float src_x) const {
  int bottom, top, middle;       //binary search

  bottom = 0;
  top = segments;
  do {
    middle = (bottom + top) / 2;
    if (segs[middle].xstart > src_x)
      top = middle;
    else
      bottom = middle;
  }
  while (top - bottom > 1);
  return &segs[bottom];
}

/**********************************************************************
 * DENORM::scale_at_x
 *
 * Return scaling at a given (normalized) x coord.
 **********************************************************************/

float DENORM::scale_at_x(float src_x) const {  // In normalized coords.
  if (segments != 0) {
    const DENORM_SEG* seg = binary_search_segment(src_x);
    if (seg->scale_factor > 0.0)
      return seg->scale_factor;
  }
  return scale_factor;
}

/**********************************************************************
 * DENORM::yshift_at_x
 *
 * Return yshift at a given (normalized) x coord.
 **********************************************************************/

float DENORM::yshift_at_x(float src_x) const {  // In normalized coords.
  if (segments != 0) {
    const DENORM_SEG* seg = binary_search_segment(src_x);
    if (seg->ycoord == -MAX_INT32) {
      if (base_is_row)
        return source_row->base_line(x(src_x));
      else
        return m * x(src_x) + c;
    } else {
      return seg->ycoord;
    }
  }
  return source_row->base_line(x(src_x));
}

/**********************************************************************
 * DENORM::x
 *
 * Denormalise an x coordinate.
 **********************************************************************/

float DENORM::x(float src_x) const {
  return src_x / scale_at_x(src_x) + x_centre;
}

// Compare two segments by xstart for use with qsort(3) and bsearch(3)
static int compare_seg_by_xstart(const DENORM_SEG* a, const DENORM_SEG* b) {
  if (a->xstart < b->xstart)
    return -1;
  else if (a->xstart > b->xstart)
    return 1;
  return 0;
}

/**********************************************************************
 * DENORM::y
 *
 * Denormalise a y coordinate.
 **********************************************************************/

float DENORM::y(                  //convert y coord
                float src_y,      //coord to convert
                float src_x_centre  //x location for base
               ) const {
  return (src_y - kBlnBaselineOffset) / scale_at_x(src_x_centre)
    + yshift_at_x(src_x_centre);
}


DENORM::DENORM(float x,              //from same pieces
               float scaling,
               double line_m,        //default line
               double line_c,
               inT16 seg_count,      //no of segments
               DENORM_SEG *seg_pts,  //actual segments
               BOOL8 using_row,      //as baseline
               ROW *src) {
  x_centre = x;                  //just copy
  scale_factor = scaling;
  source_row = src;
  if (seg_count > 0) {
    segs = new DENORM_SEG[seg_count];
    for (segments = 0; segments < seg_count; segments++)
      segs[segments] = seg_pts[segments];
    // It is possible, if infrequent that the segments may be out of order.
    // since we are searching with a binary search, keep them in order.
    qsort(segs, segments, sizeof(DENORM_SEG),
          reinterpret_cast<int(*)(const void*, const void*)>(
              &compare_seg_by_xstart));
  }
  else {
    segments = 0;
    segs = NULL;
  }
  base_is_row = using_row;
  m = line_m;
  c = line_c;
  block_ = NULL;
}


DENORM::DENORM(const DENORM &src) {
  segments = 0;
  segs = NULL;
  *this = src;
}


DENORM & DENORM::operator= (const DENORM & src) {
  x_centre = src.x_centre;
  scale_factor = src.scale_factor;
  source_row = src.source_row;
  if (segments > 0)
    delete[]segs;
  if (src.segments > 0) {
    segs = new DENORM_SEG[src.segments];
    for (segments = 0; segments < src.segments; segments++)
      segs[segments] = src.segs[segments];
  }
  else {
    segments = 0;
    segs = NULL;
  }
  base_is_row = src.base_is_row;
  m = src.m;
  c = src.c;
  block_ = src.block_;
  return *this;
}
//////////////////////////////////////////////////////////////normalis/////////////////////////////////////////////

/////////////////////////////////////////////////////////////////elst2/////////////////////////////////
/***********************************************************************
 *  MEMBER FUNCTIONS OF CLASS: ELIST2
 *  =================================
 **********************************************************************/

/***********************************************************************
 *							ELIST2::internal_clear
 *
 *  Used by the destructor and the "clear" member function of derived list
 *  classes to destroy all the elements on the list.
 *  The calling function passes a "zapper" function which can be called to
 *  delete each element of the list, regardless of its derived type.  This
 *  technique permits a generic clear function to destroy elements of
 *  different derived types correctly, without requiring virtual functions and
 *  the consequential memory overhead.
 **********************************************************************/

void
ELIST2::internal_clear (         //destroy all links
void (*zapper) (ELIST2_LINK *)) {
                                 //ptr to zapper functn
  ELIST2_LINK *ptr;
  ELIST2_LINK *next;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2::internal_clear", ABORT, NULL);
  #endif

  if (!empty ()) {
    ptr = last->next;            //set to first
    last->next = NULL;           //break circle
    last = NULL;                 //set list empty
    while (ptr) {
      next = ptr->next;
      zapper(ptr);
      ptr = next;
    }
  }
}

/***********************************************************************
 *							ELIST2::assign_to_sublist
 *
 *  The list is set to a sublist of another list.  "This" list must be empty
 *  before this function is invoked.  The two iterators passed must refer to
 *  the same list, different from "this" one.  The sublist removed is the
 *  inclusive list from start_it's current position to end_it's current
 *  position.  If this range passes over the end of the source list then the
 *  source list has its end set to the previous element of start_it.  The
 *  extracted sublist is unaffected by the end point of the source list, its
 *  end point is always the end_it position.
 **********************************************************************/

void ELIST2::assign_to_sublist(                            //to this list
                               ELIST2_ITERATOR *start_it,  //from list start
                               ELIST2_ITERATOR *end_it) {  //from list end
  const ERRCODE LIST_NOT_EMPTY =
    "Destination list must be empty before extracting a sublist";

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2::assign_to_sublist", ABORT, NULL);
  #endif

  if (!empty ())
    LIST_NOT_EMPTY.error ("ELIST2.assign_to_sublist", ABORT, NULL);

  last = start_it->extract_sublist (end_it);
}


/***********************************************************************
 *							ELIST2::length
 *
 *  Return count of elements on list
 **********************************************************************/

inT32 ELIST2::length() {  //count elements
  ELIST2_ITERATOR it(this);
  inT32 count = 0;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2::length", ABORT, NULL);
  #endif

  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
    count++;
  return count;
}


/***********************************************************************
 *							ELIST2::sort
 *
 *  Sort elements on list
 *  NB If you dont like the const declarations in the comparator, coerce yours:
 *   ( int (*)(const void *, const void *)
 **********************************************************************/

void
ELIST2::sort (                   //sort elements
int comparator (                 //comparison routine
const void *, const void *)) {
  ELIST2_ITERATOR it(this);
  inT32 count;
  ELIST2_LINK **base;            //ptr array to sort
  ELIST2_LINK **current;
  inT32 i;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2::sort", ABORT, NULL);
  #endif

  /* Allocate an array of pointers, one per list element */
  count = length ();
  base = (ELIST2_LINK **) malloc (count * sizeof (ELIST2_LINK *));

  /* Extract all elements, putting the pointers in the array */
  current = base;
  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
    *current = it.extract ();
    current++;
  }

  /* Sort the pointer array */
  qsort ((char *) base, count, sizeof (*base), comparator);

  /* Rebuild the list from the sorted pointers */
  current = base;
  for (i = 0; i < count; i++) {
    it.add_to_end (*current);
    current++;
  }
  free(base);
}

// Assuming list has been sorted already, insert new_link to
// keep the list sorted according to the same comparison function.
// Comparision function is the same as used by sort, i.e. uses double
// indirection. Time is O(1) to add to beginning or end.
// Time is linear to add pre-sorted items to an empty list.
void ELIST2::add_sorted(int comparator(const void*, const void*),
                        ELIST2_LINK* new_link) {
  // Check for adding at the end.
  if (last == NULL || comparator(&last, &new_link) < 0) {
    if (last == NULL) {
      new_link->next = new_link;
      new_link->prev = new_link;
    } else {
      new_link->next = last->next;
      new_link->prev = last;
      last->next = new_link;
      new_link->next->prev = new_link;
    }
    last = new_link;
  } else {
    // Need to use an iterator.
    ELIST2_ITERATOR it(this);
    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
      ELIST2_LINK* link = it.data();
      if (comparator(&link, &new_link) > 0)
        break;
    }
    if (it.cycled_list())
      it.add_to_end(new_link);
    else
      it.add_before_then_move(new_link);
  }
}

/***********************************************************************
 *							ELIST2::prep_serialise
 *
 *  Replace the last member with a count of elements for serialisation.
 *  This is used on list objects which are members of objects being
 *  serialised.  The containing object has been shallow copied and this member
 *  function is invoked on the COPY.
 **********************************************************************/

void ELIST2::prep_serialise() {
  ELIST2_ITERATOR this_it(this);
  inT32 count = 0;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2::prep_serialise", ABORT, NULL);
  #endif

  count = 0;
  if (!empty ())
    for (this_it.mark_cycle_pt ();
    !this_it.cycled_list (); this_it.forward ())
  count++;
  last = (ELIST2_LINK *)&count;
}


/***********************************************************************
 *							ELIST2::internal_dump
 *
 *  Cause each element on the list to be serialised by walking the list and
 *  calling the element_serialiser function for each element.  The
 *  element_serialiser simply does the appropriate coercion of the element to
 *  its real type and then invokes the elements serialise function
 **********************************************************************/

void
ELIST2::internal_dump (FILE * f,
void element_serialiser (FILE *, ELIST2_LINK *)) {
  ELIST2_ITERATOR this_it(this);

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2::internal_dump", ABORT, NULL);
  #endif

  if (!empty ())
    for (this_it.mark_cycle_pt ();
    !this_it.cycled_list (); this_it.forward ())
  element_serialiser (f, this_it.data ());
}


/***********************************************************************
 *							ELIST2::internal_de_dump
 *
 *  Cause each element on the list to be de_serialised by extracting the count
 *  of elements on the list, (held in the last member of the dumped version of
 *  the list object), and then de-serialising that number of list elements,
 *  adding each to the end of the reconstructed list.
 **********************************************************************/

void
ELIST2::internal_de_dump (FILE * f,
ELIST2_LINK * element_de_serialiser (FILE *)) {
  inT32 count = (ptrdiff_t) last;
  ELIST2_ITERATOR this_it;
  ELIST2_LINK *de_serialised_element;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2::internal_de_dump", ABORT, NULL);
  #endif

  last = NULL;
  this_it.set_to_list (this);
  for (; count > 0; count--) {
    de_serialised_element = element_de_serialiser (f);
                                 //ignore old ptr
    de_serialised_element->next = NULL;
                                 //ignore old ptr
    de_serialised_element->prev = NULL;
    this_it.add_to_end (de_serialised_element);
  }
}


/***********************************************************************
 *  MEMBER FUNCTIONS OF CLASS: ELIST2_ITERATOR
 *  ==========================================
 **********************************************************************/

/***********************************************************************
 *							ELIST2_ITERATOR::forward
 *
 *  Move the iterator to the next element of the list.
 *  REMEMBER: ALL LISTS ARE CIRCULAR.
 **********************************************************************/

ELIST2_LINK *ELIST2_ITERATOR::forward() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::forward", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::forward", ABORT, NULL);
  #endif
  if (list->empty ())
    return NULL;

  if (current) {                 //not removed so
                                 //set previous
    prev = current;
    started_cycling = TRUE;
    // In case next is deleted by another iterator, get it from the current.
    current = current->next;
  }
  else {
    if (ex_current_was_cycle_pt)
      cycle_pt = next;
    current = next;
  }
  next = current->next;

  #ifndef NDEBUG
  if (!current)
    NULL_DATA.error ("ELIST2_ITERATOR::forward", ABORT, NULL);
  if (!next)
    NULL_NEXT.error ("ELIST2_ITERATOR::forward", ABORT,
                     "This is: %p  Current is: %p", this, current);
  #endif
  return current;
}


/***********************************************************************
 *							ELIST2_ITERATOR::backward
 *
 *  Move the iterator to the previous element of the list.
 *  REMEMBER: ALL LISTS ARE CIRCULAR.
 **********************************************************************/

ELIST2_LINK *ELIST2_ITERATOR::backward() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::backward", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::backward", ABORT, NULL);
  #endif
  if (list->empty ())
    return NULL;

  if (current) {                 //not removed so
                                 //set previous
    next = current;
    started_cycling = TRUE;
    // In case prev is deleted by another iterator, get it from current.
    current = current->prev;
  } else {
    if (ex_current_was_cycle_pt)
      cycle_pt = prev;
    current = prev;
  }
  prev = current->prev;

  #ifndef NDEBUG
  if (!current)
    NULL_DATA.error ("ELIST2_ITERATOR::backward", ABORT, NULL);
  if (!prev)
    NULL_PREV.error ("ELIST2_ITERATOR::backward", ABORT,
      "This is: %p  Current is: %p", this, current);
  #endif
  return current;
}


/***********************************************************************
 *							ELIST2_ITERATOR::data_relative
 *
 *  Return the data pointer to the element "offset" elements from current.
 *  (This function can't be INLINEd because it contains a loop)
 **********************************************************************/

ELIST2_LINK *ELIST2_ITERATOR::data_relative(                //get data + or - ..
                                            inT8 offset) {  //offset from current
  ELIST2_LINK *ptr;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::data_relative", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::data_relative", ABORT, NULL);
  if (list->empty ())
    EMPTY_LIST.error ("ELIST2_ITERATOR::data_relative", ABORT, NULL);
  #endif

  if (offset < 0)
    for (ptr = current ? current : next; offset++ < 0; ptr = ptr->prev);
  else
    for (ptr = current ? current : prev; offset-- > 0; ptr = ptr->next);

  #ifndef NDEBUG
  if (!ptr)
    NULL_DATA.error ("ELIST2_ITERATOR::data_relative", ABORT, NULL);
  #endif

  return ptr;
}


/***********************************************************************
 *							ELIST2_ITERATOR::exchange()
 *
 *  Given another iterator, whose current element is a different element on
 *  the same list list OR an element of another list, exchange the two current
 *  elements.  On return, each iterator points to the element which was the
 *  other iterators current on entry.
 *  (This function hasn't been in-lined because its a bit big!)
 **********************************************************************/

void ELIST2_ITERATOR::exchange(                              //positions of 2 links
                               ELIST2_ITERATOR *other_it) {  //other iterator
  const ERRCODE DONT_EXCHANGE_DELETED =
    "Can't exchange deleted elements of lists";

  ELIST2_LINK *old_current;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::exchange", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::exchange", ABORT, NULL);
  if (!other_it)
    BAD_PARAMETER.error ("ELIST2_ITERATOR::exchange", ABORT, "other_it NULL");
  if (!(other_it->list))
    NO_LIST.error ("ELIST2_ITERATOR::exchange", ABORT, "other_it");
  #endif

  /* Do nothing if either list is empty or if both iterators reference the same
  link */

  if ((list->empty ()) ||
    (other_it->list->empty ()) || (current == other_it->current))
    return;

  /* Error if either current element is deleted */

  if (!current || !other_it->current)
    DONT_EXCHANGE_DELETED.error ("ELIST2_ITERATOR.exchange", ABORT, NULL);

  /* Now handle the 4 cases: doubleton list; non-doubleton adjacent elements
  (other before this); non-doubleton adjacent elements (this before other);
  non-adjacent elements. */

                                 //adjacent links
  if ((next == other_it->current) ||
  (other_it->next == current)) {
                                 //doubleton list
    if ((next == other_it->current) &&
    (other_it->next == current)) {
      prev = next = current;
      other_it->prev = other_it->next = other_it->current;
    }
    else {                       //non-doubleton with
                                 //adjacent links
                                 //other before this
      if (other_it->next == current) {
        other_it->prev->next = current;
        other_it->current->next = next;
        other_it->current->prev = current;
        current->next = other_it->current;
        current->prev = other_it->prev;
        next->prev = other_it->current;

        other_it->next = other_it->current;
        prev = current;
      }
      else {                     //this before other
        prev->next = other_it->current;
        current->next = other_it->next;
        current->prev = other_it->current;
        other_it->current->next = current;
        other_it->current->prev = prev;
        other_it->next->prev = current;

        next = current;
        other_it->prev = other_it->current;
      }
    }
  }
  else {                         //no overlap
    prev->next = other_it->current;
    current->next = other_it->next;
    current->prev = other_it->prev;
    next->prev = other_it->current;
    other_it->prev->next = current;
    other_it->current->next = next;
    other_it->current->prev = prev;
    other_it->next->prev = current;
  }

  /* update end of list pointer when necessary (remember that the 2 iterators
    may iterate over different lists!) */

  if (list->last == current)
    list->last = other_it->current;
  if (other_it->list->last == other_it->current)
    other_it->list->last = current;

  if (current == cycle_pt)
    cycle_pt = other_it->cycle_pt;
  if (other_it->current == other_it->cycle_pt)
    other_it->cycle_pt = cycle_pt;

  /* The actual exchange - in all cases*/

  old_current = current;
  current = other_it->current;
  other_it->current = old_current;
}


/***********************************************************************
 *							ELIST2_ITERATOR::extract_sublist()
 *
 *  This is a private member, used only by ELIST2::assign_to_sublist.
 *  Given another iterator for the same list, extract the links from THIS to
 *  OTHER inclusive, link them into a new circular list, and return a
 *  pointer to the last element.
 *  (Can't inline this function because it contains a loop)
 **********************************************************************/

ELIST2_LINK *ELIST2_ITERATOR::extract_sublist(                              //from this current
                                              ELIST2_ITERATOR *other_it) {  //to other current
  #ifndef NDEBUG
  const ERRCODE BAD_EXTRACTION_PTS =
    "Can't extract sublist from points on different lists";
  const ERRCODE DONT_EXTRACT_DELETED =
    "Can't extract a sublist marked by deleted points";
  #endif
  const ERRCODE BAD_SUBLIST = "Can't find sublist end point in original list";

  ELIST2_ITERATOR temp_it = *this;
  ELIST2_LINK *end_of_new_list;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::extract_sublist", ABORT, NULL);
  if (!other_it)
    BAD_PARAMETER.error ("ELIST2_ITERATOR::extract_sublist", ABORT,
      "other_it NULL");
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::extract_sublist", ABORT, NULL);
  if (list != other_it->list)
    BAD_EXTRACTION_PTS.error ("ELIST2_ITERATOR.extract_sublist", ABORT, NULL);
  if (list->empty ())
    EMPTY_LIST.error ("ELIST2_ITERATOR::extract_sublist", ABORT, NULL);

  if (!current || !other_it->current)
    DONT_EXTRACT_DELETED.error ("ELIST2_ITERATOR.extract_sublist", ABORT,
      NULL);
  #endif

  ex_current_was_last = other_it->ex_current_was_last = FALSE;
  ex_current_was_cycle_pt = FALSE;
  other_it->ex_current_was_cycle_pt = FALSE;

  temp_it.mark_cycle_pt ();
  do {                           //walk sublist
    if (temp_it.cycled_list ())  //cant find end pt
      BAD_SUBLIST.error ("ELIST2_ITERATOR.extract_sublist", ABORT, NULL);

    if (temp_it.at_last ()) {
      list->last = prev;
      ex_current_was_last = other_it->ex_current_was_last = TRUE;
    }

    if (temp_it.current == cycle_pt)
      ex_current_was_cycle_pt = TRUE;

    if (temp_it.current == other_it->cycle_pt)
      other_it->ex_current_was_cycle_pt = TRUE;

    temp_it.forward ();
  }
                                 //do INCLUSIVE list
  while (temp_it.prev != other_it->current);

                                 //circularise sublist
  other_it->current->next = current;
                                 //circularise sublist
  current->prev = other_it->current;
  end_of_new_list = other_it->current;

                                 //sublist = whole list
  if (prev == other_it->current) {
    list->last = NULL;
    prev = current = next = NULL;
    other_it->prev = other_it->current = other_it->next = NULL;
  }
  else {
    prev->next = other_it->next;
    other_it->next->prev = prev;

    current = other_it->current = NULL;
    next = other_it->next;
    other_it->prev = prev;
  }
  return end_of_new_list;
}
/////////////////////////////////////////////////////////////////elst2/////////////////////////////////

/////////////////////////////////////////////////////////////////elst/////////////////////////////////
//default serialise
void ELIST_LINK::serialise_asc(FILE *f)
{
    Q_UNUSED(f);
    SERIALISE_LINKS.error ("ELIST_LINK::serialise_asc", ABORT, "Don't call this, override!");
}

//default de_serialise
void ELIST_LINK::de_serialise_asc(FILE *f)
{
    Q_UNUSED(f);
    SERIALISE_LINKS.error ("ELIST_LINK::de_serialise_asc", ABORT, "Don't call this, override!");
}


/***********************************************************************
 *  MEMBER FUNCTIONS OF CLASS: ELIST
 *  ================================
 **********************************************************************/

/***********************************************************************
 *							ELIST::internal_clear
 *
 *  Used by the destructor and the "clear" member function of derived list
 *  classes to destroy all the elements on the list.
 *  The calling function passes a "zapper" function which can be called to
 *  delete each element of the list, regardless of its derived type.  This
 *  technique permits a generic clear function to destroy elements of
 *  different derived types correctly, without requiring virtual functions and
 *  the consequential memory overhead.
 **********************************************************************/

//destroy all links
void ELIST::internal_clear(void (*zapper) (ELIST_LINK *))
{
    //ptr to zapper functn
    ELIST_LINK *ptr;
    ELIST_LINK *next;

#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error ("ELIST::internal_clear", ABORT, NULL);
#endif

    if (!empty ())
    {
        ptr = last->next;            //set to first
        last->next = NULL;           //break circle
        last = NULL;                 //set list empty

        while (ptr)
        {
            next = ptr->next;
            zapper(ptr);
            ptr = next;
        }
    }
}

/***********************************************************************
 *							ELIST::assign_to_sublist
 *
 *  The list is set to a sublist of another list.  "This" list must be empty
 *  before this function is invoked.  The two iterators passed must refer to
 *  the same list, different from "this" one.  The sublist removed is the
 *  inclusive list from start_it's current position to end_it's current
 *  position.  If this range passes over the end of the source list then the
 *  source list has its end set to the previous element of start_it.  The
 *  extracted sublist is unaffected by the end point of the source list, its
 *  end point is always the end_it position.
 **********************************************************************/

//to this list                //from list start
void ELIST::assign_to_sublist(ELIST_ITERATOR *start_it,   ELIST_ITERATOR *end_it)
{
    //from list end
    const ERRCODE LIST_NOT_EMPTY = "Destination list must be empty before extracting a sublist";

#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error ("ELIST::assign_to_sublist", ABORT, NULL);
#endif

    if (!empty ())
    {
        LIST_NOT_EMPTY.error ("ELIST.assign_to_sublist", ABORT, NULL);
    }

    last = start_it->extract_sublist (end_it);
}


/***********************************************************************
 *							ELIST::length
 *
 *  Return count of elements on list
 **********************************************************************/

inT32 ELIST::length()
{
    //count elements
    ELIST_ITERATOR it(this);
    inT32 count = 0;

#ifndef NDEBUG
    if (!this)
    {
        NULL_OBJECT.error ("ELIST::length", ABORT, NULL);
    }
#endif

    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
    {
        count++;
    }

    return count;
}


/***********************************************************************
 *							ELIST::sort
 *
 *  Sort elements on list
 *  NB If you dont like the const declarations in the comparator, coerce yours:
 *   ( int (*)(const void *, const void *)
 **********************************************************************/
//sort elements                 //comparison routine
void ELIST::sort(int comparator(const void *, const void *))
{
    ELIST_ITERATOR it(this);
    inT32 count;
    ELIST_LINK **base;             //ptr array to sort
    ELIST_LINK **current;
    inT32 i;

#ifndef NDEBUG
    if (!this)
    {
        NULL_OBJECT.error("ELIST::sort", ABORT, NULL);
    }
#endif

    /* Allocate an array of pointers, one per list element */
    count = length();
    base = (ELIST_LINK **)malloc(count * sizeof (ELIST_LINK *));

    /* Extract all elements, putting the pointers in the array */
    current = base;
    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
    {
        *current = it.extract();
        current++;
    }

    /* Sort the pointer array */
    qsort((char *)base, count, sizeof(*base), comparator);

    /* Rebuild the list from the sorted pointers */
    current = base;
    for (i = 0; i < count; i++)
    {
        it.add_to_end(*current);
        current++;
    }

    free(base);
}

// Assuming list has been sorted already, insert new_link to
// keep the list sorted according to the same comparison function.
// Comparision function is the same as used by sort, i.e. uses double
// indirection. Time is O(1) to add to beginning or end.
// Time is linear to add pre-sorted items to an empty list.
void ELIST::add_sorted(int comparator(const void*, const void*), ELIST_LINK* new_link)
{
    // Check for adding at the end.
    if (last == NULL || comparator(&last, &new_link) < 0)
    {
        if (last == NULL)
        {
            new_link->next = new_link;
        }
        else
        {
            new_link->next = last->next;
            last->next = new_link;
        }

        last = new_link;
    }
    else
    {
        // Need to use an iterator.
        ELIST_ITERATOR it(this);
        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
        {
            ELIST_LINK* link = it.data();
            if (comparator(&link, &new_link) > 0) break;
        }
        if (it.cycled_list())
        {
            it.add_to_end(new_link);
        }
        else
        {
            it.add_before_then_move(new_link);
        }
    }
}

/***********************************************************************
 *							ELIST::prep_serialise
 *
 *  Replace the last member with a count of elements for serialisation.
 *  This is used on list objects which are members of objects being
 *  serialised.  The containing object has been shallow copied and this member
 *  function is invoked on the COPY.
 **********************************************************************/

void ELIST::prep_serialise()
{
    ELIST_ITERATOR this_it(this);
    inT32 count = 0;

#ifndef NDEBUG
    if (!this)
    {
        NULL_OBJECT.error ("ELIST::prep_serialise", ABORT, NULL);
    }
#endif

    count = 0;
    if (!empty ())
        for (this_it.mark_cycle_pt ();!this_it.cycled_list (); this_it.forward ())
            count++;
    last = (ELIST_LINK *)&count;
}


/***********************************************************************
 *							ELIST::internal_dump
 *
 *  Cause each element on the list to be serialised by walking the list and
 *  calling the element_serialiser function for each element.  The
 *  element_serialiser simply does the appropriate coercion of the element to
 *  its real type and then invokes the elements serialise function
 **********************************************************************/

void
ELIST::internal_dump (FILE * f,
                      void element_serialiser (FILE *, ELIST_LINK *))
{
    ELIST_ITERATOR this_it(this);

#ifndef NDEBUG
    if (!this)
    {
        NULL_OBJECT.error ("ELIST::internal_dump", ABORT, NULL);
    }
#endif

    if (!empty ())
    {
        for (this_it.mark_cycle_pt (); !this_it.cycled_list (); this_it.forward ())
        {
            element_serialiser (f, this_it.data ());
        }
    }
}


/***********************************************************************
 *							ELIST::internal_de_dump
 *
 *  Cause each element on the list to be de_serialised by extracting the count
 *  of elements on the list, (held in the last member of the dumped version of
 *  the list object), and then de-serialising that number of list elements,
 *  adding each to the end of the reconstructed list.
 **********************************************************************/

void ELIST::internal_de_dump (FILE * f, ELIST_LINK * element_de_serialiser (FILE *))
{
    inT32 count = (ptrdiff_t) last;
    ELIST_ITERATOR this_it;
    ELIST_LINK *de_serialised_element;

#ifndef NDEBUG
    if (!this)
    {
        NULL_OBJECT.error ("ELIST::internal_de_dump", ABORT, NULL);
    }
#endif

    last = NULL;
    this_it.set_to_list (this);
    for (; count > 0; count--)
    {
        de_serialised_element = element_de_serialiser (f);

        //ignore old ptr
        de_serialised_element->next = NULL;
        this_it.add_to_end (de_serialised_element);
    }
}


/***********************************************************************
 *  MEMBER FUNCTIONS OF CLASS: ELIST_ITERATOR
 *  =========================================
 **********************************************************************/

/***********************************************************************
 *							ELIST_ITERATOR::forward
 *
 *  Move the iterator to the next element of the list.
 *  REMEMBER: ALL LISTS ARE CIRCULAR.
 **********************************************************************/

ELIST_LINK *ELIST_ITERATOR::forward()
{
#ifndef NDEBUG
    if (!this)
    {
        NULL_OBJECT.error ("ELIST_ITERATOR::forward", ABORT, NULL);
    }

    if (!list)
    {
        NO_LIST.error ("ELIST_ITERATOR::forward", ABORT, NULL);
    }
#endif
    if (list->empty ()) return NULL;

    if (current)
    {
        //not removed so
        //set previous
        prev = current;
        started_cycling = TRUE;

        // In case next is deleted by another iterator, get next from current.
        current = current->next;
    }
    else
    {
        if (ex_current_was_cycle_pt)
        {
            cycle_pt = next;
        }

        current = next;
    }
    next = current->next;

#ifndef NDEBUG
    if (!current)
    {
        NULL_DATA.error ("ELIST_ITERATOR::forward", ABORT, NULL);
    }

    if (!next)
    {
        NULL_NEXT.error ("ELIST_ITERATOR::forward", ABORT, "This is: %p  Current is: %p", this, current);
    }
#endif

    return current;
}


/***********************************************************************
 *							ELIST_ITERATOR::data_relative
 *
 *  Return the data pointer to the element "offset" elements from current.
 *  "offset" must not be less than -1.
 *  (This function can't be INLINEd because it contains a loop)
 **********************************************************************/

//get data + or - ...
ELIST_LINK *ELIST_ITERATOR::data_relative(inT8 offset)
{  //offset from current
    ELIST_LINK *ptr;

#ifndef NDEBUG
    if (!this)
    {
        NULL_OBJECT.error ("ELIST_ITERATOR::data_relative", ABORT, NULL);
    }

    if (!list)
    {
        NO_LIST.error ("ELIST_ITERATOR::data_relative", ABORT, NULL);
    }

    if (list->empty ())
    {
        EMPTY_LIST.error ("ELIST_ITERATOR::data_relative", ABORT, NULL);
    }

    if (offset < -1)
    {
        BAD_PARAMETER.error ("ELIST_ITERATOR::data_relative", ABORT, "offset < -l");
    }
#endif

    if (offset == -1)
    {
        ptr = prev;
    }
    else
    {
        for (ptr = current ? current : prev; offset-- > 0; ptr = ptr->next);
    }

#ifndef NDEBUG
    if (!ptr)
    {
        NULL_DATA.error ("ELIST_ITERATOR::data_relative", ABORT, NULL);
    }
#endif

    return ptr;
}


/***********************************************************************
 *							ELIST_ITERATOR::move_to_last()
 *
 *  Move current so that it is set to the end of the list.
 *  Return data just in case anyone wants it.
 *  (This function can't be INLINEd because it contains a loop)
 **********************************************************************/

ELIST_LINK *ELIST_ITERATOR::move_to_last()
{
#ifndef NDEBUG
    if (!this)
    {
        NULL_OBJECT.error ("ELIST_ITERATOR::move_to_last", ABORT, NULL);
    }

    if (!list)
    {
        NO_LIST.error ("ELIST_ITERATOR::move_to_last", ABORT, NULL);
    }
#endif

    while (current != list->last)
    {
        forward();
    }

    return current;
}


/***********************************************************************
 *							ELIST_ITERATOR::exchange()
 *
 *  Given another iterator, whose current element is a different element on
 *  the same list list OR an element of another list, exchange the two current
 *  elements.  On return, each iterator points to the element which was the
 *  other iterators current on entry.
 *  (This function hasn't been in-lined because its a bit big!)
 **********************************************************************/

//positions of 2 links
void ELIST_ITERATOR::exchange(ELIST_ITERATOR *other_it)
{  //other iterator
    const ERRCODE DONT_EXCHANGE_DELETED = "Can't exchange deleted elements of lists";

    ELIST_LINK *old_current;

#ifndef NDEBUG
    if (!this)
    {
        NULL_OBJECT.error ("ELIST_ITERATOR::exchange", ABORT, NULL);
    }

    if (!list)
    {
        NO_LIST.error ("ELIST_ITERATOR::exchange", ABORT, NULL);
    }

    if (!other_it)
    {
        BAD_PARAMETER.error ("ELIST_ITERATOR::exchange", ABORT, "other_it NULL");
    }

    if (!(other_it->list))
    {
        NO_LIST.error ("ELIST_ITERATOR::exchange", ABORT, "other_it");
    }
#endif

    /* Do nothing if either list is empty or if both iterators reference the same
  link */

    if ((list->empty ()) || (other_it->list->empty ()) || (current == other_it->current)) return;

    /* Error if either current element is deleted */

    if (!current || !other_it->current)
    {
        DONT_EXCHANGE_DELETED.error ("ELIST_ITERATOR.exchange", ABORT, NULL);
    }

    /* Now handle the 4 cases: doubleton list; non-doubleton adjacent elements
  (other before this); non-doubleton adjacent elements (this before other);
  non-adjacent elements. */

    //adjacent links
    if ((next == other_it->current) || (other_it->next == current))
    {
        //doubleton list
        if ((next == other_it->current) && (other_it->next == current))
        {
            prev = next = current;
            other_it->prev = other_it->next = other_it->current;
        }
        else
        {
            //non-doubleton with
            //adjacent links
            //other before this
            if (other_it->next == current)
            {
                other_it->prev->next = current;
                other_it->current->next = next;
                current->next = other_it->current;
                other_it->next = other_it->current;
                prev = current;
            }
            else
            {
                //this before other
                prev->next = other_it->current;
                current->next = other_it->next;
                other_it->current->next = current;
                next = current;
                other_it->prev = other_it->current;
            }
        }
    }
    else
    {
        //no overlap
        prev->next = other_it->current;
        current->next = other_it->next;
        other_it->prev->next = current;
        other_it->current->next = next;
    }

    /* update end of list pointer when necessary (remember that the 2 iterators
    may iterate over different lists!) */

    if (list->last == current)
    {
        list->last = other_it->current;
    }

    if (other_it->list->last == other_it->current)
    {
        other_it->list->last = current;
    }

    if (current == cycle_pt)
    {
        cycle_pt = other_it->cycle_pt;
    }

    if (other_it->current == other_it->cycle_pt)
    {
        other_it->cycle_pt = cycle_pt;
    }

    /* The actual exchange - in all cases*/

    old_current = current;
    current = other_it->current;
    other_it->current = old_current;
}


/***********************************************************************
 *							ELIST_ITERATOR::extract_sublist()
 *
 *  This is a private member, used only by ELIST::assign_to_sublist.
 *  Given another iterator for the same list, extract the links from THIS to
 *  OTHER inclusive, link them into a new circular list, and return a
 *  pointer to the last element.
 *  (Can't inline this function because it contains a loop)
 **********************************************************************/

//from this current
ELIST_LINK *ELIST_ITERATOR::extract_sublist(ELIST_ITERATOR *other_it)
{
    //to other current
#ifndef NDEBUG
    const ERRCODE BAD_EXTRACTION_PTS = "Can't extract sublist from points on different lists";
    const ERRCODE DONT_EXTRACT_DELETED = "Can't extract a sublist marked by deleted points";
#endif
    const ERRCODE BAD_SUBLIST = "Can't find sublist end point in original list";

    ELIST_ITERATOR temp_it = *this;
    ELIST_LINK *end_of_new_list;

#ifndef NDEBUG
    if (!this)
    {
        NULL_OBJECT.error ("ELIST_ITERATOR::extract_sublist", ABORT, NULL);
    }

    if (!other_it)
    {
        BAD_PARAMETER.error ("ELIST_ITERATOR::extract_sublist", ABORT, "other_it NULL");
    }

    if (!list)
    {
        NO_LIST.error ("ELIST_ITERATOR::extract_sublist", ABORT, NULL);
    }

    if (list != other_it->list)
    {
        BAD_EXTRACTION_PTS.error ("ELIST_ITERATOR.extract_sublist", ABORT, NULL);
    }

    if (list->empty ())
    {
        EMPTY_LIST.error ("ELIST_ITERATOR::extract_sublist", ABORT, NULL);
    }

    if (!current || !other_it->current)
    {
        DONT_EXTRACT_DELETED.error ("ELIST_ITERATOR.extract_sublist", ABORT, NULL);
    }
#endif

    ex_current_was_last = other_it->ex_current_was_last = FALSE;
    ex_current_was_cycle_pt = FALSE;
    other_it->ex_current_was_cycle_pt = FALSE;

    temp_it.mark_cycle_pt ();
    do
    {
        //walk sublist
        if (temp_it.cycled_list ())  //cant find end pt
        {
            BAD_SUBLIST.error ("ELIST_ITERATOR.extract_sublist", ABORT, NULL);
        }

        if (temp_it.at_last ())
        {
            list->last = prev;
            ex_current_was_last = other_it->ex_current_was_last = TRUE;
        }

        if (temp_it.current == cycle_pt)
        {
            ex_current_was_cycle_pt = TRUE;
        }

        if (temp_it.current == other_it->cycle_pt)
        {
            other_it->ex_current_was_cycle_pt = TRUE;
        }

        temp_it.forward ();
    }
    while (temp_it.prev != other_it->current);

    //circularise sublist
    other_it->current->next = current;
    end_of_new_list = other_it->current;

    //sublist = whole list
    if (prev == other_it->current)
    {
        list->last = NULL;
        prev = current = next = NULL;
        other_it->prev = other_it->current = other_it->next = NULL;
    }
    else
    {
        prev->next = other_it->next;
        current = other_it->current = NULL;
        next = other_it->next;
        other_it->prev = prev;
    }
    return end_of_new_list;
}
/////////////////////////////////////////////////////////////////elst/////////////////////////////////

//////////////////////////////////////////////////////////////stepblob/////////////////////////////////////////////
ELISTIZE_S (C_BLOB)
/**********************************************************************
 * position_outline
 *
 * Position the outline in the given list at the relevant place
 * according to its nesting.
 **********************************************************************/

//put in place
static void position_outline(C_OUTLINE *outline,       //thing to place
                             C_OUTLINE_LIST *destlist  //desstination list
                            )
{
  C_OUTLINE *dest_outline;       //outline from dest list
  C_OUTLINE_IT it = destlist;    //iterator

  //iterator on children
  C_OUTLINE_IT child_it = outline->child ();

  if (!it.empty ())
  {
    do
      {
      dest_outline = it.data (); //get destination

      //encloses dest
      if (*dest_outline < *outline)
      {
       //take off list
        dest_outline = it.extract ();

        //put this in place
        it.add_after_then_move (outline);

        //make it a child
        child_it.add_to_end (dest_outline);

        while (!it.at_last ())
        {
          it.forward ();         //do rest of list

          //check for other children
          dest_outline = it.data ();
          if (*dest_outline < *outline)
          {
           //take off list
            dest_outline = it.extract ();
            child_it.add_to_end (dest_outline);

            //make it a child
            if (it.empty ()) break;
          }
        }

        return;                  //finished
      }
      else if (*outline < *dest_outline) //enclosed by dest
      {
        position_outline (outline, dest_outline->child ());

        //place in child list
        return;                  //finished
      }
      it.forward ();
    }
    while (!it.at_first ());
  }

  it.add_to_end (outline);       //at outer level
}


/**********************************************************************
 * plot_outline_list
 *
 * Draw a list of outlines in the given colour and their children
 * in the child colour.
 **********************************************************************/

#ifndef GRAPHICS_DISABLED
//draw outlines
static void plot_outline_list(C_OUTLINE_LIST *list,  //outline to draw
                              ScrollView* window,         //window to draw in
                              ScrollView::Color colour,         //colour to use
                              ScrollView::Color child_colour    //colour of children
                             )
{
  C_OUTLINE *outline;            //current outline
  C_OUTLINE_IT it = list;        //iterator

  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
  {
    outline = it.data ();

    //draw it
    outline->plot (window, colour);
    if (!outline->child ()->empty ())
    {
      plot_outline_list (outline->child (), window, child_colour, child_colour);
    }
  }
}
#endif


/**********************************************************************
 * reverse_outline_list
 *
 * Reverse a list of outlines and their children.
 **********************************************************************/
//reverse outlines               //outline to reverse
static void reverse_outline_list(C_OUTLINE_LIST *list)
{
  C_OUTLINE *outline;            //current outline
  C_OUTLINE_IT it = list;        //iterator

  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
  {
    outline = it.data ();
    outline->reverse ();         //reverse it

    if (!outline->child ()->empty ())
    {
      reverse_outline_list (outline->child ());
    }
  }
}


/**********************************************************************
 * C_BLOB::C_BLOB
 *
 * Constructor to build a C_BLOB from a list of C_OUTLINEs.
 * The C_OUTLINEs are not copied so the source list is emptied.
 * The C_OUTLINEs are nested correctly in the blob.
 **********************************************************************/
//constructor           //in random order
C_BLOB::C_BLOB(C_OUTLINE_LIST *outline_list)
{
  C_OUTLINE *outline;            //current outline
  C_OUTLINE_IT it = outline_list;//iterator

  while (!it.empty ())
  {
    //grab the list
    outline = it.extract ();     //get off the list

    //put it in place
    position_outline(outline, &outlines);

    if (!it.empty()) it.forward();
  }
  it.set_to_list (&outlines);

  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
  {
    outline = it.data ();

    if (outline->turn_direction () < 0)
    {
      outline->reverse ();
      reverse_outline_list (outline->child ());
      outline->set_flag (COUT_INVERSE, TRUE);
    }
    else
    {
      outline->set_flag (COUT_INVERSE, FALSE);
    }
  }
}

// Build and return a fake blob containing a single fake outline with no
// steps.
C_BLOB* C_BLOB::FakeBlob(const TBOX& box)
{
  C_OUTLINE_LIST outlines;
  C_OUTLINE::FakeOutline(box, &outlines);

  return new C_BLOB(&outlines);
}

/**********************************************************************
 * C_BLOB::bounding_box
 *
 * Return the bounding box of the blob.
 **********************************************************************/

TBOX C_BLOB::bounding_box()
{  //bounding box
  C_OUTLINE *outline;            //current outline
  C_OUTLINE_IT it = &outlines;   //outlines of blob
  TBOX box;                       //bounding box

  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
  {
    outline = it.data ();
    box += outline->bounding_box ();
  }

  return box;
}


/**********************************************************************
 * C_BLOB::area
 *
 * Return the area of the blob.
 **********************************************************************/

inT32 C_BLOB::area()
{
  //area
  C_OUTLINE *outline;            //current outline
  C_OUTLINE_IT it = &outlines;   //outlines of blob
  inT32 total;                   //total area

  total = 0;
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
  {
    outline = it.data();
    total += outline->area();
  }

  return total;
}

/**********************************************************************
 * C_BLOB::perimeter
 *
 * Return the perimeter of the top and 2nd level outlines.
 **********************************************************************/

inT32 C_BLOB::perimeter()
{
  C_OUTLINE *outline;            // current outline
  C_OUTLINE_IT it = &outlines;   // outlines of blob
  inT32 total;                   // total perimeter

  total = 0;
  for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
  {
    outline = it.data();
    total += outline->perimeter();
  }

  return total;
}


/**********************************************************************
 * C_BLOB::outer_area
 *
 * Return the area of the blob.
 **********************************************************************/

inT32 C_BLOB::outer_area()
{
  //area
  C_OUTLINE *outline;            //current outline
  C_OUTLINE_IT it = &outlines;   //outlines of blob
  inT32 total;                   //total area

  total = 0;
  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
  {
    outline = it.data ();
    total += outline->outer_area ();
  }

  return total;
}


/**********************************************************************
 * C_BLOB::count_transitions
 *
 * Return the total x and y maxes and mins in the blob.
 * Chlid outlines are not counted.
 **********************************************************************/
//area                          //on size
inT32 C_BLOB::count_transitions(inT32 threshold)
{
  C_OUTLINE *outline;            //current outline
  C_OUTLINE_IT it = &outlines;   //outlines of blob
  inT32 total;                   //total area

  total = 0;
  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
  {
    outline = it.data ();
    total += outline->count_transitions (threshold);
  }

  return total;
}


/**********************************************************************
 * C_BLOB::move
 *
 * Move C_BLOB by vector
 **********************************************************************/

void C_BLOB::move(                  // reposition blob
                  const ICOORD vec  // by vector
                 )
{
  C_OUTLINE_IT it(&outlines);  // iterator

  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
  {
    it.data ()->move (vec);      // move each outline
  }
}

// Static helper for C_BLOB::rotate to allow recursion of child outlines.
void RotateOutlineList(const FCOORD& rotation, C_OUTLINE_LIST* outlines)
{
  C_OUTLINE_LIST new_outlines;
  C_OUTLINE_IT src_it(outlines);
  C_OUTLINE_IT dest_it(&new_outlines);

  while (!src_it.empty())
  {
    C_OUTLINE* old_outline = src_it.extract();
    src_it.forward();
    C_OUTLINE* new_outline = new C_OUTLINE(old_outline, rotation);

    if (!old_outline->child()->empty())
    {
      RotateOutlineList(rotation, old_outline->child());
      C_OUTLINE_IT child_it(new_outline->child());
      child_it.add_list_after(old_outline->child());
    }
    delete old_outline;

    dest_it.add_to_end(new_outline);
  }

  src_it.add_list_after(&new_outlines);
}

/**********************************************************************
 * C_BLOB::rotate
 *
 * Rotate C_BLOB by rotation.
 * Warning! has to rebuild all the C_OUTLINEs.
 **********************************************************************/
void C_BLOB::rotate(const FCOORD& rotation)
{
  RotateOutlineList(rotation, &outlines);
}


/**********************************************************************
 * C_BLOB::plot
 *
 * Draw the C_BLOB in the given colour.
 **********************************************************************/

#ifndef GRAPHICS_DISABLED
//draw it
void C_BLOB::plot(ScrollView* window,       //window to draw in
                  ScrollView::Color blob_colour,  //main colour
                  ScrollView::Color child_colour  //for holes
                 )
{
  plot_outline_list(&outlines, window, blob_colour, child_colour);
}
#endif
//////////////////////////////////////////////////////////////stepblob/////////////////////////////////////////////

//////////////////////////////////////////////////////////////points////////////////////////////
ELISTIZE_S (ICOORDELT)           //turn to list
bool FCOORD::normalise()
{  //Convert to unit vec
    float len = length ();

    if (len < 0.0000000001)
    {
        return false;
    }

    xcoord /= len;
    ycoord /= len;

    return true;
}

// Set from the given x,y, shrinking the vector to fit if needed.
void ICOORD::set_with_shrink(int x, int y)
{
    // Fit the vector into an ICOORD, which is 16 bit.
    int factor = 1;
    int max_extent = MAX(abs(x), abs(y));
    if (max_extent > MAX_INT16) factor = max_extent / MAX_INT16 + 1;

    xcoord = x / factor;
    ycoord = y / factor;
}

// The fortran/basic sgn function returns -1, 0, 1 if x < 0, x == 0, x > 0
// respectively.
static int sign(int x)
{
    if (x < 0)
    {
        return -1;
    }
    else
    {
        return x > 0 ? 1 : 0;
    }
}

// Setup for iterating over the pixels in a vector by the well-known
// Bresenham rendering algorithm.
// Starting with major/2 in the accumulator, on each step add major_step,
// and then add minor to the accumulator. When the accumulator >= major
// subtract major and step a minor step.

void ICOORD::setup_render(ICOORD* major_step, ICOORD* minor_step, int* major, int* minor) const
{
    int abs_x = abs(xcoord);
    int abs_y = abs(ycoord);

    if (abs_x >= abs_y)
    {
        // X-direction is major.
        major_step->xcoord = sign(xcoord);
        major_step->ycoord = 0;
        minor_step->xcoord = 0;
        minor_step->ycoord = sign(ycoord);
        *major = abs_x;
        *minor = abs_y;
    }
    else
    {
        // Y-direction is major.
        major_step->xcoord = 0;
        major_step->ycoord = sign(ycoord);
        minor_step->xcoord = sign(xcoord);
        minor_step->ycoord = 0;
        *major = abs_y;
        *minor = abs_x;
    }
}

//convert to ascii         //file to write
void ICOORD::serialise_asc(FILE *f)
{
    serialise_INT32(f, xcoord);
    serialise_INT32(f, ycoord);
}

//convert from ascii          //file to write
void ICOORD::de_serialise_asc(FILE *f)
{
    xcoord = (inT16) de_serialise_INT32 (f);
    ycoord = (inT16) de_serialise_INT32 (f);
}

//convert to ascii            //file to write
void ICOORDELT::serialise_asc(FILE *f)
{
    ((ICOORD *) this)->serialise_asc (f);
}

//convert from ascii             //file to write
void ICOORDELT::de_serialise_asc(FILE *f)
{
    ((ICOORD *) this)->de_serialise_asc (f);
}
//////////////////////////////////////////////////////////////points////////////////////////////

//////////////////////////////////////////////////////////////mod128/////////////////////////////////////////////
static inT16 idirtab[] = {
  1000, 0, 998, 49, 995, 98, 989, 146,
  980, 195, 970, 242, 956, 290, 941, 336,
  923, 382, 903, 427, 881, 471, 857, 514,
  831, 555, 803, 595, 773, 634, 740, 671,
  707, 707, 671, 740, 634, 773, 595, 803,
  555, 831, 514, 857, 471, 881, 427, 903,
  382, 923, 336, 941, 290, 956, 242, 970,
  195, 980, 146, 989, 98, 995, 49, 998,
  0, 1000, -49, 998, -98, 995, -146, 989,
  -195, 980, -242, 970, -290, 956, -336, 941,
  -382, 923, -427, 903, -471, 881, -514, 857,
  -555, 831, -595, 803, -634, 773, -671, 740,
  -707, 707, -740, 671, -773, 634, -803, 595,
  -831, 555, -857, 514, -881, 471, -903, 427,
  -923, 382, -941, 336, -956, 290, -970, 242,
  -980, 195, -989, 146, -995, 98, -998, 49,
  -1000, 0, -998, -49, -995, -98, -989, -146,
  -980, -195, -970, -242, -956, -290, -941, -336,
  -923, -382, -903, -427, -881, -471, -857, -514,
  -831, -555, -803, -595, -773, -634, -740, -671,
  -707, -707, -671, -740, -634, -773, -595, -803,
  -555, -831, -514, -857, -471, -881, -427, -903,
  -382, -923, -336, -941, -290, -956, -242, -970,
  -195, -980, -146, -989, -98, -995, -49, -998,
  0, -1000, 49, -998, 98, -995, 146, -989,
  195, -980, 242, -970, 290, -956, 336, -941,
  382, -923, 427, -903, 471, -881, 514, -857,
  555, -831, 595, -803, 634, -773, 671, -740,
  707, -707, 740, -671, 773, -634, 803, -595,
  831, -555, 857, -514, 881, -471, 903, -427,
  923, -382, 941, -336, 956, -290, 970, -242,
  980, -195, 989, -146, 995, -98, 998, -49
};

static ICOORD *dirtab = (ICOORD *) idirtab;

/**********************************************************************
 * DIR128::DIR128
 *
 * Quantize the direction of an FCOORD to make a DIR128.
 **********************************************************************/

DIR128::DIR128(                 //from fcoord
               const FCOORD fc  //vector to quantize
              ) {
  int high, low, current;        //binary search

  low = 0;
  if (fc.y () == 0) {
    if (fc.x () >= 0)
      dir = 0;
    else
      dir = MODULUS / 2;
    return;
  }
  high = MODULUS;
  do {
    current = (high + low) / 2;
    if (dirtab[current] * fc >= 0)
      low = current;
    else
      high = current;
  }
  while (high - low > 1);
  dir = low;
}


/**********************************************************************
 * dir_to_gradient
 *
 * Convert a direction to a vector.
 **********************************************************************/

ICOORD DIR128::vector() const {  //convert to vector
  return dirtab[dir];            //easy really
}
//////////////////////////////////////////////////////////////mod128/////////////////////////////////////////////

//////////////////////////////////////////////////////////////svutil/////////////////////////////////////////////
#ifdef WIN32
struct addrinfo {
  struct sockaddr* ai_addr;
  int ai_addrlen;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
};
#else
#ifdef __linux__
#endif
#endif

// Include automatically generated configuration file if running autoconf.
#ifdef HAVE_CONFIG_H
#endif

const int kBufferSize = 65536;
const int kMaxMsgSize = 4096;

// Signals a thread to exit.
void SVSync::ExitThread() {
#ifdef WIN32
  //ExitThread(0);
#else
  pthread_exit(0);
#endif
}

// Starts a new process.
void SVSync::StartProcess(const char* executable, const char* args) {
#ifdef WIN32
  std::string proc;
  proc.append(executable);
  proc.append(" ");
  proc.append(args);
  std::cout << "Starting " << proc << std::endl;
  STARTUPINFO start_info;
  PROCESS_INFORMATION proc_info;
  GetStartupInfo(&start_info);
  if (!CreateProcess(NULL, const_cast<char*>(proc.c_str()), NULL, NULL, FALSE,
                CREATE_NO_WINDOW | DETACHED_PROCESS, NULL, NULL,
                &start_info, &proc_info))
    return;
#else
  int pid = fork();
  if (pid != 0) {   // The father process returns
  } else {
#ifdef __linux__
    // Make sure the java process terminates on exit, since its
    // broken socket detection seems to be useless.
    prctl(PR_SET_PDEATHSIG, 2, 0, 0, 0);
#endif
    char* mutable_args = strdup(args);
    int argc = 1;
    for (int i = 0; mutable_args[i]; ++i) {
      if (mutable_args[i] == ' ') {
        ++argc;
      }
    }
    char** argv = new char*[argc + 2];
    argv[0] = strdup(executable);
    argv[1] = mutable_args;
    argc = 2;
    bool inquote = false;
    for (int i = 0; mutable_args[i]; ++i) {
      if (!inquote && mutable_args[i] == ' ') {
        mutable_args[i] = '\0';
        argv[argc++] = mutable_args + i + 1;
      } else if (mutable_args[i] == '"') {
        inquote = !inquote;
        mutable_args[i] = ' ';
      }
    }
    argv[argc] = NULL;
    execvp(executable, argv);
  }
#endif
}

SVSemaphore::SVSemaphore() {
#ifdef WIN32
  semaphore_ = CreateSemaphore(0, 0, 10, 0);
#else
  sem_init(&semaphore_, 0, 0);
#endif
}

void SVSemaphore::Signal() {
#ifdef WIN32
  ReleaseSemaphore(semaphore_, 1, NULL);
#else
  sem_post(&semaphore_);
#endif
}

void SVSemaphore::Wait() {
#ifdef WIN32
  WaitForSingleObject(semaphore_, INFINITE);
#else
  sem_wait(&semaphore_);
#endif
}

SVMutex::SVMutex() {
#ifdef WIN32
  mutex_ = CreateMutex(0, FALSE, 0);
#else
  pthread_mutex_init(&mutex_, NULL);
#endif
}

void SVMutex::Lock() {
#ifdef WIN32
  WaitForSingleObject(mutex_, INFINITE);
#else
  pthread_mutex_lock(&mutex_);
#endif
}

void SVMutex::Unlock() {
#ifdef WIN32
  ReleaseMutex(mutex_);
#else
  pthread_mutex_unlock(&mutex_);
#endif
}

// Create new thread.

void SVSync::StartThread(void *(*func)(void*), void* arg) {
#ifdef WIN32
  LPTHREAD_START_ROUTINE f = (LPTHREAD_START_ROUTINE) func;
  DWORD threadid;
  HANDLE newthread = CreateThread(
  NULL,          // default security attributes
  0,             // use default stack size
  f,             // thread function
  arg,           // argument to thread function
  0,             // use default creation flags
  &threadid);    // returns the thread identifier
#else
  pthread_t helper;
  pthread_create(&helper, NULL, func, arg);
#endif
}

// Place a message in the message buffer (and flush it).
void SVNetwork::Send(const char* msg) {
  mutex_send_->Lock();
  msg_buffer_out_.append(msg);
  mutex_send_->Unlock();
}

// Send the whole buffer.
void SVNetwork::Flush() {
  mutex_send_->Lock();
  while (msg_buffer_out_.size() > 0) {
    int i = send(stream_, msg_buffer_out_.c_str(), msg_buffer_out_.length(), 0);
    msg_buffer_out_.erase(0, i);
  }
  mutex_send_->Unlock();
}

// Receive a message from the server.
// This will always return one line of char* (denoted by \n).
char* SVNetwork::Receive() {
  char* result = NULL;
#ifdef WIN32
  if (has_content) { result = strtok (NULL, "\n"); }
#else
  if (buffer_ptr_ != NULL) { result = strtok_r(NULL, "\n", &buffer_ptr_); }
#endif

  // This means there is something left in the buffer and we return it.
  if (result != NULL) { return result;
  // Otherwise, we read from the stream_.
  } else {
    buffer_ptr_ = NULL;
    has_content = false;

    // The timeout length is not really important since we are looping anyway
    // until a new message is delivered.
    struct timeval tv;
    tv.tv_sec = 10;
    tv.tv_usec = 0;

    // Set the flags to return when the stream_ is ready to be read.
    fd_set readfds;
    FD_ZERO(&readfds);
    FD_SET(stream_, &readfds);

    int i = select(stream_+1, &readfds, NULL, NULL, &tv);

    // The stream_ died.
    if (i == 0) { return NULL; }

    // Read the message buffer.
    i = recv(stream_, msg_buffer_in_, kMaxMsgSize, 0);

    // Server quit (0) or error (-1).
    if (i <= 0) { return NULL; }
    msg_buffer_in_[i] = '\0';
    has_content = true;
#ifdef WIN32
    return strtok(msg_buffer_in_,"\n");
#else
    // Setup a new string tokenizer.
    return strtok_r(msg_buffer_in_, "\n", &buffer_ptr_);
#endif
  }
}

// Close the connection to the server.
void SVNetwork::Close() {
#ifdef WIN32
  closesocket(stream_);
#else
  close(stream_);
#endif
}


// The program to invoke to start ScrollView
static const char* ScrollViewProg() {
#ifdef WIN32
  const char* prog = "java -Xms512m -Xmx1024m";
#else
  const char* prog = "sh";
#endif
  return prog;
}


// The arguments to the program to invoke to start ScrollView
static std::string ScrollViewCommand(std::string scrollview_path) {
  // The following ugly ifdef is to enable the output of the java runtime
  // to be sent down a black hole on non-windows to ignore all the
  // exceptions in piccolo. Ideally piccolo would be debugged to make
  // this unnecessary.
  // Also the path has to be separated by ; on windows and : otherwise.
#ifdef WIN32
  const char* cmd_template = "-Djava.library.path=%s -cp %s/ScrollView.jar;"
      "%s/piccolo-1.2.jar;%s/piccolox-1.2.jar"
      " com.google.scrollview.ScrollView";
#else
  const char* cmd_template = "-c \"trap 'kill %1' 0 1 2 ; java "
      "-Xms1024m -Xmx2048m -Djava.library.path=%s -cp %s/ScrollView.jar:"
      "%s/piccolo-1.2.jar:%s/piccolox-1.2.jar"
      " com.google.scrollview.ScrollView"
      " >/dev/null 2>&1 & wait\"";
#endif
  int cmdlen = strlen(cmd_template) + 4*strlen(scrollview_path.c_str()) + 1;
  char* cmd = new char[cmdlen];
  const char* sv_path = scrollview_path.c_str();
  snprintf(cmd, cmdlen, cmd_template, sv_path, sv_path, sv_path, sv_path);
  std::string command(cmd);
  delete [] cmd;
  return command;
}


// Platform-independent freeaddrinfo()
static void FreeAddrInfo(struct addrinfo* addr_info) {
  #if defined(__linux__)
  freeaddrinfo(addr_info);
  #else
  delete addr_info->ai_addr;
  delete addr_info;
  #endif
}


// Non-linux version of getaddrinfo()
#if !defined(__linux__)
static int GetAddrInfoNonLinux(const char* hostname, int port,
                               struct addrinfo** addr_info) {
// Get the host data depending on the OS.
  struct sockaddr_in* address;
  *addr_info = new struct addrinfo;
  memset(*addr_info, 0, sizeof(struct addrinfo));
  address = new struct sockaddr_in;
  memset(address, 0, sizeof(struct sockaddr_in));

  (*addr_info)->ai_addr = (struct sockaddr*) address;
  (*addr_info)->ai_addrlen = sizeof(struct sockaddr);
  (*addr_info)->ai_family = AF_INET;
  (*addr_info)->ai_socktype = SOCK_STREAM;

  struct hostent *name;
#ifdef WIN32
  WSADATA wsaData;
  WSAStartup(MAKEWORD(1, 1), &wsaData);
  name = gethostbyname(hostname);
#else
  name = gethostbyname(hostname);
#endif

  if (name == NULL) {
    FreeAddrInfo(*addr_info);
    *addr_info = NULL;
    return -1;
  }

  // Fill in the appropriate variables to be able to connect to the server.
  address->sin_family = name->h_addrtype;
  memcpy((char *) &address->sin_addr.s_addr,
         name->h_addr_list[0], name->h_length);
  address->sin_port = htons(port);
  return 0;
}
#endif


// Platform independent version of getaddrinfo()
//   Given a hostname:port, produce an addrinfo struct
static int GetAddrInfo(const char* hostname, int port,
                       struct addrinfo** address) {
#if defined(__linux__)
  char port_str[40];
  snprintf(port_str, 40, "%d", port);
  return getaddrinfo(hostname, port_str, NULL, address);
#else
  return GetAddrInfoNonLinux(hostname, port, address);
#endif
}


// Set up a connection to a ScrollView on hostname:port.
SVNetwork::SVNetwork(const char* hostname, int port) {
  mutex_send_ = new SVMutex();
  msg_buffer_in_ = new char[kMaxMsgSize + 1];
  msg_buffer_in_[0] = '\0';

  has_content = false;
  buffer_ptr_ = NULL;

  struct addrinfo *addr_info = NULL;

  if (GetAddrInfo(hostname, port, &addr_info) != 0) {
  }

  stream_ = socket(addr_info->ai_family, addr_info->ai_socktype,
                   addr_info->ai_protocol);

  // If server is not there, we will start a new server as local child process.
  if (connect(stream_, addr_info->ai_addr, addr_info->ai_addrlen) < 0) {
    const char* scrollview_path = getenv("SCROLLVIEW_PATH");
    if (scrollview_path == NULL) {
#ifdef SCROLLVIEW_PATH
#define _STR(a) #a
#define _XSTR(a) _STR(a)
      scrollview_path = _XSTR(SCROLLVIEW_PATH);
#undef _XSTR
#undef _STR
#else
      scrollview_path = ".";
#endif
    }
    const char *prog = ScrollViewProg();
    std::string command = ScrollViewCommand(scrollview_path);
    SVSync::StartProcess(prog, command.c_str());

    // Wait for server to show up.
    // Note: There is no exception handling in case the server never turns up.
    while (connect(stream_, (struct sockaddr *) addr_info->ai_addr,
                   addr_info->ai_addrlen) < 0) {
#ifdef WIN32
      Sleep(1000);
#else
      sleep(1);
#endif
    }
  }
  FreeAddrInfo(addr_info);
}

SVNetwork::~SVNetwork() {
  delete[] msg_buffer_in_;
  delete mutex_send_;
}
//////////////////////////////////////////////////////////////svutil/////////////////////////////////////////////

//////////////////////////////////////////////////////////////scrollview/////////////////////////////////////////////
// Include automatically generated configuration file if running autoconf.
#ifdef HAVE_CONFIG_H
#endif

#ifndef GRAPHICS_DISABLED
// This class contains the main ScrollView-logic,
// e.g. parsing & sending messages, images etc.
#ifdef _MSC_VER
#pragma warning(disable:4786)  // Don't give stupid warnings for stl
#pragma warning(disable:4018)  // signed/unsigned warnings
#pragma warning(disable:4530)  // exception warnings
#endif

const int kSvPort = 8461;
//const int kMaxMsgSize = 4096;
const int kMaxIntPairSize = 45;  // Holds %d,%d, for upto 64 bit.

struct SVPolyLineBuffer {
  bool empty;  // Independent indicator to allow SendMsg to call SendPolygon.
  std::vector<int> xcoords;
  std::vector<int> ycoords;
};

// A map between the window IDs and their corresponding pointers.
static std::map<int, ScrollView*> svmap;
static SVMutex* svmap_mu;
// A map of all semaphores waiting for a specific event on a specific window.
static std::map<std::pair<ScrollView*, SVEventType>,
                std::pair<SVSemaphore*, SVEvent*> > waiting_for_events;
static SVMutex* waiting_for_events_mu;

SVEvent* SVEvent::copy() {
  SVEvent* any = new SVEvent;
  any->command_id = command_id;
  any->counter = counter;
  any->parameter = new char[strlen(parameter) + 1];
  strncpy(any->parameter, parameter, strlen(parameter));
  any->parameter[strlen(parameter)] = '\0';
  any->type = type;
  any->x = x;
  any->y = y;
  any->x_size = x_size;
  any->y_size = y_size;
  any->window = window;
  return any;
}

/// This is the main loop which handles the ScrollView-logic from the server
/// to the client. It basically loops through messages, parses them to events
/// and distributes it to the waiting handlers.
/// It is run from a different thread and synchronizes via SVSync.
void* ScrollView::MessageReceiver(void* a)
{
    Q_UNUSED(a);
  int counter_event_id = 0;  // ongoing counter
  char* message = NULL;
  // Wait until a new message appears in the input stream_.
  do {
    message = ScrollView::GetStream()->Receive();
  } while (message == NULL);

// This is the main loop which iterates until the server is dead (strlen = -1).
// It basically parses for 3 different messagetypes and then distributes the
// events accordingly.
  while ((int)strlen(message) != -1) {
      // The new event we create.
      SVEvent* cur = new SVEvent;
      // The ID of the corresponding window.
      int window_id;

      int ev_type;

      int n;
      // Fill the new SVEvent properly.
      sscanf(message, "%d,%d,%d,%d,%d,%d,%d,%n", &window_id, &ev_type, &cur->x,
             &cur->y, &cur->x_size, &cur->y_size, &cur->command_id, &n);
      char* p = (message + n);

      svmap_mu->Lock();
      cur->window = svmap[window_id];

      if (cur->window != NULL) {
        cur->parameter = new char[strlen(p) + 1];
        strncpy(cur->parameter, p, strlen(p) + 1);
        if (strlen(p) > 0) {  // remove the last \n
          cur->parameter[strlen(p)] = '\0';
        }
        cur->type = static_cast<SVEventType>(ev_type);
        cur->y = cur->window->TranslateYCoordinate(cur->y);
        cur->counter = counter_event_id;
        // Increase by 2 since we will also create an SVET_ANY event from cur,
        // which will have a counter_id of cur + 1 (and thus gets processed
        // after cur).
        counter_event_id += 2;

        // In case of an SVET_EXIT event, quit the whole application.
        if (ev_type == SVET_EXIT) { ScrollView::Exit(); }

        // Place two copies of it in the table for the window.
        cur->window->SetEvent(cur);

        // Check if any of the threads currently waiting want it.
        std::pair<ScrollView*, SVEventType> awaiting_list(cur->window,
                                                          cur->type);
        std::pair<ScrollView*, SVEventType> awaiting_list_any(cur->window,
                                                              SVET_ANY);
        std::pair<ScrollView*, SVEventType> awaiting_list_any_window((ScrollView*)0,
                                                              SVET_ANY);
        waiting_for_events_mu->Lock();
        if (waiting_for_events.count(awaiting_list) > 0) {
          waiting_for_events[awaiting_list].second = cur;
          waiting_for_events[awaiting_list].first->Signal();
        } else if (waiting_for_events.count(awaiting_list_any) > 0) {
          waiting_for_events[awaiting_list_any].second = cur;
          waiting_for_events[awaiting_list_any].first->Signal();
        } else if (waiting_for_events.count(awaiting_list_any_window) > 0) {
          waiting_for_events[awaiting_list_any_window].second = cur;
          waiting_for_events[awaiting_list_any_window].first->Signal();
        } else {
          // No one wanted it, so delete it.
          delete cur;
        }
        waiting_for_events_mu->Unlock();
        // Signal the corresponding semaphore twice (for both copies).
        ScrollView* sv = svmap[window_id];
        if (sv != NULL) {
          sv->Signal();
          sv->Signal();
        }
      }
      svmap_mu->Unlock();

      // Wait until a new message appears in the input stream_.
      do {
        message = ScrollView::GetStream()->Receive();
      } while (message == NULL);
    }
  return 0;
}

// Table to implement the color index values in the old system.
int table_colors[ScrollView::GREEN_YELLOW+1][4]= {
  {0, 0, 0, 0},        // NONE (transparent)
  {0, 0, 0, 255},        // BLACK.
  {255, 255, 255, 255},  // WHITE.
  {255, 0, 0, 255},      // RED.
  {255, 255, 0, 255},    // YELLOW.
  {0, 255, 0, 255},      // GREEN.
  {0, 255, 255, 255},    // CYAN.
  {0, 0, 255, 255},      // BLUE.
  {255, 0, 255, 255},    // MAGENTA.
  {0, 128, 255, 255},    // AQUAMARINE.
  {0, 0, 64, 255},       // DARK_SLATE_BLUE.
  {128, 128, 255, 255},  // LIGHT_BLUE.
  {64, 64, 255, 255},    // MEDIUM_BLUE.
  {0, 0, 32, 255},       // MIDNIGHT_BLUE.
  {0, 0, 128, 255},      // NAVY_BLUE.
  {192, 192, 255, 255},  // SKY_BLUE.
  {64, 64, 128, 255},    // SLATE_BLUE.
  {32, 32, 64, 255},     // STEEL_BLUE.
  {255, 128, 128, 255},  // CORAL.
  {128, 64, 0, 255},     // BROWN.
  {128, 128, 0, 255},    // SANDY_BROWN.
  {192, 192, 0, 255},    // GOLD.
  {192, 192, 128, 255},  // GOLDENROD.
  {0, 64, 0, 255},       // DARK_GREEN.
  {32, 64, 0, 255},      // DARK_OLIVE_GREEN.
  {64, 128, 0, 255},     // FOREST_GREEN.
  {128, 255, 0, 255},    // LIME_GREEN.
  {192, 255, 192, 255},  // PALE_GREEN.
  {192, 255, 0, 255},    // YELLOW_GREEN.
  {192, 192, 192, 255},  // LIGHT_GREY.
  {64, 64, 128, 255},    // DARK_SLATE_GREY.
  {64, 64, 64, 255},     // DIM_GREY.
  {128, 128, 128, 255},  // GREY.
  {64, 192, 0, 255},     // KHAKI.
  {255, 0, 192, 255},    // MAROON.
  {255, 128, 0, 255},    // ORANGE.
  {255, 128, 64, 255},   // ORCHID.
  {255, 192, 192, 255},  // PINK.
  {128, 0, 128, 255},    // PLUM.
  {255, 0, 64, 255},     // INDIAN_RED.
  {255, 64, 0, 255},     // ORANGE_RED.
  {255, 0, 192, 255},    // VIOLET_RED.
  {255, 192, 128, 255},  // SALMON.
  {128, 128, 0, 255},    // TAN.
  {0, 255, 255, 255},    // TURQUOISE.
  {0, 128, 128, 255},    // DARK_TURQUOISE.
  {192, 0, 255, 255},    // VIOLET.
  {128, 128, 0, 255},    // WHEAT.
  {128, 255, 0, 255}     // GREEN_YELLOW
};


/*******************************************************************************
* Scrollview implementation.
*******************************************************************************/

SVNetwork* ScrollView::stream_ = NULL;
int ScrollView::nr_created_windows_ = 0;

/// Calls Initialize with all arguments given.
ScrollView::ScrollView(const char* name, int x_pos, int y_pos, int x_size,
                       int y_size, int x_canvas_size, int y_canvas_size,
                       bool y_axis_reversed, const char* server_name) {
  Initialize(name, x_pos, y_pos, x_size, y_size, x_canvas_size, y_canvas_size,
             y_axis_reversed, server_name);}

/// Calls Initialize with default argument for server_name_.
ScrollView::ScrollView(const char* name, int x_pos, int y_pos, int x_size,
                       int y_size, int x_canvas_size, int y_canvas_size,
                       bool y_axis_reversed) {
  Initialize(name, x_pos, y_pos, x_size, y_size, x_canvas_size, y_canvas_size,
             y_axis_reversed, "localhost");
}

/// Calls Initialize with default argument for server_name_ & y_axis_reversed.
ScrollView::ScrollView(const char* name, int x_pos, int y_pos, int x_size,
                       int y_size, int x_canvas_size, int y_canvas_size) {
  Initialize(name, x_pos, y_pos, x_size, y_size, x_canvas_size, y_canvas_size,
             false, "localhost");
}

/// Sets up a ScrollView window, depending on the constructor variables.
void ScrollView::Initialize(const char* name, int x_pos, int y_pos, int x_size,
                            int y_size, int x_canvas_size, int y_canvas_size,
                            bool y_axis_reversed, const char* server_name) {
  // If this is the first ScrollView Window which gets created, there is no
  // network connection yet and we have to set it up in a different thread.
  if (stream_ == NULL) {
    nr_created_windows_ = 0;
    stream_ = new SVNetwork(server_name, kSvPort);
    waiting_for_events_mu = new SVMutex();
    svmap_mu = new SVMutex();
    SendRawMessage(
        "svmain = luajava.bindClass('com.google.scrollview.ScrollView')\n");
    SVSync::StartThread(MessageReceiver, NULL);
  }

  // Set up the variables on the clientside.
  nr_created_windows_++;
  event_handler_ = NULL;
  event_handler_ended_ = false;
  y_axis_is_reversed_ = y_axis_reversed;
  y_size_ = y_canvas_size;
  window_name_ = name;
  window_id_ = nr_created_windows_;
  // Set up polygon buffering.
  points_ = new SVPolyLineBuffer;
  points_->empty = true;

  svmap_mu->Lock();
  svmap[window_id_] = this;
  svmap_mu->Unlock();

  for (int i = 0; i < SVET_COUNT; i++) {
    event_table_[i] = NULL;
  }

  mutex_ = new SVMutex();
  semaphore_ = new SVSemaphore();

  // Set up an actual Window on the client side.
  char message[kMaxMsgSize];
  snprintf(message, sizeof(message),
           "w%u = luajava.newInstance('com.google.scrollview.ui"
           ".SVWindow','%s',%u,%u,%u,%u,%u,%u,%u)\n",
           window_id_, window_name_, window_id_,
           x_pos, y_pos, x_size, y_size, x_canvas_size, y_canvas_size);
  SendRawMessage(message);

  SVSync::StartThread(StartEventHandler, this);
}

/// Sits and waits for events on this window.
void* ScrollView::StartEventHandler(void* a) {
  ScrollView* sv = reinterpret_cast<ScrollView*>(a);
  SVEvent* new_event;

  do {
    stream_->Flush();
    sv->semaphore_->Wait();
    new_event = NULL;
    int serial = -1;
    int k = -1;
    sv->mutex_->Lock();
    // Check every table entry if he is is valid and not already processed.

    for (int i = 0; i < SVET_COUNT; i++) {
      if (sv->event_table_[i] != NULL &&
          (serial < 0 || sv->event_table_[i]->counter < serial)) {
        new_event = sv->event_table_[i];
        serial = sv->event_table_[i]->counter;
        k = i;
      }
    }
    // If we didnt find anything we had an old alarm and just sleep again.
    if (new_event != NULL) {
      sv->event_table_[k] = NULL;
      sv->mutex_->Unlock();
      if (sv->event_handler_ != NULL) { sv->event_handler_->Notify(new_event); }
      if (new_event->type == SVET_DESTROY) {
        // Signal the destructor that it is safe to terminate.
        sv->event_handler_ended_ = true;
        sv = NULL;
      }
      delete new_event;  // Delete the pointer after it has been processed.
    } else { sv->mutex_->Unlock(); }
  // The thread should run as long as its associated window is alive.
  } while (sv != NULL);
  return 0;
}

ScrollView::~ScrollView() {
  svmap_mu->Lock();
  if (svmap[window_id_] != NULL) {
    svmap_mu->Unlock();
    // So the event handling thread can quit.
    SendMsg("destroy()");

    SVEvent* sve = AwaitEvent(SVET_DESTROY);
    delete sve;
    svmap_mu->Lock();
    svmap[window_id_] = NULL;
    svmap_mu->Unlock();
    // The event handler thread for this window *must* receive the
    // destroy event and set its pointer to this to NULL before we allow
    // the destructor to exit.
    while (!event_handler_ended_)
      Update();
  } else {
    svmap_mu->Unlock();
  }
  delete mutex_;
  delete semaphore_;
  delete points_;
}

/// Send a message to the server, attaching the window id.
void ScrollView::SendMsg(const char* format, ...) {
  if (!points_->empty)
    SendPolygon();
  va_list args;
  char message[kMaxMsgSize];

  va_start(args, format);  // variable list
  vsnprintf(message, kMaxMsgSize, format, args);
  va_end(args);

  char form[kMaxMsgSize];
  snprintf(form, kMaxMsgSize, "w%u:%s\n", window_id_, message);

  stream_->Send(form);
}

/// Send a message to the server without a
/// window id. Used for global events like exit().
void ScrollView::SendRawMessage(const char* msg) {
  stream_->Send(msg);
}

/// Add an Event Listener to this ScrollView Window
void ScrollView::AddEventHandler(SVEventHandler* listener) {
  event_handler_ = listener;
}

void ScrollView::Signal() {
  semaphore_->Signal();
}

void ScrollView::SetEvent(SVEvent* svevent) {
// Copy event
  SVEvent* any = svevent->copy();
  SVEvent* specific = svevent->copy();
  any->counter = specific->counter + 1;

// Place both events into the queue.
  mutex_->Lock();
  // Delete the old objects..
  if (event_table_[specific->type] != NULL) {
    delete event_table_[specific->type]; }
  if (event_table_[SVET_ANY] != NULL) {
    delete event_table_[SVET_ANY]; }
  // ...and put the new ones in the table.
  event_table_[specific->type] = specific;
  event_table_[SVET_ANY] = any;
  mutex_->Unlock();
}


/// Block until an event of the given type is received.
/// Note: The calling function is responsible for deleting the returned
/// SVEvent afterwards!
SVEvent* ScrollView::AwaitEvent(SVEventType type) {
  // Initialize the waiting semaphore.
  SVSemaphore* sem = new SVSemaphore();
  std::pair<ScrollView*, SVEventType> ea(this, type);
  waiting_for_events_mu->Lock();
  waiting_for_events[ea] = std::pair<SVSemaphore*, SVEvent*> (sem, (SVEvent*)0);
  waiting_for_events_mu->Unlock();
  // Wait on it, but first flush.
  stream_->Flush();
  sem->Wait();
  // Process the event we got woken up for (its in waiting_for_events pair).
  waiting_for_events_mu->Lock();
  SVEvent* ret = waiting_for_events[ea].second;
  waiting_for_events.erase(ea);
  delete sem;
  waiting_for_events_mu->Unlock();
  return ret;
}

// Block until any event on any window is received.
// No event is returned here!
SVEvent* ScrollView::AwaitEventAnyWindow() {
  // Initialize the waiting semaphore.
  SVSemaphore* sem = new SVSemaphore();
  std::pair<ScrollView*, SVEventType> ea((ScrollView*)0, SVET_ANY);
  waiting_for_events_mu->Lock();
  waiting_for_events[ea] = std::pair<SVSemaphore*, SVEvent*> (sem, (SVEvent*)0);
  waiting_for_events_mu->Unlock();
  // Wait on it.
  stream_->Flush();
  sem->Wait();
  // Process the event we got woken up for (its in waiting_for_events pair).
  waiting_for_events_mu->Lock();
  SVEvent* ret = waiting_for_events[ea].second;
  waiting_for_events.erase(ea);
  waiting_for_events_mu->Unlock();
  return ret;
}

// Send the current buffered polygon (if any) and clear it.
void ScrollView::SendPolygon() {
  if (!points_->empty) {
    points_->empty = true;  // Allows us to use SendMsg.
    int length = points_->xcoords.size();
    // length == 1 corresponds to 2 SetCursors in a row and only the
    // last setCursor has any effect.
    if (length == 2) {
      // An isolated line!
      SendMsg("drawLine(%d,%d,%d,%d)",
              points_->xcoords[0], points_->ycoords[0],
              points_->xcoords[1], points_->ycoords[1]);
    } else if (length > 2) {
      // A polyline.
      SendMsg("createPolyline(%d)", length);
      char coordpair[kMaxIntPairSize];
      std::string decimal_coords;
      for (int i = 0; i < length; ++i) {
        snprintf(coordpair, kMaxIntPairSize, "%d,%d,",
                 points_->xcoords[i], points_->ycoords[i]);
        decimal_coords += coordpair;
      }
      decimal_coords += '\n';
      SendRawMessage(decimal_coords.c_str());
      SendMsg("drawPolyline()");
    }
    points_->xcoords.clear();
    points_->ycoords.clear();
  }
}


/*******************************************************************************
* LUA "API" functions.
*******************************************************************************/

// Sets the position from which to draw to (x,y).
void ScrollView::SetCursor(int x, int y) {
  SendPolygon();
  DrawTo(x, y);
}

// Draws from the current position to (x,y) and sets the new position to it.
void ScrollView::DrawTo(int x, int y) {
  points_->xcoords.push_back(x);
  points_->ycoords.push_back(TranslateYCoordinate(y));
  points_->empty = false;
}

// Draw a line using the current pen color.
void ScrollView::Line(int x1, int y1, int x2, int y2) {
  if (!points_->xcoords.empty() && x1 == points_->xcoords.back() &&
      TranslateYCoordinate(y1) == points_->ycoords.back()) {
    // We are already at x1, y1, so just draw to x2, y2.
    DrawTo(x2, y2);
  } else if (!points_->xcoords.empty() && x2 == points_->xcoords.back() &&
      TranslateYCoordinate(y2) == points_->ycoords.back()) {
    // We are already at x2, y2, so just draw to x1, y1.
    DrawTo(x1, y1);
  } else {
    // This is a new line.
    SetCursor(x1, y1);
    DrawTo(x2, y2);
  }
}

// Set the visibility of the window.
void ScrollView::SetVisible(bool visible) {
  if (visible) { SendMsg("setVisible(true)");
  } else { SendMsg("setVisible(false)"); }
}

// Set the alwaysOnTop flag.
void ScrollView::AlwaysOnTop(bool b) {
  if (b) { SendMsg("setAlwaysOnTop(true)");
  } else { SendMsg("setAlwaysOnTop(false)"); }
}

// Adds a message entry to the message box.
void ScrollView::AddMessage(const char* format, ...) {
  va_list args;
  char message[kMaxMsgSize];
  char form[kMaxMsgSize];

  va_start(args, format);  // variable list
  vsnprintf(message, kMaxMsgSize, format, args);
  va_end(args);

  snprintf(form, kMaxMsgSize, "w%u:%s", window_id_, message);

  char* esc = AddEscapeChars(form);
  SendMsg("addMessage(\"%s\")", esc);
  delete[] esc;
}

// Set a messagebox.
void ScrollView::AddMessageBox() {
  SendMsg("addMessageBox()");
}

// Exit the client completely (and notify the server of it).
void ScrollView::Exit() {
  SendRawMessage("svmain:exit()");
  exit(0);
}

// Clear the canvas.
void ScrollView::Clear() {
  SendMsg("clear()");
}

// Set the stroke width.
void ScrollView::Stroke(float width) {
  SendMsg("setStrokeWidth(%f)", width);
}

// Draw a rectangle using the current pen color.
// The rectangle is filled with the current brush color.
void ScrollView::Rectangle(int x1, int y1, int x2, int y2) {
  if (x1 == x2 && y1 == y2)
    return;  // Scrollviewer locks up.
  SendMsg("drawRectangle(%d,%d,%d,%d)",
    x1, TranslateYCoordinate(y1), x2, TranslateYCoordinate(y2));
}

// Draw an ellipse using the current pen color.
// The ellipse is filled with the current brush color.
void ScrollView::Ellipse(int x1, int y1, int width, int height) {
  SendMsg("drawEllipse(%d,%d,%u,%u)",
    x1, TranslateYCoordinate(y1), width, height);
}

// Set the pen color to the given RGB values.
void ScrollView::Pen(int red, int green, int blue) {
  SendMsg("pen(%d,%d,%d)", red, green, blue);
}

// Set the pen color to the given RGB values.
void ScrollView::Pen(int red, int green, int blue, int alpha) {
  SendMsg("pen(%d,%d,%d,%d)", red, green, blue, alpha);
}

// Set the brush color to the given RGB values.
void ScrollView::Brush(int red, int green, int blue) {
  SendMsg("brush(%d,%d,%d)", red, green, blue);
}

// Set the brush color to the given RGB values.
void ScrollView::Brush(int red, int green, int blue, int alpha) {
  SendMsg("brush(%d,%d,%d,%d)", red, green, blue, alpha);
}

// Set the attributes for future Text(..) calls.
void ScrollView::TextAttributes(const char* font, int pixel_size,
                                bool bold, bool italic, bool underlined) {
  const char* b;
  const char* i;
  const char* u;

  if (bold) { b = "true";
  } else { b = "false"; }
  if (italic) { i = "true";
  } else { i = "false"; }
  if (underlined) { u = "true";
  } else { u = "false"; }
  SendMsg("textAttributes('%s',%u,%s,%s,%s)", font, pixel_size,
    b, i, u);
}

// Draw text at the given coordinates.
void ScrollView::Text(int x, int y, const char* mystring) {
  SendMsg("drawText(%d,%d,'%s')", x, TranslateYCoordinate(y), mystring);
}

// Open and draw an image given a name at (x,y).
void ScrollView::Image(const char* image, int x_pos, int y_pos) {
  SendMsg("openImage('%s')", image);
  SendMsg("drawImage('%s',%d,%d)",
                image, x_pos, TranslateYCoordinate(y_pos));
}

// Add new checkboxmenuentry to menubar.
void ScrollView::MenuItem(const char* parent, const char* name,
                          int cmdEvent, bool flag) {
  if (parent == NULL) { parent = ""; }
  if (flag) { SendMsg("addMenuBarItem('%s','%s',%d,true)",
                      parent, name, cmdEvent);
  } else { SendMsg("addMenuBarItem('%s','%s',%d,false)",
                   parent, name, cmdEvent); }
}

// Add new menuentry to menubar.
void ScrollView::MenuItem(const char* parent, const char* name, int cmdEvent) {
  if (parent == NULL) { parent = ""; }
  SendMsg("addMenuBarItem('%s','%s',%d)", parent, name, cmdEvent);
}

// Add new submenu to menubar.
void ScrollView::MenuItem(const char* parent, const char* name) {
  if (parent == NULL) { parent = ""; }
  SendMsg("addMenuBarItem('%s','%s')", parent, name);
}

// Add new submenu to popupmenu.
void ScrollView::PopupItem(const char* parent, const char* name) {
  if (parent == NULL) { parent = ""; }
  SendMsg("addPopupMenuItem('%s','%s')", parent, name);
}

// Add new submenuentry to popupmenu.
void ScrollView::PopupItem(const char* parent, const char* name,
                           int cmdEvent, const char* value, const char* desc) {
  if (parent == NULL) { parent = ""; }
  char* esc = AddEscapeChars(value);
  char* esc2 = AddEscapeChars(desc);
  SendMsg("addPopupMenuItem('%s','%s',%d,'%s','%s')", parent, name,
          cmdEvent, esc, esc2);
  delete[] esc;
  delete[] esc2;
}

// Send an update message for a single window.
void ScrollView::UpdateWindow() {
  SendMsg("update()");
}

// Note: this is an update to all windows
void ScrollView::Update() {
  svmap_mu->Lock();
  for (std::map<int, ScrollView*>::iterator iter = svmap.begin();
      iter != svmap.end(); ++iter) {
    if (iter->second != NULL)
      iter->second->UpdateWindow();
  }
  svmap_mu->Unlock();
}

// Set the pen color, using an enum value (e.g. ScrollView::ORANGE)
void ScrollView::Pen(Color color) {
  Pen(table_colors[color][0], table_colors[color][1],
      table_colors[color][2], table_colors[color][3]);
}

// Set the brush color, using an enum value (e.g. ScrollView::ORANGE)
void ScrollView::Brush(Color color) {
  Brush(table_colors[color][0],
        table_colors[color][1],
        table_colors[color][2],
        table_colors[color][3]);
}

// Shows a modal Input Dialog which can return any kind of String
char* ScrollView::ShowInputDialog(const char* msg) {
  SendMsg("showInputDialog(\"%s\")", msg);
  SVEvent* ev;
  // wait till an input event (all others are thrown away)
  ev = AwaitEvent(SVET_INPUT);
  char* p = new char[strlen(ev->parameter) + 1];
  strncpy(p, ev->parameter, strlen(ev->parameter));
  p[strlen(ev->parameter)] = '\0';
  delete ev;
  return p;
}

// Shows a modal Yes/No Dialog which will return 'y' or 'n'
int ScrollView::ShowYesNoDialog(const char* msg) {
  SendMsg("showYesNoDialog(\"%s\")", msg);
  SVEvent* ev;
  // Wait till an input event (all others are thrown away)
  ev = AwaitEvent(SVET_INPUT);
  int a = ev->parameter[0];
  delete ev;
  return a;
}

// Zoom the window to the rectangle given upper left corner and
// lower right corner.
void ScrollView::ZoomToRectangle(int x1, int y1, int x2, int y2) {
  y1 = TranslateYCoordinate(y1);
  y2 = TranslateYCoordinate(y2);
  SendMsg("zoomRectangle(%d,%d,%d,%d)",
          MIN(x1, x2), MIN(y1, y2), MAX(x1, x2), MAX(y1, y2));
}

#ifdef HAVE_LIBLEPT
// Send an image of type PIX.
void ScrollView::Image(PIX* image, int x_pos, int y_pos) {
  int width = image->w;
  int height = image->h;
  l_uint32 bpp = image->d;
  // PIX* do not have a unique identifier/name associated, so name them "lept".
  SendMsg("createImage('%s',%d,%d,%d)", "lept", width, height, bpp);

  if (bpp == 32) {
    Transfer32bppImage(image);
  } else if (bpp == 8) {
    TransferGrayImage(image);
  } else if (bpp == 1) {
    TransferBinaryImage(image);
  }
  // PIX* do not have a unique identifier/name associated, so name them "lept".
  SendMsg("drawImage('%s',%d,%d)", "lept", x_pos, y_pos);
}

// Sends each pixel as hex value like html, e.g. #00FF00 for green.
void ScrollView::Transfer32bppImage(PIX* image) {
  int ppL = pixGetWidth(image);
  int h = pixGetHeight(image);
  int wpl = pixGetWpl(image);
  int transfer_size= ppL * 7 + 2;
  char* pixel_data = new char[transfer_size];
  for (int y = 0; y < h; ++y) {
    l_uint32* data = pixGetData(image) + y*wpl;
    for (int x = 0; x < ppL; ++x, ++data) {
      snprintf(&pixel_data[x*7], 7, "#%.2x%.2x%.2x",
               GET_DATA_BYTE(data, COLOR_RED),
               GET_DATA_BYTE(data, COLOR_GREEN),
               GET_DATA_BYTE(data, COLOR_BLUE));
    }
    pixel_data[transfer_size - 2] = '\n';
    pixel_data[transfer_size - 1] = '\0';
    SendRawMessage(pixel_data);
  }
  delete[] pixel_data;
}

// Sends for each pixel either '1' or '0'.
void ScrollView::TransferGrayImage(PIX* image) {
  char* pixel_data = new char[image->w * 2 + 2];
  for (int y = 0; y < image->h; y++) {
    l_uint32* data = pixGetData(image) + y * pixGetWpl(image);
    for (int x = 0; x < image->w; x++) {
      snprintf(&pixel_data[x*2], 2, "%.2x", (GET_DATA_BYTE(data, x)));
      pixel_data[image->w * 2] = '\n';
      pixel_data[image->w * 2 + 1] = '\0';
      SendRawMessage(pixel_data);
    }
  }
  delete [] pixel_data;
}

// Sends for each pixel either '1' or '0'.
void ScrollView::TransferBinaryImage(PIX* image) {
  char* pixel_data = new char[image->w + 2];
  for (int y = 0; y < image->h; y++) {
    l_uint32* data = pixGetData(image) + y * pixGetWpl(image);
    for (int x = 0; x < image->w; x++) {
      if (GET_DATA_BIT(data, x))
        pixel_data[x] = '1';
      else
        pixel_data[x] = '0';
    }
    pixel_data[image->w] = '\n';
    pixel_data[image->w + 1] = '\0';
    SendRawMessage(pixel_data);
  }
  delete [] pixel_data;
}
#endif

// Escapes the ' character with a \, so it can be processed by LUA.
// Note: The caller will have to make sure he deletes the newly allocated item.
char* ScrollView::AddEscapeChars(const char* input) {
  const char* nextptr = strchr(input, '\'');
  const char* lastptr = input;
  char* message = new char[kMaxMsgSize];
  int pos = 0;
  while (nextptr != NULL) {
    strncpy(message+pos, lastptr, nextptr-lastptr);
    pos += nextptr - lastptr;
    message[pos] = '\\';
    pos += 1;
    lastptr = nextptr;
    nextptr = strchr(nextptr+1, '\'');
  }
  strncpy(message+pos, lastptr, strlen(lastptr));
  message[pos+strlen(lastptr)] = '\0';
  return message;
}

// Inverse the Y axis if the coordinates are actually inversed.
int ScrollView::TranslateYCoordinate(int y) {
  if (!y_axis_is_reversed_) { return y;
  } else { return y_size_ - y; }
}

#endif  // GRAPHICS_DISABLED
//////////////////////////////////////////////////////////////scrollview/////////////////////////////////////////////

//////////////////////////////////////////////////////////////quspline/////////////////////////////////////////////
#define QSPLINE_PRECISION 16     //no of steps to draw

/**********************************************************************
 * QSPLINE::QSPLINE
 *
 * Constructor to build a QSPLINE given the components used in the old code.
 **********************************************************************/

QSPLINE::QSPLINE(                 //constructor
                 inT32 count,     //no of segments
                 inT32 *xstarts,  //start coords
                 double *coeffs   //coefficients
                ) {
  inT32 index;                   //segment index

                                 //get memory
  xcoords = (inT32 *) alloc_mem ((count + 1) * sizeof (inT32));
  quadratics = (QUAD_COEFFS *) alloc_mem (count * sizeof (QUAD_COEFFS));
  segments = count;
  for (index = 0; index < segments; index++) {
                                 //copy them
    xcoords[index] = xstarts[index];
    quadratics[index] = QUAD_COEFFS (coeffs[index * 3],
      coeffs[index * 3 + 1],
      coeffs[index * 3 + 2]);
  }
                                 //right edge
  xcoords[index] = xstarts[index];
}


/**********************************************************************
 * QSPLINE::QSPLINE
 *
 * Constructor to build a QSPLINE by appproximation of points.
 **********************************************************************/

QSPLINE::QSPLINE (               //constructor
int xstarts[],                   //spline boundaries
int segcount,                    //no of segments
int xpts[],                      //points to fit
int ypts[], int pointcount,      //no of pts
int degree                       //fit required
) {
  register int pointindex;       /*no along text line */
  register int segment;          /*segment no */
  inT32 *ptcounts;               //no in each segment
  QLSQ qlsq;                     /*accumulator */

  segments = segcount;
  xcoords = (inT32 *) alloc_mem ((segcount + 1) * sizeof (inT32));
  ptcounts = (inT32 *) alloc_mem ((segcount + 1) * sizeof (inT32));
  quadratics = (QUAD_COEFFS *) alloc_mem (segcount * sizeof (QUAD_COEFFS));
  memmove (xcoords, xstarts, (segcount + 1) * sizeof (inT32));
  ptcounts[0] = 0;               /*none in any yet */
  for (segment = 0, pointindex = 0; pointindex < pointcount; pointindex++) {
    while (segment < segcount && xpts[pointindex] >= xstarts[segment]) {
      segment++;                 /*try next segment */
                                 /*cumulative counts */
      ptcounts[segment] = ptcounts[segment - 1];
    }
    ptcounts[segment]++;         /*no in previous partition */
  }
  while (segment < segcount) {
    segment++;
                                 /*zero the rest */
    ptcounts[segment] = ptcounts[segment - 1];
  }

  for (segment = 0; segment < segcount; segment++) {
    qlsq.clear ();
                                 /*first blob */
    pointindex = ptcounts[segment];
    if (pointindex > 0
      && xpts[pointindex] != xpts[pointindex - 1]
      && xpts[pointindex] != xstarts[segment])
      qlsq.add (xstarts[segment],
        ypts[pointindex - 1]
        + (ypts[pointindex] - ypts[pointindex - 1])
        * (xstarts[segment] - xpts[pointindex - 1])
        / (xpts[pointindex] - xpts[pointindex - 1]));
    for (; pointindex < ptcounts[segment + 1]; pointindex++) {
      qlsq.add (xpts[pointindex], ypts[pointindex]);
    }
    if (pointindex > 0 && pointindex < pointcount
      && xpts[pointindex] != xstarts[segment + 1])
      qlsq.add (xstarts[segment + 1],
        ypts[pointindex - 1]
        + (ypts[pointindex] - ypts[pointindex - 1])
        * (xstarts[segment + 1] - xpts[pointindex - 1])
        / (xpts[pointindex] - xpts[pointindex - 1]));
    qlsq.fit (degree);
    quadratics[segment].a = qlsq.get_a ();
    quadratics[segment].b = qlsq.get_b ();
    quadratics[segment].c = qlsq.get_c ();
  }
  free_mem(ptcounts);
}


/**********************************************************************
 * QSPLINE::QSPLINE
 *
 * Constructor to build a QSPLINE from another.
 **********************************************************************/

QSPLINE::QSPLINE(  //constructor
                 const QSPLINE &src) {
  segments = 0;
  xcoords = NULL;
  quadratics = NULL;
  *this = src;
}


/**********************************************************************
 * QSPLINE::~QSPLINE
 *
 * Destroy a QSPLINE.
 **********************************************************************/

QSPLINE::~QSPLINE (              //constructor
) {
  if (xcoords != NULL) {
    free_mem(xcoords);
    xcoords = NULL;
  }
  if (quadratics != NULL) {
    free_mem(quadratics);
    quadratics = NULL;
  }
}


/**********************************************************************
 * QSPLINE::operator=
 *
 * Copy a QSPLINE
 **********************************************************************/

QSPLINE & QSPLINE::operator= (   //assignment
const QSPLINE & source) {
  if (xcoords != NULL)
    free_mem(xcoords);
  if (quadratics != NULL)
    free_mem(quadratics);

  segments = source.segments;
  xcoords = (inT32 *) alloc_mem ((segments + 1) * sizeof (inT32));
  quadratics = (QUAD_COEFFS *) alloc_mem (segments * sizeof (QUAD_COEFFS));
  memmove (xcoords, source.xcoords, (segments + 1) * sizeof (inT32));
  memmove (quadratics, source.quadratics, segments * sizeof (QUAD_COEFFS));
  return *this;
}


/**********************************************************************
 * QSPLINE::step
 *
 * Return the total of the step functions between the given coords.
 **********************************************************************/

double QSPLINE::step(            //find step functions
                     double x1,  //between coords
                     double x2) {
  int index1, index2;            //indices of coords
  double total;                  /*total steps */

  index1 = spline_index (x1);
  index2 = spline_index (x2);
  total = 0;
  while (index1 < index2) {
    total +=
      (double) quadratics[index1 + 1].y ((float) xcoords[index1 + 1]);
    total -= (double) quadratics[index1].y ((float) xcoords[index1 + 1]);
    index1++;                    /*next segment */
  }
  return total;                  /*total steps */
}


/**********************************************************************
 * QSPLINE::y
 *
 * Return the y value at the given x value.
 **********************************************************************/

double QSPLINE::y(          //evaluate
                  double x  //coord to evaluate at
                 ) const {
  inT32 index;                   //segment index

  index = spline_index (x);
  return quadratics[index].y (x);//in correct segment
}


/**********************************************************************
 * QSPLINE::spline_index
 *
 * Return the index to the largest xcoord not greater than x.
 **********************************************************************/

inT32 QSPLINE::spline_index(          //evaluate
                            double x  //coord to evaluate at
                           ) const {
  inT32 index;                   //segment index
  inT32 bottom;                  //bottom of range
  inT32 top;                     //top of range

  bottom = 0;
  top = segments;
  while (top - bottom > 1) {
    index = (top + bottom) / 2;  //centre of range
    if (x >= xcoords[index])
      bottom = index;            //new min
    else
      top = index;               //new max
  }
  return bottom;
}


/**********************************************************************
 * QSPLINE::move
 *
 * Reposition spline by vector
 **********************************************************************/

void QSPLINE::move(            // reposition spline
                   ICOORD vec  // by vector
                  ) {
  inT32 segment;                 //index of segment
  inT16 x_shift = vec.x ();

  for (segment = 0; segment < segments; segment++) {
    xcoords[segment] += x_shift;
    quadratics[segment].move (vec);
  }
  xcoords[segment] += x_shift;
}


/**********************************************************************
 * QSPLINE::overlap
 *
 * Return TRUE if spline2 overlaps this by no more than fraction less
 * than the bounds of this.
 **********************************************************************/

BOOL8 QSPLINE::overlap(                   //test overlap
                       QSPLINE *spline2,  //2 cannot be smaller
                       double fraction    //by more than this
                      ) {
  int leftlimit;                 /*common left limit */
  int rightlimit;                /*common right limit */

  leftlimit = xcoords[1];
  rightlimit = xcoords[segments - 1];
                                 /*or too non-overlap */
  if (spline2->segments < 3 || spline2->xcoords[1] > leftlimit + fraction * (rightlimit - leftlimit)
    || spline2->xcoords[spline2->segments - 1] < rightlimit
    - fraction * (rightlimit - leftlimit))
    return FALSE;
  else
    return TRUE;
}


/**********************************************************************
 * extrapolate_spline
 *
 * Extrapolates the spline linearly using the same gradient as the
 * quadratic has at either end.
 **********************************************************************/

void QSPLINE::extrapolate(                  //linear extrapolation
                          double gradient,  //gradient to use
                          int xmin,         //new left edge
                          int xmax          //new right edge
                         ) {
  register int segment;          /*current segment of spline */
  int dest_segment;              //dest index
  int *xstarts;                  //new boundaries
  QUAD_COEFFS *quads;            //new ones
  int increment;                 //in size

  increment = xmin < xcoords[0] ? 1 : 0;
  if (xmax > xcoords[segments])
    increment++;
  if (increment == 0)
    return;
  xstarts = (int *) alloc_mem ((segments + 1 + increment) * sizeof (int));
  quads =
    (QUAD_COEFFS *) alloc_mem ((segments + increment) * sizeof (QUAD_COEFFS));
  if (xmin < xcoords[0]) {
    xstarts[0] = xmin;
    quads[0].a = 0;
    quads[0].b = gradient;
    quads[0].c = y (xcoords[0]) - quads[0].b * xcoords[0];
    dest_segment = 1;
  }
  else
    dest_segment = 0;
  for (segment = 0; segment < segments; segment++) {
    xstarts[dest_segment] = xcoords[segment];
    quads[dest_segment] = quadratics[segment];
    dest_segment++;
  }
  xstarts[dest_segment] = xcoords[segment];
  if (xmax > xcoords[segments]) {
    quads[dest_segment].a = 0;
    quads[dest_segment].b = gradient;
    quads[dest_segment].c = y (xcoords[segments])
      - quads[dest_segment].b * xcoords[segments];
    dest_segment++;
    xstarts[dest_segment] = xmax + 1;
  }
  segments = dest_segment;
  free_mem(xcoords);
  free_mem(quadratics);
  xcoords = (inT32 *) xstarts;
  quadratics = quads;
}


/**********************************************************************
 * QSPLINE::plot
 *
 * Draw the QSPLINE in the given colour.
 **********************************************************************/

#ifndef GRAPHICS_DISABLED
void QSPLINE::plot(                //draw it
                   ScrollView* window,  //window to draw in
                   ScrollView::Color colour   //colour to draw in
                  ) const {
  inT32 segment;                 //index of segment
  inT16 step;                    //index of poly piece
  double increment;              //x increment
  double x;                      //x coord

  window->Pen(colour);
  for (segment = 0; segment < segments; segment++) {
    increment =
      (double) (xcoords[segment + 1] -
      xcoords[segment]) / QSPLINE_PRECISION;
    x = xcoords[segment];
    for (step = 0; step <= QSPLINE_PRECISION; step++) {
      if (segment == 0 && step == 0)
    window->SetCursor(x, quadratics[segment].y (x));
      else
    window->DrawTo(x, quadratics[segment].y (x));
      x += increment;
    }
  }
}
#endif
//////////////////////////////////////////////////////////////quspline/////////////////////////////////////////////

//////////////////////////////////////////////////////////////rect/////////////////////////////////////////////
// Include automatically generated configuration file if running autoconf.
#ifdef HAVE_CONFIG_H
#endif

/**********************************************************************
 * TBOX::TBOX()  Constructor from 2 ICOORDS
 *
 **********************************************************************/

TBOX::TBOX(                   //construtor
         const ICOORD pt1,  //one corner
         const ICOORD pt2   //the other corner
        ) {
  if (pt1.x () <= pt2.x ()) {
    if (pt1.y () <= pt2.y ()) {
      bot_left = pt1;
      top_right = pt2;
    }
    else {
      bot_left = ICOORD (pt1.x (), pt2.y ());
      top_right = ICOORD (pt2.x (), pt1.y ());
    }
  }
  else {
    if (pt1.y () <= pt2.y ()) {
      bot_left = ICOORD (pt2.x (), pt1.y ());
      top_right = ICOORD (pt1.x (), pt2.y ());
    }
    else {
      bot_left = pt2;
      top_right = pt1;
    }
  }
}

/**********************************************************************
 * TBOX::TBOX()  Constructor from 4 integer values.
 *  Note: It is caller's responsibility to provide values in the right
 *        order.
 **********************************************************************/

TBOX::TBOX(                    //constructor
    inT16 left, inT16 bottom, inT16 right, inT16 top)
    : bot_left(left, bottom), top_right(right, top) {
}

// rotate_large constructs the containing bounding box of all 4
// corners after rotating them. It therefore guarantees that all
// original content is contained within, but also slightly enlarges the box.
void TBOX::rotate_large(const FCOORD& vec) {
  ICOORD top_left(bot_left.x(), top_right.y());
  ICOORD bottom_right(top_right.x(), bot_left.y());
  top_left.rotate(vec);
  bottom_right.rotate(vec);
  rotate(vec);
  TBOX box2(top_left, bottom_right);
  *this += box2;
}

/**********************************************************************
 * TBOX::intersection()  Build the largest box contained in both boxes
 *
 **********************************************************************/

TBOX TBOX::intersection(  //shared area box
                      const TBOX &box) const {
  inT16 left;
  inT16 bottom;
  inT16 right;
  inT16 top;
  if (overlap (box)) {
    if (box.bot_left.x () > bot_left.x ())
      left = box.bot_left.x ();
    else
      left = bot_left.x ();

    if (box.top_right.x () < top_right.x ())
      right = box.top_right.x ();
    else
      right = top_right.x ();

    if (box.bot_left.y () > bot_left.y ())
      bottom = box.bot_left.y ();
    else
      bottom = bot_left.y ();

    if (box.top_right.y () < top_right.y ())
      top = box.top_right.y ();
    else
      top = top_right.y ();
  }
  else {
    left = MAX_INT16;
    bottom = MAX_INT16;
    top = -MAX_INT16;
    right = -MAX_INT16;
  }
  return TBOX (left, bottom, right, top);
}


/**********************************************************************
 * TBOX::bounding_union()  Build the smallest box containing both boxes
 *
 **********************************************************************/

TBOX TBOX::bounding_union(  //box enclosing both
                        const TBOX &box) const {
  ICOORD bl;                     //bottom left
  ICOORD tr;                     //top right

  if (box.bot_left.x () < bot_left.x ())
    bl.set_x (box.bot_left.x ());
  else
    bl.set_x (bot_left.x ());

  if (box.top_right.x () > top_right.x ())
    tr.set_x (box.top_right.x ());
  else
    tr.set_x (top_right.x ());

  if (box.bot_left.y () < bot_left.y ())
    bl.set_y (box.bot_left.y ());
  else
    bl.set_y (bot_left.y ());

  if (box.top_right.y () > top_right.y ())
    tr.set_y (box.top_right.y ());
  else
    tr.set_y (top_right.y ());
  return TBOX (bl, tr);
}


/**********************************************************************
 * TBOX::plot()  Paint a box using specified settings
 *
 **********************************************************************/

#ifndef GRAPHICS_DISABLED
void TBOX::plot(                      //paint box
               ScrollView* fd,       //where to paint
               ScrollView::Color fill_colour,   //colour for inside
               ScrollView::Color border_colour  //colour for border
              ) const {
  fd->Brush(fill_colour);
  fd->Pen(border_colour);
  plot(fd);
}
#endif


/**********************************************************************
 * operator+=
 *
 * Extend one box to include the other  (In place union)
 **********************************************************************/

TBOX &operator+= (                     //bounding bounding bx
TBOX & op1,                       //operands
const TBOX & op2) {
  if (op2.bot_left.x () < op1.bot_left.x ())
    op1.bot_left.set_x (op2.bot_left.x ());

  if (op2.top_right.x () > op1.top_right.x ())
    op1.top_right.set_x (op2.top_right.x ());

  if (op2.bot_left.y () < op1.bot_left.y ())
    op1.bot_left.set_y (op2.bot_left.y ());

  if (op2.top_right.y () > op1.top_right.y ())
    op1.top_right.set_y (op2.top_right.y ());

  return op1;
}


/**********************************************************************
 * operator-=
 *
 * Reduce one box to intersection with the other  (In place intersection)
 **********************************************************************/

TBOX &operator-= (                     //inplace intersection
TBOX & op1,                       //operands
const TBOX & op2) {
  if (op1.overlap (op2)) {
    if (op2.bot_left.x () > op1.bot_left.x ())
      op1.bot_left.set_x (op2.bot_left.x ());

    if (op2.top_right.x () < op1.top_right.x ())
      op1.top_right.set_x (op2.top_right.x ());

    if (op2.bot_left.y () > op1.bot_left.y ())
      op1.bot_left.set_y (op2.bot_left.y ());

    if (op2.top_right.y () < op1.top_right.y ())
      op1.top_right.set_y (op2.top_right.y ());
  }
  else {
    op1.bot_left.set_x (MAX_INT16);
    op1.bot_left.set_y (MAX_INT16);
    op1.top_right.set_x (-MAX_INT16);
    op1.top_right.set_y (-MAX_INT16);
  }
  return op1;
}


/**********************************************************************
 * TBOX::serialise_asc()  Convert to ascii file.
 *
 **********************************************************************/

void TBOX::serialise_asc(         //convert to ascii
                        FILE *f  //file to use
                       ) {
  bot_left.serialise_asc (f);
  top_right.serialise_asc (f);
}


/**********************************************************************
 * TBOX::de_serialise_asc()  Convert from ascii file.
 *
 **********************************************************************/

void TBOX::de_serialise_asc(         //convert from ascii
                           FILE *f  //file to use
                          ) {
  bot_left.de_serialise_asc (f);
  top_right.de_serialise_asc (f);
}
//////////////////////////////////////////////////////////////rect/////////////////////////////////////////////

//////////////////////////////////////////////////////////////bits16/////////////////////////////////////////////
// constructor
BITS16::BITS16(uinT16 init)
{
// initial val
val = init;
}
//////////////////////////////////////////////////////////////bits16/////////////////////////////////////////////

//////////////////////////////////////////////////////////////poutline/////////////////////////////////////////////
// Include automatically generated configuration file if running autoconf.
#ifdef HAVE_CONFIG_H
#endif

ELISTIZE_S (OUTLINE)
/**********************************************************************
 * OUTLINE::OUTLINE
 *
 * Constructor to build a OUTLINE from a compact LOOP.
 **********************************************************************/
OUTLINE::OUTLINE (               //constructor
const ICOORD & startpt,          //start position
inT8 * compactloop,              //from Tess format
BOOL8 invert,                    //reverse it
ICOORD bot_left,                 //bounding box
ICOORD top_right):
box (bot_left, top_right),
start(startpt) {
  ICOORD pos;                    //current point
  ICOORD vec;                    //vector to next
  POLYPT *polypt;                //new point
  inT8 *vector;                  //compact loop
  POLYPT_IT it = &outline;       //iterator

  pos = startpt;
  vector = compactloop;
  do {
                                 //vector to next
    vec = ICOORD (*vector, *(vector + 1));
                                 //make a new one
    polypt = new POLYPT (FCOORD (pos), FCOORD (vec));
                                 //add to list
    it.add_after_then_move (polypt);
    pos += vec;                  //move to next
    vector += 2;
  }
  while (pos != startpt);
  if (invert)
    reverse();  //now reverse it
}


/**********************************************************************
 * OUTLINE::OUTLINE
 *
 * Constructor to build an OUTLINE from a list of POLYPTs.
 **********************************************************************/

OUTLINE::OUTLINE(                    //constructor
                 POLYPT_IT *polypts  //input list
                ) {
  POLYPT_IT other_it = *polypts; //end of list

  polypts->move_to_first ();
  other_it.move_to_last ();
                                 //put in outline
  outline.assign_to_sublist (polypts, &other_it);
  compute_bb();
}


/**********************************************************************
 * OUTLINE::compute_bb
 *
 * Compute the bounding box from the outline points.
 **********************************************************************/

void OUTLINE::compute_bb() {  //constructor
  ICOORD ibl, itr;               //integer bb
  FCOORD botleft;                //bounding box
  FCOORD topright;
  FCOORD pos;                    //current pos;
  POLYPT_IT polypts = &outline;  //iterator

  botleft = polypts.data ()->pos;
  topright = botleft;
  start = ICOORD ((inT16) botleft.x (), (inT16) botleft.y ());
  do {
    pos = polypts.data ()->pos;
    if (pos.x () < botleft.x ())
                                 //get bounding box
      botleft = FCOORD (pos.x (), botleft.y ());
    if (pos.y () < botleft.y ())
      botleft = FCOORD (botleft.x (), pos.y ());
    if (pos.x () > topright.x ())
      topright = FCOORD (pos.x (), topright.y ());
    if (pos.y () > topright.y ())
      topright = FCOORD (topright.x (), pos.y ());
    polypts.forward ();
  }
  while (!polypts.at_first ());
  ibl = ICOORD ((inT16) botleft.x (), (inT16) botleft.y ());
  itr = ICOORD ((inT16) topright.x () + 1, (inT16) topright.y () + 1);
  box = TBOX (ibl, itr);
}


/**********************************************************************
 * OUTLINE::area
 *
 * Compute the area from the outline points.
 **********************************************************************/

float OUTLINE::area() {  //constructor
  FCOORD origin;                 //startpt
  FCOORD prev_vec;               //previous value of vec
  FCOORD vec;                    //from start to current
  float total;                   //total area
  POLYPT_IT poly_it = polypts ();//iterator
                                 //child outline itertr
  OUTLINE_IT child_it(&children);

  origin = poly_it.data ()->pos;
  poly_it.forward ();
  vec = poly_it.data ()->pos - origin;
  poly_it.forward ();
  total = 0.0f;
  while (!poly_it.at_first ()) {
    prev_vec = vec;
    vec = poly_it.data ()->pos - origin;
    total += prev_vec * vec;
    poly_it.forward ();
  }
  total /= 2;
  for (child_it.mark_cycle_pt (); !child_it.cycled_list ();
  child_it.forward ()) {
                                 //add ares of childrein
    total += child_it.data ()->area ();
  }
  return total;
}


/**********************************************************************
 * OUTLINE::operator<
 *
 * Return TRUE if the left operand is inside the right one.
 **********************************************************************/

BOOL8
OUTLINE::operator< (             //winding number
OUTLINE & other                  //other outline
) {
  inT16 count;                   //winding count
  POLYPT_IT it = &outline;       //iterator

  if (!box.overlap (other.box))
    return FALSE;                //can't be contained

  do {
    count = other.winding_number (FCOORD (it.data ()->pos));
    //get winding number
    if (count != INTERSECTING)
      return count != 0;
    it.forward ();
  }
  while (!it.at_first ());

                                 //switch lists
  it.set_to_list (&other.outline);
  do {
                                 //try other way round
    count = winding_number (FCOORD (it.data ()->pos));
    if (count != INTERSECTING)
      return count == 0;
    it.forward ();
  }
  while (!it.at_first ());
  return TRUE;
}


/**********************************************************************
 * OUTLINE::winding_number
 *
 * Return the winding number of the outline around the given point.
 **********************************************************************/

inT16 OUTLINE::winding_number(                     //winding number
                              const FCOORD &point  //point to wind around
                             ) {
  inT16 count;                   //winding count
  POLYPT *polypt;                //current point
  FCOORD vec;                    //to current point
  float cross;                   //cross product
  POLYPT_IT it = &outline;       //iterator

  count = 0;
  do {
    polypt = it.data ();
    vec = polypt->pos - point;
                                 //crossing the line
    if (vec.y () <= 0 && vec.y () + polypt->vec.y () > 0) {
      cross = vec * polypt->vec; //cross product
      if (cross > 0)
        count++;                 //crossing right half
      else if (cross == 0)
        return INTERSECTING;     //going through point
    }
    else if (vec.y () > 0 && vec.y () + polypt->vec.y () <= 0) {
      cross = vec * polypt->vec;
      if (cross < 0)
        count--;                 //crossing back
      else if (cross == 0)
        return INTERSECTING;     //illegal
    }
    it.forward ();
  }
  while (!it.at_first ());
  return count;                  //winding number
}


/**********************************************************************
 * OUTLINE::reverse
 *
 * Reverse the direction of an outline.
 **********************************************************************/

void OUTLINE::reverse() {  //reverse direction
  POLYPT_LIST back_list;         //reversed list
  POLYPT_IT dest_it = &back_list;//destination
  POLYPT_IT src_it = &outline;   //source list
  POLYPT *polypt;                //current point

  do {
    polypt = src_it.extract ();
                                 //copy in reverse
    dest_it.add_after_then_move (polypt);
    src_it.backward ();
  }
  while (!src_it.empty ());
  dest_it.move_to_first ();
  do {
    polypt = dest_it.data ();
    polypt->vec = dest_it.data_relative (1)->pos - polypt->pos;
    //vector to next
    dest_it.forward ();
  }
  while (!dest_it.at_first ());
  dest_it.backward ();
  src_it.set_to_list (&back_list);
                                 //put it back
  outline.assign_to_sublist (&src_it, &dest_it);
}


/**********************************************************************
 * OUTLINE::move
 *
 * Move OUTLINE by vector
 **********************************************************************/

void OUTLINE::move(                  // reposition OUTLINE
                   const FCOORD vec  // by vector
                  ) {
                                 //child outline itertr
  OUTLINE_IT child_it(&children);
  POLYPT_IT poly_it(&outline);  //outline point itertr

  box.move (vec);

  start.set_x ((inT16) floor (start.x () + vec.x () + 0.5));
  // ?? Why ICOORD?
  start.set_y ((inT16) floor (start.y () + vec.y () + 0.5));
  // ?? Why ICOORD?

  for (poly_it.mark_cycle_pt (); !poly_it.cycled_list (); poly_it.forward ())
    poly_it.data ()->pos += vec;

  for (child_it.mark_cycle_pt (); !child_it.cycled_list ();
    child_it.forward ())
  child_it.data ()->move (vec);  // move child outlines
}


/**********************************************************************
 * OUTLINE::scale
 *
 * Scale OUTLINE by vector
 **********************************************************************/

void OUTLINE::scale(               // scale OUTLINE
                    const float f  // by multiplier
                   ) {
                                 //child outline itertr
  OUTLINE_IT child_it(&children);
  POLYPT_IT poly_it(&outline);  //outline point itertr
  POLYPT *pt;

  box.scale (f);

                                 // ?? Why ICOORD?
  start.set_x ((inT16) floor (start.x () * f + 0.5));
                                 // ?? Why ICOORD?
  start.set_y ((inT16) floor (start.y () * f + 0.5));

  for (poly_it.mark_cycle_pt (); !poly_it.cycled_list (); poly_it.forward ()) {
    pt = poly_it.data ();
    pt->pos *= f;
    pt->vec *= f;
  }

  for (child_it.mark_cycle_pt (); !child_it.cycled_list ();
    child_it.forward ())
  child_it.data ()->scale (f);   //scale child outlines
}


/**********************************************************************
 * OUTLINE::scale
 *
 * Scale OUTLINE by vector
 **********************************************************************/

void OUTLINE::scale(                     // scale OUTLINE
                    const FCOORD vector  //by fcoord
                   ) {
                                 //child outline itertr
  OUTLINE_IT child_it(&children);
  POLYPT_IT poly_it(&outline);  //outline point itertr
  POLYPT *pt;

  box.scale (vector);

  start.set_x ((inT16) floor (start.x () * vector.x () + 0.5));
  // ?? Why ICOORD?
  start.set_y ((inT16) floor (start.y () * vector.y () + 0.5));
  // ?? Why ICOORD?

  for (poly_it.mark_cycle_pt (); !poly_it.cycled_list (); poly_it.forward ()) {
    pt = poly_it.data ();
    pt->pos =
      FCOORD (pt->pos.x () * vector.x (), pt->pos.y () * vector.y ());
    pt->vec =
      FCOORD (pt->vec.x () * vector.x (), pt->vec.y () * vector.y ());
  }

  for (child_it.mark_cycle_pt (); !child_it.cycled_list ();
    child_it.forward ())
                                 //scale child outlines
  child_it.data ()->scale (vector);
}

/**********************************************************************
 * OUTLINE::rotate
 *
 * Rotate OUTLINE by the given vector
 **********************************************************************/

void OUTLINE::rotate(
                     const FCOORD vector  //by fcoord
                    ) {
                                 //child outline itertr
  OUTLINE_IT child_it(&children);
  POLYPT_IT poly_it(&outline);  //outline point itertr
  POLYPT *pt;
  box.rotate(vector);

  start.rotate(vector);

  for (poly_it.mark_cycle_pt (); !poly_it.cycled_list (); poly_it.forward ()) {
    pt = poly_it.data ();
    pt->pos.rotate(vector);
    pt->vec.rotate(vector);
  }

  for (child_it.mark_cycle_pt (); !child_it.cycled_list ();
    child_it.forward ())
                                 //scale child outlines
    child_it.data ()->rotate(vector);
}


/**********************************************************************
 * OUTLINE::plot
 *
 * Draw the outline in the given colour.
 **********************************************************************/

#ifndef GRAPHICS_DISABLED
void OUTLINE::plot(                //draw it
                   ScrollView* window,  //window to draw in
                   ScrollView::Color colour   //colour to draw in
                  ) {
  POLYPT *polypt;                //current point
  POLYPT_IT it = &outline;       //iterator

  window->Pen(colour);
  polypt = it.data ();
  int startx = polypt->pos.x ();
  int starty = polypt->pos.y ();
  do {
    it.forward ();
    polypt = it.data ();
    window->Line(startx,starty,polypt->pos.x (),polypt->pos.y ());
    startx = polypt->pos.x ();
    starty = polypt->pos.y ();
  }
  while (!it.at_first ());
}
#endif


/**********************************************************************
 * OUTLINE::operator=
 *
 * Assignment - deep copy data
 **********************************************************************/

OUTLINE & OUTLINE::operator= (   //assignment
const OUTLINE & source           //from this
) {
  box = source.box;
  start = source.start;
  if (!outline.empty())
    outline.clear();
  outline.deep_copy(&source.outline, &POLYPT::deep_copy);
  if (!children.empty())
    children.clear();
  children.deep_copy(&source.children, &OUTLINE::deep_copy);
  return *this;
}
//////////////////////////////////////////////////////////////poutline/////////////////////////////////////////////

//////////////////////////////////////////////////////////////linlsq/////////////////////////////////////////////
#ifndef __UNIX__
#define M_PI        3.14159265359
#endif

const ERRCODE EMPTY_LLSQ = "Can't delete from an empty LLSQ";

#define EXTERN

EXTERN double_VAR (pdlsq_posdir_ratio, 4e-6, "Mult of dir to cf pos");
EXTERN double_VAR (pdlsq_threshold_angleavg, 0.1666666,
"Frac of pi for simple fit");

/**********************************************************************
 * LLSQ::clear
 *
 * Function to initialize a LLSQ.
 **********************************************************************/

void LLSQ::clear() {  //initialize
  n = 0;                         //no elements
  sigx = 0;                      //update accumulators
  sigy = 0;
  sigxx = 0;
  sigxy = 0;
  sigyy = 0;
}


/**********************************************************************
 * LLSQ::add
 *
 * Add an element to the accumulator.
 **********************************************************************/

void LLSQ::add(           //add an element
               double x,  //xcoord
               double y   //ycoord
              ) {
  n++;                           //count elements
  sigx += x;                     //update accumulators
  sigy += y;
  sigxx += x * x;
  sigxy += x * y;
  sigyy += y * y;
}


/**********************************************************************
 * LLSQ::remove
 *
 * Delete an element from the acculuator.
 **********************************************************************/

void LLSQ::remove(           //delete an element
                  double x,  //xcoord
                  double y   //ycoord
                 ) {
  if (n <= 0)
                                 //illegal
    EMPTY_LLSQ.error ("LLSQ::remove", ABORT, NULL);
  n--;                           //count elements
  sigx -= x;                     //update accumulators
  sigy -= y;
  sigxx -= x * x;
  sigxy -= x * y;
  sigyy -= y * y;
}


/**********************************************************************
 * LLSQ::m
 *
 * Return the gradient of the line fit.
 **********************************************************************/

double LLSQ::m() {  //get gradient
  if (n > 1)
    return (sigxy - sigx * sigy / n) / (sigxx - sigx * sigx / n);
  else
    return 0;                    //too little
}


/**********************************************************************
 * LLSQ::c
 *
 * Return the constant of the line fit.
 **********************************************************************/

double LLSQ::c(          //get constant
               double m  //gradient to fit with
              ) {
  if (n > 0)
    return (sigy - m * sigx) / n;
  else
    return 0;                    //too little
}


/**********************************************************************
 * LLSQ::rms
 *
 * Return the rms error of the fit.
 **********************************************************************/

double LLSQ::rms(           //get error
                 double m,  //gradient to fit with
                 double c   //constant to fit with
                ) {
  double error;                  //total error

  if (n > 0) {
    error =
      sigyy + m * (m * sigxx + 2 * (c * sigx - sigxy)) + c * (n * c -
      2 * sigy);
    if (error >= 0)
      error = sqrt (error / n);  //sqrt of mean
    else
      error = 0;
  }
  else
    error = 0;                   //too little
  return error;
}


/**********************************************************************
 * LLSQ::spearman
 *
 * Return the spearman correlation coefficient.
 **********************************************************************/

double LLSQ::spearman() {  //get error
  double error;                  //total error

  if (n > 1) {
    error = (sigxx - sigx * sigx / n) * (sigyy - sigy * sigy / n);
    if (error > 0) {
      error = (sigxy - sigx * sigy / n) / sqrt (error);
    }
    else
      error = 1;
  }
  else
    error = 1;                   //too little
  return error;
}


/**********************************************************************
 * PDLSQ::fit
 *
 * Return all the parameters of the fit to pos/dir.
 * The return value is the rms error.
 **********************************************************************/

float PDLSQ::fit(                 //get fit
                 DIR128 &ang,     //output angle
                 float &sin_ang,  //r,theta parameterisation
                 float &cos_ang,
                 float &r) {
  double a, b;                   //itermediates
  double angle;                  //resulting angle
  double avg_angle;              //simple average
  double error;                  //total error
  double sinx, cosx;             //return values

  if (pos.n > 0) {
    a = pos.sigxy - pos.sigx * pos.sigy / pos.n
      + pdlsq_posdir_ratio * dir.sigxy;
    b =
      pos.sigxx - pos.sigyy + (pos.sigy * pos.sigy -
      pos.sigx * pos.sigx) / pos.n +
      pdlsq_posdir_ratio * (dir.sigxx - dir.sigyy);
    if (dir.sigy != 0 || dir.sigx != 0)
      avg_angle = atan2 (dir.sigy, dir.sigx);
    else
      avg_angle = 0;
    if ((a != 0 || b != 0) && pos.n > 1)
      angle = atan2 (2 * a, b) / 2;
    else
      angle = avg_angle;
    error = avg_angle - angle;
    if (error > M_PI / 2) {
      error -= M_PI;
      angle += M_PI;
    }
    if (error < -M_PI / 2) {
      error += M_PI;
      angle -= M_PI;
    }
    if (error > M_PI * pdlsq_threshold_angleavg
      || error < -M_PI * pdlsq_threshold_angleavg)
      angle = avg_angle;         //go simple
                                 //convert direction
    ang = (inT16) (angle * MODULUS / (2 * M_PI));
    sinx = sin (angle);
    cosx = cos (angle);
    r = (sinx * pos.sigx - cosx * pos.sigy) / pos.n;
    //              tprintf("x=%g, y=%g, xx=%g, xy=%g, yy=%g, a=%g, b=%g, ang=%g, r=%g\n",
    //                      pos.sigx,pos.sigy,pos.sigxx,pos.sigxy,pos.sigyy,
    //                      a,b,angle,r);
    error = dir.sigxx * sinx * sinx + dir.sigyy * cosx * cosx
      - 2 * dir.sigxy * sinx * cosx;
    error *= pdlsq_posdir_ratio;
    error += sinx * sinx * pos.sigxx + cosx * cosx * pos.sigyy
      - 2 * sinx * cosx * pos.sigxy
      - 2 * r * (sinx * pos.sigx - cosx * pos.sigy) + r * r * pos.n;
    if (error >= 0)
                                 //rms value
        error = sqrt (error / pos.n);
    else
      error = 0;                 //-0
    sin_ang = sinx;
    cos_ang = cosx;
  }
  else {
    sin_ang = 0.0f;
    cos_ang = 0.0f;
    ang = 0;
    error = 0;                   //too little
  }
  return error;
}
//////////////////////////////////////////////////////////////linlsq/////////////////////////////////////////////

//////////////////////////////////////////////////////////////werd/////////////////////////////////////////////
#define FIRST_COLOUR    ScrollView::RED      //< first rainbow colour

/// last rainbow colour
#define LAST_COLOUR     ScrollView::AQUAMARINE
#define CHILD_COLOUR    ScrollView::BROWN    //< colour of children

const ERRCODE CANT_SCALE_EDGESTEPS =
"Attempted to scale an edgestep format word";

#define EXTERN

EXTERN BOOL_VAR (bln_numericmode, 0, "Optimize for numbers");
EXTERN INT_VAR (bln_x_height, 128, "Baseline Normalisation X-height");
EXTERN INT_VAR (bln_baseline_offset, 64, "Baseline Norm. offset of baseline");
EXTERN double_VAR (bln_blshift_maxshift, -1.0,
"Fraction of xh before shifting");
EXTERN double_VAR (bln_blshift_xfraction, 0.75,
"Size fraction of xh before shifting");

ELISTIZE_S (WERD)
/**
 * WERD::WERD
 *
 * Constructor to build a WERD from a list of C_BLOBs.
 * The C_BLOBs are not copied so the source list is emptied.
 */
WERD::WERD (                     //constructor
C_BLOB_LIST * blob_list,         //< in word order
uinT8 blank_count,               //< blanks in front
const char *text                 //< correct text
):
flags (0),
correct(text) {
  C_BLOB_IT start_it = blob_list;//iterator
  C_BLOB_IT end_it = blob_list;  //another
                                 //rejected blobs in wd
  C_BLOB_IT rej_cblob_it = &rej_cblobs;
  C_OUTLINE_IT c_outline_it;     //coutline iterator
  BOOL8 blob_inverted;
  BOOL8 reject_blob;
  inT16 inverted_vote = 0;
  inT16 non_inverted_vote = 0;

  while (!end_it.at_last ())
    end_it.forward ();           //move to last
                                 //move to our list
  cblobs.assign_to_sublist (&start_it, &end_it);
  blanks = blank_count;
  /*
    Set white on black flag for the WERD, moving any duff blobs onto the
    rej_cblobs list.
    First, walk the cblobs checking the inverse flag for each outline of each
    cblob. If a cblob has inconsistent flag settings for its different
    outlines, move the blob to the reject list. Otherwise, increment the
    appropriate w-on-b or b-on-w vote for the word.

    Now set the inversion flag for the WERD by maximum vote.

    Walk the blobs again, moving any blob whose inversion flag does not agree
    with the concencus onto the reject list.
  */
  start_it.set_to_list (&cblobs);
  if (start_it.empty ())
    return;
  for (start_it.mark_cycle_pt ();
  !start_it.cycled_list (); start_it.forward ()) {
    c_outline_it.set_to_list (start_it.data ()->out_list ());
    blob_inverted = c_outline_it.data ()->flag (COUT_INVERSE);
    reject_blob = FALSE;
    for (c_outline_it.mark_cycle_pt ();
      !c_outline_it.cycled_list () && !reject_blob;
    c_outline_it.forward ()) {
      reject_blob =
        c_outline_it.data ()->flag (COUT_INVERSE) != blob_inverted;
    }
    if (reject_blob)
      rej_cblob_it.add_after_then_move (start_it.extract ());
    else {
      if (blob_inverted)
        inverted_vote++;
      else
        non_inverted_vote++;
    }
  }

  flags.set_bit (W_INVERSE, (inverted_vote > non_inverted_vote));

  start_it.set_to_list (&cblobs);
  if (start_it.empty ())
    return;
  for (start_it.mark_cycle_pt ();
  !start_it.cycled_list (); start_it.forward ()) {
    c_outline_it.set_to_list (start_it.data ()->out_list ());
    if (c_outline_it.data ()->flag (COUT_INVERSE) != flags.bit (W_INVERSE))
      rej_cblob_it.add_after_then_move (start_it.extract ());
  }
}


/**
 * WERD::WERD
 *
 * Constructor to build a WERD from a list of BLOBs.
 * The BLOBs are not copied so the source list is emptied.
 */

WERD::WERD (                     //constructor
PBLOB_LIST * blob_list,          //< in word order
uinT8 blank_count,               //< blanks in front
const char *text                 //< correct text
):
flags (0),
correct(text) {
  PBLOB_IT start_it = blob_list; //iterator
  PBLOB_IT end_it = blob_list;   //another

  while (!end_it.at_last ())
    end_it.forward ();           //move to last

  C_BLOB_LIST *p = &cblobs;
  ((PBLOB_LIST *)p)->assign_to_sublist (&start_it, &end_it);
  //move to our list
                                 //it's a polygon
  flags.set_bit (W_POLYGON, TRUE);
  blanks = blank_count;
  //      fprintf(stderr,"Wrong constructor!!!!\n");
}


/**
 * WERD::WERD
 *
 * Constructor to build a WERD from a list of BLOBs.
 * The BLOBs are not copied so the source list is emptied.
 */

WERD::WERD (                     //constructor
PBLOB_LIST * blob_list,          //< in word order
WERD * clone                     //< sorce of flags
):flags (clone->flags), correct (clone->correct) {
  PBLOB_IT start_it = blob_list; //iterator
  PBLOB_IT end_it = blob_list;   //another

  while (!end_it.at_last ())
    end_it.forward ();           //move to last

  C_BLOB_LIST *p = &cblobs;
  ((PBLOB_LIST *)p)->assign_to_sublist (&start_it, &end_it);
  //move to our list
  blanks = clone->blanks;
  //      fprintf(stderr,"Wrong constructor!!!!\n");
}


/**
 * WERD::WERD
 *
 * Constructor to build a WERD from a list of C_BLOBs.
 * The C_BLOBs are not copied so the source list is emptied.
 */

WERD::WERD (                     //constructor
C_BLOB_LIST * blob_list,         //< in word order
WERD * clone                     //< source of flags
):flags (clone->flags), correct (clone->correct) {
  C_BLOB_IT start_it = blob_list;//iterator
  C_BLOB_IT end_it = blob_list;  //another

  while (!end_it.at_last ())
    end_it.forward ();           //move to last
  ((C_BLOB_LIST *) (&cblobs))->assign_to_sublist (&start_it, &end_it);
  //move to our list
  blanks = clone->blanks;
  //      fprintf(stderr,"Wrong constructor!!!!\n");
}


/**
 * WERD::poly_copy
 *
 * Make a copy of a WERD in polygon format.
 * The source WERD is untouched.
 */

WERD *WERD::poly_copy(               //make a poly copy
                      float xheight  //< row height
                     ) {
  PBLOB *blob;                   //new blob
  WERD *result = new WERD;       //output word
  C_BLOB_IT src_it = &cblobs;    //iterator
  //      LARC_BLOB_IT                            larc_it=(LARC_BLOB_LIST*)(&cblobs);
  PBLOB_IT dest_it = (PBLOB_LIST *) (&result->cblobs);
  //another

  if (flags.bit (W_POLYGON)) {
    *result = *this;             //just copy it
  }
  else {
    result->flags = flags;
    result->correct = correct;   //copy info
    result->dummy = dummy;
    if (!src_it.empty ()) {
      //                      if (flags.bit(W_LINEARC))
      //                      {
      //                              do
      //                              {
      //                                      blob=new PBLOB;
      //                                      poly_linearc_outlines(larc_it.data()->out_list(),
      //                                                                                              blob->out_list());      //convert outlines
      //                                      dest_it.add_after_then_move(blob);                      //add to dest list
      //                                      larc_it.forward();
      //                              }
      //                              while (!larc_it.at_first());
      //                      }
      //                      else
      //                      {
      do {
        blob = new PBLOB (src_it.data (), xheight);
        //convert blob
                                 //add to dest list
        dest_it.add_after_then_move (blob);
        src_it.forward ();
      }
      while (!src_it.at_first ());
      //                      }
    }
    if (!rej_cblobs.empty ()) {
      /* Polygonal approx of reject blobs */
      src_it.set_to_list (&rej_cblobs);
      dest_it = (PBLOB_LIST *) (&result->rej_cblobs);
      do {
                                 //convert blob
        blob = new PBLOB (src_it.data (), xheight);
                                 //add to dest list
        dest_it.add_after_then_move (blob);
        src_it.forward ();
      }
      while (!src_it.at_first ());
    }
                                 //polygon now
    result->flags.set_bit (W_POLYGON, TRUE);
    result->blanks = blanks;
  }
  return result;
}


/**
 * WERD::bounding_box
 *
 * Return the bounding box of the WERD.
 * This is quite a mess to compute!
 * ORIGINALLY, REJECT CBLOBS WERE EXCLUDED, however, this led to bugs when the
 * words on the row were re-sorted. The original words were built with reject
 * blobs included. The FUZZY SPACE flags were set accordingly. If ALL the
 * blobs in a word are rejected the BB for the word is NULL, causing the sort
 * to screw up, leading to the erroneous possibility of the first word in a
 * row being marked as FUZZY space.
 */

TBOX WERD::bounding_box() {  //bounding box
  TBOX box;                       //box being built
                                 //rejected blobs in wd
  C_BLOB_IT rej_cblob_it = &rej_cblobs;

  for (rej_cblob_it.mark_cycle_pt ();
  !rej_cblob_it.cycled_list (); rej_cblob_it.forward ()) {
    box += rej_cblob_it.data ()->bounding_box ();
  }

  if (flags.bit (W_POLYGON)) {
                                 //polygons
    PBLOB_IT it = (PBLOB_LIST *) (&cblobs);

    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
      box += it.data ()->bounding_box ();
    }
  }
  else {
    C_BLOB_IT it = &cblobs;      //blobs of WERD

    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
      box += it.data ()->bounding_box ();
    }
  }
  return box;
}


/**
 * WERD::move
 *
 * Reposition WERD by vector
 * NOTE!! REJECT CBLOBS ARE NOT MOVED
 */

void WERD::move(                  // reposition WERD
                const ICOORD vec  //< by vector
               ) {
  PBLOB_IT blob_it ((PBLOB_LIST *) & cblobs);
  // blob iterator
  //      LARC_BLOB_IT                            lblob_it((LARC_BLOB_LIST*)&cblobs);
  C_BLOB_IT cblob_it(&cblobs);  // cblob iterator

  if (flags.bit (W_POLYGON))
    for (blob_it.mark_cycle_pt ();
    !blob_it.cycled_list (); blob_it.forward ())
  blob_it.data ()->move (vec);
  //      else if (flags.bit(W_LINEARC))
  //              for( lblob_it.mark_cycle_pt();
  //                      !lblob_it.cycled_list();
  //                      lblob_it.forward() )
  //                      lblob_it.data()->move( vec );
  else
    for (cblob_it.mark_cycle_pt ();
    !cblob_it.cycled_list (); cblob_it.forward ())
  cblob_it.data ()->move (vec);
}


/**
 * WERD::scale
 *
 * Scale WERD by multiplier
 */

void WERD::scale(               // scale WERD
                 const float f  //< by multiplier
                ) {
  PBLOB_IT blob_it ((PBLOB_LIST *) & cblobs);
  // blob iterator
  //      LARC_BLOB_IT                            lblob_it((LARC_BLOB_LIST*)&cblobs);

  if (flags.bit (W_POLYGON))
    for (blob_it.mark_cycle_pt ();
    !blob_it.cycled_list (); blob_it.forward ())
  blob_it.data ()->scale (f);
  //      else if (flags.bit(W_LINEARC))
  //              for (lblob_it.mark_cycle_pt();
  //                              !lblob_it.cycled_list();
  //                              lblob_it.forward() )
  //                      lblob_it.data()->scale( f );
  else
    CANT_SCALE_EDGESTEPS.error ("WERD::scale", ABORT, NULL);
}


/**
 * WERD::join_on
 *
 * Join other word onto this one. Delete the old word.
 */

void WERD::join_on(              // join WERD
                   WERD *&other  //< other word
                  ) {
  PBLOB_IT blob_it ((PBLOB_LIST *) & cblobs);
  // blob iterator
  PBLOB_IT src_it ((PBLOB_LIST *) & other->cblobs);
  C_BLOB_IT rej_cblob_it(&rej_cblobs);
  C_BLOB_IT src_rej_it (&other->rej_cblobs);

  while (!src_it.empty ()) {
    blob_it.add_to_end (src_it.extract ());
    src_it.forward ();
  }
  while (!src_rej_it.empty ()) {
    rej_cblob_it.add_to_end (src_rej_it.extract ());
    src_rej_it.forward ();
  }
}


/**
 * WERD::copy_on
 *
 * Copy blobs from other word onto this one.
 */

void WERD::copy_on(              //copy blobs
                   WERD *&other  //< from other
                  ) {
  if (flags.bit (W_POLYGON)) {
    PBLOB_IT blob_it ((PBLOB_LIST *) & cblobs);
    // blob iterator
    PBLOB_LIST blobs;

    blobs.deep_copy(reinterpret_cast<PBLOB_LIST*>(&other->cblobs),
                    &PBLOB::deep_copy);
    blob_it.move_to_last();
    blob_it.add_list_after(&blobs);
  } else {
    C_BLOB_IT c_blob_it(&cblobs);
    C_BLOB_LIST c_blobs;

    c_blobs.deep_copy(&other->cblobs, &C_BLOB::deep_copy);
    c_blob_it.move_to_last ();
    c_blob_it.add_list_after (&c_blobs);
  }
  if (!other->rej_cblobs.empty ()) {
    C_BLOB_IT rej_c_blob_it(&rej_cblobs);
    C_BLOB_LIST new_rej_c_blobs;

    new_rej_c_blobs.deep_copy(&other->rej_cblobs, &C_BLOB::deep_copy);
    rej_c_blob_it.move_to_last ();
    rej_c_blob_it.add_list_after (&new_rej_c_blobs);
  }
}


/**
 * WERD::baseline_normalise
 *
 * Baseline Normalise the word in Tesseract style.  (I.e origin at centre of
 * word at bottom. x-height region scaled to region y =
 * (bln_baseline_offset)..(bln_baseline_offset + bln_x_height)
 * - usually 64..192)
 */

void WERD::baseline_normalise(                // Tess style BL Norm
                              ROW *row,
                              DENORM *denorm  //< antidote
                             ) {
  baseline_normalise_x (row, row->x_height (), denorm);
  //Use standard x ht
}


/**
 * WERD::baseline_normalise_x
 *
 * Baseline Normalise the word in Tesseract style.  (I.e origin at centre of
 * word at bottom. x-height region scaled to region y =
 * (bln_baseline_offset)..(bln_baseline_offset + bln_x_height)
 * - usually 64..192)
 *  USE A SPECIFIED X-HEIGHT - NOT NECESSARILY THE ONE IN row
 */

void WERD::baseline_normalise_x(                 // Tess style BL Norm
                                ROW *row,
                                float x_height,  //< non standard value
                                DENORM *denorm   //< antidote
                               ) {
  BOOL8 using_row;               //as baseline
  float blob_x_centre;           //middle of blob
  float blob_offset;             //bottom miss
  float top_offset;              //top miss
  float blob_x_height;           //xh for this blob
  inT16 segments;                //no of segments
  inT16 segment;                 //current segment
  DENORM_SEG *segs;              //array of segments
  float mean_x;                  //mean xheight
  inT32 x_count;                 //no of xs
  TBOX word_box = bounding_box ();//word bounding box
  TBOX blob_box;                  //blob bounding box
  PBLOB_IT blob_it ((PBLOB_LIST *) & cblobs);
  // blob iterator
  PBLOB *blob;
  LLSQ line;                     //fitted line
  double line_m, line_c;         //fitted line
                                 //inverse norm
  DENORM antidote (word_box.left () +

    (word_box.right () - word_box.left ()) / 2.0,
    bln_x_height / x_height, row);

  if (!flags.bit (W_POLYGON)) {
    WRONG_WORD.error ("WERD::baseline_normalise", ABORT,
      "Need to poly approx");
  }

  if (flags.bit (W_NORMALIZED)) {
    WRONG_WORD.error ("WERD::baseline_normalise", ABORT,
      "Baseline unnormalised");
  }

  if (bln_numericmode) {
    segs = new DENORM_SEG[blob_it.length ()];
    segments = 0;
    float factor;  // For scaling to baseline normalised size.
    for (blob_it.mark_cycle_pt (); !blob_it.cycled_list ();
    blob_it.forward ()) {
      blob = blob_it.data ();
      blob_box = blob->bounding_box ();
      blob->move (FCOORD (-antidote.origin (),
        -blob_box.bottom ()));
      factor = bln_x_height * 4.0f / (3 * blob_box.height ());
      // Constrain the scale factor as target numbers should be either
      // cap height already or xheight.
      if (factor < antidote.scale())
        factor = antidote.scale();
      else if (factor > antidote.scale() * 1.5f)
        factor = antidote.scale() * 1.5f;
      blob->scale (factor);
      blob->move (FCOORD (0.0, bln_baseline_offset));
      segs[segments].xstart = blob->bounding_box().left();
      segs[segments].ycoord = blob_box.bottom();
      segs[segments++].scale_factor = factor;
    }
    antidote = DENORM (antidote.origin (), antidote.scale (),
      0.0f, 0.0f, segments, segs, true, row);
    delete [] segs;

    //Repeat for rej blobs
    C_BLOB_LIST *p = &rej_cblobs;
    blob_it.set_to_list ((PBLOB_LIST *)p);
    for (blob_it.mark_cycle_pt (); !blob_it.cycled_list ();
    blob_it.forward ()) {
      blob = blob_it.data ();
      blob_box = blob->bounding_box ();
      blob->move (FCOORD (-antidote.origin (),
                          -blob_box.bottom ()));
      blob->scale (bln_x_height * 4.0f / (3 * blob_box.height ()));
      blob->move (FCOORD (0.0, bln_baseline_offset));
    }
  }
  else if (bln_blshift_maxshift < 0) {
    for (blob_it.mark_cycle_pt (); !blob_it.cycled_list ();
    blob_it.forward ()) {
      blob = blob_it.data ();
      blob_box = blob->bounding_box ();
      blob_x_centre = blob_box.left () +
        (blob_box.right () - blob_box.left ()) / 2.0;
      blob->move (FCOORD (-antidote.origin (),
        -(row->base_line (blob_x_centre))));
      blob->scale (antidote.scale ());
      blob->move (FCOORD (0.0, bln_baseline_offset));
    }

    //Repeat for rej blobs
    C_BLOB_LIST *p = &rej_cblobs;
    blob_it.set_to_list ((PBLOB_LIST *)p);
    for (blob_it.mark_cycle_pt (); !blob_it.cycled_list ();
    blob_it.forward ()) {
      blob = blob_it.data ();
      blob_box = blob->bounding_box ();
      blob_x_centre = blob_box.left () +
        (blob_box.right () - blob_box.left ()) / 2.0;
      blob->move (FCOORD (-antidote.origin (),
        -(row->base_line (blob_x_centre))));
      blob->scale (antidote.scale ());
      blob->move (FCOORD (0.0, bln_baseline_offset));
    }

  }
  else {
    mean_x = x_height;
    x_count = 1;
    segs = new DENORM_SEG[blob_it.length ()];
    segments = 0;
    for (blob_it.mark_cycle_pt (); !blob_it.cycled_list ();
    blob_it.forward ()) {
      blob = blob_it.data ();
      blob_box = blob->bounding_box ();
      if (blob_box.height () > bln_blshift_xfraction * x_height) {
        blob_x_centre = blob_box.left () +
          (blob_box.right () - blob_box.left ()) / 2.0;
        blob_offset =
          blob_box.bottom () - row->base_line (blob_x_centre);
        top_offset = blob_offset + blob_box.height () - x_height - 1;
        blob_x_height = top_offset + x_height;
        if (top_offset < 0)
          top_offset = -top_offset;
        if (blob_offset < 0)
          blob_offset = -blob_offset;
        if (blob_offset < bln_blshift_maxshift * x_height) {
          segs[segments].ycoord = blob_box.bottom ();
          line.add (blob_x_centre, blob_box.bottom ());
          if (top_offset < bln_blshift_maxshift * x_height) {
            segs[segments].scale_factor = blob_box.height () - 1.0f;
            x_count++;
          }
          else
            segs[segments].scale_factor = 0.0f;
          //fix it later
        }
        else {
                                 //not a goer
          segs[segments].ycoord = -MAX_INT32;
          if (top_offset < bln_blshift_maxshift * x_height) {
            segs[segments].scale_factor = blob_x_height;
            x_count++;
          }
          else
            segs[segments].scale_factor = 0.0f;
          //fix it later
        }
      }
      else {
        segs[segments].scale_factor = 0.0f;
        segs[segments].ycoord = -MAX_INT32;
      }
      segs[segments].xstart = blob_box.left ();
      segments++;
    }
    using_row = line.count () <= 1;
    if (!using_row) {
      line_m = line.m ();
      line_c = line.c (line_m);
    }
    else
      line_m = line_c = 0;
    segments = 0;
    for (blob_it.mark_cycle_pt (); !blob_it.cycled_list ();
    blob_it.forward ()) {
      blob = blob_it.data ();
      blob_box = blob->bounding_box ();
      blob_x_centre = blob_box.left () +
        (blob_box.right () - blob_box.left ()) / 2.0;
      if (segs[segments].ycoord == -MAX_INT32
      && segs[segments].scale_factor != 0 && !using_row) {
        blob_offset = line_m * blob_x_centre + line_c;
        segs[segments].scale_factor = blob_box.top () - blob_offset;
      }
      if (segs[segments].scale_factor != 0)
        mean_x += segs[segments].scale_factor;
      segments++;
    }
    mean_x /= x_count;
    //              printf("mean x=%g, count=%d, line_m=%g, line_c=%g\n",
    //                      mean_x,x_count,line_m,line_c);
    segments = 0;
    for (blob_it.mark_cycle_pt (); !blob_it.cycled_list ();
    blob_it.forward ()) {
      blob = blob_it.data ();
      blob_box = blob->bounding_box ();
      blob_x_centre = blob_box.left () +
        (blob_box.right () - blob_box.left ()) / 2.0;
      if (segs[segments].ycoord != -MAX_INT32)
        blob_offset = (float) segs[segments].ycoord;
      else if (using_row)
        blob_offset = row->base_line (blob_x_centre);
      else
        blob_offset = line_m * blob_x_centre + line_c;
      if (segs[segments].scale_factor == 0)
        segs[segments].scale_factor = mean_x;
      segs[segments].scale_factor =
        bln_x_height / segs[segments].scale_factor;
      //                      printf("Blob sf=%g, top=%d, bot=%d, base=%g\n",
      //                              segs[segments].scale_factor,blob_box.top(),
      //                              blob_box.bottom(),blob_offset);
      blob->move (FCOORD (-antidote.origin (), -blob_offset));
      blob->
        scale (FCOORD (antidote.scale (), segs[segments].scale_factor));
      blob->move (FCOORD (0.0, bln_baseline_offset));
      segments++;
    }

    //Repeat for rej blobs
    C_BLOB_LIST *p = &rej_cblobs;
    blob_it.set_to_list ((PBLOB_LIST *)p);
    segment = 0;
    for (blob_it.mark_cycle_pt (); !blob_it.cycled_list ();
    blob_it.forward ()) {
      blob = blob_it.data ();
      blob_box = blob->bounding_box ();
      blob_x_centre = blob_box.left () +
        (blob_box.right () - blob_box.left ()) / 2.0;
      while (segment < segments - 1
        && segs[segment + 1].xstart <= blob_x_centre)
        segment++;
      if (segs[segment].ycoord != -MAX_INT32)
        blob_offset = (float) segs[segment].ycoord;
      else if (using_row)
        blob_offset = row->base_line (blob_x_centre);
      else
        blob_offset = line_m * blob_x_centre + line_c;
      blob->move (FCOORD (-antidote.origin (), -blob_offset));
      blob->
        scale (FCOORD (antidote.scale (), segs[segment].scale_factor));
      blob->move (FCOORD (0.0, bln_baseline_offset));
    }
    if (line.count () > 0 || x_count > 1)
      antidote = DENORM (antidote.origin (), antidote.scale (),
        line_m, line_c, segments, segs, using_row, row);
    delete[]segs;
  }
  if (denorm != NULL)
    *denorm = antidote;
                                 //it's normalised
  flags.set_bit (W_NORMALIZED, TRUE);
}


/**
 * WERD::baseline_denormalise
 *
 * Baseline DeNormalise the word in Tesseract style.  (I.e origin at centre of
 * word at bottom. x-height region scaled to region y =
 * (bln_baseline_offset)..(bln_baseline_offset + bln_x_height)
 * - usually 64..192)
 */

void WERD::baseline_denormalise(                      // Tess style BL Norm
                                const DENORM *denorm  //< antidote
                               ) {
  PBLOB_IT blob_it ((PBLOB_LIST *) & cblobs);
  // blob iterator
  PBLOB *blob;

  if (!flags.bit (W_NORMALIZED)) {
    WRONG_WORD.error ("WERD::baseline_denormalise", ABORT,
      "Baseline normalised");
  }

  for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ()) {
    blob = blob_it.data ();
                                 //denormalise it
    blob->baseline_denormalise (denorm);
  }

  //Repeat for rej blobs
  C_BLOB_LIST *p = &rej_cblobs;
  blob_it.set_to_list ((PBLOB_LIST *)p);
  for (blob_it.mark_cycle_pt (); !blob_it.cycled_list (); blob_it.forward ()) {
    blob = blob_it.data ();
                                 //denormalise it
    blob->baseline_denormalise (denorm);
  }

                                 //it's not normalised
  flags.set_bit (W_NORMALIZED, FALSE);
}


/**
 * WERD::print
 *
 * Display members
 */

void WERD::print(        //print
                 FILE *  //< file to print on
                ) {
  tprintf ("Blanks= %d\n", blanks);
  bounding_box ().print ();
  tprintf ("Flags = %d = 0%o\n", flags.val, flags.val);
  tprintf ("   W_SEGMENTED = %s\n",
    flags.bit (W_SEGMENTED) ? "TRUE" : "FALSE ");
  tprintf ("   W_ITALIC = %s\n", flags.bit (W_ITALIC) ? "TRUE" : "FALSE ");
  tprintf ("   W_BOL = %s\n", flags.bit (W_BOL) ? "TRUE" : "FALSE ");
  tprintf ("   W_EOL = %s\n", flags.bit (W_EOL) ? "TRUE" : "FALSE ");
  tprintf ("   W_NORMALIZED = %s\n",
    flags.bit (W_NORMALIZED) ? "TRUE" : "FALSE ");
  tprintf ("   W_POLYGON = %s\n", flags.bit (W_POLYGON) ? "TRUE" : "FALSE ");
  tprintf ("   W_LINEARC = %s\n", flags.bit (W_LINEARC) ? "TRUE" : "FALSE ");
  tprintf ("   W_DONT_CHOP = %s\n",
    flags.bit (W_DONT_CHOP) ? "TRUE" : "FALSE ");
  tprintf ("   W_REP_CHAR = %s\n",
    flags.bit (W_REP_CHAR) ? "TRUE" : "FALSE ");
  tprintf ("   W_FUZZY_SP = %s\n",
    flags.bit (W_FUZZY_SP) ? "TRUE" : "FALSE ");
  tprintf ("   W_FUZZY_NON = %s\n",
    flags.bit (W_FUZZY_NON) ? "TRUE" : "FALSE ");
  tprintf ("Correct= %s\n", correct.string ());
  tprintf ("Rejected cblob count = %d\n", rej_cblobs.length ());
}


/**
 * WERD::plot
 *
 * Draw the WERD in the given colour.
 */

#ifndef GRAPHICS_DISABLED
void WERD::plot(                //draw it
                ScrollView* window,  //window to draw in
                ScrollView::Color colour,  //colour to draw in
                BOOL8 solid     //draw larcs solid
               ) {
  if (flags.bit (W_POLYGON)) {
                                 //polygons
    PBLOB_IT it = (PBLOB_LIST *) (&cblobs);

    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
      it.data ()->plot (window, colour, colour);
    }
  }
  //      else if (flags.bit(W_LINEARC))
  //      {
  //              LARC_BLOB_IT                    it=(LARC_BLOB_LIST*)(&cblobs);

  //              for ( it.mark_cycle_pt(); !it.cycled_list(); it.forward() )
  //              {
  //                      it.data()->plot(window,solid,colour,solid ? BLACK : colour);
  //              }
  //      }
  else {
    C_BLOB_IT it = &cblobs;      //blobs of WERD

    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
      it.data ()->plot (window, colour, colour);
    }
  }
  plot_rej_blobs(window, solid);
}
#endif


/**
 * WERD::plot
 *
 * Draw the WERD in rainbow colours.
 */

#ifndef GRAPHICS_DISABLED
void WERD::plot(                //draw it
                ScrollView* window,  //< window to draw in
                BOOL8 solid     //< draw larcs solid
               ) {
  ScrollView::Color colour = FIRST_COLOUR;  //current colour
  if (flags.bit (W_POLYGON)) {
                                 //polygons
    PBLOB_IT it = (PBLOB_LIST *) (&cblobs);

    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
      it.data ()->plot (window, colour, CHILD_COLOUR);
      colour = (ScrollView::Color) (colour + 1);
      if (colour == LAST_COLOUR)
        colour = FIRST_COLOUR;   //cycle round
    }
  }
  //      else if (flags.bit(W_LINEARC))
  //      {
  //              LARC_BLOB_IT                    it=(LARC_BLOB_LIST*)(&cblobs);

  //              for ( it.mark_cycle_pt(); !it.cycled_list(); it.forward() )
  //              {
  //                      it.data()->plot(window,solid,colour,solid ? BLACK : CHILD_COLOUR);
  //                      colour=(COLOUR)(colour+1);
  //                      if (colour==LAST_COLOUR)
  //                              colour=FIRST_COLOUR;
  //              }
  //      }
  else {
    C_BLOB_IT it = &cblobs;      //blobs of WERD

    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
      it.data ()->plot (window, colour, CHILD_COLOUR);
      colour = (ScrollView::Color) (colour + 1);
      if (colour == LAST_COLOUR)
        colour = FIRST_COLOUR;   //cycle round
    }
  }
  plot_rej_blobs(window, solid);
}
#endif


/**
 * WERD::plot_rej_blobs
 *
 * Draw the WERD rejected blobs - ALWAYS GREY
 */

#ifndef GRAPHICS_DISABLED
void WERD::plot_rej_blobs(                //draw it
                          ScrollView* window,  //< window to draw in
                          BOOL8 solid     //< draw larcs solid
                         )
{
    Q_UNUSED(solid);
  if (flags.bit (W_POLYGON)) {
    PBLOB_IT it = (PBLOB_LIST *) (&rej_cblobs);
    //polygons

    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
      it.data ()->plot (window, ScrollView::GREY, ScrollView::GREY);
    }
  } else {
    C_BLOB_IT it = &rej_cblobs;  //blobs of WERD

    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
      it.data ()->plot (window, ScrollView::GREY, ScrollView::GREY);
    }
  }
}
#endif


/**
 * WERD::shallow_copy()
 *
 * Make a shallow copy of a word
 */

WERD *WERD::shallow_copy() {  //shallow copy
  WERD *new_word = new WERD;

  new_word->blanks = blanks;
  new_word->flags = flags;
  new_word->dummy = dummy;
  new_word->correct = correct;
  return new_word;
}


/**
 * WERD::operator=
 *
 * Assign a word, DEEP copying the blob list
 */

WERD & WERD::operator= (         //assign words
const WERD & source              //from this
) {
  this->ELIST_LINK::operator= (source);
  blanks = source.blanks;
  flags = source.flags;
  dummy = source.dummy;
  correct = source.correct;
  if (flags.bit (W_POLYGON))
  {
    if (!cblobs.empty())
    {
      C_BLOB_LIST *p = &cblobs;
      reinterpret_cast<PBLOB_LIST*>(p)->clear();
    }

    C_BLOB_LIST *p2 = &cblobs;
    reinterpret_cast<PBLOB_LIST*>(p2)->deep_copy(
      reinterpret_cast<const PBLOB_LIST*>(&source.cblobs), &PBLOB::deep_copy);

    if (!rej_cblobs.empty())
    {
        C_BLOB_LIST *p = &rej_cblobs;
      reinterpret_cast<PBLOB_LIST*>(&p)->clear();
    }

    C_BLOB_LIST *p3 = &rej_cblobs;
    reinterpret_cast<PBLOB_LIST*>(p3)->deep_copy(
      reinterpret_cast<const PBLOB_LIST*>(&source.rej_cblobs),
      &PBLOB::deep_copy);
  } else {
    if (!cblobs.empty ())
      cblobs.clear ();
    cblobs.deep_copy(&source.cblobs, &C_BLOB::deep_copy);

    if (!rej_cblobs.empty ())
      rej_cblobs.clear ();
    rej_cblobs.deep_copy(&source.rej_cblobs, &C_BLOB::deep_copy);
  }
  return *this;
}


/**
 *  word_comparator()
 *
 *  word comparator used to sort a word list so that words are in increasing
 *  order of left edge.
 */

int word_comparator(                     //sort blobs
                    const void *word1p,  //< ptr to ptr to word1
                    const void *word2p   //< ptr to ptr to word2
                   ) {
  WERD *
    word1 = *(WERD **) word1p;
  WERD *
    word2 = *(WERD **) word2p;

  return word1->bounding_box ().left () - word2->bounding_box ().left ();
}
//////////////////////////////////////////////////////////////werd/////////////////////////////////////////////

//////////////////////////////////////////////////////////////ocrrow/////////////////////////////////////////////
ELISTIZE_S (ROW)
/**********************************************************************
 * ROW::ROW
 *
 * Constructor to build a ROW. Only the stats stuff are given here.
 * The words are added directly.
 **********************************************************************/
ROW::ROW (                       //constructor
inT32 spline_size,               //no of segments
inT32 * xstarts,                 //segment boundaries
double *coeffs,                  //coefficients
float x_height,                  //line height
float ascenders,                 //ascender size
float descenders,                //descender drop
inT16 kern,                      //char gap
inT16 space                      //word gap
):
baseline(spline_size, xstarts, coeffs) {
  kerning = kern;                //just store stuff
  spacing = space;
  xheight = x_height;
  ascrise = ascenders;
  descdrop = descenders;
}


/**********************************************************************
 * ROW::ROW
 *
 * Constructor to build a ROW. Only the stats stuff are given here.
 * The words are added directly.
 **********************************************************************/

ROW::ROW(                 //constructor
         TO_ROW *to_row,  //source row
         inT16 kern,      //char gap
         inT16 space      //word gap
        ) {
  kerning = kern;                //just store stuff
  spacing = space;
  xheight = to_row->xheight;
  ascrise = to_row->ascrise;
  descdrop = to_row->descdrop;
  baseline = to_row->baseline;
}


/**********************************************************************
 * ROW::recalc_bounding_box
 *
 * Set the bounding box correctly
 **********************************************************************/

void ROW::recalc_bounding_box() {  //recalculate BB
  WERD *word;                    //current word
  WERD_IT it = &words;           //words of ROW
  inT16 left;                    //of word
  inT16 prev_left;               //old left

  if (!it.empty ()) {
    word = it.data ();
    prev_left = word->bounding_box ().left ();
    it.forward ();
    while (!it.at_first ()) {
      word = it.data ();
      left = word->bounding_box ().left ();
      if (left < prev_left) {
        it.move_to_first ();
                                 //words in BB order
        it.sort (word_comparator);
        break;
      }
      prev_left = left;
      it.forward ();
    }
  }
  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
    word = it.data ();
    if (it.at_first ())
      word->set_flag (W_BOL, TRUE);
    else
                                 //not start of line
      word->set_flag (W_BOL, FALSE);
    if (it.at_last ())
      word->set_flag (W_EOL, TRUE);
    else
                                 //not end of line
      word->set_flag (W_EOL, FALSE);
                                 //extend BB as reqd
    bound_box += word->bounding_box ();
  }
}


/**********************************************************************
 * ROW::move
 *
 * Reposition row by vector
 **********************************************************************/

void ROW::move(                  // reposition row
               const ICOORD vec  // by vector
              ) {
  WERD_IT it(&words);  // word iterator

  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
    it.data ()->move (vec);

  bound_box.move (vec);
  baseline.move (vec);
}


/**********************************************************************
 * ROW::print
 *
 * Display members
 **********************************************************************/

void ROW::print(          //print
                FILE *fp  //file to print on
               )
{
    Q_UNUSED(fp);
  tprintf ("Kerning= %d\n", kerning);
  tprintf ("Spacing= %d\n", spacing);
  bound_box.print ();
  tprintf ("Xheight= %f\n", xheight);
  tprintf ("Ascrise= %f\n", ascrise);
  tprintf ("Descdrop= %f\n", descdrop);
}


/**********************************************************************
 * ROW::plot
 *
 * Draw the ROW in the given colour.
 **********************************************************************/

#ifndef GRAPHICS_DISABLED
void ROW::plot(                //draw it
               ScrollView* window,  //window to draw in
               ScrollView::Color colour   //colour to draw in
              ) {
  WERD *word;                    //current word
  WERD_IT it = &words;           //words of ROW

  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
    word = it.data ();
    word->plot (window, colour); //all in one colour
  }
}
#endif

/**********************************************************************
 * ROW::plot
 *
 * Draw the ROW in rainbow colours.
 **********************************************************************/

#ifndef GRAPHICS_DISABLED
void ROW::plot(               //draw it
               ScrollView* window  //window to draw in
              ) {
  WERD *word;                    //current word
  WERD_IT it = &words;           //words of ROW

  for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ()) {
    word = it.data ();
    word->plot (window);         //in rainbow colours
  }
}
#endif

/**********************************************************************
 * ROW::operator=
 *
 * Assign rows by duplicating the row structure but NOT the WERDLIST
 **********************************************************************/

ROW & ROW::operator= (           //assignment
const ROW & source               //from this
) {
  this->ELIST_LINK::operator= (source);
  kerning = source.kerning;
  spacing = source.spacing;
  xheight = source.xheight;
  ascrise = source.ascrise;
  descdrop = source.descdrop;
  if (!words.empty ())
    words.clear ();
  baseline = source.baseline;    //QSPLINES must do =
  bound_box = source.bound_box;
  return *this;
}
//////////////////////////////////////////////////////////////ocrrow/////////////////////////////////////////////

//////////////////////////////////////////////////////////////polyaprx/////////////////////////////////////////////
#define FASTEDGELENGTH    256
#define EXTERN
EXTERN BOOL_VAR (poly_debug, FALSE, "Debug old poly");
EXTERN BOOL_VAR (poly_wide_objects_better, TRUE,
"More accurate approx on wide things");

static int par1, par2;

#define CONVEX        1          /*OUTLINE point is convex */
#define CONCAVE       2          /*used and set only in edges */
#define FIXED       4            /*OUTLINE point is fixed */
#define ONHULL        8          /*on convex hull */

#define RUNLENGTH     1          /*length of run */

#define DIR         2            /*direction of run */

#define CORRECTION      3        /*correction of run */
//#define MAXSHORT                      32767                                           /*max value of short*/
#define FLAGS       0

#define fixed_dist      20       //really an int_variable
#define approx_dist     15       //really an int_variable

#define point_diff(p,p1,p2) (p).x = (p1).x - (p2).x ; (p).y = (p1).y - (p2).y
#define CROSS(a,b) ((a).x * (b).y - (a).y * (b).x)
#define LENGTH(a) ((a).x * (a).x + (a).y * (a).y)

#define DISTANCE(a,b) (((b).x-(a).x) * ((b).x-(a).x) \
                        + ((b).y-(a).y) * ((b).y-(a).y))

/**********************************************************************
 * tesspoly_outline
 *
 * Approximate an outline from c form using the old tess algorithm.
 **********************************************************************/

OUTLINE *tesspoly_outline(                       //old approximation
                          C_OUTLINE *c_outline,  //input
                          float                  //xheight
                         ) {
  EDGEPT *edgept;                //converted steps
  EDGEPT *startpt;               //start of outline
  TBOX loop_box;                  //bounding box
  inT32 area;                    //loop area
  FCOORD pos;                    //vertex
  FCOORD vec;                    //vector
  POLYPT_LIST polypts;           //output polygon
  POLYPT *polypt;                //converted point
  POLYPT_IT poly_it = &polypts;  //iterator
  EDGEPT stack_edgepts[FASTEDGELENGTH];  // converted path
  EDGEPT* edgepts = stack_edgepts;

  // Use heap memory if the stack buffer is not big enough.
  if (c_outline->pathlength() > FASTEDGELENGTH)
    edgepts = new EDGEPT[c_outline->pathlength()];

  loop_box = c_outline->bounding_box ();
  area = loop_box.height ();
  if (!poly_wide_objects_better && loop_box.width () > area)
    area = loop_box.width ();
  area *= area;
  edgept = edgesteps_to_edgepts (c_outline, edgepts);
  fix2(edgepts, area);
  edgept = poly2 (edgepts, area);/*2nd approximation */
  startpt = edgept;
  do {
    pos = FCOORD (edgept->pos.x, edgept->pos.y);
    vec = FCOORD (edgept->vec.x, edgept->vec.y);
    polypt = new POLYPT (pos, vec);
                                 //add to list
    poly_it.add_after_then_move (polypt);
    edgept = edgept->next;
  }
  while (edgept != startpt);
  if (edgepts != stack_edgepts)
    delete [] edgepts;
  if (poly_it.length() <= 2)
    return NULL;
  else
    return new OUTLINE(&poly_it);
}


/**********************************************************************
 * edgesteps_to_edgepts
 *
 * Convert a C_OUTLINE to EDGEPTs.
 **********************************************************************/

EDGEPT *
edgesteps_to_edgepts (           //convert outline
C_OUTLINE * c_outline,           //input
EDGEPT edgepts[]                 //output is array
) {
  inT32 length;                  //steps in path
  ICOORD pos;                    //current coords
  inT32 stepindex;               //current step
  inT32 stepinc;                 //increment
  inT32 epindex;                 //current EDGEPT
  inT32 count;                   //repeated steps
  ICOORD vec;                    //for this 8 step
  ICOORD prev_vec;
  inT8 epdir;                    //of this step
  DIR128 prevdir;                //prvious dir
  DIR128 dir;                    //of this step

  pos = c_outline->start_pos (); //start of loop
  length = c_outline->pathlength ();
  stepindex = 0;
  epindex = 0;
  prevdir = -1;
  count = 0;
  do {
    dir = c_outline->step_dir (stepindex);
    vec = c_outline->step (stepindex);
    if (stepindex < length - 1
    && c_outline->step_dir (stepindex + 1) - dir == -32) {
      dir += 128 - 16;
      vec += c_outline->step (stepindex + 1);
      stepinc = 2;
    }
    else
      stepinc = 1;
    if (count == 0) {
      prevdir = dir;
      prev_vec = vec;
    }
    if (prevdir.get_dir () != dir.get_dir ()) {
      edgepts[epindex].pos.x = pos.x ();
      edgepts[epindex].pos.y = pos.y ();
      prev_vec *= count;
      edgepts[epindex].vec.x = prev_vec.x ();
      edgepts[epindex].vec.y = prev_vec.y ();
      pos += prev_vec;
      edgepts[epindex].flags[RUNLENGTH] = count;
      edgepts[epindex].prev = &edgepts[epindex - 1];
      edgepts[epindex].flags[FLAGS] = 0;
      edgepts[epindex].next = &edgepts[epindex + 1];
      prevdir += 64;
      epdir = (DIR128) 0 - prevdir;
      epdir >>= 4;
      epdir &= 7;
      edgepts[epindex].flags[DIR] = epdir;
      epindex++;
      prevdir = dir;
      prev_vec = vec;
      count = 1;
    }
    else
      count++;
    stepindex += stepinc;
  }
  while (stepindex < length);
  edgepts[epindex].pos.x = pos.x ();
  edgepts[epindex].pos.y = pos.y ();
  prev_vec *= count;
  edgepts[epindex].vec.x = prev_vec.x ();
  edgepts[epindex].vec.y = prev_vec.y ();
  pos += prev_vec;
  edgepts[epindex].flags[RUNLENGTH] = count;
  edgepts[epindex].flags[FLAGS] = 0;
  edgepts[epindex].prev = &edgepts[epindex - 1];
  edgepts[epindex].next = &edgepts[0];
  prevdir += 64;
  epdir = (DIR128) 0 - prevdir;
  epdir >>= 4;
  epdir &= 7;
  edgepts[epindex].flags[DIR] = epdir;
  edgepts[0].prev = &edgepts[epindex];
  ASSERT_HOST (pos.x () == c_outline->start_pos ().x ()
    && pos.y () == c_outline->start_pos ().y ());
  return &edgepts[0];
}


/**********************************************************************
 *fix2(start,area) fixes points on the outline according to a trial method*
 **********************************************************************/

//#pragma OPT_LEVEL 1                                                                           /*stop compiler bugs*/

void fix2(                //polygonal approx
          EDGEPT *start,  /*loop to approimate */
          int area) {
  register EDGEPT *edgept;       /*current point */
  register EDGEPT *edgept1;
  register EDGEPT *loopstart;    /*modified start of loop */
  register EDGEPT *linestart;    /*start of line segment */
  register int dir1, dir2;       /*directions of line */
  register int sum1, sum2;       /*lengths in dir1,dir2 */
  int stopped;                   /*completed flag */
  int fixed_count;               //no of fixed points
  int d01, d12, d23, gapmin;
  TPOINT d01vec, d12vec, d23vec;
  register EDGEPT *edgefix, *startfix;
  register EDGEPT *edgefix0, *edgefix1, *edgefix2, *edgefix3;

  edgept = start;                /*start of loop */
  while (((edgept->flags[DIR] - edgept->prev->flags[DIR] + 1) & 7) < 3
    && (dir1 =
    (edgept->prev->flags[DIR] - edgept->next->flags[DIR]) & 7) != 2
    && dir1 != 6)
    edgept = edgept->next;       /*find suitable start */
  loopstart = edgept;            /*remember start */

  stopped = 0;                   /*not finished yet */
  edgept->flags[FLAGS] |= FIXED; /*fix it */
  do {
    linestart = edgept;          /*possible start of line */
    dir1 = edgept->flags[DIR];   /*first direction */
                                 /*length of dir1 */
    sum1 = edgept->flags[RUNLENGTH];
    edgept = edgept->next;
    dir2 = edgept->flags[DIR];   /*2nd direction */
                                 /*length in dir2 */
    sum2 = edgept->flags[RUNLENGTH];
    if (((dir1 - dir2 + 1) & 7) < 3) {
      while (edgept->prev->flags[DIR] == edgept->next->flags[DIR]) {
        edgept = edgept->next;   /*look at next */
        if (edgept->flags[DIR] == dir1)
                                 /*sum lengths */
          sum1 += edgept->flags[RUNLENGTH];
        else
          sum2 += edgept->flags[RUNLENGTH];
      }

      if (edgept == loopstart)
        stopped = 1;             /*finished */
      if (sum2 + sum1 > 2
        && linestart->prev->flags[DIR] == dir2
        && (linestart->prev->flags[RUNLENGTH] >
      linestart->flags[RUNLENGTH] || sum2 > sum1)) {
                                 /*start is back one */
        linestart = linestart->prev;
        linestart->flags[FLAGS] |= FIXED;
      }

      if (((edgept->next->flags[DIR] - edgept->flags[DIR] + 1) & 7) >= 3
        || (edgept->flags[DIR] == dir1 && sum1 >= sum2)
        || ((edgept->prev->flags[RUNLENGTH] < edgept->flags[RUNLENGTH]
        || (edgept->flags[DIR] == dir2 && sum2 >= sum1))
          && linestart->next != edgept))
        edgept = edgept->next;
    }
                                 /*sharp bend */
    edgept->flags[FLAGS] |= FIXED;
  }
                                 /*do whole loop */
  while (edgept != loopstart && !stopped);

  edgept = start;
  do {
    if (((edgept->flags[RUNLENGTH] >= 8) &&
      (edgept->flags[DIR] != 2) && (edgept->flags[DIR] != 6)) ||
      ((edgept->flags[RUNLENGTH] >= 8) &&
    ((edgept->flags[DIR] == 2) || (edgept->flags[DIR] == 6)))) {
      edgept->flags[FLAGS] |= FIXED;
      edgept1 = edgept->next;
      edgept1->flags[FLAGS] |= FIXED;
    }
    edgept = edgept->next;
  }
  while (edgept != start);

  edgept = start;
  do {
                                 /*single fixed step */
    if (edgept->flags[FLAGS] & FIXED && edgept->flags[RUNLENGTH] == 1
                                 /*and neighours free */
      && edgept->next->flags[FLAGS] & FIXED && (edgept->prev->flags[FLAGS] & FIXED) == 0
                                 /*same pair of dirs */
      && (edgept->next->next->flags[FLAGS] & FIXED) == 0 && edgept->prev->flags[DIR] == edgept->next->flags[DIR] && edgept->prev->prev->flags[DIR] == edgept->next->next->flags[DIR]
    && ((edgept->prev->flags[DIR] - edgept->flags[DIR] + 1) & 7) < 3) {
                                 /*unfix it */
      edgept->flags[FLAGS] &= ~FIXED;
      edgept->next->flags[FLAGS] &= ~FIXED;
    }
    edgept = edgept->next;       /*do all points */
  }
  while (edgept != start);       /*until finished */

  stopped = 0;
  if (area < 450)
    area = 450;

  gapmin = area * fixed_dist * fixed_dist / 44000;

  edgept = start;
  fixed_count = 0;
  do {
    if (edgept->flags[FLAGS] & FIXED)
      fixed_count++;
    edgept = edgept->next;
  }
  while (edgept != start);
  while ((edgept->flags[FLAGS] & FIXED) == 0)
    edgept = edgept->next;
  edgefix0 = edgept;

  edgept = edgept->next;
  while ((edgept->flags[FLAGS] & FIXED) == 0)
    edgept = edgept->next;
  edgefix1 = edgept;

  edgept = edgept->next;
  while ((edgept->flags[FLAGS] & FIXED) == 0)
    edgept = edgept->next;
  edgefix2 = edgept;

  edgept = edgept->next;
  while ((edgept->flags[FLAGS] & FIXED) == 0)
    edgept = edgept->next;
  edgefix3 = edgept;

  startfix = edgefix2;

  do {
    if (fixed_count <= 3)
      break;                     //already too few
    point_diff (d12vec, edgefix1->pos, edgefix2->pos);
    d12 = LENGTH (d12vec);
    if (d12 <= gapmin) {
      point_diff (d01vec, edgefix0->pos, edgefix1->pos);
      d01 = LENGTH (d01vec);
      point_diff (d23vec, edgefix2->pos, edgefix3->pos);
      d23 = LENGTH (d23vec);
      if (d01 > d23) {
        edgefix2->flags[FLAGS] &= ~FIXED;
        fixed_count--;
        /*                  if ( plots[EDGE] & PATHS )
                  mark(edgefd,edgefix2->pos.x,edgefix2->pos.y,PLUS);
                                  */
      }
      else {
        edgefix1->flags[FLAGS] &= ~FIXED;
        fixed_count--;
        /*                  if ( plots[EDGE] & PATHS )
                  mark(edgefd,edgefix1->pos.x,edgefix1->pos.y,PLUS);
                                    */
        edgefix1 = edgefix2;
      }
    }
    else {
      edgefix0 = edgefix1;
      edgefix1 = edgefix2;
    }
    edgefix2 = edgefix3;
    edgept = edgept->next;
    while ((edgept->flags[FLAGS] & FIXED) == 0) {
      if (edgept == startfix)
        stopped = 1;
      edgept = edgept->next;
    }
    edgefix3 = edgept;
    edgefix = edgefix2;
  }
  while ((edgefix != startfix) && (!stopped));
}


//#pragma OPT_LEVEL 2                                                                           /*stop compiler bugs*/

/**********************************************************************
 *poly2(startpt,area,path) applies a second approximation to the outline
 *using the points which have been fixed by the first approximation*
 **********************************************************************/

EDGEPT *poly2(                  //second poly
              EDGEPT *startpt,  /*start of loop */
              int area          /*area of blob box */
             ) {
  register EDGEPT *edgept;       /*current outline point */
  EDGEPT *loopstart;             /*starting point */
  register EDGEPT *linestart;    /*start of line */
  register int edgesum;          /*correction count */

  if (area < 1200)
    area = 1200;                 /*minimum value */

                                 /*1200(4) */
  par1 = 4500 / (approx_dist * approx_dist);
                                 /*1200(6) */
  par2 = 6750 / (approx_dist * approx_dist);

  loopstart = NULL;              /*not found it yet */
  edgept = startpt;              /*start of loop */

  do {
                                 /*current point fixed */
    if (edgept->flags[FLAGS] & FIXED
                                 /*and next not */
    && (edgept->next->flags[FLAGS] & FIXED) == 0) {
      loopstart = edgept;        /*start of repoly */
      break;
    }
    edgept = edgept->next;       /*next point */
  }
  while (edgept != startpt);     /*until found or finished */

  if (loopstart == NULL && (startpt->flags[FLAGS] & FIXED) == 0) {
                                 /*fixed start of loop */
    startpt->flags[FLAGS] |= FIXED;
    loopstart = startpt;         /*or start of loop */
  }
  if (loopstart) {
    do {
      edgept = loopstart;        /*first to do */
      do {
        linestart = edgept;
        edgesum = 0;             /*sum of lengths */
        do {
                                 /*sum lengths */
          edgesum += edgept->flags[RUNLENGTH];
          edgept = edgept->next; /*move on */
        }
        while ((edgept->flags[FLAGS] & FIXED) == 0
          && edgept != loopstart && edgesum < 126);
        if (poly_debug)
          tprintf
            ("Poly2:starting at (%d,%d)+%d=(%d,%d),%d to (%d,%d)\n",
            linestart->pos.x, linestart->pos.y, linestart->flags[DIR],
            linestart->vec.x, linestart->vec.y, edgesum, edgept->pos.x,
            edgept->pos.y);
                                 /*reapproximate */
        cutline(linestart, edgept, area);

        while ((edgept->next->flags[FLAGS] & FIXED)
          && edgept != loopstart)
          edgept = edgept->next; /*look for next non-fixed */
      }
                                 /*do all the loop */
      while (edgept != loopstart);
      edgesum = 0;
      do {
        if (edgept->flags[FLAGS] & FIXED)
          edgesum++;
        edgept = edgept->next;
      }
                                 //count fixed pts
      while (edgept != loopstart);
      if (edgesum < 3)
        area /= 2;               //must have 3 pts
    }
    while (edgesum < 3);
    do {
      linestart = edgept;
      do {
        edgept = edgept->next;
      }
      while ((edgept->flags[FLAGS] & FIXED) == 0);
      linestart->next = edgept;
      edgept->prev = linestart;
      linestart->vec.x = edgept->pos.x - linestart->pos.x;
      linestart->vec.y = edgept->pos.y - linestart->pos.y;
    }
    while (edgept != loopstart);
  }
  else
    edgept = startpt;            /*start of loop */

  loopstart = edgept;            /*new start */
  return loopstart;              /*correct exit */
}


/**********************************************************************
 *cutline(first,last,area) straightens out a line by partitioning
 *and joining the ends by a straight line*
 **********************************************************************/

void cutline(                //recursive refine
             EDGEPT *first,  /*ends of line */
             EDGEPT *last,
             int area        /*area of object */
            ) {
  register EDGEPT *edge;         /*current edge */
  TPOINT vecsum;                 /*vector sum */
  int vlen;                      /*approx length of vecsum */
  TPOINT vec;                    /*accumulated vector */
  EDGEPT *maxpoint;              /*worst point */
  int maxperp;                   /*max deviation */
  register int perp;             /*perp distance */
  int ptcount;                   /*no of points */
  int squaresum;                 /*sum of perps */

  edge = first;                  /*start of line */
  if (edge->next == last)
    return;                      /*simple line */

                                 /*vector sum */
  vecsum.x = last->pos.x - edge->pos.x;
  vecsum.y = last->pos.y - edge->pos.y;
  if (vecsum.x == 0 && vecsum.y == 0) {
                                 /*special case */
    vecsum.x = -edge->prev->vec.x;
    vecsum.y = -edge->prev->vec.y;
  }
                                 /*absolute value */
  vlen = vecsum.x > 0 ? vecsum.x : -vecsum.x;
  if (vecsum.y > vlen)
    vlen = vecsum.y;             /*maximum */
  else if (-vecsum.y > vlen)
    vlen = -vecsum.y;            /*absolute value */

  vec.x = edge->vec.x;           /*accumulated vector */
  vec.y = edge->vec.y;
  maxperp = 0;                   /*none yet */
  squaresum = ptcount = 0;
  edge = edge->next;             /*move to actual point */
  maxpoint = edge;               /*in case there isn't one */
  do {
    perp = CROSS (vec, vecsum);  /*get perp distance */
    if (perp != 0) {
      perp *= perp;              /*squared deviation */
    }
    squaresum += perp;           /*sum squares */
    ptcount++;                   /*count points */
    if (poly_debug)
      tprintf ("Cutline:Final perp=%d\n", perp);
    if (perp > maxperp) {
      maxperp = perp;
      maxpoint = edge;           /*find greatest deviation */
    }
    vec.x += edge->vec.x;        /*accumulate vectors */
    vec.y += edge->vec.y;
    edge = edge->next;
  }
  while (edge != last);          /*test all line */

  perp = LENGTH (vecsum);
  ASSERT_HOST (perp != 0);

  if (maxperp < 256 * MAX_INT16) {
    maxperp <<= 8;
    maxperp /= perp;             /*true max perp */
  }
  else {
    maxperp /= perp;
    maxperp <<= 8;               /*avoid overflow */
  }
  if (squaresum < 256 * MAX_INT16)
                                 /*mean squared perp */
    perp = (squaresum << 8) / (perp * ptcount);
  else
                                 /*avoid overflow */
    perp = (squaresum / perp << 8) / ptcount;

  if (poly_debug)
    tprintf ("Cutline:A=%d, max=%.2f(%.2f%%), msd=%.2f(%.2f%%)\n",
      area, maxperp / 256.0, maxperp * 200.0 / area,
      perp / 256.0, perp * 300.0 / area);
  if (maxperp * par1 >= 10 * area || perp * par2 >= 10 * area || vlen >= 126) {
    maxpoint->flags[FLAGS] |= FIXED;
                                 /*partitions */
    cutline(first, maxpoint, area);
    cutline(maxpoint, last, area);
  }
}
//////////////////////////////////////////////////////////////polyaprx/////////////////////////////////////////////

//////////////////////////////////////////////////////////////polyblob/////////////////////////////////////////////
// Include automatically generated configuration file if running autoconf.
#ifdef HAVE_CONFIG_H
#endif

#define EXTERN

EXTERN BOOL_VAR (polygon_tess_approximation, TRUE,
                 "Do tess poly instead of greyscale");

ELISTIZE_S (PBLOB)
/**********************************************************************
 * position_outline
 *
 * Position the outline in the given list at the relevant place
 * according to its nesting.
 **********************************************************************/
static void position_outline(                        //put in place
                                                     OUTLINE *outline,       //thing to place
                                                     OUTLINE_LIST *destlist  //desstination list
                                                     )
{
    OUTLINE *dest_outline;         //outline from dest list
    OUTLINE_IT it = destlist;      //iterator
    //iterator on children
    OUTLINE_IT child_it = outline->child ();

    if (!it.empty ())
    {
        do
        {
            dest_outline = it.data (); //get destination

            //encloses dest
            if (*dest_outline < *outline)
            {
                //take off list
                dest_outline = it.extract ();

                //put this in place
                it.add_after_then_move (outline);

                //make it a child
                child_it.add_to_end (dest_outline);

                while (!it.at_last ())
                {
                    it.forward ();         //do rest of list

                    //check for other children
                    dest_outline = it.data ();

                    if (*dest_outline < *outline)
                    {
                        //take off list
                        dest_outline = it.extract ();
                        child_it.add_to_end (dest_outline);

                        //make it a child
                        if (it.empty ()) break;
                    }
                }

                return;                  //finished
            }
            else if (*outline < *dest_outline) //enclosed by dest
            {
                position_outline (outline, dest_outline->child ());

                //place in child list
                return;                  //finished
            }

            it.forward ();
        }
        while (!it.at_first ());
    }

    it.add_to_end (outline);       //at outer level
}


/**********************************************************************
 * plot_outline_list
 *
 * Draw a list of outlines in the given colour and their children
 * in the child colour.
 **********************************************************************/

#ifndef GRAPHICS_DISABLED
//draw outlines
static void plot_outline_list(OUTLINE_LIST *list,  //outline to draw
                              ScrollView* window,       //window to draw in
                              ScrollView::Color colour,       //colour to use
                              ScrollView::Color child_colour  //colour of children
                              )
{
    OUTLINE *outline;              //current outline
    OUTLINE_IT it = list;          //iterator

    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
    {
        outline = it.data ();

        //draw it
        outline->plot (window, colour);
        if (!outline->child ()->empty ())
        {
            plot_outline_list (outline->child (), window, child_colour, child_colour);
        }
    }
}
#endif


/**********************************************************************
 * PBLOB::PBLOB
 *
 * Constructor to build a PBLOB from a list of OUTLINEs.
 * The OUTLINEs are not copied so the source list is emptied.
 * The OUTLINEs are nested correctly in the blob.
 **********************************************************************/
//constructor  //in random order
PBLOB::PBLOB(OUTLINE_LIST *outline_list)
{
    OUTLINE *outline;              //current outline
    OUTLINE_IT it = outline_list;  //iterator

    while (!it.empty())
    {         //grab the list
        outline = it.extract ();     //get off the list

        //put it in place
        position_outline(outline, &outlines);

        if (!it.empty ())
        {
            it.forward ();
        }
    }
}


/**********************************************************************
 * approximate_outline_list
 *
 * Convert a list of outlines to polygonal form.
 **********************************************************************/
//do list of outlines
static void approximate_outline_list(C_OUTLINE_LIST *srclist,  //list to convert
                                     OUTLINE_LIST *destlist,   //desstination list
                                     float xheight             //height of line
                                     )
{
    C_OUTLINE *src_outline;        //outline from src list
    OUTLINE *dest_outline;         //result
    C_OUTLINE_IT src_it = srclist; //source iterator
    OUTLINE_IT dest_it = destlist; //iterator

    do
    {
        src_outline = src_it.data ();

        //if (polygon_tess_approximation)
        dest_outline = tesspoly_outline(src_outline, xheight);

        if (dest_outline != NULL)
        {
            dest_it.add_after_then_move (dest_outline);
            if (!src_outline->child ()->empty ())
            {
                //do child list
                approximate_outline_list (src_outline->child (), dest_outline->child (), xheight);
            }
        }

        src_it.forward ();
    }
    while (!src_it.at_first ());
}


/**********************************************************************
 * PBLOB::PBLOB
 *
 * Constructor to build a PBLOB from a C_BLOB by polygonal approximation.
 **********************************************************************/
//constructor
PBLOB::PBLOB(C_BLOB *cblob,  //compact blob
             float xheight   //height of line
             )
{
    TBOX bbox;                      //bounding box

    if (!cblob->out_list ()->empty ())
    {

        //get bounding box
        bbox = cblob->bounding_box ();
        if (bbox.height () > xheight)
        {
            xheight = bbox.height ();  //max of line and blob
        }

        //copy it
        approximate_outline_list (cblob->out_list (), &outlines, xheight);
    }
}


/**********************************************************************
 * PBLOB::bounding_box
 *
 * Return the bounding box of the blob.
 **********************************************************************/

TBOX PBLOB::bounding_box()
{
    //bounding box
    OUTLINE *outline;              //current outline
    OUTLINE_IT it = &outlines;     //outlines of blob
    TBOX box;                       //bounding box

    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
    {
        outline = it.data ();
        box += outline->bounding_box ();
    }

    return box;
}


/**********************************************************************
 * PBLOB::area
 *
 * Return the area of the blob.
 **********************************************************************/

float PBLOB::area()
{
    //area
    OUTLINE *outline;              //current outline
    OUTLINE_IT it = &outlines;     //outlines of blob
    float total;                   //total area

    total = 0.0f;
    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
    {
        outline = it.data ();
        total += outline->area ();
    }

    return total;
}


/**********************************************************************
 * PBLOB::baseline_normalise
 *
 * Baseline normalize a blob
 **********************************************************************/
//normalize blob
PBLOB *PBLOB::baseline_normalise(ROW *row,       //row it came from
                                 DENORM *denorm  //inverse mapping
                                 )
{
    TBOX blob_box = bounding_box ();
    float x_centre = (blob_box.left () + blob_box.right ()) / 2.0;
    PBLOB *bn_blob;                //copied blob

    *denorm = DENORM (x_centre, bln_x_height / row->x_height (), row);
    bn_blob = new PBLOB;           //get one
    *bn_blob = *this;              //deep copy

    bn_blob->move (FCOORD (-denorm->origin (), -row->base_line (x_centre)));
    bn_blob->scale (denorm->scale ());
    bn_blob->move (FCOORD (0.0, bln_baseline_offset));

    return bn_blob;
}


/**********************************************************************
 * PBLOB::baseline_denormalise
 *
 * DeBaseline Normalise the blob properly with the given denorm.
 **********************************************************************/
// Tess style BL Norm                  //antidote
void PBLOB::baseline_denormalise(const DENORM *denorm)
{
    float blob_x_left;           // Left edge of blob.
    TBOX blob_box;                  //blob bounding box

    move(FCOORD (0.0f, 0.0f - bln_baseline_offset));
    blob_box = bounding_box ();
    blob_x_left = blob_box.left ();
    scale (1.0 / denorm->scale_at_x (blob_x_left));
    move (FCOORD (denorm->origin (), denorm->yshift_at_x (blob_x_left)));
}


/**********************************************************************
 * PBLOB::move
 *
 * Move PBLOB by vector
 **********************************************************************/
// reposition blob  // by vector
void PBLOB::move(const FCOORD vec)
{
    OUTLINE_IT it(&outlines);  // iterator

    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
    {
        it.data ()->move (vec);      // move each outline
    }
}


/**********************************************************************
 * PBLOB::scale
 *
 * Scale PBLOB by float multiplier
 **********************************************************************/
// scale blob     // by multiplier
void PBLOB::scale(const float f)
{
    OUTLINE_IT it(&outlines);  // iterator

    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
    {
        it.data ()->scale (f);       // scale each outline
    }
}


/**********************************************************************
 * PBLOB::scale
 *
 * Scale PBLOB by float multiplier
 **********************************************************************/
// scale blob     // by multiplier
void PBLOB::scale(const FCOORD vec)
{
    OUTLINE_IT it(&outlines);  // iterator

    for (it.mark_cycle_pt (); !it.cycled_list (); it.forward ())
    {
        it.data ()->scale (vec);     // scale each outline
    }
}

/**********************************************************************
 * PBLOB::rotate
 *
 * Rotate PBLOB 90 deg anticlockwise about the origin.
 **********************************************************************/

void PBLOB::rotate()
{
    // Rotate 90 deg anti
    rotate(FCOORD(0.0f, 1.0f));
}

/**********************************************************************
 * PBLOB::rotate
 *
 * Rotate PBLOB by the given rotation about the origin.
 * The rotation is defined to be (cos a, sin a) where a is the anticlockwise
 * rotation angle (in units appropriate for cos, sin).
 * Alternatively think of multiplication by the complex number
 * rotation = z = (x + iy), with |z| = 1.
 **********************************************************************/
void PBLOB::rotate(const FCOORD& rotation)
{
    // Rotate by given rotation.
    OUTLINE_IT it(&outlines);

    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
    {
        it.data()->rotate(rotation);     // Rotate each outline.
    }
}

/**********************************************************************
 * PBLOB::plot
 *
 * Draw the PBLOB in the given colour.
 **********************************************************************/

#ifndef GRAPHICS_DISABLED
//draw it
void PBLOB::plot(ScrollView* window,       //window to draw in
                 ScrollView::Color blob_colour,  //main colour
                 ScrollView::Color child_colour  //for holes
                 )
{
    plot_outline_list(&outlines, window, blob_colour, child_colour);
}
#endif
//////////////////////////////////////////////////////////////polyblob/////////////////////////////////////////////

//////////////////////////////////////////////////////////////ratngs//////////////////////////////////
extern FILE *matcher_fp;

ELISTIZE (BLOB_CHOICE) CLISTIZE (BLOB_CHOICE_LIST) CLISTIZE (WERD_CHOICE)
//extern FILE* matcher_fp;

/**
 * BLOB_CHOICE::BLOB_CHOICE
 *
 * Constructor to build a BLOB_CHOICE from a char, rating and certainty.
 */
BLOB_CHOICE::BLOB_CHOICE(UNICHAR_ID src_unichar_id, //< character id
                         float src_rating,          //< rating
                         float src_cert,            //< certainty
                         inT8 src_config,           //< config (font)
                         int src_script_id          //< script
                        ) {
  unichar_id_ = src_unichar_id;
  rating_ = src_rating;
  certainty_ = src_cert;
  config_ = src_config;
  script_id_ = src_script_id;
}

/**
 * BLOB_CHOICE::BLOB_CHOICE
 *
 * Constructor to build a BLOB_CHOICE from another BLOB_CHOICE.
 */
BLOB_CHOICE::BLOB_CHOICE(const BLOB_CHOICE &other) : ELIST_LINK(other)
{
  unichar_id_ = other.unichar_id();
  rating_ = other.rating();
  certainty_ = other.certainty();
  config_ = other.config();
  script_id_ = other.script_id();
}

/**
 * WERD_CHOICE::WERD_CHOICE
 *
 * Constructor to build a WERD_CHOICE from the given string.
 * The function assumes that src_string is not NULL.
 */
WERD_CHOICE::WERD_CHOICE(const char *src_string,
                         const UNICHARSET &unicharset) {
  STRING src_lengths;
  int len = strlen(src_string);
  const char *ptr = src_string;
  int step = unicharset.step(ptr);
  for (; ptr < src_string + len && step > 0;
       step = unicharset.step(ptr), src_lengths += step, ptr += step);
  if (step != 0 && ptr == src_string + len) {
    this->init(src_string, src_lengths.string(),
               0.0, 0.0, NO_PERM, unicharset);
  } else {  // there must have been an invalid unichar in the string
    this->init(8);
    this->make_bad();
  }
}

/**
 * WERD_CHOICE::init
 *
 * Helper function to build a WERD_CHOICE from the given string,
 * fragment lengths, rating, certainty and permuter.
 *
 * The function assumes that src_string is not NULL.
 * src_lengths argument could be NULL, in which case the unichars
 * in src_string are assumed to all be of length 1.
 */
void WERD_CHOICE::init(const char *src_string,
                       const char *src_lengths,
                       float src_rating,
                       float src_certainty,
                       uinT8 src_permuter,
                       const UNICHARSET &unicharset) {
  int src_string_len = strlen(src_string);
  if (src_string_len == 0) {
    this->init(8);
  } else {
    this->init(src_lengths ? strlen(src_lengths): src_string_len);
    length_ = reserved_;
    int offset = 0;
    for (int i = 0; i < length_; ++i) {
      int unichar_length = src_lengths ? src_lengths[i] : 1;
      unichar_ids_[i] =
          unicharset.unichar_to_id(src_string+offset, unichar_length);
      fragment_lengths_[i] = 1;
      offset += unichar_length;
    }
  }
  rating_ = src_rating;
  certainty_ = src_certainty;
  permuter_ = src_permuter;
}

/**
 * WERD_CHOICE::~WERD_CHOICE
 */
WERD_CHOICE::~WERD_CHOICE() {
  delete[] unichar_ids_;
  delete[] fragment_lengths_;
  delete_blob_choices();
}


/**
 * WERD_CHOICE::set_blob_choices
 *
 * Delete current blob_choices. Set the blob_choices to the given new
 * list.
 */
void WERD_CHOICE::set_blob_choices(BLOB_CHOICE_LIST_CLIST *blob_choices) {
  if (blob_choices_ != blob_choices) {
    delete_blob_choices();
    blob_choices_ = blob_choices;
  }
}


/**
 * contains_unichar_id
 *
 * Returns true if unichar_ids_ contain the given unichar_id, false otherwise.
 */
bool WERD_CHOICE::contains_unichar_id(UNICHAR_ID unichar_id) const {
  for (int i = 0; i < length_; ++i) {
    if (unichar_ids_[i] == unichar_id) {
      return true;
    }
  }
  return false;
}

/**
 * remove_unichar_ids
 *
 * Removes num unichar ids starting from index start from unichar_ids_
 * and updates length_ and fragment_lengths_ to reflect this change.
 * Note: this function does not modify rating_ and certainty_.
 */
void WERD_CHOICE::remove_unichar_ids(int start, int num) {
  ASSERT_HOST(start >= 0 && start + num <= length_);
  for (int i = start; i+num < length_; ++i) {
    unichar_ids_[i] = unichar_ids_[i+num];
    fragment_lengths_[i] = fragment_lengths_[i+num];
  }
  length_ -= num;
}

/**
 * string_and_lengths
 *
 * Populates the given word_str with unichars from unichar_ids and
 * and word_lengths_str with the corresponding unichar lengths.
 * Uses current_unicharset to make unichar id -> unichar conversions.
 */
void WERD_CHOICE::string_and_lengths(const UNICHARSET &current_unicharset,
                                     STRING *word_str,
                                     STRING *word_lengths_str) const {
  *word_str = "";
  if (word_lengths_str != NULL) *word_lengths_str = "";
  for (int i = 0; i < length_; ++i) {
    const char *ch = current_unicharset.id_to_unichar(unichar_ids_[i]);
    *word_str += ch;
    if (word_lengths_str != NULL) {
      *word_lengths_str += strlen(ch);
    }
  }
}

/**
 * append_unichar_id
 *
 * Make sure there is enough space in the word for the new unichar id
 * and call append_unichar_id_space_allocated().
 */
void WERD_CHOICE::append_unichar_id(
    UNICHAR_ID unichar_id, char fragment_length,
    float rating, float certainty) {
  if (length_ == reserved_) {
    this->double_the_size();
  }
  this->append_unichar_id_space_allocated(unichar_id, fragment_length,
                                          rating, certainty);
}

/**
 * WERD_CHOICE::operator+=
 *
 * Cat a second word rating on the end of this current one.
 * The ratings are added and the confidence is the min.
 * If the permuters are NOT the same the permuter is set to COMPOUND_PERM
 */
WERD_CHOICE & WERD_CHOICE::operator+= (const WERD_CHOICE & second) {
  // TODO(daria): find out why the choice was cleared this way if any
  // of the pieces are empty. Add the description of this behavior
  // to the comments.
  // if (word_string.length () == 0 || second.word_string.length () == 0) {
  //   word_string = NULL;          //make it empty
  //   word_lengths = NULL;
  //   delete_blob_choices();
  // } else {
  while (reserved_ < length_ + second.length()) {
    this->double_the_size();
  }
  const UNICHAR_ID *other_unichar_ids = second.unichar_ids();
  const char *other_fragment_lengths = second.fragment_lengths();
  for (int i = 0; i < second.length(); ++i) {
    unichar_ids_[length_ + i] = other_unichar_ids[i];
    fragment_lengths_[length_ + i] = other_fragment_lengths[i];
  }
  length_ += second.length();
  rating_ += second.rating();  // add ratings
  if (second.certainty() < certainty_) // take min
    certainty_ = second.certainty();
  if (permuter_ == NO_PERM) {
    permuter_ = second.permuter();
  } else if (second.permuter() != NO_PERM &&
             second.permuter() != permuter_) {
    permuter_ = COMPOUND_PERM;
  }
  unichar_string_ += second.unichar_string();
  unichar_lengths_ += second.unichar_lengths();

  // Append a deep copy of second blob_choices if it exists.
  if (second.blob_choices_ != NULL) {
    if (this->blob_choices_ == NULL)
      this->blob_choices_ = new BLOB_CHOICE_LIST_CLIST;

    BLOB_CHOICE_LIST_C_IT this_blob_choices_it;
    BLOB_CHOICE_LIST_C_IT second_blob_choices_it;

    this_blob_choices_it.set_to_list(this->blob_choices_);
    this_blob_choices_it.move_to_last();

    second_blob_choices_it.set_to_list(second.blob_choices_);

    for (second_blob_choices_it.mark_cycle_pt();
         !second_blob_choices_it.cycled_list();
         second_blob_choices_it.forward()) {

      BLOB_CHOICE_LIST* blob_choices_copy = new BLOB_CHOICE_LIST();
      blob_choices_copy->deep_copy(second_blob_choices_it.data(),
                                   &BLOB_CHOICE::deep_copy);

      this_blob_choices_it.add_after_then_move(blob_choices_copy);
    }
  }
  return *this;
}


/**
 * WERD_CHOICE::operator=
 *
 * Allocate enough memory to hold a copy of source and copy over
 * all the information from source to this WERD_CHOICE.
 */
WERD_CHOICE& WERD_CHOICE::operator=(const WERD_CHOICE& source) {
  while (reserved_ < source.length()) {
    this->double_the_size();
  }

  const UNICHAR_ID *other_unichar_ids = source.unichar_ids();
  const char *other_fragment_lengths = source.fragment_lengths();
  for (int i = 0; i < source.length(); ++i) {
    unichar_ids_[i] = other_unichar_ids[i];
    fragment_lengths_[i] = other_fragment_lengths[i];
  }
  length_ = source.length();
  rating_ = source.rating();
  certainty_ = source.certainty();
  permuter_ = source.permuter();
  fragment_mark_ = source.fragment_mark();
  unichar_string_ = source.unichar_string();
  unichar_lengths_ = source.unichar_lengths();

  // Delete existing blob_choices
  this->delete_blob_choices();

  // Deep copy blob_choices of source
  if (source.blob_choices_ != NULL) {
    BLOB_CHOICE_LIST_C_IT this_blob_choices_it;
    BLOB_CHOICE_LIST_C_IT source_blob_choices_it;

    this->blob_choices_ = new BLOB_CHOICE_LIST_CLIST();

    this_blob_choices_it.set_to_list(this->blob_choices_);
    source_blob_choices_it.set_to_list(source.blob_choices_);

    for (source_blob_choices_it.mark_cycle_pt();
         !source_blob_choices_it.cycled_list();
         source_blob_choices_it.forward()) {

      BLOB_CHOICE_LIST* blob_choices_copy = new BLOB_CHOICE_LIST();
      blob_choices_copy->deep_copy(source_blob_choices_it.data(),
                                   &BLOB_CHOICE::deep_copy);

      this_blob_choices_it.add_after_then_move(blob_choices_copy);
    }
  }
  return *this;
}

/**********************************************************************
 * WERD_CHOICE::delete_blob_choices
 *
 * Clear the blob_choices list, delete it and set it to NULL.
 **********************************************************************/
void WERD_CHOICE::delete_blob_choices() {
  if (blob_choices_ != NULL) {
    blob_choices_->deep_clear();
    delete blob_choices_;
    blob_choices_ = NULL;
  }
}

/**
 * WERD_CHOICE::print
 *
 * Print WERD_CHOICE to stdout.
 */
void WERD_CHOICE::print(const char *msg) const {
  tprintf("%s WERD_CHOICE:\n", msg);
  tprintf("length_ %d reserved_ %d permuter_ %d\n",
         length_, reserved_, permuter_);
  tprintf("rating_ %.4f certainty_ %.4f", rating_, certainty_);
  if (fragment_mark_) {
    tprintf(" fragment_mark_ true");
  }
  tprintf("\n");
  if (unichar_string_.length() > 0) {
    tprintf("unichar_string_ %s unichar_lengths_ %s\n",
            unichar_string_.string(), unichar_lengths_.string());
  }
  tprintf("unichar_ids: ");
  int i;
  for (i = 0; i < length_; ++i) {
    tprintf("%d ", unichar_ids_[i]);
  }
  tprintf("\nfragment_lengths_: ");
  for (i = 0; i < length_; ++i) {
    tprintf("%d ", fragment_lengths_[i]);
  }
  tprintf("\n");
  fflush(stdout);
}

/**
 * print_ratings_list
 *
 * Send all the ratings out to the logfile.
 *
 * @param msg intro message
 * @param ratings list of ratings
 * @param current_unicharset unicharset that can be used
 * for id-to-unichar conversion
 */
void print_ratings_list(const char *msg,
                        BLOB_CHOICE_LIST *ratings,
                        const UNICHARSET &current_unicharset) {
  if (ratings->length() == 0) {
    tprintf("%s:<none>\n", msg);
    return;
  }
  if (*msg != '\0') {
    tprintf("%s\n", msg);
  }
  BLOB_CHOICE_IT c_it;
  c_it.set_to_list(ratings);
  for (c_it.mark_cycle_pt(); !c_it.cycled_list(); c_it.forward()) {
    tprintf("r%.2f c%.2f : %d %s",
            c_it.data()->rating(), c_it.data()->certainty(),
            c_it.data()->unichar_id(),
            current_unicharset.debug_str(c_it.data()->unichar_id()).string());
    if (!c_it.at_last()) {
      tprintf("\n");
    }
  }
  tprintf("\n");
  fflush(stdout);
}

/**
 * print_ratings_list
 *
 * Print ratings list (unichar ids only).
 */
void print_ratings_list(const char *msg, BLOB_CHOICE_LIST *ratings) {
  if (ratings->length() == 0) {
    tprintf("%s:<none>\n", msg);
    return;
  }
  if (*msg != '\0') {
    tprintf("%s\n", msg);
  }
  BLOB_CHOICE_IT c_it;
  c_it.set_to_list(ratings);
  for (c_it.mark_cycle_pt(); !c_it.cycled_list(); c_it.forward()) {
    tprintf("r%.2f c%.2f : %d", c_it.data()->rating(),
            c_it.data()->certainty(), c_it.data()->unichar_id());
    if (!c_it.at_last()) {
      tprintf("\n");
    }
  }
  tprintf("\n");
  fflush(stdout);
}

/**
 * print_ratings_info
 *
 * Send all the ratings out to the logfile.
 *
 * @param fp file to use
 * @param ratings list of results
 * @param current_unicharset unicharset that can be used
 * for id-to-unichar conversion
 */
void print_ratings_info(FILE *fp,
                        BLOB_CHOICE_LIST *ratings,
                        const UNICHARSET &current_unicharset)
{
  Q_UNUSED(fp);
  inT32 index;                    // to list
  inT32 best_index;               // to list
  FLOAT32 best_rat;               // rating
  FLOAT32 best_cert;              // certainty
  const char* first_char = NULL;  // character
  FLOAT32 first_rat;              // rating
  FLOAT32 first_cert;             // certainty
  const char* sec_char = NULL;    // character
  FLOAT32 sec_rat = 0.0f;         // rating
  FLOAT32 sec_cert = 0.0f;        // certainty
  BLOB_CHOICE_IT c_it = ratings;  // iterator

  index = ratings->length();
  if (index > 0) {
    first_char = current_unicharset.id_to_unichar(c_it.data()->unichar_id());
    first_rat = c_it.data()->rating();
    first_cert = -c_it.data()->certainty();
    if (index > 1) {
      sec_char = current_unicharset.id_to_unichar(
          c_it.data_relative(1)->unichar_id());
      sec_rat = c_it.data_relative(1)->rating();
      sec_cert = -c_it.data_relative(1)->certainty();
    } else {
      sec_char = NULL;
      sec_rat = -1;
      sec_cert = -1;
    }
  } else {
    first_char = NULL;
    first_rat = -1;
    first_cert = -1;
  }
  best_index = -1;
  best_rat = -1;
  best_cert = -1;
  for (index = 0, c_it.mark_cycle_pt(); !c_it.cycled_list();
       c_it.forward(), index++) {
    if (strcmp(current_unicharset.id_to_unichar(c_it.data()->unichar_id()),
               blob_answer) == 0) {
      best_index = index;
      best_rat = c_it.data()->rating();
      best_cert = -c_it.data()->certainty();
    }
  }
  if (first_char != NULL && (*first_char == '\0' || *first_char == ' '))
    first_char = NULL;
  if (sec_char != NULL && (*sec_char == '\0' || *sec_char == ' '))
    sec_char = NULL;
  fprintf(matcher_fp,
          " " INT32FORMAT " " INT32FORMAT " %g %g %s %g %g %s %g %g\n",
          ratings->length(), best_index, best_rat, best_cert,
          first_char != NULL ? first_char : "~",
          first_rat, first_cert, sec_char != NULL ? sec_char : "~",
          sec_rat, sec_cert);
}

/**
 * print_char_choices_list
 */
void print_char_choices_list(const char *msg,
                             const BLOB_CHOICE_LIST_VECTOR &char_choices,
                             const UNICHARSET &current_unicharset,
                             BOOL8 detailed) {
  if (*msg != '\0') tprintf("%s\n", msg);
  for (int x = 0; x < char_choices.length(); ++x) {
    BLOB_CHOICE_IT c_it;
    c_it.set_to_list(char_choices.get(x));
    tprintf("char[%d]: %s\n", x,
            current_unicharset.debug_str( c_it.data()->unichar_id()).string());
    if (detailed)
      print_ratings_list("  ", char_choices.get(x), current_unicharset);
  }
}
//////////////////////////////////////////////////////////////ratngs//////////////////////////////////

/////////////////////////////////////////////////////////////////ambigs/////////////////////////////////
INT_VAR(global_ambigs_debug_level, 0, "Debug level for unichar ambiguities");
BOOL_VAR(use_definite_ambigs_for_classifier, 0, "Use definite ambiguities when running character classifier");

AmbigSpec::AmbigSpec()
{
    wrong_ngram[0] = INVALID_UNICHAR_ID;
    correct_fragments[0] = INVALID_UNICHAR_ID;
    correct_ngram_id = INVALID_UNICHAR_ID;
    type = NOT_AMBIG;
    wrong_ngram_size = 0;
}

ELISTIZE(AmbigSpec)

void UnicharAmbigs::LoadUnicharAmbigs(FILE *AmbigFile, inT64 end_offset, UNICHARSET *unicharset)
{
    int i;
    for (i = 0; i < unicharset->size(); ++i)
    {
        replace_ambigs_.push_back(NULL);
        dang_ambigs_.push_back(NULL);
        one_to_one_definite_ambigs_.push_back(NULL);
    }

    if (global_ambigs_debug_level)
    {
        tprintf("Reading ambiguities\n");
    }

    int TestAmbigPartSize;
    int ReplacementAmbigPartSize;

    // Maximum line size:
    //   10 for sizes of ambigs, tabs, abmig type and newline
    //   UNICHAR_LEN * (MAX_AMBIG_SIZE + 1) for each part of the ambig
    // The space for buffer is allocated on the heap to avoid
    // GCC frame size warning.
    const int kMaxAmbigStringSize = UNICHAR_LEN * (MAX_AMBIG_SIZE + 1);
    const int kBufferSize = 10 + 2 * kMaxAmbigStringSize;
    char *buffer = new char[kBufferSize];
    char ReplacementString[kMaxAmbigStringSize];
    UNICHAR_ID TestUnicharIds[MAX_AMBIG_SIZE + 1];
    int line_num = 0;
    int type = NOT_AMBIG;

    // Determine the version of the ambigs file.
    int version = 0;
    ASSERT_HOST(fgets(buffer, kBufferSize, AmbigFile) != NULL && strlen(buffer) > 0);
    if (*buffer == 'v')
    {
        version = static_cast<int>(strtol(buffer+1, NULL, 10));
        ++line_num;
    }
    else
    {
        rewind(AmbigFile);
    }

    while ((end_offset < 0 || ftell(AmbigFile) < end_offset) && fgets(buffer, kBufferSize, AmbigFile) != NULL)
    {
        chomp_string(buffer);
        if (global_ambigs_debug_level > 2) tprintf("read line %s\n", buffer);
        ++line_num;
        if (!ParseAmbiguityLine(line_num, version, *unicharset, buffer, &TestAmbigPartSize,
                                TestUnicharIds, &ReplacementAmbigPartSize, ReplacementString, &type))
        {
            continue;
        }

        // Construct AmbigSpec and add it to the appropriate AmbigSpec_LIST.
        AmbigSpec *ambig_spec = new AmbigSpec();
        InsertIntoTable((type == REPLACE_AMBIG) ? replace_ambigs_ : dang_ambigs_,
                        TestAmbigPartSize, TestUnicharIds, ReplacementAmbigPartSize, ReplacementString, type, ambig_spec, unicharset);

        // Update one_to_one_definite_ambigs_.
        if (use_definite_ambigs_for_classifier && TestAmbigPartSize == 1 && ReplacementAmbigPartSize == 1 && type == DEFINITE_AMBIG)
        {
            if (one_to_one_definite_ambigs_[TestUnicharIds[0]] == NULL)
            {
                one_to_one_definite_ambigs_[TestUnicharIds[0]] = new UnicharIdVector();
            }
            one_to_one_definite_ambigs_[TestUnicharIds[0]]->push_back(ambig_spec->correct_ngram_id);
        }
    }
    delete[] buffer;

    // Print what was read from the input file.
    if (global_ambigs_debug_level > 2)
    {
        for (int tbl = 0; tbl < 2; ++tbl)
        {
            const UnicharAmbigsVector &print_table = (tbl == 0) ? replace_ambigs_ : dang_ambigs_;
            for (i = 0; i < print_table.size(); ++i)
            {
                AmbigSpec_LIST *lst = print_table[i];
                if (lst == NULL) continue;

                if (!lst->empty())
                {
                    tprintf("%s Ambiguities for %s:\n", (tbl == 0) ? "Replaceable" : "Dangerous", unicharset->debug_str(i).string());
                }

                AmbigSpec_IT lst_it(lst);
                for (lst_it.mark_cycle_pt(); !lst_it.cycled_list(); lst_it.forward())
                {
                    AmbigSpec *ambig_spec = lst_it.data();
                    tprintf("wrong_ngram:");

                    UnicharIdArrayUtils::print(ambig_spec->wrong_ngram, *unicharset);
                    tprintf("correct_fragments:");

                    UnicharIdArrayUtils::print(ambig_spec->correct_fragments, *unicharset);
                }
            }
        }
    }
}

bool UnicharAmbigs::ParseAmbiguityLine(int line_num, int version, const UNICHARSET &unicharset, char *buffer,
                                       int *TestAmbigPartSize, UNICHAR_ID *TestUnicharIds, int *ReplacementAmbigPartSize, char *ReplacementString, int *type)
{
    int i;
    char *token;
    char *next_token;
    if (!(token = strtok_r(buffer, kAmbigDelimiters, &next_token)) || !sscanf(token, "%d", TestAmbigPartSize) || *TestAmbigPartSize <= 0)
    {
        if (global_ambigs_debug_level)
        {
            tprintf(kIllegalMsg, line_num);
        }

        return false;
    }

    if (*TestAmbigPartSize > MAX_AMBIG_SIZE)
    {
        tprintf("Too many unichars in ambiguity on line %d\n");

        return false;
    }

    for (i = 0; i < *TestAmbigPartSize; ++i)
    {
        if (!(token = strtok_r(NULL, kAmbigDelimiters, &next_token))) break;

        if (!unicharset.contains_unichar(token))
        {
            if (global_ambigs_debug_level)
            {
                tprintf(kIllegalUnicharMsg, token);
            }

            break;
        }

        TestUnicharIds[i] = unicharset.unichar_to_id(token);
    }

    TestUnicharIds[i] = INVALID_UNICHAR_ID;

    if (i != *TestAmbigPartSize || !(token = strtok_r(NULL, kAmbigDelimiters, &next_token)) ||
            !sscanf(token, "%d", ReplacementAmbigPartSize) || *ReplacementAmbigPartSize <= 0)
    {
        if (global_ambigs_debug_level)
        {
            tprintf(kIllegalMsg, line_num);
        }

        return false;
    }

    if (*ReplacementAmbigPartSize > MAX_AMBIG_SIZE)
    {
        tprintf("Too many unichars in ambiguity on line %d\n");

        return false;
    }

    ReplacementString[0] = '\0';
    for (i = 0; i < *ReplacementAmbigPartSize; ++i)
    {
        if (!(token = strtok_r(NULL, kAmbigDelimiters, &next_token))) break;

        strcat(ReplacementString, token);

        if (!unicharset.contains_unichar(token))
        {
            if (global_ambigs_debug_level)
            {
                tprintf(kIllegalUnicharMsg, token);
            }

            break;
        }
    }

    if (i != *ReplacementAmbigPartSize)
    {
        if (global_ambigs_debug_level)
        {
            tprintf(kIllegalMsg, line_num);
        }

        return false;
    }

    if (version > 0)
    {
        // The next field being true indicates that the abiguity should
        // always be substituted (e.g. '' should always be changed to ").
        // For such "certain" n -> m ambigs tesseract will insert character
        // fragments for the n pieces in the unicharset. AmbigsFound()
        // will then replace the incorrect ngram with the character
        // fragments of the correct character (or ngram if m > 1).
        // Note that if m > 1, an ngram will be inserted into the
        // modified word, not the individual unigrams. Tesseract
        // has limited support for ngram unichar (e.g. dawg permuter).
        if (!(token = strtok_r(NULL, kAmbigDelimiters, &next_token)) || !sscanf(token, "%d", type))
        {
            if (global_ambigs_debug_level)
            {
                tprintf(kIllegalMsg, line_num);
            }

            return false;
        }
    }

    return true;
}

void UnicharAmbigs::InsertIntoTable(UnicharAmbigsVector &table, int TestAmbigPartSize, UNICHAR_ID *TestUnicharIds, int ReplacementAmbigPartSize,
                                    const char *ReplacementString, int type, AmbigSpec *ambig_spec, UNICHARSET *unicharset)
{
    ambig_spec->type = static_cast<AmbigType>(type);
    if (TestAmbigPartSize == 1 && ReplacementAmbigPartSize == 1 &&
            unicharset->to_lower(TestUnicharIds[0]) == unicharset->to_lower(unicharset->unichar_to_id(ReplacementString)))
    {
        ambig_spec->type = CASE_AMBIG;
    }

    ambig_spec->wrong_ngram_size = UnicharIdArrayUtils::copy(TestUnicharIds, ambig_spec->wrong_ngram);

    // Since we need to maintain a constant number of unichar positions in
    // order to construct ambig_blob_choices vector in NoDangerousAmbig(), for
    // each n->m ambiguity we will have to place n character fragments of the
    // correct ngram into the corresponding positions in the vector (e.g. given
    // "vvvvw" and vvvv->ww we will place v and |ww|0|4 into position 0, v and
    // |ww|1|4 into position 1 and so on. The correct ngram is reconstructed
    // from fragments by dawg_permute_and_select().

    // Insert the corresponding correct ngram into the unicharset.
    // Unicharset code assumes that the "base" ngram is inserted into
    // the unicharset before fragments of this ngram are inserted.
    unicharset->unichar_insert(ReplacementString);
    ambig_spec->correct_ngram_id = unicharset->unichar_to_id(ReplacementString);
    if (ReplacementAmbigPartSize > 1)
    {
        unicharset->set_isngram(ambig_spec->correct_ngram_id, true);
    }

    // Add the corresponding fragments of the correct ngram to unicharset.
    int i;
    for (i = 0; i < TestAmbigPartSize; ++i)
    {
        UNICHAR_ID unichar_id;
        if (TestAmbigPartSize == 1)
        {
            unichar_id = ambig_spec->correct_ngram_id;
        }
        else
        {
            STRING frag_str = CHAR_FRAGMENT::to_string(ReplacementString, i, TestAmbigPartSize); unicharset->unichar_insert(frag_str.string());
            unichar_id = unicharset->unichar_to_id(frag_str.string());
        }
        ambig_spec->correct_fragments[i] = unichar_id;
    }
    ambig_spec->correct_fragments[i] = INVALID_UNICHAR_ID;

    // Add AmbigSpec for this ambiguity to the corresponding AmbigSpec_LIST.
    // Keep AmbigSpec_LISTs sorted by AmbigSpec.wrong_ngram.
    if (table[TestUnicharIds[0]] == NULL)
    {
        table[TestUnicharIds[0]] = new AmbigSpec_LIST();
    }
    table[TestUnicharIds[0]]->add_sorted(AmbigSpec::compare_ambig_specs, ambig_spec);
}
/////////////////////////////////////////////////////////////////ambigs/////////////////////////////////

OCR::OCR()
{
}

int OCR::init(const QString &sDataPath)
{
    //设置训练数据，和训练数据的语言
    int iRet = m_tessBaseApi.Init(sDataPath.toLatin1().constData(), NULL);

    return iRet;
}

QString OCR::getRecognizeText(const Mat &matSrc)
{
    if (matSrc.channels() != 1) return QString();

    //设置图像
    m_tessBaseApi.SetImage(matSrc.data, matSrc.cols, matSrc.rows, matSrc.channels(), matSrc.step);

    //识别图像中的文字
    char* pText = m_tessBaseApi.GetUTF8Text();
    QString sText(pText);
    if (pText != NULL) delete[] pText;
    m_tessBaseApi.Clear();

    return QString(sText);
}
