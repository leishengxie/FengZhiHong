#ifndef OCR_H
#define OCR_H

#include <cv.h>
#include <cxcore.h>
#include <highgui.h>
#include <imgproc.hpp>
#include <imgcodecs.hpp>

#include <limits.h>
#include <setjmp.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <assert.h>
#include <stdint.h>
#include <stddef.h>
#include <sys/stat.h>
#include <memory.h>
#include <errno.h>
#include <time.h>
#include <stdarg.h>
#include <signal.h>
#include <ctype.h>
#include <unistd.h>
#include <inttypes.h>
#include <sys/types.h>
#include <fcntl.h>
#include <math.h>
#include <map>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <pthread.h>
#include <semaphore.h>
#include <netdb.h>
#include <sys/socket.h>
#include <sys/prctl.h>
#include <limits.h>
#include <utility>
#include <algorithm>
#include <vector>
#include <cstring>
#include <climits>
#include <QTime>
#include <QDebug>

using namespace cv;
using namespace std;

// A variable to indicate an invalid or uninitialized unichar id.
static const int INVALID_UNICHAR_ID = -1;

#define MAX_NUM_CLASSES   8192
#define UNICHAR_LEN       24
#define PATHSIZE          8192       /*max elements in edge path */
#define OUTLINESIZE       256      /*max elements in aprroximated path */
#define BLOBSIZE          10000      /*max no of blobs on a page */
#define VECSCALE          3          /*vector scaling factor in fx */
#define REALSCALE         ((double)(1<<VECSCALE))
#define SPLINESIZE        23       /*max spline parts to a line */
#define MAXUCHAR          255        /*max value of unsigned char */
#define PI                3.14159265359/*pi */
#define FILENAMESIZE    1024     /*max permissible path name length */
#define MAX_WO_CLASSES    3      /*no of quickie classes */
#define ITALIC        0          /*measure of italicness */
#define ASPECT_RATIO    2        /*aspect ratio of blob */
#define NODEFLAGS     4          /*no of flags in a node */
#define EDGEPTFLAGS     4        /*concavity,length etc. */
#define FLAGS       0            /*flags array indices */
#define CONVEX        1          /*TESSLINE point is convex */
#define CONCAVE       2          /*used and set only in edges */
#define ONHULL        8          /*on convex hull */
#define RUNLENGTH     1          /*length of run */
#define DIR         2            /*direction of run */
#define CORRECTION      3        /*correction of run */
#define OUTLINES_PER_BLOB 8      /*max no of outlines in blob */
#define PLUS        1            /*starbase markers */
#define CIRCLE        3
#define SMD         0x100000     /*memory driver output */
#define SCAN        0            /*scanner process id */
#define EDGE        1            /*edge process id */
#define FX          2            /*fx process id */
#define TESSTO      3            /*pageseg process id */
#define OCR1         4            /*ocr process id */
#define MAXPROC       (OCR1+1)    /*no of processes */
#define STRINGCMPS      0x1      /*show ocrdiff compares */
#define CHECKS        0x1        /*run accuracy checks */
#define WRITEERRORS     0x2      /*write error output */
#define WRITECORRECTS   0x4      /*write correct blobs as errors */
#define WRITEWERDS      0x8      /*write whole words */
#define FXSELECT      0x10       /*write error output */
#define WRITEROWFILE    0x06     /*any write errors */
#define LEARN       0x100        /*learn mode */
#define WRITELEARNFILE    0xf00  /*any learning */
#define EACHWERD      0x2000     /*clear vdc after each word */

#ifdef __MSW32__
#define SIGNED
#define snprintf _snprintf
#define read _read
#define write _write
#define close _close
#define lseek _lseek
#define open _open
#define ultoa _ultoa
#define ltoa _ltoa
#define strtok_r(s, d, p) strtok(s, d)
#if (_MSC_VER <= 1400)
#define vsnprintf _vsnprintf
#endif
#else
#define __UNIX__
#ifndef PATH_MAX
#else
#endif
#define SIGNED signed
#endif

typedef int UNICHAR_ID;
typedef short CLASS_CUTOFF_ARRAY[MAX_NUM_CLASSES];
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
 **                                IMPORTANT!!!                                                                                                                 **
 **                                                                                                                                                                              **
 ** Defines either __MSW__, __MSW32__, __MAC__, __UNIX__, __OS2__, __PM__ to
 ** use the specified definitions indicated below in the preprocessor settings.                                                        **
 **                                                                                                                                                                              **
 ** Also define either  __FarProc__ or  __FarData__  and __MOTO__ to use the
 ** specified definitions indicated below in the preprocessor settings.                                                                        **
 **                                                                                                                                                                             **
 ** If a preprocessor settings is not allow in the compiler that is being use,
 ** then it is recommended that a "platform.h" is created with the definition
 ** of the computer and/or operating system.
 ******************************************************************************/
/********************************************************/
#if defined(__UNIX__) || defined( __DOS__ ) || defined(__OS2__) || defined(__PM__)
/*----------------------------*/
/* FarProc and FarData */
/*----------------------------*/
#define DLLIMPORT
#define DLLEXPORT
/*----------------------------*/
#endif
/*****************************************************************************
 **
 **                      Standard GHC Definitions
 **
 *****************************************************************************/

#ifdef __MOTO__
#define __NATIVE__   MOTO
#else
#define __NATIVE__   INTEL
#endif

//typedef HANDLE FD*  PHANDLE;

// definitions of portable data types (numbers and characters)
typedef signed char inT8;
typedef unsigned char uinT8;
typedef short inT16;
typedef unsigned short uinT16;
typedef int inT32;
typedef unsigned int uinT32;
#if (_MSC_VER >= 1200)            //%%% vkr for VC 6.0
typedef INT64 inT64;
typedef UINT64 uinT64;
#else
typedef long long int inT64;
typedef unsigned long long int uinT64;
#endif                           //%%% vkr for VC 6.0
typedef float FLOAT32;
typedef double FLOAT64;
typedef unsigned char BOOL8;

#define INT32FORMAT "%d"
#define INT64FORMAT "%lld"

#define MAX_INT8  0x7f
#define MAX_INT16 0x7fff
#define MAX_INT32 0x7fffffff
#define MAX_UINT8 0xff
#define MAX_UINT16  0xffff
#define MAX_UINT32  0xffffffff
#define MAX_FLOAT32 ((float)3.40282347e+38)

#define MIN_INT8  0x80
#define MIN_INT16 0x8000
#define MIN_INT32 0x80000000
#define MIN_UINT8 0x00
#define MIN_UINT16  0x0000
#define MIN_UINT32  0x00000000
#define MIN_FLOAT32 ((float)1.17549435e-38)
#define MAX_PATH 4096

// Defines

#ifndef OKAY
#define OKAY            0
#endif

#ifndef HPERR
#define HPERR           -1
#endif

#ifndef TRUE
#define TRUE            1
#endif

#ifndef FALSE
#define FALSE           0
#endif

#ifndef NULL
#define NULL            0L
#endif

// Return true if x is within tolerance of y
template<class T> bool NearlyEqual(T x, T y, T tolerance)
{
  T diff = x - y;
  return diff <= tolerance && -diff <= tolerance;
}

//hash function
inT32 myHash(inT32 bits, void *key, inT32 keysize);

typedef uinT64 EDGE_RECORD;
typedef EDGE_RECORD *EDGE_ARRAY;
typedef inT64 EDGE_REF;
typedef inT64 NODE_REF;
typedef EDGE_REF *NODE_MAP;

#define LEARN_MODE      0
#define CLASSIFY_MODE   1
typedef char *CHAR_FEATURES;

/* define the maximum number of classes defined for any matcher
  and the maximum class id for any matcher. This must be changed
  if more different classes need to be classified */
#define MAX_CLASS_ID    (MAX_NUM_CLASSES - 1)

/** a CLASS_ID is the ascii character to be associated with a class */
typedef UNICHAR_ID CLASS_ID;
#define NO_CLASS      (0)

/** a PROTO_ID is the index of a prototype within it's class.  Valid proto
  id's are 0 to N-1 where N is the number of prototypes that make up the
  class. */
typedef inT16 PROTO_ID;
#define NO_PROTO  (-1)

/** FEATURE_ID is the index of a feature within a character description
  The feature id ranges from 0 to N-1 where N is the number
  of features in a character description. */
typedef uinT8 FEATURE_ID;
#define NO_FEATURE      255
#define NOISE_FEATURE   254
#define MISSING_PROTO   254
#define MAX_NUM_FEAT    40
#define MAX_FEATURE_ID    250

/** a RATING is the match rating returned by a classifier.
  Higher is better. */
typedef FLOAT32 RATING;

/** a CERTAINTY is an indication of the degree of confidence of the
  classifier.  Higher is better.  0 means the match is as good as the
  mean of the matches seen in training.  -1 means the match was one
  standard deviation worse than the training matches, etc. */
typedef FLOAT32 CERTAINTY;

/** define a data structure to hold a single match result */
typedef struct
{
  CLASS_ID Class;
  RATING Rating;
  CERTAINTY Certainty;
}


MATCH_RESULT;

/** define a data structure for holding an array of match results */
typedef MATCH_RESULT SORTED_CLASSES[MAX_CLASS_ID + 1];


// Multiple of box size to search for initial gaps.
const int kTabRadiusFactor = 5;
// Min and Max multiple of height to search vertically when extrapolating.
const int kMinVerticalSearch = 3;
const int kMaxVerticalSearch = 12;
const int kMaxRaggedSearch = 25;
// Minimum number of lines in a column width to make it interesting.
const int kMinLinesInColumn = 10;
// Minimum width of a column to be interesting.
const int kMinColumnWidth = 200;
// Minimum fraction of total column lines for a column to be interesting.
const double kMinFractionalLinesInColumn = 0.125;
// Fraction of height used as alignment tolerance for aligned tabs.
const double kAlignedFraction = 0.03125;
// Fraction of height used as a minimum gap for aligned blobs.
const double kAlignedGapFraction = 0.75;
// Multiplier of new y positions in running average for skew estimation.
const double kSmoothFactor = 0.25;
// Min coverage for a good baseline between vectors
const double kMinBaselineCoverage = 0.5;
// Minimum overlap fraction when scanning text lines for column widths.
const double kCharVerticalOverlapFraction = 0.375;
// Maximum horizontal gap allowed when scanning for column widths
const double kMaxHorizontalGap = 3.0;
// Maximum upper quartile error allowed on a baseline fit as a fraction
// of height.
const double kMaxBaselineError = 0.4375;
// Min number of points to accept after evaluation.
const int kMinEvaluatedTabs = 3;
// Minimum aspect ratio of a textline to make a good textline blob with a
// single blob.
const int kMaxTextLineBlobRatio = 5;
// Minimum aspect ratio of a textline to make a good textline blob with
// multiple blobs. Target ratio varies according to number of blobs.
const int kMinTextLineBlobRatio = 3;
// Fraction of box area covered by image to make a blob image.
const double kMinImageArea = 0.5;
/*----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------*/
/**
  all feature matchers that are to be used with the high level
  classifier must support the following interface.  The names will, of
  course, be unique for each different matcher.  Note also that
  FEATURE_STRUCT is a data structure that is defined specifically for
  each feature extractor/matcher pair.
*/

/* misc test functions for proto id's and feature id's */
#define IsValidFeature(Fid) ((Fid) < MAX_FEATURE_ID)
#define IsValidProto(Pid) ((Pid) >= 0)

#if defined(__STDC__) || defined(__cplusplus)
# define _ARGS(s) s
#else
# define _ARGS(s) ()
#endif

/* matchdefs.c */
int CompareMatchResults
_ARGS ((MATCH_RESULT * Result1, MATCH_RESULT * Result2));

void PrintMatchResult _ARGS ((FILE * File, MATCH_RESULT * MatchResult));

void PrintMatchResults
_ARGS ((FILE * File, int N, MATCH_RESULT MatchResults[]));

#undef _ARGS

#undef Min
#undef Max
#define FEAT_NAME_SIZE    80

/*define trap errors which can be caused by this module*/
#define ILLEGAL_FEATURE_PARAM 1000
#define ILLEGAL_NUM_FEATURES  1001
typedef struct
{
  inT8 Circular;                 /* TRUE if dimension wraps around */
  inT8 NonEssential;             /* TRUE if dimension not used in searches */
  FLOAT32 Min;                   /* low end of range for circular dimensions */
  FLOAT32 Max;                   /* high end of range for circular dimensions */
  FLOAT32 Range;                 /* Max - Min */
  FLOAT32 HalfRange;             /* (Max - Min)/2 */
  FLOAT32 MidRange;              /* (Max + Min)/2 */
} PARAM_DESC;

typedef struct fds
{
  uinT16 NumParams;              /* total # of params */
  uinT8 NumLinearParams;         /* # of linear params */
  uinT8 NumCircularParams;       /* # of linear params */
  uinT8 MinFeatPerChar;          /* min # of feats allowed */
  uinT8 MaxFeatPerChar;          /* max # of feats allowed */
  char LongName[FEAT_NAME_SIZE]; /* long name for feature */
  char ShortName[FEAT_NAME_SIZE];/* short name for feature */
  PARAM_DESC *ParamDesc;         /* array - one per param */
} FEATURE_DESC_STRUCT;
typedef FEATURE_DESC_STRUCT *FEATURE_DESC;

typedef struct
{
  struct fds *Type;              /* points to description of feature type */
  FLOAT32 Params[1];             /* variable size array - params for feature */
} FEATURE_STRUCT;
typedef FEATURE_STRUCT *FEATURE;

typedef struct
{
  uinT16 NumFeatures;            /* number of features in set */
  uinT16 MaxNumFeatures;         /* maximum size of feature set */
  FEATURE Features[1];           /* variable size array of features */
} FEATURE_SET_STRUCT;
typedef FEATURE_SET_STRUCT *FEATURE_SET;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////globaloc/////////////////////////////////////////////////////////
//Signal which
void signal_exit(int signal_code);

//extern "C" {
void err_exit();

//The real signal
void signal_termination_handler(int sig);
//};

void set_global_loc_code(int loc_code);

void set_global_subloc_code(int loc_code);

void set_global_subsubloc_code(int loc_code);
/////////////////////////////////////////////////////globaloc/////////////////////////////////////////////////////////

/////////////////////////////////////////////////////danerror/////////////////////////////////////////////////////////
/**----------------------------------------------------------------------------
          Include Files and Type Defines
----------------------------------------------------------------------------**/
#define SetErrorTrap(Proc)  setjmp(PushErrorTrap(Proc))
#define NOERROR       0
#define DO_NOTHING      0

typedef int TRAPERROR;
typedef void (*VOID_PROC) ();

/**----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------**/
void ReleaseErrorTrap();

void DoError(int Error, const char *Message);

jmp_buf &PushErrorTrap(VOID_PROC Procedure);
/////////////////////////////////////////////////////danerror/////////////////////////////////////////////////////////

/////////////////////////////////////////////////////freelist/////////////////////////////////////////////////////////
int *memalloc(int size);

int *memrealloc(void *ptr, int size, int oldsize);

void memfree(void *element);

void mem_tidy(int level);
/////////////////////////////////////////////////////freelist/////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////tessarray//////////////////////////////////
/*
----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------
*/

typedef struct array_record
{
  size_t limit;
  size_t top;
  void *base[2];
} *ARRAY;

typedef void (*voidProc) ();

typedef int (*intProc) ();

/*
----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------
*/

#define DEFAULT_SIZE 2

/**********************************************************************
 * array_count
 *
 * Return the value of the number of elements currently in the array.
 **********************************************************************/

#define array_count(a)  \
((a)->top)

/**********************************************************************
 * array_free
 *
 * Free the memory allocated to this array.
 **********************************************************************/

#define array_free  \
memfree

/**********************************************************************
 * array_index
 *
 * Check to make sure that the index value is valid. Return the
 * value of the nth element currently in the array.
 **********************************************************************/

#define array_index(a,i)   \
((i<array_count(a)) ? (a)->base[i] : 0)

/**********************************************************************
 * array_limit
 *
 * Return the maximum number of elements that could be currently held
 * in this array without further expansion.
 **********************************************************************/

#define array_limit(a)     \
((a)->limit)

/**********************************************************************
 * array_loop
 *
 * Iterate through each of the array elements.  Each value can then be
 * accessed by:
 *    array_index (a, x)
 **********************************************************************/

#define array_loop(a,x)    \
for (x=0; x < (int)array_count(a); x++)

/**********************************************************************
 * array_top
 *
 * Return the last element that was pushed on this array.
 **********************************************************************/

#define array_top(a)       \
((a)->base[array_count (a) - 1])

/**********************************************************************
 * array_value
 *
 * Return the nth element of the array.  Don't do range checking.
 **********************************************************************/

#define array_value(a,i)   \
((a)->base[i])

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
ARRAY array_insert(ARRAY array, int index, void *value);

ARRAY array_new(int num);

ARRAY array_push(ARRAY array, void *value);
//////////////////////////////////////////////////////////////tessarray//////////////////////////////////

//////////////////////////////////////////////////////////////choicearr//////////////////////////////////
/*
----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------
*/

typedef ARRAY CHOICES_LIST;

#define CHOICES_PER_LIST 40

/*
----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------
*/

/**********************************************************************
 * free_choice_list
 *
 * Free a list of choices. Free the array structure but not each of the
 * sublists of choices.
 **********************************************************************/

#define free_choice_list(choice_list)  \
array_free (choice_list)

/**********************************************************************
 * for_each_choice
 *
 * Iterate through each of the possible choices.
 **********************************************************************/

#define for_each_choice(array,index)  \
array_loop (array, index)

/**********************************************************************
 * free_all_choices
 *
 * Free an array of choices (deep free).
 **********************************************************************/

#define free_all_choices(choices,index)                      \
for_each_choice (choices, index) {                         \
    free_choices ((CHOICES) array_value (choices, index));  \
}                                                          \
array_free (choices)                                       \


/**********************************************************************
 * new_choice_list
 *
 * Return a new array structure that is a list of choices. Each set of
 * choices will be of type CHOICES.
 **********************************************************************/

#define new_choice_list()  \
array_new (CHOICES_PER_LIST)
//////////////////////////////////////////////////////////////choicearr//////////////////////////////////

//////////////////////////////////////////////////////////////cutil//////////////////////////////////
/*----------------------------------------------------------------------
                      T y p e s
----------------------------------------------------------------------*/
#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#define CHARS_PER_LINE 500

#if defined(__STDC__) || defined(__cplusplus) || MAC_OR_DOS
# define _ARGS(s) s
#else
# define _ARGS(s) ()
#endif

//typedef int (*int_proc)               (void);
typedef void (*void_proc) (...);
typedef void *(*void_star_proc) _ARGS ((...));

typedef int (*int_void) (void);
typedef void (*void_void) (void);
typedef int (*int_compare) (void *, void *);
typedef void (*void_dest) (void *);

/*----------------------------------------------------------------------
                     M a c r o s
----------------------------------------------------------------------*/
/**********************************************************************
 * new_line
 *
 * Print a new line character on stdout.
 **********************************************************************/

#define new_line()  \
  tprintf("\n")

/**********************************************************************
 * print_string
 *
 * Print a string on stdout.
 **********************************************************************/

#define print_string(str)  \
  printf ("%s\n", str)

/**********************************************************************
 * strfree
 *
 * Reserve a spot in memory for the string to be stored. Copy the string
 * to it and return the result.
 **********************************************************************/

#define strfree(s)  (free_string(s))

/**********************************************************************
 * strsave
 *
 * Reserve a spot in memory for the string to be stored. Copy the string
 * to it and return the result.
 **********************************************************************/

#define strsave(s)    \
  ((s) != NULL ?  \
   ((char*) strcpy (alloc_string(strlen(s)+1), s))  :  \
   (NULL))

/*----------------------------------------------------------------------
                     F u n c t i o n s
----------------------------------------------------------------------*/
long long_rand(long limit);

FILE *open_file(const char *filename, const char *mode);

bool exists_file(const char *filename);
//////////////////////////////////////////////////////////////cutil//////////////////////////////////

/////////////////////////////////////////////////////////////////callback/////////////////////////////////
struct CallbackUtils_ {
  static void FailIsRepeatable(const char* name);
};


class Closure {
 public:
  virtual ~Closure() { }
  virtual void Run() = 0;
};

template <class R>
class ResultCallback {
 public:
  virtual ~ResultCallback() { }
  virtual R Run() = 0;
};

template <bool del, class R, class T>
class _ConstMemberResultCallback_0_0 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (T::*MemberSignature)() const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstMemberResultCallback_0_0(
     const T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual R Run() {
    if (!del) {
      R result = (object_->*member_)();
      return result;
    } else {
      R result = (object_->*member_)();
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
      return result;
    }
  }
};

template <bool del, class T>
class _ConstMemberResultCallback_0_0<del, void, T>
  : public Closure {
 public:
  typedef Closure base;
  typedef void (T::*MemberSignature)() const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstMemberResultCallback_0_0(
      const T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual void Run() {
    if (!del) {
      (object_->*member_)();
    } else {
      (object_->*member_)();
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
};

#ifndef SWIG
template <class T1, class T2, class R>
inline typename _ConstMemberResultCallback_0_0<true,R,T1>::base*
NewCallback(
    const T1* obj, R (T2::*member)() const) {
  return new _ConstMemberResultCallback_0_0<true,R,T1>(
      obj, member);
}
#endif

#ifndef SWIG
template <class T1, class T2, class R>
inline typename _ConstMemberResultCallback_0_0<false,R,T1>::base*
NewPermanentCallback(
    const T1* obj, R (T2::*member)() const) {
  return new _ConstMemberResultCallback_0_0<false,R,T1>(
      obj, member);
}
#endif

template <bool del, class R, class T>
class _MemberResultCallback_0_0 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (T::*MemberSignature)() ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _MemberResultCallback_0_0(
      T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual R Run() {
    if (!del) {
      R result = (object_->*member_)();
      return result;
    } else {
      R result = (object_->*member_)();
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
      return result;
    }
  }
};

template <bool del, class T>
class _MemberResultCallback_0_0<del, void, T>
  : public Closure {
 public:
  typedef Closure base;
  typedef void (T::*MemberSignature)() ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _MemberResultCallback_0_0(
       T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual void Run() {
    if (!del) {
      (object_->*member_)();
    } else {
      (object_->*member_)();
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
};

#ifndef SWIG
template <class T1, class T2, class R>
inline typename _MemberResultCallback_0_0<true,R,T1>::base*
NewCallback(
     T1* obj, R (T2::*member)() ) {
  return new _MemberResultCallback_0_0<true,R,T1>(
      obj, member);
}
#endif

#ifndef SWIG
template <class T1, class T2, class R>
inline typename _MemberResultCallback_0_0<false,R,T1>::base*
NewPermanentCallback(
     T1* obj, R (T2::*member)() ) {
  return new _MemberResultCallback_0_0<false,R,T1>(
      obj, member);
}
#endif

template <bool del, class R>
class _FunctionResultCallback_0_0 : public ResultCallback<R> {
 public:
  typedef ResultCallback<R> base;
  typedef R (*FunctionSignature)();

 private:
  FunctionSignature function_;

 public:
  inline _FunctionResultCallback_0_0(
      FunctionSignature function)
    : function_(function) {
  }

  virtual R Run() {
    if (!del) {
      R result = (*function_)();
      return result;
    } else {
      R result = (*function_)();
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
      return result;
    }
  }
};

template <bool del>
class _FunctionResultCallback_0_0<del, void>
  : public Closure {
 public:
  typedef Closure base;
  typedef void (*FunctionSignature)();

 private:
  FunctionSignature function_;

 public:
  inline _FunctionResultCallback_0_0(
      FunctionSignature function)
    : function_(function) {
  }

  virtual void Run() {
    if (!del) {
      (*function_)();
    } else {
      (*function_)();
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
};

template <class R>
inline typename _FunctionResultCallback_0_0<true,R>::base*
NewCallback(R (*function)()) {
  return new _FunctionResultCallback_0_0<true,R>(function);
}

template <class R>
inline typename _FunctionResultCallback_0_0<false,R>::base*
NewPermanentCallback(R (*function)()) {
  return new _FunctionResultCallback_0_0<false,R>(function);
}

template <class A1>
class Callback1 {
 public:
  virtual ~Callback1() { }
  virtual void Run(A1) = 0;
};

template <class R, class A1>
class ResultCallback1 {
 public:
  virtual ~ResultCallback1() { }
  virtual R Run(A1) = 0;
};

template <bool del, class R, class T, class A1>
class _ConstMemberResultCallback_0_1 : public ResultCallback1<R,A1> {
 public:
  typedef ResultCallback1<R,A1> base;
  typedef R (T::*MemberSignature)(A1) const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstMemberResultCallback_0_1(
     const T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (object_->*member_)(a1);
      return result;
    } else {
      R result = (object_->*member_)(a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class A1>
class _ConstMemberResultCallback_0_1<del, void, T, A1>
  : public Callback1<A1> {
 public:
  typedef Callback1<A1> base;
  typedef void (T::*MemberSignature)(A1) const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstMemberResultCallback_0_1(
      const T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual void Run(A1 a1) {
    if (!del) {
      (object_->*member_)(a1);
    } else {
      (object_->*member_)(a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
};

#ifndef SWIG
template <class T1, class T2, class R, class A1>
inline typename _ConstMemberResultCallback_0_1<true,R,T1,A1>::base*
NewCallback(
    const T1* obj, R (T2::*member)(A1) const) {
  return new _ConstMemberResultCallback_0_1<true,R,T1,A1>(
      obj, member);
}
#endif

#ifndef SWIG
template <class T1, class T2, class R, class A1>
inline typename _ConstMemberResultCallback_0_1<false,R,T1,A1>::base*
NewPermanentCallback(
    const T1* obj, R (T2::*member)(A1) const) {
  return new _ConstMemberResultCallback_0_1<false,R,T1,A1>(
      obj, member);
}
#endif

template <bool del, class R, class T, class A1>
class _MemberResultCallback_0_1 : public ResultCallback1<R,A1> {
 public:
  typedef ResultCallback1<R,A1> base;
  typedef R (T::*MemberSignature)(A1) ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _MemberResultCallback_0_1(
      T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (object_->*member_)(a1);
      return result;
    } else {
      R result = (object_->*member_)(a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class A1>
class _MemberResultCallback_0_1<del, void, T, A1>
  : public Callback1<A1> {
 public:
  typedef Callback1<A1> base;
  typedef void (T::*MemberSignature)(A1) ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _MemberResultCallback_0_1(
       T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual void Run(A1 a1) {
    if (!del) {
      (object_->*member_)(a1);
    } else {
      (object_->*member_)(a1);
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
};

#ifndef SWIG
template <class T1, class T2, class R, class A1>
inline typename _MemberResultCallback_0_1<true,R,T1,A1>::base*
NewCallback(
     T1* obj, R (T2::*member)(A1) ) {
  return new _MemberResultCallback_0_1<true,R,T1,A1>(
      obj, member);
}
#endif

#ifndef SWIG
template <class T1, class T2, class R, class A1>
inline typename _MemberResultCallback_0_1<false,R,T1,A1>::base*
NewPermanentCallback(
     T1* obj, R (T2::*member)(A1) ) {
  return new _MemberResultCallback_0_1<false,R,T1,A1>(
      obj, member);
}
#endif

template <bool del, class R, class A1>
class _FunctionResultCallback_0_1 : public ResultCallback1<R,A1> {
 public:
  typedef ResultCallback1<R,A1> base;
  typedef R (*FunctionSignature)(A1);

 private:
  FunctionSignature function_;

 public:
  inline _FunctionResultCallback_0_1(
      FunctionSignature function)
    : function_(function) {
  }

  virtual R Run(A1 a1) {
    if (!del) {
      R result = (*function_)(a1);
      return result;
    } else {
      R result = (*function_)(a1);
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
      return result;
    }
  }
};

template <bool del, class A1>
class _FunctionResultCallback_0_1<del, void, A1>
  : public Callback1<A1> {
 public:
  typedef Callback1<A1> base;
  typedef void (*FunctionSignature)(A1);

 private:
  FunctionSignature function_;

 public:
  inline _FunctionResultCallback_0_1(
      FunctionSignature function)
    : function_(function) {
  }

  virtual void Run(A1 a1) {
    if (!del) {
      (*function_)(a1);
    } else {
      (*function_)(a1);
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
};

template <class R, class A1>
inline typename _FunctionResultCallback_0_1<true,R,A1>::base*
NewCallback(R (*function)(A1)) {
  return new _FunctionResultCallback_0_1<true,R,A1>(function);
}

template <class R, class A1>
inline typename _FunctionResultCallback_0_1<false,R,A1>::base*
NewPermanentCallback(R (*function)(A1)) {
  return new _FunctionResultCallback_0_1<false,R,A1>(function);
}

template <class A1,class A2>
class Callback2 {
 public:
  virtual ~Callback2() { }
  virtual void Run(A1,A2) = 0;
};

template <class R, class A1,class A2>
class ResultCallback2 {
 public:
  virtual ~ResultCallback2() { }
  virtual R Run(A1,A2) = 0;
};

template <bool del, class R, class T, class A1, class A2>
class _ConstMemberResultCallback_0_2 : public ResultCallback2<R,A1,A2> {
 public:
  typedef ResultCallback2<R,A1,A2> base;
  typedef R (T::*MemberSignature)(A1,A2) const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstMemberResultCallback_0_2(
     const T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (object_->*member_)(a1,a2);
      return result;
    } else {
      R result = (object_->*member_)(a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class A1, class A2>
class _ConstMemberResultCallback_0_2<del, void, T, A1, A2>
  : public Callback2<A1,A2> {
 public:
  typedef Callback2<A1,A2> base;
  typedef void (T::*MemberSignature)(A1,A2) const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstMemberResultCallback_0_2(
      const T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (object_->*member_)(a1,a2);
    } else {
      (object_->*member_)(a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
};

#ifndef SWIG
template <class T1, class T2, class R, class A1, class A2>
inline typename _ConstMemberResultCallback_0_2<true,R,T1,A1,A2>::base*
NewCallback(
    const T1* obj, R (T2::*member)(A1,A2) const) {
  return new _ConstMemberResultCallback_0_2<true,R,T1,A1,A2>(
      obj, member);
}
#endif

#ifndef SWIG
template <class T1, class T2, class R, class A1, class A2>
inline typename _ConstMemberResultCallback_0_2<false,R,T1,A1,A2>::base*
NewPermanentCallback(
    const T1* obj, R (T2::*member)(A1,A2) const) {
  return new _ConstMemberResultCallback_0_2<false,R,T1,A1,A2>(
      obj, member);
}
#endif

template <bool del, class R, class T, class A1, class A2>
class _MemberResultCallback_0_2 : public ResultCallback2<R,A1,A2> {
 public:
  typedef ResultCallback2<R,A1,A2> base;
  typedef R (T::*MemberSignature)(A1,A2) ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _MemberResultCallback_0_2(
      T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (object_->*member_)(a1,a2);
      return result;
    } else {
      R result = (object_->*member_)(a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class A1, class A2>
class _MemberResultCallback_0_2<del, void, T, A1, A2>
  : public Callback2<A1,A2> {
 public:
  typedef Callback2<A1,A2> base;
  typedef void (T::*MemberSignature)(A1,A2) ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _MemberResultCallback_0_2(
       T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (object_->*member_)(a1,a2);
    } else {
      (object_->*member_)(a1,a2);
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
};

#ifndef SWIG
template <class T1, class T2, class R, class A1, class A2>
inline typename _MemberResultCallback_0_2<true,R,T1,A1,A2>::base*
NewCallback(
     T1* obj, R (T2::*member)(A1,A2) ) {
  return new _MemberResultCallback_0_2<true,R,T1,A1,A2>(
      obj, member);
}
#endif

#ifndef SWIG
template <class T1, class T2, class R, class A1, class A2>
inline typename _MemberResultCallback_0_2<false,R,T1,A1,A2>::base*
NewPermanentCallback(
     T1* obj, R (T2::*member)(A1,A2) ) {
  return new _MemberResultCallback_0_2<false,R,T1,A1,A2>(
      obj, member);
}
#endif

template <bool del, class R, class A1, class A2>
class _FunctionResultCallback_0_2 : public ResultCallback2<R,A1,A2> {
 public:
  typedef ResultCallback2<R,A1,A2> base;
  typedef R (*FunctionSignature)(A1,A2);

 private:
  FunctionSignature function_;

 public:
  inline _FunctionResultCallback_0_2(
      FunctionSignature function)
    : function_(function) {
  }

  virtual R Run(A1 a1,A2 a2) {
    if (!del) {
      R result = (*function_)(a1,a2);
      return result;
    } else {
      R result = (*function_)(a1,a2);
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
      return result;
    }
  }
};

template <bool del, class A1, class A2>
class _FunctionResultCallback_0_2<del, void, A1, A2>
  : public Callback2<A1,A2> {
 public:
  typedef Callback2<A1,A2> base;
  typedef void (*FunctionSignature)(A1,A2);

 private:
  FunctionSignature function_;

 public:
  inline _FunctionResultCallback_0_2(
      FunctionSignature function)
    : function_(function) {
  }

  virtual void Run(A1 a1,A2 a2) {
    if (!del) {
      (*function_)(a1,a2);
    } else {
      (*function_)(a1,a2);
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
};

template <class R, class A1, class A2>
inline typename _FunctionResultCallback_0_2<true,R,A1,A2>::base*
NewCallback(R (*function)(A1,A2)) {
  return new _FunctionResultCallback_0_2<true,R,A1,A2>(function);
}

template <class R, class A1, class A2>
inline typename _FunctionResultCallback_0_2<false,R,A1,A2>::base*
NewPermanentCallback(R (*function)(A1,A2)) {
  return new _FunctionResultCallback_0_2<false,R,A1,A2>(function);
}

template <class A1,class A2,class A3>
class Callback3 {
 public:
  virtual ~Callback3() { }
  virtual void Run(A1,A2,A3) = 0;
};

template <class R, class A1,class A2,class A3>
class ResultCallback3 {
 public:
  virtual ~ResultCallback3() { }
  virtual R Run(A1,A2,A3) = 0;
};

template <bool del, class R, class T, class A1, class A2, class A3>
class _ConstMemberResultCallback_0_3 : public ResultCallback3<R,A1,A2,A3> {
 public:
  typedef ResultCallback3<R,A1,A2,A3> base;
  typedef R (T::*MemberSignature)(A1,A2,A3) const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstMemberResultCallback_0_3(
     const T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (object_->*member_)(a1,a2,a3);
      return result;
    } else {
      R result = (object_->*member_)(a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class A1, class A2, class A3>
class _ConstMemberResultCallback_0_3<del, void, T, A1, A2, A3>
  : public Callback3<A1,A2,A3> {
 public:
  typedef Callback3<A1,A2,A3> base;
  typedef void (T::*MemberSignature)(A1,A2,A3) const;

 private:
  const T* object_;
  MemberSignature member_;

 public:
  inline _ConstMemberResultCallback_0_3(
      const T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (object_->*member_)(a1,a2,a3);
    } else {
      (object_->*member_)(a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
};

#ifndef SWIG
template <class T1, class T2, class R, class A1, class A2, class A3>
inline typename _ConstMemberResultCallback_0_3<true,R,T1,A1,A2,A3>::base*
NewCallback(
    const T1* obj, R (T2::*member)(A1,A2,A3) const) {
  return new _ConstMemberResultCallback_0_3<true,R,T1,A1,A2,A3>(
      obj, member);
}
#endif

#ifndef SWIG
template <class T1, class T2, class R, class A1, class A2, class A3>
inline typename _ConstMemberResultCallback_0_3<false,R,T1,A1,A2,A3>::base*
NewPermanentCallback(
    const T1* obj, R (T2::*member)(A1,A2,A3) const) {
  return new _ConstMemberResultCallback_0_3<false,R,T1,A1,A2,A3>(
      obj, member);
}
#endif

template <bool del, class R, class T, class A1, class A2, class A3>
class _MemberResultCallback_0_3 : public ResultCallback3<R,A1,A2,A3> {
 public:
  typedef ResultCallback3<R,A1,A2,A3> base;
  typedef R (T::*MemberSignature)(A1,A2,A3) ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _MemberResultCallback_0_3(
      T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (object_->*member_)(a1,a2,a3);
      return result;
    } else {
      R result = (object_->*member_)(a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
      return result;
    }
  }
};

template <bool del, class T, class A1, class A2, class A3>
class _MemberResultCallback_0_3<del, void, T, A1, A2, A3>
  : public Callback3<A1,A2,A3> {
 public:
  typedef Callback3<A1,A2,A3> base;
  typedef void (T::*MemberSignature)(A1,A2,A3) ;

 private:
   T* object_;
  MemberSignature member_;

 public:
  inline _MemberResultCallback_0_3(
       T* object, MemberSignature member)
    : object_(object),
      member_(member) {
  }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (object_->*member_)(a1,a2,a3);
    } else {
      (object_->*member_)(a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      member_ = NULL;
      delete this;
    }
  }
};

#ifndef SWIG
template <class T1, class T2, class R, class A1, class A2, class A3>
inline typename _MemberResultCallback_0_3<true,R,T1,A1,A2,A3>::base*
NewCallback(
     T1* obj, R (T2::*member)(A1,A2,A3) ) {
  return new _MemberResultCallback_0_3<true,R,T1,A1,A2,A3>(
      obj, member);
}
#endif

#ifndef SWIG
template <class T1, class T2, class R, class A1, class A2, class A3>
inline typename _MemberResultCallback_0_3<false,R,T1,A1,A2,A3>::base*
NewPermanentCallback(
     T1* obj, R (T2::*member)(A1,A2,A3) ) {
  return new _MemberResultCallback_0_3<false,R,T1,A1,A2,A3>(
      obj, member);
}
#endif

template <bool del, class R, class A1, class A2, class A3>
class _FunctionResultCallback_0_3 : public ResultCallback3<R,A1,A2,A3> {
 public:
  typedef ResultCallback3<R,A1,A2,A3> base;
  typedef R (*FunctionSignature)(A1,A2,A3);

 private:
  FunctionSignature function_;

 public:
  inline _FunctionResultCallback_0_3(
      FunctionSignature function)
    : function_(function) {
  }

  virtual R Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      R result = (*function_)(a1,a2,a3);
      return result;
    } else {
      R result = (*function_)(a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
      return result;
    }
  }
};

template <bool del, class A1, class A2, class A3>
class _FunctionResultCallback_0_3<del, void, A1, A2, A3>
  : public Callback3<A1,A2,A3> {
 public:
  typedef Callback3<A1,A2,A3> base;
  typedef void (*FunctionSignature)(A1,A2,A3);

 private:
  FunctionSignature function_;

 public:
  inline _FunctionResultCallback_0_3(
      FunctionSignature function)
    : function_(function) {
  }

  virtual void Run(A1 a1,A2 a2,A3 a3) {
    if (!del) {
      (*function_)(a1,a2,a3);
    } else {
      (*function_)(a1,a2,a3);
      //  zero out the pointer to ensure segfault if used again
      function_ = NULL;
      delete this;
    }
  }
};

template <class R, class A1, class A2, class A3>
inline typename _FunctionResultCallback_0_3<true,R,A1,A2,A3>::base*
NewCallback(R (*function)(A1,A2,A3)) {
  return new _FunctionResultCallback_0_3<true,R,A1,A2,A3>(function);
}

template <class R, class A1, class A2, class A3>
inline typename _FunctionResultCallback_0_3<false,R,A1,A2,A3>::base*
NewPermanentCallback(R (*function)(A1,A2,A3)) {
  return new _FunctionResultCallback_0_3<false,R,A1,A2,A3>(function);
}
/////////////////////////////////////////////////////////////////callback/////////////////////////////////

/////////////////////////////////////////////////////////////////helpers/////////////////////////////////
// Remove newline (if any) at the end of the string.
inline void chomp_string(char *str) {
  int last_index = strlen(str) - 1;
  if (str[last_index] == '\n') {
    str[last_index] = '\0';
  }
}

// Advance the current pointer of the file if it points to a newline character.
inline void SkipNewline(FILE *file) {
  if (fgetc(file) != '\n') fseek(file, -1, SEEK_CUR);
}

// qsort function to sort 2 floats.
inline int sort_floats(const void *arg1, const void *arg2) {
  float diff = *((float *) arg1) - *((float *) arg2);
  if (diff > 0) {
    return 1;
  } else if (diff < 0) {
    return -1;
  } else {
    return 0;
  }
}

// return the smallest multiple of block_size greater than or equal to n.
inline int RoundUp(int n, int block_size) {
  return block_size * ((n + block_size - 1) / block_size);
}

// Clip a numeric value to the interval [lower_bound, upper_bound].
template<typename T>
inline T ClipToRange(const T& x, const T& lower_bound, const T& upper_bound) {
  if (x < lower_bound)
    return lower_bound;
  if (x > upper_bound)
    return upper_bound;
  return x;
}

// Extend the range [lower_bound, upper_bound] to include x.
template<typename T1, typename T2>
inline void UpdateRange(const T1& x, T2* lower_bound, T2* upper_bound) {
  if (x < *lower_bound)
    *lower_bound = x;
  if (x > *upper_bound)
    *upper_bound = x;
}

// Decrease lower_bound to be <= x_lo AND increase upper_bound to be >= x_hi.
template<typename T1, typename T2>
inline void UpdateRange(const T1& x_lo, const T1& x_hi,
                        T2* lower_bound, T2* upper_bound) {
  if (x_lo < *lower_bound)
    *lower_bound = x_lo;
  if (x_hi > *upper_bound)
    *upper_bound = x_hi;
}

// Proper modulo arithmetic operator. Returns a mod b that works for -ve a.
// For any integer a and positive b, returns r : 0<=r<b and a=n*b + r for
// some integer n.
inline int Modulo(int a, int b) {
  return (a % b + b) % b;
}

// Integer division operator with rounding that works for negative input.
// Returns a divided by b, rounded to the nearest integer, without double
// counting at 0. With simple rounding 1/3 = 0, 0/3 = 0 -1/3 = 0, -2/3 = 0,
// -3/3 = 0 and -4/3 = -1.
// I want 1/3 = 0, 0/3 = 0, -1/3 = 0, -2/3 = -1, -3/3 = -1 and -4/3 = -1.
// Results with b negative are not defined.
inline int DivRounded(int a, int b) {
  return a >= 0 ? (a + b / 2) / b : (a - b / 2) / b;
}

// Reverse the order of bytes in a n byte quantity for big/little-endian switch.
inline void ReverseN(void* ptr, int num_bytes) {
  char *cptr = reinterpret_cast<char *>(ptr);
  int halfsize = num_bytes / 2;
  for (int i = 0; i < halfsize; ++i) {
    char tmp = cptr[i];
    cptr[i] = cptr[num_bytes - 1 - i];
    cptr[num_bytes - 1 - i] = tmp;
  }
}

// Reverse the order of bytes in a 16 bit quantity for big/little-endian switch.
inline void Reverse16(void *ptr) {
  ReverseN(ptr, 2);
}

// Reverse the order of bytes in a 32 bit quantity for big/little-endian switch.
inline void Reverse32(void *ptr) {
  ReverseN(ptr, 4);
}

// Reverse the order of bytes in a 64 bit quantity for big/little-endian switch.
inline void Reverse64(void* ptr) {
  ReverseN(ptr, 8);
}
/////////////////////////////////////////////////////////////////helpers/////////////////////////////////

//////////////////////////////////////////////////////////////errcode////////////////////////////
/*Control parameters for error()*/
#define DBG         -1           /*log without alert */
#define TESSLOG         0            /*alert user */
#define EXIT        1            /*exit after erro */
#define ABORT       2            /*abort after error */

/* Explicit Error Abort codes */
#define NO_ABORT_CODE      0
#define LIST_ABORT      1
#define MEMORY_ABORT    2
#define FILE_ABORT      3

/* Location of code at error codes Reserve 0..2 (status codes 0..23 for UNLV)*/
#define LOC_UNUSED0        0
#define LOC_UNUSED1        1
#define LOC_UNUSED2        2
#define LOC_INIT      3
#define LOC_EDGE_PROG   4
#define LOC_TEXT_ORD_ROWS 5
#define LOC_TEXT_ORD_WORDS  6
#define LOC_PASS1     7
#define LOC_PASS2     8
/* Reserve up to 8..13 for adding subloc 0/3 plus subsubloc 0/1/2 */
#define LOC_FUZZY_SPACE   14
/* Reserve up to 14..20 for adding subloc 0/3 plus subsubloc 0/1/2 */
#define LOC_MM_ADAPT    21
#define LOC_DOC_BLK_REJ   22
#define LOC_WRITE_RESULTS 23
#define LOC_ADAPTIVE    24
/* DONT DEFINE ANY LOCATION > 31 !!! */

/* Sub locatation determines whether pass2 was in normal mode or fix xht mode*/
#define SUBLOC_NORM     0
#define SUBLOC_FIX_XHT    3

/* Sub Sub locatation determines whether match_word_pass2 was in Tess
  matcher, NN matcher or somewhere else */

#define SUBSUBLOC_OTHER   0
#define SUBSUBLOC_TESS    1
#define SUBSUBLOC_NN    2

class ERRCODE             //error handler class
{
  const char *message;           //error message
  public:
    void error (                 //error print function
      const char *caller,        //function location
      inT8 action,               //action to take
      const char *format, ...    //fprintf format
      ) const;
    ERRCODE(const char *string)
    {
      message = string;
    }                            //initialize with string
};

const ERRCODE ASSERT_FAILED = "Assert failed";

#define ASSERT_HOST(x) if (!(x))										\
{																			\
    ASSERT_FAILED.error(#x,ABORT,"in file %s, line %d",		\
        __FILE__,__LINE__);											\
}

void signal_exit(                 //
                 int signal_code  //Signal which
                );
//extern "C"
//{
//  void err_exit();
//                                 //The real signal
//  void signal_termination_handler(int sig);
//}

void set_global_loc_code(int loc_code);

void set_global_subloc_code(int loc_code);

void set_global_subsubloc_code(int loc_code);
//////////////////////////////////////////////////////////////errcode////////////////////////////////////////

/////////////////////////////////////////////////////////////////genericvector/////////////////////////////////
template <typename T>
class GenericVector {
 public:
  GenericVector() { this->init(kDefaultVectorSize); }
  GenericVector(int size) { this->init(size); }

  // Copy
  GenericVector(const GenericVector& other) {
    this->init(other.size());
    this->operator+=(other);
  }
  GenericVector<T> &operator+=(const GenericVector& other);
  GenericVector<T> &operator=(const GenericVector& other);

  virtual ~GenericVector();

  // Reserve some memory.
  void reserve(int size);
  // Double the size of the internal array.
  void double_the_size();

  // Return the size used.
  int size() const {
    return size_used_;
  }

  int length() const {
    return size_used_;
  }

  // Return true if empty.
  bool empty() const {
    return size_used_ == 0;
  }

  // Return the object from an index.
  T &get(int index) const;
  T &operator[](int index) const;

  // Return the index of the T object.
  // This method NEEDS a compare_callback to be passed to
  // set_compare_callback.
  int get_index(T object) const;

  // Return true if T is in the array
  bool contains(T object) const;

  // Return true if the index is valid
  T contains_index(int index) const;

  // Push an element in the end of the array
  int push_back(T object);
  void operator+=(T t);

  // Set the value at the given index
  void set(T t, int index);

  // Insert t at the given index, push other elements to the right.
  void insert(T t, int index);

  // Removes an element at the given index and
  // shifts the remaining elements to the left.
  void remove(int index);

  // Add a callback to be called to delete the elements when the array took
  // their ownership.
  void set_clear_callback(Callback1<T>* cb);

  // Add a callback to be called to compare the elements when needed (contains,
  // get_id, ...)
  void set_compare_callback(ResultCallback2<bool, T const &, T const &>* cb);

  // Clear the array, calling the clear callback function if any.
  // All the owned Callbacks are also deleted.
  // If you don't want the Callbacks to be deleted, before calling clear, set
  // the callback to NULL.
  virtual void clear();

  // Delete objects pointed to by data_[i]
  void delete_data_pointers();

  // This method clears the current object, then, does a shallow copy of
  // its argument, and finally invalidate its argument.
  // Callbacks are moved to the current object;
  void move(GenericVector<T>* from);

  // Read/Write the array to a file. This does _NOT_ read/write the callbacks.
  // The Callback given must be permanent since they will be called more than
  // once. The given callback will be deleted at the end.
  // If the callbacks are NULL, then the data is simply read/written using
  // fread (and swapping)/fwrite.
  // Returns false on error or if the callback returns false.
  bool write(FILE* f, ResultCallback2<bool, FILE*, T const &>* cb) const;
  bool read(FILE* f, ResultCallback3<bool, FILE*, T*, bool>* cb, bool swap);

  // Allocates a new array of double the current_size, copies over the
  // information from data to the new location, deletes data and returns
  // the pointed to the new larger array.
  // This function uses memcpy to copy the data, instead of invoking
  // operator=() for each element like double_the_size() does.
  static T *double_the_size_memcpy(int current_size, T *data) {
    T *data_new = new T[current_size * 2];
    memcpy(data_new, data, sizeof(T) * current_size);
    delete[] data;
    return data_new;
  }

 protected:

  // Init the object, allocating size memory.
  void init(int size);

  // We are assuming that the object generally placed in thie
  // vector are small enough that for efficiency it makes sence
  // to start with a larger initial size.
  static const int kDefaultVectorSize = 4;
  inT32   size_used_;
  inT32   size_reserved_;
  T*    data_;
  Callback1<T>* clear_cb_;
  // Mutable because Run method is not const
  mutable ResultCallback2<bool, T const &, T const &>* compare_cb_;
};


template <typename T>
bool cmp_eq(T const & t1, T const & t2) {
  return t1 == t2;
}

// A useful vector that uses operator== to do comparisons.
template <typename T>
class GenericVectorEqEq : public GenericVector<T> {
 public:
  GenericVectorEqEq() {
    GenericVector<T>::set_compare_callback(
        NewPermanentCallback(cmp_eq<T>));
  }
  GenericVectorEqEq(int size) : GenericVector<T>(size) {
    GenericVector<T>::set_compare_callback(
        NewPermanentCallback(cmp_eq<T>));
  }
};

template <typename T>
void GenericVector<T>::init(int size) {
  size_used_ = 0;
  size_reserved_ = 0;
  data_ = 0;
  clear_cb_ = 0;
  compare_cb_ = 0;
  reserve(size);
}

template <typename T>
GenericVector<T>::~GenericVector() {
  clear();
}

// Reserve some memory. If the internal array contains elements, they are
// copied.
template <typename T>
void GenericVector<T>::reserve(int size) {
  if (size_reserved_ > size || size <= 0)
    return;
  T* new_array = new T[size];
  for (int i = 0; i < size_used_; ++i)
    new_array[i] = data_[i];
  if (data_ != NULL) delete[] data_;
  data_ = new_array;
  size_reserved_ = size;
}

template <typename T>
void GenericVector<T>::double_the_size() {
  if (size_reserved_ == 0) {
    reserve(kDefaultVectorSize);
  }
  else {
    reserve(2 * size_reserved_);
  }
}



// Return the object from an index.
template <typename T>
T &GenericVector<T>::get(int index) const {
  ASSERT_HOST(index >= 0 && index < size_used_);
  return data_[index];
}

template <typename T>
T &GenericVector<T>::operator[](int index) const {
 return data_[index];
}

// Return the object from an index.
template <typename T>
void GenericVector<T>::set(T t, int index) {
  ASSERT_HOST(index >= 0 && index < size_used_);
  data_[index] = t;
}

// Shifts the rest of the elements to the right to make
// space for the new elements and inserts the given element
// at the specified index.
template <typename T>
void GenericVector<T>::insert(T t, int index) {
  ASSERT_HOST(index >= 0 && index < size_used_);
  if (size_reserved_ == size_used_)
    double_the_size();
  for (int i = size_used_; i > index; --i) {
    data_[i] = data_[i-1];
  }
  data_[index] = t;
  size_used_++;
}

// Removes an element at the given index and
// shifts the remaining elements to the left.
template <typename T>
void GenericVector<T>::remove(int index) {
  ASSERT_HOST(index >= 0 && index < size_used_);
  for (int i = index; i < size_used_ - 1; ++i) {
    data_[i] = data_[i+1];
  }
  size_used_--;
}

// Return true if the index is valindex
template <typename T>
T GenericVector<T>::contains_index(int index) const {
  return index >= 0 && index < size_used_;
}

// Return the index of the T object.
template <typename T>
int GenericVector<T>::get_index(T object) const {
  for (int i = 0; i < size_used_; ++i) {
    ASSERT_HOST(compare_cb_ != NULL);
    if (compare_cb_->Run(object, data_[i]))
      return i;
  }
  return -1;
}

// Return true if T is in the array
template <typename T>
bool GenericVector<T>::contains(T object) const {
  return get_index(object) != -1;
}

// Add an element in the array
template <typename T>
int GenericVector<T>::push_back(T object) {
  int index = 0;
  if (size_used_ == size_reserved_)
    double_the_size();
  index = size_used_++;
  data_[index] = object;
  return index;
}

template <typename T>
void GenericVector<T>::operator+=(T t) {
  push_back(t);
}

template <typename T>
GenericVector<T> &GenericVector<T>::operator+=(const GenericVector& other) {
  for (int i = 0; i < other.size(); ++i) {
    this->operator+=(other.data_[i]);
  }
  return *this;
}

template <typename T>
GenericVector<T> &GenericVector<T>::operator=(const GenericVector& other) {
  this->clear();
  this->operator+=(other);
  return *this;
}

// Add a callback to be called to delete the elements when the array took
// their ownership.
template <typename T>
void GenericVector<T>::set_clear_callback(Callback1<T>* cb) {
  clear_cb_ = cb;
}

// Add a callback to be called to delete the elements when the array took
// their ownership.
template <typename T>
void GenericVector<T>::set_compare_callback(ResultCallback2<bool, T const &, T const &>* cb) {
  compare_cb_ = cb;
}

// Clear the array, calling the callback function if any.
template <typename T>
void GenericVector<T>::clear() {
  if (size_reserved_ > 0) {
    if (clear_cb_ != NULL)
      for (int i = 0; i < size_used_; ++i)
        clear_cb_->Run(data_[i]);
    delete[] data_;
    data_ = NULL;
    size_used_ = 0;
    size_reserved_ = 0;
  }
  if (clear_cb_ != NULL) {
    delete clear_cb_;
    clear_cb_ = NULL;
  }
  if (compare_cb_ != NULL) {
    delete compare_cb_;
    compare_cb_ = NULL;
  }
}

template <typename T>
void GenericVector<T>::delete_data_pointers() {
  for (int i = 0; i < size_used_; ++i)
    if (data_[i]) {
      delete data_[i];
    }
}


template <typename T>
bool GenericVector<T>::write(
    FILE* f, ResultCallback2<bool, FILE*, T const &>* cb) const {
  if (fwrite(&size_reserved_, sizeof(size_reserved_), 1, f) != 1) return false;
  if (fwrite(&size_used_, sizeof(size_used_), 1, f) != 1) return false;
  if (cb != NULL) {
    for (int i = 0; i < size_used_; ++i) {
      if (!cb->Run(f, data_[i])) {
        delete cb;
        return false;
      }
    }
    delete cb;
  } else {
    if (fwrite(data_, sizeof(T), size_used_, f) != (size_t)size_used_) return false;
  }
  return true;
}

template <typename T>
bool GenericVector<T>::read(FILE* f,
                            ResultCallback3<bool, FILE*, T*, bool>* cb,
                            bool swap) {
  uinT32 reserved;
  if (fread(&reserved, sizeof(reserved), 1, f) != 1) return false;
  if (swap) Reverse32(&reserved);
  reserve(reserved);
  if (fread(&size_used_, sizeof(size_used_), 1, f) != 1) return false;
  if (swap) Reverse32(&size_used_);
  if (cb != NULL) {
    for (int i = 0; i < size_used_; ++i) {
      if (!cb->Run(f, data_ + i, swap)) {
        delete cb;
        return false;
      }
    }
    delete cb;
  } else {
    if (fread(data_, sizeof(T), size_used_, f) != (size_t)size_used_) return false;
    if (swap) {
      for (int i = 0; i < size_used_; ++i)
        ReverseN(&data_[i], sizeof(T));
    }
  }
  return true;
}

// This method clear the current object, then, does a shallow copy of
// its argument, and finally invalindate its argument.
template <typename T>
void GenericVector<T>::move(GenericVector<T>* from) {
  this->clear();
  this->data_ = from->data_;
  this->size_reserved_ = from->size_reserved_;
  this->size_used_ = from->size_used_;
  this->compare_cb_ = from->compare_cb_;
  this->clear_cb_ = from->clear_cb_;
  from->data_ = NULL;
  from->clear_cb_ = NULL;
  from->compare_cb_ = NULL;
  from->size_used_ = 0;
  from->size_reserved_ = 0;
}
/////////////////////////////////////////////////////////////////genericvector/////////////////////////////////

/////////////////////////////////////////////////////////////////unicity_table/////////////////////////////////
template <typename T>
class UnicityTable {
 public:
  UnicityTable();
  /// Clear the structures and deallocate internal structures.
  ~UnicityTable();

  /// Reserve some memory. If there is size or more elements, the table will
  /// then allocate size * 2 elements.
  void reserve(int size);

  /// Return the size used.
  int size() const;

  /// Return the object from an id.
  T get(int id) const;

  /// Return the id of the T object.
  /// This method NEEDS a compare_callback to be passed to
  /// set_compare_callback.
  int get_id(T object) const;

  /// Return true if T is in the table
  bool contains(T object) const;

  /// Return true if the id is valid
  T contains_id(int id) const;

  /// Add an element in the table
  int push_back(T object);

  /// Add a callback to be called to delete the elements when the table took
  /// their ownership.
  void set_clear_callback(Callback1<T>* cb);

  /// Add a callback to be called to compare the elements when needed (contains,
  /// get_id, ...)
  void set_compare_callback(ResultCallback2<bool, T const &, T const &>* cb);

  /// Clear the table, calling the callback function if any.
  /// All the owned Callbacks are also deleted.
  /// If you don't want the Callbacks to be deleted, before calling clear, set
  /// the callback to NULL.
  void clear();

  /// This method clear the current object, then, does a shallow copy of
  /// its argument, and finally invalidate its argument.
  void move(UnicityTable<T>* from);

  /// Read/Write the table to a file. This does _NOT_ read/write the callbacks.
  /// The Callback given must be permanent since they will be called more than
  /// once. The given callback will be deleted at the end.
  /// Returns false on read/write error.
  bool write(FILE* f, ResultCallback2<bool, FILE*, T const &>* cb);
  /// swap is used to switch the endianness.
  bool read(FILE* f, ResultCallback3<bool, FILE*, T*, bool>* cb, bool swap);

 private:
  GenericVector<T> table_;
  // Mutable because Run method is not const
  mutable ResultCallback2<bool, T const &, T const &>* compare_cb_;
};

template <typename T>
class UnicityTableEqEq : public UnicityTable<T> {
 public:
  UnicityTableEqEq() {
    UnicityTable<T>::set_compare_callback(
        NewPermanentCallback(cmp_eq<T>));
  }
};

template <typename T>
UnicityTable<T>::UnicityTable() :
  compare_cb_(0) {
}


template <typename T>
UnicityTable<T>::~UnicityTable() {
  clear();
}

template <typename T>
int UnicityTable<T>::size() const{
  return table_.size();
}

// Reserve some memory. If there is size or more elements, the table will
// then allocate size * 2 elements.
template <typename T>
void UnicityTable<T>::reserve(int size) {
  table_.reserve(size);
}

// Return the object from an id.
template <typename T>
T UnicityTable<T>::get(int id) const {
  return table_.get(id);
}

// Return true if the id is valid
template <typename T>
T UnicityTable<T>::contains_id(int id) const {
  return table_.contains_index(id);
}

// Return the id of the T object.
template <typename T>
int UnicityTable<T>::get_id(T object) const {
  return table_.get_index(object);
}

// Return true if T is in the table
template <typename T>
bool UnicityTable<T>::contains(T object) const {
  return get_id(object) != -1;
}

// Add an element in the table
template <typename T>
int UnicityTable<T>::push_back(T object) {
  int idx = get_id(object);
  if (idx == -1) {
    idx = table_.push_back(object);
  }
  return idx;
}

// Add a callback to be called to delete the elements when the table took
// their ownership.
template <typename T>
void UnicityTable<T>::set_clear_callback(Callback1<T>* cb) {
  table_.set_clear_callback(cb);
}

// Add a callback to be called to delete the elements when the table took
// their ownership.
template <typename T>
void UnicityTable<T>::set_compare_callback(ResultCallback2<bool, T const &, T const &>* cb) {
  table_.set_compare_callback(cb);
  compare_cb_ = cb;
}

// Clear the table, calling the callback function if any.
template <typename T>
void UnicityTable<T>::clear() {
  table_.clear();
}

template <typename T>
bool UnicityTable<T>::write(FILE* f,
                            ResultCallback2<bool, FILE*, T const &>* cb) {
  return table_.write(f, cb);
}

template <typename T>
bool UnicityTable<T>::read(
    FILE* f, ResultCallback3<bool, FILE*, T*, bool>* cb, bool swap) {
  return table_.read(f, cb, swap);
}

// This method clear the current object, then, does a shallow copy of
// its argument, and finally invalidate its argument.
template <typename T>
void UnicityTable<T>::move(UnicityTable<T>* from) {
  table_.move(&from->table_);
}
/////////////////////////////////////////////////////////////////unicity_table/////////////////////////////////


//////////////////////////////////////////////////////////////oldlist//////////////////////////////////
/*----------------------------------------------------------------------
                  T y p e s
----------------------------------------------------------------------*/
#define NIL  (LIST) 0
struct list_rec
{
  struct list_rec *node;
  struct list_rec *next;
};
typedef list_rec *LIST;

/*----------------------------------------------------------------------
                  M a c r o s
----------------------------------------------------------------------*/
/* Predefinitions */
#define rest(l)  ((l) ? (l)->next : NIL)
#define first_node(l) ((l) ? (l)->node : NIL)

/**********************************************************************
 *  c o p y   f i r s t
 *
 *  Do the appropriate kind a push operation to copy the first node from
 *  one list to another.
 *
 **********************************************************************/

#define copy_first(l1,l2)  \
(l2=push(l2, first_node(l1)))

/**********************************************************************
 *  i t e r a t e
 *
 *  Visit each node in the list.  Replace the old list with the list
 *  minus the head.  Continue until the list is NIL.
 **********************************************************************/

#define iterate(l)             \
for (; (l) != NIL; (l) = rest (l))

/**********************************************************************
 *  i t e r a t e   l i s t
 *
 *  Visit each node in the list (l).  Use a local variable (x) to iterate
 *  through all of the list cells.  This macro is identical to iterate
 *  except that it does not lose the original list.
 **********************************************************************/

#define iterate_list(x,l)  \
for ((x)=(l); (x)!=0; (x)=rest(x))

/**********************************************************************
 * j o i n   o n
 *
 * Add another list onto the tail of this one.  The list given as an input
 * parameter is modified.
 **********************************************************************/

#define JOIN_ON(list1,list2)    \
((list1) = join ((list1), (list2)))

/**********************************************************************
 * p o p   o f f
 *
 * Add a cell onto the front of a list.  The list given as an input
 * parameter is modified.
 **********************************************************************/

#define pop_off(list)    \
((list) = pop (list))

/**********************************************************************
 * p u s h   o n
 *
 * Add a cell onto the front of a list.  The list given as an input
 * parameter is modified.
 **********************************************************************/

#define push_on(list,thing)    \
((list) = push (list, (LIST) (thing)))

/**********************************************************************
 *  s e c o n d
 *
 *  Return the contents of the second list element.
 *
 *  #define second_node(l)    first_node (rest (l))
 **********************************************************************/

#define second_node(l)              \
first_node (rest (l))

/**********************************************************************
 *  s e t   r e s t
 *
 *  Change the "next" field of a list element to point to a desired place.
 *
 *  #define set_rest(l,node)        l->next = node;
 **********************************************************************/

#define set_rest(l,cell)\
((l)->next = (cell))

/**********************************************************************
 *  t h i r d
 *
 *  Return the contents of the third list element.
 *
 *  #define third(l)     first_node (rest (rest (l)))
 **********************************************************************/

#define third(l)               \
first_node (rest (rest (l)))

/*----------------------------------------------------------------------
          Public Funtion Prototypes
----------------------------------------------------------------------*/
int count(LIST var_list);

LIST delete_d(LIST list, void *key, int_compare is_equal);

LIST delete_d(LIST list, void *key,
              ResultCallback2<int, void*, void*>* is_equal);

LIST destroy(LIST list);

void destroy_nodes(LIST list, void_dest destructor);

void insert(LIST list, void *node);

int is_same_node(void *item1, void *item2);

int is_same(void *item1, void *item2);

LIST join(LIST list1, LIST list2);

LIST last(LIST var_list);

void *nth_cell(LIST var_list, int item_num);

LIST pop(LIST list);

LIST push(LIST list, void *element);

LIST push_last(LIST list, void *item);

LIST reverse(LIST list);

LIST reverse_d(LIST list);

LIST s_adjoin(LIST var_list, void *variable, int_compare compare);

LIST search(LIST list, void *key, int_compare is_equal);

LIST search(LIST list, void *key, ResultCallback2<int, void*, void*>*);
//////////////////////////////////////////////////////////////oldlist//////////////////////////////////

//////////////////////////////////////////////////////////////tessclas////////////////////////////
#define SPLINESIZE      23       /*max spline parts to a line */

#define TBLOBFLAGS      4        /*No of flags in a blob */
#define MAX_WO_CLASSES    3
#define EDGEPTFLAGS     4        /*concavity,length etc. */

typedef struct
{
  double a;                      /*x squared */
  double b;                      /*x */
  double c;                      /*constant */
} QUAD_SPEC;                     /*definiton of quadratic */

typedef struct
{
  int segments;                  /*no of spline segments */
  int xstarts[SPLINESIZE];       /*start x coords */
  QUAD_SPEC quads[SPLINESIZE];   /*quadratic sections */
} SPLINE_SPEC;                   /*quadratic spline */

typedef struct
{
  short x;                       /*absolute x coord */
  short y;                       /*absolute y coord */
} TPOINT;
typedef TPOINT VECTOR;           /*structure for coordinates */

typedef struct
{
  char dx;                       /*compact vectors */
  char dy;
} BYTEVEC;

typedef struct edgeptstruct
{
  TPOINT pos;                    /*position */
  VECTOR vec;                    /*vector to next point */
  char flags[EDGEPTFLAGS];       /*concavity, length etc */
  struct edgeptstruct *next;     /*anticlockwise element */
  struct edgeptstruct *prev;     /*clockwise element */
} EDGEPT;                        /*point on expanded outline */

typedef struct blobstruct
{
  struct olinestruct *outlines;  /*list of outlines in blob */
  char flags[TBLOBFLAGS];        /*blob flags */
  char correct;                  /*correct text */
  char guess;                    /*best guess */
                                 /*quickie classification */
  unsigned char classes[MAX_WO_CLASSES];
                                 /*quickie ratings */
  unsigned char values[MAX_WO_CLASSES];
  struct blobstruct *next;       /*next blob in block */
} TBLOB;                         /*blob structure */

typedef struct olinestruct
{
  TPOINT topleft;                /*top left of loop */
  TPOINT botright;               /*bottom right of loop */
  TPOINT start;                  /*start of loop */
  BYTEVEC *compactloop;          /*ptr to compacted loop */
  EDGEPT *loop;                  /*edgeloop */
  void *node;                    /*1st node on outline */
  struct olinestruct *next;      /*next at this level */
  struct olinestruct *child;     /*inner outline */
} TESSLINE;                      /*outline structure */

typedef struct wordstruct
{
  struct textrowstruct *row;     /*row it came from */
  char *correct;                 /*correct word string */
  char *guess;                   /*guess word string */
  TBLOB *blobs;                  /*blobs in word */
  int blanks;                    /*blanks before word */
  int blobcount;                 /*no of blobs in word */
  struct wordstruct *next;       /*next word */
} TWERD;                         /*word structure */

typedef struct textrowstruct
{
  int blobcount;                 /** count of blobs in row. **/
  TBLOB *blobs;                  /*list of blobs in row */
  TWERD *words;                  /*list of words in row */
  int mean_y;                    /** y coordinate of centre of row **/
  int max_y;                     /** y coordinate of top of row **/
  int min_y;                     /** y coordinate of bottom of row **/
  SPLINE_SPEC xheight;           /*top of row */
  SPLINE_SPEC baseline;          /*bottom of row */
  float descdrop;                /*descender drop */
  float ascrise;                 /*ascender rise */
  float lineheight;              /*average xheight-baseline */
  int kerning;                   /*kerning of row */
  int space;                     /*spacing of row */
  float space_threshold;         /*Bayesian space limit */
  int p_spaced;                  /*proportinal flag */
  int b_space;                   /*block spacing */
  int b_kern;                    /*block kerning */
  struct textrowstruct *next;    /*next row in block */
} TEXTROW;

typedef struct blockstruct       /** list of coordinates **/
{
  TBLOB *blobs;                  /*blobs in block */
  TEXTROW *rows;                 /*rows in block */
  int blobcount;                 /*no of blobs */
  short xmin;
  short xmax;
  short ymin;
  short ymax;
  char type;                     /** block type **/
  char p_spaced;                 /** flag to show propertianal spacing **/
  short rowcount;                /** number of rows **/
  short leading;                 /** space between rows **/
  short kerning;                 /** space between characters **/
  short space;                   /** distance between char centres **/
  short minwidth;                /*min width of char in block */
  short p_size;                  /** point size of text **/
  short l_margin;                /** posn of left margin **/
  short italic;                  /** flag to show italic block **/
  short spurious;                /** percentage of spurious characters **/
  struct blockstruct *next;      /*next text block */
} TEXTBLOCK;                     /*block from image */

/** define a data structure to hold line statistics.  These line statistics
  are used to normalize character outlines to a standard size and position
  relative to the baseline of the text. */
typedef struct
{
  SPLINE_SPEC *Baseline;         /**< collection of splines describing baseline */
  SPLINE_SPEC *XHeightLine;      /**< collection of splines describing x-height */
  FLOAT32 xheight;               /**< avg. distance from x-height to baseline */
  FLOAT32 AscRise;               /**< avg. distance from ascenders to x-height */
  FLOAT32 DescDrop;              /**< avg. distance from baseline to descenders */
  /* always a negative number */
  TEXTROW *TextRow;              /**< kludge - only needed by fx for fast matcher */
  /* should be removed later */
}LINE_STATS;

/**********************************************************************
 * iterate_blobs
 *
 * Visit all the words in a list using a local variable.
 **********************************************************************/

#define iterate_blobs(blob,blobs)  \
for (blob = blobs; blob != NULL; blob = blob->next)
//////////////////////////////////////////////////////////////tessclas////////////////////////////

//////////////////////////////////////////////////////////////structures//////////////////////////////////
#define NUM_DATA_TYPES 20

//extern int max_data_types;
//extern void_void memory_print_functions[NUM_DATA_TYPES];

/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
/**********************************************************************
 * makestructure
 *
 * Allocate a chunk of memory for a particular data type.  This macro
 * defines an allocation, deallocation, and status printing function
 * for each new data type.
 **********************************************************************/

#define makestructure(newfunc,old,print,type,nextfree,blocksize,typestring,usecount)                \
type *newfunc()                                                                  \
{                                                                            \
    return new type; \
}                                                                            \
                                                                                                    \
                                                                                                    \
                                                                                                    \
void old(type* deadelement)                                                       \
{                                                                            \
    delete deadelement; \
}                                                                            \


/**********************************************************************
 * newstructure
 *
 * Allocate a chunk of memory for a particular data type.
 **********************************************************************/

#define newstructure(name,type,nextfree,blocksize,errorstring,usecount)\
type *name()											/*returns a new type*/\
{\
    return new type;\
}

/**********************************************************************
 * oldstructure
 *
 * Returns a structure to the freelist
 **********************************************************************/

#define oldstructure(name,type,nextfree,stringtype,usecount)\
\
type *name(type* deadelement)\
{\
    type                    *returnelement;				/*return next ptr*/\
\
    returnelement=deadelement->next;					/*return link*/\
    delete deadelement;  \
    return returnelement;\
}

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
extern TBLOB *newblob();
extern TBLOB *oldblob(TBLOB *);

extern TESSLINE *newoutline();
extern void oldoutline(TESSLINE *);

extern EDGEPT *newedgept();
extern EDGEPT *oldedgept(EDGEPT *);

extern TWERD *newword();
extern void oldword(TWERD *);

extern LIST new_cell();
extern void free_cell(LIST);
//////////////////////////////////////////////////////////////structures//////////////////////////////////

//////////////////////////////////////////////////////////////oldlist//////////////////////////////////
/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
#define add_on(l,x)     l = push (l,first_node (x))
#define next_one(l)     l = rest (l)

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
/**********************************************************************
 *  c o u n t
 *
 *  Recursively count the elements in  a list.  Return the count.
 **********************************************************************/
int myCount(LIST var_list);

/**********************************************************************
 *  d e l e t e    d
 *
 *  Delete all the elements out of the current list that match the key.
 *  This operation destroys the original list.  The caller will supply a
 *  routine that will compare each node to the
 *  key, and return a non-zero value when they match.  If the value
 *  NULL is supplied for is_equal, the is_key routine will be used.
 **********************************************************************/
LIST delete_d(LIST list, void *key, int_compare is_equal);
LIST delete_d(LIST list, void *key, ResultCallback2<int, void*, void*>* is_equal);


/**********************************************************************
 *  d e s t r o y
 *
 *  Return the space taken by a list to the heap.
 **********************************************************************/
LIST destroy(LIST list);

/**********************************************************************
 *  d e s t r o y   n o d e s
 *
 *  Return the space taken by the LISTs of a list to the heap.
 **********************************************************************/
void destroy_nodes(LIST list, void_dest destructor);


/**********************************************************************
 *  i n s e r t
 *
 *  Create a list element and rearange the pointers so that the first
 *  element in the list is the second aurgment.
 **********************************************************************/
void insert(LIST list, void *node);


/**********************************************************************
 *  i s   s a m e   n o d e
 *
 *  Compare the list node with the key value return TRUE (non-zero)
 *  if they are equivalent strings.  (Return FALSE if not)
 **********************************************************************/
int is_same_node(void *item1, void *item2);


/**********************************************************************
 *  i s   s a m e
 *
 *  Compare the list node with the key value return TRUE (non-zero)
 *  if they are equivalent strings.  (Return FALSE if not)
 **********************************************************************/
int is_same(void *item1, void *item2);


/**********************************************************************
 *  j o i n
 *
 *  Join the two lists together. This function is similar to concat
 *  except that concat creates a new list.  This function returns the
 *  first list updated.
 **********************************************************************/
LIST join(LIST list1, LIST list2);

/**********************************************************************
 *  l a s t
 *
 *  Return the last list item (this is list type).
 **********************************************************************/
LIST last(LIST var_list);

/**********************************************************************
 *  n t h   c e l l
 *
 *  Return nth list cell in the list.
 **********************************************************************/
void *nth_cell(LIST var_list, int item_num);


/**********************************************************************
 *  p o p
 *
 *  Return the list with the first element removed.  Destroy the space
 *  that it occupied in the list.
 **********************************************************************/
LIST pop(LIST list);

/**********************************************************************
 *  p u s h
 *
 *  Create a list element.  Push the second parameter (the node) onto
 *  the first parameter (the list). Return the new list to the caller.
 **********************************************************************/
LIST push(LIST list, void *element);

/**********************************************************************
 *  p u s h   l a s t
 *
 *  Create a list element. Add the element onto the end of the list.
 **********************************************************************/
LIST push_last(LIST list, void *item);

/**********************************************************************
 *  r e v e r s e
 *
 *  Create a new list with the elements reversed. The old list is not
 *  destroyed.
 **********************************************************************/
LIST reverse(LIST list);

/**********************************************************************
 *  r e v e r s e   d
 *
 *  Create a new list with the elements reversed. The old list is
 *  destroyed.
 **********************************************************************/
LIST reverse_d(LIST list);

/**********************************************************************
 *  s   a d j o i n
 *
 *  Adjoin an element to an assorted list.  The original list is
 *  modified.  Returns the modified list.
 **********************************************************************/
LIST s_adjoin(LIST var_list, void *variable, int_compare compare);

/**********************************************************************
 *   s e a r c h
 *
 *  Search list, return NIL if not found. Return the list starting from
 *  the item if found.  The compare routine "is_equal" is passed in as
 *  the third paramter to this routine.   If the value NULL is supplied
 *  for is_equal, the is_key routine will be used.
 **********************************************************************/
LIST search(LIST list, void *key, int_compare is_equal);

LIST search(LIST list, void *key, ResultCallback2<int, void*, void*>* is_equal);
//////////////////////////////////////////////////////////////oldlist//////////////////////////////////

//////////////////////////////////////////////////////////////structures//////////////////////////////////
/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
#define BLOBBLOCK          64    /*no allocated together */
#define OUTLINEBLOCK       300   /*of each type */
#define NODEBLOCK          36    /*blocks all about 1K bytes */
#define EDGEPTBLOCK        50
#define WERDBLOCK          42
#define LISTBLOCK          300

/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
//int structblockcount = 0;
//void_void memory_print_functions[NUM_DATA_TYPES];
//int max_data_types = 0;
//////////////////////////////////////////////////////////////structures//////////////////////////////////

class STRING;
class UNICHARSET;
class BLOB_CHOICE_LIST_CLIST;

//////////////////////////////////////////////////////////////imgunpk//////////////////////////////////
const uinT8 bpp4table[256][2] =
{      // 4 bit converter
  {0, 0}, {0, 1}, {0, 2}, {0, 3},
  {0, 4}, {0, 5}, {0, 6}, {0, 7},
  {0, 8}, {0, 9}, {0, 10}, {0, 11},
  {0, 12}, {0, 13}, {0, 14}, {0, 15},
  {1, 0}, {1, 1}, {1, 2}, {1, 3},
  {1, 4}, {1, 5}, {1, 6}, {1, 7},
  {1, 8}, {1, 9}, {1, 10}, {1, 11},
  {1, 12}, {1, 13}, {1, 14}, {1, 15},
  {2, 0}, {2, 1}, {2, 2}, {2, 3},
  {2, 4}, {2, 5}, {2, 6}, {2, 7},
  {2, 8}, {2, 9}, {2, 10}, {2, 11},
  {2, 12}, {2, 13}, {2, 14}, {2, 15},
  {3, 0}, {3, 1}, {3, 2}, {3, 3},
  {3, 4}, {3, 5}, {3, 6}, {3, 7},
  {3, 8}, {3, 9}, {3, 10}, {3, 11},
  {3, 12}, {3, 13}, {3, 14}, {3, 15},
  {4, 0}, {4, 1}, {4, 2}, {4, 3},
  {4, 4}, {4, 5}, {4, 6}, {4, 7},
  {4, 8}, {4, 9}, {4, 10}, {4, 11},
  {4, 12}, {4, 13}, {4, 14}, {4, 15},
  {5, 0}, {5, 1}, {5, 2}, {5, 3},
  {5, 4}, {5, 5}, {5, 6}, {5, 7},
  {5, 8}, {5, 9}, {5, 10}, {5, 11},
  {5, 12}, {5, 13}, {5, 14}, {5, 15},
  {6, 0}, {6, 1}, {6, 2}, {6, 3},
  {6, 4}, {6, 5}, {6, 6}, {6, 7},
  {6, 8}, {6, 9}, {6, 10}, {6, 11},
  {6, 12}, {6, 13}, {6, 14}, {6, 15},
  {7, 0}, {7, 1}, {7, 2}, {7, 3},
  {7, 4}, {7, 5}, {7, 6}, {7, 7},
  {7, 8}, {7, 9}, {7, 10}, {7, 11},
  {7, 12}, {7, 13}, {7, 14}, {7, 15},
  {8, 0}, {8, 1}, {8, 2}, {8, 3},
  {8, 4}, {8, 5}, {8, 6}, {8, 7},
  {8, 8}, {8, 9}, {8, 10}, {8, 11},
  {8, 12}, {8, 13}, {8, 14}, {8, 15},
  {9, 0}, {9, 1}, {9, 2}, {9, 3},
  {9, 4}, {9, 5}, {9, 6}, {9, 7},
  {9, 8}, {9, 9}, {9, 10}, {9, 11},
  {9, 12}, {9, 13}, {9, 14}, {9, 15},
  {10, 0}, {10, 1}, {10, 2}, {10, 3},
  {10, 4}, {10, 5}, {10, 6}, {10, 7},
  {10, 8}, {10, 9}, {10, 10}, {10, 11},
  {10, 12}, {10, 13}, {10, 14}, {10, 15},
  {11, 0}, {11, 1}, {11, 2}, {11, 3},
  {11, 4}, {11, 5}, {11, 6}, {11, 7},
  {11, 8}, {11, 9}, {11, 10}, {11, 11},
  {11, 12}, {11, 13}, {11, 14}, {11, 15},
  {12, 0}, {12, 1}, {12, 2}, {12, 3},
  {12, 4}, {12, 5}, {12, 6}, {12, 7},
  {12, 8}, {12, 9}, {12, 10}, {12, 11},
  {12, 12}, {12, 13}, {12, 14}, {12, 15},
  {13, 0}, {13, 1}, {13, 2}, {13, 3},
  {13, 4}, {13, 5}, {13, 6}, {13, 7},
  {13, 8}, {13, 9}, {13, 10}, {13, 11},
  {13, 12}, {13, 13}, {13, 14}, {13, 15},
  {14, 0}, {14, 1}, {14, 2}, {14, 3},
  {14, 4}, {14, 5}, {14, 6}, {14, 7},
  {14, 8}, {14, 9}, {14, 10}, {14, 11},
  {14, 12}, {14, 13}, {14, 14}, {14, 15},
  {15, 0}, {15, 1}, {15, 2}, {15, 3},
  {15, 4}, {15, 5}, {15, 6}, {15, 7},
  {15, 8}, {15, 9}, {15, 10}, {15, 11},
  {15, 12}, {15, 13}, {15, 14}, {15, 15},
};

const uinT8 bpp2table[256][4] =
{      // 2bpp converter
  {0, 0, 0, 0},
  {0, 0, 0, 1},
  {0, 0, 0, 2},
  {0, 0, 0, 3},
  {0, 0, 1, 0},
  {0, 0, 1, 1},
  {0, 0, 1, 2},
  {0, 0, 1, 3},
  {0, 0, 2, 0},
  {0, 0, 2, 1},
  {0, 0, 2, 2},
  {0, 0, 2, 3},
  {0, 0, 3, 0},
  {0, 0, 3, 1},
  {0, 0, 3, 2},
  {0, 0, 3, 3},
  {0, 1, 0, 0},
  {0, 1, 0, 1},
  {0, 1, 0, 2},
  {0, 1, 0, 3},
  {0, 1, 1, 0},
  {0, 1, 1, 1},
  {0, 1, 1, 2},
  {0, 1, 1, 3},
  {0, 1, 2, 0},
  {0, 1, 2, 1},
  {0, 1, 2, 2},
  {0, 1, 2, 3},
  {0, 1, 3, 0},
  {0, 1, 3, 1},
  {0, 1, 3, 2},
  {0, 1, 3, 3},
  {0, 2, 0, 0},
  {0, 2, 0, 1},
  {0, 2, 0, 2},
  {0, 2, 0, 3},
  {0, 2, 1, 0},
  {0, 2, 1, 1},
  {0, 2, 1, 2},
  {0, 2, 1, 3},
  {0, 2, 2, 0},
  {0, 2, 2, 1},
  {0, 2, 2, 2},
  {0, 2, 2, 3},
  {0, 2, 3, 0},
  {0, 2, 3, 1},
  {0, 2, 3, 2},
  {0, 2, 3, 3},
  {0, 3, 0, 0},
  {0, 3, 0, 1},
  {0, 3, 0, 2},
  {0, 3, 0, 3},
  {0, 3, 1, 0},
  {0, 3, 1, 1},
  {0, 3, 1, 2},
  {0, 3, 1, 3},
  {0, 3, 2, 0},
  {0, 3, 2, 1},
  {0, 3, 2, 2},
  {0, 3, 2, 3},
  {0, 3, 3, 0},
  {0, 3, 3, 1},
  {0, 3, 3, 2},
  {0, 3, 3, 3},
  {1, 0, 0, 0},
  {1, 0, 0, 1},
  {1, 0, 0, 2},
  {1, 0, 0, 3},
  {1, 0, 1, 0},
  {1, 0, 1, 1},
  {1, 0, 1, 2},
  {1, 0, 1, 3},
  {1, 0, 2, 0},
  {1, 0, 2, 1},
  {1, 0, 2, 2},
  {1, 0, 2, 3},
  {1, 0, 3, 0},
  {1, 0, 3, 1},
  {1, 0, 3, 2},
  {1, 0, 3, 3},
  {1, 1, 0, 0},
  {1, 1, 0, 1},
  {1, 1, 0, 2},
  {1, 1, 0, 3},
  {1, 1, 1, 0},
  {1, 1, 1, 1},
  {1, 1, 1, 2},
  {1, 1, 1, 3},
  {1, 1, 2, 0},
  {1, 1, 2, 1},
  {1, 1, 2, 2},
  {1, 1, 2, 3},
  {1, 1, 3, 0},
  {1, 1, 3, 1},
  {1, 1, 3, 2},
  {1, 1, 3, 3},
  {1, 2, 0, 0},
  {1, 2, 0, 1},
  {1, 2, 0, 2},
  {1, 2, 0, 3},
  {1, 2, 1, 0},
  {1, 2, 1, 1},
  {1, 2, 1, 2},
  {1, 2, 1, 3},
  {1, 2, 2, 0},
  {1, 2, 2, 1},
  {1, 2, 2, 2},
  {1, 2, 2, 3},
  {1, 2, 3, 0},
  {1, 2, 3, 1},
  {1, 2, 3, 2},
  {1, 2, 3, 3},
  {1, 3, 0, 0},
  {1, 3, 0, 1},
  {1, 3, 0, 2},
  {1, 3, 0, 3},
  {1, 3, 1, 0},
  {1, 3, 1, 1},
  {1, 3, 1, 2},
  {1, 3, 1, 3},
  {1, 3, 2, 0},
  {1, 3, 2, 1},
  {1, 3, 2, 2},
  {1, 3, 2, 3},
  {1, 3, 3, 0},
  {1, 3, 3, 1},
  {1, 3, 3, 2},
  {1, 3, 3, 3},
  {2, 0, 0, 0},
  {2, 0, 0, 1},
  {2, 0, 0, 2},
  {2, 0, 0, 3},
  {2, 0, 1, 0},
  {2, 0, 1, 1},
  {2, 0, 1, 2},
  {2, 0, 1, 3},
  {2, 0, 2, 0},
  {2, 0, 2, 1},
  {2, 0, 2, 2},
  {2, 0, 2, 3},
  {2, 0, 3, 0},
  {2, 0, 3, 1},
  {2, 0, 3, 2},
  {2, 0, 3, 3},
  {2, 1, 0, 0},
  {2, 1, 0, 1},
  {2, 1, 0, 2},
  {2, 1, 0, 3},
  {2, 1, 1, 0},
  {2, 1, 1, 1},
  {2, 1, 1, 2},
  {2, 1, 1, 3},
  {2, 1, 2, 0},
  {2, 1, 2, 1},
  {2, 1, 2, 2},
  {2, 1, 2, 3},
  {2, 1, 3, 0},
  {2, 1, 3, 1},
  {2, 1, 3, 2},
  {2, 1, 3, 3},
  {2, 2, 0, 0},
  {2, 2, 0, 1},
  {2, 2, 0, 2},
  {2, 2, 0, 3},
  {2, 2, 1, 0},
  {2, 2, 1, 1},
  {2, 2, 1, 2},
  {2, 2, 1, 3},
  {2, 2, 2, 0},
  {2, 2, 2, 1},
  {2, 2, 2, 2},
  {2, 2, 2, 3},
  {2, 2, 3, 0},
  {2, 2, 3, 1},
  {2, 2, 3, 2},
  {2, 2, 3, 3},
  {2, 3, 0, 0},
  {2, 3, 0, 1},
  {2, 3, 0, 2},
  {2, 3, 0, 3},
  {2, 3, 1, 0},
  {2, 3, 1, 1},
  {2, 3, 1, 2},
  {2, 3, 1, 3},
  {2, 3, 2, 0},
  {2, 3, 2, 1},
  {2, 3, 2, 2},
  {2, 3, 2, 3},
  {2, 3, 3, 0},
  {2, 3, 3, 1},
  {2, 3, 3, 2},
  {2, 3, 3, 3},
  {3, 0, 0, 0},
  {3, 0, 0, 1},
  {3, 0, 0, 2},
  {3, 0, 0, 3},
  {3, 0, 1, 0},
  {3, 0, 1, 1},
  {3, 0, 1, 2},
  {3, 0, 1, 3},
  {3, 0, 2, 0},
  {3, 0, 2, 1},
  {3, 0, 2, 2},
  {3, 0, 2, 3},
  {3, 0, 3, 0},
  {3, 0, 3, 1},
  {3, 0, 3, 2},
  {3, 0, 3, 3},
  {3, 1, 0, 0},
  {3, 1, 0, 1},
  {3, 1, 0, 2},
  {3, 1, 0, 3},
  {3, 1, 1, 0},
  {3, 1, 1, 1},
  {3, 1, 1, 2},
  {3, 1, 1, 3},
  {3, 1, 2, 0},
  {3, 1, 2, 1},
  {3, 1, 2, 2},
  {3, 1, 2, 3},
  {3, 1, 3, 0},
  {3, 1, 3, 1},
  {3, 1, 3, 2},
  {3, 1, 3, 3},
  {3, 2, 0, 0},
  {3, 2, 0, 1},
  {3, 2, 0, 2},
  {3, 2, 0, 3},
  {3, 2, 1, 0},
  {3, 2, 1, 1},
  {3, 2, 1, 2},
  {3, 2, 1, 3},
  {3, 2, 2, 0},
  {3, 2, 2, 1},
  {3, 2, 2, 2},
  {3, 2, 2, 3},
  {3, 2, 3, 0},
  {3, 2, 3, 1},
  {3, 2, 3, 2},
  {3, 2, 3, 3},
  {3, 3, 0, 0},
  {3, 3, 0, 1},
  {3, 3, 0, 2},
  {3, 3, 0, 3},
  {3, 3, 1, 0},
  {3, 3, 1, 1},
  {3, 3, 1, 2},
  {3, 3, 1, 3},
  {3, 3, 2, 0},
  {3, 3, 2, 1},
  {3, 3, 2, 2},
  {3, 3, 2, 3},
  {3, 3, 3, 0},
  {3, 3, 3, 1},
  {3, 3, 3, 2},
  {3, 3, 3, 3},
};

const uinT8 bpp1table[256][8] = {      // 1bpp converter
  {0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 1},
  {0, 0, 0, 0, 0, 0, 1, 0},
  {0, 0, 0, 0, 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 1, 0, 0},
  {0, 0, 0, 0, 0, 1, 0, 1},
  {0, 0, 0, 0, 0, 1, 1, 0},
  {0, 0, 0, 0, 0, 1, 1, 1},
  {0, 0, 0, 0, 1, 0, 0, 0},
  {0, 0, 0, 0, 1, 0, 0, 1},
  {0, 0, 0, 0, 1, 0, 1, 0},
  {0, 0, 0, 0, 1, 0, 1, 1},
  {0, 0, 0, 0, 1, 1, 0, 0},
  {0, 0, 0, 0, 1, 1, 0, 1},
  {0, 0, 0, 0, 1, 1, 1, 0},
  {0, 0, 0, 0, 1, 1, 1, 1},
  {0, 0, 0, 1, 0, 0, 0, 0},
  {0, 0, 0, 1, 0, 0, 0, 1},
  {0, 0, 0, 1, 0, 0, 1, 0},
  {0, 0, 0, 1, 0, 0, 1, 1},
  {0, 0, 0, 1, 0, 1, 0, 0},
  {0, 0, 0, 1, 0, 1, 0, 1},
  {0, 0, 0, 1, 0, 1, 1, 0},
  {0, 0, 0, 1, 0, 1, 1, 1},
  {0, 0, 0, 1, 1, 0, 0, 0},
  {0, 0, 0, 1, 1, 0, 0, 1},
  {0, 0, 0, 1, 1, 0, 1, 0},
  {0, 0, 0, 1, 1, 0, 1, 1},
  {0, 0, 0, 1, 1, 1, 0, 0},
  {0, 0, 0, 1, 1, 1, 0, 1},
  {0, 0, 0, 1, 1, 1, 1, 0},
  {0, 0, 0, 1, 1, 1, 1, 1},
  {0, 0, 1, 0, 0, 0, 0, 0},
  {0, 0, 1, 0, 0, 0, 0, 1},
  {0, 0, 1, 0, 0, 0, 1, 0},
  {0, 0, 1, 0, 0, 0, 1, 1},
  {0, 0, 1, 0, 0, 1, 0, 0},
  {0, 0, 1, 0, 0, 1, 0, 1},
  {0, 0, 1, 0, 0, 1, 1, 0},
  {0, 0, 1, 0, 0, 1, 1, 1},
  {0, 0, 1, 0, 1, 0, 0, 0},
  {0, 0, 1, 0, 1, 0, 0, 1},
  {0, 0, 1, 0, 1, 0, 1, 0},
  {0, 0, 1, 0, 1, 0, 1, 1},
  {0, 0, 1, 0, 1, 1, 0, 0},
  {0, 0, 1, 0, 1, 1, 0, 1},
  {0, 0, 1, 0, 1, 1, 1, 0},
  {0, 0, 1, 0, 1, 1, 1, 1},
  {0, 0, 1, 1, 0, 0, 0, 0},
  {0, 0, 1, 1, 0, 0, 0, 1},
  {0, 0, 1, 1, 0, 0, 1, 0},
  {0, 0, 1, 1, 0, 0, 1, 1},
  {0, 0, 1, 1, 0, 1, 0, 0},
  {0, 0, 1, 1, 0, 1, 0, 1},
  {0, 0, 1, 1, 0, 1, 1, 0},
  {0, 0, 1, 1, 0, 1, 1, 1},
  {0, 0, 1, 1, 1, 0, 0, 0},
  {0, 0, 1, 1, 1, 0, 0, 1},
  {0, 0, 1, 1, 1, 0, 1, 0},
  {0, 0, 1, 1, 1, 0, 1, 1},
  {0, 0, 1, 1, 1, 1, 0, 0},
  {0, 0, 1, 1, 1, 1, 0, 1},
  {0, 0, 1, 1, 1, 1, 1, 0},
  {0, 0, 1, 1, 1, 1, 1, 1},
  {0, 1, 0, 0, 0, 0, 0, 0},
  {0, 1, 0, 0, 0, 0, 0, 1},
  {0, 1, 0, 0, 0, 0, 1, 0},
  {0, 1, 0, 0, 0, 0, 1, 1},
  {0, 1, 0, 0, 0, 1, 0, 0},
  {0, 1, 0, 0, 0, 1, 0, 1},
  {0, 1, 0, 0, 0, 1, 1, 0},
  {0, 1, 0, 0, 0, 1, 1, 1},
  {0, 1, 0, 0, 1, 0, 0, 0},
  {0, 1, 0, 0, 1, 0, 0, 1},
  {0, 1, 0, 0, 1, 0, 1, 0},
  {0, 1, 0, 0, 1, 0, 1, 1},
  {0, 1, 0, 0, 1, 1, 0, 0},
  {0, 1, 0, 0, 1, 1, 0, 1},
  {0, 1, 0, 0, 1, 1, 1, 0},
  {0, 1, 0, 0, 1, 1, 1, 1},
  {0, 1, 0, 1, 0, 0, 0, 0},
  {0, 1, 0, 1, 0, 0, 0, 1},
  {0, 1, 0, 1, 0, 0, 1, 0},
  {0, 1, 0, 1, 0, 0, 1, 1},
  {0, 1, 0, 1, 0, 1, 0, 0},
  {0, 1, 0, 1, 0, 1, 0, 1},
  {0, 1, 0, 1, 0, 1, 1, 0},
  {0, 1, 0, 1, 0, 1, 1, 1},
  {0, 1, 0, 1, 1, 0, 0, 0},
  {0, 1, 0, 1, 1, 0, 0, 1},
  {0, 1, 0, 1, 1, 0, 1, 0},
  {0, 1, 0, 1, 1, 0, 1, 1},
  {0, 1, 0, 1, 1, 1, 0, 0},
  {0, 1, 0, 1, 1, 1, 0, 1},
  {0, 1, 0, 1, 1, 1, 1, 0},
  {0, 1, 0, 1, 1, 1, 1, 1},
  {0, 1, 1, 0, 0, 0, 0, 0},
  {0, 1, 1, 0, 0, 0, 0, 1},
  {0, 1, 1, 0, 0, 0, 1, 0},
  {0, 1, 1, 0, 0, 0, 1, 1},
  {0, 1, 1, 0, 0, 1, 0, 0},
  {0, 1, 1, 0, 0, 1, 0, 1},
  {0, 1, 1, 0, 0, 1, 1, 0},
  {0, 1, 1, 0, 0, 1, 1, 1},
  {0, 1, 1, 0, 1, 0, 0, 0},
  {0, 1, 1, 0, 1, 0, 0, 1},
  {0, 1, 1, 0, 1, 0, 1, 0},
  {0, 1, 1, 0, 1, 0, 1, 1},
  {0, 1, 1, 0, 1, 1, 0, 0},
  {0, 1, 1, 0, 1, 1, 0, 1},
  {0, 1, 1, 0, 1, 1, 1, 0},
  {0, 1, 1, 0, 1, 1, 1, 1},
  {0, 1, 1, 1, 0, 0, 0, 0},
  {0, 1, 1, 1, 0, 0, 0, 1},
  {0, 1, 1, 1, 0, 0, 1, 0},
  {0, 1, 1, 1, 0, 0, 1, 1},
  {0, 1, 1, 1, 0, 1, 0, 0},
  {0, 1, 1, 1, 0, 1, 0, 1},
  {0, 1, 1, 1, 0, 1, 1, 0},
  {0, 1, 1, 1, 0, 1, 1, 1},
  {0, 1, 1, 1, 1, 0, 0, 0},
  {0, 1, 1, 1, 1, 0, 0, 1},
  {0, 1, 1, 1, 1, 0, 1, 0},
  {0, 1, 1, 1, 1, 0, 1, 1},
  {0, 1, 1, 1, 1, 1, 0, 0},
  {0, 1, 1, 1, 1, 1, 0, 1},
  {0, 1, 1, 1, 1, 1, 1, 0},
  {0, 1, 1, 1, 1, 1, 1, 1},
  {1, 0, 0, 0, 0, 0, 0, 0},
  {1, 0, 0, 0, 0, 0, 0, 1},
  {1, 0, 0, 0, 0, 0, 1, 0},
  {1, 0, 0, 0, 0, 0, 1, 1},
  {1, 0, 0, 0, 0, 1, 0, 0},
  {1, 0, 0, 0, 0, 1, 0, 1},
  {1, 0, 0, 0, 0, 1, 1, 0},
  {1, 0, 0, 0, 0, 1, 1, 1},
  {1, 0, 0, 0, 1, 0, 0, 0},
  {1, 0, 0, 0, 1, 0, 0, 1},
  {1, 0, 0, 0, 1, 0, 1, 0},
  {1, 0, 0, 0, 1, 0, 1, 1},
  {1, 0, 0, 0, 1, 1, 0, 0},
  {1, 0, 0, 0, 1, 1, 0, 1},
  {1, 0, 0, 0, 1, 1, 1, 0},
  {1, 0, 0, 0, 1, 1, 1, 1},
  {1, 0, 0, 1, 0, 0, 0, 0},
  {1, 0, 0, 1, 0, 0, 0, 1},
  {1, 0, 0, 1, 0, 0, 1, 0},
  {1, 0, 0, 1, 0, 0, 1, 1},
  {1, 0, 0, 1, 0, 1, 0, 0},
  {1, 0, 0, 1, 0, 1, 0, 1},
  {1, 0, 0, 1, 0, 1, 1, 0},
  {1, 0, 0, 1, 0, 1, 1, 1},
  {1, 0, 0, 1, 1, 0, 0, 0},
  {1, 0, 0, 1, 1, 0, 0, 1},
  {1, 0, 0, 1, 1, 0, 1, 0},
  {1, 0, 0, 1, 1, 0, 1, 1},
  {1, 0, 0, 1, 1, 1, 0, 0},
  {1, 0, 0, 1, 1, 1, 0, 1},
  {1, 0, 0, 1, 1, 1, 1, 0},
  {1, 0, 0, 1, 1, 1, 1, 1},
  {1, 0, 1, 0, 0, 0, 0, 0},
  {1, 0, 1, 0, 0, 0, 0, 1},
  {1, 0, 1, 0, 0, 0, 1, 0},
  {1, 0, 1, 0, 0, 0, 1, 1},
  {1, 0, 1, 0, 0, 1, 0, 0},
  {1, 0, 1, 0, 0, 1, 0, 1},
  {1, 0, 1, 0, 0, 1, 1, 0},
  {1, 0, 1, 0, 0, 1, 1, 1},
  {1, 0, 1, 0, 1, 0, 0, 0},
  {1, 0, 1, 0, 1, 0, 0, 1},
  {1, 0, 1, 0, 1, 0, 1, 0},
  {1, 0, 1, 0, 1, 0, 1, 1},
  {1, 0, 1, 0, 1, 1, 0, 0},
  {1, 0, 1, 0, 1, 1, 0, 1},
  {1, 0, 1, 0, 1, 1, 1, 0},
  {1, 0, 1, 0, 1, 1, 1, 1},
  {1, 0, 1, 1, 0, 0, 0, 0},
  {1, 0, 1, 1, 0, 0, 0, 1},
  {1, 0, 1, 1, 0, 0, 1, 0},
  {1, 0, 1, 1, 0, 0, 1, 1},
  {1, 0, 1, 1, 0, 1, 0, 0},
  {1, 0, 1, 1, 0, 1, 0, 1},
  {1, 0, 1, 1, 0, 1, 1, 0},
  {1, 0, 1, 1, 0, 1, 1, 1},
  {1, 0, 1, 1, 1, 0, 0, 0},
  {1, 0, 1, 1, 1, 0, 0, 1},
  {1, 0, 1, 1, 1, 0, 1, 0},
  {1, 0, 1, 1, 1, 0, 1, 1},
  {1, 0, 1, 1, 1, 1, 0, 0},
  {1, 0, 1, 1, 1, 1, 0, 1},
  {1, 0, 1, 1, 1, 1, 1, 0},
  {1, 0, 1, 1, 1, 1, 1, 1},
  {1, 1, 0, 0, 0, 0, 0, 0},
  {1, 1, 0, 0, 0, 0, 0, 1},
  {1, 1, 0, 0, 0, 0, 1, 0},
  {1, 1, 0, 0, 0, 0, 1, 1},
  {1, 1, 0, 0, 0, 1, 0, 0},
  {1, 1, 0, 0, 0, 1, 0, 1},
  {1, 1, 0, 0, 0, 1, 1, 0},
  {1, 1, 0, 0, 0, 1, 1, 1},
  {1, 1, 0, 0, 1, 0, 0, 0},
  {1, 1, 0, 0, 1, 0, 0, 1},
  {1, 1, 0, 0, 1, 0, 1, 0},
  {1, 1, 0, 0, 1, 0, 1, 1},
  {1, 1, 0, 0, 1, 1, 0, 0},
  {1, 1, 0, 0, 1, 1, 0, 1},
  {1, 1, 0, 0, 1, 1, 1, 0},
  {1, 1, 0, 0, 1, 1, 1, 1},
  {1, 1, 0, 1, 0, 0, 0, 0},
  {1, 1, 0, 1, 0, 0, 0, 1},
  {1, 1, 0, 1, 0, 0, 1, 0},
  {1, 1, 0, 1, 0, 0, 1, 1},
  {1, 1, 0, 1, 0, 1, 0, 0},
  {1, 1, 0, 1, 0, 1, 0, 1},
  {1, 1, 0, 1, 0, 1, 1, 0},
  {1, 1, 0, 1, 0, 1, 1, 1},
  {1, 1, 0, 1, 1, 0, 0, 0},
  {1, 1, 0, 1, 1, 0, 0, 1},
  {1, 1, 0, 1, 1, 0, 1, 0},
  {1, 1, 0, 1, 1, 0, 1, 1},
  {1, 1, 0, 1, 1, 1, 0, 0},
  {1, 1, 0, 1, 1, 1, 0, 1},
  {1, 1, 0, 1, 1, 1, 1, 0},
  {1, 1, 0, 1, 1, 1, 1, 1},
  {1, 1, 1, 0, 0, 0, 0, 0},
  {1, 1, 1, 0, 0, 0, 0, 1},
  {1, 1, 1, 0, 0, 0, 1, 0},
  {1, 1, 1, 0, 0, 0, 1, 1},
  {1, 1, 1, 0, 0, 1, 0, 0},
  {1, 1, 1, 0, 0, 1, 0, 1},
  {1, 1, 1, 0, 0, 1, 1, 0},
  {1, 1, 1, 0, 0, 1, 1, 1},
  {1, 1, 1, 0, 1, 0, 0, 0},
  {1, 1, 1, 0, 1, 0, 0, 1},
  {1, 1, 1, 0, 1, 0, 1, 0},
  {1, 1, 1, 0, 1, 0, 1, 1},
  {1, 1, 1, 0, 1, 1, 0, 0},
  {1, 1, 1, 0, 1, 1, 0, 1},
  {1, 1, 1, 0, 1, 1, 1, 0},
  {1, 1, 1, 0, 1, 1, 1, 1},
  {1, 1, 1, 1, 0, 0, 0, 0},
  {1, 1, 1, 1, 0, 0, 0, 1},
  {1, 1, 1, 1, 0, 0, 1, 0},
  {1, 1, 1, 1, 0, 0, 1, 1},
  {1, 1, 1, 1, 0, 1, 0, 0},
  {1, 1, 1, 1, 0, 1, 0, 1},
  {1, 1, 1, 1, 0, 1, 1, 0},
  {1, 1, 1, 1, 0, 1, 1, 1},
  {1, 1, 1, 1, 1, 0, 0, 0},
  {1, 1, 1, 1, 1, 0, 0, 1},
  {1, 1, 1, 1, 1, 0, 1, 0},
  {1, 1, 1, 1, 1, 0, 1, 1},
  {1, 1, 1, 1, 1, 1, 0, 0},
  {1, 1, 1, 1, 1, 1, 0, 1},
  {1, 1, 1, 1, 1, 1, 1, 0},
  {1, 1, 1, 1, 1, 1, 1, 1},
};
//////////////////////////////////////////////////////////////imgunpk//////////////////////////////////

//////////////////////////////////////////////////////////////states//////////////////////////////////
/*----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------*/
#define MAX_NUM_CHUNKS  64       /* Limit on pieces */

typedef struct
{
  uinT32 part1;
  uinT32 part2;
} STATE;

/** State variable for search */
typedef int *SEARCH_STATE;

/** State variable for search */
typedef uinT8 PIECES_STATE[MAX_NUM_CHUNKS + 2];

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
SEARCH_STATE bin_to_chunks(STATE *state, int num_joints);

void bin_to_pieces(STATE *state, int num_joints, PIECES_STATE pieces);

void insert_new_chunk(register STATE *state,
                      register int index,
                      int num_joints);

STATE *new_state(STATE *oldstate);

int ones_in_state(STATE *state, int num_joints);

void print_state(const char *label, STATE *state, int num_joints);

void set_n_ones(STATE *state, int n);

int compare_states(STATE *true_state, STATE *this_state, int *blob_index);

extern void free_state(STATE *);
//////////////////////////////////////////////////////////////states//////////////////////////////////

//////////////////////////////////////////////////////////////lsterr/////////////////////////////////////////////////////////////////////////
const ERRCODE DONT_CONSTRUCT_LIST_BY_COPY = "Can't create a list by assignment";
const ERRCODE DONT_ASSIGN_LISTS = "Can't assign to lists";
const ERRCODE SERIALISE_LINKS = "Attempted to (de)serialise a link element";

#ifndef NDEBUG

const ERRCODE NO_LIST = "Iterator not set to a list";
const ERRCODE NULL_OBJECT = "List found this = NULL!";
const ERRCODE NULL_DATA = "List would have returned a NULL data pointer";
const ERRCODE NULL_CURRENT = "List current position is NULL";
const ERRCODE NULL_NEXT = "Next element on the list is NULL";
const ERRCODE NULL_PREV = "Previous element on the list is NULL";
const ERRCODE EMPTY_LIST = "List is empty";
const ERRCODE BAD_PARAMETER = "List parameter error";
const ERRCODE STILL_LINKED =
"Attemting to add an element with non NULL links, to a list";

const ERRCODE CANTOPENFILE = "Can't open file";
const ERRCODE CANTCREATEFILE = "Can't create file";
const ERRCODE CANTMAKEPIPE = "Can't create pipe";
const ERRCODE CANTCONNECTPIPE = "Can't reconnect pipes to stdin/stdout";
const ERRCODE READFAILED = "Read of file failed";
const ERRCODE WRITEFAILED = "Write of file failed";
const ERRCODE SELECTFAILED = "Select failed";

const ERRCODE EXECFAILED = "Could not exec new process";

const ERRCODE MEMTOOBIG = "Memory request too big";
const ERRCODE NOMOREBLOCKS = "Max total memory blocks exceeded";
const ERRCODE NOMOREMEM = "No more memory available from malloc";
const ERRCODE FREENULLPTR = "Attempt to free memory NULL pointer";
const ERRCODE NOTMALLOCMEM =
"Attempt to free memory not belonging to memalloc";
const ERRCODE FREEILLEGALPTR = "Pointer or memory corrupted";
const ERRCODE FREEFREEDBLOCK = "Memory block already marked free";
const ERRCODE BADMEMCHUNKS = "Inconsistency in memory chunks";
const ERRCODE BADSTRUCTCOUNT = "Memory incorrect freelist length";
const ERRCODE NEGATIVE_USED_STRUCTS =
"Negative number of used memory structures";
const ERRCODE NOTASTRING = "Illegal pointer for memory strfree";

const ERRCODE BADIMAGETYPE = "Unrecognized image type";
const ERRCODE CANTREADIMAGETYPE = "Can't read this image type";
const ERRCODE CANTWRITEIMAGETYPE = "Can't write this image type";
const ERRCODE IMAGEUNDEFINED = "Attempt to operate on undefined image";
const ERRCODE BADIMAGECOORDS = "Coordinates in image out of bounds";
const ERRCODE BADIMAGESEEK = "Can't seek backwards in a buffered image!";
const ERRCODE BADIMAGESIZE = "Illegal image size";
const ERRCODE BADIMAGEFORMAT = "Illegal image format";
const ERRCODE BADBPP = "Only 1,2,4,5,6,8 bpp are supported";
const ERRCODE BADWINDOW = "Convolution window must have odd dimensions";
const ERRCODE MEMORY_OUT = "Out of memory";


const ERRCODE BADBLOCKLINE = "Y coordinate in block out of bounds";
const ERRCODE LOSTBLOCKLINE = "Can't find rectangle for line";
const ERRCODE ILLEGAL_GRADIENT = "Gradient wrong side of edge step!";
const ERRCODE WRONG_WORD = "Word doesn't have blobs of that type";
#endif
//////////////////////////////////////////////////////////////lsterr/////////////////////////////////////////////

/////////////////////////////////////////////////////////////////elst2/////////////////////////////////
class ELIST2_ITERATOR;

/**********************************************************************
DESIGN NOTE
===========

It would probably be possible to implement the ELIST2 classes as derived
classes from ELIST.  I haven't done this because:

a) I think it would be harder to understand the code
(Though the problem with not inheriting is that changes to ELIST must be
  reflected in ELIST2 and vice versa)

b) Most of the code is inline so:
i)  The duplication in source does not affect the run time code size - the
    code is copied inline anyway!

  ii) The compiler should have a bit less work to do!
**********************************************************************/

/**********************************************************************
 *							CLASS - ELIST2_LINK
 *
 *							Generic link class for doubly linked lists with embedded links
 *
 *  Note:  No destructor - elements are assumed to be destroyed EITHER after
 *  they have been extracted from a list OR by the ELIST2 destructor which
 *  walks the list.
 **********************************************************************/

class ELIST2_LINK
{
  friend class ELIST2_ITERATOR;
  friend class ELIST2;

  ELIST2_LINK *prev;
  ELIST2_LINK *next;

  public:
    ELIST2_LINK() {  //constructor
      prev = next = NULL;
    }

    ELIST2_LINK(                        //copy constructor
                const ELIST2_LINK &) {  //dont copy link
      prev = next = NULL;
    }

    void operator= (             //dont copy links
    const ELIST2_LINK &) {
      prev = next = NULL;
    }

    /* NOTE that none of the serialise member functions are required for
    ELIST2_LINKs as they are never serialised.  (We demand that the derived
    class terminates recursion - just to make sure that it defines the member
    functions anyway.)
    */
};

/**********************************************************************
 * CLASS - ELIST2
 *
 * Generic list class for doubly linked lists with embedded links
 **********************************************************************/

class ELIST2
{
  friend class ELIST2_ITERATOR;

  ELIST2_LINK *last;             //End of list
  //(Points to head)
  ELIST2_LINK *First() {  // return first
    return last ? last->next : NULL;
  }

  public:
    ELIST2() {  //constructor
      last = NULL;
    }

    void internal_clear (        //destroy all links
      void (*zapper) (ELIST2_LINK *));
    //ptr to zapper functn

    bool empty() {  //is list empty?
      return !last;
    }

    bool singleton() {
      return last ? (last == last->next) : FALSE;
    }

    void shallow_copy(                      //dangerous!!
                      ELIST2 *from_list) {  //beware destructors!!
      last = from_list->last;
    }

                                 //ptr to copier functn
    void internal_deep_copy (ELIST2_LINK * (*copier) (ELIST2_LINK *),
      const ELIST2 * list);      //list being copied

    void assign_to_sublist(                            //to this list
                           ELIST2_ITERATOR *start_it,  //from list start
                           ELIST2_ITERATOR *end_it);   //from list end

    inT32 length();  //# elements in list

    void sort (                  //sort elements
      int comparator (           //comparison routine
      const void *, const void *));

    // Assuming list has been sorted already, insert new_link to
    // keep the list sorted according to the same comparison function.
    // Comparision function is the same as used by sort, i.e. uses double
    // indirection. Time is O(1) to add to beginning or end.
    // Time is linear to add pre-sorted items to an empty list.
    void add_sorted(int comparator(const void*, const void*),
                    ELIST2_LINK* new_link);

    void internal_dump (         //serialise each elem
      FILE * f,                  //to this file
      void element_serialiser (  //using this function
      FILE *, ELIST2_LINK *));

    void internal_de_dump (      //de_serial each elem
      FILE * f,                  //from this file
                                 //using this function
      ELIST2_LINK * element_de_serialiser (
      FILE *));

    void prep_serialise();  //change last to count

    /*  Note that dump() and de_dump() are not required as calls to dump/de_dump a
      list class should be handled by a class derived from this.

      make_serialise is not required for a similar reason.
    */
};

/***********************************************************************
 *							CLASS - ELIST2_ITERATOR
 *
 *							Generic iterator class for doubly linked lists with embedded links
 **********************************************************************/

class ELIST2_ITERATOR
{
  friend void ELIST2::assign_to_sublist(ELIST2_ITERATOR *, ELIST2_ITERATOR *);

  ELIST2 *list;                  //List being iterated
  ELIST2_LINK *prev;             //prev element
  ELIST2_LINK *current;          //current element
  ELIST2_LINK *next;             //next element
  bool ex_current_was_last;     //current extracted
  //was end of list
  bool ex_current_was_cycle_pt; //current extracted
  //was cycle point
  ELIST2_LINK *cycle_pt;         //point we are cycling
  //the list to.
  bool started_cycling;         //Have we moved off
  //the start?

  ELIST2_LINK *extract_sublist(                             //from this current...
                               ELIST2_ITERATOR *other_it);  //to other current

  public:
    ELIST2_ITERATOR() {  //constructor
      list = NULL;
    }                            //unassigned list

    ELIST2_ITERATOR(  //constructor
                    ELIST2 *list_to_iterate);

    void set_to_list(  //change list
                     ELIST2 *list_to_iterate);

    void add_after_then_move(                         //add after current &
                             ELIST2_LINK *new_link);  //move to new

    void add_after_stay_put(                         //add after current &
                            ELIST2_LINK *new_link);  //stay at current

    void add_before_then_move(                         //add before current &
                              ELIST2_LINK *new_link);  //move to new

    void add_before_stay_put(                         //add before current &
                             ELIST2_LINK *new_link);  //stay at current

    void add_list_after(                       //add a list &
                        ELIST2 *list_to_add);  //stay at current

    void add_list_before(                       //add a list &
                         ELIST2 *list_to_add);  //move to it 1st item

    ELIST2_LINK *data() {  //get current data
    #ifndef NDEBUG
      if (!current)
        NULL_DATA.error ("ELIST2_ITERATOR::data", ABORT, NULL);
      if (!list)
        NO_LIST.error ("ELIST2_ITERATOR::data", ABORT, NULL);
    #endif
      return current;
    }

    ELIST2_LINK *data_relative(               //get data + or - ...
                               inT8 offset);  //offset from current

    ELIST2_LINK *forward();  //move to next element

    ELIST2_LINK *backward();  //move to prev element

    ELIST2_LINK *extract();  //remove from list

                                 //go to start of list
    ELIST2_LINK *move_to_first();

    ELIST2_LINK *move_to_last();  //go to end of list

    void mark_cycle_pt();  //remember current

    bool empty() {  //is list empty?
    #ifndef NDEBUG
      if (!list)
        NO_LIST.error ("ELIST2_ITERATOR::empty", ABORT, NULL);
    #endif
      return list->empty ();
    }

    bool current_extracted() {  //current extracted?
      return !current;
    }

    bool at_first();  //Current is first?

    bool at_last();  //Current is last?

    bool cycled_list();  //Completed a cycle?

    void add_to_end(                         //add at end &
                    ELIST2_LINK *new_link);  //dont move

    void exchange(                             //positions of 2 links
                  ELIST2_ITERATOR *other_it);  //other iterator

    inT32 length();  //# elements in list

    void sort (                  //sort elements
      int comparator (           //comparison routine
      const void *, const void *));

};

/***********************************************************************
 *							ELIST2_ITERATOR::set_to_list
 *
 *  (Re-)initialise the iterator to point to the start of the list_to_iterate
 *  over.
 **********************************************************************/

inline void ELIST2_ITERATOR::set_to_list(  //change list
                                         ELIST2 *list_to_iterate) {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::set_to_list", ABORT, NULL);
  if (!list_to_iterate)
    BAD_PARAMETER.error ("ELIST2_ITERATOR::set_to_list", ABORT,
      "list_to_iterate is NULL");
  #endif

  list = list_to_iterate;
  prev = list->last;
  current = list->First ();
  next = current ? current->next : NULL;
  cycle_pt = NULL;               //await explicit set
  started_cycling = FALSE;
  ex_current_was_last = FALSE;
  ex_current_was_cycle_pt = FALSE;
}


/***********************************************************************
 *							ELIST2_ITERATOR::ELIST2_ITERATOR
 *
 *  CONSTRUCTOR - set iterator to specified list;
 **********************************************************************/

inline ELIST2_ITERATOR::ELIST2_ITERATOR(ELIST2 *list_to_iterate) {
  set_to_list(list_to_iterate);
}


/***********************************************************************
 *							ELIST2_ITERATOR::add_after_then_move
 *
 *  Add a new element to the list after the current element and move the
 *  iterator to the new element.
 **********************************************************************/

inline void ELIST2_ITERATOR::add_after_then_move(  // element to add
                                                 ELIST2_LINK *new_element) {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::add_after_then_move", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::add_after_then_move", ABORT, NULL);
  if (!new_element)
    BAD_PARAMETER.error ("ELIST2_ITERATOR::add_after_then_move", ABORT,
      "new_element is NULL");
  if (new_element->next)
    STILL_LINKED.error ("ELIST2_ITERATOR::add_after_then_move", ABORT, NULL);
  #endif

  if (list->empty ()) {
    new_element->next = new_element;
    new_element->prev = new_element;
    list->last = new_element;
    prev = next = new_element;
  }
  else {
    new_element->next = next;
    next->prev = new_element;

    if (current) {               //not extracted
      new_element->prev = current;
      current->next = new_element;
      prev = current;
      if (current == list->last)
        list->last = new_element;
    }
    else {                       //current extracted
      new_element->prev = prev;
      prev->next = new_element;
      if (ex_current_was_last)
        list->last = new_element;
      if (ex_current_was_cycle_pt)
        cycle_pt = new_element;
    }
  }
  current = new_element;
}


/***********************************************************************
 *							ELIST2_ITERATOR::add_after_stay_put
 *
 *  Add a new element to the list after the current element but do not move
 *  the iterator to the new element.
 **********************************************************************/

inline void ELIST2_ITERATOR::add_after_stay_put(  // element to add
                                                ELIST2_LINK *new_element) {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::add_after_stay_put", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::add_after_stay_put", ABORT, NULL);
  if (!new_element)
    BAD_PARAMETER.error ("ELIST2_ITERATOR::add_after_stay_put", ABORT,
      "new_element is NULL");
  if (new_element->next)
    STILL_LINKED.error ("ELIST2_ITERATOR::add_after_stay_put", ABORT, NULL);
  #endif

  if (list->empty ()) {
    new_element->next = new_element;
    new_element->prev = new_element;
    list->last = new_element;
    prev = next = new_element;
    ex_current_was_last = FALSE;
    current = NULL;
  }
  else {
    new_element->next = next;
    next->prev = new_element;

    if (current) {               //not extracted
      new_element->prev = current;
      current->next = new_element;
      if (prev == current)
        prev = new_element;
      if (current == list->last)
        list->last = new_element;
    }
    else {                       //current extracted
      new_element->prev = prev;
      prev->next = new_element;
      if (ex_current_was_last) {
        list->last = new_element;
        ex_current_was_last = FALSE;
      }
    }
    next = new_element;
  }
}


/***********************************************************************
 *							ELIST2_ITERATOR::add_before_then_move
 *
 *  Add a new element to the list before the current element and move the
 *  iterator to the new element.
 **********************************************************************/

inline void ELIST2_ITERATOR::add_before_then_move(  // element to add
                                                  ELIST2_LINK *new_element) {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::add_before_then_move", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::add_before_then_move", ABORT, NULL);
  if (!new_element)
    BAD_PARAMETER.error ("ELIST2_ITERATOR::add_before_then_move", ABORT,
      "new_element is NULL");
  if (new_element->next)
    STILL_LINKED.error ("ELIST2_ITERATOR::add_before_then_move", ABORT, NULL);
  #endif

  if (list->empty ()) {
    new_element->next = new_element;
    new_element->prev = new_element;
    list->last = new_element;
    prev = next = new_element;
  }
  else {
    prev->next = new_element;
    new_element->prev = prev;

    if (current) {               //not extracted
      new_element->next = current;
      current->prev = new_element;
      next = current;
    }
    else {                       //current extracted
      new_element->next = next;
      next->prev = new_element;
      if (ex_current_was_last)
        list->last = new_element;
      if (ex_current_was_cycle_pt)
        cycle_pt = new_element;
    }
  }
  current = new_element;
}


/***********************************************************************
 *							ELIST2_ITERATOR::add_before_stay_put
 *
 *  Add a new element to the list before the current element but dont move the
 *  iterator to the new element.
 **********************************************************************/

inline void ELIST2_ITERATOR::add_before_stay_put(  // element to add
                                                 ELIST2_LINK *new_element) {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::add_before_stay_put", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::add_before_stay_put", ABORT, NULL);
  if (!new_element)
    BAD_PARAMETER.error ("ELIST2_ITERATOR::add_before_stay_put", ABORT,
      "new_element is NULL");
  if (new_element->next)
    STILL_LINKED.error ("ELIST2_ITERATOR::add_before_stay_put", ABORT, NULL);
  #endif

  if (list->empty ()) {
    new_element->next = new_element;
    new_element->prev = new_element;
    list->last = new_element;
    prev = next = new_element;
    ex_current_was_last = TRUE;
    current = NULL;
  }
  else {
    prev->next = new_element;
    new_element->prev = prev;

    if (current) {               //not extracted
      new_element->next = current;
      current->prev = new_element;
      if (next == current)
        next = new_element;
    }
    else {                       //current extracted
      new_element->next = next;
      next->prev = new_element;
      if (ex_current_was_last)
        list->last = new_element;
    }
    prev = new_element;
  }
}


/***********************************************************************
 *							ELIST2_ITERATOR::add_list_after
 *
 *  Insert another list to this list after the current element but dont move the
 *  iterator.
 **********************************************************************/

inline void ELIST2_ITERATOR::add_list_after(ELIST2 *list_to_add) {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::add_list_after", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::add_list_after", ABORT, NULL);
  if (!list_to_add)
    BAD_PARAMETER.error ("ELIST2_ITERATOR::add_list_after", ABORT,
      "list_to_add is NULL");
  #endif

  if (!list_to_add->empty ()) {
    if (list->empty ()) {
      list->last = list_to_add->last;
      prev = list->last;
      next = list->First ();
      ex_current_was_last = TRUE;
      current = NULL;
    }
    else {
      if (current) {             //not extracted
        current->next = list_to_add->First ();
        current->next->prev = current;
        if (current == list->last)
          list->last = list_to_add->last;
        list_to_add->last->next = next;
        next->prev = list_to_add->last;
        next = current->next;
      }
      else {                     //current extracted
        prev->next = list_to_add->First ();
        prev->next->prev = prev;
        if (ex_current_was_last) {
          list->last = list_to_add->last;
          ex_current_was_last = FALSE;
        }
        list_to_add->last->next = next;
        next->prev = list_to_add->last;
        next = prev->next;
      }
    }
    list_to_add->last = NULL;
  }
}


/***********************************************************************
 *							ELIST2_ITERATOR::add_list_before
 *
 *  Insert another list to this list before the current element. Move the
 *  iterator to the start of the inserted elements
 *  iterator.
 **********************************************************************/

inline void ELIST2_ITERATOR::add_list_before(ELIST2 *list_to_add) {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::add_list_before", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::add_list_before", ABORT, NULL);
  if (!list_to_add)
    BAD_PARAMETER.error ("ELIST2_ITERATOR::add_list_before", ABORT,
      "list_to_add is NULL");
  #endif

  if (!list_to_add->empty ()) {
    if (list->empty ()) {
      list->last = list_to_add->last;
      prev = list->last;
      current = list->First ();
      next = current->next;
      ex_current_was_last = FALSE;
    }
    else {
      prev->next = list_to_add->First ();
      prev->next->prev = prev;

      if (current) {             //not extracted
        list_to_add->last->next = current;
        current->prev = list_to_add->last;
      }
      else {                     //current extracted
        list_to_add->last->next = next;
        next->prev = list_to_add->last;
        if (ex_current_was_last)
          list->last = list_to_add->last;
        if (ex_current_was_cycle_pt)
          cycle_pt = prev->next;
      }
      current = prev->next;
      next = current->next;
    }
    list_to_add->last = NULL;
  }
}


/***********************************************************************
 *							ELIST2_ITERATOR::extract
 *
 *  Do extraction by removing current from the list, returning it to the
 *  caller, but NOT updating the iterator.  (So that any calling loop can do
 *  this.)   The iterator's current points to NULL.  If the extracted element
 *  is to be deleted, this is the callers responsibility.
 **********************************************************************/

inline ELIST2_LINK *ELIST2_ITERATOR::extract() {
  ELIST2_LINK *extracted_link;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::extract", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::extract", ABORT, NULL);
  if (!current)                  //list empty or
                                 //element extracted
    NULL_CURRENT.error ("ELIST2_ITERATOR::extract",
      ABORT, NULL);
  #endif

  if (list->singleton()) {
    // Special case where we do need to change the iterator.
    prev = next = list->last = NULL;
  } else {
    prev->next = next;           //remove from list
    next->prev = prev;

    if (current == list->last) {
      list->last = prev;
      ex_current_was_last = TRUE;
    } else {
      ex_current_was_last = FALSE;
    }
  }
  // Always set ex_current_was_cycle_pt so an add/forward will work in a loop.
  ex_current_was_cycle_pt = (current == cycle_pt) ? TRUE : FALSE;
  extracted_link = current;
  extracted_link->next = NULL;   //for safety
  extracted_link->prev = NULL;   //for safety
  current = NULL;
  return extracted_link;
}


/***********************************************************************
 *							ELIST2_ITERATOR::move_to_first()
 *
 *  Move current so that it is set to the start of the list.
 *  Return data just in case anyone wants it.
 **********************************************************************/

inline ELIST2_LINK *ELIST2_ITERATOR::move_to_first() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::move_to_first", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::move_to_first", ABORT, NULL);
  #endif

  current = list->First ();
  prev = list->last;
  next = current ? current->next : NULL;
  return current;
}


/***********************************************************************
 *							ELIST2_ITERATOR::move_to_last()
 *
 *  Move current so that it is set to the end of the list.
 *  Return data just in case anyone wants it.
 **********************************************************************/

inline ELIST2_LINK *ELIST2_ITERATOR::move_to_last() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::move_to_last", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::move_to_last", ABORT, NULL);
  #endif

  current = list->last;
  prev = current ? current->prev : NULL;
  next = current ? current->next : NULL;
  return current;
}


/***********************************************************************
 *							ELIST2_ITERATOR::mark_cycle_pt()
 *
 *  Remember the current location so that we can tell whether we've returned
 *  to this point later.
 *
 *  If the current point is deleted either now, or in the future, the cycle
 *  point will be set to the next item which is set to current.  This could be
 *  by a forward, add_after_then_move or add_after_then_move.
 **********************************************************************/

inline void ELIST2_ITERATOR::mark_cycle_pt() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::mark_cycle_pt", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::mark_cycle_pt", ABORT, NULL);
  #endif

  if (current)
    cycle_pt = current;
  else
    ex_current_was_cycle_pt = TRUE;
  started_cycling = FALSE;
}


/***********************************************************************
 *							ELIST2_ITERATOR::at_first()
 *
 *  Are we at the start of the list?
 *
 **********************************************************************/

inline bool ELIST2_ITERATOR::at_first() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::at_first", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::at_first", ABORT, NULL);
  #endif

                                 //we're at a deleted
  return ((list->empty ()) || (current == list->First ()) || ((current == NULL) &&
    (prev == list->last) &&      //NON-last pt between
    !ex_current_was_last));      //first and last
}


/***********************************************************************
 *							ELIST2_ITERATOR::at_last()
 *
 *  Are we at the end of the list?
 *
 **********************************************************************/

inline bool ELIST2_ITERATOR::at_last() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::at_last", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::at_last", ABORT, NULL);
  #endif

                                 //we're at a deleted
  return ((list->empty ()) || (current == list->last) || ((current == NULL) &&
    (prev == list->last) &&      //last point between
    ex_current_was_last));       //first and last
}


/***********************************************************************
 *							ELIST2_ITERATOR::cycled_list()
 *
 *  Have we returned to the cycle_pt since it was set?
 *
 **********************************************************************/

inline bool ELIST2_ITERATOR::cycled_list() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::cycled_list", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::cycled_list", ABORT, NULL);
  #endif

  return ((list->empty ()) || ((current == cycle_pt) && started_cycling));

}


/***********************************************************************
 *							ELIST2_ITERATOR::length()
 *
 *  Return the length of the list
 *
 **********************************************************************/

inline inT32 ELIST2_ITERATOR::length() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::length", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::length", ABORT, NULL);
  #endif

  return list->length ();
}


/***********************************************************************
 *							ELIST2_ITERATOR::sort()
 *
 *  Sort the elements of the list, then reposition at the start.
 *
 **********************************************************************/

inline void
ELIST2_ITERATOR::sort (          //sort elements
int comparator (                 //comparison routine
const void *, const void *)) {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::sort", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::sort", ABORT, NULL);
  #endif

  list->sort (comparator);
  move_to_first();
}


/***********************************************************************
 *							ELIST2_ITERATOR::add_to_end
 *
 *  Add a new element to the end of the list without moving the iterator.
 *  This is provided because a single linked list cannot move to the last as
 *  the iterator couldn't set its prev pointer.  Adding to the end is
 *  essential for implementing
              queues.
**********************************************************************/

inline void ELIST2_ITERATOR::add_to_end(  // element to add
                                        ELIST2_LINK *new_element) {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("ELIST2_ITERATOR::add_to_end", ABORT, NULL);
  if (!list)
    NO_LIST.error ("ELIST2_ITERATOR::add_to_end", ABORT, NULL);
  if (!new_element)
    BAD_PARAMETER.error ("ELIST2_ITERATOR::add_to_end", ABORT,
      "new_element is NULL");
  if (new_element->next)
    STILL_LINKED.error ("ELIST2_ITERATOR::add_to_end", ABORT, NULL);
  #endif

  if (this->at_last ()) {
    this->add_after_stay_put (new_element);
  }
  else {
    if (this->at_first ()) {
      this->add_before_stay_put (new_element);
      list->last = new_element;
    }
    else {                       //Iteratr is elsewhere
      new_element->next = list->last->next;
      new_element->prev = list->last;
      list->last->next->prev = new_element;
      list->last->next = new_element;
      list->last = new_element;
    }
  }
}


/***********************************************************************
  QUOTE_IT   MACRO DEFINITION
  ===========================
Replace <parm> with "<parm>".  <parm> may be an arbitrary number of tokens
***********************************************************************/

#define QUOTE_IT( parm ) #parm

/***********************************************************************
  ELIST2IZE( CLASSNAME ) MACRO DEFINITION
  ======================================

CLASSNAME is assumed to be the name of a class which has a baseclass of
ELIST2_LINK.

NOTE:  Because we dont use virtual functions in the list code, the list code
will NOT work correctly for classes derived from this.

The macro generates:
  - An element deletion function:      CLASSNAME##_zapper
  - An element serialiser function"    CLASSNAME##_serialiser
  - An element de-serialiser function" CLASSNAME##_de_serialiser
  - An E_LIST2 subclass:	CLASSNAME##_LIST
  - An E_LIST2_ITERATOR subclass:
              CLASSNAME##_IT

NOTE: Generated names are DELIBERATELY designed to clash with those for
ELISTIZE but NOT with those for CLISTIZE and CLIST2IZE

Four macros are provided: ELIST2IZE, ELIST2IZE_S, ELIST2IZEH and ELIST2IZEH_S
The ...IZEH macros just define the class names for use in .h files
The ...IZE macros define the code use in .c files
The _S versions define lists which can be serialised.  They assume that
the make_serialise() macro is used in the list element class derived from
ELIST2_LINK to define serialise() and de_serialise() members for the list
elements.
***********************************************************************/

/***********************************************************************
  ELIST2IZEH( CLASSNAME )  and  ELIST2IZEH_S( CLASSNAME ) MACROS

These macros are constructed from 3 fragments ELIST2IZEH_A, ELIST2IZEH_B and
ELIST2IZEH_C.  ELIST2IZEH is simply a concatenation of these parts.
ELIST2IZEH_S has some additional bits thrown in the gaps.
***********************************************************************/

#define ELIST2IZEH_A( CLASSNAME )													\
                                                                                                        \
extern void			CLASSNAME##_zapper(			/*delete a link*/		\
ELIST2_LINK*				link);						/*link to delete*/

#define ELIST2IZEH_B( CLASSNAME )													\
                                                                                                        \
/***********************************************************************		\
*							CLASS - CLASSNAME##_LIST																	\
*																										\
*							List class for class CLASSNAME															\
*																										\
**********************************************************************/			\
                                                                                                        \
class  				CLASSNAME##_LIST : public ELIST2							\
{																										\
public:																								\
                            CLASSNAME##_LIST():ELIST2() {} \
                                                        /* constructor */		\
                                                                                                        \
                            CLASSNAME##_LIST(			/* dont construct */ \
    const CLASSNAME##_LIST&)							/*by initial assign*/\
    { DONT_CONSTRUCT_LIST_BY_COPY.error( QUOTE_IT( CLASSNAME##_LIST ),      \
                                                        ABORT, NULL ); }							\
                                                                                                        \
void						clear()						/* delete elements */\
    { ELIST2::internal_clear( &CLASSNAME##_zapper ); }								\
                                                                                                        \
                                    ~CLASSNAME##_LIST()	/* destructor */		\
    { clear(); }																				\
\
/* Become a deep copy of src_list*/ \
void deep_copy(const CLASSNAME##_LIST* src_list, \
               CLASSNAME* (*copier)(const CLASSNAME*)); \
\
void						operator=(					/* prevent assign */	\
    const CLASSNAME##_LIST&)																\
    { DONT_ASSIGN_LISTS.error( QUOTE_IT( CLASSNAME##_LIST ),						\
                                            ABORT, NULL ); }

#define ELIST2IZEH_C( CLASSNAME )													\
};																										\
                                                                                                        \
                                                                                                        \
                                                                                                        \
/***********************************************************************		\
*							CLASS - CLASSNAME##_IT																		\
*																										\
*							Iterator class for class CLASSNAME##_LIST											\
*																										\
*  Note: We don't need to coerce pointers to member functions input				\
*  parameters as these are automatically converted to the type of the base		\
*  type. ("A ptr to a class may be converted to a pointer to a public base		\
*  class of that class")																		\
**********************************************************************/			\
                                                                                                        \
class  				CLASSNAME##_IT : public ELIST2_ITERATOR				\
{																										\
public:																								\
                                CLASSNAME##_IT():ELIST2_ITERATOR(){}					\
                                                                                                        \
                                CLASSNAME##_IT(												\
CLASSNAME##_LIST*			list):ELIST2_ITERATOR(list){}								\
                                                                                                        \
    CLASSNAME*			data()															\
        { return (CLASSNAME*) ELIST2_ITERATOR::data(); }								\
                                                                                                        \
    CLASSNAME*			data_relative(													\
    inT8					offset)															\
        { return (CLASSNAME*) ELIST2_ITERATOR::data_relative( offset ); }		\
                                                                                                        \
    CLASSNAME*			forward()														\
        { return (CLASSNAME*) ELIST2_ITERATOR::forward(); }							\
                                                                                                        \
    CLASSNAME*			backward()														\
        { return (CLASSNAME*) ELIST2_ITERATOR::backward(); }						\
                                                                                                        \
    CLASSNAME*			extract()														\
        { return (CLASSNAME*) ELIST2_ITERATOR::extract(); }							\
                                                                                                        \
    CLASSNAME*			move_to_first()												\
        { return (CLASSNAME*) ELIST2_ITERATOR::move_to_first(); }					\
                                                                                                        \
    CLASSNAME*			move_to_last()													\
        { return (CLASSNAME*) ELIST2_ITERATOR::move_to_last(); }					\
};

#define ELIST2IZEH( CLASSNAME )														\
                                                                                                        \
ELIST2IZEH_A( CLASSNAME )																		\
                                                                                                        \
ELIST2IZEH_B( CLASSNAME )																		\
                                                                                                        \
ELIST2IZEH_C( CLASSNAME )

#define ELIST2IZEH_S( CLASSNAME )													\
                                                                                                        \
ELIST2IZEH_A( CLASSNAME )																		\
                                                                                                        \
extern  void			CLASSNAME##_serialiser(										\
FILE*						f,																	\
ELIST2_LINK*				element);														\
                                                                                                        \
extern  ELIST2_LINK*	CLASSNAME##_de_serialiser(								\
FILE*						f);																\
                                                                                                        \
ELIST2IZEH_B( CLASSNAME )																		\
                                                                                                        \
    void					dump(						/* dump to file */   \
    FILE*					f)																	\
    { ELIST2::internal_dump( f, &CLASSNAME##_serialiser );}						\
                                                                                                        \
    void					de_dump(					/* get from file */  \
    FILE*					f)																	\
    { ELIST2::internal_de_dump( f, &CLASSNAME##_de_serialiser );}				\
                                                                                                        \
make_serialise( CLASSNAME##_LIST )													\
                                                                                                        \
ELIST2IZEH_C( CLASSNAME )

/***********************************************************************
  ELIST2IZE( CLASSNAME )  and   ELIST2IZE_S( CLASSNAME )  MACROS
ELIST2IZE_S is a simple extension to ELIST2IZE
***********************************************************************/

#define ELIST2IZE( CLASSNAME )                                                \
                                                                                                        \
/***********************************************************************		\
*							CLASSNAME##_zapper																			\
*																										\
*  A function which can delete a CLASSNAME element.  This is passed to the		\
*  generic clear list member function so that when a list is cleared the		\
*  elements on the list are properly destroyed from the base class, even		\
*  though we dont use a virtual destructor function.									\
**********************************************************************/			\
                                                                                                        \
void					CLASSNAME##_zapper(			/*delete a link*/		\
ELIST2_LINK*				link)						/*link to delete*/	\
{																										\
delete (CLASSNAME *) link;																	\
}																										\
\
/* Become a deep copy of src_list*/ \
void CLASSNAME##_LIST::deep_copy(const CLASSNAME##_LIST* src_list, \
               CLASSNAME* (*copier)(const CLASSNAME*)) { \
\
  CLASSNAME##_IT from_it(const_cast<CLASSNAME##_LIST*>(src_list)); \
  CLASSNAME##_IT to_it(this); \
\
  for (from_it.mark_cycle_pt(); !from_it.cycled_list(); from_it.forward()) \
    to_it.add_after_then_move((*copier)(from_it.data())); \
}

#define ELIST2IZE_S(CLASSNAME) \
\
ELIST2IZE(CLASSNAME) \
\
/***********************************************************************		\
*							CLASSNAME##_serialiser																			\
*																										\
*  A function which can serialise an element												\
*  This is passed to the generic dump member function so that when a list is  \
*  serialised the elements on the list are properly serialised.					\
**********************************************************************/			\
\
void	CLASSNAME##_serialiser(FILE* f, ELIST2_LINK* element) { \
  reinterpret_cast<CLASSNAME*>(element)->serialise(f); \
} \
\
/***********************************************************************		\
*							CLASSNAME##_de_serialiser																		\
*																										\
*  A function which can de-serialise an element											\
*  This is passed to the generic de-dump member function so that when a list  \
*  is de-serialised the elements on the list are properly de-serialised.		\
**********************************************************************/			\
\
 ELIST2_LINK* CLASSNAME##_de_serialiser(FILE* f) { \
  return reinterpret_cast<ELIST2_LINK*>(CLASSNAME::de_serialise(f)); \
}
/////////////////////////////////////////////////////////////////elst2/////////////////////////////////

/////////////////////////////////////////////////////////////////elst/////////////////////////////////
class ELIST_ITERATOR;

/**********************************************************************
This module implements list classes and iterators.
The following list types and iterators are provided:

  List type        List Class      Iterator Class     Element Class
  ---------         ----------      --------------      -------------

    Embedded list       ELIST
              ELIST_ITERATOR
              ELIST_LINK
    (Single linked)

    Embedded list       ELIST2
              ELIST2_ITERATOR
              ELIST2_LINK
    (Double linked)

    Cons List           CLIST
              CLIST_ITERATOR
              CLIST_LINK
    (Single linked)

    Cons List           CLIST2
              CLIST2_ITERATOR
              CLIST2_LINK
    (Double linked)

An embedded list is where the list pointers are provided by a generic class.
Data types to be listed inherit from the generic class.  Data is thus linked
in only ONE list at any one time.

A cons list has a separate structure for a "cons cell".  This contains the
list pointer(s) AND a pointer to the data structure held on the list.  A
structure can be on many cons lists at the same time, and the structure does
not need to inherit from any generic class in order to be on the list.

The implementation of lists is very careful about space and speed overheads.
This is why many embedded lists are provided. The same concerns mean that
in-line type coercion is done, rather than use virtual functions.  This is
cumbersome in that each data type to be listed requires its own iterator and
list class - though macros can gererate these.  It also prevents heterogenous
lists.
**********************************************************************/

/**********************************************************************
 *                          CLASS - ELIST_LINK
 *
 *                          Generic link class for singly linked lists with embedded links
 *
 *  Note:  No destructor - elements are assumed to be destroyed EITHER after
 *  they have been extracted from a list OR by the ELIST destructor which
 *  walks the list.
 **********************************************************************/

class ELIST_LINK
{
    friend class ELIST_ITERATOR;
    friend class ELIST;

    ELIST_LINK *next;

public:
    ELIST_LINK()
    {
        next = NULL;
    }
    //constructor

    //copy constructor
    ELIST_LINK(const ELIST_LINK &)
    {
        //dont copy link
        next = NULL;
    }

    //dont copy links
    void operator= (const ELIST_LINK &)
    {
        next = NULL;
    }

    //serialise to ascii
    void serialise_asc(FILE *f);

    //de-serialise from ascii
    void de_serialise_asc(FILE *f);

    /* NOTE that none of the serialise member functions are required for
    ELIST_LINKS as they are never serialised.  (We demand that the derived
    class terminates recursion - just to make sure that it defines the member
    functions anyway.)
    */
};

/**********************************************************************
 * CLASS - ELIST
 *
 * Generic list class for singly linked lists with embedded links
 **********************************************************************/

class ELIST
{
    friend class ELIST_ITERATOR;

    ELIST_LINK *last;              //End of list

    //(Points to head)
    ELIST_LINK *First()
    {
        // return first
        return last ? last->next : NULL;
    }

public:
    //constructor
    ELIST()
    {
        last = NULL;
    }

    virtual ~ELIST()
    {
        // Empty
    }

    //destroy all links         //ptr to zapper functn
    void internal_clear(void (*zapper) (ELIST_LINK *));

    bool empty()
    {
        //is list empty?
        return !last;
    }

    bool singleton()
    {
        return last ? (last == last->next) : FALSE;
    }

    //dangerous!!
    void shallow_copy(ELIST *from_list)
    {
        //beware destructors!!
        last = from_list->last;
    }

    //ptr to copier functn
    void internal_deep_copy (ELIST_LINK * (*copier) (ELIST_LINK *), const ELIST * list); //list being copied

    //to this list          //from list start
    void assign_to_sublist(ELIST_ITERATOR *start_it, ELIST_ITERATOR *end_it);   //from list end

    inT32 length();  //# elements in list

    //sort elements          //comparison routine
    void sort (int comparator(const void *, const void *));

    // Assuming list has been sorted already, insert new_link to
    // keep the list sorted according to the same comparison function.
    // Comparision function is the same as used by sort, i.e. uses double
    // indirection. Time is O(1) to add to beginning or end.
    // Time is linear to add pre-sorted items to an empty list.
    void add_sorted(int comparator(const void*, const void*), ELIST_LINK* new_link);

    //serialise each elem //to this file   //using this function
    void internal_dump (FILE * f,          void element_serialiser(FILE *, ELIST_LINK *));

    //de_serial each elem  //from this file    //using this function
    void internal_de_dump (FILE * f,           ELIST_LINK * element_de_serialiser(FILE *));

    void prep_serialise();  //change last to count

    /*  Note that dump() and de_dump() are not required as calls to dump/de_dump a
      list class should be handled by a class derived from this.

      make_serialise is not required for a similar reason.
    */
};

/***********************************************************************
 *                          CLASS - ELIST_ITERATOR
 *
 *                          Generic iterator class for singly linked lists with embedded links
 **********************************************************************/

class ELIST_ITERATOR
{
    friend void ELIST::assign_to_sublist(ELIST_ITERATOR *, ELIST_ITERATOR *);

    ELIST *list;                   //List being iterated
    ELIST_LINK *prev;              //prev element
    ELIST_LINK *current;           //current element
    ELIST_LINK *next;              //next element
    bool ex_current_was_last;     //current extracted

    //was end of list
    bool ex_current_was_cycle_pt; //current extracted

    //was cycle point
    ELIST_LINK *cycle_pt;          //point we are cycling

    //the list to.
    bool started_cycling;         //Have we moved off
    //the start?

    //from this current...
    ELIST_LINK *extract_sublist(ELIST_ITERATOR *other_it);  //to other current

public:
    //constructor
    ELIST_ITERATOR()
    {
        list = NULL;
    }                            //unassigned list

    //constructor
    ELIST_ITERATOR(ELIST *list_to_iterate);

    //change list
    void set_to_list(ELIST *list_to_iterate);

    //add after current &
    void add_after_then_move(ELIST_LINK *new_link);  //move to new

    //add after current &
    void add_after_stay_put(ELIST_LINK *new_link);  //stay at current

    //add before current &
    void add_before_then_move(ELIST_LINK *new_link);  //move to new

    //add before current &
    void add_before_stay_put(ELIST_LINK *new_link);  //stay at current

    //add a list &
    void add_list_after(ELIST *list_to_add);  //stay at current

    //add a list &
    void add_list_before(ELIST *list_to_add);  //move to it 1st item

    //get current data
    ELIST_LINK *data()
    {
#ifndef NDEBUG
        if (!list)
            NO_LIST.error ("ELIST_ITERATOR::data", ABORT, NULL);
        if (!current)
            NULL_DATA.error ("ELIST_ITERATOR::data", ABORT, NULL);
#endif
        return current;
    }

    //get data + or - ...
    ELIST_LINK *data_relative(inT8 offset);  //offset from current

    ELIST_LINK *forward();  //move to next element

    ELIST_LINK *extract();  //remove from list

    ELIST_LINK *move_to_first();  //go to start of list

    ELIST_LINK *move_to_last();  //go to end of list

    void mark_cycle_pt();  //remember current

    //is list empty?
    bool empty()
    {
#ifndef NDEBUG
        if (!list)
            NO_LIST.error ("ELIST_ITERATOR::empty", ABORT, NULL);
#endif
        return list->empty ();
    }

    bool current_extracted()
    {
        //current extracted?
        return !current;
    }

    bool at_first();  //Current is first?

    bool at_last();  //Current is last?

    bool cycled_list();  //Completed a cycle?

    //add at end &
    void add_to_end(ELIST_LINK *new_link);  //dont move

    //positions of 2 links
    void exchange(ELIST_ITERATOR *other_it);  //other iterator

    inT32 length();  //# elements in list

    //sort elements         //comparison routine
    void sort(int comparator(const void *, const void *));

};

/***********************************************************************
 *                          ELIST_ITERATOR::set_to_list
 *
 *  (Re-)initialise the iterator to point to the start of the list_to_iterate
 *  over.
 **********************************************************************/

//change list
inline void ELIST_ITERATOR::set_to_list(ELIST *list_to_iterate)
{
#ifndef NDEBUG
    if (!this)
    {
        NULL_OBJECT.error ("ELIST_ITERATOR::set_to_list", ABORT, NULL);
    }

    if (!list_to_iterate)
    {
        BAD_PARAMETER.error ("ELIST_ITERATOR::set_to_list", ABORT, "list_to_iterate is NULL");
    }
#endif

    list = list_to_iterate;
    prev = list->last;
    current = list->First();
    next = current ? current->next : NULL;
    cycle_pt = NULL;               //await explicit set
    started_cycling = FALSE;
    ex_current_was_last = FALSE;
    ex_current_was_cycle_pt = FALSE;
}


/***********************************************************************
 *                          ELIST_ITERATOR::ELIST_ITERATOR
 *
 *  CONSTRUCTOR - set iterator to specified list;
 **********************************************************************/

inline ELIST_ITERATOR::ELIST_ITERATOR(ELIST *list_to_iterate)
{
    set_to_list(list_to_iterate);
}


/***********************************************************************
 *                          ELIST_ITERATOR::add_after_then_move
 *
 *  Add a new element to the list after the current element and move the
 *  iterator to the new element.
 **********************************************************************/

// element to add
inline void ELIST_ITERATOR::add_after_then_move(ELIST_LINK *new_element)
{
#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error ("ELIST_ITERATOR::add_after_then_move", ABORT, NULL);
    if (!list)
        NO_LIST.error ("ELIST_ITERATOR::add_after_then_move", ABORT, NULL);
    if (!new_element)
        BAD_PARAMETER.error ("ELIST_ITERATOR::add_after_then_move", ABORT, "new_element is NULL");
    if (new_element->next)
        STILL_LINKED.error ("ELIST_ITERATOR::add_after_then_move", ABORT, NULL);
#endif

    if (list->empty())
    {
        new_element->next = new_element;
        list->last = new_element;
        prev = next = new_element;
    }
    else
    {
        new_element->next = next;

        if (current)
        {
            //not extracted
            current->next = new_element;
            prev = current;
            if (current == list->last)
            {
                list->last = new_element;
            }
        }
        else
        {
            //current extracted
            prev->next = new_element;

            if (ex_current_was_last)
            {
                list->last = new_element;
            }

            if (ex_current_was_cycle_pt)
            {
                cycle_pt = new_element;
            }
        }
    }

    current = new_element;
}


/***********************************************************************
 *                          ELIST_ITERATOR::add_after_stay_put
 *
 *  Add a new element to the list after the current element but do not move
 *  the iterator to the new element.
 **********************************************************************/

// element to add
inline void ELIST_ITERATOR::add_after_stay_put(ELIST_LINK *new_element)
{
#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error ("ELIST_ITERATOR::add_after_stay_put", ABORT, NULL);
    if (!list)
        NO_LIST.error ("ELIST_ITERATOR::add_after_stay_put", ABORT, NULL);
    if (!new_element)
        BAD_PARAMETER.error ("ELIST_ITERATOR::add_after_stay_put", ABORT,
                             "new_element is NULL");
    if (new_element->next)
        STILL_LINKED.error ("ELIST_ITERATOR::add_after_stay_put", ABORT, NULL);
#endif

    if (list->empty ())
    {
        new_element->next = new_element;
        list->last = new_element;
        prev = next = new_element;
        ex_current_was_last = FALSE;
        current = NULL;
    }
    else
    {
        new_element->next = next;

        if (current)
        {
            //not extracted
            current->next = new_element;

            if (prev == current)
            {
                prev = new_element;
            }

            if (current == list->last)
            {
                list->last = new_element;
            }
        }
        else
        {
            //current extracted
            prev->next = new_element;

            if (ex_current_was_last)
            {
                list->last = new_element;
                ex_current_was_last = FALSE;
            }
        }
        next = new_element;
    }
}


/***********************************************************************
 *                          ELIST_ITERATOR::add_before_then_move
 *
 *  Add a new element to the list before the current element and move the
 *  iterator to the new element.
 **********************************************************************/

// element to add
inline void ELIST_ITERATOR::add_before_then_move(ELIST_LINK *new_element)
{
#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error ("ELIST_ITERATOR::add_before_then_move", ABORT, NULL);
    if (!list)
        NO_LIST.error ("ELIST_ITERATOR::add_before_then_move", ABORT, NULL);
    if (!new_element)
        BAD_PARAMETER.error ("ELIST_ITERATOR::add_before_then_move", ABORT,
                             "new_element is NULL");
    if (new_element->next)
        STILL_LINKED.error ("ELIST_ITERATOR::add_before_then_move", ABORT, NULL);
#endif

    if (list->empty ())
    {
        new_element->next = new_element;
        list->last = new_element;
        prev = next = new_element;
    }
    else
    {
        prev->next = new_element;
        if (current)
        {
            //not extracted
            new_element->next = current;
            next = current;
        }
        else
        {
            //current extracted
            new_element->next = next;

            if (ex_current_was_last)
            {
                list->last = new_element;
            }

            if (ex_current_was_cycle_pt)
            {
                cycle_pt = new_element;
            }
        }
    }
    current = new_element;
}


/***********************************************************************
 *                          ELIST_ITERATOR::add_before_stay_put
 *
 *  Add a new element to the list before the current element but dont move the
 *  iterator to the new element.
 **********************************************************************/

// element to add
inline void ELIST_ITERATOR::add_before_stay_put(ELIST_LINK *new_element)
{
#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error ("ELIST_ITERATOR::add_before_stay_put", ABORT, NULL);
    if (!list)
        NO_LIST.error ("ELIST_ITERATOR::add_before_stay_put", ABORT, NULL);
    if (!new_element)
        BAD_PARAMETER.error ("ELIST_ITERATOR::add_before_stay_put", ABORT,
                             "new_element is NULL");
    if (new_element->next)
        STILL_LINKED.error ("ELIST_ITERATOR::add_before_stay_put", ABORT, NULL);
#endif

    if (list->empty ())
    {
        new_element->next = new_element;
        list->last = new_element;
        prev = next = new_element;
        ex_current_was_last = TRUE;
        current = NULL;
    }
    else
    {
        prev->next = new_element;

        if (current)
        {
            //not extracted
            new_element->next = current;

            if (next == current)
            {
                next = new_element;
            }
        }
        else
        {
            //current extracted
            new_element->next = next;
            if (ex_current_was_last)
            {
                list->last = new_element;
            }
        }
        prev = new_element;
    }
}


/***********************************************************************
 *                          ELIST_ITERATOR::add_list_after
 *
 *  Insert another list to this list after the current element but dont move the
 *  iterator.
 **********************************************************************/

inline void ELIST_ITERATOR::add_list_after(ELIST *list_to_add)
{
#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error ("ELIST_ITERATOR::add_list_after", ABORT, NULL);
    if (!list)
        NO_LIST.error ("ELIST_ITERATOR::add_list_after", ABORT, NULL);
    if (!list_to_add)
        BAD_PARAMETER.error ("ELIST_ITERATOR::add_list_after", ABORT,
                             "list_to_add is NULL");
#endif

    if (!list_to_add->empty ())
    {
        if (list->empty ())
        {
            list->last = list_to_add->last;
            prev = list->last;
            next = list->First ();
            ex_current_was_last = TRUE;
            current = NULL;
        }
        else
        {
            if (current)
            {
                //not extracted
                current->next = list_to_add->First ();

                if (current == list->last)
                {
                    list->last = list_to_add->last;
                }
                list_to_add->last->next = next;
                next = current->next;
            }
            else
            {
                //current extracted
                prev->next = list_to_add->First ();

                if (ex_current_was_last)
                {
                    list->last = list_to_add->last;
                    ex_current_was_last = FALSE;
                }

                list_to_add->last->next = next;
                next = prev->next;
            }
        }
        list_to_add->last = NULL;
    }
}


/***********************************************************************
 *                          ELIST_ITERATOR::add_list_before
 *
 *  Insert another list to this list before the current element. Move the
 *  iterator to the start of the inserted elements
 *  iterator.
 **********************************************************************/

inline void ELIST_ITERATOR::add_list_before(ELIST *list_to_add)
{
#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error ("ELIST_ITERATOR::add_list_before", ABORT, NULL);
    if (!list)
        NO_LIST.error ("ELIST_ITERATOR::add_list_before", ABORT, NULL);
    if (!list_to_add)
        BAD_PARAMETER.error ("ELIST_ITERATOR::add_list_before", ABORT,
                             "list_to_add is NULL");
#endif

    if (!list_to_add->empty ())
    {
        if (list->empty ())
        {
            list->last = list_to_add->last;
            prev = list->last;
            current = list->First ();
            next = current->next;
            ex_current_was_last = FALSE;
        }
        else
        {
            prev->next = list_to_add->First ();
            if (current)
            {
                //not extracted
                list_to_add->last->next = current;
            }
            else
            {
                //current extracted
                list_to_add->last->next = next;

                if (ex_current_was_last)
                {
                    list->last = list_to_add->last;
                }

                if (ex_current_was_cycle_pt)
                {
                    cycle_pt = prev->next;
                }
            }
            current = prev->next;
            next = current->next;
        }
        list_to_add->last = NULL;
    }
}


/***********************************************************************
 *                          ELIST_ITERATOR::extract
 *
 *  Do extraction by removing current from the list, returning it to the
 *  caller, but NOT updating the iterator.  (So that any calling loop can do
 *  this.)   The iterator's current points to NULL.  If the extracted element
 *  is to be deleted, this is the callers responsibility.
 **********************************************************************/

inline ELIST_LINK *ELIST_ITERATOR::extract()
{
    ELIST_LINK *extracted_link;

#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error ("ELIST_ITERATOR::extract", ABORT, NULL);
    if (!list)
        NO_LIST.error ("ELIST_ITERATOR::extract", ABORT, NULL);
    if (!current)                  //list empty or
        //element extracted
        NULL_CURRENT.error ("ELIST_ITERATOR::extract",
                            ABORT, NULL);
#endif

    if (list->singleton())
    {
        // Special case where we do need to change the iterator.
        prev = next = list->last = NULL;
    }
    else
    {
        prev->next = next;           //remove from list

        if (current == list->last)
        {
            list->last = prev;
            ex_current_was_last = TRUE;
        }
        else
        {
            ex_current_was_last = FALSE;
        }
    }

    // Always set ex_current_was_cycle_pt so an add/forward will work in a loop.
    ex_current_was_cycle_pt = (current == cycle_pt) ? TRUE : FALSE;
    extracted_link = current;
    extracted_link->next = NULL;   //for safety
    current = NULL;

    return extracted_link;
}


/***********************************************************************
 *                          ELIST_ITERATOR::move_to_first()
 *
 *  Move current so that it is set to the start of the list.
 *  Return data just in case anyone wants it.
 **********************************************************************/

inline ELIST_LINK *ELIST_ITERATOR::move_to_first()
{
#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error ("ELIST_ITERATOR::move_to_first", ABORT, NULL);
    if (!list)
        NO_LIST.error ("ELIST_ITERATOR::move_to_first", ABORT, NULL);
#endif

    current = list->First();
    prev = list->last;
    next = current ? current->next : NULL;
    return current;
}


/***********************************************************************
 *                          ELIST_ITERATOR::mark_cycle_pt()
 *
 *  Remember the current location so that we can tell whether we've returned
 *  to this point later.
 *
 *  If the current point is deleted either now, or in the future, the cycle
 *  point will be set to the next item which is set to current.  This could be
 *  by a forward, add_after_then_move or add_after_then_move.
 **********************************************************************/

inline void ELIST_ITERATOR::mark_cycle_pt()
{
#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error ("ELIST_ITERATOR::mark_cycle_pt", ABORT, NULL);
    if (!list)
        NO_LIST.error ("ELIST_ITERATOR::mark_cycle_pt", ABORT, NULL);
#endif

    if (current)
    {
        cycle_pt = current;
    }
    else
    {
        ex_current_was_cycle_pt = TRUE;
    }

    started_cycling = FALSE;
}


/***********************************************************************
 *                          ELIST_ITERATOR::at_first()
 *
 *  Are we at the start of the list?
 *
 **********************************************************************/

inline bool ELIST_ITERATOR::at_first()
{
#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error ("ELIST_ITERATOR::at_first", ABORT, NULL);
    if (!list)
        NO_LIST.error ("ELIST_ITERATOR::at_first", ABORT, NULL);
#endif

    //we're at a deleted
    return ((list->empty ()) || (current == list->First ()) || ((current == NULL) && (prev == list->last) &&      //NON-last pt between
                                                                !ex_current_was_last));      //first and last
}


/***********************************************************************
 *                          ELIST_ITERATOR::at_last()
 *
 *  Are we at the end of the list?
 *
 **********************************************************************/

inline bool ELIST_ITERATOR::at_last()
{
#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error ("ELIST_ITERATOR::at_last", ABORT, NULL);
    if (!list)
        NO_LIST.error ("ELIST_ITERATOR::at_last", ABORT, NULL);
#endif

    //we're at a deleted
    return ((list->empty ()) || (current == list->last) || ((current == NULL) &&
                                                            (prev == list->last) &&      //last point between
                                                            ex_current_was_last));       //first and last
}


/***********************************************************************
 *                          ELIST_ITERATOR::cycled_list()
 *
 *  Have we returned to the cycle_pt since it was set?
 *
 **********************************************************************/

inline bool ELIST_ITERATOR::cycled_list()
{
#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error ("ELIST_ITERATOR::cycled_list", ABORT, NULL);
    if (!list)
        NO_LIST.error ("ELIST_ITERATOR::cycled_list", ABORT, NULL);
#endif

    return ((list->empty ()) || ((current == cycle_pt) && started_cycling));

}


/***********************************************************************
 *                          ELIST_ITERATOR::length()
 *
 *  Return the length of the list
 *
 **********************************************************************/

inline inT32 ELIST_ITERATOR::length()
{
#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error ("ELIST_ITERATOR::length", ABORT, NULL);
    if (!list)
        NO_LIST.error ("ELIST_ITERATOR::length", ABORT, NULL);
#endif

    return list->length ();
}


/***********************************************************************
 *                          ELIST_ITERATOR::sort()
 *
 *  Sort the elements of the list, then reposition at the start.
 *
 **********************************************************************/

//sort elements                      //comparison routine
inline void ELIST_ITERATOR::sort(int comparator(const void *, const void *))
{
#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error("ELIST_ITERATOR::sort", ABORT, NULL);
    if (!list)
        NO_LIST.error("ELIST_ITERATOR::sort", ABORT, NULL);
#endif

    list->sort(comparator);
    move_to_first();
}


/***********************************************************************
 *                          ELIST_ITERATOR::add_to_end
 *
 *  Add a new element to the end of the list without moving the iterator.
 *  This is provided because a single linked list cannot move to the last as
 *  the iterator couldn't set its prev pointer.  Adding to the end is
 *  essential for implementing
              queues.
**********************************************************************/

// element to add
inline void ELIST_ITERATOR::add_to_end(ELIST_LINK *new_element)
{
#ifndef NDEBUG
    if (!this)
        NULL_OBJECT.error ("ELIST_ITERATOR::add_to_end", ABORT, NULL);
    if (!list)
        NO_LIST.error ("ELIST_ITERATOR::add_to_end", ABORT, NULL);
    if (!new_element)
        BAD_PARAMETER.error ("ELIST_ITERATOR::add_to_end", ABORT,
                             "new_element is NULL");
    if (new_element->next)
        STILL_LINKED.error ("ELIST_ITERATOR::add_to_end", ABORT, NULL);
#endif

    if (this->at_last ())
    {
        this->add_after_stay_put (new_element);
    }
    else
    {
        if (this->at_first ())
        {
            this->add_before_stay_put (new_element);
            list->last = new_element;
        }
        else
        {
            //Iteratr is elsewhere
            new_element->next = list->last->next;
            list->last->next = new_element;
            list->last = new_element;
        }
    }
}
/////////////////////////////////////////////////////////////////elst/////////////////////////////////

//////////////////////////////////////////////////////////////memry/////////////////////////////////////////////

#define JUSTCHECKS      0        /*just check consistency */
#define MEMCHECKS     1          /*report totals */
#define FULLMEMCHECKS   2        /*report on all blocks */

#ifdef __MSW32__
#define NEWDELETE										/*replace new & delete*/\
    void					*operator new(				/*fast allocator*/\
    size_t					size,						/*size of object*/\
    const char*				file=NULL,					/*filename*/\
    inT32					line=0)						/*line number*/\
    {\
        return alloc_struct(size);						/*simple to do*/\
    }\
\
    void					operator delete(			/*fast destructor*/\
    void					*deadstruct,				/*thing to free*/\
    size_t					size)						/*sizeof struct*/\
    {\
        free_struct(deadstruct,size);					/*free it*/\
    }\

#define NEWDELETE2(name)								/*replace new & delete*/\
    void					*operator new(				/*fast allocator*/\
    size_t					size,						/*size of object*/\
    const char*				file=NULL,					/*filename*/\
    inT32					line=0)						/*line number*/\
    {\
        return alloc_struct(size,#name);				/*simple to do*/\
    }\
\
    void					operator delete(			/*fast destructor*/\
    void					*deadstruct,				/*thing to free*/\
    size_t					size)						/*sizeof struct*/\
    {\
        free_struct(deadstruct,size,#name);				/*free it*/\
    }\


#undef NEWDELETE
#define NEWDELETE
#undef NEWDELETE2
#define NEWDELETE2(name)

#else
#define NEWDELETE										/*replace new & delete*/\
    void					*operator new(				/*fast allocator*/\
    size_t					size)						/*size of object*/\
    {\
        return alloc_struct(size);						/*simple to do*/\
    }\
\
    void					operator delete(			/*fast destructor*/\
    void					*deadstruct,				/*thing to free*/\
    size_t					size)						/*sizeof struct*/\
    {\
        free_struct(deadstruct,size);					/*free it*/\
    }\

#define NEWDELETE2(name)								/*replace new & delete*/\
    void					*operator new(				/*fast allocator*/\
    size_t					size)						/*size of object*/\
    {\
        return alloc_struct(size,#name);				/*simple to do*/\
    }\
\
    void					operator delete(			/*fast destructor*/\
    void					*deadstruct,				/*thing to free*/\
    size_t					size)						/*sizeof struct*/\
    {\
        free_struct(deadstruct,size,#name);				/*free it*/\
    }\

#endif
/**********************************************************************
 * ALLOC_2D_ARRAY
 *
 * Create a dynamic 2D array.
 **********************************************************************/

#define ALLOC_2D_ARRAY(x,y,mem,ptrs,type)				/*make 2d array*/\
{ \
    inT32					TMP_i; \
    mem=(type*)alloc_mem((x)*(y)*sizeof(type));			/*get memory*/\
    ptrs=(type**)alloc_mem((x)*sizeof(type*));			/*get ptrs*/\
    for (TMP_i=0;TMP_i<(x);TMP_i++)\
        ptrs[TMP_i]=mem+(y)*TMP_i;						/*set ptrs*/\
} \

/**********************************************************************
 * FREE_2D_ARRAY
 *
 * Destroy a 2D array created by ALLOC_2D_ARRAY
 **********************************************************************/

#define FREE_2D_ARRAY(mem,ptrs)							/*free a 2D array*/\
{ \
    free_mem(mem);										/*free the memory*/\
    free_mem(ptrs);										/*and the ptrs*/\
} \

/**********************************************************************
 * ALLOC_BIG_2D_ARRAY
 *
 * Create a dynamic 2D array. Use a memory allocator that allows
 * allocation of bigger chunks.
 **********************************************************************/

#define ALLOC_BIG_2D_ARRAY(x,y,mem,ptrs,type)			/*make 2d array*/\
{ \
    inT32					TMP_i; \
    mem=(type*)alloc_big_mem((x)*(y)*sizeof(type));		/*get memory*/\
    ptrs=(type**)alloc_big_mem((x)*sizeof(type*));		/*get ptrs*/\
    for (TMP_i=0;TMP_i<(x);TMP_i++)\
        ptrs[TMP_i]=mem+(y)*TMP_i;						/*set ptrs*/\
} \

/**********************************************************************
 * FREE_BIG_2D_ARRAY
 *
 * Destroy a 2D array created by ALLOC_BIG_2D_ARRAY
 **********************************************************************/

#define FREE_BIG_2D_ARRAY(mem,ptrs)						/*free a 2D array*/\
{ \
    free_big_mem(mem);									/*free the memory*/\
    free_big_mem(ptrs);									/*and the ptrs*/\
} \

extern void check_mem(                     //check consistency
                             const char *string,  //context message
                             inT8 level           //level of check
                            );
                                 //allocate string
extern char *alloc_string(inT32 count  //no of chars required
                                );
extern void free_string(              //free a string
                               char *string  //string to free
                              );
                                 //allocate memory
extern void *alloc_struct (
inT32 count,                     //no of chars required
const char *name = NULL          //class name
);
extern void free_struct ( //free a structure
void *deadstruct,                //structure to free
inT32 count,                     //no of bytes
const char *name = NULL          //class name
);
extern void *alloc_mem_p(             //allocate permanent space
                                inT32 count  //block size to allocate
                               );
extern void *alloc_mem(             //get some memory
                              inT32 count  //no of bytes to get
                             );
                                 //get some memory
extern void *alloc_big_mem(inT32 count  //no of bytes to get
                                 );
                                 //get some memory
extern void *alloc_big_zeros(inT32 count  //no of bytes to get
                                   );
extern void free_mem(                //free mem from alloc_mem
                            void *oldchunk  //chunk to free
                           );
extern void free_big_mem(                //free mem from alloc_mem
                                void *oldchunk  //chunk to free
                               );
//////////////////////////////////////////////////////////////memry/////////////////////////////////////////////////////////////////////////////////////////////////memry/////////////////////////////////////////////

#define JUSTCHECKS      0        /*just check consistency */
#define MEMCHECKS     1          /*report totals */
#define FULLMEMCHECKS   2        /*report on all blocks */

#ifdef __MSW32__
#define NEWDELETE										/*replace new & delete*/\
    void					*operator new(				/*fast allocator*/\
    size_t					size,						/*size of object*/\
    const char*				file=NULL,					/*filename*/\
    inT32					line=0)						/*line number*/\
    {\
        return alloc_struct(size);						/*simple to do*/\
    }\
\
    void					operator delete(			/*fast destructor*/\
    void					*deadstruct,				/*thing to free*/\
    size_t					size)						/*sizeof struct*/\
    {\
        free_struct(deadstruct,size);					/*free it*/\
    }\

#define NEWDELETE2(name)								/*replace new & delete*/\
    void					*operator new(				/*fast allocator*/\
    size_t					size,						/*size of object*/\
    const char*				file=NULL,					/*filename*/\
    inT32					line=0)						/*line number*/\
    {\
        return alloc_struct(size,#name);				/*simple to do*/\
    }\
\
    void					operator delete(			/*fast destructor*/\
    void					*deadstruct,				/*thing to free*/\
    size_t					size)						/*sizeof struct*/\
    {\
        free_struct(deadstruct,size,#name);				/*free it*/\
    }\


#undef NEWDELETE
#define NEWDELETE
#undef NEWDELETE2
#define NEWDELETE2(name)

#else
#define NEWDELETE										/*replace new & delete*/\
    void					*operator new(				/*fast allocator*/\
    size_t					size)						/*size of object*/\
    {\
        return alloc_struct(size);						/*simple to do*/\
    }\
\
    void					operator delete(			/*fast destructor*/\
    void					*deadstruct,				/*thing to free*/\
    size_t					size)						/*sizeof struct*/\
    {\
        free_struct(deadstruct,size);					/*free it*/\
    }\

#define NEWDELETE2(name)								/*replace new & delete*/\
    void					*operator new(				/*fast allocator*/\
    size_t					size)						/*size of object*/\
    {\
        return alloc_struct(size,#name);				/*simple to do*/\
    }\
\
    void					operator delete(			/*fast destructor*/\
    void					*deadstruct,				/*thing to free*/\
    size_t					size)						/*sizeof struct*/\
    {\
        free_struct(deadstruct,size,#name);				/*free it*/\
    }\

#endif
/**********************************************************************
 * ALLOC_2D_ARRAY
 *
 * Create a dynamic 2D array.
 **********************************************************************/

#define ALLOC_2D_ARRAY(x,y,mem,ptrs,type)				/*make 2d array*/\
{ \
    inT32					TMP_i; \
    mem=(type*)alloc_mem((x)*(y)*sizeof(type));			/*get memory*/\
    ptrs=(type**)alloc_mem((x)*sizeof(type*));			/*get ptrs*/\
    for (TMP_i=0;TMP_i<(x);TMP_i++)\
        ptrs[TMP_i]=mem+(y)*TMP_i;						/*set ptrs*/\
} \

/**********************************************************************
 * FREE_2D_ARRAY
 *
 * Destroy a 2D array created by ALLOC_2D_ARRAY
 **********************************************************************/

#define FREE_2D_ARRAY(mem,ptrs)							/*free a 2D array*/\
{ \
    free_mem(mem);										/*free the memory*/\
    free_mem(ptrs);										/*and the ptrs*/\
} \

/**********************************************************************
 * ALLOC_BIG_2D_ARRAY
 *
 * Create a dynamic 2D array. Use a memory allocator that allows
 * allocation of bigger chunks.
 **********************************************************************/

#define ALLOC_BIG_2D_ARRAY(x,y,mem,ptrs,type)			/*make 2d array*/\
{ \
    inT32					TMP_i; \
    mem=(type*)alloc_big_mem((x)*(y)*sizeof(type));		/*get memory*/\
    ptrs=(type**)alloc_big_mem((x)*sizeof(type*));		/*get ptrs*/\
    for (TMP_i=0;TMP_i<(x);TMP_i++)\
        ptrs[TMP_i]=mem+(y)*TMP_i;						/*set ptrs*/\
} \

/**********************************************************************
 * FREE_BIG_2D_ARRAY
 *
 * Destroy a 2D array created by ALLOC_BIG_2D_ARRAY
 **********************************************************************/

#define FREE_BIG_2D_ARRAY(mem,ptrs)						/*free a 2D array*/\
{ \
    free_big_mem(mem);									/*free the memory*/\
    free_big_mem(ptrs);									/*and the ptrs*/\
} \

extern void check_mem(                     //check consistency
                             const char *string,  //context message
                             inT8 level           //level of check
                            );
                                 //allocate string
extern char *alloc_string(inT32 count  //no of chars required
                                );
extern void free_string(              //free a string
                               char *string  //string to free
                              );
                                 //allocate memory
extern void *alloc_struct (
inT32 count,                     //no of chars required
const char *name          //class name
);
extern void free_struct ( //free a structure
void *deadstruct,                //structure to free
inT32 count,                     //no of bytes
const char *name          //class name
);
extern void *alloc_mem_p(             //allocate permanent space
                                inT32 count  //block size to allocate
                               );
extern void *alloc_mem(             //get some memory
                              inT32 count  //no of bytes to get
                             );
                                 //get some memory
extern void *alloc_big_mem(inT32 count  //no of bytes to get
                                 );
                                 //get some memory
extern void *alloc_big_zeros(inT32 count  //no of bytes to get
                                   );
extern void free_mem(                //free mem from alloc_mem
                            void *oldchunk  //chunk to free
                           );
extern void free_big_mem(                //free mem from alloc_mem
                                void *oldchunk  //chunk to free
                               );
//////////////////////////////////////////////////////////////memry///////////////////////////////////

//////////////////////////////////////////////////////////////serialis/////////////////////////////
/* **************************************************************************

These are the only routines that write/read data to/from the serialisation.

"serialise_bytes" and "de_serialise_bytes" are used to serialise NON class
items.  The "make_serialise" macro generates "serialise" and "de_serialise"
member functions for the class name specified in the macro parameter.

************************************************************************** */

extern void *de_serialise_bytes(FILE *f, int size);
extern void serialise_bytes(FILE *f, void *ptr, int size);
extern void serialise_INT32(FILE *f, inT32 the_int);
extern inT32 de_serialise_INT32(FILE *f);
extern void serialise_FLOAT64(FILE *f, double the_float);
extern double de_serialise_FLOAT64(FILE *f);
// Switch endinan.
extern uinT64 reverse64(uinT64);
extern uinT32 reverse32(uinT32);
extern uinT16 reverse16(uinT16);

/***********************************************************************
  QUOTE_IT   MACRO DEFINITION
  ===========================
Replace <parm> with "<parm>".  <parm> may be an arbitrary number of tokens
***********************************************************************/

#define QUOTE_IT( parm ) #parm

#define make_serialise( CLASSNAME )                                            \
                                                                               \
  NEWDELETE2(CLASSNAME)                                                        \
                                                                               \
void            serialise(                                                     \
  FILE*          f)                                                            \
{                                                                              \
  CLASSNAME*      shallow_copy;                                                \
                                                                               \
  shallow_copy = (CLASSNAME*) alloc_struct( sizeof( *this ) );                 \
    memmove( shallow_copy, this, sizeof( *this ) );                            \
                                                                               \
  shallow_copy->prep_serialise();                                              \
    if (fwrite( (char*) shallow_copy, sizeof( *shallow_copy ), 1, f ) != 1)    \
    WRITEFAILED.error( QUOTE_IT( CLASSNAME::serialise ),                       \
                  ABORT, NULL );                                               \
                                                                               \
  free_struct( shallow_copy, sizeof( *this ) );                                \
    this->dump( f );                                                           \
}                                                                              \
                                                                               \
  static CLASSNAME*    de_serialise(                                           \
  FILE*          f)                                                            \
{                                                                              \
  CLASSNAME*      restored;                                                    \
                                                                               \
    restored = (CLASSNAME*) alloc_struct( sizeof( CLASSNAME ) );               \
    if (fread( (char*) restored, sizeof( CLASSNAME ), 1, f ) != 1)             \
    READFAILED.error( QUOTE_IT( CLASSNAME::de_serialise ),                     \
                  ABORT, NULL );                                               \
                                                                               \
  restored->de_dump( f );                                                      \
    return restored;                                                           \
}
//////////////////////////////////////////////////////////////serialis/////////////////////////////////

//////////////////////////////////////////////////////////////tprintf//////////////////////////////////
class BOOL_VARIABLE;
class STRING_VARIABLE;
class INT_VARIABLE;
class double_VARIABLE;

/* SECURE_NAMES is defined in senames.h when necessary */
#ifdef SECURE_NAMES

#define INT_VAR(name,val,comment)           /*make INT_VARIABLE*/\
    INT_VARIABLE      name(val,"","")

#define BOOL_VAR(name,val,comment)            /*make BOOL_VARIABLE*/\
    BOOL_VARIABLE     name(val,"","")

#define STRING_VAR(name,val,comment)          /*make STRING_VARIABLE*/\
    STRING_VARIABLE     name(val,"","")

#define double_VAR(name,val,comment)          /*make double_VARIABLE*/\
    double_VARIABLE     name(val,"","")

#else

#define INT_VAR(name,val,comment)           /*make INT_VARIABLE*/\
    INT_VARIABLE      name(val,#name,comment)

#define BOOL_VAR(name,val,comment)            /*make BOOL_VARIABLE*/\
    BOOL_VARIABLE     name(val,#name,comment)

#define STRING_VAR(name,val,comment)          /*make STRING_VARIABLE*/\
    STRING_VARIABLE     name(val,#name,comment)

#define double_VAR(name,val,comment)          /*make double_VARIABLE*/\
    double_VARIABLE     name(val,#name,comment)
#endif

#define INT_VAR_H(name,val,comment)           /*declare one*/\
    INT_VARIABLE      name

#define BOOL_VAR_H(name,val,comment)          /*declare one*/\
    BOOL_VARIABLE     name

#define STRING_VAR_H(name,val,comment)          /*declare one*/\
    STRING_VARIABLE     name

#define double_VAR_H(name,val,comment)          /*declare one*/\
    double_VARIABLE     name

#define INT_MEMBER(name, val, comment)          /*make INT_VARIABLE*/\
    name(val, #name, comment)

#define BOOL_MEMBER(name, val, comment)         /*make BOOL_VARIABLE*/\
    name(val, #name, comment)

#define STRING_MEMBER(name, val, comment)       /*make STRING_VARIABLE*/\
    name(val, #name, comment)

#define double_MEMBER(name, val, comment)       /*make double_VARIABLE*/\
    name(val, #name, comment)

#define INT_EVAR(name,val,comment)            /*make INT_VARIABLE*/\
    INT_VARIABLE      name(val,#name,comment)

#define INT_EVAR_H(name,val,comment)          /*declare one*/\
    INT_VARIABLE      name

#define BOOL_EVAR(name,val,comment)           /*make BOOL_VARIABLE*/\
    BOOL_VARIABLE     name(val,#name,comment)

#define BOOL_EVAR_H(name,val,comment)         /*declare one*/\
    BOOL_VARIABLE     name

#define STRING_EVAR(name,val,comment)         /*make STRING_VARIABLE*/\
    STRING_VARIABLE     name(val,#name,comment)

#define STRING_EVAR_H(name,val,comment)         /*declare one*/\
    STRING_VARIABLE     name

#define double_EVAR(name,val,comment)         /*make double_VARIABLE*/\
    double_VARIABLE     name(val,#name,comment)

#define double_EVAR_H(name,val,comment)         /*declare one*/\
    double_VARIABLE     name

extern STRING_VAR_H (debug_file, "", "File to send tprintf output to");
extern BOOL_VAR_H (debug_window_on, TRUE, "Send tprintf to window unless file set");

//Trace printf       //special message
void tprintf(const char *format, ...);

//special message
BOOL8 pause_continue (const char *format, ...);

/***********************************************************************
 ********************    MACROS    **************************************
 ***********************************************************************/

/***********************************************************************
  QUOTE_IT   MACRO DEFINITION
  ===========================
Replace <parm> with "<parm>".  <parm> may be an arbitrary number of tokens
***********************************************************************/

#define QUOTE_IT( parm ) #parm

/***********************************************************************
  ELISTIZE( CLASSNAME ) MACROS
  ============================

CLASSNAME is assumed to be the name of a class which has a baseclass of
ELIST_LINK.

NOTE:  Because we dont use virtual functions in the list code, the list code
will NOT work correctly for classes derived from this.

The macros generate:
  - An element deletion function:      CLASSNAME##_zapper
  - An element serialiser function"    CLASSNAME##_serialiser
  - An element de-serialiser function" CLASSNAME##_de_serialiser
  - An E_LIST subclass: CLASSNAME##_LIST
  - An E_LIST_ITERATOR subclass:       CLASSNAME##_IT

NOTE: Generated names are DELIBERATELY designed to clash with those for
ELIST2IZE but NOT with those for CLISTIZE and CLIST2IZE

Four macros are provided: ELISTIZE, ELISTIZE_S, ELISTIZEH and ELISTIZEH_S
The ...IZEH macros just define the class names for use in .h files
The ...IZE macros define the code use in .c files
The _S versions define lists which can be serialised.  They assume that
the make_serialise() macro is used in the list element class derived from
ELIST_LINK to define serialise() and de_serialise() members for the list
elements.
***********************************************************************/

/***********************************************************************
  ELISTIZEH( CLASSNAME )  and  ELISTIZEH_S( CLASSNAME ) MACROS

These macros are constructed from 3 fragments ELISTIZEH_A, ELISTIZEH_B and
ELISTIZEH_C.  ELISTIZEH is simply a concatenation of these parts.
ELISTIZEH_S has some additional bits thrown in the gaps.
***********************************************************************/

#define ELISTIZEH_A(CLASSNAME)                                               \
    \
    extern void CLASSNAME##_zapper(ELIST_LINK* link);

#define ELISTIZEH_B(CLASSNAME)                                               \
    \
    /***********************************************************************        \
    *                           CLASS - CLASSNAME##_LIST                                                                    \
    *                                                                                                       \
    *                           List class for class CLASSNAME                                                          \
    *                                                                                                       \
    **********************************************************************/         \
    \
    class  CLASSNAME##_LIST : public ELIST                         \
{                                                                                                       \
    public:                                                                                             \
    CLASSNAME##_LIST():ELIST() {}\
    /* constructor */       \
    \
    CLASSNAME##_LIST(           /* dont construct */ \
    const CLASSNAME##_LIST&)                            /*by initial assign*/\
{ DONT_CONSTRUCT_LIST_BY_COPY.error( QUOTE_IT( CLASSNAME##_LIST ),      \
    ABORT, NULL ); }                            \
    \
    void                        clear()                     /* delete elements */\
{ ELIST::internal_clear( &CLASSNAME##_zapper ); }                               \
    \
    ~CLASSNAME##_LIST() /* destructor */        \
{ clear(); }                                                                                \
    \
    /* Become a deep copy of src_list*/ \
    void deep_copy(const CLASSNAME##_LIST* src_list, \
    CLASSNAME* (*copier)(const CLASSNAME*)); \
    \
    void                        operator=(                  /* prevent assign */    \
    const CLASSNAME##_LIST&)                                                                \
{ DONT_ASSIGN_LISTS.error( QUOTE_IT( CLASSNAME##_LIST ),                        \
    ABORT, NULL ); }

#define ELISTIZEH_C( CLASSNAME )                                                        \
    };                                                                                                      \
    \
    \
    \
    /***********************************************************************        \
    *                           CLASS - CLASSNAME##_IT                                                                      \
    *                                                                                                       \
    *                           Iterator class for class CLASSNAME##_LIST                                           \
    *                                                                                                       \
    *  Note: We don't need to coerce pointers to member functions input             \
    *  parameters as these are automatically converted to the type of the base      \
    *  type. ("A ptr to a class may be converted to a pointer to a public base      \
    *  class of that class")                                                                        \
    **********************************************************************/         \
    \
    class  CLASSNAME##_IT : public ELIST_ITERATOR                  \
{                                                                                                       \
    public:                                                                                             \
    CLASSNAME##_IT():ELIST_ITERATOR(){}                     \
    \
    CLASSNAME##_IT(                                             \
    CLASSNAME##_LIST*           list):ELIST_ITERATOR(list){}                                \
    \
    CLASSNAME*          data()                                                          \
{ return (CLASSNAME*) ELIST_ITERATOR::data(); }                             \
    \
    CLASSNAME*          data_relative(                                                  \
    inT8                    offset)                                                         \
{ return (CLASSNAME*) ELIST_ITERATOR::data_relative( offset ); }        \
    \
    CLASSNAME*          forward()                                                       \
{ return (CLASSNAME*) ELIST_ITERATOR::forward(); }                          \
    \
    CLASSNAME*          extract()                                                       \
{ return (CLASSNAME*) ELIST_ITERATOR::extract(); }                          \
    \
    CLASSNAME*          move_to_first()                                             \
{ return (CLASSNAME*) ELIST_ITERATOR::move_to_first(); }                    \
    \
    CLASSNAME*          move_to_last()                                                  \
{ return (CLASSNAME*) ELIST_ITERATOR::move_to_last(); }                 \
    };

#define ELISTIZEH( CLASSNAME )                                                      \
    \
    ELISTIZEH_A( CLASSNAME )                                                                        \
    \
    ELISTIZEH_B( CLASSNAME )                                                                        \
    \
    ELISTIZEH_C( CLASSNAME )

#define ELISTIZEH_S( CLASSNAME )                                                        \
    \
    ELISTIZEH_A( CLASSNAME )                                                                        \
    \
    extern void          CLASSNAME##_serialiser(                                     \
    FILE*                       f,                                                                  \
    ELIST_LINK*                 element);                                                       \
    \
    extern ELIST_LINK*   CLASSNAME##_de_serialiser(                                  \
    FILE*                       f);                                                             \
    \
    ELISTIZEH_B( CLASSNAME )                                                                        \
    \
    void                    dump(                       /* dump to file */   \
    FILE*                   f)                                                                  \
{ ELIST::internal_dump( f, &CLASSNAME##_serialiser );}                      \
    \
    void                    de_dump(                    /* get from file */  \
    FILE*                   f)                                                                  \
{ ELIST::internal_de_dump( f, &CLASSNAME##_de_serialiser );}                \
    \
    void                    serialise_asc(              /*dump to ascii*/       \
    FILE*                   f);                                                                 \
    void                    de_serialise_asc(           /*de-dump from ascii*/\
    FILE*                   f);                                                                 \
    \
    make_serialise( CLASSNAME##_LIST )                                                  \
    \
    ELISTIZEH_C( CLASSNAME )

/***********************************************************************
  ELISTIZE( CLASSNAME )  and   ELISTIZE_S( CLASSNAME )  MACROS
ELISTIZE_S is a simple extension to ELISTIZE
***********************************************************************/

#define ELISTIZE(CLASSNAME)                                                 \
    \
    /***********************************************************************    \
    *                           CLASSNAME##_zapper                              \
    *                                                                           \
    *  A function which can delete a CLASSNAME element.  This is passed to the  \
    *  generic clear list member function so that when a list is cleared the    \
    *  elements on the list are properly destroyed from the base class, even    \
    *  though we dont use a virtual destructor function.                        \
    **********************************************************************/     \
    \
    void CLASSNAME##_zapper(ELIST_LINK* link) {                          \
    delete reinterpret_cast<CLASSNAME*>(link);                                \
    }                                                                           \
    \
    /* Become a deep copy of src_list*/                                         \
    void CLASSNAME##_LIST::deep_copy(const CLASSNAME##_LIST* src_list,          \
    CLASSNAME* (*copier)(const CLASSNAME*)) {                    \
    \
    CLASSNAME##_IT from_it(const_cast<CLASSNAME##_LIST*>(src_list));          \
    CLASSNAME##_IT to_it(this);                                               \
    \
    for (from_it.mark_cycle_pt(); !from_it.cycled_list(); from_it.forward())  \
    to_it.add_after_then_move((*copier)(from_it.data()));                   \
    }

#define ELISTIZE_S(CLASSNAME)                                               \
    \
    ELISTIZE(CLASSNAME)                                                         \
    \
    void                  CLASSNAME##_LIST::serialise_asc(FILE* f) {            \
    CLASSNAME##_IT      it(this);                                             \
    \
    serialise_INT32(f, length());                                             \
    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())                 \
    it.data()->serialise_asc(f);                /*serialise the list*/    \
    }                                                                           \
    \
    void                  CLASSNAME##_LIST::de_serialise_asc(FILE* f) {         \
    inT32               len;                        /*length to retrive*/     \
    CLASSNAME##_IT      it;                                                   \
    CLASSNAME*          new_elt = NULL;               /*list element*/        \
    \
    len = de_serialise_INT32(f);                                              \
    it.set_to_list(this);                                                     \
    for (; len > 0; len--) {                                                  \
    new_elt = new CLASSNAME;                                                \
    new_elt->de_serialise_asc(f);                                           \
    it.add_to_end(new_elt);                     /*put on the list*/         \
    }                                                                         \
    return;                                                                   \
    }                                                                           \
    \
    \
    /***********************************************************************   \
    *                           CLASSNAME##_serialiser                         \
    *                                                                          \
    *  A function which can serialise an element                               \
    *  This is passed to the generic dump member function so that when a list is  \
    *  serialised the elements on the list are properly serialised.            \
    **********************************************************************/    \
    \
    void CLASSNAME##_serialiser(FILE* f, ELIST_LINK* element) {         \
    reinterpret_cast<CLASSNAME*>(element)->serialise(f);                     \
    }                                                                          \
    \
    \
    \
    /***********************************************************************   \
    *                           CLASSNAME##_de_serialiser                      \
    *                                                                          \
    *  A function which can de-serialise an element                            \
    *  This is passed to the generic de-dump member function so that when a list  \
    *  is de-serialised the elements on the list are properly de-serialised.   \
    **********************************************************************/    \
    \
    ELIST_LINK* CLASSNAME##_de_serialiser(FILE* f) {                  \
    return (ELIST_LINK*) CLASSNAME::de_serialise(f);                       \
    }
//////////////////////////////////////////////////////////////tprintf////////////////////////////////////

//////////////////////////////////////////////////////////////tovars////////////////////////////////////
extern BOOL_VAR_H (textord_show_initial_words, FALSE,
"Display separate words");
extern BOOL_VAR_H (textord_show_new_words, FALSE, "Display separate words");
extern BOOL_VAR_H (textord_show_fixed_words, FALSE,
"Display forced fixed pitch words");
extern BOOL_VAR_H (textord_blocksall_fixed, FALSE, "Moan about prop blocks");
extern BOOL_VAR_H (textord_blocksall_prop, FALSE,
"Moan about fixed pitch blocks");
extern BOOL_VAR_H (textord_blocksall_testing, FALSE,
"Dump stats when moaning");
extern BOOL_VAR_H (textord_test_mode, FALSE, "Do current test");
extern BOOL_VAR_H (textord_repeat_extraction, TRUE, "Extract repeated chars");
extern INT_VAR_H (textord_dotmatrix_gap, 3,
"Max pixel gap for broken pixed pitch");
extern INT_VAR_H (textord_repeat_threshold, 4,
"Min multiple for repeated char");
extern INT_VAR_H (textord_debug_block, 0, "Block to do debug on");
extern INT_VAR_H (textord_pitch_range, 2, "Max range test on pitch");
extern double_VAR_H (textord_repeat_rating, 6, "Min rating for equal blobs");
extern double_VAR_H(textord_repch_width_variance, 0.2,
"Max width change of gap/blob for repeated chars");
extern double_VAR_H (textord_wordstats_smooth_factor, 0.05,
"Smoothing gap stats");
extern double_VAR_H (textord_width_smooth_factor, 0.10,
"Smoothing width stats");
extern double_VAR_H (textord_words_width_ile, 0.4,
"Ile of blob widths for space est");
extern double_VAR_H (textord_words_maxspace, 4.0, "Multiple of xheight");
extern double_VAR_H (textord_words_default_maxspace, 3.5,
"Max believable third space");
extern double_VAR_H (textord_words_default_minspace, 0.6,
"Fraction of xheight");
extern double_VAR_H (textord_words_min_minspace, 0.3, "Fraction of xheight");
extern double_VAR_H (textord_words_default_nonspace, 0.2,
"Fraction of xheight");
extern double_VAR_H (textord_words_initial_lower, 0.25,
"Max inital cluster size");
extern double_VAR_H (textord_words_initial_upper, 0.15,
"Min initial cluster spacing");
extern double_VAR_H (textord_words_minlarge, 0.75,
"Fraction of valid gaps needed");
extern double_VAR_H (textord_words_pitchsd_threshold, 0.025,
"Pitch sync threshold");
extern double_VAR_H (textord_words_def_fixed, 0.01,
"Threshold for definite fixed");
extern double_VAR_H (textord_words_def_prop, 0.06,
"Threshold for definite prop");
extern INT_VAR_H (textord_words_veto_power, 5,
"Rows required to outvote a veto");
extern double_VAR_H (textord_pitch_rowsimilarity, 0.08,
"Fraction of xheight for sameness");
extern BOOL_VAR_H (textord_pitch_scalebigwords, FALSE,
"Scale scores on big words");
extern double_VAR_H (words_initial_lower, 0.5, "Max inital cluster size");
extern double_VAR_H (words_initial_upper, 0.15,
"Min initial cluster spacing");
extern double_VAR_H (words_default_prop_nonspace, 0.25,
"Fraction of xheight");
extern double_VAR_H (words_default_fixed_space, 0.75, "Fraction of xheight");
extern double_VAR_H (words_default_fixed_limit, 0.6, "Allowed size variance");
extern double_VAR_H (textord_words_definite_spread, 0.30,
"Non-fuzzy spacing region");
extern double_VAR_H (textord_spacesize_ratiofp, 2.8,
"Min ratio space/nonspace");
extern double_VAR_H (textord_spacesize_ratioprop, 2.0,
"Min ratio space/nonspace");
extern double_VAR_H (textord_fpiqr_ratio, 1.5, "Pitch IQR/Gap IQR threshold");
extern double_VAR_H (textord_max_pitch_iqr, 0.20,
"Xh fraction noise in pitch");
extern double_VAR_H (textord_fp_min_width, 0.5, "Min width of decent blobs");
//////////////////////////////////////////////////////////////tovars////////////////////////////////////

//////////////////////////////////////////////////////////////context////////////////////////////////////
class WERD_CHOICE;
class Context {
 public:
  static int case_ok(const WERD_CHOICE &word, const UNICHARSET &unicharset);
};

void close_choices();

void write_choice_line();

typedef double (*PROBABILITY_IN_CONTEXT_FUNCTION)(const char* context,
                                                  int context_bytes,
                                                  const char* character,
                                                  int character_bytes);

extern PROBABILITY_IN_CONTEXT_FUNCTION probability_in_context;

extern double def_probability_in_context(const char* context,
                                         int context_bytes,
                                         const char* character,
                                         int character_bytes);
//////////////////////////////////////////////////////////////context////////////////////////////////////

//////////////////////////////////////////////////////////////stopper//////////////////////////////////
typedef uinT8 BLOB_WIDTH;

typedef struct
{
  inT16 index;
  unsigned bad_length:8;
  unsigned good_length:8;
} DANGERR;

enum ACCEPTABLE_CHOICE_CALLER { CHOPPER_CALLER, ASSOCIATOR_CALLER };
typedef struct
{
  UNICHAR_ID Class;
  uinT16 NumChunks;
  float Certainty;
}CHAR_CHOICE;

typedef struct
{
  float Rating;
  float Certainty;
  FLOAT32 AdjustFactor;
  int Length;
  bool ComposedFromCharFragments;
  CHAR_CHOICE Blob[1];
} VIABLE_CHOICE_STRUCT;
typedef VIABLE_CHOICE_STRUCT *VIABLE_CHOICE;

/*---------------------------------------------------------------------------
          Variables
---------------------------------------------------------------------------*/
extern double_VAR_H(stopper_certainty_per_char, -0.50,
     "Certainty to add for each dict char above small word size.");

extern double_VAR_H(stopper_nondict_certainty_base, -2.50,
    "Certainty threshold for non-dict words");

extern double_VAR_H(stopper_phase2_certainty_rejection_offset, 1.0,
           "Reject certainty offset");

extern INT_VAR_H(stopper_debug_level, 0, "Stopper debug level");

extern BOOL_VAR_H(stopper_no_acceptable_choices, false,
                  "Make AcceptableChoice() always return false. Useful"
                  " when there is a need to explore all segmentations");

extern BOOL_VAR_H(save_raw_choices, false, "Save all explored raw choices");
//////////////////////////////////////////////////////////////stopper//////////////////////////////////

//////////////////////////////////////////////////////////////permdawg////////////////////////////
/*---------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
extern BOOL_VAR_H(segment_dawg_debug, 0, "Debug mode for word segmentation");

extern double_VAR_H(segment_penalty_dict_case_bad, 1.3125,
           "Default score multiplier for word matches, which may have case or "
           "punctuation issues (lower is better).");

extern double_VAR_H(segment_penalty_dict_case_ok, 1.1,
           "Score multiplier for word matches that have good case "
           "(lower is better).");

extern double_VAR_H(segment_penalty_dict_frequent_word, 1.0,
           "Score multiplier for word matches which have good case and are "
           "frequent in the given language (lower is better).");
//////////////////////////////////////////////////////////////permdawg////////////////////////////

//////////////////////////////////////////////////////////////permute////////////////////////////
/*----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------*/
#define RATING_PAD      4.0

/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
extern INT_VAR_H(fragments_debug, 0, "Debug character fragments");
extern BOOL_VAR_H(segment_debug, 0, "Debug the whole segmentation process");
extern BOOL_VAR_H(permute_debug, 0, "char permutation debug");

extern BOOL_VAR_H(permute_script_word, 0,
                  "Turn on word script consistency permuter");

extern BOOL_VAR_H(segment_segcost_rating, 0,
                  "incorporate segmentation cost in word rating?");

extern double_VAR_H(segment_reward_script, 0.95,
                    "Score multipler for script consistency within a word. "
                    "Being a 'reward' factor, it should be <= 1. "
                    "Smaller value implies bigger reward.");

extern double_VAR_H(segment_penalty_garbage, 1.5,
                    "Score multiplier for poorly cased strings that are not "
                    "in the dictionary and generally look like garbage "
                    "(lower is better).");

extern double_VAR_H(segment_penalty_dict_nonword, 1.25,
                    "Score multiplier for glyph fragment segmentations which "
                    "do not match a dictionary word (lower is better).");

extern int permute_only_top;
extern float wordseg_rating_adjust_factor;

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
void adjust_non_word(const char *word, const char *word_lengths,
                     float rating, float *new_rating, float *adjust_factor);

const char* choose_il1(const char *first_char,   //first choice
                       const char *second_char,  //second choice
                       const char *third_char,   //third choice
                       const char *prev_char,    //prev in word
                       const char *next_char,    //next in word
                       const char *next_next_char);
//////////////////////////////////////////////////////////////permute////////////////////////////

//////////////////////////////////////////////////////////////points////////////////////////////
class FCOORD;

///integer coordinate
class ICOORD
{
    friend class FCOORD;

public:
    ///empty constructor
    ICOORD()
    {
        xcoord = ycoord = 0;       //default zero
    }

    ///constructor
    ///@param xin x value
    ///@param yin y value
    ICOORD(inT16 xin, inT16 yin)
    {
        xcoord = xin;
        ycoord = yin;
    }

    ///destructor
    ~ICOORD () {}

    ///access function
    NEWDELETE2 (ICOORD) inT16 x () const
    {
        return xcoord;
    }

    ///access_function
    inT16 y() const
    {
        return ycoord;
    }

    ///rewrite function
    void set_x(inT16 xin)
    {
        xcoord = xin;              //write new value
    }

    ///rewrite function
    void set_y(inT16 yin)
    {
        //value to set
        ycoord = yin;
    }

    /// Set from the given x,y, shrinking the vector to fit if needed.
    void set_with_shrink(int x, int y);

    ///find sq length
    float sqlength() const
    {
        return (float) (xcoord * xcoord + ycoord * ycoord);
    }

    ///find length
    float length() const
    {
        return (float) sqrt (sqlength ());
    }

    ///sq dist between pts
    float pt_to_pt_sqdist(const ICOORD &pt) const
    {
        ICOORD gap;

        gap.xcoord = xcoord - pt.xcoord;
        gap.ycoord = ycoord - pt.ycoord;
        return gap.sqlength ();
    }

    ///Distance between pts
    float pt_to_pt_dist(const ICOORD &pt) const
    {
        return (float) sqrt (pt_to_pt_sqdist (pt));
    }

    ///find angle
    float angle() const
    {
        return (float) atan2 ((double) ycoord, (double) xcoord);
    }

    ///test equality
    BOOL8 operator== (const ICOORD & other)
    {
        return xcoord == other.xcoord && ycoord == other.ycoord;
    }

    ///test inequality
    BOOL8 operator!= (const ICOORD & other)
    {
        return xcoord != other.xcoord || ycoord != other.ycoord;
    }

    ///rotate 90 deg anti
    friend ICOORD operator! (const ICOORD &);

    ///unary minus
    friend ICOORD operator- (const ICOORD &);

    ///add
    friend ICOORD operator+ (const ICOORD &, const ICOORD &);

    ///add
    friend ICOORD & operator+= (ICOORD &, const ICOORD &);

    ///subtract
    friend ICOORD operator- (const ICOORD &, const ICOORD &);

    ///subtract
    friend ICOORD & operator-= (ICOORD &, const ICOORD &);

    ///scalar product
    friend inT32 operator% (const ICOORD &, const ICOORD &);

    ///cross product
    friend inT32 operator *(const ICOORD &, const ICOORD &);

    ///multiply
    friend ICOORD operator *(const ICOORD &, inT16);

    ///multiply
    friend ICOORD operator *(inT16, const ICOORD &);

    ///multiply
    friend ICOORD & operator*= (ICOORD &, inT16);

    ///divide
    friend ICOORD operator/ (const ICOORD &, inT16);

    ///divide
    friend ICOORD & operator/= (ICOORD &, inT16);

    ///rotate
    ///@param vec by vector
    void rotate(const FCOORD& vec);

    /// Setup for iterating over the pixels in a vector by the well-known
    /// Bresenham rendering algorithm.
    /// Starting with major/2 in the accumulator, on each step move by
    /// major_step, and then add minor to the accumulator. When
    /// accumulator >= major subtract major and also move by minor_step.
    void setup_render(ICOORD* major_step, ICOORD* minor_step, int* major, int* minor) const;

    ///serialise to ascii
    void serialise_asc(FILE *f);

    ///serialise from ascii
    void de_serialise_asc(FILE *f);

protected:
    inT16 xcoord;                //< x value
    inT16 ycoord;                //< y value
};

class ICOORDELT:public ELIST_LINK, public ICOORD
        //embedded coord list
{
public:
    ///empty constructor
    ICOORDELT() {}

    ///constructor from ICOORD
    ICOORDELT (ICOORD icoord):ICOORD (icoord) {}

    ///constructor
    ///@param xin x value
    ///@param yin y value
    ICOORDELT(inT16 xin, inT16 yin)
    {
        xcoord = xin;
        ycoord = yin;
    }

    /* Note that prep_serialise() dump() and de_dump() dont need to do anything
    more than terminate recursion. */

    ///set ptrs to counts
    void prep_serialise() const {}

    ///write external bits
    void dump(FILE *) const {}

    ///read external bits
    void de_dump(FILE *) {}

    ///serialise to ascii
    make_serialise(ICOORDELT)

    static ICOORDELT* deep_copy(const ICOORDELT* src)
    {
        ICOORDELT* elt = new ICOORDELT;
        *elt = *src;
        return elt;
    }

    ///serialise to ascii
    void serialise_asc(FILE * f);

    ///deserialise from ascii
    void de_serialise_asc(FILE *f);
};

ELISTIZEH_S (ICOORDELT)
class FCOORD
{
    public:
    ///empty constructor
    FCOORD() {}

    ///constructor
    ///@param xvalue x value
    ///@param yvalue y value
    FCOORD(float xvalue, float yvalue)
    {
        xcoord = xvalue;           //set coords
        ycoord = yvalue;
    }

    //make from ICOORD
    FCOORD(ICOORD icoord)
    {  //coords to set
        xcoord = icoord.xcoord;
        ycoord = icoord.ycoord;
    }

    float x() const
    {
        //get coords
        return xcoord;
    }

    float y() const
    {
        return ycoord;
    }

    ///rewrite function
    void set_x(float xin)
    {
        xcoord = xin;              //write new value
    }

    ///rewrite function
    void set_y(float yin)
    {  //value to set
        ycoord = yin;
    }

    ///find sq length
    float sqlength() const
    {
        return xcoord * xcoord + ycoord * ycoord;
    }

    ///find length
    float length() const
    {
        return (float) sqrt (sqlength ());
    }

    ///sq dist between pts
    float pt_to_pt_sqdist(const FCOORD &pt) const
    {
        FCOORD gap;

        gap.xcoord = xcoord - pt.xcoord;
        gap.ycoord = ycoord - pt.ycoord;

        return gap.sqlength ();
    }

    ///Distance between pts
    float pt_to_pt_dist(const FCOORD &pt) const
    {
        return (float) sqrt (pt_to_pt_sqdist (pt));
    }

    ///find angle
    float angle() const
    {
        return (float) atan2 (ycoord, xcoord);
    }

    ///Convert to unit vec
    bool normalise();

    ///test equality
    BOOL8 operator== (const FCOORD & other)
    {
        return xcoord == other.xcoord && ycoord == other.ycoord;
    }

    ///test inequality
    BOOL8 operator!= (const FCOORD & other)
    {
        return xcoord != other.xcoord || ycoord != other.ycoord;
    }

    ///rotate 90 deg anti
    friend FCOORD operator! (const FCOORD &);

    ///unary minus
    friend FCOORD operator- (const FCOORD &);

    ///add
    friend FCOORD operator+ (const FCOORD &, const FCOORD &);

    ///add
    friend FCOORD & operator+= (FCOORD &, const FCOORD &);

    ///subtract
    friend FCOORD operator- (const FCOORD &, const FCOORD &);

    ///subtract
    friend FCOORD & operator-= (FCOORD &, const FCOORD &);

    ///scalar product
    friend float operator% (const FCOORD &, const FCOORD &);

    ///cross product
    friend float operator *(const FCOORD &, const FCOORD &);

    ///multiply
    friend FCOORD operator *(const FCOORD &, float);

    ///multiply
    friend FCOORD operator *(float, const FCOORD &);

    ///multiply
    friend FCOORD & operator*= (FCOORD &, float);

    ///divide
    friend FCOORD operator/ (const FCOORD &, float);

    ///rotate
    ///@param vec by vector

    void rotate(const FCOORD vec);

    ///divide
    friend FCOORD & operator/= (FCOORD &, float);

private:
    float xcoord;                //2 floating coords
    float ycoord;
};
//////////////////////////////////////////////////////////////points////////////////////////////

//////////////////////////////////////////////////////////////crakedge/////////////////////////////////////////////
class CRACKEDGE
{
  public:
    ICOORD pos;                  /*position of crack */
    inT8 stepx;                  //edge step
    inT8 stepy;
    inT8 stepdir;                //chaincode
    CRACKEDGE *prev;             /*previous point */
    CRACKEDGE *next;             /*next point */

    NEWDELETE2 (CRACKEDGE) CRACKEDGE () {} //empty constructor
};
//////////////////////////////////////////////////////////////crakedge/////////////////////////////////////////////

//////////////////////////////////////////////////////////////mod128/////////////////////////////////////////////
#define MODULUS       128        /*range of directions */
#define DIRBITS       7          //no of bits used
#define DIRSCALE      1000       //length of vector

class DIR128
{
  public:
    DIR128() {
    }                            //empty constructor

    DIR128(                //constructor
           inT16 value) {  //value to assign
      value %= MODULUS;          //modulo arithmetic
      if (value < 0)
        value += MODULUS;        //done properly
      dir = (inT8) value;
    }
    DIR128(const FCOORD fc);  //quantize vector

    DIR128 & operator= (         //assign of inT16
    inT16 value) {               //value to assign
      value %= MODULUS;          //modulo arithmetic
      if (value < 0)
        value += MODULUS;        //done properly
      dir = (inT8) value;
      return *this;
    }
    inT8 operator- (             //subtraction
      const DIR128 & minus) const//for signed result
    {
                                 //result
      inT16 result = dir - minus.dir;

      if (result > MODULUS / 2)
        result -= MODULUS;       //get in range
      else if (result < -MODULUS / 2)
        result += MODULUS;
      return (inT8) result;
    }
    DIR128 operator+ (           //addition
      const DIR128 & add) const  //of itself
    {
      DIR128 result;             //sum

      result = dir + add.dir;    //let = do the work
      return result;
    }
    DIR128 & operator+= (        //same as +
    const DIR128 & add) {
      *this = dir + add.dir;     //let = do the work
      return *this;
    }
    inT8 get_dir() const {  //access function
      return dir;
    }
    ICOORD vector() const;  //turn to vector

  private:
    inT8 dir;                    //a direction
};
//////////////////////////////////////////////////////////////mod128/////////////////////////////////////////////

//////////////////////////////////////////////////////////////svutil/////////////////////////////////////////////
#ifdef WIN32
#define snprintf _snprintf
#if (_MSC_VER <= 1400)
#define vsnprintf _vsnprintf
#endif
#pragma warning(disable:4786)
#else
#endif

#ifndef MAX
#define MAX(a, b)  ((a > b) ? a : b)
#endif

#ifndef MIN
#define MIN(a, b)  ((a < b) ? a : b)
#endif

/// The SVSync class provides functionality for Thread & Process Creation
class SVSync {
 public:
  /// Create new thread.
  static void StartThread(void *(*func)(void*), void* arg);
  /// Signals a thread to exit.
  static void ExitThread();
  /// Starts a new process.
  static void StartProcess(const char* executable, const char* args);
};

/// A semaphore class which encapsulates the main signalling
/// and wait abilities of semaphores for windows and unix.
class SVSemaphore {
 public:
  /// Sets up a semaphore.
  SVSemaphore();
  /// Signal a semaphore.
  void Signal();
  /// Wait on a semaphore.
  void Wait();
 private:
#ifdef WIN32
  HANDLE semaphore_;
#else
  sem_t semaphore_;
#endif
};

/// A mutex which encapsulates the main locking and unlocking
/// abilites of mutexes for windows and unix.
class SVMutex {
 public:
  /// Sets up a new mutex.
  SVMutex();
  /// Locks on a mutex.
  void Lock();
  /// Unlocks on a mutex.
  void Unlock();
 private:
#ifdef WIN32
  HANDLE mutex_;
#else
  pthread_mutex_t mutex_;
#endif
};

/// The SVNetwork class takes care of the remote connection for ScrollView
/// This means setting up and maintaining a remote connection, sending and
/// receiving messages and closing the connection.
/// It is designed to work on both Linux and Windows.
class SVNetwork {
 public:
  /// Set up a connection to hostname on port.
  SVNetwork(const char* hostname, int port);

  /// Destructor.
  ~SVNetwork();

  /// Put a message in the messagebuffer to the server and try to send it.
  void Send(const char* msg);

  /// Receive a message from the server.
  /// This will always return one line of char* (denoted by \n).
  char* Receive();

  /// Close the connection to the server.
  void Close();

  /// Flush the buffer.
  void Flush();

 private:
  /// The mutex for access to Send() and Flush().
  SVMutex* mutex_send_;
  /// The actual stream_ to the server.
  int stream_;
  /// Stores the last received message-chunk from the server.
  char* msg_buffer_in_;

  /// Stores the messages which are supposed to go out.
  std::string msg_buffer_out_;

  bool has_content; // Win32 (strtok)
  /// Where we are at in our msg_buffer_in_
  char* buffer_ptr_;  // Unix (strtok_r)
};
//////////////////////////////////////////////////////////////svutil/////////////////////////////////////////////

//////////////////////////////////////////////////////////////scrollview/////////////////////////////////////////////
class ScrollView;
class SVNetwork;
class SVMutex;
class SVSemaphore;
struct SVPolyLineBuffer;

enum SVEventType
{
  SVET_DESTROY,    // Window has been destroyed by user.
  SVET_EXIT,       // User has destroyed the last window by clicking on the 'X'.
  SVET_CLICK,      // Left button pressed.
  SVET_SELECTION,  // Left button selection.
  SVET_INPUT,      // There is some input (single key or a whole string).
  SVET_MOUSE,      // The mouse has moved with a button pressed.
  SVET_MOTION,     // The mouse has moved with no button pressed.
  SVET_HOVER,      // The mouse has stayed still for a second.
  SVET_POPUP,      // A command selected through a popup menu.
  SVET_MENU,       // A command selected through the menubar.
  SVET_ANY,        // Any of the above.

  SVET_COUNT       // Array sizing.
};

struct SVEvent
{
  ~SVEvent() { delete [] parameter; }
  SVEvent* copy();
  SVEventType type;    // What kind of event.
  ScrollView* window;  // Window event relates to.
  int x;               // Coords of click or selection.
  int y;
  int x_size;          // Size of selection.
  int y_size;
  int command_id;      // The ID of the possibly associated event (e.g. MENU)
  char* parameter;     // Any string that might have been passed as argument.
  int counter;         // Used to detect which kind of event to process next.

  SVEvent()
  {
    window = NULL;
    parameter = NULL;
  }

  SVEvent(const SVEvent&);
  SVEvent& operator=(const SVEvent&);
};

// The SVEventHandler class is used for Event handling: If you register your
// class as SVEventHandler to a ScrollView Window, the SVEventHandler will be
// called whenever an appropriate event occurs.
class SVEventHandler
{
  public:
    virtual ~SVEventHandler() {}

// Gets called by the SV Window. Does nothing on default, overwrite this
// to implement the desired behaviour
    virtual void Notify(const SVEvent* sve){Q_UNUSED(sve);}
};

// The ScrollView class provides the expernal API to the scrollviewer process.
// The scrollviewer process manages windows and displays images, graphics and
// text while allowing the user to zoom and scroll the windows arbitrarily.
// Each ScrollView class instance represents one window, and stuff is drawn in
// the window through method calls on the class. The constructor is used to
// create the class instance (and the window).

class ScrollView
{
 public:

  // Color enum for pens and brushes.
  enum Color
  {
    NONE,
    BLACK,
    WHITE,
    RED,
    YELLOW,
    GREEN,
    CYAN,
    BLUE,
    MAGENTA,
    AQUAMARINE,
    DARK_SLATE_BLUE,
    LIGHT_BLUE,
    MEDIUM_BLUE,
    MIDNIGHT_BLUE,
    NAVY_BLUE,
    SKY_BLUE,
    SLATE_BLUE,
    STEEL_BLUE,
    CORAL,
    BROWN,
    SANDY_BROWN,
    GOLD,
    GOLDENROD,
    DARK_GREEN,
    DARK_OLIVE_GREEN,
    FOREST_GREEN,
    LIME_GREEN,
    PALE_GREEN,
    YELLOW_GREEN,
    LIGHT_GREY,
    DARK_SLATE_GREY,
    DIM_GREY,
    GREY,
    KHAKI,
    MAROON,
    ORANGE,
    ORCHID,
    PINK,
    PLUM,
    INDIAN_RED,
    ORANGE_RED,
    VIOLET_RED,
    SALMON,
    TAN,
    TURQUOISE,
    DARK_TURQUOISE,
    VIOLET,
    WHEAT,
    GREEN_YELLOW  // Make sure this one is last.
};

#ifndef GRAPHICS_DISABLED

// Create a window. The pixel size of the window may be 0,0, in which case
// a default size is selected based on the size of your canvas.
// The canvas may not be 0,0 in size!
  ScrollView(const char* name, int x_pos, int y_pos, int x_size, int y_size, int x_canvas_size, int y_canvas_size);

// With a flag whether the x axis is reversed.
  ScrollView(const char* name, int x_pos, int y_pos, int x_size, int y_size, int x_canvas_size, int y_canvas_size, bool y_axis_reversed);

// Connect to a server other than localhost.
  ScrollView(const char* name, int x_pos, int y_pos, int x_size, int y_size, int x_canvas_size, int y_canvas_size, bool y_axis_reversed, const char* server_name);

  ~ScrollView();

/*******************************************************************************
* Event handling
* To register as listener, the class has to derive from the SVEventHandler
* class, which consists of a notifyMe(SVEvent*) function that should be
* overwritten to process the event the way you want.
*******************************************************************************/

// Add an Event Listener to this ScrollView Window.
  void AddEventHandler(SVEventHandler* listener);

// Block until an event of the given type is received.
  SVEvent* AwaitEvent(SVEventType type);

// Block until any event on any window is received.
  SVEvent* AwaitEventAnyWindow();

/*******************************************************************************
* Getters and Setters
*******************************************************************************/

// Returns the title of the window.
  const char* GetName() { return window_name_; }

// Returns the unique ID of the window.
  int GetId() { return window_id_; }

/*******************************************************************************
* API functions for LUA calls
* the implementations for these can be found in svapi.cc
* (keep in mind that the window is actually created through the ScrollView
* constructor, so this is not listed here)
*******************************************************************************/

#ifdef HAVE_LIBLEPT
// Draw a Pix on (x,y).
  void Image(struct Pix* image, int x_pos, int y_pos);
#endif

// Flush buffers and update display.
  static void Update();

// Exit the program.
  static void Exit();

// Update the contents of a specific window.
  void UpdateWindow();

// Erase all content from the window, but do not destroy it.
  void Clear();

// Set pen color with an enum.
  void Pen(Color color);

// Set pen color to RGB (0-255).
  void Pen(int red, int green, int blue);

// Set pen color to RGBA (0-255).
  void Pen(int red, int green, int blue, int alpha);

// Set brush color with an enum.
  void Brush(Color color);

// Set brush color to RGB (0-255).
  void Brush(int red, int green, int blue);

// Set brush color to RGBA (0-255).
  void Brush(int red, int green, int blue, int alpha);

// Set attributes for future text, like font name (e.g.
// "Times New Roman"), font size etc..
// Note: The underlined flag is currently not supported
  void TextAttributes(const char* font, int pixel_size, bool bold, bool italic, bool underlined);

// Draw line from (x1,y1) to (x2,y2) with the current pencolor.
  void Line(int x1, int y1, int x2, int y2);

// Set the stroke width of the pen.
  void Stroke(float width);

// Draw a rectangle given upper left corner and lower right corner.
// The current pencolor is used as outline, the brushcolor to fill the shape.
  void Rectangle(int x1, int y1, int x2, int y2);

// Draw an ellipse centered on (x,y).
// The current pencolor is used as outline, the brushcolor to fill the shape.
  void Ellipse(int x, int y, int width, int height);

// Draw text with the current pencolor
  void Text(int x, int y, const char* mystring);

// Draw an image from a local filename. This should be faster than createImage.
// WARNING: This only works on a local machine. This also only works image
// types supported by java (like bmp,jpeg,gif,png) since the image is opened by
// the server.
  void Image(const char* image, int x_pos, int y_pos);

// Set the current position to draw from (x,y). In conjunction with...
  void SetCursor(int x, int y);

// ...this function, which draws a line from the current to (x,y) and then
// sets the new position to the new (x,y), this can be used to easily draw
// polygons using vertices
  void DrawTo(int x, int y);

// Set the SVWindow visible/invisible.
  void SetVisible(bool visible);

// Set the SVWindow always on top or not always on top.
  void AlwaysOnTop(bool b);

// Shows a modal dialog with "msg" as question and returns 'y' or 'n'.
  int ShowYesNoDialog(const char* msg);

// Shows a modal dialog with "msg" as question and returns a char* string.
// Constraint: As return, only words (e.g. no whitespaces etc.) are allowed.
  char* ShowInputDialog(const char* msg);

// Adds a messagebox to the SVWindow. This way, it can show the messages...
  void AddMessageBox();

// ...which can be added by this command.
// This is intended as an "debug" output window.
  void AddMessage(const char* format, ...);

// Zoom the window to the rectangle given upper left corner and
// lower right corner.
  void ZoomToRectangle(int x1, int y1, int x2, int y2);

// Custom messages (manipulating java code directly) can be send through this.
// Send a message to the server and attach the Id of the corresponding window.
// Note: This should only be called if you are know what you are doing, since
// you are fiddling with the Java objects on the server directly. Calling
// this just for fun will likely break your application!
// It is public so you can actually take use of the LUA functionalities, but
// be careful!
  void SendMsg(const char* msg, ...);

// Custom messages (manipulating java code directly) can be send through this.
// Send a message to the server without adding the
// window id. Used for global events like Exit().
// Note: This should only be called if you are know what you are doing, since
// you are fiddling with the Java objects on the server directly. Calling
// this just for fun will likely break your application!
// It is public so you can actually take use of the LUA functionalities, but
// be careful!
  static void SendRawMessage(const char* msg);

/*******************************************************************************
* Add new menu entries to parent. If parent is "", the entry gets added to the
* main menubar (toplevel).
*******************************************************************************/
// This adds a new submenu to the menubar.
  void MenuItem(const char* parent, const char* name);

// This adds a new (normal) menu entry with an associated eventID, which should
// be unique among menubar eventIDs.
  void MenuItem(const char* parent, const char* name, int cmdEvent);

// This adds a new checkbox entry, which might initally be flagged.
  void MenuItem(const char* parent, const char* name, int cmdEvent, bool flagged);

// This adds a new popup submenu to the popup menu. If parent is "", the entry
// gets added at "toplevel" popupmenu.
  void PopupItem(const char* parent, const char* name);

// This adds a new popup entry with the associated eventID, which should be
// unique among popup eventIDs.
// If value and desc are given, on a click the server will ask you to modify
// the value and return the new value.
  void PopupItem(const char* parent, const char* name, int cmdEvent, const char* value, const char* desc);

// Returns the correct Y coordinate for a window, depending on whether it might
// have to be flipped (by ySize).
  int TranslateYCoordinate(int y);

 private:
#ifdef HAVE_LIBLEPT
// Transfers a binary Image.
  void TransferBinaryImage(struct Pix* image);
// Transfers a gray scale Image.
  void TransferGrayImage(struct Pix* image);
// Transfers a 32-Bit Image.
  void Transfer32bppImage(struct Pix* image);
#endif

// Sets up ScrollView, depending on the variables from the constructor.
  void Initialize(const char* name, int x_pos, int y_pos, int x_size, int y_size, int x_canvas_size,
                  int y_canvas_size, bool y_axis_reversed, const char* server_name);

// Send the current buffered polygon (if any) and clear it.
  void SendPolygon();

// Start the message receiving thread.
  static void* MessageReceiver(void* a);

// Place an event into the event_table (synchronized).
  void SetEvent(SVEvent* svevent);

// Wake up the semaphore.
  void Signal();

// Returns the unique, shared network stream.
  static SVNetwork* GetStream() { return stream_; }

// Starts a new event handler. Called whenever a new window is created.
  static void* StartEventHandler(void* sv);

// Escapes the ' character with a \, so it can be processed by LUA.
  char* AddEscapeChars(const char* input);

  // The event handler for this window.
  SVEventHandler* event_handler_;

  // The name of the window.
  const char* window_name_;

  // The id of the window.
  int window_id_;

  // The points of the currently under-construction polyline.
  SVPolyLineBuffer* points_;

  // Whether the axis is reversed.
  bool y_axis_is_reversed_;

  // Set to true only after the event handler has terminated.
  bool event_handler_ended_;

  // If the y axis is reversed, flip all y values by ySize.
  int y_size_;

  // # of created windows (used to assign an id to each ScrollView* for svmap).
  static int nr_created_windows_;

  // The stream through which the c++ client is connected to the server.
  static SVNetwork* stream_;

  // Table of all the currently queued events.
  SVEvent* event_table_[SVET_COUNT];

  // Mutex to access the event_table_ in a synchronized fashion.
  SVMutex* mutex_;

  // Semaphore to the thread belonging to this window.
  SVSemaphore* semaphore_;
#endif  // GRAPHICS_DISABLED
};
//////////////////////////////////////////////////////////////scrollview/////////////////////////////////////////////

//////////////////////////////////////////////////////////////svmnode/////////////////////////////////////////////
class SVMenuNode {
 public:
  // Creating the (empty) root menu node.
  SVMenuNode();

  // Destructor for every node.
  ~SVMenuNode();

  // Create a new sub menu node with just a caption.  This is used to create
  // nodes which act as parent nodes to other nodes (e.g. submenus).
  SVMenuNode* AddChild(const char* txt);

  // Create a "normal" menu node which is associated with a command event.
  void AddChild(const char* txt, int command_event);

  // Create a flag menu node.
  void AddChild(const char* txt, int command_event, int tv);

  // Create a menu node with an associated value (which might be changed
  // through the gui).
  void AddChild(const char* txt, int command_event, const char* val);

  // Create a menu node with an associated value and description_.
  void AddChild(const char* txt, int command_event,
                const char* val, const char* desc);

  // Build a menu structure for the server and send the necessary messages.
  // Should be called on the root node. If menu_bar is true, a menu_bar menu
  // is built (e.g. on top of the window), if it is false a popup menu is
  // built which gets shown by right clicking on the window.
  void BuildMenu(ScrollView *sv, bool menu_bar = true);

 private:
  // Constructor holding the actual node data.
  SVMenuNode(int command_event, const char* txt, int tv,
              bool check_box_entry, const char* val, const char* desc);

  // Adds a new menu node to the current node.
  void AddChild(SVMenuNode* svmn);

  // The parent node of this node.
  SVMenuNode* parent_;
  // The first child of this node.
  SVMenuNode* child_;
  // The next "sibling" of this node (e.g. same parent).
  SVMenuNode* next_;
  // Whether this menu node actually is a flag.
  bool is_check_box_entry_;

  // The command event associated with a specific menu node. Should be unique.
  int cmd_event_;
  // The caption associated with a specific menu node.
  char* text_;
  // The value of the flag (if this menu node is a flag).
  bool toggle_value_;
  // The value of the menu node. (optional)
  const char* value_;
  // A description_ of the value. (optional)
  const char* description_;
};
//////////////////////////////////////////////////////////////svmnode/////////////////////////////////////////////

//////////////////////////////////////////////////////////////callcpp/////////////////////////////////////////////
class ScrollView;

typedef enum {
  Black,
  White,
  Red,
  Yellow,
  Green,
  Cyan,
  Blue,
  Magenta,
  Aquamarine,
  Dark_SLATE_BLUE,
  Light_BLUE,
  Medium_BLUE,
  Midnight_BLUE,
  Navy_BLUE,
  Sky_BLUE,
  Slate_BLUE,
  Steel_BLUE,
  Coral,
  Brown,
  Sandy_BROWN,
  Gold,
  GoldENROD,
  Dark_GREEN,
  Dark_OLIVE_GREEN,
  Forest_GREEN,
  Lime_GREEN,
  Pale_GREEN,
  Yellow_GREEN,
  Light_GREY,
  Dark_SLATE_GREY,
  Dim_GREY,
  Grey,
  Khaki,
  Maroon,
  Orange,
  Orchid,
  Pink,
  Plum,
  Indian_RED,
  Orange_RED,
  Violet_RED,
  Salmon,
  Tan,
  Turqoise,
  Dark_TURQUOISE,
  Violet,
  Wheat,
  Green_YELLOW
} C_COL;                         /*starbase colours */

#define INTEL       0x4949
#define MOTO        0x4d4d

extern INT_VAR_H (tess_cp_mapping0, 0, "Mappings for class pruner distance");
extern INT_VAR_H (tess_cp_mapping1, 1, "Mappings for class pruner distance");
extern INT_VAR_H (tess_cp_mapping2, 2, "Mappings for class pruner distance");
extern INT_VAR_H (tess_cp_mapping3, 3, "Mappings for class pruner distance");
extern INT_VAR_H (record_matcher_output, 0, "Record detailed matcher info");
extern INT_VAR_H (il1_adaption_test, 0,
"Dont adapt to i/I at beginning of word");
extern double_VAR_H (permuter_pending_threshold, 0.0,
"Worst conf for using pending dictionary");

//Global matcher info from the class pruner.
extern inT32 cp_maps[4];
//Global info to control writes of matcher info
extern char blob_answer[UNICHAR_LEN + 1];         //correct char
extern char *word_answer;        //correct word
extern inT32 bits_in_states;     //no of bits in states

void setup_cp_maps();
void cprintf (                   //Trace printf
const char *format, ...          //special message
);
ScrollView *c_create_window(                   /*create a window */
                      const char *name,  /*name/title of window */
                      inT16 xpos,        /*coords of window */
                      inT16 ypos,        /*coords of window */
                      inT16 xsize,       /*size of window */
                      inT16 ysize,       /*size of window */
                      double xmin,       /*scrolling limits */
                      double xmax,       /*to stop users */
                      double ymin,       /*getting lost in */
                      double ymax        /*empty space */
                     );
void c_line_color_index(  /*set color */
                        void *win,
                        C_COL index);
void c_move(  /*move pen */
            void *win,
            double x,
            double y);
void c_draw(  /*move pen */
            void *win,
            double x,
            double y);
void c_make_current(  /*move pen */
                    void *win);
void c_clear_window(  /*move pen */
                    void *win);
char window_wait(ScrollView* win);
void reverse32(void *ptr);
void reverse16(void *ptr);
//////////////////////////////////////////////////////////////callcpp/////////////////////////////////////////////

//////////////////////////////////////////////////////////////rect/////////////////////////////////////////////
class TBOX  {  // bounding box
  public:
    TBOX ():       // empty constructor making a null box
    bot_left (MAX_INT16, MAX_INT16), top_right (-MAX_INT16, -MAX_INT16) {
    }

    TBOX(          // constructor
        const ICOORD pt1,   // one corner
        const ICOORD pt2);  // the other corner

    TBOX(                    // constructor
        inT16 left, inT16 bottom, inT16 right, inT16 top);

    TBOX(  // box around FCOORD
        const FCOORD pt);

    bool null_box() const {  // Is box null
      return ((left () >= right ()) || (top () <= bottom ()));
    }

    inT16 top() const {  // coord of top
      return top_right.y ();
    }
    void set_top(int y) {
      top_right.set_y(y);
    }

    inT16 bottom() const {  // coord of bottom
      return bot_left.y ();
    }
    void set_bottom(int y) {
      bot_left.set_y(y);
    }

    inT16 left() const {  // coord of left
      return bot_left.x ();
    }
    void set_left(int x) {
      bot_left.set_x(x);
    }

    inT16 right() const {  // coord of right
      return top_right.x ();
    }
    void set_right(int x) {
      top_right.set_x(x);
    }

    const ICOORD &botleft() const {  // access function
      return bot_left;
    }

    ICOORD botright() const {  // ~ access function
      return ICOORD (top_right.x (), bot_left.y ());
    }

    ICOORD topleft() const {  // ~ access function
      return ICOORD (bot_left.x (), top_right.y ());
    }

    const ICOORD &topright() const {  // access function
      return top_right;
    }

    inT16 height() const {  // how high is it?
      if (!null_box ())
        return top_right.y () - bot_left.y ();
      else
        return 0;
    }

    inT16 width() const {  // how high is it?
      if (!null_box ())
        return top_right.x () - bot_left.x ();
      else
        return 0;
    }

    inT32 area() const {  // what is the area?
      if (!null_box ())
        return width () * height ();
      else
        return 0;
    }

    void move_bottom_edge(                  // move one edge
                          const inT16 y) {  // by +/- y
      bot_left += ICOORD (0, y);
    }

    void move_left_edge(                  // move one edge
                        const inT16 x) {  // by +/- x
      bot_left += ICOORD (x, 0);
    }

    void move_right_edge(                  // move one edge
                         const inT16 x) {  // by +/- x
      top_right += ICOORD (x, 0);
    }

    void move_top_edge(                  // move one edge
                       const inT16 y) {  // by +/- y
      top_right += ICOORD (0, y);
    }

    void move(                     // move box
              const ICOORD vec) {  // by vector
      bot_left += vec;
      top_right += vec;
    }

    void move(                     // move box
              const FCOORD vec) {  // by float vector
      bot_left.set_x ((inT16) floor (bot_left.x () + vec.x ()));
      // round left
      bot_left.set_y ((inT16) floor (bot_left.y () + vec.y ()));
      // round down
      top_right.set_x ((inT16) ceil (top_right.x () + vec.x ()));
      // round right
      top_right.set_y ((inT16) ceil (top_right.y () + vec.y ()));
      // round up
    }

    void scale(                  // scale box
               const float f) {  // by multiplier
      bot_left.set_x ((inT16) floor (bot_left.x () * f));  // round left
      bot_left.set_y ((inT16) floor (bot_left.y () * f));  // round down
      top_right.set_x ((inT16) ceil (top_right.x () * f));  // round right
      top_right.set_y ((inT16) ceil (top_right.y () * f));  // round up
    }
    void scale(                     // scale box
               const FCOORD vec) {  // by float vector
      bot_left.set_x ((inT16) floor (bot_left.x () * vec.x ()));
      bot_left.set_y ((inT16) floor (bot_left.y () * vec.y ()));
      top_right.set_x ((inT16) ceil (top_right.x () * vec.x ()));
      top_right.set_y ((inT16) ceil (top_right.y () * vec.y ()));
    }

    // rotate doesn't enlarge the box - it just rotates the bottom-left
    // and top-right corners. Use rotate_large if you want to guarantee
    // that all content is contained within the rotated box.
    void rotate(const FCOORD& vec) {  // by vector
      bot_left.rotate (vec);
      top_right.rotate (vec);
      *this = TBOX (bot_left, top_right);
    }
    // rotate_large constructs the containing bounding box of all 4
    // corners after rotating them. It therefore guarantees that all
    // original content is contained within, but also slightly enlarges the box.
    void rotate_large(const FCOORD& vec);

    bool contains(  // is pt inside box
                   const FCOORD pt) const;

    bool contains(  // is box inside box
                   const TBOX &box) const;

    bool overlap(  // do boxes overlap
                  const TBOX &box) const;

    bool major_overlap(  // do boxes overlap more than half
                        const TBOX &box) const;

    // Do boxes overlap on x axis.
    bool x_overlap(const TBOX &box) const;

    // Do boxes overlap on x axis by more than
    // half of the width of the narrower box.
    bool major_x_overlap(const TBOX &box) const;

    // Do boxes overlap on y axis.
    bool y_overlap(const TBOX &box) const;

    // Do boxes overlap on y axis by more than
    // half of the height of the shorter box.
    bool major_y_overlap(const TBOX &box) const;

    // fraction of current box's area covered by other
    double overlap_fraction(const TBOX &box) const;

    TBOX intersection(  // shared area box
                     const TBOX &box) const;

    TBOX bounding_union(  // box enclosing both
                       const TBOX &box) const;

    void print() const {  // print
      tprintf("Bounding box=(%d,%d)->(%d,%d)\n",
              left(), bottom(), right(), top());
    }

#ifndef GRAPHICS_DISABLED
    void plot(                    // use current settings
              ScrollView* fd) const {  // where to paint
      fd->Rectangle(bot_left.x (), bot_left.y (), top_right.x (),
        top_right.y ());
    }

    void plot(                              // paint box
              ScrollView* fd,                    // where to paint
              ScrollView::Color fill_colour,           // colour for inside
              ScrollView::Color border_colour) const;  // colour for border
#endif

    friend TBOX & operator+= (TBOX &, const TBOX &);
    // in place union
    friend TBOX & operator-= (TBOX &, const TBOX &);
    // in place intrsection

    void serialise_asc(  // convert to ascii
                       FILE *f);
    void de_serialise_asc(  // convert from ascii
                          FILE *f);

  private:
    ICOORD bot_left;             // bottom left corner
    ICOORD top_right;            // top right corner
};

/**********************************************************************
 * TBOX::TBOX()  Constructor from 1 FCOORD
 *
 **********************************************************************/

inline TBOX::TBOX(               // construtor
                const FCOORD pt  // floating centre
               ) {
  bot_left = ICOORD ((inT16) floor (pt.x ()), (inT16) floor (pt.y ()));
  top_right = ICOORD ((inT16) ceil (pt.x ()), (inT16) ceil (pt.y ()));
}


/**********************************************************************
 * TBOX::contains()  Is point within box
 *
 **********************************************************************/

inline bool TBOX::contains(const FCOORD pt) const {
  return ((pt.x () >= bot_left.x ()) &&
    (pt.x () <= top_right.x ()) &&
    (pt.y () >= bot_left.y ()) && (pt.y () <= top_right.y ()));
}


/**********************************************************************
 * TBOX::contains()  Is box within box
 *
 **********************************************************************/

inline bool TBOX::contains(const TBOX &box) const
{
  return (contains(box.bot_left) && contains(box.top_right));
}


/**********************************************************************
 * TBOX::overlap()  Do two boxes overlap?
 *
 **********************************************************************/

inline bool TBOX::overlap(  // do boxes overlap
                          const TBOX &box) const {
  return ((box.bot_left.x () <= top_right.x ()) &&
    (box.top_right.x () >= bot_left.x ()) &&
    (box.bot_left.y () <= top_right.y ()) &&
    (box.top_right.y () >= bot_left.y ()));
}

/**********************************************************************
 * TBOX::major_overlap()  Do two boxes overlap by at least half of the smallest?
 *
 **********************************************************************/

inline bool TBOX::major_overlap(  // Do boxes overlap more that half.
                                const TBOX &box) const {
  int overlap = MIN(box.top_right.x(), top_right.x());
  overlap -= MAX(box.bot_left.x(), bot_left.x());
  overlap += overlap;
  if (overlap < MIN(box.width(), width()))
    return false;
  overlap = MIN(box.top_right.y(), top_right.y());
  overlap -= MAX(box.bot_left.y(), bot_left.y());
  overlap += overlap;
  if (overlap < MIN(box.height(), height()))
    return false;
  return true;
}

/**********************************************************************
 * TBOX::overlap_fraction()  Fraction of area covered by the other box
 *
 **********************************************************************/

inline double TBOX::overlap_fraction(const TBOX &box) const {
  double fraction = 0.0;
  if (this->area()) {
    fraction = this->intersection(box).area() * 1.0 / this->area();
  }
  return fraction;
}

/**********************************************************************
 * TBOX::x_overlap()  Do two boxes overlap on x-axis
 *
 **********************************************************************/

inline bool TBOX::x_overlap(const TBOX &box) const {
  return ((box.bot_left.x() <= top_right.x()) &&
    (box.top_right.x() >= bot_left.x()));
}

/**********************************************************************
 * TBOX::major_x_overlap()  Do two boxes overlap by more than half the
 *                          width of the narrower box on the x-axis
 *
 **********************************************************************/

inline bool TBOX::major_x_overlap(const TBOX &box) const {
  inT16 overlap = box.width();
  if (this->left() > box.left()) {
    overlap -= this->left() - box.left();
  }
  if (this->right() < box.right()) {
    overlap -= box.right() - this->right();
  }
  return (overlap >= box.width() / 2 || overlap >= this->width() / 2);
}

/**********************************************************************
 * TBOX::y_overlap()  Do two boxes overlap on y-axis
 *
 **********************************************************************/

inline bool TBOX::y_overlap(const TBOX &box) const {
  return ((box.bot_left.y() <= top_right.y()) &&
    (box.top_right.y() >= bot_left.y()));
}

/**********************************************************************
 * TBOX::major_y_overlap()  Do two boxes overlap by more than half the
 *                          height of the shorter box on the y-axis
 *
 **********************************************************************/

inline bool TBOX::major_y_overlap(const TBOX &box) const {
  inT16 overlap = box.height();
  if (this->bottom() > box.bottom()) {
    overlap -= this->bottom() - box.bottom();
  }
  if (this->top() < box.top()) {
    overlap -= box.top() - this->top();
  }
  return (overlap >= box.height() / 2 || overlap >= this->height() / 2);
}
//////////////////////////////////////////////////////////////rect/////////////////////////////////////////////

//////////////////////////////////////////////////////////////quadratc/////////////////////////////////////////////
class QUAD_COEFFS
{
  public:
    QUAD_COEFFS() {
    }                            //empty constructor
    QUAD_COEFFS(             //constructor
                double xsq,  //coefficients
                float x,
                float constant) {
      a = xsq;
      b = x;
      c = constant;
    }

    float y(                  //evaluate
            float x) const {  //at x
      return (float) ((a * x + b) * x + c);
    }

    void move(               // reposition word
              ICOORD vec) {  // by vector
      /************************************************************
        y - q = a (x - p)^2 + b (x - p) + c
        y - q = ax^2 - 2apx + ap^2 + bx - bp + c
          y = ax^2 + (b - 2ap)x + (c - bp + ap^2 + q)
      ************************************************************/
      inT16 p = vec.x ();
      inT16 q = vec.y ();

      c = (float) (c - b * p + a * p * p + q);
      b = (float) (b - 2 * a * p);
    }

    double a;                    //x squared
    float b;                     //x
    float c;                     //constant
  private:
};
//////////////////////////////////////////////////////////////quadratc/////////////////////////////////////////////

//////////////////////////////////////////////////////////////quspline/////////////////////////////////////////////
class ROW;

class QSPLINE
{
  friend void make_first_baseline(TBOX *,
                                  int,
                                  int *,
                                  int *,
                                  QSPLINE *,
                                  QSPLINE *,
                                  float);
  friend void make_holed_baseline(TBOX *, int, QSPLINE *, QSPLINE *, float);
  friend void tweak_row_baseline(ROW *);
  public:
    QSPLINE()
    {  //empty constructor
      segments = 0;
      xcoords = NULL;            //everything empty
      quadratics = NULL;
    }

    //copy constructor
    QSPLINE(const QSPLINE &src);

    QSPLINE(                  //constructor
            inT32 count,      //number of segments
            inT32 *xstarts,   //segment starts
            double *coeffs);  //coefficients
    ~QSPLINE ();                 //destructor

    QSPLINE (                    //least squares fit
      int xstarts[],             //spline boundaries
      int segcount,              //no of segments
      int xcoords[],             //points to fit
      int ycoords[], int blobcount,//no of coords
      int degree);               //function

    //step change
    double step(
                double x1,  //between coords
                double x2);

    //evaluate
    double y(double x) const;  //at x

    // reposition spline
    void move(ICOORD vec);  // by vector

    //test overlap
    BOOL8 overlap(QSPLINE *spline2,  //2 cannot be smaller
                  double fraction);  //by more than this

    //linear extrapolation
    void extrapolate(double gradient,  //gradient to use
                     int left,         //new left edge
                     int right);       //new right edge

#ifndef GRAPHICS_DISABLED
    //draw it
    void plot(ScrollView* window,         //in window
              ScrollView::Color colour) const;  //in colour
#endif

    //set ptrs to counts
    void prep_serialise() {}                            //not required

    //write external bits
    void dump(FILE *f)
    {
      serialise_bytes (f, (void *) xcoords, (segments + 1) * sizeof (inT32));
      serialise_bytes (f, (void *) quadratics, segments * sizeof (QUAD_COEFFS));
    }

    //read external bits
    void de_dump(FILE *f)
    {
      xcoords = (inT32 *) de_serialise_bytes (f, (segments + 1) * sizeof (inT32));
      quadratics = (QUAD_COEFFS *) de_serialise_bytes (f, segments * sizeof (QUAD_COEFFS));
    }

                                 //assign copy
    make_serialise (QSPLINE) QSPLINE & operator= (const QSPLINE & source);   //from this

  private:

    //binary search
    inT32 spline_index(double x) const;  //for x
    inT32 segments;              //no of segments
    inT32 *xcoords;              //no of coords
    QUAD_COEFFS *quadratics;     //spline pieces
};
//////////////////////////////////////////////////////////////quspline/////////////////////////////////////////////

//////////////////////////////////////////////////////////////bits16/////////////////////////////////////////////
class BITS16
{
public:
    uinT16 val;

    // constructor
    BITS16()
    {
        val = 0;
    }

    // constructor
    BITS16(uinT16 init);  // initial val

    // flip specified bit
    void turn_on_bit(uinT8 bit_num)
    {
        // bit to flip 0..7
        val = val | 01 << bit_num;
    }

    // flip specified bit
    void turn_off_bit(uinT8 bit_num)
    {
        // bit to flip 0..7
        val = val & ~(01 << bit_num);
    }

    // flip specified bit   // bit to flip 0..7
    void set_bit(uinT8 bit_num,          BOOL8 value)
    {
        // value to flip to
        if (value)
        {
            val = val | 01 << bit_num;
        }
        else
        {
            val = val & ~(01 << bit_num);
        }
    }

    // access bit
    BOOL8 bit(uinT8 bit_num) const
    {
        // bit to access
        return (val >> bit_num) & 01;
    }
};
//////////////////////////////////////////////////////////////bits16/////////////////////////////////////////////

//////////////////////////////////////////////////////////////coutln/////////////////////////////////////////////
#define INTERSECTING    MAX_INT16//no winding number

                                 //mask to get step
#define STEP_MASK       3

enum C_OUTLINE_FLAGS
{
  COUT_INVERSE                   //White on black blob
};

class C_OUTLINE;          //forward declaration

ELISTIZEH_S (C_OUTLINE)
class C_OUTLINE:public ELIST_LINK
{
public:
    //empty constructor
    C_OUTLINE(){steps = NULL;}

    C_OUTLINE(                     //constructor
              CRACKEDGE *startpt,  //from edge detector
              ICOORD bot_left,     //bounding box //length of loop
              ICOORD top_right,
              inT16 length);

    C_OUTLINE(ICOORD startpt,    //start of loop
              DIR128 *new_steps,  //steps in loop
              inT16 length);     //length of loop
                                 //outline to copy

    C_OUTLINE(C_OUTLINE *srcline, FCOORD rotation);  //and rotate

    // Build a fake outline, given just a bounding box and append to the list.
    static void FakeOutline(const TBOX& box, C_OUTLINE_LIST* outlines);

    ~C_OUTLINE()
    {
      //destructor
      if (steps != NULL)
      {
        free_mem(steps);
      }

      steps = NULL;
    }

    //test flag
    BOOL8 flag(C_OUTLINE_FLAGS mask) const
    {
      //flag to test
      return flags.bit (mask);
    }

    void set_flag(                       //set flag value
                  C_OUTLINE_FLAGS mask,  //flag to test
                  BOOL8 value)
    {
      //value to set
      flags.set_bit (mask, value);
    }

    C_OUTLINE_LIST *child()
    {
      //get child list
      return &children;
    }

    //access function
    const TBOX &bounding_box() const
    {
      return box;
    }

    //set a step  //index of step
    void set_step(inT16 stepindex, inT8 stepdir)
    {
      //chain code
      int shift = stepindex % 4 * 2;
      uinT8 mask = 3 << shift;
      steps[stepindex / 4] = ((stepdir << shift) & mask) | (steps[stepindex / 4] & ~mask);
      //squeeze 4 into byte
    }

    //set a step  //index of step
    void set_step(inT16 stepindex, DIR128 stepdir)
    {
      //direction
      //clean it
      inT8 chaindir = stepdir.get_dir() >> (DIRBITS - 2);

      //difference
      set_step(stepindex, chaindir);
      //squeeze 4 into byte
    }

    //get start position
    const ICOORD &start_pos() const
    {
      return start;
    }

    inT32 pathlength() const
    {
      //get path length
      return stepcount;
    }

    // Return step at a given index as a DIR128.
    DIR128 step_dir(inT16 index) const
    {
      return DIR128((inT16)(((steps[index/4] >> (index%4 * 2)) & STEP_MASK) << (DIRBITS - 2)));
    }

    // Return the step vector for the given outline position.
    ICOORD step(inT16 index) const
    {
      //index of step
      return step_coords[(steps[index/4] >> (index%4 * 2)) & STEP_MASK];
    }

    inT32 area();  //return area
    inT32 perimeter();  // Total perimeter of self and 1st level children.
    inT32 outer_area();  //return area

    //count maxima
    inT32 count_transitions(inT32 threshold);  //size threshold

    //containment test
    BOOL8 operator< (const C_OUTLINE & other) const;

    //containment test
    BOOL8 operator> (C_OUTLINE & other) const
    {
      return other < *this;      //use the < to do it
    }

    //get winding number
    inT16 winding_number(ICOORD testpt) const;  //around this point

    //get direction
    inT16 turn_direction() const;
    void reverse();  //reverse direction

    // reposition outline
    void move(const ICOORD vec);  // by vector

    // If this outline is smaller than the given min_size, delete this and
    // remove from its list, via *it, after checking that *it points to this.
    // Otherwise, if any children of this are too small, delete them.
    // On entry, *it must be an iterator pointing to this. If this gets deleted
    // then this is extracted from *it, so an iteration can continue.
    void RemoveSmallRecursive(int min_size, C_OUTLINE_IT* it);

    //draw one
    void plot(
              ScrollView* window,         //window to draw in
              ScrollView::Color colour) const;  //colour to draw it

    void prep_serialise()
    {
      //set ptrs to counts
      children.prep_serialise ();
    }

    //write external bits
    void dump(FILE *f)
    {
      //stepcount = # bytes
      serialise_bytes (f, (void *) steps, step_mem());
      children.dump (f);
    }

    //read external bits
    void de_dump(FILE *f)
    {
      steps = (uinT8 *) de_serialise_bytes (f, step_mem());
      children.de_dump (f);
    }

    //assignment
    make_serialise (C_OUTLINE)

    C_OUTLINE& operator=(const C_OUTLINE& source);

    static C_OUTLINE* deep_copy(const C_OUTLINE* src)
    {
      C_OUTLINE* outline = new C_OUTLINE;
      *outline = *src;

      return outline;
    }

    static ICOORD chain_step(int chaindir);

private:
    int step_mem() const { return (stepcount+3) / 4; }

    TBOX box;                     //boudning box
    ICOORD start;                //start coord
    uinT8 *steps;                //step array
    inT16 stepcount;             //no of steps
    BITS16 flags;                //flags about outline
    C_OUTLINE_LIST children;     //child elements
    static ICOORD step_coords[4];
};
//////////////////////////////////////////////////////////////coutln/////////////////////////////////////////////

//////////////////////////////////////////////////////////////stepblob/////////////////////////////////////////////
class C_BLOB:public ELIST_LINK
{
  public:
    C_BLOB() {}
    explicit C_BLOB(C_OUTLINE_LIST *outline_list);

    // Build and return a fake blob containing a single fake outline with no
    // steps.
    static C_BLOB* FakeBlob(const TBOX& box);

    C_OUTLINE_LIST *out_list()
    {
      //get outline list
      return &outlines;
    }

    TBOX bounding_box();  //compute bounding box
    inT32 area();  //compute area
    inT32 perimeter();  // Total perimeter of outlines and 1st level children.
    inT32 outer_area();  //compute area

    //count maxima
    inT32 count_transitions(inT32 threshold);  //size threshold

    void move(const ICOORD vec);  // repostion blob by vector
    void rotate(const FCOORD& rotation);  // Rotate by given vector.

    void plot(                       //draw one
              ScrollView* window,         //window to draw in
              ScrollView::Color blob_colour,    //for outer bits
              ScrollView::Color child_colour);  //for holes

    void prep_serialise()
    {
       //set ptrs to counts
      outlines.prep_serialise ();
    }

    //write external bits
    void dump(FILE *f)
    {
      outlines.dump (f);
    }

    //read external bits
    void de_dump(FILE *f)
    {
      outlines.de_dump (f);
    }

    //assignment
    make_serialise(C_BLOB)

    C_BLOB& operator= (const C_BLOB & source)
    {
      if (!outlines.empty ()) outlines.clear();
      outlines.deep_copy(&source.outlines, &C_OUTLINE::deep_copy);

      return *this;
    }

    static C_BLOB* deep_copy(const C_BLOB* src)
    {
      C_BLOB* blob = new C_BLOB;
      *blob = *src;
      return blob;
    }

  private:
    C_OUTLINE_LIST outlines;     //master elements
};

ELISTIZEH_S (C_BLOB)
//////////////////////////////////////////////////////////////stepblob/////////////////////////////////////////////



//////////////////////////////////////////////////////////////polyvert/////////////////////////////////////////////
class POLYPT:public ELIST2_LINK
{
  public:
    POLYPT() {  //empty
    }
    POLYPT(                         //constructor
           const FCOORD &position,  //coords
           const FCOORD &vector) {  //step to next
      pos = position;
      vec = vector;              //just copy
    }

    void prep_serialise() {  //set ptrs to counts
    }
    void dump(  //write external bits
              FILE *) {
    }
    void de_dump(  //read external bits
                 FILE *) {
    }

    static POLYPT* deep_copy(const POLYPT* src) {
      return new POLYPT(*src);
    }
                                 //really simple
    make_serialise (POLYPT)

    FCOORD pos;
    FCOORD vec;                  //vector to next
};

ELIST2IZEH_S (POLYPT)
//////////////////////////////////////////////////////////////polyvert/////////////////////////////////////////////

//////////////////////////////////////////////////////////////normalis/////////////////////////////////////////////
class ROW;                       //forward decl
class BLOCK;

class DENORM_SEG
{
  public:
    DENORM_SEG() {}

    inT32 xstart;         // start of segment
    inT32 ycoord;         // y at segment
    float scale_factor;   // normalized_x/scale_factor + x_center == original_x
};

class DENORM
{
  public:
    DENORM() {  //constructor
      source_row = NULL;
      x_centre = 0.0f;
      scale_factor = 1.0f;
      segments = 0;
      segs = NULL;
      base_is_row = TRUE;
      m = c = 0;
      block_ = NULL;
    }
    DENORM(          //constructor
           float x,  //from same pieces
           float scaling,
           ROW *src) {
      x_centre = x;              //just copy
      scale_factor = scaling;
      source_row = src;
      segments = 0;
      segs = NULL;
      base_is_row = TRUE;
      m = c = 0;
      block_ = NULL;
    }
    DENORM(                      // constructor
           float x,              // from same pieces
           float scaling,
           double line_m,        // default line: y = mx + c
           double line_c,
           inT16 seg_count,      // no of segments
           DENORM_SEG *seg_pts,  // actual segments
           BOOL8 using_row,      // as baseline
           ROW *src);
    DENORM(const DENORM &);
    DENORM & operator= (const DENORM &);
    ~DENORM() {
      if (segments > 0)
        delete[]segs;
    }

    // Return the original x coordinate of the middle of the word
    // (mapped to 0 in normalized coordinates).
    float origin() const { return x_centre; }

    float scale() const {  //get scale
      return scale_factor;
    }
    ROW *row() const {  //get row
      return source_row;
    }
    const BLOCK* block() const {
      return block_;
    }
    void set_block(const BLOCK* block) {
      block_ = block;
    }

    // normalized x -> original x
    float x(float src_x) const;

    // Given a (y coordinate, x center of segment) in normalized coordinates,
    // return the original y coordinate.
    float y(float src_y, float src_x_centre) const;

    float scale_at_x(  // Return scaling at this coord.
            float src_x) const;
    float yshift_at_x(  // Return yshift at this coord.
            float src_x) const;

  private:
    const DENORM_SEG *binary_search_segment(float src_x) const;

    BOOL8 base_is_row;    // using row baseline?
    inT16 segments;       // no of segments
    double c, m;          // baseline: y = mx + c
    float x_centre;       // middle of word in original coordinates
    float scale_factor;   // normalized_x/scale_factor + x_center == original_x
    ROW *source_row;      // row it came from
    DENORM_SEG *segs;     // array of segments
    const BLOCK* block_;  // Block the word came from.
};
//////////////////////////////////////////////////////////////normalis/////////////////////////////////////////////

//////////////////////////////////////////////////////////////poutline/////////////////////////////////////////////
#define INTERSECTING    MAX_INT16//no winding number

class OUTLINE;                   //forward declaration

ELISTIZEH_S (OUTLINE)
class OUTLINE:public ELIST_LINK
{
  public:
    OUTLINE() {  //empty constructor
    }
    OUTLINE(                        //constructor
            const ICOORD &startpt,  //start point
            inT8 *compactloop,      //from Tess format
            BOOL8 reverse,          //reverse it
            ICOORD bot_left,        //bounding box
            ICOORD top_right);
    OUTLINE(                      //constructor
            POLYPT_IT *poly_it);  //from list of pts

    OUTLINE_LIST *child() {  //get child list
      return &children;
    }

                                 //access function
    const TBOX &bounding_box() const {
      return box;
    }
    void compute_bb();  //set bounding box

                                 //get start position
    const ICOORD &start_pos() const {
      return start;
    }
    float area();  //return area
    POLYPT_LIST *polypts() {  //get poly
      return &outline;
    }

    BOOL8 operator< (            //containment test
      OUTLINE & other);
    BOOL8 operator> (            //containment test
    OUTLINE & other) {
      return other < *this;      //use the < to do it
    }
    inT16 winding_number(                        //get winding number
                         const FCOORD &testpt);  //around this point
    void reverse();  //reverse it

    void move(                    // reposition outline
              const FCOORD vec);  // by FLOAT vector

    void scale(                 // scale outline
               const float f);  // by multiplier
    void scale(                    // scale outline
               const FCOORD vec);  // by FLOAT vector

    void rotate(               // rotate outline
        const FCOORD vector);  // by fcoord

    void plot(                 //draw one
              ScrollView* window,   //window to draw in
              ScrollView::Color colour);  //colour to draw it

    void prep_serialise() {  //set ptrs to counts
      outline.prep_serialise ();
      children.prep_serialise ();
    }

    void dump(  //write external bits
              FILE *f) {
      outline.dump (f);
      children.dump (f);
    }

    void de_dump(  //read external bits
                 FILE *f) {
      outline.de_dump (f);
      children.de_dump (f);
    }

                                 //assignment
    make_serialise(OUTLINE)

    OUTLINE& operator=(const OUTLINE& source);

    static OUTLINE* deep_copy(const OUTLINE* src) {
      OUTLINE* outline = new OUTLINE;
      *outline = *src;
      return outline;
    }

  private:
    TBOX box;                     //boudning box
    ICOORD start;                //start coord
    POLYPT_LIST outline;         //outline points
    OUTLINE_LIST children;       //child elements
};
//////////////////////////////////////////////////////////////poutline/////////////////////////////////////////////

//////////////////////////////////////////////////////////////STRING////////////////////////////////////////

// STRING_IS_PROTECTED means that  string[index] = X is invalid
// because you have to go through strings interface to modify it.
// This allows the string to ensure internal integrity and maintain
// its own string length. Unfortunately this is not possible because
// STRINGS are used as direct-manipulation data buffers for things
// like length arrays and many places cast away the const on string()
// to mutate the string. Turning this off means that internally we
// cannot assume we know the strlen.
#define STRING_IS_PROTECTED  0

class STRING
{
  public:
    STRING();
    STRING(const STRING &string);
    STRING(const char *string);
    ~STRING ();

    BOOL8 contains(const char c) const;
    inT32 length() const;
    const char *string() const;

#if STRING_IS_PROTECTED
    const char &operator[] (inT32 index) const;
    // len is number of chars in s to insert starting at index in this string
    void insert_range(inT32 index, const char*s, int len);
    void erase_range(inT32 index, int len);
    void truncate_at(inT32 index);
#else
    char &operator[] (inT32 index) const;
#endif

    BOOL8 operator== (const STRING & string) const;
    BOOL8 operator!= (const STRING & string) const;
    BOOL8 operator!= (const char *string) const;

    STRING & operator= (const char *string);
    STRING & operator= (const STRING & string);

    STRING operator+ (const STRING & string) const;
    STRING operator+ (const char ch) const;

    STRING & operator+= (const char *string);
    STRING & operator+= (const STRING & string);
    STRING & operator+= (const char ch);

    // Appends the given string and int (as a %d) to this.
    // += cannot be used for ints as there as a char += operator that would
    // be ambiguous, and ints usually need a string before or between them
    // anyway.
    void add_str_int(const char* str, int number);

    // WARNING
    // This method leaks the underlying pointer,
    // but that is what the original implementation did
    void prep_serialise();

    void dump(FILE *f);
    void de_dump(FILE *f);

    make_serialise(STRING)

    // ensure capcaity but keep pointer encapsulated
    inline void ensure(inT32 min_capacity) { ensure_cstr(min_capacity); }

  private:
    typedef struct STRING_HEADER
    {
      // How much space was allocated in the string buffer for char data.
      int capacity_;

      // used_ is how much of the capacity is currently being used,
      // including a '\0' terminator.
      //
      // If used_ is 0 then string is NULL (not even the '\0')
      // else if used_ > 0 then it is strlen() + 1 (because it includes '\0')
      // else strlen is >= 0 (not NULL) but needs to be computed.
      //      this condition is set when encapsulation is violated because
      //      an API returned a mutable string.
      //
      // capacity_ - used_ = excess capacity that the string can grow
      //                     without reallocating
      mutable int used_;
    } STRING_HEADER;

    // To preserve the behavior of the old serialization, we only have space
    // for one pointer in this structure. So we are embedding a data structure
    // at the start of the storage that will hold additional state variables,
    // then storing the actual string contents immediately after.
    STRING_HEADER* data_;

    // returns the header part of the storage
    inline STRING_HEADER* GetHeader()
    {
      return data_;
    }

    inline const STRING_HEADER* GetHeader() const
    {
      return data_;
    }

    // returns the string data part of storage
    inline char* GetCStr()
    {
      return ((char *)data_) + sizeof(STRING_HEADER);
    }

    inline const char* GetCStr() const
    {
      return ((const char *)data_) + sizeof(STRING_HEADER);
    }

    // Ensure string has requested capacity as optimization
    // to avoid unnecessary reallocations.
    // The return value is a cstr buffer with at least requested capacity
    char* ensure_cstr(inT32 min_capacity);

    void FixHeader() const;  // make used_ non-negative, even if const

    char* AllocData(int used, int capacity);
    void DiscardData();
};
//////////////////////////////////////////////////////////////STRING//////////////////////////////////

//////////////////////////////////////////////////////////////linlsq/////////////////////////////////////////////
    class LLSQ
    {
      friend class PDLSQ;            //pos & direction

      public:
        LLSQ() {  //constructor
          clear();  //set to zeros
        }
        void clear();  //initialize

        void add(           //add element
                 double x,  //coords to add
                 double y);
        void remove(           //delete element
                    double x,  //coords to delete
                    double y);
        inT32 count() {  //no of elements
          return n;
        }

        double m();  //get gradient
        double c(            //get constant
                 double m);  //gradient
        double rms(            //get error
                   double m,   //gradient
                   double c);  //constant
        double spearman();  //get error

      private:
        inT32 n;                     //no of elements
        double sigx;                 //sum of x
        double sigy;                 //sum of y
        double sigxx;                //sum x squared
        double sigxy;                //sum of xy
        double sigyy;                //sum y squared
    };

    class PDLSQ
    {
      public:
        PDLSQ() {  //constructor
          clear();  //set to zeros
        }
        void clear() {  //initialize
          pos.clear ();              //clear both
          dir.clear ();
        }

        void add(                         //add element
                 const ICOORD &addpos,    //position of pt
                 const ICOORD &adddir) {  //dir of pt
          pos.add (addpos.x (), addpos.y ());
          dir.add (adddir.x (), adddir.y ());
        }
        void remove(                            //remove element
                    const ICOORD &removepos,    //position of pt
                    const ICOORD &removedir) {  //dir of pt
          pos.remove (removepos.x (), removepos.y ());
          dir.remove (removedir.x (), removedir.y ());
        }
        inT32 count() {  //no of elements
          return pos.count ();
        }

        float fit(                 //get fit parameters
                  DIR128 &ang,     //output angle
                  float &sin_ang,  //output components
                  float &cos_ang,
                  float &r);

      private:
        LLSQ pos;                    //position
        LLSQ dir;                    //directions
    };
    extern double_VAR_H (pdlsq_posdir_ratio, 0.4e-6, "Mult of dir to cf pos");
//////////////////////////////////////////////////////////////linlsq/////////////////////////////////////////////

//////////////////////////////////////////////////////////////werd/////////////////////////////////////////////
    class PBLOB;
    ELISTIZEH_S (PBLOB)
    enum WERD_FLAGS
    {
      W_SEGMENTED,                   //< correctly segmented
      W_ITALIC,                      //< italic text
      W_BOLD,                        //< bold text
      W_BOL,                         //< start of line
      W_EOL,                         //< end of line
      W_NORMALIZED,                  //< flags
      W_POLYGON,                     //< approximation
      W_LINEARC,                     //< linearc approx
      W_DONT_CHOP,                   //< fixed pitch chopped
      W_REP_CHAR,                    //< repeated character
      W_FUZZY_SP,                    //< fuzzy space
      W_FUZZY_NON,                   //< fuzzy nonspace
      W_INVERSE                      //< white on black
    };

    enum DISPLAY_FLAGS
    {
      /* Display flags bit number allocations */
      DF_BOX,                        //< Bounding box
      DF_TEXT,                       //< Correct ascii
      DF_POLYGONAL,                  //< Polyg approx
      DF_EDGE_STEP,                  //< Edge steps
      DF_BN_POLYGONAL                //< BL normalisd polyapx
    };

    class ROW;                       //forward decl

    class WERD:public ELIST_LINK
    {
      public:
        WERD() {
        }                            //empty constructor
        WERD(                         //constructor
             C_BLOB_LIST *blob_list,  //blobs in word
             uinT8 blanks,            //blanks in front
             const char *text);       //correct text
        WERD(                        //constructor
             PBLOB_LIST *blob_list,  //blobs in word
             uinT8 blanks,           //blanks in front
             const char *text);      //correct text
        WERD(                        //constructor
             PBLOB_LIST *blob_list,  //blobs in word
             WERD *clone);           //use these flags etc.
        WERD(                         //constructor
             C_BLOB_LIST *blob_list,  //blobs in word
             WERD *clone);            //use these flags etc.
        ~WERD ()
        {
          //destructor
          if (flags.bit (W_POLYGON))
          {
             //use right     destructor
             C_BLOB_LIST *pCblobs = &cblobs;
            ((PBLOB_LIST*)pCblobs)->clear();

              //use right     destructor
             C_BLOB_LIST *pRej_cblobs = &rej_cblobs;
            ((PBLOB_LIST *)pRej_cblobs)->clear();
          }
        }

        WERD *poly_copy(                 //make copy as poly
                        float xheight);  //row xheight
        WERD *larc_copy(                 //make copy as larc
                        float xheight);  //row xheight

                                     //get DUFF compact blobs
        C_BLOB_LIST *rej_cblob_list() {
          if (flags.bit (W_POLYGON))
            WRONG_WORD.error ("WERD::rej_cblob_list", ABORT, NULL);
          return &rej_cblobs;
        }

                                     //get DUFF poly blobs
        PBLOB_LIST *rej_blob_list() {
          if (!flags.bit (W_POLYGON))
            WRONG_WORD.error ("WERD::rej_blob_list", ABORT, NULL);
          return (PBLOB_LIST *) (&rej_cblobs);
        }

        C_BLOB_LIST *cblob_list() {  //get compact blobs
          if (flags.bit (W_POLYGON) || flags.bit (W_LINEARC))
            WRONG_WORD.error ("WERD::cblob_list", ABORT, NULL);
          return &cblobs;
        }
        PBLOB_LIST *blob_list() {  //get poly blobs
          if (!flags.bit (W_POLYGON))
            WRONG_WORD.error ("WERD::blob_list", ABORT, NULL);
                                     //make it right type
          return (PBLOB_LIST *) (&cblobs);
        }
        //      LARC_BLOB_LIST                          *larc_blob_list()                                       //get poly blobs
        //      {
        //              if (!flags.bit(W_LINEARC))
        //                      WRONG_WORD.error("WERD::larc_blob_list",ABORT,NULL);
        //              return (LARC_BLOB_LIST*)(&cblobs);                                              //make it right type
        //      }
        PBLOB_LIST *gblob_list() {  //get generic blobs
                                     //make it right type
          return (PBLOB_LIST *) (&cblobs);
        }

        const char *text() const {  //correct text
          return correct.string ();
        }
        uinT8 space() {  //access function
          return blanks;
        }
        void set_blanks(  //set blanks
                        uinT8 new_blanks) {
          blanks = new_blanks;
        }

        void set_text(                         //replace correct text
                      const char *new_text) {  //with this
          correct = new_text;
        }

        TBOX bounding_box();  //compute bounding box

        BOOL8 flag(                          //test flag
                   WERD_FLAGS mask) const {  //flag to test
          return flags.bit (mask);
        }
        void set_flag(                  //set flag value
                      WERD_FLAGS mask,  //flag to test
                      BOOL8 value) {    //value to set
          flags.set_bit (mask, value);
        }

        BOOL8 display_flag(                     //test display flag
                           uinT8 flag) const {  //flag to test
          return disp_flags.bit (flag);
        }

        void set_display_flag(                //set display flag
                              uinT8 flag,     //flag to set
                              BOOL8 value) {  //value to set
          disp_flags.set_bit (flag, value);
        }

        WERD *shallow_copy();  //shallow copy word

        void move(                    // reposition word
                  const ICOORD vec);  // by vector

        void scale(                   // scale word
                   const float vec);  // by multiplier

        void join_on(                //append word
                     WERD *&other);  //Deleting other

        void copy_on(                //copy blobs
                     WERD *&other);  //from other

        void baseline_normalise (    // Tess style BL Norm
                                     //optional antidote
          ROW * row, DENORM * denorm = NULL);

        void baseline_normalise_x (  //Use non standard xht
          ROW * row, float x_height, //Weird value to use
          DENORM * denorm = NULL);   //optional antidote

        void baseline_denormalise(  //un-normalise
                                  const DENORM *denorm);

        void print(            //print
                   FILE *fp);  //file to print on

        void plot (                  //draw one
          ScrollView* window,             //window to draw in
                                     //uniform colour
          ScrollView::Color colour, BOOL8 solid = FALSE);

        void plot (                  //draw one
                                     //in rainbow colours
          ScrollView* window, BOOL8 solid = FALSE);

        void plot_rej_blobs (        //draw one
                                     //in rainbow colours
          ScrollView* window, BOOL8 solid = FALSE);

        WERD & operator= (           //assign words
          const WERD & source);      //from this

        void prep_serialise() {  //set ptrs to counts
          correct.prep_serialise ();
          if (flags.bit (W_POLYGON))
          {
              C_BLOB_LIST *pCnlobs = &cblobs;
            ((PBLOB_LIST *)pCnlobs)->prep_serialise ();
          }
          else
            cblobs.prep_serialise ();
          rej_cblobs.prep_serialise ();
        }

        //write external bits
        void dump(FILE *f)
        {
          correct.dump (f);
          if (flags.bit (W_POLYGON))
          {
              C_BLOB_LIST *pCnlobs = &cblobs;
            ((PBLOB_LIST *)pCnlobs)->dump (f);
          }
          else
            cblobs.dump (f);

          rej_cblobs.dump (f);
        }

        void de_dump(  //read external bits
                     FILE *f) {
          correct.de_dump (f);
          if (flags.bit (W_POLYGON))
          {
              C_BLOB_LIST *pCblobs = &cblobs;
            ((PBLOB_LIST *)pCblobs)->de_dump(f);
          }
          else
            cblobs.de_dump (f);
          rej_cblobs.de_dump (f);
        }

        make_serialise (WERD) private:
        uinT8 blanks;                //no of blanks
        uinT8 dummy;                 //padding
        BITS16 flags;                //flags about word
        BITS16 disp_flags;           //display flags
        inT16 dummy2;                //padding
        STRING correct;              //correct text
        C_BLOB_LIST cblobs;          //compacted blobs
        C_BLOB_LIST rej_cblobs;      //DUFF blobs
    };

    ELISTIZEH_S (WERD)
    extern BOOL_VAR_H (bln_numericmode, 0, "Optimize for numbers");
    extern INT_VAR_H (bln_x_height, 128, "Baseline Normalisation X-height");
    extern INT_VAR_H (bln_baseline_offset, 64,
    "Baseline Norm. offset of baseline");

    int word_comparator(                     //sort blobs
                        const void *word1p,  //ptr to ptr to word1
                        const void *word2p   //ptr to ptr to word2
                       );
//////////////////////////////////////////////////////////////werd/////////////////////////////////////////////

//////////////////////////////////////////////////////////////ocrrow/////////////////////////////////////////////
class TO_ROW;

class ROW:public ELIST_LINK
{
        friend void tweak_row_baseline(ROW *);
    public:
        ROW() {
        }                            //empty constructor
        ROW(                    //constructor
                                inT32 spline_size,  //no of segments
                                inT32 *xstarts,     //segment boundaries
                                double *coeffs,     //coefficients //ascender size
                                float x_height,
                                float ascenders,
                                float descenders,   //descender size
                                inT16 kern,         //char gap
                                inT16 space);       //word gap
        ROW(               //constructor
                           TO_ROW *row,   //textord row
                           inT16 kern,    //char gap
                           inT16 space);  //word gap

        WERD_LIST *word_list() {  //get words
            return &words;
        }

        float base_line(                     //compute baseline
                                             float xpos) const {  //at the position
            //get spline value
            return (float) baseline.y (xpos);
        }
        float x_height() const {  //return x height
            return xheight;
        }
        void set_x_height(float new_xheight) {  // set x height
            xheight = new_xheight;
        }
        inT32 kern() const {  //return kerning
            return kerning;
        }
        inT32 space() const {  //return spacing
            return spacing;
        }
        float ascenders() const {  //return size
            return ascrise;
        }
        float descenders() const {  //return size
            return descdrop;
        }
        TBOX bounding_box() const {  //return bounding box
            return bound_box;
        }

        void recalc_bounding_box();  //recalculate BB

        void move(                    // reposition row
                                      const ICOORD vec);  // by vector

        void print(            //print
                               FILE *fp);  //file to print on

        void plot(                 //draw one
                                   ScrollView* window,   //window to draw in
                                   ScrollView::Color colour);  //uniform colour
        void plot(                 //draw one
                                   ScrollView* window);  //in rainbow colours

#ifndef GRAPHICS_DISABLED
        void plot_baseline(                  //draw the baseline
                                             ScrollView* window,    //window to draw in
                                             ScrollView::Color colour) {  //colour to draw
            //draw it
            baseline.plot (window, colour);
        }
#endif

        void prep_serialise() {  //set ptrs to counts
            words.prep_serialise ();
            baseline.prep_serialise ();
        }

        void dump(  //write external bits
                    FILE *f) {
            words.dump (f);
            baseline.dump (f);
        }

        void de_dump(  //read external bits
                       FILE *f) {
            words.de_dump (f);
            baseline.de_dump (f);
        }

        //assignment
        make_serialise (ROW) ROW & operator= (
                    const ROW & source);       //from this

    private:
        inT32 kerning;               //inter char gap
        inT32 spacing;               //inter word gap
        TBOX bound_box;               //bounding box
        float xheight;               //height of line
        float ascrise;               //size of ascenders
        float descdrop;              //-size of descenders
        WERD_LIST words;             //words
        QSPLINE baseline;            //baseline spline
};

ELISTIZEH_S (ROW)
//////////////////////////////////////////////////////////////ocrrow/////////////////////////////////////////////

//////////////////////////////////////////////////////////////polyaprx/////////////////////////////////////////////
OUTLINE *tesspoly_outline(                       //old approximation
                          C_OUTLINE *c_outline,  //input
                          float                  //xheight
                         );
EDGEPT *edgesteps_to_edgepts (   //convert outline
C_OUTLINE * c_outline,           //input
EDGEPT edgepts[]                 //output is array
);
void fix2(                //polygonal approx
          EDGEPT *start,  /*loop to approimate */
          int area);
EDGEPT *poly2(                  //second poly
              EDGEPT *startpt,  /*start of loop */
              int area          /*area of blob box */
             );
void cutline(                //recursive refine
             EDGEPT *first,  /*ends of line */
             EDGEPT *last,
             int area        /*area of object */
            );
#define fixed_dist      20       //really an int_variable
#define point_diff1(p,p1,p2) (p).x = (p1).x - (p2).x ; (p).y = (p1).y - (p2).y
#define CROSS(a,b) ((a).x * (b).y - (a).y * (b).x)
#define LENGTH(a) ((a).x * (a).x + (a).y * (a).y)
//////////////////////////////////////////////////////////////polyaprx/////////////////////////////////////////////

//////////////////////////////////////////////////////////////polyblob/////////////////////////////////////////////
const int kBlnXHeight = 128;  // x-height for baseline normalisation
const int kBlnBaselineOffset = 64;  // offset for baseline normalization

class PBLOB : public ELIST_LINK
{
public:
    PBLOB() {}                            //empty constructor
    //constructor
    PBLOB(OUTLINE_LIST *outline_list);  //in random order

    //constructor //polygonal approx
    PBLOB(C_BLOB *cblob, float xheight);

    OUTLINE_LIST *out_list()
    {
        //get outline list
        return &outlines;
    }

    TBOX bounding_box();  //compute bounding box
    float area();  //get area of blob

    //normalise single blob   //row it came from
    PBLOB *baseline_normalise(ROW *row, DENORM *denorm);  //inverse mapping out

    //denormalise
    void baseline_denormalise(const DENORM *denorm);  //antidote

    //draw one
    void plot(ScrollView* window,         //window to draw in
              ScrollView::Color blob_colour,    //for outer bits
              ScrollView::Color child_colour);  //for holes

    // reposition blob
    void move(const FCOORD vec);  // by FLOAT vector

    // scale blob
    void scale(const float f);  // by multiplier

    // scale blob
    void scale(const FCOORD vec);  // by FLOAT vector

    void rotate();  // Rotate 90 deg anti
    void rotate(const FCOORD& rotation);  // Rotate by given rotation.

    void prep_serialise()
    {
        //set ptrs to counts
        outlines.prep_serialise ();
    }

    //write external bits
    void dump(FILE *f)
    {
        outlines.dump (f);
    }

    //read external bits
    void de_dump(FILE *f)
    {
        outlines.de_dump (f);
    }


    //assignment
    make_serialise(PBLOB)

    PBLOB& operator=(const PBLOB & source)
    {
       if (!outlines.empty())
       outlines.clear();
       outlines.deep_copy(&source.outlines, &OUTLINE::deep_copy);
       return *this;
    }

    static PBLOB* deep_copy(const PBLOB* src)
    {
      PBLOB* blob = new PBLOB;
      *blob = *src;
      return blob;
    }

private:
      OUTLINE_LIST outlines;       //master elements
};
//////////////////////////////////////////////////////////////polyblob/////////////////////////////////////////////

/////////////////////////////////////////////////////////////////UNICHARMAP/////////////////////////////////
// A UNICHARMAP stores unique unichars. Each of them is associated with one
// UNICHAR_ID.
class UNICHARMAP {
 public:

  // Create an empty UNICHARMAP
  UNICHARMAP();

  ~UNICHARMAP();

  // Insert the given unichar represention in the UNICHARMAP and associate it
  // with the given id. The length of the representation MUST be non-zero.
  void insert(const char* const unichar_repr, UNICHAR_ID id);

  // Return the id associated with the given unichar representation,
  // this representation MUST exist within the UNICHARMAP.
  // The length of the representation MUST be non-zero.
  UNICHAR_ID unichar_to_id(const char* const unichar_repr) const;

  // Return the id associated with the given unichar representation,
  // this representation MUST exist within the UNICHARMAP. The first
  // length characters (maximum) from unichar_repr are used. The length
  // MUST be non-zero.
  UNICHAR_ID unichar_to_id(const char* const unichar_repr, int length) const;

  // Return true if the given unichar representation is already present in the
  // UNICHARMAP. The length of the representation MUST be non-zero.
  bool contains(const char* const unichar_repr) const;

  // Return true if the given unichar representation is already present in the
  // UNICHARMAP. The first length characters (maximum) from unichar_repr are
  // used. The length MUST be non-zero.
  bool contains(const char* const unichar_repr, int length) const;

  // Return the minimum number of characters that must be used from this string
  // to obtain a match in the UNICHARMAP.
  int minmatch(const char* const unichar_repr) const;

  // Clear the UNICHARMAP. All previous data is lost.
  void clear();

 private:

  // The UNICHARMAP is represented as a tree whose nodes are of type
  // UNICHARMAP_NODE.
  struct UNICHARMAP_NODE {

    UNICHARMAP_NODE();
    ~UNICHARMAP_NODE();

    UNICHARMAP_NODE* children;
    UNICHAR_ID id;
  };

  UNICHARMAP_NODE* nodes;
};
/////////////////////////////////////////////////////////////////UNICHARMAP/////////////////////////////////

/////////////////////////////////////////////////////////////////CHAR_FRAGMENT/////////////////////////////////
class CHAR_FRAGMENT
{
public:
    // Minimum number of characters used for fragment representation.
    static const int kMinLen = 6;

    // Maximum number of characters used for fragment representation.
    static const int kMaxLen = 3 + UNICHAR_LEN + 2;

    // Special character used in representing character fragments.
    static const char kSeparator = '|';

    // Maximum number of fragments per character.
    static const int kMaxChunks = 3;

    // Setters and Getters.
    inline void set_all(const char *unichar, int pos, int total)
    {
        this->set_unichar(unichar);
        this->set_pos(pos);
        this->set_total(total);
    }

    inline void set_unichar(const char *uch)
    {
        strncpy(this->unichar, uch, UNICHAR_LEN);
        this->unichar[UNICHAR_LEN] = '\0';
    }

    inline void set_pos(int p) { this->pos = p; }
    inline void set_total(int t) { this->total = t; }
    inline const char* get_unichar() const { return this->unichar; }
    inline int get_pos() const { return this->pos; }
    inline int get_total() const { return this->total; }

    // Returns the string that represents a fragment
    // with the given unichar, pos and total.
    static STRING to_string(const char *unichar, int pos, int total)
    {
        STRING result = "";
        result += kSeparator;
        result += unichar;
        char buffer[kMaxLen];
        snprintf(buffer, kMaxLen, "%c%d%c%d", kSeparator, pos, kSeparator, total);
        result += buffer;

        return result;
    }

    // Returns the string that represents this fragment.
    STRING to_string() const
    {
        return to_string(this->unichar, this->pos, this->total);
    }

    // Checks whether a fragment has the same unichar,
    // position and total as the given inputs.
    inline bool equals(const char *other_unichar, int other_pos, int other_total) const
    {
        return (strcmp(this->unichar, other_unichar) == 0 && this->pos == other_pos && this->total == other_total);
    }

    inline bool equals(const CHAR_FRAGMENT *other) const
    {
        return this->equals(other->get_unichar(), other->get_pos(), other->get_total());
    }

    // Checks whether a given fragment is a continuation of this fragment.
    // Assumes that the given fragment pointer is not NULL.
    inline bool is_continuation_of(const CHAR_FRAGMENT *fragment) const
    {
        return (strcmp(this->unichar, fragment->get_unichar()) == 0 && this->total == fragment->get_total() && this->pos == fragment->get_pos() + 1);
    }

    // Returns true if this fragment is a beginning fragment.
    inline bool is_beginning() const { return this->pos == 0; }

    // Returns true if this fragment is an ending fragment.
    inline bool is_ending() const { return this->pos == this->total-1; }

    // Parses the string to see whether it represents a character fragment
    // (rather than a regular character). If so, allocates memory for a new
    // CHAR_FRAGMENT instance and fills it in with the corresponding fragment
    // information. Fragments are of the form:
    // |m|1|2, meaning chunk 1 of 2 of character m.
    //
    // If parsing succeeded returns the pointer to the allocated CHAR_FRAGMENT
    // instance, otherwise (if the string does not represent a fragment or it
    // looks like it does, but parsing it as a fragment fails) returns NULL.
    //
    // Note: The caller is responsible for deallocating memory
    // associated with the returned pointer.
    static CHAR_FRAGMENT *parse_from_string(const char *str);

private:
    char unichar[UNICHAR_LEN + 1];
    inT16 pos;    // fragment position in the character
    inT16 total;  // total number of fragments in the character
};
/////////////////////////////////////////////////////////////////CHAR_FRAGMENT/////////////////////////////////

/////////////////////////////////////////////////////////////////ambigs/////////////////////////////////
#define MAX_AMBIG_SIZE    10

extern INT_VAR_H(global_ambigs_debug_level, 0,
                 "Debug level for unichar ambiguities");
extern BOOL_VAR_H(use_definite_ambigs_for_classifier, 0,
                  "Use definite ambiguities when running character classifier");
static const int kUnigramAmbigsBufferSize = 1000;
static const char kAmbigNgramSeparator[] = { ' ', '\0' };
static const char kAmbigDelimiters[] = "\t ";
static const char kIllegalMsg[] = "Illegal ambiguity specification on line %d\n";
static const char kIllegalUnicharMsg[] = "Illegal unichar %s in ambiguity specification\n";

enum AmbigType
{
    NOT_AMBIG,        // the ngram pair is not ambiguous
    REPLACE_AMBIG,    // ocred ngram should always be substituted with correct
    DEFINITE_AMBIG,   // add correct ngram to the classifier results (1-1)
    SIMILAR_AMBIG,    // use pairwise classifier for ocred/correct pair (1-1)
    CASE_AMBIG,       // this is a case ambiguity (1-1)

    AMBIG_TYPE_COUNT  // number of enum entries
};

// A collection of utility functions for arrays of UNICHAR_IDs that are
// terminated by INVALID_UNICHAR_ID.

// The UNICHARSET class is an utility class for Tesseract that holds the
// set of characters that are used by the engine. Each character is identified
// by a unique number, from 0 to (size - 1).
class UNICHARSET
{
public:
    // Create an empty UNICHARSET
    UNICHARSET();

    ~UNICHARSET();

    // Return the UNICHAR_ID of a given unichar representation within the
    // UNICHARSET.
    UNICHAR_ID unichar_to_id(const char* const unichar_repr) const;

    // Return the UNICHAR_ID of a given unichar representation within the
    // UNICHARSET. Only the first length characters from unichar_repr are used.
    UNICHAR_ID unichar_to_id(const char* const unichar_repr, int length) const;

    // Return the minimum number of bytes that matches a legal UNICHAR_ID,
    // while leaving a legal UNICHAR_ID afterwards. In other words, if there
    // is both a short and a long match to the string, return the length that
    // ensures there is a legal match after it.
    int step(const char* str) const;

    // Return the unichar representation corresponding to the given UNICHAR_ID
    // within the UNICHARSET.
    char* id_to_unichar(UNICHAR_ID id) const;

    // Return a STRING that reformats the utf8 str into the str followed
    // by its hex unicodes.
    static STRING debug_utf8_str(const char* str);

    // Return a STRING containing debug information on the unichar, including
    // the id_to_unichar, its hex unicodes and the properties.
    STRING debug_str(UNICHAR_ID id) const;
    STRING debug_str(const char * unichar_repr) const
    {
        return debug_str(unichar_to_id(unichar_repr));
    }

    // Add a unichar representation to the set.
    void unichar_insert(const char* const unichar_repr);

    // Return true if the given unichar id exists within the set.
    // Relies on the fact that unichar ids are contiguous in the unicharset.
    bool contains_unichar_id(UNICHAR_ID unichar_id) const
    {
        return unichar_id != INVALID_UNICHAR_ID && unichar_id < size_used;
    }

    // Return true if the given unichar representation exists within the set.
    bool contains_unichar(const char* const unichar_repr) const;
    bool contains_unichar(const char* const unichar_repr, int length) const;

    // Return true if the given unichar representation corresponds to the given
    // UNICHAR_ID within the set.
    bool eq(UNICHAR_ID unichar_id, const char* const unichar_repr) const;

    // Delete CHAR_FRAGMENTs stored in properties of unichars array.
    void delete_pointers_in_unichars()
    {
        for (int i = 0; i < size_used; ++i)
        {
            if (unichars[i].properties.fragment != NULL)
            {
                delete unichars[i].properties.fragment;
                unichars[i].properties.fragment = NULL;
            }
        }
    }

    // Clear the UNICHARSET (all the previous data is lost).
    void clear()
    {
        if (size_reserved > 0)
        {
            for (int i = 0; i < script_table_size_used; ++i)
                delete[] script_table[i];

            delete[] script_table;
            script_table = 0;
            script_table_size_reserved = 0;
            script_table_size_used = 0;
            delete_pointers_in_unichars();
            delete[] unichars;
            unichars = 0;
            size_reserved = 0;
            size_used = 0;
        }

        ids.clear();
    }

    // Return the size of the set (the number of different UNICHAR it holds).
    int size() const
    {
        return size_used;
    }

    // Reserve enough memory space for the given number of UNICHARS
    void reserve(int unichars_number);

    // Opens the file indicated by filename and saves unicharset to that file.
    // Returns true if the operation is successful.
    bool save_to_file(const char * const filename) const
    {
        FILE* file = fopen(filename, "w+");
        if (file == NULL) return false;
        bool result = save_to_file(file);
        fclose(file);
        return result;
    }

    // Saves the content of the UNICHARSET to the given file.
    // Returns true if the operation is successful.
    bool save_to_file(FILE *file) const;

    // Opens the file indicated by filename and loads the UNICHARSET
    // from the given file. The previous data is lost.
    // Returns true if the operation is successful.
    bool load_from_file(const char* const filename)
    {
        FILE* file = fopen(filename, "r");
        if (file == NULL) return false;
        bool result = load_from_file(file);
        fclose(file);

        return result;
    }

    // Loads the UNICHARSET from the given file. The previous data is lost.
    // Returns true if the operation is successful.
    bool load_from_file(FILE *file);

    // Set a whitelist and/or blacklist of characters to recognize.
    // An empty or NULL whitelist enables everything (minus any blacklist).
    // An empty or NULL blacklist disables nothing.
    // The blacklist overrides the whitelist.
    // Each list is a string of utf8 character strings. Boundaries between
    // unicharset units are worked out automatically, and characters not in
    // the unicharset are silently ignored.
    void set_black_and_whitelist(const char* blacklist, const char* whitelist);

    // Set the isalpha property of the given unichar to the given value.
    void set_isalpha(UNICHAR_ID unichar_id, bool value)
    {
        unichars[unichar_id].properties.isalpha = value;
    }

    // Set the islower property of the given unichar to the given value.
    void set_islower(UNICHAR_ID unichar_id, bool value)
    {
        unichars[unichar_id].properties.islower = value;
    }

    // Set the isupper property of the given unichar to the given value.
    void set_isupper(UNICHAR_ID unichar_id, bool value)
    {
        unichars[unichar_id].properties.isupper = value;
    }

    // Set the isdigit property of the given unichar to the given value.
    void set_isdigit(UNICHAR_ID unichar_id, bool value)
    {
        unichars[unichar_id].properties.isdigit = value;
    }

    // Set the ispunctuation property of the given unichar to the given value.
    void set_ispunctuation(UNICHAR_ID unichar_id, bool value)
    {
        unichars[unichar_id].properties.ispunctuation = value;
    }

    // Set the isngram property of the given unichar to the given value.
    void set_isngram(UNICHAR_ID unichar_id, bool value)
    {
        unichars[unichar_id].properties.isngram = value;
    }

    // Set the script name of the given unichar to the given value.
    // Value is copied and thus can be a temporary;
    void set_script(UNICHAR_ID unichar_id, const char* value)
    {
        unichars[unichar_id].properties.script_id = add_script(value);
    }

    // Set other_case unichar id in the properties for the given unichar id.
    void set_other_case(UNICHAR_ID unichar_id, UNICHAR_ID other_case)
    {
        unichars[unichar_id].properties.other_case = other_case;
    }

    // Return the isalpha property of the given unichar.
    bool get_isalpha(UNICHAR_ID unichar_id) const
    {
        return unichars[unichar_id].properties.isalpha;
    }

    // Return the islower property of the given unichar.
    bool get_islower(UNICHAR_ID unichar_id) const
    {
        return unichars[unichar_id].properties.islower;
    }

    // Return the isupper property of the given unichar.
    bool get_isupper(UNICHAR_ID unichar_id) const
    {
        return unichars[unichar_id].properties.isupper;
    }

    // Return the isdigit property of the given unichar.
    bool get_isdigit(UNICHAR_ID unichar_id) const
    {
        return unichars[unichar_id].properties.isdigit;
    }

    // Return the ispunctuation property of the given unichar.
    bool get_ispunctuation(UNICHAR_ID unichar_id) const
    {
        return unichars[unichar_id].properties.ispunctuation;
    }

    // Return the isngram property of the given unichar.
    bool get_isngram(UNICHAR_ID unichar_id) const
    {
        return unichars[unichar_id].properties.isngram;
    }

    // Return the script name of the given unichar.
    // The returned pointer will always be the same for the same script, it's
    // managed by unicharset and thus MUST NOT be deleted
    int get_script(UNICHAR_ID unichar_id) const
    {
        return unichars[unichar_id].properties.script_id;
    }

    // Get other_case unichar id in the properties for the given unichar id.
    UNICHAR_ID get_other_case(UNICHAR_ID unichar_id) const
    {
        return unichars[unichar_id].properties.other_case;
    }

    // Returns UNICHAR_ID of the corresponding lower-case unichar.
    UNICHAR_ID to_lower(UNICHAR_ID unichar_id) const
    {
        if (unichars[unichar_id].properties.islower) return unichar_id;
        return unichars[unichar_id].properties.other_case;
    }

    // Returns UNICHAR_ID of the corresponding upper-case unichar.
    UNICHAR_ID to_upper(UNICHAR_ID unichar_id) const
    {
        if (unichars[unichar_id].properties.isupper) return unichar_id;
        return unichars[unichar_id].properties.other_case;
    }

    // Return a pointer to the CHAR_FRAGMENT class if the given
    // unichar id represents a character fragment.
    const CHAR_FRAGMENT *get_fragment(UNICHAR_ID unichar_id) const
    {
        return unichars[unichar_id].properties.fragment;
    }

    // Return the isalpha property of the given unichar representation.
    bool get_isalpha(const char* const unichar_repr) const
    {
        return get_isalpha(unichar_to_id(unichar_repr));
    }

    // Return the islower property of the given unichar representation.
    bool get_islower(const char* const unichar_repr) const
    {
        return get_islower(unichar_to_id(unichar_repr));
    }

    // Return the isupper property of the given unichar representation.
    bool get_isupper(const char* const unichar_repr) const
    {
        return get_isupper(unichar_to_id(unichar_repr));
    }

    // Return the isdigit property of the given unichar representation.
    bool get_isdigit(const char* const unichar_repr) const
    {
        return get_isdigit(unichar_to_id(unichar_repr));
    }

    // Return the ispunctuation property of the given unichar representation.
    bool get_ispunctuation(const char* const unichar_repr) const
    {
        return get_ispunctuation(unichar_to_id(unichar_repr));
    }

    // Return the script name of the given unichar representation.
    // The returned pointer will always be the same for the same script, it's
    // managed by unicharset and thus MUST NOT be deleted
    int get_script(const char* const unichar_repr) const
    {
        return get_script(unichar_to_id(unichar_repr));
    }

    // Return a pointer to the CHAR_FRAGMENT class struct if the given
    // unichar representation represents a character fragment.
    const CHAR_FRAGMENT *get_fragment(const char* const unichar_repr) const
    {
        if (unichar_repr == NULL || unichar_repr[0] == '\0' || !ids.contains(unichar_repr))
        {
            return NULL;
        }

        return get_fragment(unichar_to_id(unichar_repr));
    }

    // Return the isalpha property of the given unichar representation.
    // Only the first length characters from unichar_repr are used.
    bool get_isalpha(const char* const unichar_repr,int length) const
    {
        return get_isalpha(unichar_to_id(unichar_repr, length));
    }

    // Return the islower property of the given unichar representation.
    // Only the first length characters from unichar_repr are used.
    bool get_islower(const char* const unichar_repr, int length) const
    {
        return get_islower(unichar_to_id(unichar_repr, length));
    }

    // Return the isupper property of the given unichar representation.
    // Only the first length characters from unichar_repr are used.
    bool get_isupper(const char* const unichar_repr, int length) const
    {
        return get_isupper(unichar_to_id(unichar_repr, length));
    }

    // Return the isdigit property of the given unichar representation.
    // Only the first length characters from unichar_repr are used.
    bool get_isdigit(const char* const unichar_repr, int length) const
    {
        return get_isdigit(unichar_to_id(unichar_repr, length));
    }

    // Return the ispunctuation property of the given unichar representation.
    // Only the first length characters from unichar_repr are used.
    bool get_ispunctuation(const char* const unichar_repr, int length) const
    {
        return get_ispunctuation(unichar_to_id(unichar_repr, length));
    }

    // Return the script name of the given unichar representation.
    // Only the first length characters from unichar_repr are used.
    // The returned pointer will always be the same for the same script, it's
    // managed by unicharset and thus MUST NOT be deleted
    int get_script(const char* const unichar_repr, int length) const
    {
        return get_script(unichar_to_id(unichar_repr, length));
    }

    // Return the (current) number of scripts in the script table
    int get_script_table_size() const
    {
        return script_table_size_used;
    }

    // Return the script string from its id
    const char* get_script_from_script_id(int id) const
    {
        if (id >= script_table_size_used || id < 0) return null_script;

        return script_table[id];
    }

    // Returns the id from the name of the script, or 0 if script is not found.
    // Note that this is an expensive operation since it involves iteratively
    // comparing strings in the script table.  To avoid dependency on STL, we
    // won't use a hash.  Instead, the calling function can use this to lookup
    // and save the ID for relevant scripts for fast comparisons later.
    int get_script_id_from_name(const char* script_name) const;

    // Return true if the given script is the null script
    bool is_null_script(const char* script) const
    {
        return script == null_script;
    }

    // Uniquify the given script. For two scripts a and b, if strcmp(a, b) == 0,
    // then the returned pointer will be the same.
    // The script parameter is copied and thus can be a temporary.
    int add_script(const char* script);

    // Return the enabled property of the given unichar.
    bool get_enabled(UNICHAR_ID unichar_id) const
    {
        return unichars[unichar_id].properties.enabled;
    }


    int null_sid() const { return null_sid_; }
    int common_sid() const { return common_sid_; }
    int latin_sid() const { return latin_sid_; }
    int cyrillic_sid() const { return cyrillic_sid_; }
    int greek_sid() const { return greek_sid_; }
    int han_sid() const { return han_sid_; }

private:

    struct UNICHAR_PROPERTIES
    {
        bool  isalpha;
        bool  islower;
        bool  isupper;
        bool  isdigit;
        bool  ispunctuation;
        bool  isngram;
        bool  enabled;
        int   script_id;
        UNICHAR_ID other_case;  // id of the corresponding upper/lower case unichar

        // Contains meta information about the fragment if a unichar represents
        // a fragment of a character, otherwise should be set to NULL.
        // It is assumed that character fragments are added to the unicharset
        // after the corresponding 'base' characters.
        CHAR_FRAGMENT *fragment;
    };

    struct UNICHAR_SLOT
    {
        char representation[UNICHAR_LEN + 1];
        UNICHAR_PROPERTIES properties;
    };

    UNICHAR_SLOT* unichars;
    UNICHARMAP ids;
    int size_used;
    int size_reserved;
    char** script_table;
    int script_table_size_used;
    int script_table_size_reserved;
    const char* null_script;

    // A few convenient script name-to-id mapping without using hash.
    // These are initialized when unicharset file is loaded.  Anything
    // missing from this list can be looked up using get_script_id_from_name.
    int null_sid_;
    int common_sid_;
    int latin_sid_;
    int cyrillic_sid_;
    int greek_sid_;
    int han_sid_;
};

class UnicharIdArrayUtils
{
public:
    // Compares two arrays of unichar ids. Returns -1 if the length of array1 is
    // less than length of array2, if any array1[i] is less than array2[i].
    // Returns 0 if the arrays are equal, 1 otherwise.
    // The function assumes that the arrays are terminated by INVALID_UNICHAR_ID.
    static inline int compare(const UNICHAR_ID array1[], const UNICHAR_ID array2[])
    {
        const UNICHAR_ID *ptr1 = array1;
        const UNICHAR_ID *ptr2 = array2;
        while (*ptr1 != INVALID_UNICHAR_ID && *ptr2 != INVALID_UNICHAR_ID)
        {
            if (*ptr1 != *ptr2) return *ptr1 < *ptr2 ? -1 : 1;
            ++ptr1;
            ++ptr2;
        }

        if (*ptr1 == INVALID_UNICHAR_ID && *ptr2 == INVALID_UNICHAR_ID)
        {
            return 0;
        }

        return *ptr1 == INVALID_UNICHAR_ID ? -1 : 1;
    }

    // Copies UNICHAR_IDs from dst to src. Returns the number of ids copied.
    // The function assumes that the arrays are terminated by INVALID_UNICHAR_ID
    // and that dst has enough space for all the elements from src.
    static inline int copy(const UNICHAR_ID src[], UNICHAR_ID dst[])
    {
        int i = 0;
        do
        {
            dst[i] = src[i];
        }
        while (dst[i++] != INVALID_UNICHAR_ID);

        return i - 1;
    }

    // Prints unichars corresponding to the unichar_ids in the given array.
    // The function assumes that array is terminated by INVALID_UNICHAR_ID.
    static inline void print(const UNICHAR_ID array[], const UNICHARSET &unicharset)
    {
        const UNICHAR_ID *ptr = array;
        if (*ptr == INVALID_UNICHAR_ID)
        {
            tprintf("[Empty]");
        }

        while (*ptr != INVALID_UNICHAR_ID)
        {
            tprintf("%s ", unicharset.id_to_unichar(*ptr++));
        }

        tprintf("( ");
        ptr = array;
        while (*ptr != INVALID_UNICHAR_ID)
        {
            tprintf("%d ", *ptr++);
        }

        tprintf(")\n");
    }
};

/////////////////////////////////////////////////////////////////ambigs////////////////////////////////


/////////////////////////////////////////////////////////clst/////////////////////////////////////////
class CLIST_ITERATOR;

/**********************************************************************
 *							CLASS - CLIST_LINK
 *
 *							Generic link class for singly linked CONS cell lists
 *
 *  Note:  No destructor - elements are assumed to be destroyed EITHER after
 *  they have been extracted from a list OR by the CLIST destructor which
 *  walks the list.
 **********************************************************************/

class CLIST_LINK
{
  friend class CLIST_ITERATOR;
  friend class CLIST;

  CLIST_LINK *next;
  void *data;

  public:
    CLIST_LINK() {  //constructor
      data = next = NULL;
    }

    CLIST_LINK(                       //copy constructor
               const CLIST_LINK &) {  //dont copy link
      data = next = NULL;
    }

    void operator= (             //dont copy links
    const CLIST_LINK &) {
      data = next = NULL;
    }

    NEWDELETE2 (CLIST_LINK)
    /* NOTE that none of the serialise member functions are required for
    CLIST_LINKS as they are never serialised. */
};

/**********************************************************************
 * CLASS - CLIST
 *
 * Generic list class for singly linked CONS cell lists
 **********************************************************************/

class CLIST
{
  friend class CLIST_ITERATOR;

  CLIST_LINK *last;              //End of list
  //(Points to head)
  CLIST_LINK *First() {  // return first
    return last != NULL ? last->next : NULL;
  }

  public:
    CLIST() {  //constructor
      last = NULL;
    }

    ~CLIST () {                  //destructor
      shallow_clear();
    }

    void internal_deep_clear (   //destroy all links
      void (*zapper) (void *));  //ptr to zapper functn

    void shallow_clear();  //clear list but dont
    //delete data elements

    bool empty() {  //is list empty?
      return !last;
    }

    bool singleton() {
      return last != NULL ? (last == last->next) : FALSE;
    }

    void shallow_copy(                     //dangerous!!
                      CLIST *from_list) {  //beware destructors!!
      last = from_list->last;
    }

                                 //ptr to copier functn
    void internal_deep_copy (void *(*copier) (void *),
      const CLIST * list);       //list being copied

    void assign_to_sublist(                           //to this list
                           CLIST_ITERATOR *start_it,  //from list start
                           CLIST_ITERATOR *end_it);   //from list end

    inT32 length();  //# elements in list

    void sort (                  //sort elements
      int comparator (           //comparison routine
      const void *, const void *));

    // Assuming list has been sorted already, insert new_data to
    // keep the list sorted according to the same comparison function.
    // Comparision function is the same as used by sort, i.e. uses double
    // indirection. Time is O(1) to add to beginning or end.
    // Time is linear to add pre-sorted items to an empty list.
    // If unique, then don't add duplicate entries.
    void add_sorted(int comparator(const void*, const void*),
                    bool unique, void* new_data);

    void internal_dump (         //serialise each elem
      FILE * f,                  //to this file
      void element_serialiser (  //using this function
      FILE *, void *));

    void internal_de_dump (      //de_serial each elem
      FILE * f,                  //from this file
      void *element_de_serialiser (//using this function
      FILE *));

    void prep_serialise();  //change last to count

    /*  Note that dump() and de_dump() are not required as calls to dump/de_dump a
      list class should be handled by a class derived from this.

      make_serialise is not required for a similar reason.
    */
};

/***********************************************************************
 *							CLASS - CLIST_ITERATOR
 *
 *							Generic iterator class for singly linked lists with embedded links
 **********************************************************************/

class CLIST_ITERATOR
{
  friend void CLIST::assign_to_sublist(CLIST_ITERATOR *, CLIST_ITERATOR *);

  CLIST *list;                   //List being iterated
  CLIST_LINK *prev;              //prev element
  CLIST_LINK *current;           //current element
  CLIST_LINK *next;              //next element
  bool ex_current_was_last;     //current extracted
  //was end of list
  bool ex_current_was_cycle_pt; //current extracted
  //was cycle point
  CLIST_LINK *cycle_pt;          //point we are cycling
  //the list to.
  bool started_cycling;         //Have we moved off
  //the start?

  CLIST_LINK *extract_sublist(                            //from this current...
                              CLIST_ITERATOR *other_it);  //to other current

  public:
    CLIST_ITERATOR() {  //constructor
      list = NULL;
    }                            //unassigned list

    CLIST_ITERATOR(  //constructor
                   CLIST *list_to_iterate);

    void set_to_list(  //change list
                     CLIST *list_to_iterate);

    void add_after_then_move(                  //add after current &
                             void *new_data);  //move to new

    void add_after_stay_put(                  //add after current &
                            void *new_data);  //stay at current

    void add_before_then_move(                  //add before current &
                              void *new_data);  //move to new

    void add_before_stay_put(                  //add before current &
                             void *new_data);  //stay at current

    void add_list_after(                      //add a list &
                        CLIST *list_to_add);  //stay at current

    void add_list_before(                      //add a list &
                         CLIST *list_to_add);  //move to it 1st item

    void *data() {  //get current data
    #ifndef NDEBUG
      if (!list)
        NO_LIST.error ("CLIST_ITERATOR::data", ABORT, NULL);
      if (!current)
        NULL_DATA.error ("CLIST_ITERATOR::data", ABORT, NULL);
    #endif
      return current->data;
    }

    void *data_relative(               //get data + or - ...
                        inT8 offset);  //offset from current

    void *forward();  //move to next element

    void *extract();  //remove from list

    void *move_to_first();  //go to start of list

    void *move_to_last();  //go to end of list

    void mark_cycle_pt();  //remember current

    bool empty() {  //is list empty?
    #ifndef NDEBUG
      if (!list)
        NO_LIST.error ("CLIST_ITERATOR::empty", ABORT, NULL);
    #endif
      return list->empty ();
    }

    bool current_extracted() {  //current extracted?
      return !current;
    }

    bool at_first();  //Current is first?

    bool at_last();  //Current is last?

    bool cycled_list();  //Completed a cycle?

    void add_to_end(                  //add at end &
                    void *new_data);  //dont move

    void exchange(                            //positions of 2 links
                  CLIST_ITERATOR *other_it);  //other iterator

    inT32 length();  //# elements in list

    void sort (                  //sort elements
      int comparator (           //comparison routine
      const void *, const void *));

};

/***********************************************************************
 *							CLIST_ITERATOR::set_to_list
 *
 *  (Re-)initialise the iterator to point to the start of the list_to_iterate
 *  over.
 **********************************************************************/

inline void CLIST_ITERATOR::set_to_list(  //change list
                                        CLIST *list_to_iterate) {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::set_to_list", ABORT, NULL);
  if (!list_to_iterate)
    BAD_PARAMETER.error ("CLIST_ITERATOR::set_to_list", ABORT,
      "list_to_iterate is NULL");
  #endif

  list = list_to_iterate;
  prev = list->last;
  current = list->First ();
  next = current != NULL ? current->next : NULL;
  cycle_pt = NULL;               //await explicit set
  started_cycling = FALSE;
  ex_current_was_last = FALSE;
  ex_current_was_cycle_pt = FALSE;
}


/***********************************************************************
 *							CLIST_ITERATOR::CLIST_ITERATOR
 *
 *  CONSTRUCTOR - set iterator to specified list;
 **********************************************************************/

inline CLIST_ITERATOR::CLIST_ITERATOR(CLIST *list_to_iterate) {
  set_to_list(list_to_iterate);
}


/***********************************************************************
 *							CLIST_ITERATOR::add_after_then_move
 *
 *  Add a new element to the list after the current element and move the
 *  iterator to the new element.
 **********************************************************************/

inline void CLIST_ITERATOR::add_after_then_move(  // element to add
                                                void *new_data) {
  CLIST_LINK *new_element;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::add_after_then_move", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::add_after_then_move", ABORT, NULL);
  if (!new_data)
    BAD_PARAMETER.error ("CLIST_ITERATOR::add_after_then_move", ABORT,
      "new_data is NULL");
  #endif

  new_element = new CLIST_LINK;
  new_element->data = new_data;

  if (list->empty ()) {
    new_element->next = new_element;
    list->last = new_element;
    prev = next = new_element;
  }
  else {
    new_element->next = next;

    if (current) {               //not extracted
      current->next = new_element;
      prev = current;
      if (current == list->last)
        list->last = new_element;
    }
    else {                       //current extracted
      prev->next = new_element;
      if (ex_current_was_last)
        list->last = new_element;
      if (ex_current_was_cycle_pt)
        cycle_pt = new_element;
    }
  }
  current = new_element;
}


/***********************************************************************
 *							CLIST_ITERATOR::add_after_stay_put
 *
 *  Add a new element to the list after the current element but do not move
 *  the iterator to the new element.
 **********************************************************************/

inline void CLIST_ITERATOR::add_after_stay_put(  // element to add
                                               void *new_data) {
  CLIST_LINK *new_element;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::add_after_stay_put", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::add_after_stay_put", ABORT, NULL);
  if (!new_data)
    BAD_PARAMETER.error ("CLIST_ITERATOR::add_after_stay_put", ABORT,
      "new_data is NULL");
  #endif

  new_element = new CLIST_LINK;
  new_element->data = new_data;

  if (list->empty ()) {
    new_element->next = new_element;
    list->last = new_element;
    prev = next = new_element;
    ex_current_was_last = FALSE;
    current = NULL;
  }
  else {
    new_element->next = next;

    if (current) {               //not extracted
      current->next = new_element;
      if (prev == current)
        prev = new_element;
      if (current == list->last)
        list->last = new_element;
    }
    else {                       //current extracted
      prev->next = new_element;
      if (ex_current_was_last) {
        list->last = new_element;
        ex_current_was_last = FALSE;
      }
    }
    next = new_element;
  }
}


/***********************************************************************
 *							CLIST_ITERATOR::add_before_then_move
 *
 *  Add a new element to the list before the current element and move the
 *  iterator to the new element.
 **********************************************************************/

inline void CLIST_ITERATOR::add_before_then_move(  // element to add
                                                 void *new_data) {
  CLIST_LINK *new_element;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::add_before_then_move", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::add_before_then_move", ABORT, NULL);
  if (!new_data)
    BAD_PARAMETER.error ("CLIST_ITERATOR::add_before_then_move", ABORT,
      "new_data is NULL");
  #endif

  new_element = new CLIST_LINK;
  new_element->data = new_data;

  if (list->empty ()) {
    new_element->next = new_element;
    list->last = new_element;
    prev = next = new_element;
  }
  else {
    prev->next = new_element;
    if (current) {               //not extracted
      new_element->next = current;
      next = current;
    }
    else {                       //current extracted
      new_element->next = next;
      if (ex_current_was_last)
        list->last = new_element;
      if (ex_current_was_cycle_pt)
        cycle_pt = new_element;
    }
  }
  current = new_element;
}


/***********************************************************************
 *							CLIST_ITERATOR::add_before_stay_put
 *
 *  Add a new element to the list before the current element but dont move the
 *  iterator to the new element.
 **********************************************************************/

inline void CLIST_ITERATOR::add_before_stay_put(  // element to add
                                                void *new_data) {
  CLIST_LINK *new_element;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::add_before_stay_put", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::add_before_stay_put", ABORT, NULL);
  if (!new_data)
    BAD_PARAMETER.error ("CLIST_ITERATOR::add_before_stay_put", ABORT,
      "new_data is NULL");
  #endif

  new_element = new CLIST_LINK;
  new_element->data = new_data;

  if (list->empty ()) {
    new_element->next = new_element;
    list->last = new_element;
    prev = next = new_element;
    ex_current_was_last = TRUE;
    current = NULL;
  }
  else {
    prev->next = new_element;
    if (current) {               //not extracted
      new_element->next = current;
      if (next == current)
        next = new_element;
    }
    else {                       //current extracted
      new_element->next = next;
      if (ex_current_was_last)
        list->last = new_element;
    }
    prev = new_element;
  }
}


/***********************************************************************
 *							CLIST_ITERATOR::add_list_after
 *
 *  Insert another list to this list after the current element but dont move the
 *  iterator.
 **********************************************************************/

inline void CLIST_ITERATOR::add_list_after(CLIST *list_to_add) {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::add_list_after", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::add_list_after", ABORT, NULL);
  if (!list_to_add)
    BAD_PARAMETER.error ("CLIST_ITERATOR::add_list_after", ABORT,
      "list_to_add is NULL");
  #endif

  if (!list_to_add->empty ()) {
    if (list->empty ()) {
      list->last = list_to_add->last;
      prev = list->last;
      next = list->First ();
      ex_current_was_last = TRUE;
      current = NULL;
    }
    else {
      if (current) {             //not extracted
        current->next = list_to_add->First ();
        if (current == list->last)
          list->last = list_to_add->last;
        list_to_add->last->next = next;
        next = current->next;
      }
      else {                     //current extracted
        prev->next = list_to_add->First ();
        if (ex_current_was_last) {
          list->last = list_to_add->last;
          ex_current_was_last = FALSE;
        }
        list_to_add->last->next = next;
        next = prev->next;
      }
    }
    list_to_add->last = NULL;
  }
}


/***********************************************************************
 *							CLIST_ITERATOR::add_list_before
 *
 *  Insert another list to this list before the current element. Move the
 *  iterator to the start of the inserted elements
 *  iterator.
 **********************************************************************/

inline void CLIST_ITERATOR::add_list_before(CLIST *list_to_add) {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::add_list_before", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::add_list_before", ABORT, NULL);
  if (!list_to_add)
    BAD_PARAMETER.error ("CLIST_ITERATOR::add_list_before", ABORT,
      "list_to_add is NULL");
  #endif

  if (!list_to_add->empty ()) {
    if (list->empty ()) {
      list->last = list_to_add->last;
      prev = list->last;
      current = list->First ();
      next = current->next;
      ex_current_was_last = FALSE;
    }
    else {
      prev->next = list_to_add->First ();
      if (current) {             //not extracted
        list_to_add->last->next = current;
      }
      else {                     //current extracted
        list_to_add->last->next = next;
        if (ex_current_was_last)
          list->last = list_to_add->last;
        if (ex_current_was_cycle_pt)
          cycle_pt = prev->next;
      }
      current = prev->next;
      next = current->next;
    }
    list_to_add->last = NULL;
  }
}


/***********************************************************************
 *							CLIST_ITERATOR::extract
 *
 *  Do extraction by removing current from the list, deleting the cons cell
 *  and returning the data to the caller, but NOT updating the iterator.  (So
 *  that any calling loop can do this.)  The iterator's current points to
 *  NULL.  If the data is to be deleted, this is the callers responsibility.
 **********************************************************************/

inline void *CLIST_ITERATOR::extract() {
  void *extracted_data;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::extract", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::extract", ABORT, NULL);
  if (!current)                  //list empty or
                                 //element extracted
    NULL_CURRENT.error ("CLIST_ITERATOR::extract",
      ABORT, NULL);
  #endif

  if (list->singleton()) {
    // Special case where we do need to change the iterator.
    prev = next = list->last = NULL;
  } else {
    prev->next = next;           //remove from list

    if (current == list->last) {
      list->last = prev;
      ex_current_was_last = TRUE;
    } else {
      ex_current_was_last = FALSE;
    }
  }
  // Always set ex_current_was_cycle_pt so an add/forward will work in a loop.
  ex_current_was_cycle_pt = (current == cycle_pt) ? TRUE : FALSE;
  extracted_data = current->data;
  delete(current);  //destroy CONS cell
  current = NULL;
  return extracted_data;
}


/***********************************************************************
 *							CLIST_ITERATOR::move_to_first()
 *
 *  Move current so that it is set to the start of the list.
 *  Return data just in case anyone wants it.
 **********************************************************************/

inline void *CLIST_ITERATOR::move_to_first() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::move_to_first", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::move_to_first", ABORT, NULL);
  #endif

  current = list->First ();
  prev = list->last;
  next = current != NULL ? current->next : NULL;
  return current != NULL ? current->data : NULL;
}


/***********************************************************************
 *							CLIST_ITERATOR::mark_cycle_pt()
 *
 *  Remember the current location so that we can tell whether we've returned
 *  to this point later.
 *
 *  If the current point is deleted either now, or in the future, the cycle
 *  point will be set to the next item which is set to current.  This could be
 *  by a forward, add_after_then_move or add_after_then_move.
 **********************************************************************/

inline void CLIST_ITERATOR::mark_cycle_pt() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::mark_cycle_pt", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::mark_cycle_pt", ABORT, NULL);
  #endif

  if (current)
    cycle_pt = current;
  else
    ex_current_was_cycle_pt = TRUE;
  started_cycling = FALSE;
}


/***********************************************************************
 *							CLIST_ITERATOR::at_first()
 *
 *  Are we at the start of the list?
 *
 **********************************************************************/

inline bool CLIST_ITERATOR::at_first() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::at_first", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::at_first", ABORT, NULL);
  #endif

                                 //we're at a deleted
  return ((list->empty ()) || (current == list->First ()) || ((current == NULL) &&
    (prev == list->last) &&      //NON-last pt between
    !ex_current_was_last));      //first and last
}


/***********************************************************************
 *							CLIST_ITERATOR::at_last()
 *
 *  Are we at the end of the list?
 *
 **********************************************************************/

inline bool CLIST_ITERATOR::at_last() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::at_last", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::at_last", ABORT, NULL);
  #endif

                                 //we're at a deleted
  return ((list->empty ()) || (current == list->last) || ((current == NULL) &&
    (prev == list->last) &&      //last point between
    ex_current_was_last));       //first and last
}


/***********************************************************************
 *							CLIST_ITERATOR::cycled_list()
 *
 *  Have we returned to the cycle_pt since it was set?
 *
 **********************************************************************/

inline bool CLIST_ITERATOR::cycled_list() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::cycled_list", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::cycled_list", ABORT, NULL);
  #endif

  return ((list->empty ()) || ((current == cycle_pt) && started_cycling));

}


/***********************************************************************
 *							CLIST_ITERATOR::length()
 *
 *  Return the length of the list
 *
 **********************************************************************/

inline inT32 CLIST_ITERATOR::length() {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::length", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::length", ABORT, NULL);
  #endif

  return list->length ();
}


/***********************************************************************
 *							CLIST_ITERATOR::sort()
 *
 *  Sort the elements of the list, then reposition at the start.
 *
 **********************************************************************/

inline void
CLIST_ITERATOR::sort (           //sort elements
int comparator (                 //comparison routine
const void *, const void *)) {
  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::sort", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::sort", ABORT, NULL);
  #endif

  list->sort (comparator);
  move_to_first();
}


/***********************************************************************
 *							CLIST_ITERATOR::add_to_end
 *
 *  Add a new element to the end of the list without moving the iterator.
 *  This is provided because a single linked list cannot move to the last as
 *  the iterator couldn't set its prev pointer.  Adding to the end is
 *  essential for implementing
              queues.
**********************************************************************/

inline void CLIST_ITERATOR::add_to_end(  // element to add
                                       void *new_data) {
  CLIST_LINK *new_element;

  #ifndef NDEBUG
  if (!this)
    NULL_OBJECT.error ("CLIST_ITERATOR::add_to_end", ABORT, NULL);
  if (!list)
    NO_LIST.error ("CLIST_ITERATOR::add_to_end", ABORT, NULL);
  if (!new_data)
    BAD_PARAMETER.error ("CLIST_ITERATOR::add_to_end", ABORT,
      "new_data is NULL");
  #endif

  if (this->at_last ()) {
    this->add_after_stay_put (new_data);
  }
  else {
    if (this->at_first ()) {
      this->add_before_stay_put (new_data);
      list->last = prev;
    }
    else {                       //Iteratr is elsewhere
      new_element = new CLIST_LINK;
      new_element->data = new_data;

      new_element->next = list->last->next;
      list->last->next = new_element;
      list->last = new_element;
    }
  }
}


/***********************************************************************
  QUOTE_IT   MACRO DEFINITION
  ===========================
Replace <parm> with "<parm>".  <parm> may be an arbitrary number of tokens
***********************************************************************/

#define QUOTE_IT( parm ) #parm

/***********************************************************************
  CLISTIZE( CLASSNAME ) MACRO DEFINITION
  ======================================

CLASSNAME is assumed to be the name of a class to be used in a CONS list

NOTE:  Because we dont use virtual functions in the list code, the list code
will NOT work correctly for classes derived from this.

The macro generates:
  - An element deletion function:      CLASSNAME##_c1_zapper
  - An element copier function:
              CLASSNAME##_c1_copier
  - An element serialiser function"    CLASSNAME##_c1_serialiser
  - An element de-serialiser function" CLASSNAME##_c1_de_serialiser
  - A CLIST subclass:		CLASSNAME##_CLIST
  - A CLIST_ITERATOR subclass:
              CLASSNAME##_C_IT

NOTE: Generated names do NOT clash with those generated by ELISTIZE,
ELIST2ISE and CLIST2IZE

Four macros are provided: CLISTIZE, CLISTIZE_S, CLISTIZEH and CLISTIZEH_S
The ...IZEH macros just define the class names for use in .h files
The ...IZE macros define the code use in .c files
The _S versions define lists which can be serialised.  They assume that the
make_serialise() macro is used in the list element class to define
serialise() and de_serialise() members for the list elements.
This, in turn, assumes that the list element class has prep_serialise()
dump() and de_dump() member functions.
***********************************************************************/

/***********************************************************************
  CLISTIZEH( CLASSNAME )  and  CLISTIZEH_S( CLASSNAME ) MACROS

These macros are constructed from 3 fragments CLISTIZEH_A, CLISTIZEH_B and
CLISTIZEH_C.  CLISTIZEH is simply a concatenation of these parts.
CLISTIZEH_S has some additional bits thrown in the gaps.
***********************************************************************/

#define CLISTIZEH_A( CLASSNAME )												\
                                                                                \
extern void			CLASSNAME##_c1_zapper(		/*delete a link*/		\
void*						link);						/*link to delete*/		\
                                                                                \
extern void*			CLASSNAME##_c1_copier(		/*deep copy a link*/	\
void*						old_element);   /*source link */

#define CLISTIZEH_B( CLASSNAME )												\
                                                                                \
/***********************************************************************		\
*							CLASS - CLASSNAME##_CLIST							\
*																				\
*							List class for class CLASSNAME						\
*																				\
**********************************************************************/			\
                                                                                \
class CLASSNAME##_CLIST : public CLIST			                        		\
{																				\
public:																			\
                            CLASSNAME##_CLIST():CLIST() {}						\
                                                        /* constructor */		\
                                                                                \
                            CLASSNAME##_CLIST(	/* dont construct */			\
    const CLASSNAME##_CLIST&)							/*by initial assign*/	\
    { DONT_CONSTRUCT_LIST_BY_COPY.error( QUOTE_IT( CLASSNAME##_CLIST ),			\
                                                        ABORT, NULL ); }		\
                                                                                \
void						deep_clear()				/* delete elements */	\
    { CLIST::internal_deep_clear( &CLASSNAME##_c1_zapper ); }					\
                                                                                \
void						deep_copy(					/* become a deep */		\
    const CLASSNAME##_CLIST*list)						/* copy of src list*/	\
    { CLIST::internal_deep_copy( &CLASSNAME##_c1_copier, list ); }				\
                                                                                \
void						operator=(					/* prevent assign */	\
    const CLASSNAME##_CLIST&)													\
    { DONT_ASSIGN_LISTS.error( QUOTE_IT( CLASSNAME##_CLIST ),					\
                                            ABORT, NULL ); }

#define CLISTIZEH_C( CLASSNAME )												\
                                                                                \
};																				\
                                                                                \
                                                                                \
                                                                                \
/***********************************************************************		\
*							CLASS - CLASSNAME##_C_IT							\
*																				\
*							Iterator class for class CLASSNAME##_CLIST			\
*																				\
*  Note: We don't need to coerce pointers to member functions input				\
*  parameters as these are automatically converted to the type of the base		\
*  type. ("A ptr to a class may be converted to a pointer to a public base		\
*  class of that class")														\
**********************************************************************/			\
                                                                                \
class                         CLASSNAME##_C_IT : public CLIST_ITERATOR			\
{																				\
public:																			\
                            CLASSNAME##_C_IT():CLIST_ITERATOR(){}				\
                                                                                \
                            CLASSNAME##_C_IT(									\
    CLASSNAME##_CLIST*		list):CLIST_ITERATOR(list){}						\
                                                                                \
    CLASSNAME*			data()												\
        { return (CLASSNAME*) CLIST_ITERATOR::data(); }						\
                                                                                \
    CLASSNAME*			data_relative(										\
    inT8					offset)												\
        { return (CLASSNAME*) CLIST_ITERATOR::data_relative( offset ); }		\
                                                                                \
    CLASSNAME*			forward()											\
        { return (CLASSNAME*) CLIST_ITERATOR::forward(); }					\
                                                                                \
    CLASSNAME*			extract()											\
        { return (CLASSNAME*) CLIST_ITERATOR::extract(); }					\
                                                                                \
    CLASSNAME*			move_to_first()										\
        { return (CLASSNAME*) CLIST_ITERATOR::move_to_first(); }				\
                                                                                \
    CLASSNAME*			move_to_last()										\
        { return (CLASSNAME*) CLIST_ITERATOR::move_to_last(); }				\
};

#define CLISTIZEH( CLASSNAME )													\
                                                                                \
CLISTIZEH_A( CLASSNAME )														\
                                                                                \
CLISTIZEH_B( CLASSNAME )														\
                                                                                \
CLISTIZEH_C( CLASSNAME )

#define CLISTIZEH_S( CLASSNAME )												\
                                                                                \
CLISTIZEH_A( CLASSNAME )														\
                                                                                \
extern void			CLASSNAME##_c1_serialiser(							\
FILE*						f,													\
void*						element);											\
                                                                                \
extern void*			CLASSNAME##_c1_de_serialiser(						\
FILE*						f);													\
                                                                                \
CLISTIZEH_B( CLASSNAME )														\
                                                                                \
    void					dump(						/* dump to file */		\
    FILE*					f)													\
    { CLIST::internal_dump( f, &CLASSNAME##_c1_serialiser );}					\
                                                                                \
    void					de_dump(					/* get from file */		\
    FILE*					f)													\
    { CLIST::internal_de_dump( f, &CLASSNAME##_c1_de_serialiser );}				\
                                                                                \
make_serialise( CLASSNAME##_CLIST )												\
                                                                                \
CLISTIZEH_C( CLASSNAME )

/***********************************************************************
  CLISTIZE( CLASSNAME )  and   CLISTIZE_S( CLASSNAME )  MACROS
CLISTIZE_S is a simple extension to CLISTIZE
***********************************************************************/

#define CLISTIZE( CLASSNAME )													\
                                                                                \
/***********************************************************************		\
*							CLASSNAME##_c1_zapper								\
*																				\
*  A function which can delete a CLASSNAME element.  This is passed to the		\
*  generic deep_clear list member function so that when a list is cleared the	\
*  elements on the list are properly destroyed from the base class, even		\
*  though we dont use a virtual destructor function.							\
**********************************************************************/			\
                                                                                \
void					CLASSNAME##_c1_zapper(		/*delete a link*/		\
void*						link)						/*link to delete*/		\
{																				\
delete (CLASSNAME *) link;														\
}																				\
                                                                                \
                                                                                \
                                                                                \
/***********************************************************************		\
*							CLASSNAME##_c1_copier								\
*																				\
*  A function which can generate a new, deep copy of a CLASSNAME element.		\
*  This is passed to the generic deep copy list member function so that when	\
*  a list is copied the elements on the list are properly copied from the		\
*  base class, even though we dont use a virtual function.						\
*																				\
**********************************************************************/			\
                                                                                \
void*				CLASSNAME##_c1_copier(		/*deep copy a link*/	\
void*						old_element)				/*source link*/			\
{																				\
    CLASSNAME*			new_element;										\
                                                                                \
new_element = new CLASSNAME;													\
*new_element = *((CLASSNAME*) old_element);									\
return (void*) new_element;														\
}

#define CLISTIZE_S( CLASSNAME )													\
                                                                                \
CLISTIZE( CLASSNAME )															\
                                                                                \
/***********************************************************************		\
*							CLASSNAME##_c1_serialiser							\
*																				\
*  A function which can serialise an element									\
*  This is passed to the generic dump member function so that when a list is	\
*  serialised the elements on the list are properly serialised.					\
**********************************************************************/			\
                                                                                \
void					CLASSNAME##_c1_serialiser(							\
FILE*						f,													\
void*						element)											\
{																				\
((CLASSNAME*) element)->serialise( f );										\
}																				\
                                                                                \
                                                                                \
                                                                                \
/***********************************************************************		\
*							CLASSNAME##_c1_de_serialiser						\
*																				\
*  A function which can de-serialise an element									\
*  This is passed to the generic de-dump member function so that when a list	\
*  is de-serialised the elements on the list are properly de-serialised.		\
**********************************************************************/			\
                                                                                \
void*				CLASSNAME##_c1_de_serialiser(						\
FILE*						f)													\
{																				\
return CLASSNAME::de_serialise( f );											\
}
/////////////////////////////////////////////////////////clst////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////ratngs//////////////////////////////////
class BLOB_CHOICE: public ELIST_LINK
{
  public:
    BLOB_CHOICE() {
      unichar_id_ = INVALID_UNICHAR_ID;
      config_ = '\0';
      rating_ = MAX_FLOAT32;
      certainty_ = -MAX_FLOAT32;
      script_id_ = -1;
    }
    BLOB_CHOICE(UNICHAR_ID src_unichar_id, // character id
                float src_rating,          // rating
                float src_cert,            // certainty
                inT8 src_config,           // config (font)
                int script_id);            // script
    BLOB_CHOICE(const BLOB_CHOICE &other);
    ~BLOB_CHOICE() {}
    UNICHAR_ID unichar_id() const {
      return unichar_id_;
    }
    float rating() const {
      return rating_;
    }
    float certainty() const {
      return certainty_;
    }
    inT8 config() const {
      return config_;
    }
    int script_id() const {
      return script_id_;
    }

    void set_unichar_id(UNICHAR_ID newunichar_id) {
      unichar_id_ = newunichar_id;
    }
    void set_rating(float newrat) {
      rating_ = newrat;
    }
    void set_certainty(float newrat) {
      certainty_ = newrat;
    }
    void set_config(inT8 newfont) {
      config_ = newfont;
    }
    void set_script(int newscript_id) {
      script_id_ = newscript_id;
    }

    static BLOB_CHOICE* deep_copy(const BLOB_CHOICE* src) {
      BLOB_CHOICE* choice = new BLOB_CHOICE;
      *choice = *src;
      return choice;
    }

    NEWDELETE
 private:
  UNICHAR_ID unichar_id_;          // unichar id
  char config_;                    // char config (font)
  inT16 junk2_;
  float rating_;                   // size related
  float certainty_;                // absolute
  int script_id_;
};

// Make BLOB_CHOICE listable.
ELISTIZEH(BLOB_CHOICE) CLISTIZEH (BLOB_CHOICE_LIST)

// Permuter codes used in WERD_CHOICEs.
enum PermuterType {
  NO_PERM,           // 0
  PUNC_PERM,         // 1
  TOP_CHOICE_PERM,   // 2
  LOWER_CASE_PERM,   // 3
  UPPER_CASE_PERM,   // 4
  NUMBER_PERM,       // 5
  SYSTEM_DAWG_PERM,  // 6
  DOC_DAWG_PERM,     // 7
  USER_DAWG_PERM,    // 8
  FREQ_DAWG_PERM,    // 9
  COMPOUND_PERM,     // 10
};

class WERD_CHOICE {
 public:
  WERD_CHOICE() { this->init(8); }
  WERD_CHOICE(int reserved) { this->init(reserved); }
  WERD_CHOICE(const char *src_string,
              const char *src_lengths,
              float src_rating,
              float src_certainty,
              uinT8 src_permuter,
              const UNICHARSET &unicharset) {
    this->init(src_string, src_lengths, src_rating,
               src_certainty, src_permuter, unicharset);
  }
  WERD_CHOICE (const char *src_string, const UNICHARSET &unicharset);
  WERD_CHOICE(const WERD_CHOICE &word) {
    this->init(word.length());
    this->operator=(word);
  }
  ~WERD_CHOICE();

  inline int length() const {
    return length_;
  }
  inline const UNICHAR_ID *unichar_ids() const {
    return unichar_ids_;
  }
  inline UNICHAR_ID unichar_id(int index) const {
    assert(index < length_);
    return unichar_ids_[index];
  }
  inline const char *fragment_lengths() const {
    return fragment_lengths_;
  }
  inline char fragment_length(int index) const {
    assert(index < length_);
    return fragment_lengths_[index];
  }
  inline float rating() const {
    return rating_;
  }
  inline float certainty() const {
    return certainty_;
  }
  inline uinT8 permuter() const {
    return permuter_;
  }
  inline bool fragment_mark() const {
    return fragment_mark_;
  }
  inline BLOB_CHOICE_LIST_CLIST* blob_choices() {
    return blob_choices_;
  }
  inline void set_unichar_id(UNICHAR_ID unichar_id, int index) {
    assert(index < length_);
    unichar_ids_[index] = unichar_id;
  }
  inline void set_rating(float new_val) {
    rating_ = new_val;
  }
  inline void set_certainty(float new_val) {
    certainty_ = new_val;
  }
  inline void set_permuter(uinT8 perm) {
    permuter_ = perm;
  }
  inline void set_fragment_mark(bool new_fragment_mark) {
    fragment_mark_ = new_fragment_mark;
  }
  void set_blob_choices(BLOB_CHOICE_LIST_CLIST *blob_choices);

  /// Make more space in unichar_id_ and fragment_lengths_ arrays.
  inline void double_the_size() {
    unichar_ids_ = GenericVector<UNICHAR_ID>::double_the_size_memcpy(
        reserved_, unichar_ids_);
    fragment_lengths_ = GenericVector<char>::double_the_size_memcpy(
        reserved_, fragment_lengths_);
    reserved_ *= 2;
  }

  /// Initializes WERD_CHOICE - reseves length slots in unichar_ids_ and
  /// fragment_length_ arrays. Sets other values to default (blank) values.
  inline void init(int reserved) {
    reserved_ = reserved;
    unichar_ids_ = new UNICHAR_ID[reserved];
    fragment_lengths_ = new char[reserved];
    length_ = 0;
    rating_ = 0.0;
    certainty_ = MAX_FLOAT32;
    permuter_ = NO_PERM;
    fragment_mark_ = false;
    blob_choices_ = NULL;
    unichar_string_ = "";
    unichar_lengths_ = "";
  }

  /// Helper function to build a WERD_CHOICE from the given string,
  /// fragment lengths, rating, certainty and permuter.
  /// The function assumes that src_string is not NULL.
  /// src_lengths argument could be NULL, in which case the unichars
  /// in src_string are assumed to all be of length 1.
  void init(const char *src_string, const char *src_lengths,
            float src_rating, float src_certainty,
            uinT8 src_permuter, const UNICHARSET &current_unicharset);

  /// Set the fields in this choice to be default (bad) values.
  inline void make_bad() {
    length_ = 0;
    rating_ = MAX_FLOAT32;
    certainty_ = -MAX_FLOAT32;
    fragment_mark_ = false;
    unichar_string_ = "";
    unichar_lengths_ = "";
  }

  /// This function assumes that there is enough space reserved
  /// in the WERD_CHOICE for adding another unichar.
  /// This is an efficient alternative to append_unichar_id().
  inline void append_unichar_id_space_allocated(
      UNICHAR_ID unichar_id, char fragment_length,
      float rating, float certainty) {
    assert(reserved_ > length_);
    length_++;
    this->set_unichar_id(unichar_id, fragment_length,
                         rating, certainty, length_-1);
  }

  void append_unichar_id(UNICHAR_ID unichar_id, char fragment_length,
                         float rating, float certainty);

  inline void set_unichar_id(UNICHAR_ID unichar_id, char fragment_length,
                             float rating, float certainty, int index) {
    assert(index < length_);
    unichar_ids_[index] = unichar_id;
    fragment_lengths_[index] = fragment_length;
    rating_ += rating;
    if (certainty < certainty_) {
      certainty_ = certainty;
    }
  }

  bool contains_unichar_id(UNICHAR_ID unichar_id) const;
  void remove_unichar_ids(int index, int num);
  inline void remove_last_unichar_id() { --length_; }
  inline void remove_unichar_id(int index) { this->remove_unichar_ids(index, 1); }
  void string_and_lengths(const UNICHARSET &current_unicharset,
                          STRING *word_str, STRING *word_lengths_str) const;
  const STRING debug_string(const UNICHARSET &current_unicharset) const {
    STRING word_str;
    for (int i = 0; i < length_; ++i) {
      word_str += current_unicharset.debug_str(unichar_ids_[i]);
      word_str += " ";
    }
    return word_str;
  }
  /// Since this function walks over the whole word to convert unichar ids
  /// to unichars, it is best to call it once, e.g. after all changes to
  /// unichar_ids_ in WERD_CHOICE are finished.
  void populate_unichars(const UNICHARSET &current_unicharset) {
    this->string_and_lengths(current_unicharset, &unichar_string_,
                             &unichar_lengths_);
  }
  /// This function should only be called if populate_unichars()
  /// was called and WERD_CHOICE did not change since then.
  const STRING &unichar_string() const {
    assert(unichar_string_.length() <= 0 ||
           unichar_string_.length() >= length_);  // sanity check
    return unichar_string_;
  }
  /// This function should only be called if populate_unichars()
  /// was called and WERD_CHOICE did not change since then.
  const STRING &unichar_lengths() const {
    assert(unichar_lengths_.length() <= 0 ||
           unichar_lengths_.length() == length_);  // sanity check
    return unichar_lengths_;
  }
  void print() const { this->print(""); }
  void print(const char *msg) const;

  WERD_CHOICE& operator+= (     // concatanate
    const WERD_CHOICE & second);// second on first

  WERD_CHOICE& operator= (const WERD_CHOICE& source);

  NEWDELETE private:
  UNICHAR_ID *unichar_ids_;  // unichar ids that represent the text of the word
  char *fragment_lengths_;   // number of fragments in each unichar
  int reserved_;             // size of the above arrays
  int length_;               // word length
  float rating_;             // size related
  float certainty_;          // absolute
  uinT8 permuter_;           // permuter code
  bool fragment_mark_;       // if true, indicates that this choice
                             // was chosen over a better one that
                             // contained a fragment
  BLOB_CHOICE_LIST_CLIST *blob_choices_;  // best choices for each blob

  // The following variables are only populated by calling populate_unichars().
  // They are not synchronized with the values in unichar_ids otherwise.
  STRING unichar_string_;
  STRING unichar_lengths_;
  bool unichar_info_present;

 private:
  void delete_blob_choices();
};

// Make WERD_CHOICE listable.
CLISTIZEH (WERD_CHOICE)
typedef GenericVector<BLOB_CHOICE_LIST *> BLOB_CHOICE_LIST_VECTOR;
typedef GenericVector<WERD_CHOICE_CLIST *> WERD_CHOICE_LIST_VECTOR;

typedef void (*POLY_TESTER) (const STRING&, PBLOB *, DENORM *, BOOL8,
                             char *, inT32, BLOB_CHOICE_LIST *);

void print_ratings_list(const char *msg, BLOB_CHOICE_LIST *ratings);
void print_ratings_list(
    const char *msg,                      // intro message
    BLOB_CHOICE_LIST *ratings,            // list of results
    const UNICHARSET &current_unicharset  // unicharset that can be used
                                          // for id-to-unichar conversion
    );
void print_ratings_info(
    FILE *fp,                             // file to use
    BLOB_CHOICE_LIST *ratings,            // list of results
    const UNICHARSET &current_unicharset  // unicharset that can be used
                                          // for id-to-unichar conversion
    );
void print_char_choices_list(
    const char *msg,
    const BLOB_CHOICE_LIST_VECTOR &char_choices,
    const UNICHARSET &current_unicharset,
    BOOL8 detailed
    );
//////////////////////////////////////////////////////////////ratngs//////////////////////////////////

//////////////////////////////////////////////////////////////debugwin//////////////////////////////////
//the following define the default position of a debug window
//if not specified at construction
#define DEBUG_WIN_XPOS    50     //default position
#define DEBUG_WIN_YPOS    30     //default position
#define DEBUG_WIN_XSIZE   700    //default size
#define DEBUG_WIN_YSIZE   300    //default size

//number of lines in the scrollable area of the window
extern INT_VAR_H(debug_lines, 256, "Number of lines in debug window");

//the API for the debug window is simple, see below.
//Most of its behaviour is its UI.
//It has a scrollable text area (most of the window)
//It has a stop control.
//It has a clear button.
//A dprintf to the window causes the text to be sent to the
//text area. If the stop control is set, then the dprintf
//blocks (does not display anything or return) until the stop
//is released.
//In multi-threaded apps, other threads and the UI continue to
//function during the stop. Only the calling thread is blocked.
//Pressing the clear button erases all text from the window.
//As text is sent to the window, it scrolls up so that the most
//recent output is visible. If the user has scrolled back, this
//does not happen. If the user scrolls back to the bottom, then
//the scrolling turns back on.
//If the user destroys the window, it never comes back.

class DEBUG_WIN
{
  public:
    //the constructor creates the window, the destructor kills it
    DEBUG_WIN (                  //constructor
      const char *title,         //of window
      inT32 xpos = DEBUG_WIN_XPOS,//initial position
      inT32 ypos = DEBUG_WIN_YPOS,//in pixels
                                 //initial size
      inT32 xsize = DEBUG_WIN_XSIZE,
                                 //in pixels
      inT32 ysize = DEBUG_WIN_YSIZE,
                                 //default scroll size (textlines)
      inT32 buflines = 256);

    ~DEBUG_WIN ();               //destructor

    void dprintf (               //printf to window
      const char *format, ...);  //message

    void await_destruction();  //wait for user to close

  #ifdef __MAC__
    static void SetCommander(LCommander *pCommander);
  #endif

  private:

  #ifdef __MSW32__
    HWND handle;                 //handle to window
    char *shm_mem;               //shared memory
    char *msg_end;               //current string
    HANDLE shm_hand;             //handle to it
    HANDLE dbg_process;          //handle to it
    HANDLE dbg_thread;           //handle to it
  #endif
  #ifdef __UNIX__
    FILE *fp;                    /*return file */
  #endif

  #ifdef __MAC__
    LWindow *pWindow;
  #endif
};
//////////////////////////////////////////////////////////////debugwin//////////////////////////////////

//////////////////////////////////////////////////////////////scanutils/////////////////////////////////
#ifndef _MSC_VER
// Parse a file stream according to the given format. See the fscanf manpage
// for more information, as this function attempts to mimic its behavior.
// Note that scientific floating-point notation is not supported.
// This variant is used to ensure correct reading regardless of locale.
int tess_fscanf(FILE* stream, const char *format, ...);
#endif

#ifdef EMBEDDED
// Attempts to parse the given file stream s as an integer of the base
// 'base'. Returns the first successfully parsed integer as a uintmax_t, or
// 0, if none was found.
uintmax_t streamtoumax(FILE* s, int base);

// Parse a file stream according to the given format. See the fscanf manpage
// for more information, as this function attempts to mimic its behavior.
// Note that scientific floating-point notation is not supported.
int fscanf(FILE* stream, const char *format, ...);

// Parse a file stream according to the given format. See the fscanf manpage
// for more information, as this function attempts to mimic its behavior.
// Note that scientific floating-point notation is not supported.
int vfscanf(FILE* stream, const char *format, va_list ap);

// Create a file at the specified path. See the creat manpage for more
// information, as this function attempts to mimic its behavior.
int creat(const char *pathname, mode_t mode);

// Convert the specified C-String to a float. Returns the first parsed float,
// or 0.0 if no floating point value could be found. Note that scientific
// floating-point notation is not supported.
double strtofloat(const char* s);

#endif
//////////////////////////////////////////////////////////////scanutils///////////////////////////////////////////

/////////////////////////////////////////////////////////varable//////////////////////////////////////////////
class INT_VARIABLE;

// Read config file.
extern  BOOL8 read_variables_file(
        const char *file,   // filename to read
        bool global_only);  // only set variables starting with "global_"

// Read variables from the given file pointer (stop at end_offset).
bool read_variables_from_fp(FILE *fp, inT64 end_offset, bool global_only);

// Set a variable to have the given value.
bool set_variable(const char *variable, const char* value);

// Print variables to a file.
extern  void print_variables(FILE *fp);

const char kGlobalVariablePrefix[] = "global_";

CLISTIZEH (INT_VARIABLE)
class  INT_VAR_FROM
{
    friend class INT_VAR_TO;
    public:
    INT_VAR_FROM();  //constructor
    private:
    INT_VARIABLE_CLIST list;     //copy of list
};

class  INT_VAR_TO
{
public:
    INT_VAR_TO();  //constructor
private:
    INT_VARIABLE_CLIST dummy;
};

class  INT_VARIABLE
{
    friend class INT_VAR_TO;
    friend class INT_VAR_FROM;
    //for setting values
    friend bool set_variable(const char *variable, const char* value);

public:
    INT_VARIABLE(inT32 v,               // initial value
                 const char *vname,     // name of variable
                 const char *comment);  // info on variable

    INT_VARIABLE()
    {  // for elist only
        value = 0;
        name = "NONAME";
        info = "Uninitialized";
    }
    ~INT_VARIABLE();            // for elist only

    operator inT32()
    {  // conversion
        return value;              // access as int
    }

    void set_value(inT32 v)
    {  // value to set
        value = v;
    }

    const char *name_str()
    {  // access name
        return name;
    }

    const char *info_str()
    {  // access name
        return info;
    }

    // access list head
    static INT_VARIABLE_CLIST *get_head();

    static void print(FILE *fp);  // file to print on

private:
    inT32 value;                 // the variable
    const char *name;            // name of variable
    const char *info;            // for menus
    static INT_VAR_FROM copy;    // pre constructor
    // start  of list
    static INT_VARIABLE_CLIST head;
    static INT_VAR_TO replace;   // post constructor
};

class BOOL_VARIABLE;

CLISTIZEH(BOOL_VARIABLE)
class BOOL_VAR_FROM
{
    friend class BOOL_VAR_TO;
    public:
    BOOL_VAR_FROM();  // constructor
    private:
    BOOL_VARIABLE_CLIST list;    // copy of list
};

class BOOL_VAR_TO
{
public:
    BOOL_VAR_TO();  // constructor
private:
    BOOL_VARIABLE_CLIST dummy;
};

class BOOL_VARIABLE
{
    friend class BOOL_VAR_FROM;
    friend class BOOL_VAR_TO;
    //for setting values
    friend bool set_variable(const char *variable, const char* value);

public:
    BOOL_VARIABLE(                       //constructor
                                         BOOL8 v,               //initial value
                                         const char *vname,     //name of variable
                                         const char *comment);  //info on variable

    BOOL_VARIABLE()
    {  //for elist only
        value = FALSE;
        name = "NONAME";
        info = "Uninitialized";
    }
    ~BOOL_VARIABLE ();           //for elist only

    operator BOOL8()
    {  //conversion
        return value;              //access as int
    }

    void set_value(            //assign to value
                               BOOL8 v)
    {  //value to set
        value = v;
    }

    const char *name_str()
    {  //access name
        return name;
    }

    const char *info_str()
    {  //access name
        return info;
    }

    //access list head
    static BOOL_VARIABLE_CLIST *get_head();

    static void print(            //print whole list
                                  FILE *fp);  //file to print on

private:
    BOOL8 value;                 //the variable
    const char *name;            //name of variable
    const char *info;            //for menus
    static BOOL_VAR_FROM copy;   //pre constructor
    //start  of list
    static BOOL_VARIABLE_CLIST head;
    static BOOL_VAR_TO replace;  //post constructor
};

class STRING_VARIABLE;

CLISTIZEH (STRING_VARIABLE)
class STRING_VAR_FROM
{
    friend class STRING_VAR_TO;
    public:
    STRING_VAR_FROM();  //constructor
    private:
    STRING_VARIABLE_CLIST list;  //copy of list
};

class STRING_VAR_TO
{
public:
    STRING_VAR_TO();  //constructor
private:
    STRING_VARIABLE_CLIST dummy;
};

class STRING_VARIABLE
{
    friend class STRING_VAR_TO;
    friend class STRING_VAR_FROM;
    //for setting values
    friend bool set_variable(const char *variable, const char* value);

public:
    STRING_VARIABLE(                       //constructor
                                           const char *v,         //initial value
                                           const char *vname,     //name of variable
                                           const char *comment);  //info on variable

    STRING_VARIABLE()
    {  //for elist only
        name = "NONAME";
        info = "Uninitialized";
    }
    ~STRING_VARIABLE ();         //for elist only

    //conversion
    operator const STRING &()
    {
        return value;              //access as int
    }

    void set_value(             //assign to value
                                STRING v)
    {  //value to set
        value = v;
    }

    const char *string() const
    {  //get string
        return value.string ();
    }

    const char *name_str()
    {  //access name
        return name;
    }

    const char *info_str()
    {  //access name
        return info;
    }

    //access list head
    static STRING_VARIABLE_CLIST *get_head();

    static void print(            //print whole list
                                  FILE *fp);  //file to print on

private:
    STRING value;                //the variable
    const char *name;            //name of variable
    const char *info;            //for menus
    static STRING_VAR_FROM copy; //pre constructor
    //start  of list
    static STRING_VARIABLE_CLIST head;
    static STRING_VAR_TO replace;//post constructor
};

class double_VARIABLE;

CLISTIZEH (double_VARIABLE)
class double_VAR_FROM
{
    friend class double_VAR_TO;
    public:
    double_VAR_FROM();  //constructor
    private:
    double_VARIABLE_CLIST list;  //copy of list
};

class double_VAR_TO
{
public:
    double_VAR_TO();  //constructor
private:
    double_VARIABLE_CLIST dummy;
};

class double_VARIABLE
{
    friend class double_VAR_TO;
    friend class double_VAR_FROM;
    //for setting values
    friend bool set_variable(const char *variable, const char* value);

public:
    double_VARIABLE(                       //constructor
                                           double v,              //initial value
                                           const char *vname,     //name of variable
                                           const char *comment);  //info on variable

    double_VARIABLE()
    {  //for elist only
        value = 0.0;
        name = "NONAME";
        info = "Uninitialized";
    }
    ~double_VARIABLE ();         //for elist only

    operator double()
    {  //conversion
        return value;              //access as int
    }

    void set_value(             //assign to value
                                double v)
    {  //value to set
        value = v;
    }

    const char *name_str()
    {  //access name
        return name;
    }

    const char *info_str()
    {  //access name
        return info;
    }

    //access list head
    static double_VARIABLE_CLIST *get_head();

    static void print(            //print whole list
                                  FILE *fp);  //file to print on

private:
    double value;                //the variable
    const char *name;            //name of variable
    const char *info;            //for menus
    static double_VAR_FROM copy; //pre constructor
    //start  of list
    static double_VARIABLE_CLIST head;
    static double_VAR_TO replace;//post constructor
};

/*************************************************************************
 * NOTE ON DEFINING VARIABLES
 *
 * For our normal code, the ***_VAR and ***_EVAR macros for variable
 * definitions are identical.  HOWEVER, for the code version to ship to NEVADA
 * (or anywhere else where we want to hide the majority of variables) the
 * **_VAR macros are changed so that the "#name" and "comment" parameters
 * to the variable constructor are changed to empty strings.  This prevents the
 * variable name or comment string appearing in the object code file (after it
 * has gone through strip).
 *
 * Certain variables can remain EXPOSED and hence be used in config files given
 * to UNLV. These are variable which have been declared with the ***_EVAR
 * macros.
 *
 *************************************************************************/
/////////////////////////////////////////////////////////varable///////////////////////////////////////////////

/////////////////////////////////////////////////////////tordvars/////////////////////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
extern FILE *rawfile;                       /* Text before dictionary */
extern FILE *textfile;                      /* Text output file */
extern FILE *correct_fp;                    //correct text
extern FILE *matcher_fp;

extern BOOL_VAR_H(tord_write_output, 0, "Text file output");

extern BOOL_VAR_H(tord_write_raw_output, 0, "Text before context");

extern BOOL_VAR_H(tord_similarity_enable, 0, "Switch for Similarity");

extern double_VAR_H(tord_certainty_threshold, -2.25, "Certainty Value");

extern INT_VAR_H(tord_num_word_choices, 30, "Number of choices");

extern BOOL_VAR_H(tord_blob_skip, 0, "Skip to Next selection");

extern double_VAR_H(tord_overlap_threshold, 0.33, "Overlap Threshold");

extern BOOL_VAR_H(tord_debug_3, 0, "Textord Debug #3");

extern BOOL_VAR_H(tord_debug_5, 0, "Textord Debug #5");

extern BOOL_VAR_H(tord_debug_8, 0, "Textord Debug #8");

extern INT_VAR_H(tord_display_ratings, 0, "Ratings display");

extern BOOL_VAR_H(tord_display_text, 0, "Display Text");

extern BOOL_VAR_H(tord_show_bold, 1, "Show Bold Text");
/////////////////////////////////////////////////////////tordvars/////////////////////////////////////////////

/////////////////////////////////////////////////////////memblk/////////////////////////////////////////////
#define MAXBLOCKS     16         /*max allowed to grab */
#define MAX_STRUCTS     20       //no of units maintained
#define MAX_CLASSES     24       //max classes of each size
#define MAX_FREE_S_BLOCKS 10     //max free list before all freed
#define STRUCT_BLOCK_SIZE 2521
#define MAX_CHUNK     262144     //max single chunk
#define FIRSTSIZE     16384      //size of first block
#define LASTSIZE      262144     //biggest size to use
#define BIGSIZE       2100000    //size of big blocks
#define MAX_BIGCHUNK    20000000 //max chunk of big mem

//#define TESTING_BIGSTUFF                                                                                      //define for big tests
//#define COUNTING_CLASS_STRUCTURES

class MEMUNION
{
  public:
    union
    {
      MEMUNION *ptr;             //next chunk
      inT32 size;                //chunk size
    };
    uinT16 owner;                //owner of chunk
    uinT16 age;                  //age of chunk
};

class MEMBLOCK
{
  public:
    MEMUNION * blockstart;       /*start of block */
    MEMUNION *blockend;          /*end of block */
    MEMUNION *freechunk;         /*next free chunk */
    MEMUNION *topchunk;          /*top free chunk */
    MEMBLOCK *next;              /*next block in chain */
    inT32 upperspace;            /*space above freechunk */
    inT32 lowerspace;            /*space below freechunk */

    MEMUNION *find_chunk(               //find free chunk
                         inT32 count);  //size required
};

class FREE_CALL
{
  public:
    void *freeer;                //return addr
    inT32 count;                 //no of frees
    FREE_CALL() {  //constructor
      freeer = NULL;
      count = 0;
    }
};
class MALLOC_CALL
{
  public:
    void *caller;                //return addr
    FREE_CALL *free_list;        //freeer counts
    inT32 *counts;               //no of blocks
    inT32 free_bits;             //bits in free table

    MALLOC_CALL() {  //constructor
      caller = NULL;
      free_list = NULL;
      counts = NULL;
      free_bits = 0;
    }
    void count_freeer(              //check a structure
                      void *addr);  //return address

    void init_freeers();  //check a structure
};

class MEM_ALLOCATOR
{
  public:
    inT16 blockcount;            //blocks in use
    uinT16 malloc_serial;        //serial allocation
    MEMBLOCK *topblock;          //block for permanents
    MEMBLOCK *currblock;         //current block
    MALLOC_CALL *callers;        //hash table of callers
    void *(*malloc) (inT32);     //external allocator
    void (*free) (void *);       //external free
    inT32 maxsize;               //biggest block
    inT32 biggestblock;          //biggest chunk
    inT32 totalmem;              //total free memory
    inT32 memsize;               //current block size
    uinT32 malloc_div_ratio;     //scaling of malloc_serial
    uinT32 malloc_minor_serial;  //scaling counter
    uinT32 malloc_auto_count;    //counts auto checks
    inT32 call_bits;             //size of table
    inT32 entries;               //size of table
                                 //all memory blocks
    MEMBLOCK memblocks[MAXBLOCKS];

    void init (                  //initialize
      void *(*ext_malloc) (inT32),//external source
      void (*ext_free) (void *), //external free
      inT32 firstsize,           //size of first block
      inT32 lastsize,            //size of last block
      inT32 maxchunk);           //biggest request

    void *alloc(                //allocator
                inT32 size,     //size of chunk
                void *caller);  //ptr to caller
    void *alloc_p(                //allocator
                  inT32 size,     //size of chunk
                  void *caller);  //ptr to caller
    void dealloc(                //deallocator
                 void *ptr,      //mem to free
                 void *caller);  //ptr to caller
    void check(                     //check chunks
               const char *string,  //message
               inT8 level);         //amount of checks

    void reduce_counts();  //divide by 2
    void display_counts();  //count up
    MEMBLOCK *new_block(                 //get new big block
                        inT32 minsize);  //minimum size
    uinT16 hash_caller(              //check a structure
                       void *addr);  //return address

  private:
    void init_callers();  //check a structure
    void set_owner(                       //set owner & date
                   MEMUNION *chunkstart,  //chunk to set
                   void *caller);         //ptr to caller
};
extern MEM_ALLOCATOR big_mem;
extern MEM_ALLOCATOR main_mem;
                                 //heads of freelists
extern MEMUNION *free_structs[MAX_STRUCTS];
                                 //number issued
extern inT32 structs_in_use[MAX_STRUCTS];
                                 //number issued
extern inT32 blocks_in_use[MAX_STRUCTS];
                                 //head of block lists
extern MEMUNION *struct_blocks[MAX_STRUCTS];
extern inT32 owner_counts[MAX_STRUCTS][MAX_CLASSES];

extern INT_VAR_H (mem_mallocdepth, 0, "Malloc stack depth to trace");
extern INT_VAR_H (mem_mallocbits, 8, "Log 2 of hash table size");
extern INT_VAR_H (mem_freedepth, 0, "Free stack dpeth to trace");
extern INT_VAR_H (mem_freebits, 8, "Log 2 of hash table size");
extern INT_VAR_H (mem_countbuckets, 16, "No of buckets for histogram");
extern INT_VAR_H (mem_checkfreq, 0,
"Calls to alloc_mem between owner counts");

void *trace_caller(             //trace stack
                   inT32 depth  //depth to trace
                  );
inT32 identify_struct_owner(                     //get table index
                            inT32 struct_count,  //cell size
                            const char *name     //name of type
                           );
void check_struct(             //check a structure
                  inT8 level,  //print control
                  inT32 count  //no of bytes
                 );
void check_structs(            //count in use on structs
                   inT8 level  //print control
                  );
void *new_struct_block();  //allocate memory
void old_struct_block(                     //free a structure block
                      MEMUNION *deadblock  //block to free
                     );
/////////////////////////////////////////////////////////memblk////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////IMAGE/////////////////////////////////////////////////////////////////////////
struct Pix;

/** 14inch * 400dpi */
#define MAXIMAGEWIDTH   (900*14)

/** 14inch * 400dpi */
#define MAXIMAGEHEIGHT    (900*14)

#define COMPUTE_IMAGE_XDIM(xsize,bpp) ((bpp)>8 ? ((xsize)*(bpp)+7)/8 :((xsize)+8/(bpp)-1)/(8/(bpp)))

typedef inT8 (*IMAGE_OPENER) (int, inT32 *, inT32 *, inT8 *, inT8 *, inT32 *);
typedef inT8 (*IMAGE_READER) (int, uinT8 *, inT32, inT32, inT8, inT32);
typedef inT8 (*IMAGE_WRITER) (int, uinT8 *, inT32, inT32, inT8, inT8, inT32);

/** array of colours */
typedef uinT8 *COLOUR_PIX;
enum COLOUR_PIX_NAME
{
    RED_PIX,
    GREEN_PIX,
    BLUE_PIX
};

class IMAGELINE;

/** encapsulated image */
class IMAGE
{
public:
    IMAGE();  //constructor

    ~IMAGE ()
    {                  //destructor
        destroy();  //free memory
    }

    IMAGE & operator= (          //assignment
                                 IMAGE & source);

    /**
     * get file header
     * @param name name of image
     */
    inT8 read_header(const char *name);

    /**
     * get rest of image
     * @param buflines size of buffer
     */
    inT8 read(inT32 buflines);

    /**
     * write image
     * @param name name to write
     */
    inT8 write(const char *name);

    /**
     * create blank image
     * @param x x size required
     * @param y y size required
     * @param bits_per_pixel bpp required
     */
    inT8 create(inT32 x, inT32 y, inT8 bits_per_pixel);

    /**
     * capture raw image
     * @param pixels pixels to capture
     * @param x x size required
     * @param y y size required
     * @param bits_per_pixel bpp required
     */
    inT8 capture(uinT8 *pixels, inT32 x, inT32 y, inT8 bits_per_pixel);

    /** destroy image */
    void destroy();

    /**
     * access function
     * @return xsize
     */
    inT32 get_xsize()
    {
        return xsize;
    }

    /**
     * access function
     * @return ysize
     */
    inT32 get_ysize()
    {
        return ysize;
    }

    /**
     * access function
     * @return bits per pixel
     */
    inT8 get_bpp()
    {
        return bpp;
    }

    /**
     * access function
     * @return bits per sample
     */
    inT8 get_bps()
    {
        return bps;
    }

    /** photo interp */
    BOOL8 white_high()
    {
        return photo_interp;
    }

    /** access function */
    uinT8 get_white_level()
    {
        return (1 << bpp) - 1;
    }

    /** get resolution */
    inT32 get_res()
    {
        return res;
    }

    /** set resolution */
    void set_res(inT32 resolution)
    {
        res = resolution;
    }

    uinT8 *get_buffer()
    {
        return image;
    }

    /**
     * access pixel
     * @param x coord
     * @param y coord
     */
    uinT8 pixel(inT32 x, inT32 y);

    /**
     * get image line
     * @param x coord to start at
     * @param y line to get
     * @param width line to get
     * @param linebuf line to copy to
     */
    void fast_get_line(inT32 x, inT32 y, inT32 width, IMAGELINE *linebuf);

    /**
     * get image line
     * @param x coord to start at
     * @param y line to get
     * @param width line to get
     * @param linebuf line to copy to
     * @param margins size of margins
     */
    void get_line(inT32 x, inT32 y, inT32 width, IMAGELINE *linebuf, inT32 margins);

    /**
     * get image column
     * @param x coord to start at
     * @param y line to get
     * @param height number of pixels to get
     * @param linebuf line to copy to
     * @param margins size of margins
     */
    void get_column(inT32 x, inT32 y, inT32 height, IMAGELINE *linebuf, inT32 margins);

    /**
     * put image line
     * @param x coord to start at
     * @param y line to put
     * @param width number of pixels to put
     * @param linebuf line to copy from
     */
    void fast_put_line(inT32 x, inT32 y, inT32 width, IMAGELINE *linebuf);

    /**
     * put image line
     * @param x coord to start at
     * @param y line to put
     * @param width number of pixels to put
     * @param linebuf line to copy from
     * @param margins size of margins
     */
    void put_line(inT32 x, inT32 y, inT32 width, IMAGELINE *linebuf, inT32 margins);

    /**
     * put image column
     * @param x coord to start at
     * @param y line to put
     * @param height number of pixels to put
     * @param linebuf line to copy to
     * @param margins size of margins
     */
    void put_column(inT32 x, inT32 y, inT32 height, IMAGELINE *linebuf, inT32 margins);

    /**
     * check coordinates
     * @param x xcoord to check
     * @param y ycoord to check
     */
    void check_legal_access(inT32 x, inT32 y, inT32 xext);


    /** Methods to convert image types. Only available if Leptonica is available. */
    Pix* ToPix();
    void FromPix(const Pix* src_pix);

    /**
     * Map function over window
     * @param win_width Window width
     * @param win_height Window height
     * @param convolve Conv function
     */
    void convolver (
            inT32 win_width,
            inT32 win_height,
            void (*convolve) (
                uinT8 ** pixels,           ///< Of window
                uinT8 bytespp,             ///< 1 or 3 for colour
                inT32 win_wd,              ///< Window width
                inT32 win_ht,              ///< Window height
                uinT8 ret_white_value,     ///< White value to RETURN
                uinT8 * result             ///< Result pixel(s)
                ));

    //copy rectangle
    friend  void copy_sub_image(IMAGE *source,  //source image
                                      inT32 xstart,   //start coords
                                      inT32 ystart,
                                      inT32 xext,     //extent to copy
                                      inT32 yext,
                                      IMAGE *dest,    //destination image
                                      inT32 xdest,    //destination coords //shift to match bpp
                                      inT32 ydest,
                                      BOOL8 adjust_grey);

    //enlarge rectangle
    friend void enlarge_sub_image(IMAGE *source,       //source image
                                         inT32 xstart,        //scaled coords
                                         inT32 ystart,
                                         IMAGE *dest,         //destination image
                                         inT32 xdest,         //destination coords
                                         inT32 ydest,
                                         inT32 xext,          //extent to copy
                                         inT32 yext,
                                         inT32 scale,         //scale factor
                                         BOOL8 adjust_grey);  //shift to match bpp

    //reduce rectangle
    friend void fast_reduce_sub_image(IMAGE *source,       //source image
                                             inT32 xstart,        //start coords
                                             inT32 ystart,
                                             inT32 xext,          //extent to copy
                                             inT32 yext,
                                             IMAGE *dest,         //destination image
                                             inT32 xdest,         //destination coords
                                             inT32 ydest,
                                             inT32 scale,         //scale factor
                                             BOOL8 adjust_grey);  //shift to match bpp

    //reduce rectangle
    friend void reduce_sub_image(IMAGE *source,       //source image
                                        inT32 xstart,        //start coords
                                        inT32 ystart,
                                        inT32 xext,          //extent to copy
                                        inT32 yext,
                                        IMAGE *dest,         //destination image
                                        inT32 xdest,         //destination coords
                                        inT32 ydest,
                                        inT32 scale,         //scale factor
                                        BOOL8 adjust_grey);  //shift to match bpp

private:
    inT8 bpp;                    ///< bits per pixel
    inT8 bps;                    ///< bits per sample
    inT8 bytespp;                ///< per pixel
    inT8 lineskip;               ///< waste bytes on line
    BOOL8 captured;              ///< true if buffer captured
    inT8 photo_interp;           ///< interpretation
    inT32 xsize, ysize;          ///< size of image
    inT32 res;                   ///< resolution
public:
    uinT8 *image;                ///< the actual image
    inT32 xdim;                  ///< bytes per line
    inT32 bufheight;             ///< height of buffer
    int fd;                      ///< open file descriptor
    IMAGE_READER reader;         ///< reading function
    inT32 ymin;                  ///< bottom line in mem
    inT32 ymax;                  ///< top line in mem+1
    /**
     * read some more
     * @param y ycoord required
     */
    inT8 bufread(inT32 y);
};

class IMAGELINE           //one line of image
{
public:
    uinT8 * pixels;              ///< image pixels
    inT8 bpp;                    ///< bits per pixel
    /** colour pixels */
    COLOUR_PIX operator[] (inT32 index)
    {
        return &pixels[index * 3]; //coercion access op
    }

    /** default constructor */
    IMAGELINE()
    {
        linewidth = 0;
        line = NULL;
        pixels = line;
        bpp = 8;
    }

    //setup size
    void init(inT32 width)
    {
        //size of line
        if (width <= 0)
        {
            width = MAXIMAGEWIDTH;
        }

        if (width > linewidth)
        {
            if (line != NULL) free_mem(line);

            linewidth = width;
            line = (uinT8 *) alloc_mem(linewidth * sizeof (uinT8));
        }

        pixels = line;
        bpp = 8;
    }

    ~IMAGELINE ()
    {              //destructor
        if (line != NULL)
            free_mem(line);
    }

    /** For colour */
    void set_bpp(inT8 new_bpp)
    {
        if (new_bpp <= 8)
            bpp = 8;
        else
            bpp = 24;
    }

    void init()
    {
        if (line == NULL)
        {
            init (0);
        }
        else
        {
            pixels = line;
            bpp = 8;
        }
    }

    /**
     * copies a line
     * @param x coord to start at
     * @param y line to get
     * @param width no of pixels to get
     * @param linebuf line to copy to
     * @param margins size of margins
     */
    friend void IMAGE::get_line(inT32 x, inT32 y, inT32 width, IMAGELINE *linebuf, inT32 margins);
    /**
     * copies a column
     * @param x coord to start at
     * @param y line to get
     * @param height no of pixels to get
     * @param linebuf line to copy to
     * @param margins size of margins
     */
    friend void IMAGE::get_column(inT32 x, inT32 y, inT32 height, IMAGELINE *linebuf, inT32 margins);

    /**
     * writes a line
     * @param x coord to start at
     * @param y line to get
     * @param width no of pixels to put
     * @param linebuf line to copy to
     * @param margins size of margins
     */
    friend void IMAGE::put_line(inT32 x, inT32 y, inT32 width, IMAGELINE *linebuf, inT32 margins);

    /**
     * writes a column
     * @param x coord to start at
     * @param y line to get
     * @param height no of pixels to put
     * @param linebuf line to copy to
     * @param margins size of margins
     */
    friend void IMAGE::put_column(inT32 x,inT32 y, inT32 height, IMAGELINE *linebuf, inT32 margins);

    /**
     * @note may just change pointer
     * @param x coord to start at
     * @param y line to get
     * @param width no of pixels to get
     * @param linebuf line to copy to
     */
    friend void IMAGE::fast_get_line(inT32 x, inT32 y, inT32 width, IMAGELINE *linebuf);

    /**
     * @note may just change pointer
     * @param x coord to start at
     * @param y line to get
     * @param width no of pixels to put
     * @param linebuf line to copy to
     */
    friend void IMAGE::fast_put_line(inT32 x, inT32 y, inT32 width, IMAGELINE *linebuf);

private:
    uinT8 * line;                ///< local buffer
    inT32 linewidth;             ///< width of buffer
};
////////////////////////////////////////////////////////////////IMAGE/////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////bitstrm////////////////////////////////////////////////////////
#define BITBUFSIZE      8192     //bitstream buffer

class R_BITSTREAM
{
private:
    int bitfd;                   //file descriptor
    inT32 bitindex;              //current byte
    uinT32 bitword;              //current word
    inT32 bitbit;                //current bit
    inT32 bufsize;               //size of buffer
    uinT8 bitbuf[BITBUFSIZE];    //bitstream buffer
    //for reading codes
    static const uinT16 bitmasks[17];

public:

    //Null constructor
    R_BITSTREAM()
    {
    }

    //open to read
    uinT16 open(int fd);  //file to read

    //read a code
    uinT16 read_code(uinT8 length);  //bits to lose

    //read a code
    uinT16 masks(inT32 index);  //bits to lose
};

class W_BITSTREAM
{
private:
    int bitfd;                   //file descriptor
    inT32 bitindex;              //current byte
    uinT32 bitword;              //current word
    inT32 bitbit;                //current bit
    uinT8 bitbuf[BITBUFSIZE];    //bitstream buffer

public:
    //Null constructor
    W_BITSTREAM()
    {
    }

    //open to write
    void open(int fd);  //file to write

    //write a code  //code to write   //bits to lose
    inT8 write_code(uinT16 code,      uinT8 length);
};
///////////////////////////////////////////bitstrm////////////////////////////////////////////////////////

///////////////////////////////////////////imgtiff////////////////////////////////////////////////////////
inT8 open_tif_image(               //read header
                    int fd,        //file to read
                    inT32 *xsize,  //size of image
                    inT32 *ysize,
                    inT8 *bpp,     //bits per pixel
                    inT8 *photo,   //interpretation
                    inT32 *res     //resolution
                   );
inT8 read_tif_image(                //read whole image
                    int fd,         //file to read
                    uinT8 *pixels,  //pixels of image
                    inT32 xsize,    //size of image
                    inT32 ysize,
                    inT8 bpp,       //bits per pixel
                    inT32           //bytes per line
                   );
inT32 read_eol(                    //read end of line
               R_BITSTREAM *bits,  //bitstream to read
               uinT16 &code        //current code
              );
inT8 write_moto_tif(                //write whole image
                    int fd,         //file to write on
                    uinT8 *pixels,  //image pixels
                    inT32 xsize,    //size of image
                    inT32 ysize,
                    inT8 bpp,       //bits per pixel
                    inT8 photo,
                    inT32 res       //resolution
                   );
inT8 write_intel_tif(                //write whole image
                     int fd,         //file to write on
                     uinT8 *pixels,  //image pixels
                     inT32 xsize,    //size of image
                     inT32 ysize,
                     inT8 bpp,       //bits per pixel
                     inT8 photo,
                     inT32 res       //resolution
                    );
inT8 write_inverse_tif(                //write whole image
                       int fd,         //file to write on
                       uinT8 *pixels,  //image pixels
                       inT32 xsize,    //size of image
                       inT32 ysize,
                       inT8 bpp,       //bits per pixel
                       inT8 photo,
                       inT32 res       //resolution
                      );
inT8 write_tif_image(                //write whole image
                     int fd,         //file to write on
                     uinT8 *pixels,  //image pixels
                     inT32 xsize,    //size of image
                     inT32 ysize,
                     inT8 bpp,       //bits per pixel
                     inT32 res,      //resolution
                     inT16 type,     //format type
                     inT16 photo     //metric interp
                    );
///////////////////////////////////////////imgtiff////////////////////////////////////////////////////////

/////////////////////////////////////////////////imgbmp/////////////////////////////////////////////////
inT8 open_bmp_image(               //read header
                    int fd,        //file to read
                    inT32 *xsize,  //size of image
                    inT32 *ysize,
                    inT8 *bpp,     //bits per pixel
                    inT8 *photo,
                    inT32 *res     //resolution
                   );
inT8 read_bmp_image(                //read header
                    int fd,         //file to read
                    uinT8 *pixels,  //pixels of image
                    inT32 xsize,    //size of image
                    inT32 ysize,
                    inT8 bpp,       //bits per pixel
                    inT32           //bytes per line
                   );
inT8 write_bmp_image(                //write whole image
                     int fd,         //file to write on
                     uinT8 *pixels,  //image pixels
                     inT32 xsize,    //size of image
                     inT32 ysize,
                     inT8 bpp,       //bits per pixel
                     inT8,
                     inT32           //resolution
                    );
/////////////////////////////////////////////////imgbmp/////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
const int kHistogramSize = 256;  // The size of a histogram of pixel values.

// Compute the Otsu threshold(s) for the given image rectangle, making one
// for each channel. Each channel is always one byte per pixel.
// Returns an array of threshold values and an array of hi_values, such
// that a pixel value >threshold[channel] is considered foreground if
// hi_values[channel] is 0 or background if 1. A hi_value of -1 indicates
// that there is no apparent foreground. At least one hi_value will not be -1.
// Delete thresholds and hi_values with delete [] after use.
void OtsuThreshold(const unsigned char* imagedata,
                   int bytes_per_pixel, int bytes_per_line,
                   int left, int top, int width, int height,
                   int** thresholds, int** hi_values);

// Compute the histogram for the given image rectangle, and the given
// channel. (Channel pointed to by imagedata.) Each channel is always
// one byte per pixel.
// Bytes per pixel is used to skip channels not being
// counted with this call in a multi-channel (pixel-major) image.
// Histogram is always a 256 element array to count occurrences of
// each pixel value.
void HistogramRect(const unsigned char* imagedata,
                   int bytes_per_pixel, int bytes_per_line,
                   int left, int top, int width, int height,
                   int* histogram);

// Compute the Otsu threshold(s) for the given histogram.
// Also returns H = total count in histogram, and
// omega0 = count of histogram below threshold.
int OtsuStats(const int* histogram, int* H_out, int* omega0_out);

////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////ImageThresholder/////////////////////////
class IMAGE;
struct Pix;
/// Base class for all image thresholding classes.
/// Specific classes can add new thresholding methods by
/// overriding ThresholdToIMAGE and/or ThresholdToPix.
/// Each instance deals with a single image, but the design is intended to
/// be useful for multiple calls to SetRectangle and ThresholdTo* if
/// desired.
class ImageThresholder {
 public:
  ImageThresholder();
  virtual ~ImageThresholder();

  /// Destroy the Pix if there is one, freeing memory.
  virtual void Clear();

  /// Return true if no image has been set.
  bool IsEmpty() const;

  /// SetImage makes a copy of only the metadata, not the underlying
  /// image buffer. It promises to treat the source as read-only in either case,
  /// but in return assumes that the Pix or image buffer remain valid
  /// throughout the life of the ImageThresholder.
  /// Greyscale of 8 and color of 24 or 32 bits per pixel may be given.
  /// Palette color images will not work properly and must be converted to
  /// 24 bit.
  /// Binary images of 1 bit per pixel may also be given but they must be
  /// byte packed with the MSB of the first byte being the first pixel, and a
  /// one pixel is WHITE. For binary images set bytes_per_pixel=0.
  void SetImage(const unsigned char* imagedata, int width, int height,
                int bytes_per_pixel, int bytes_per_line);

  /// Store the coordinates of the rectangle to process for later use.
  /// Doesn't actually do any thresholding.
  void SetRectangle(int left, int top, int width, int height);

  /// Get enough parameters to be able to rebuild bounding boxes in the
  /// original image (not just within the rectangle).
  /// Left and top are enough with top-down coordinates, but
  /// the height of the rectangle and the image are needed for bottom-up.
  virtual void GetImageSizes(int* left, int* top, int* width, int* height,
                             int* imagewidth, int* imageheight);

  /// Return true if HAVE_LIBLEPT and this thresholder implements the Pix
  /// interface.
  virtual bool HasThresholdToPix() const;

  /// Return true if the source image is color.
  bool IsColor() const {
    return image_bytespp_ >= 3;
  }

  /// Threshold the source image as efficiently as possible to the output
  /// tesseract IMAGE class.
  virtual void ThresholdToIMAGE(IMAGE* image);

#ifdef HAVE_LIBLEPT
  /// Pix vs raw, which to use?
  /// Implementations should provide the ability to source and target Pix
  /// where possible. A future version of Tesseract may choose to use Pix
  /// as its internal representation and discard IMAGE altogether.
  /// Because of that, an implementation that sources and targets Pix may end up
  /// with less copies than an implementation that does not.
  /// NOTE: Opposite to SetImage for raw images, SetImage for Pix clones its
  /// input, so the source pix may be pixDestroyed immediately after.
  void SetImage(const Pix* pix);

  /// Threshold the source image as efficiently as possible to the output Pix.
  /// Creates a Pix and sets pix to point to the resulting pointer.
  /// Caller must use pixDestroy to free the created Pix.
  virtual void ThresholdToPix(Pix** pix);

  /// Get a clone/copy of the source image rectangle.
  /// The returned Pix must be pixDestroyed.
  /// This function will be used in the future by the page layout analysis, and
  /// the layout analysis that uses it will only be available with Leptonica,
  /// so there is no raw equivalent.
  Pix* GetPixRect();
#endif

 protected:
  // ----------------------------------------------------------------------
  // Utility functions that may be useful components for other thresholders.

  /// Common initialization shared between SetImage methods.
  virtual void Init();

  /// Return true if we are processing the full image.
  bool IsFullImage() const {
    return rect_left_ == 0 && rect_top_ == 0 &&
           rect_width_ == image_width_ && rect_height_ == image_height_;
  }

  /// Otsu threshold the rectangle, taking everything except the image buffer
  /// pointer from the class, to the output IMAGE.
  void OtsuThresholdRectToIMAGE(const unsigned char* imagedata,
                                int bytes_per_pixel, int bytes_per_line,
                                IMAGE* image) const;

  /// Threshold the rectangle, taking everything except the image buffer pointer
  /// from the class, using thresholds/hi_values to the output IMAGE.
  void ThresholdRectToIMAGE(const unsigned char* imagedata,
                            int bytes_per_pixel, int bytes_per_line,
                            const int* thresholds, const int* hi_values,
                            IMAGE* image) const;

  /// Cut out the requested rectangle of the source raw binary image to the
  /// output IMAGE.
  void CopyBinaryRectRawToIMAGE(IMAGE* image) const;

#ifdef HAVE_LIBLEPT
  /// Otsu threshold the rectangle, taking everything except the image buffer
  /// pointer from the class, to the output Pix.
  void OtsuThresholdRectToPix(const unsigned char* imagedata,
                              int bytes_per_pixel, int bytes_per_line,
                              Pix** pix) const;

  /// Threshold the rectangle, taking everything except the image buffer pointer
  /// from the class, using thresholds/hi_values to the output IMAGE.
  void ThresholdRectToPix(const unsigned char* imagedata,
                          int bytes_per_pixel, int bytes_per_line,
                          const int* thresholds, const int* hi_values,
                          Pix** pix) const;

  /// Copy the raw image rectangle, taking all data from the class, to the Pix.
  void RawRectToPix(Pix** pix) const;

  /// Cut out the requested rectangle of the binary image to the output IMAGE.
  void CopyBinaryRectPixToIMAGE(IMAGE* image) const;
#endif

 protected:
#ifdef HAVE_LIBLEPT
  /// Clone or other copy of the source Pix.
  /// The pix will always be PixDestroy()ed on destruction of the class.
  Pix*                 pix_;
#endif
  /// Exactly one of pix_ and image_data_ is not NULL.
  const unsigned char* image_data_;     //< Raw source image.

  int                  image_width_;    //< Width of source image/pix.
  int                  image_height_;   //< Height of source image/pix.
  int                  image_bytespp_;  //< Bytes per pixel of source image/pix.
  int                  image_bytespl_;  //< Bytes per line of source image/pix.
  // Limits of image rectangle to be processed.
  int                  rect_left_;
  int                  rect_top_;
  int                  rect_width_;
  int                  rect_height_;
};
/////////////////////////////////////////////////////////////////ImageThresholder////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////AmbigSpec////////////////////////////////////////
// AMBIG_SPEC_LIST stores a list of dangerous ambigs that
// start with the same unichar (e.g. r->t rn->m rr1->m).
class AmbigSpec : public ELIST_LINK
{
public:
    AmbigSpec();
    ~AmbigSpec() {}

    // Comparator function for sorting AmbigSpec_LISTs. The lists will
    // be sorted by their wrong_ngram arrays. Example of wrong_ngram vectors
    // in a a sorted AmbigSpec_LIST: [9 1 3], [9 3 4], [9 8], [9, 8 1].
    static int compare_ambig_specs(const void *spec1, const void *spec2)
    {
        const AmbigSpec *s1 = *reinterpret_cast<const AmbigSpec * const *>(spec1);
        const AmbigSpec *s2 = *reinterpret_cast<const AmbigSpec * const *>(spec2);

        return UnicharIdArrayUtils::compare(s1->wrong_ngram, s2->wrong_ngram);
    }

    int wrong_ngram[MAX_AMBIG_SIZE + 1];
    int correct_fragments[MAX_AMBIG_SIZE + 1];
    int correct_ngram_id;
    AmbigType type;
    int wrong_ngram_size;
};

ELISTIZEH(AmbigSpec)

// AMBIG_TABLE[i] stores a set of ambiguities whose
// wrong ngram starts with unichar id i.
typedef GenericVector<AmbigSpec_LIST *> UnicharAmbigsVector;
typedef GenericVector<int> UnicharIdVector;
/////////////////////////////////////////////////////////////////AmbigSpec////////////////////////////////////////

/////////////////////////////////////////////////////////////////TessdataManager////////////////////////////////////////
extern BOOL_VAR_H(global_load_punc_dawg, true,
                  "Load dawg with punctuation patterns.");
extern BOOL_VAR_H(global_load_system_dawg, true, "Load system word dawg.");
extern BOOL_VAR_H(global_load_number_dawg, true,
                  "Load dawg with number patterns.");
extern BOOL_VAR_H(global_load_freq_dawg, true, "Load frequent word dawg.");

extern INT_VAR_H(global_tessdata_manager_debug_level, 0,
                 "Debug level for TessdataManager functions.");

static const char kTrainedDataSuffix[] = "traineddata";

// When adding new tessdata types and file suffixes, please make sure to
// update TessdataType enum, kTessdataFileSuffixes and kTessdataFileIsText.
static const char kLangConfigFileSuffix[] = "config";
static const char kUnicharsetFileSuffix[] = "unicharset";
static const char kAmbigsFileSuffix[] = "unicharambigs";
static const char kBuiltInTemplatesFileSuffix[] = "inttemp";
static const char kBuiltInCutoffsFileSuffix[] = "pffmtable";
static const char kNormProtoFileSuffix[] = "normproto";
static const char kPuncDawgFileSuffix[] = "punc-dawg";
static const char kSystemDawgFileSuffix[] = "word-dawg";
static const char kNumberDawgFileSuffix[] = "number-dawg";
static const char kFreqDawgFileSuffix[] = "freq-dawg";

enum TessdataType {
    TESSDATA_LANG_CONFIG,  // 0
    TESSDATA_UNICHARSET,   // 1
    TESSDATA_AMBIGS,       // 2
    TESSDATA_INTTEMP,      // 3
    TESSDATA_PFFMTABLE,    // 4
    TESSDATA_NORMPROTO,    // 5
    TESSDATA_PUNC_DAWG,    // 6
    TESSDATA_SYSTEM_DAWG,  // 7
    TESSDATA_NUMBER_DAWG,  // 8
    TESSDATA_FREQ_DAWG,    // 9

    TESSDATA_NUM_ENTRIES
};

/**
 * kTessdataFileSuffixes[i] indicates the file suffix for
 * tessdata of type i (from TessdataType enum).
 */
static const char * const kTessdataFileSuffixes[] =
{
    kLangConfigFileSuffix,        // 0
    kUnicharsetFileSuffix,        // 1
    kAmbigsFileSuffix,            // 2
    kBuiltInTemplatesFileSuffix,  // 3
    kBuiltInCutoffsFileSuffix,    // 4
    kNormProtoFileSuffix,         // 5
    kPuncDawgFileSuffix,          // 6
    kSystemDawgFileSuffix,        // 7
    kNumberDawgFileSuffix,        // 8
    kFreqDawgFileSuffix,          // 9
};

/**
 * If kTessdataFileIsText[i] is true - the tessdata component
 * of type i (from TessdataType enum) is text, and is binary otherwise.
 */
static const bool kTessdataFileIsText[] =
{
    true,                         // 0
    true,                         // 1
    true,                         // 2
    false,                        // 3
    true,                         // 4
    true,                         // 5
    false,                        // 6
    false,                        // 7
    false,                        // 8
    false,                        // 9
};

/**
 * TessdataType could be updated to contain more entries, however
 * we do not expect that number to be astronomically high.
 * In order to automatically detect endianness TessdataManager will
 * flip the bits if actual_tessdata_num_entries_ is larger than
 * kMaxNumTessdataEntries.
 */
static const int kMaxNumTessdataEntries = 1000;

class TessdataManager
{
public:
    TessdataManager()
    {
        data_file_ = NULL;
        actual_tessdata_num_entries_ = 0;
        for (int i = 0; i < TESSDATA_NUM_ENTRIES; ++i)
        {
            offset_table_[i] = -1;
        }
    }
    ~TessdataManager() {}

    /** Opens the given data file and reads the offset table. */
    void Init(const char *data_file_name);

    /** Returns data file pointer. */
    inline FILE *GetDataFilePtr() const { return data_file_; }

    /**
   * Returns false if there is no data of the given type.
   * Otherwise does a seek on the data_file_ to position the pointer
   * at the start of the data of the given type.
   */
    inline bool SeekToStart(TessdataType tessdata_type)
    {
        if (global_tessdata_manager_debug_level)
        {
            tprintf("TessdataManager: seek to offset %lld (start of tessdata" "type %d)\n", offset_table_[tessdata_type], tessdata_type);
        }
        if (offset_table_[tessdata_type] < 0)
        {
            return false;
        }
        else
        {
            ASSERT_HOST(fseek(data_file_, static_cast<size_t>(offset_table_[tessdata_type]), SEEK_SET) == 0);
            return true;
        }
    }

    /** Returns the end offset for the given tesseract data file type. */
    inline inT64 GetEndOffset(TessdataType tessdata_type) const
    {
        int index = tessdata_type + 1;
        while (index < actual_tessdata_num_entries_ && offset_table_[index] == -1)
        {
            ++index;  // skip tessdata types not present in the combined file
        }

        if (global_tessdata_manager_debug_level)
        {
            tprintf("TessdataManager: end offset for type %d is %lld\n", tessdata_type, (index == actual_tessdata_num_entries_) ? -1 : offset_table_[index]);
        }

        return (index == actual_tessdata_num_entries_) ? -1 : offset_table_[index] - 1;
    }

    /** Closes data_file_ (if it was opened by Init()). */
    inline void End()
    {
        if (data_file_ != NULL)
        {
            fclose(data_file_);
            data_file_ = NULL;
        }
    }

    /** Writes the number of entries and the given offset table to output_file. */
    static void WriteMetadata(inT64 *offset_table, FILE *output_file);

    /**
   * Reads all the standard tesseract config and data files for a language
   * at the given path and bundles them up into one binary data file.
   * Returns true if the combined traineddata file was successfully written.
   */
    static bool CombineDataFiles(const char *language_data_path_prefix, const char *output_filename);

    /**
   * Gets the individual components from the data_file_ with which the class was
   * initialized. Overwrites the components specified by component_filenames.
   * Writes the updated traineddata file to new_traineddata_filename.
   */
    bool OverwriteComponents(const char *new_traineddata_filename, char **component_filenames, int num_new_components);

    /**
   * Extracts tessdata component implied by the name of the input file from
   * the combined traineddata loaded into TessdataManager.
   * Writes the extracted component to the file indicated by the file name.
   * E.g. if the filename given is somepath/somelang.unicharset, unicharset
   * will be extracted from the data loaded into the TessdataManager and will
   * be written to somepath/somelang.unicharset.
   * @return true if the component was successfully extracted, false if the
   * component was not present in the traineddata loaded into TessdataManager.
   */
    bool ExtractToFile(const char *filename);

    /**
   * Copies data from the given input file to the output_file provided.
   * If num_bytes_to_copy is >= 0, only num_bytes_to_copy is copied from
   * the input file, otherwise all the data in the input file is copied.
   */
    static void CopyFile(FILE *input_file, FILE *output_file, bool newline_end, inT64 num_bytes_to_copy);

    /**
   * Fills type with TessdataType of the tessdata component represented by the
   * given file name. E.g. tessdata/eng.unicharset -> TESSDATA_UNICHARSET.
   * Sets *text_file to true if the component is in text format (e.g.
   * unicharset, unichar ambigs, config, etc).
   * @return true if the tessdata component type could be determined
   * from the given file name.
   */
    static bool TessdataTypeFromFileSuffix(const char *suffix, TessdataType *type, bool *text_file);

    /**
   * Tries to determine tessdata component file suffix from filename,
   * returns true on success.
   */
    static bool TessdataTypeFromFileName(const char *filename, TessdataType *type, bool *text_file);

private:
    /**
   * Each offset_table_[i] contains a file offset in the combined data file
   * where the data of TessdataFileType i is stored.
   */
    inT64 offset_table_[TESSDATA_NUM_ENTRIES];
    /**
   * Actual number of entries in the tessdata table. This value can only be
   * same or smaller than TESSDATA_NUM_ENTRIES, but can never be larger,
   * since then it would be impossible to interpret the type of tessdata at
   * indices same and higher than TESSDATA_NUM_ENTRIES.
   * This parameter is used to allow for backward compatiblity
   * when new tessdata types are introduced.
   */
    inT32 actual_tessdata_num_entries_;
    FILE *data_file_;  ///< pointer to the data file.
};

class UnicharAmbigs
{
public:
    UnicharAmbigs() {}
    ~UnicharAmbigs()
    {
        replace_ambigs_.delete_data_pointers();
        dang_ambigs_.delete_data_pointers();
        one_to_one_definite_ambigs_.delete_data_pointers();
    }

    const UnicharAmbigsVector &dang_ambigs() const { return dang_ambigs_; }
    const UnicharAmbigsVector &replace_ambigs() const { return replace_ambigs_; }

    // Fills in two ambiguity tables (replaceable and dangerous) with information
    // read from the ambigs file. An ambiguity table is an array of lists.
    // The array is indexed by a class id. Each entry in the table provides
    // a list of potential ambiguities which can start with the corresponding
    // character. For example the ambiguity "rn -> m", would be located in the
    // table at index of unicharset.unichar_to_id('r').
    // In 1-1 ambiguities (e.g. s -> S, 1 -> I) are recorded in
    // one_to_one_definite_ambigs_. This vector is also indexed by the class id
    // of the wrong part of the ambiguity and each entry contains a vector of
    // unichar ids that are ambiguous to it.
    void LoadUnicharAmbigs(FILE *ambigs_file, inT64 end_offset, UNICHARSET *unicharset);

    // Return definite 1-1 ambigs.
    const UnicharIdVector *OneToOneDefiniteAmbigs(int unichar_id) const
    {
        if (one_to_one_definite_ambigs_.empty())
        {
            return NULL;
        }

        return one_to_one_definite_ambigs_[unichar_id];
    }

private:
    bool ParseAmbiguityLine(int line_num, int version,
                            const UNICHARSET &unicharset, char *buffer,
                            int *TestAmbigPartSize, int *TestUnicharIds,
                            int *ReplacementAmbigPartSize,
                            char *ReplacementString, int *type);
    void InsertIntoTable(UnicharAmbigsVector &table,
                         int TestAmbigPartSize, int *TestUnicharIds,
                         int ReplacementAmbigPartSize,
                         const char *ReplacementString, int type,
                         AmbigSpec *ambig_spec, UNICHARSET *unicharset);

    UnicharAmbigsVector dang_ambigs_;
    UnicharAmbigsVector replace_ambigs_;
    GenericVector<UnicharIdVector *> one_to_one_definite_ambigs_;
};
/////////////////////////////////////////////////////////////////TessdataManager////////////////////////////////////////

/////////////////////////////////////////////////////////////////basedir////////////////////////////////////////
//get dir name of code
inT8 getpath(const char *code,  //executable to locate
                    STRING &path       //output path name
                    );
/////////////////////////////////////////////////////////////////basedir////////////////////////////////////////

/////////////////////////////////////////////////////////////////ccutil////////////////////////////////////////
class CCUtilMutex {
 public:
  CCUtilMutex();

  void Lock();

  void Unlock();
 private:
#ifdef WIN32
  HANDLE mutex_;
#else
  pthread_mutex_t mutex_;
#endif
};


class CCUtil {
 public:
  CCUtil();
  ~CCUtil();

 public:
  void main_setup(
                  const char *argv0,        // program name
                  const char *basename      // name of image
                 );
 public:
  STRING datadir;        // dir for data files
  STRING imagebasename;  // name of image

  BOOL_VAR_H (m_print_variables, FALSE,
                   "Print initial values of all variables");
  STRING_VAR_H (m_data_sub_dir, "tessdata/", "Directory for data files");
  STRING lang;
  STRING language_data_path_prefix;
  TessdataManager tessdata_manager;
  UNICHARSET unicharset;
  UnicharAmbigs unichar_ambigs;
  STRING imagefile;  // image file name
  STRING directory;  // main directory
};

extern CCUtilMutex tprintfMutex;
/////////////////////////////////////////////////////////////////ccutil////////////////////////////////////////

//////////////////////////////////////////////////////////////Image////////////////////////////
class Image {
 public:
  Image(CCUtil* ccutil_ptr);
  CCUtil* getCCUtil() {
    return ccutil_ptr_;
  }

 private:
  CCUtil* ccutil_ptr_;
};
//////////////////////////////////////////////////////////////Image////////////////////////////

/////////////////////////////////////////////////////////////////cutil_class////////////////////////////////////////
class CUtil : public CCUtil {
 public:
  CUtil();
  ~CUtil();
  void read_variables(const char *filename, bool global_only);
 public:
  TBLOB *pageblobs;                /*first blob on page */
  TEXTBLOCK *pageblocks;           /*first block on page */

  int resolution;                  /*scanner res in dpi */
  int acts[MAXPROC];               /*action flags */
  int debugs[MAXPROC];             /*debug flags */
  int plots[MAXPROC];              /*plot flags */

  int corners[4];                  /*corners of scan window */

  char *debugfile;                 /* debug file name */

  int plots_fx;
  int plots_ocr;

  int debugs_fx;
  int debugs_ocr;

  int acts_fx;
  int acts_ocr;

  char *demodir;                   /*demo home directory */
};
/////////////////////////////////////////////////////////////////cutil_class////////////////////////////////////////

/////////////////////////////////////////////////////////////////ccstruct////////////////////////////////////////
class PBLOB;
class BLOB_CHOICE_LIST;

class CCStruct : public CUtil {
 public:
  CCStruct();
  ~CCStruct();

 protected:
  Image image_;
};

class Tesseract;

typedef void (Tesseract::*POLY_MATCHER)(PBLOB *, PBLOB *, PBLOB *, WERD *, DENORM *, BLOB_CHOICE_LIST *, const char*);//cwj
/*
  typedef void (tesseract::Tesseract::*POLY_TESTER)
  (const STRING&, PBLOB *, DENORM *, BOOL8, char *,
  inT32, BLOB_CHOICE_LIST *);
*/
/////////////////////////////////////////////////////////////////ccstruct////////////////////////////////////////

/////////////////////////////////////////////////////////////////dawg////////////////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/

extern INT_VAR_H(dawg_debug_level, 0, "Set to 1 for general debug info, to"
                 " 2 for more details, to 3 to see all the debug messages");

#ifdef __MSW32__
#define NO_EDGE                (inT64) 0xffffffffffffffffi64
#else
#define NO_EDGE                (inT64) 0xffffffffffffffffll
#endif

/*----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------*/
struct NodeChild {
  UNICHAR_ID unichar_id;
  EDGE_REF edge_ref;
  NodeChild(UNICHAR_ID id, EDGE_REF ref): unichar_id(id), edge_ref(ref) {}
  NodeChild(): unichar_id(INVALID_UNICHAR_ID), edge_ref(NO_EDGE) {}
};

typedef GenericVector<NodeChild> NodeChildVector;
typedef GenericVector<int> SuccessorList;
typedef GenericVector<SuccessorList *> SuccessorListsVector;

enum DawgType {
  DAWG_TYPE_PUNCTUATION,
  DAWG_TYPE_PREFIX,
  DAWG_TYPE_ROOT,
  DAWG_TYPE_WORD,
  DAWG_TYPE_SUFFIX,
  DAWG_TYPE_NUMBER,

  DAWG_TYPE_COUNT  // number of enum entries
};

/*----------------------------------------------------------------------
              C o n s t a n t s
----------------------------------------------------------------------*/
#define FORWARD_EDGE           (inT32) 0
#define BACKWARD_EDGE          (inT32) 1
#define MAX_NODE_EDGES_DISPLAY (inT64) 100
#define LAST_FLAG              (inT64) 1
#define DIRECTION_FLAG         (inT64) 2
#define WERD_END_FLAG          (inT64) 4
#define LETTER_START_BIT       0
#define NUM_FLAG_BITS          3
#define REFFORMAT "%lld"

// Set kBeginningDawgsType[i] to true if a Dawg of
// DawgType i can contain the beginning of a word.
static const bool kBeginningDawgsType[] = {1, 1, 0, 1, 0, 1 };

static const bool kDawgSuccessors[DAWG_TYPE_COUNT][DAWG_TYPE_COUNT] = {
  { 0, 1, 0, 1, 0, 0 },  // for DAWG_TYPE_PUNCTUATION
  { 0, 0, 1, 1, 0, 0 },  // for DAWG_TYPE_PREFIX
  { 0, 0, 0, 0, 1, 0 },  // for DAWG_TYPE_ROOT
  { 1, 0, 0, 0, 0, 0 },  // for DAWG_TYPE_WORD
  { 1, 0, 0, 0, 0, 0 },  // for DAWG_TYPE_SUFFIX
  { 0, 0, 0, 0, 0, 0 }   // for DAWG_TYPE_NUMBER
};

static const char kWildcard[] = "*";


/*----------------------------------------------------------------------
              C l a s s e s   a n d   S t r u c t s
----------------------------------------------------------------------*/
//
/// Abstract class (an interface) that declares methods needed by the
/// various tesseract classes to operate on SquishedDawg and Trie objects.
///
/// This class initializes all the edge masks (since their usage by
/// SquishedDawg and Trie is identical) and implements simple accessors
/// for each of the fields encoded in an EDGE_RECORD.
/// This class also implements word_in_dawg() and check_for_words()
/// (since they use only the public methods of SquishedDawg and Trie
/// classes that are inherited from the Dawg base class).
//
class Dawg {
 public:
  /// Magic number to determine endianness when reading the Dawg from file.
  static const inT16 kDawgMagicNumber = 42;
  /// A special unichar id that indicates that any appropriate pattern
  /// (e.g.dicitonary word, 0-9 digit, etc) can be inserted instead
  /// Used for expressing patterns in punctuation and number Dawgs.
  static const UNICHAR_ID kPatternUnicharID = 0;

  inline DawgType type() const { return type_; }
  inline const STRING &lang() const { return lang_; }
  inline PermuterType permuter() const { return perm_; }

  virtual ~Dawg() {}

  /// Returns true if the given word is in the Dawg.
  bool word_in_dawg(const WERD_CHOICE &word) const;

  /// Checks the Dawg for the words that are listed in the requested file.
  /// Returns the number of words in the given file missing from the Dawg.
  int check_for_words(const char *filename,
                      const UNICHARSET &unicharset,
                      bool enable_wildcard) const;

  // Pure virtual function that should be implemented by the derived classes.

  /// Returns the edge that corresponds to the letter out of this node.
  virtual EDGE_REF edge_char_of(NODE_REF node, UNICHAR_ID unichar_id,
                                bool word_end) const = 0;

  /// Fills the given NodeChildVector with all the unichar ids (and the
  /// corresponding EDGE_REFs) for which there is an edge out of this node.
  virtual void unichar_ids_of(NODE_REF node, NodeChildVector *vec) const = 0;

  /// Returns the next node visited by following the edge
  /// indicated by the given EDGE_REF.
  virtual NODE_REF next_node(EDGE_REF edge_ref) const = 0;

  /// Returns true if the edge indicated by the given EDGE_REF
  /// marks the end of a word.
  virtual bool end_of_word(EDGE_REF edge_ref) const = 0;

  /// Returns UNICHAR_ID stored in the edge indicated by the given EDGE_REF.
  virtual UNICHAR_ID edge_letter(EDGE_REF edge_ref) const = 0;

  /// Prints the contents of the node indicated by the given NODE_REF.
  /// At most max_num_edges will be printed.
  virtual void print_node(NODE_REF node, int max_num_edges) const = 0;

 protected:
  Dawg() {}

  /// Returns the next node visited by following this edge.
  inline NODE_REF next_node_from_edge_rec(const EDGE_RECORD &edge_rec) const {
    return ((edge_rec & next_node_mask_) >> next_node_start_bit_);
  }
  /// Returns the direction flag of this edge.
  inline int direction_from_edge_rec(const EDGE_RECORD &edge_rec) const {
    return ((edge_rec & (DIRECTION_FLAG << flag_start_bit_))) ?
      BACKWARD_EDGE : FORWARD_EDGE;
  }
  /// Returns true if this edge marks the end of a word.
  inline bool end_of_word_from_edge_rec(const EDGE_RECORD &edge_rec) const {
    return (edge_rec & (WERD_END_FLAG << flag_start_bit_)) != 0;
  }
  /// Returns UNICHAR_ID recorded in this edge.
  inline UNICHAR_ID unichar_id_from_edge_rec(
      const EDGE_RECORD &edge_rec) const {
    return ((edge_rec & letter_mask_) >> LETTER_START_BIT);
  }
  /// Sets the next node link for this edge in the Dawg.
  inline void set_next_node_in_edge_rec(
      EDGE_RECORD *edge_rec, EDGE_REF value) {
    *edge_rec &= (~next_node_mask_);
    *edge_rec |= ((value << next_node_start_bit_) & next_node_mask_);
  }
  /// Sets this edge record to be the last one in a sequence of edges.
  inline void set_last_flag_in_edge_rec(EDGE_RECORD *edge_rec) {
    *edge_rec |= (LAST_FLAG << flag_start_bit_);
  }
  /// Sequentially compares the given values of unichar ID, next node
  /// and word end marker with the values in the given EDGE_RECORD.
  /// Returns: 1 if at any step the given input value exceeds
  ///            that of edge_rec (and all the values already
  ///            checked are the same)
  ///          0 if edge_rec_match() returns true
  ///         -1 otherwise
  inline int given_greater_than_edge_rec(NODE_REF next_node,
                                         bool word_end,
                                         UNICHAR_ID unichar_id,
                                         const EDGE_RECORD &edge_rec) const {
    UNICHAR_ID curr_unichar_id = unichar_id_from_edge_rec(edge_rec);
    NODE_REF curr_next_node = next_node_from_edge_rec(edge_rec);
    bool curr_word_end = end_of_word_from_edge_rec(edge_rec);
    if (edge_rec_match(next_node, word_end, unichar_id, curr_next_node,
                       curr_word_end, curr_unichar_id)) return 0;
    if (unichar_id > curr_unichar_id) return 1;
    if (unichar_id == curr_unichar_id) {
      if (next_node > curr_next_node) return 1;
      if (next_node == curr_next_node) {
        if (word_end > curr_word_end) return 1;
      }
    }
    return -1;
  }
  /// Returns true if all the values are equal (any value matches
  /// next_node if next_node == NO_EDGE, any value matches word_end
  /// if word_end is false).
  inline bool edge_rec_match(NODE_REF next_node,
                             bool word_end,
                             UNICHAR_ID unichar_id,
                             NODE_REF other_next_node,
                             bool other_word_end,
                             UNICHAR_ID other_unichar_id) const {
    return ((unichar_id == other_unichar_id) &&
            (next_node == NO_EDGE || next_node == other_next_node) &&
            (!word_end || (word_end == other_word_end)));
  }

  /// Sets type_, lang_, perm_, unicharset_size_.
  /// Initializes the values of various masks from unicharset_size_.
  void init(DawgType type, const STRING &lang,
            PermuterType perm, int unicharset_size);

  /// Matches all of the words that are represented by this string.
  /// If wilcard is set to something other than INVALID_UNICHAR_ID,
  /// the *'s in this string are interpreted as wildcards.
  /// WERD_CHOICE param is not passed by const so that wildcard searches
  /// can modify it and work without having to copy WERD_CHOICEs.
  bool match_words(WERD_CHOICE *word, inT32 index,
                   NODE_REF node, UNICHAR_ID wildcard) const;

  // Member Variables.
  DawgType type_;
  STRING lang_;
  /// Permuter code that should be used if the word is found in this Dawg.
  PermuterType perm_;
  // Variables to construct various edge masks. Formerly:
  // #define NEXT_EDGE_MASK (inT64) 0xfffffff800000000i64
  // #define FLAGS_MASK     (inT64) 0x0000000700000000i64
  // #define LETTER_MASK    (inT64) 0x00000000ffffffffi64
  int unicharset_size_;
  int flag_start_bit_;
  int next_node_start_bit_;
  uinT64 next_node_mask_;
  uinT64 flags_mask_;
  uinT64 letter_mask_;
};

//
/// DawgInfo struct and DawgInfoVector class are used for
/// storing information about the current Dawg search state.
//
struct DawgInfo {
  DawgInfo() : dawg_index(-1), ref(NO_EDGE) {}
  DawgInfo(int i, EDGE_REF r) : dawg_index(i), ref(r) {}
  bool operator==(const DawgInfo &other) {
    return (this->dawg_index == other.dawg_index &&
            this->ref == other.ref);
  }
  int dawg_index;
  EDGE_REF ref;
};
class DawgInfoVector : public GenericVector<DawgInfo> {
 public:
  /// Overload destructor, since clear() does not delete data_[] any more.
  ~DawgInfoVector() {
    if (size_reserved_ > 0) {
      delete[] data_;
      size_used_ = 0;
      size_reserved_ = 0;
    }
  }
  /// Overload clear() in order to avoid allocating/deallocating memory
  /// when clearing the vector and re-inserting entries into it later.
  void clear() { size_used_ = 0; }
  /// Adds an entry for the given dawg_index with the given node to the vec.
  /// Returns false if the same entry already exists in the vector,
  /// true otherwise.
  inline bool add_unique(const DawgInfo &new_info, const char *debug_msg) {
    for (int i = 0; i < size_used_; ++i) {
      if (data_[i] == new_info) return false;
    }
    push_back(new_info);
    if (dawg_debug_level) {
      tprintf("%s[%d, " REFFORMAT "]\n", debug_msg,
              new_info.dawg_index, new_info.ref);
    }
    return true;
  }
  /// Removes an entry that equals to the given DawgInfo.
  /// This function assumes that the entries in the vector are unique.
  /// Returns true if an entry was found and removed.
  inline bool remove(const DawgInfo &info) {
    for (int i = 0; i < size_used_; ++i) {
      if (data_[i] == info) {
        for (int j = i + 1; j < size_used_; ++j) {
          data_[j-1] = data_[j];
        }
        size_used_--;
        return true;
      }
    }
    return false;
  }
};

//
/// Concrete class that can operate on a compacted (squished) Dawg (read,
/// search and write to file). This class is read-only in the sense that
/// new words can not be added to an instance of SquishedDawg.
/// The underlying representation of the nodes and edges in SquishedDawg
/// is stored as a contiguous EDGE_ARRAY (read from file or given as an
/// argument to the constructor).
//
class SquishedDawg : public Dawg {
 public:
  SquishedDawg(FILE *file, DawgType type,
               const STRING &lang, PermuterType perm) {
    read_squished_dawg(file, type, lang, perm);
    num_forward_edges_in_node0 = num_forward_edges(0);
  }
  SquishedDawg(const char* filename, DawgType type,
               const STRING &lang, PermuterType perm) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
      tprintf("Failed to open dawg file %s\n", filename);
      exit(1);
    }
    read_squished_dawg(file, type, lang, perm);
    num_forward_edges_in_node0 = num_forward_edges(0);
    fclose(file);
  }
  SquishedDawg(EDGE_ARRAY edges, int num_edges, DawgType type,
               const STRING &lang, PermuterType perm, int unicharset_size) :
    edges_(edges), num_edges_(num_edges) {
    init(type, lang, perm, unicharset_size);
    num_forward_edges_in_node0 = num_forward_edges(0);
    if (dawg_debug_level > 3) print_all("SquishedDawg:");
  }
  ~SquishedDawg();

  /// Returns the edge that corresponds to the letter out of this node.
  EDGE_REF edge_char_of(NODE_REF node, UNICHAR_ID unichar_id,
                        bool word_end) const;

  /// Fills the given NodeChildVector with all the unichar ids (and the
  /// corresponding EDGE_REFs) for which there is an edge out of this node.
  void unichar_ids_of(NODE_REF node, NodeChildVector *vec) const {
    EDGE_REF edge = node;
    if (!edge_occupied(edge) || edge == NO_EDGE) return;
    assert(forward_edge(edge));  // we don't expect any backward edges to
    do {                         // be present when this funciton is called
      vec->push_back(NodeChild(unichar_id_from_edge_rec(edges_[edge]), edge));
    } while (!last_edge(edge++));
  }

  /// Returns the next node visited by following the edge
  /// indicated by the given EDGE_REF.
  NODE_REF next_node(EDGE_REF edge) const {
    return next_node_from_edge_rec((edges_[edge]));
  }

  /// Returns true if the edge indicated by the given EDGE_REF
  /// marks the end of a word.
  bool end_of_word(EDGE_REF edge_ref) const {
    return end_of_word_from_edge_rec((edges_[edge_ref]));
  }

  /// Returns UNICHAR_ID stored in the edge indicated by the given EDGE_REF.
  UNICHAR_ID edge_letter(EDGE_REF edge_ref) const {
    return unichar_id_from_edge_rec((edges_[edge_ref]));
  }

  /// Prints the contents of the node indicated by the given NODE_REF.
  /// At most max_num_edges will be printed.
  void print_node(NODE_REF node, int max_num_edges) const;

  /// Writes the squished/reduced Dawg to a file.
  void write_squished_dawg(const char *filename);

 private:
  /// Sets the next node link for this edge.
  inline void set_next_node(EDGE_REF edge_ref, EDGE_REF value) {
    set_next_node_in_edge_rec(&(edges_[edge_ref]), value);
  }
  /// Sets the edge to be empty.
  inline void set_empty_edge(EDGE_REF edge_ref) {
    (edges_[edge_ref] = next_node_mask_);
  }
  /// Goes through all the edges and clears each one out.
  inline void clear_all_edges() {
    for (int edge = 0; edge < num_edges_; edge++) set_empty_edge(edge);
  }
  /// Clears the last flag of this edge.
  inline void clear_last_flag(EDGE_REF edge_ref) {
     (edges_[edge_ref] &= ~(LAST_FLAG << flag_start_bit_));
  }
  /// Returns true if this edge is in the forward direction.
  inline bool forward_edge(EDGE_REF edge_ref) const {
    return (edge_occupied(edge_ref) &&
            (FORWARD_EDGE == direction_from_edge_rec(edges_[edge_ref])));
  }
  /// Returns true if this edge is in the backward direction.
  inline bool backward_edge(EDGE_REF edge_ref) const {
    return (edge_occupied(edge_ref) &&
            (BACKWARD_EDGE == direction_from_edge_rec(edges_[edge_ref])));
  }
  /// Returns true if the edge spot in this location is occupied.
  inline bool edge_occupied(EDGE_REF edge_ref) const {
    return (edges_[edge_ref] != next_node_mask_);
  }
  /// Returns true if this edge is the last edge in a sequence.
  inline bool last_edge(EDGE_REF edge_ref) const {
    return (edges_[edge_ref] & (LAST_FLAG << flag_start_bit_)) != 0;
  }

  /// Counts and returns the number of forward edges in this node.
  inT32 num_forward_edges(NODE_REF node) const;

  /// Reads SquishedDawg from a file.
  void read_squished_dawg(FILE *file, DawgType type,
                          const STRING &lang, PermuterType perm);

  /// Prints the contents of an edge indicated by the given EDGE_REF.
  void print_edge(EDGE_REF edge) const;

  /// Prints the contents of the SquishedDawg.
  void print_all(const char* msg) {
    tprintf("\n__________________________\n%s\n", msg);
    for (int i = 0; i < num_edges_; ++i) print_edge(i);
    tprintf("__________________________\n");
  }
  /// Constructs a mapping from the memory node indices to disk node indices.
  NODE_MAP build_node_map(inT32 *num_nodes) const;


  // Member variables.
  EDGE_ARRAY edges_;
  int num_edges_;
  int num_forward_edges_in_node0;
};
/////////////////////////////////////////////////////////////////dawg////////////////////////////////////////

/////////////////////////////////////////////////////////////////trie////////////////////////////////////////
// Note: if we consider either NODE_REF or EDGE_INDEX to ever exceed
// max int32, we will need to change GenericVector to use int64 for size
// and address indices. This does not seem to be needed immediately,
// since currently the largest number of edges limit used by tesseract
// (kMaxNumEdges in wordlist2dawg.cpp) is far less than max int32.
typedef inT64 EDGE_INDEX;  // index of an edge in a given node
typedef bool *NODE_MARKER;
typedef GenericVector<EDGE_RECORD> EDGE_VECTOR;

struct TRIE_NODE_RECORD {
  EDGE_VECTOR forward_edges;
  EDGE_VECTOR backward_edges;
};
typedef GenericVector<TRIE_NODE_RECORD *> TRIE_NODES;

/**
 * Concrete class for Trie data structure that allows to store a list of
 * words (extends Dawg base class) as well as dynamically add new words.
 * This class stores a vector of pointers to TRIE_NODE_RECORDs, each of
 * which has a vector of forward and backward edges.
 */
class Trie : public Dawg {
 public:
  // max_num_edges argument allows limiting the amount of memory this
  // Trie can consume (if a new word insert would cause the Trie to
  // contain more edges than max_num_edges, all the edges are cleared
  // so that new inserts can proceed).
  Trie(DawgType type, const STRING &lang, PermuterType perm,
       uinT64 max_num_edges, int unicharset_size) {
    init(type, lang, perm, unicharset_size);
    num_edges_ = 0;
    max_num_edges_ = max_num_edges;
    deref_node_index_mask_ = ~letter_mask_;
    new_dawg_node();  // need to allocate node 0
  }
  ~Trie() { nodes_.delete_data_pointers(); }

  /** Returns the edge that corresponds to the letter out of this node. */
  EDGE_REF edge_char_of(NODE_REF node_ref, UNICHAR_ID unichar_id,
                        bool word_end) const {
    EDGE_RECORD *edge_ptr;
    EDGE_INDEX edge_index;
    if (!edge_char_of(node_ref, NO_EDGE, FORWARD_EDGE, word_end, unichar_id,
                      &edge_ptr, &edge_index)) return NO_EDGE;
    return make_edge_ref(node_ref, edge_index);
  }

  /**
   * Fills the given NodeChildVector with all the unichar ids (and the
   * corresponding EDGE_REFs) for which there is an edge out of this node.
   */
  void unichar_ids_of(NODE_REF node, NodeChildVector *vec) const {
    const EDGE_VECTOR &forward_edges = nodes_[(int)node]->forward_edges;
    for (int i = 0; i < forward_edges.size(); ++i) {
      vec->push_back(NodeChild(unichar_id_from_edge_rec(forward_edges[i]),
                               make_edge_ref(node, i)));
    }
  }

  /**
   * Returns the next node visited by following the edge
   * indicated by the given EDGE_REF.
   */
  NODE_REF next_node(EDGE_REF edge_ref) const {
    if (edge_ref == NO_EDGE || num_edges_ == 0) return NO_EDGE;
    return next_node_from_edge_rec(*deref_edge_ref(edge_ref));
  }

  /**
   * Returns true if the edge indicated by the given EDGE_REF
   * marks the end of a word.
   */
  bool end_of_word(EDGE_REF edge_ref) const {
    if (edge_ref == NO_EDGE || num_edges_ == 0) return false;
    return end_of_word_from_edge_rec(*deref_edge_ref(edge_ref));
  }

  /** Returns UNICHAR_ID stored in the edge indicated by the given EDGE_REF. */
  UNICHAR_ID edge_letter(EDGE_REF edge_ref) const {
    if (edge_ref == NO_EDGE || num_edges_ == 0) return INVALID_UNICHAR_ID;
    return unichar_id_from_edge_rec(*deref_edge_ref(edge_ref));
  }

  // Prints the contents of the node indicated by the given NODE_REF.
  // At most max_num_edges will be printed.
  void print_node(NODE_REF node, int max_num_edges) const;

  // Writes edges from nodes_ to an EDGE_ARRAY and creates a SquishedDawg.
  // Eliminates redundant edges and returns the pointer to the SquishedDawg.
  // Note: the caller is responsible for deallocating memory associated
  // with the returned SquishedDawg pointer.
  SquishedDawg *trie_to_dawg();

  // Inserts the list of words from the given file into the Trie.
  bool read_word_list(const char *filename,
                      const UNICHARSET &unicharset);

  // Adds a word to the Trie (creates the necessary nodes and edges).
  void add_word_to_dawg(const WERD_CHOICE &word);

 protected:
  // The structure of an EDGE_REF for Trie edges is as follows:
  // [LETTER_START_BIT, flag_start_bit_):
  //                             edge index in *_edges in a TRIE_NODE_RECORD
  // [flag_start_bit, 30th bit]: node index in nodes (TRIE_NODES vector)
  //
  // With this arrangement there are enough bits to represent edge indices
  // (each node can have at most unicharset_size_ forward edges and
  // the position of flag_start_bit is set to be log2(unicharset_size_)).
  // It is also possible to accomodate a maximum number of nodes that is at
  // least as large as that of the SquishedDawg representation (in SquishedDawg
  // each EDGE_RECORD has 32-(flag_start_bit+NUM_FLAG_BITS) bits to represent
  // the next node index).
  //

  // Returns the pointer to EDGE_RECORD after decoding the location
  // of the edge from the information in the given EDGE_REF.
  // This function assumes that EDGE_REF holds valid node/edge indices.
  inline EDGE_RECORD *deref_edge_ref(EDGE_REF edge_ref) const {
    uinT64 edge_index = (edge_ref & letter_mask_) >> LETTER_START_BIT;
    uinT64 node_index =
      (edge_ref & deref_node_index_mask_) >> flag_start_bit_;
    TRIE_NODE_RECORD *node_rec = nodes_[(int)node_index];
    return &(node_rec->forward_edges[(int)edge_index]);
  }
  /** Constructs EDGE_REF from the given node_index and edge_index. */
  inline EDGE_REF make_edge_ref(NODE_REF node_index,
                                EDGE_INDEX edge_index) const {
    return ((node_index << flag_start_bit_) |
            (edge_index << LETTER_START_BIT));
  }
  /** Sets up this edge record to the requested values. */
  inline void link_edge(EDGE_RECORD *edge, NODE_REF nxt, int direction,
                        bool word_end, UNICHAR_ID unichar_id) {
    EDGE_RECORD flags = 0;
    if (word_end) flags |= WERD_END_FLAG;
    if (direction == BACKWARD_EDGE) flags |= DIRECTION_FLAG;
    *edge = ((nxt << next_node_start_bit_) |
             (static_cast<EDGE_RECORD>(flags) << flag_start_bit_) |
             (static_cast<EDGE_RECORD>(unichar_id) << LETTER_START_BIT));
  }
  /** Prints the given EDGE_RECORD. */
  inline void print_edge_rec(const EDGE_RECORD &edge_rec) const {
    tprintf("|" REFFORMAT "|%s%s|%d|", next_node_from_edge_rec(edge_rec),
            (direction_from_edge_rec(edge_rec) == FORWARD_EDGE) ? "F" : "B",
            end_of_word_from_edge_rec(edge_rec) ? ",E" : "",
            unichar_id_from_edge_rec(edge_rec));
  }
  // Returns true if the next node in recorded the given EDGE_RECORD
  // has exactly one forward edge.
  inline bool can_be_eliminated(const EDGE_RECORD &edge_rec) {
    NODE_REF node_ref = next_node_from_edge_rec(edge_rec);
    return (node_ref != NO_EDGE &&
            nodes_[(int)node_ref]->forward_edges.size() == 1);
  }

  // Prints the contents of the Trie.
  // At most max_num_edges will be printed for each node.
  void print_all(const char* msg, int max_num_edges) {
    tprintf("\n__________________________\n%s\n", msg);
    for (int i = 0; i < nodes_.size(); ++i) print_node(i, max_num_edges);
    tprintf("__________________________\n");
  }

  // Finds the edge with the given direction, word_end and unichar_id
  // in the node indicated by node_ref. Fills in the pointer to the
  // EDGE_RECORD and the index of the edge with the the values
  // corresponding to the edge found. Returns true if an edge was found.
  bool edge_char_of(NODE_REF node_ref, NODE_REF next_node,
                    int direction, bool word_end, UNICHAR_ID unichar_id,
                    EDGE_RECORD **edge_ptr, EDGE_INDEX *edge_index) const;

  // Adds an single edge linkage between node1 and node2 in the direction
  // indicated by direction argument.
  bool add_edge_linkage(NODE_REF node1, NODE_REF node2, int direction,
                        bool word_end, UNICHAR_ID unichar_id);

  // Adds forward edge linkage from node1 to node2 and the corresponding
  // backward edge linkage in the other direction.
  bool add_new_edge(NODE_REF node1, NODE_REF node2,
                    bool word_end, UNICHAR_ID unichar_id) {
    return (add_edge_linkage(node1, node2, FORWARD_EDGE,
                             word_end, unichar_id) &&
            add_edge_linkage(node2, node1, BACKWARD_EDGE,
                             word_end, unichar_id));
  }

  // Sets the word ending flags in an already existing edge pair.
  // Returns true on success.
  void add_word_ending(EDGE_RECORD *edge,
                       NODE_REF the_next_node,
                       UNICHAR_ID unichar_id);

  // Allocates space for a new node in the Trie.
  NODE_REF new_dawg_node();

  // Removes a single edge linkage to between node1 and node2 in the
  // direction indicated by direction argument.
  void remove_edge_linkage(NODE_REF node1, NODE_REF node2, int direction,
                           bool word_end, UNICHAR_ID unichar_id);

  // Removes forward edge linkage from node1 to node2 and the corresponding
  // backward edge linkage in the other direction.
  void remove_edge(NODE_REF node1, NODE_REF node2,
                   bool word_end, UNICHAR_ID unichar_id) {
    remove_edge_linkage(node1, node2, FORWARD_EDGE, word_end, unichar_id);
    remove_edge_linkage(node2, node1, BACKWARD_EDGE, word_end, unichar_id);
  }

  // Compares edge1 and edge2 in the given node to see if they point to two
  // next nodes that could be collapsed. If they do, performs the reduction
  // and returns true.
  bool eliminate_redundant_edges(NODE_REF node, const EDGE_RECORD &edge1,
                                 const EDGE_RECORD &edge2);

  // Assuming that edge_index indicates the first edge in a group of edges
  // in this node with a particular letter value, looks through these edges
  // to see if any of them can be collapsed. If so does it. Returns to the
  // caller when all edges with this letter have been reduced.
  // Returns true if further reduction is possible with this same letter.
  bool reduce_lettered_edges(EDGE_INDEX edge_index,
                             UNICHAR_ID unichar_id,
                             NODE_REF node,
                             const EDGE_VECTOR &backward_edges,
                             NODE_MARKER reduced_nodes);

  /**
   * Order num_edges of consequtive EDGE_RECORDS in the given EDGE_VECTOR in
   * increasing order of unichar ids. This function is normally called
   * for all edges in a single node, and since number of edges in each node
   * is usually quite small, selection sort is used.
   */
  void sort_edges(EDGE_VECTOR *edges);

  /** Eliminates any redundant edges from this node in the Trie. */
  void reduce_node_input(NODE_REF node, NODE_MARKER reduced_nodes);


  // Member variables
  TRIE_NODES nodes_;              ///< vector of nodes in the Trie
  uinT64 num_edges_;              ///< sum of all edges (forward and backward)
  uinT64 max_num_edges_;          ///< maximum number of edges allowed
  uinT64 deref_direction_mask_;   ///< mask for EDGE_REF to extract direction
  uinT64 deref_node_index_mask_;  ///< mask for EDGE_REF to extract node index
};
/////////////////////////////////////////////////////////////////trie////////////////////////////////////////

/////////////////////////////////////////////////////////////////choices////////////////////////////////////////
/*----------------------------------------------------------------------
                T y p e s
----------------------------------------------------------------------*/
typedef LIST CHOICES;            /* CHOICES */
//typedef float PROBABILITY;       /* PROBABILITY */
//typedef char PERM_TYPE;          /* PERMUTER CODE */

typedef struct choicestruct
{                                /* A_CHOICE */
  float rating;
  float certainty;
  char permuter;
  inT8 config;
  char *string;
  char *lengths;           //<  length of each unichar in the string
  int script_id;
  char *fragment_lengths;  //<  length of fragments for each unichar in string
  /**
   * if true, indicates that this choice
   * was chosen over a better one that
   * contained a fragment
   */
  bool fragment_mark;

} A_CHOICE;

/*----------------------------------------------------------------------
                M a c r o s
----------------------------------------------------------------------*/
/**
 * best_string
 *
 * Return the string corresponding to the best choice.
 */
#define best_string(choices)  \
(first_node (choices) ? ((A_CHOICE*) (first_node (choices)))->string : NULL)

/**
 * best_lengths
 *
 * Return the lengths corresponding to the best choice.
 */
#define best_lengths(choices)  \
(first_node (choices) ? ((A_CHOICE*) (first_node (choices)))->lengths : NULL)

/**
 * best_rating
 *
 * Return the rating of the best choice.
 */
#define best_rating(choices)  \
(((A_CHOICE*) (first_node (choices)))->rating)

/**
 * best_certainty
 *
 * Return the certainty of the best choice.
 */
#define best_certainty(choices)  \
(((A_CHOICE*) (first_node (choices)))->certainty)

/**
 * class_rating
 *
 * Return the rating of a given character class.
 */
#define class_rating(choice)  \
(((A_CHOICE*) (choice))->rating)

/**
 * class_certainty
 *
 * Return the certainty of a given character class.
 */
#define class_certainty(choice)  \
(((A_CHOICE*) (choice))->certainty)

/**
 * class_string
 *
 * Return the string of a given character class.
 */
#define class_string(choice)  \
(((A_CHOICE*) (choice))->string)

/**
 * class_lengths
 *
 * Return the lengths of a given character class.
 */
#define class_lengths(choice)  \
(((A_CHOICE*) (choice))->lengths)

/**
 * class_permuter
 *
 * Return the permuter of a given character class.
 */
#define class_permuter(choice)  \
(((A_CHOICE*) (choice))->permuter)

/**
 * class_config
 *
 * Return the config of a given character class.
 */
#define class_config(choice)  \
(((A_CHOICE*) (choice))->config)

/**
 * class_script
 *
 * Return the script of a given character class.
 */
#define class_script_id(choice)  \
(((A_CHOICE*) (choice))->script_id)

/**
 * free_choices
 *
 * Free a list of choices.
 */
#define free_choices(c)  \
destroy_nodes ((c), free_choice)

/**
 * print_bold
 *
 * Print a string in bold type by using escape sequences.  This only
 * works for certain output devices.
 */
#define print_bold(string)               \
cprintf ("\033&dB%s\033&d@", string)


/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/

/// Returns true if fragment_mark is set for the given choice.
inline bool class_fragment_mark(A_CHOICE *choice) {
  return choice->fragment_mark;
}

/// Sets fragment_mark of choice to the given value.
inline void set_class_fragment_mark(A_CHOICE *choice, bool mark) {
  choice->fragment_mark = mark;
}

/// Returns fragment_lengths of the given class.
inline const char *class_fragment_lengths(A_CHOICE *choice) {
  return choice->fragment_lengths;
}

CHOICES append_char_choice(CHOICES ratings,
                           const char *string,
                           const char *lengths,
                           float rating,
                           float certainty,
                           inT8 config,
                           int script_id);

CHOICES copy_choices(CHOICES choices);

/// Copy the given values into corresponding fields of choice.
void clone_choice(A_CHOICE *choice, const char *string,
                  const char *lengths, float rating, float certainty,
                  inT8 permuter, bool fragment_mark,
                  const char *fragment_lengths);

/// Copy the contents of choice_1 into choice_2.
inline void clone_choice(A_CHOICE *choice_2, A_CHOICE *choice_1) {
  clone_choice(choice_2, class_string(choice_1), class_lengths(choice_1),
               class_rating(choice_1), class_certainty(choice_1),
               class_permuter(choice_1), class_fragment_mark(choice_1),
               class_fragment_lengths(choice_1));
}

void clear_choice(A_CHOICE *choice);

void free_choice(void *arg);

A_CHOICE *get_best_free_other(A_CHOICE *choice_1, A_CHOICE *choice_2);

A_CHOICE *new_choice(const char *string,
                     const char *lengths,
                     float rating,
                     float certainty,
                     inT8 config,
                     int script_id,
                     char permuter,
                     bool fragment_mark,
                     const char *fragment_lengths);

A_CHOICE *new_choice(const char *string,
                     const char *lengths,
                     float rating,
                     float certainty,
                     inT8 config,
                     char permuter);
/////////////////////////////////////////////////////////////////choices////////////////////////////////////////

/////////////////////////////////////////////////////////////////DictT////////////////////////////////////////
extern STRING_VAR_H(global_user_words_suffix, "user-words", "A list of user-provided words.");
extern INT_VAR_H(hyphen_debug_level, 0, "Debug level for hyphenated words.");

#define MAX_WERD_LENGTH        (inT64) 40
#define NO_RATING               -1
#define FREQ_WERD               1.0
#define GOOD_WERD               1.1
#define OK_WERD                 1.3125

/** Struct used to hold temporary information about fragments. */
struct CHAR_FRAGMENT_INFO
{
  UNICHAR_ID unichar_id;
  const CHAR_FRAGMENT *fragment;
  int num_fragments;
  float rating;
  float certainty;
};

typedef GenericVector<Dawg *> DawgVector;

struct DawgArgs
{
  DawgArgs(DawgInfoVector *d, DawgInfoVector *c, DawgInfoVector *ud, DawgInfoVector *uc, float r) :
    active_dawgs(d), constraints(c), updated_active_dawgs(ud), updated_constraints(uc), rating_margin(r)
  {
    for (int i = 0; i < MAX_WERD_LENGTH; ++i)
    {
      rating_array[i] = NO_RATING;
    }

    permuter = NO_PERM;
  }

  DawgInfoVector *active_dawgs;
  DawgInfoVector *constraints;
  DawgInfoVector *updated_active_dawgs;
  DawgInfoVector *updated_constraints;
  PermuterType permuter;

  float rating_margin;  /**< pruning margin ratio */
  float rating_array[MAX_WERD_LENGTH];
};

class DictT
{
 public:
  DictT(Image* image_ptr);
  ~DictT();

  Image* getImage()
  {
    return image_ptr_;
  }

  UNICHARSET& getUnicharset()
  {
    return getImage()->getCCUtil()->unicharset;
  }

  const UnicharAmbigs &getUnicharAmbigs()
  {
    return getImage()->getCCUtil()->unichar_ambigs;
  }

  /* hyphen.cpp ************************************************************/

  /// Returns true if we've recorded the beginning of a hyphenated word.
  inline bool hyphenated() { return !last_word_on_line_ && hyphen_word_; }

  /// Size of the base word (the part on the line before) of a hyphenated word.
  inline int hyphen_base_size()
  {
    return this->hyphenated() ? hyphen_word_->length() : 0;
  }

  /// If this word is hyphenated copy the base word (the part on
  /// the line before) of a hyphenated word into the given word.
  /// This function assumes that word is not NULL.
  inline void copy_hyphen_info(WERD_CHOICE *word)
  {
    if (this->hyphenated())
    {
      *word = *hyphen_word_;
      if (/*hyphen_debug_level*/0) word->print("copy_hyphen_info: ");
    }
  }

  /// Erase the unichar ids corresponding to the portion of the word
  /// from the previous line. The word is not changed if it is not
  /// split between lines and hyphenated.
  inline void remove_hyphen_head(WERD_CHOICE *word)
  {
    if (this->hyphenated())
    {
      word->remove_unichar_ids(0, hyphen_word_->length());
      if (/*hyphen_debug_level*/0) hyphen_word_->print("remove_hyphen_head: ");
    }
  }

  /// Check whether the word has a hyphen at the end.
  inline bool has_hyphen_end(const WERD_CHOICE &word)
  {
    int word_index = word.length() - 1;
    return (last_word_on_line_ && word_index > 0 && word.unichar_id(word_index) == hyphen_unichar_id_);
  }

  /// Unless the previous word was the last one on the line, and the current
  /// one is not (thus it is the first one on the line), erase hyphen_word_,
  /// clear hyphen_active_dawgs_, hyphen_constraints_ update last_word_on_line_.
  void reset_hyphen_vars(bool last_word_on_line);

  /// Update hyphen_word_, and copy the given DawgInfoVectors into
  /// hyphen_active_dawgs_ and hyphen_constraints_.
  void set_hyphen_word(const WERD_CHOICE &word, const DawgInfoVector &active_dawgs, const DawgInfoVector &constraints);

  /* permdawg.cpp ************************************************************/
  /// If new_rating < best_choice->rating(), copy word int best_choice
  /// and update rating and permuter of best_choice to the new given values.
  inline void update_best_choice(
      const WERD_CHOICE &word, WERD_CHOICE *best_choice)
  {
    if (word.rating() < best_choice->rating())
    {
      *best_choice = word;
    }
  }

  /// Fill the given active_dawgs vector with dawgs that could contain the
  /// beginning of the word. If hyphenated() returns true, copy the entries
  /// from hyphen_active_dawgs_ instead.
  void init_active_dawgs(DawgInfoVector *active_dawgs);

  /// If hyphenated() returns true, copy the entries from hyphen_constraints_
  /// into the given constraints vector.
  void init_constraints(DawgInfoVector *constraints);

  /// Recursively explore all the possible character combinations in
  /// the given char_choices. Use go_deeper_dawg_fxn() to explore all the
  /// dawgs in the dawgs_ vector in parallel and discard invalid words.
  ///
  /// Allocate and return a WERD_CHOICE with the best valid word found.
  WERD_CHOICE *dawg_permute_and_select(const BLOB_CHOICE_LIST_VECTOR &char_choices, float rating_limit);
  void adjust_word(WERD_CHOICE *best_choice, float *certainty_array);

  /// If the choice being composed so far could be a dictionary word
  /// and we have not reached the end of the word keep exploring the
  /// char_choices further.
  ///
  /// Also:
  /// - set hyphen word if needed
  /// - if word_ending is true and word is better than best_choice
  ///   copy word to best_choice log new word choice
  void go_deeper_dawg_fxn(
      const char *debug, const BLOB_CHOICE_LIST_VECTOR &char_choices,
      int char_choice_index, const CHAR_FRAGMENT_INFO *prev_char_frag_info,
      bool word_ending, WERD_CHOICE *word, float certainties[],
      float *limit, WERD_CHOICE *best_choice, void *void_more_args);

  /* permute.cpp *************************************************************/
  void add_document_word(const WERD_CHOICE &best_choice);
  void init_permute();
  WERD_CHOICE *permute_top_choice(
    const BLOB_CHOICE_LIST_VECTOR &char_choices,
    float* rating_limit,
    WERD_CHOICE *raw_choice,
    BOOL8 *any_alpha);
  const char* choose_il1(const char *first_char,       //< first choice
                         const char *second_char,      //< second choice
                         const char *third_char,       //< third choice
                         const char *prev_char,        //< prev in word
                         const char *next_char,        //< next in word
                         const char *next_next_char);  //< after next next in word

  /// @return NO_PERM for words with digits
  int valid_word(const WERD_CHOICE &word)
  {
    return valid_word(word, false);
  }

  /// @return NUMBER_PERM for valid numbers
  int valid_word_or_number(const WERD_CHOICE &word)
  {
    return valid_word(word, true);
  }

  int valid_word(const WERD_CHOICE &word, bool numbers_ok);
  bool valid_punctuation(const WERD_CHOICE &word);
  WERD_CHOICE *permute_all(const BLOB_CHOICE_LIST_VECTOR &char_choices, float rating_limit, WERD_CHOICE *raw_choice);
  void end_permute();
  void adjust_non_word(WERD_CHOICE *word, float *adjust_factor);
  void permute_subword(const BLOB_CHOICE_LIST_VECTOR &char_choices, float rating_limit, int start, int end, WERD_CHOICE *current_word);
  void permute_characters(const BLOB_CHOICE_LIST_VECTOR &char_choices, float limit, WERD_CHOICE *best_choice, WERD_CHOICE *raw_choice);
  WERD_CHOICE *permute_compound_words( const BLOB_CHOICE_LIST_VECTOR &char_choices, float rating_limit);

  /// checks if the dominant word script, if there is one, is same as target.
  bool word_script_eq(const BLOB_CHOICE_LIST_VECTOR &char_choices, int target_script_id);

  /// Incoporate segmentation cost into word rating
  void incorporate_segcost(WERD_CHOICE* word);

  /// checks for script-consistent permutations
  WERD_CHOICE *permute_script_words(const BLOB_CHOICE_LIST_VECTOR &char_choices);

  WERD_CHOICE *top_fragments_permute_and_select(
      const BLOB_CHOICE_LIST_VECTOR &char_choices,
      float rating_limit);
  /// If the choice being composed so far could be better
  /// than best_choice keep exploring char_choices.
  /// If we have reached the end of the word and word is better than
  /// best_choice, copy word to best_choice and log a new word choice.
  void go_deeper_top_fragments_fxn(
      const char *debug, const BLOB_CHOICE_LIST_VECTOR &char_choices,
      int char_choice_index, const CHAR_FRAGMENT_INFO *prev_char_frag_info,
      bool word_ending, WERD_CHOICE *word, float certainties[],
      float *limit, WERD_CHOICE *best_choice, void *more_args);

  /// Semi-generic functions used by multiple permuters.
  bool fragment_state_okay(UNICHAR_ID curr_unichar_id,
                           float curr_rating, float curr_certainty,
                           const CHAR_FRAGMENT_INFO *prev_char_frag_info,
                           const char *debug, int word_ending,
                           CHAR_FRAGMENT_INFO *char_frag_info);
  void permute_choices(
      const char *debug,
      const BLOB_CHOICE_LIST_VECTOR &char_choices,
      int char_choice_index,
      const CHAR_FRAGMENT_INFO *prev_char_frag_info,
      WERD_CHOICE *word,
      float certainties[],
      float *limit,
      WERD_CHOICE *best_choice,
      void *more_args);

  void append_choices(
      const char *debug,
      const BLOB_CHOICE_LIST_VECTOR &char_choices,
      const BLOB_CHOICE &blob_choice,
      int char_choice_index,
      const CHAR_FRAGMENT_INFO *prev_char_frag_info,
      WERD_CHOICE *word,
      float certainties[],
      float *limit,
      WERD_CHOICE *best_choice,
      void *more_args);
  /// Pointer to go_deeper function that will be modified by various permuters.
  void (DictT::*go_deeper_fxn_)(const char *debug,
                               const BLOB_CHOICE_LIST_VECTOR &char_choices,
                               int char_choice_index,
                               const CHAR_FRAGMENT_INFO *prev_char_frag_info,
                               bool word_ending, WERD_CHOICE *word,
                               float certainties[], float *limit,
                               WERD_CHOICE *best_choice, void *void_more_args);
  /* stopper.cpp *************************************************************/
  int NoDangerousAmbig(WERD_CHOICE *BestChoice,
                       DANGERR *fixpt,
                       bool fix_replaceable,
                       BLOB_CHOICE_LIST_VECTOR *Choices,
                       bool *modified_blobs);
  void ReplaceAmbig(int wrong_ngram_begin_index, int wrong_ngram_size,
                    UNICHAR_ID correct_ngram_id, WERD_CHOICE *werd_choice,
                    BLOB_CHOICE_LIST_VECTOR *blob_choices,
                    bool *modified_blobs);

  inline void DisableChoiceAccum() { keep_word_choices_ = FALSE; }
  inline void EnableChoiceAccum() { keep_word_choices_ = TRUE; }

  int LengthOfShortestAlphaRun(const WERD_CHOICE &WordChoice);
  VIABLE_CHOICE NewViableChoice(const WERD_CHOICE &WordChoice,
                                FLOAT32 AdjustFactor,
                                const float Certainties[]);
  void PrintViableChoice(FILE *File, const char *Label, VIABLE_CHOICE Choice);
  int StringSameAs(const char *String,
                   const char *String_lengths,
                   VIABLE_CHOICE ViableChoice);
  bool StringSameAs(const WERD_CHOICE &WordChoice,
                    VIABLE_CHOICE ViableChoice);
  int AcceptableChoice(BLOB_CHOICE_LIST_VECTOR *Choices,
                       WERD_CHOICE *BestChoice,
                       const WERD_CHOICE &RawChoice,
                       DANGERR *fixpt,
                       ACCEPTABLE_CHOICE_CALLER caller,
                       bool *modified_blobs);
  int AcceptableResult(const WERD_CHOICE &BestChoice,
                       const WERD_CHOICE &RawChoice);
  int ChoiceSameAs(const WERD_CHOICE &WordChoice, VIABLE_CHOICE ViableChoice);
  void LogNewChoice(const WERD_CHOICE &WordChoice, FLOAT32 AdjustFactor,
                    const float Certainties[], bool raw_choice);
  void EndDangerousAmbigs();
  int CurrentBestChoiceIs(const WERD_CHOICE &WordChoice);
  FLOAT32 CurrentBestChoiceAdjustFactor();
  int CurrentWordAmbig();
  void DebugWordChoices();
  void PrintAmbigAlternatives(FILE *file, const char *label,
                              int label_num_unichars);
  void FillViableChoice(const WERD_CHOICE &WordChoice,
                        FLOAT32 AdjustFactor, const float Certainties[],
                        bool SameString, VIABLE_CHOICE ViableChoice);
  int AlternativeChoicesWorseThan(FLOAT32 Threshold);
  void FilterWordChoices();
  void FindClassifierErrors(FLOAT32 MinRating,
                          FLOAT32 MaxRating,
                          FLOAT32 RatingMargin,
                          FLOAT32 Thresholds[]);
  void InitChoiceAccum();
  void LogNewSegmentation(PIECES_STATE BlobWidth);
  void LogNewSplit(int Blob);
  void SettupStopperPass1();
  void SettupStopperPass2();
  /* choices.cpp *************************************************************/
  void print_word_string(const char* str);
  void print_word_choice(const char *label, A_CHOICE* choice);
  void print_choices(const char *label,
                     CHOICES rating);   // List of (A_CHOICE*).
  /* permngram.cpp ***********************************************************/
  A_CHOICE *ngram_permute_and_select(CHOICES_LIST char_choices,
                                     float rating_limit,
                                     const Dawg *dawg);
  /* dawg.cpp ****************************************************************/

  /**
   * Returns the maximal permuter code (from ccstruct/ratngs.h) if in light
   * of the current state the letter at word_index in the given word
   * is allowed according to at least one of the dawgs in dawgs_,
   * otherwise returns NO_PERM.
   *
   * The state is described by void_dawg_args, which are interpreted as
   * DawgArgs and contain two relevant input vectors: active_dawgs and
   * constraints. Each entry in the active_dawgs vector contains an index
   * into the dawgs_ vector and an EDGE_REF that indicates the last edge
   * followed in the dawg. Each entry in the constraints vector contains
   * an index into the dawgs_ vector and an EDGE_REF that indicates an edge
   * in a pattern dawg followed to match a pattern. Currently constraints
   * are used to save the state of punctuation dawgs after leading
   * punctuation was found.
   *
   * Input:
   * At word_index 0 dawg_args->active_dawgs should contain an entry for each
   * dawg whose type has a bit set in kBeginningDawgsType,
   * dawg_args->constraints should be empty. EDGE_REFs in active_dawgs and
   * constraints vectors should be initialized to NO_EDGE. If hyphen state
   * needs to be applied, initial dawg_args->active_dawgs and
   * dawg_args->constrains can be copied from the saved hyphen state
   * (maintained by DictT).
   * For word_index > 0 the corresponding state (active_dawgs and constraints)
   * can be obtained from dawg_args->updated_* passed to def_letter_is_okay
   * for word_index-1.
   * Note: the function assumes that active_dags, constraints and updated_*
   * member variables of dawg_args are not NULL.
   *
   * Output:
   * The function fills in dawg_args->updated_active_dawgs vector with the
   * entries for dawgs that contain the word up to the letter at word_index.
   * The new constraints (if any) are added to dawg_args->updated_constraints,
   * the constraints from dawg_args->constraints are also copied into it.
   *
   * Detailed description:
   * In order to determine whether the word is still valid after considering
   * all the letters up to the one at word_index the following is done for
   * each entry in dawg_args->active_dawgs:
   *
   *  - next starting node is obtained from entry.ref and edge_char_of() is
   *    called to obtain the next edge
   *  - if a valid edge is found, the function returns the updated permuter
   *    code true and an entry [entry.dawg_index, edge] is inserted in
   *    dawg_args->updated_active_dawgs
   *    otherwise:
   *    - if we are dealing with dawg of type DAWG_TYPE_PUNCTUATION,
   *      edge_char_of() is called again, but now with kPatternUnicharID
   *      as unichar_id; if a valid edge is found it is recorded in
   *      dawg_args->updated_constraints
   *    - the function checks whether the word can end with the previous
   *      letter
   *    - each successor of the dawg (e.g. dawgs with type DAWG_TYPE_WORD
   *      could be successors to dawgs with type DAWG_TYPE_PUNCTUATION; the
   *      successors are defined by successors_ vector) is explored and if
   *      a letter is found in the successor dawg, a new entry is inserted
   *      into dawg_args->updated_active_dawgs with EDGE_REF being either
   *      NO_EDGE or an EDGE_REF recorded in constraints vector for the
   *      corresponding dawg index
   */

  int def_letter_is_okay(void* void_dawg_args, int word_index,
                         const void* word, bool word_end);

  int new_letter_is_okay(void* void_dawg_args, int word_index,
                         const void* word, bool word_end);
  int (DictT::*letter_is_okay_)(void* void_dawg_args, int word_index,
                               const void *word, bool word_end);
  /** Return the number of dawgs in the dawgs_ vector. */
  inline int NumDawgs() const { return dawgs_.size(); }
  /** Return i-th dawg pointer recorded in the dawgs_ vector. */
  inline const Dawg *GetDawg(int index) const { return dawgs_[index]; }
  /**
   * At word ending make sure all the recorded constraints are satisfied.
   * Each constraint signifies that we found a beginning pattern in a
   * pattern dawg. Check that this pattern can end here (e.g. if some
   * leading punctuation is found this would ensure that we are not
   * expecting any particular trailing punctuation after the word).
   */
  inline bool ConstraintsOk(const DawgInfoVector &constraints,
                            int word_end, DawgType current_dawg_type) {
    if (!word_end) return true;
    if (current_dawg_type == DAWG_TYPE_PUNCTUATION) return true;
    for (int c = 0; c < constraints.length(); ++c) {
      const DawgInfo &cinfo = constraints[c];
      Dawg *cdawg = dawgs_[cinfo.dawg_index];
      if (!cdawg->end_of_word(cinfo.ref)) {
        if (dawg_debug_level >= 3) {
          tprintf("Constraint [%d, " REFFORMAT "] is not satisfied\n",
                  cinfo.dawg_index, cinfo.ref);
        }
        return false;
      }
    }
    return true;
  }
  /// Record the maximum of the two permuters in permuter.
  static inline void UpdatePermuter(PermuterType new_permuter,
                                    PermuterType *permuter) {
    if (dawg_debug_level >= 3) tprintf("Letter found\n");
    if (new_permuter > *permuter) *permuter = new_permuter;
  }

  /* conversion.cpp **********************************************************/
  // TODO(daria): remove these function when conversion.cpp is deprecated
  // and all the code is converted to work with unichar ids.
  void LogNewWordChoice(A_CHOICE *a_choice,
                        FLOAT32 adjust_factor,
                        const float certainties[],
                        const UNICHARSET &unicharset);
  int valid_word(const char *string);

 private:
  /** Private member variables. */
  Image* image_ptr_;
  /**
   * Table that stores ambiguities computed during training
   * (loaded when NoDangerousAmbigs() is called for the first time).
   * Each entry i in the table stores a set of amibiguities whose
   * wrong ngram starts with unichar id i.
   */
  UnicharAmbigs *dang_ambigs_table_;
  /** Same as above, but for ambiguities with replace flag set. */
  UnicharAmbigs *replace_ambigs_table_;
  /**
   * Flag used to disable accumulation of word choices
   * during compound word permutation.
   */
  BOOL8 keep_word_choices_;
  /** Additional certainty padding allowed before a word is rejected. */
  FLOAT32 reject_offset_;
  /** Current word segmentation. */
  PIECES_STATE current_segmentation_;
  /** Variables to keep track of best/raw word choices. */
  VIABLE_CHOICE best_raw_choice_;
  LIST raw_choices_;
  LIST best_choices_;
  // Hyphen-related variables.
  UNICHAR_ID hyphen_unichar_id_;
  WERD_CHOICE *hyphen_word_;
  DawgInfoVector hyphen_active_dawgs_;
  DawgInfoVector hyphen_constraints_;
  bool last_word_on_line_;
  // Dawgs.
  DawgVector dawgs_;
  SuccessorListsVector successors_;
  Dawg *freq_dawg_;
  Trie *pending_words_;
  /// The following pointers are only cached for convenience.
  /// The dawgs will be deleted when dawgs_ vector is destroyed.
  // TODO(daria): need to support multiple languages in the future,
  // so maybe will need to maintain a list of dawgs of each kind.
  Trie *document_words_;
};
/////////////////////////////////////////////////////////////////DictT////////////////////////////////////////

/////////////////////////////////////////////////////////////////emalloc////////////////////////////////////////
#define NOTENOUGHMEMORY   2000
#define ILLEGALMALLOCREQUEST  2001

/**----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------**/
void *Emalloc(size_t Size);

void *Erealloc(void *ptr, size_t size);

void Efree(void *ptr);
/////////////////////////////////////////////////////////////////emalloc////////////////////////////////////////

/////////////////////////////////////////////////////////////////bitvec////////////////////////////////////////
/*-----------------------------------------------------------------------------
          Include Files and Type Defines
-----------------------------------------------------------------------------*/
#define BITSINLONG      32       /**< no of bits in a long */
typedef uinT32 *BIT_VECTOR;

/*-----------------------------------------------------------------------------
          Public Function Prototypes
-----------------------------------------------------------------------------*/
#define zero_all_bits(array,length) \
{\
    register int			index;						/*temporary index*/\
    \
    for (index=0;index<length;index++)\
    array[index]=0;										/*zero all bits*/\
    }

#define set_all_bits(array,length) \
{\
    register int			index;						/*temporary index*/\
    \
    for (index=0;index<length;index++)\
    array[index]= ~0;									/*set all bits*/\
    }

#define copy_all_bits(source,dest,length) \
{\
    register int			index;						/*temporary index*/\
    \
    for (index=0;index<length;index++)\
    dest[index]=source[index];							/*copy all bits*/\
    }

#define SET_BIT(array,bit) (array[bit/BITSINLONG]|=1<<(bit&(BITSINLONG-1)))

#define reset_bit(array,bit) (array[bit/BITSINLONG]&=~(1<<(bit&(BITSINLONG-1))))

#define test_bit(array,bit) (array[bit/BITSINLONG] & (1<<(bit&(BITSINLONG-1))))

#define WordsInVectorOfSize(NumBits) \
    (((NumBits) + BITSINLONG - 1) / BITSINLONG)

/*--------------------------------------------------------------------------
        Public Function Prototypes
--------------------------------------------------------------------------*/
BIT_VECTOR ExpandBitVector(BIT_VECTOR Vector, int NewNumBits);

void FreeBitVector(BIT_VECTOR BitVector);

int hamming_distance(uinT32* array1, uinT32* array2, int length);

BIT_VECTOR NewBitVector(int NumBits);
/////////////////////////////////////////////////////////////////bitvec////////////////////////////////////////

/////////////////////////////////////////////////////////////////protos////////////////////////////////////////
/*----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------*/
typedef BIT_VECTOR *CONFIGS;

typedef struct
{
  FLOAT32 A;
  FLOAT32 B;
  FLOAT32 C;
  FLOAT32 X;
  FLOAT32 Y;
  FLOAT32 Angle;
  FLOAT32 Length;
} PROTO_STRUCT;
typedef PROTO_STRUCT *PROTO;

typedef struct
{
  inT16 NumProtos;
  inT16 MaxNumProtos;
  PROTO Prototypes;
  inT16 NumConfigs;
  inT16 MaxNumConfigs;
  CONFIGS Configurations;
  UnicityTableEqEq<int> font_set;
} CLASS_STRUCT;
typedef CLASS_STRUCT *CLASS_TYPE;
typedef CLASS_STRUCT *CLASSES;

/*----------------------------------------------------------------------
              C o n s t a n t s
----------------------------------------------------------------------*/
#define NUMBER_OF_CLASSES  MAX_NUM_CLASSES
#define Y_OFFSET           -40.0
#define FEATURE_SCALE      100.0

/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
extern CLASS_STRUCT TrainingData[];

extern STRING_VAR_H(classify_training_file, "MicroFeatures", "Training file");

/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
/**
 * AddProtoToConfig
 *
 * Set a single proto bit in the specified configuration.
 */

#define AddProtoToConfig(Pid,Config)	\
(SET_BIT (Config, Pid))

/**
 * RemoveProtoFromConfig
 *
 * Clear a single proto bit in the specified configuration.
 */

#define RemoveProtoFromConfig(Pid,Config)	\
(reset_bit (Config, Pid))

/**
 * ClassOfChar
 *
 * Return the class of a particular ASCII character value.
 */

#define ClassOfChar(Char)            \
((TrainingData [Char].NumProtos) ? \
    (& TrainingData [Char])         : \
    NO_CLASS)

/**
 * ProtoIn
 *
 * Choose the selected prototype in this class record.  Return the
 * pointer to it (type PROTO).
 */

#define ProtoIn(Class,Pid)  \
(& (Class)->Prototypes [Pid])

/**
 * PrintProto
 *
 * Print out the contents of a prototype.   The 'Proto' argument is of
 * type 'PROTO'.
 */

#define PrintProto(Proto)                      \
(cprintf ("X=%4.2f, Y=%4.2f, Angle=%4.2f",    \
          Proto->X,                \
          Proto->Y,                \
          Proto->Length,                \
          Proto->Angle))                \


/**
 * PrintProtoLine
 *
 * Print out the contents of a prototype.   The 'Proto' argument is of
 * type 'PROTO'.
 */

#define PrintProtoLine(Proto)             \
(cprintf ("A=%4.2f, B=%4.2f, C=%4.2f",   \
            Proto->A,           \
            Proto->B,           \
            Proto->C))           \

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
int AddConfigToClass(CLASS_TYPE Class);

int AddProtoToClass(CLASS_TYPE Class);

FLOAT32 ClassConfigLength(CLASS_TYPE Class, BIT_VECTOR Config);

FLOAT32 ClassProtoLength(CLASS_TYPE Class);

void CopyProto(PROTO Src, PROTO Dest);

void FillABC(PROTO Proto);

void FreeClass(CLASS_TYPE Class);

void FreeClassFields(CLASS_TYPE Class);

void InitPrototypes();

CLASS_TYPE NewClass(int NumProtos, int NumConfigs);

void PrintProtos(CLASS_TYPE Class);

void ReadClassFromFile(FILE *File, UNICHAR_ID unichar_id);

void ReadConfigs(register FILE *File, CLASS_TYPE Class);

void ReadProtos(register FILE *File, CLASS_TYPE Class);

int SplitProto(CLASS_TYPE Class, int OldPid);

void WriteOldConfigFile(FILE *File, CLASS_TYPE Class);

void WriteOldProtoFile(FILE *File, CLASS_TYPE Class);
/////////////////////////////////////////////////////////////////protos////////////////////////////////////////

/////////////////////////////////////////////////////////////////fpoint////////////////////////////////////////
/* define data structure to hold 2D points or vectors using floating point */
typedef struct
{
  FLOAT32 x, y;
} FPOINT;
typedef FPOINT FVECTOR;

/**----------------------------------------------------------------------------
            Macros
----------------------------------------------------------------------------**/
/* macros for computing miscellaneous functions of 2 points */
#define XDelta(A,B)   ( (B).x - (A).x )
#define YDelta(A,B)   ( (B).y - (A).y )
#define SlopeFrom(A,B)    ( YDelta(A,B) / XDelta(A,B) )
#define AngleFrom(A,B)		( atan2((double) YDelta(A,B),		\
                    (double) XDelta(A,B) ) )

#define XIntersectionOf(A,B,X)  ( SlopeFrom(A,B) * ((X) - A.x) + A.y)

/*-------------------------------------------------------------------------
        Public Function Prototypes
---------------------------------------------------------------------------*/

FLOAT32 DistanceBetween(FPOINT A, FPOINT B);

FLOAT32 NormalizedAngleFrom(FPOINT *Point1, FPOINT *Point2, FLOAT32 FullScale);
/////////////////////////////////////////////////////////////////fpoint////////////////////////////////////////

/////////////////////////////////////////////////////////////////blobs////////////////////////////////////////
/*----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------*/
typedef struct
{                                /* Widths of pieces */
  int num_chars;
  int widths[1];
} WIDTH_RECORD;

/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
/**********************************************************************
 * free_widths
 *
 * Free the memory taken up by a width array.
 **********************************************************************/
#define free_widths(w)  \
if (w) memfree (w)

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
void blob_origin(TBLOB *blob,      /*blob to compute on */
                 TPOINT *origin);  /*return value */

                                 /*blob to compute on */
void blob_bounding_box(TBLOB *blob,
                       register TPOINT *topleft,  /*bounding box */
                       register TPOINT *botright);

void blobs_bounding_box(TBLOB *blobs, TPOINT *topleft, TPOINT *botright);

void blobs_origin(TBLOB *blobs,     /*blob to compute on */
                  TPOINT *origin);  /*return value */

                                 /*blob to compute on */
WIDTH_RECORD *blobs_widths(TBLOB *blobs);

int count_blobs(TBLOB *blobs);

void delete_word(TWERD *word);

void delete_edgepts(register EDGEPT *edgepts);
/////////////////////////////////////////////////////////////////blobs////////////////////////////////////////

/////////////////////////////////////////////////////////////////baseline////////////////////////////////////////
#define BASELINE_OFFSET 64
#define BASELINE_SCALE  128
extern INT_VAR_H(classify_baseline_normalized, 1, "Baseline Enable");
/////////////////////////////////////////////////////////////////baseline////////////////////////////////////////

/////////////////////////////////////////////////////////////////kdtree////////////////////////////////////////
/**
NOTE:  All circular parameters of all keys must be in the range

Min <= Param < Max

where Min and Max are specified in the KeyDesc parameter passed to
MakeKDTree.  All KD routines assume that this is true and will not operate
correctly if circular parameters outside the specified range are used.
*/

typedef struct kdnode
{
  FLOAT32 *Key;                  /**< search key */
  char *Data;                    /**< data that corresponds to key */
  FLOAT32 BranchPoint;           /**< needed to make deletes work efficiently */
  FLOAT32 LeftBranch;            /**< used to optimize search pruning */
  FLOAT32 RightBranch;           /**< used to optimize search pruning */
  struct kdnode *Left;           /**< ptr for KD tree structure */
  struct kdnode *Right;          /**< ptr for KD tree structure */
}KDNODE;

typedef struct
{
  inT16 KeySize;                 /* number of dimensions in the tree */
  KDNODE Root;                   /* Root.Left points to actual root node */
  PARAM_DESC KeyDesc[1];         /* description of each dimension */
}KDTREE;

/** used for walking thru KD trees */
typedef enum {
  preorder, postorder, endorder, leaf
}VISIT;

/*----------------------------------------------------------------------------
            Macros
-----------------------------------------------------------------------------*/
#define RootOf(T)   ((T)->Root.Left->Data)

/*-----------------------------------------------------------------------------
          Public Function Prototypes
-----------------------------------------------------------------------------*/
KDTREE *MakeKDTree (inT16 KeySize, PARAM_DESC KeyDesc[]);

void KDStore(KDTREE *Tree, FLOAT32 *Key, void *Data);

void KDDelete (KDTREE * Tree, FLOAT32 Key[], void *Data);

int KDNearestNeighborSearch (KDTREE * Tree,
FLOAT32 Query[],
int QuerySize,
FLOAT32 MaxDistance,
void *NBuffer, FLOAT32 DBuffer[]);

void KDWalk(KDTREE *Tree, void_proc Action);

void FreeKDTree(KDTREE *Tree);

/*-----------------------------------------------------------------------------
          Private Function Prototypes
-----------------------------------------------------------------------------*/
int Equal (FLOAT32 Key1[], FLOAT32 Key2[]);

KDNODE *MakeKDNode (FLOAT32 Key[], char *Data, int Index);

void FreeKDNode(KDNODE *Node);

void Search(int Level, KDNODE *SubTree);

FLOAT32 ComputeDistance (register int N,
register PARAM_DESC Dim[],
register FLOAT32 p1[], register FLOAT32 p2[]);

void FindMaxDistance();

int QueryIntersectsSearch();

int QueryInSearch();

void Walk(KDNODE *SubTree, inT32 Level);

void FreeSubTree(KDNODE *SubTree);
/////////////////////////////////////////////////////////////////kdtree////////////////////////////////////////

/////////////////////////////////////////////////////////////////oldheap////////////////////////////////////////
#define HEAPFULL      3000
#define OK          0
#define EMPTY -1

typedef struct
{
  FLOAT32 Key;
  void *Data;
}HEAPENTRY;

typedef struct
{
  inT32 Size;
  inT32 FirstFree;
  HEAPENTRY Entry[1];
}HEAP;

/*-----------------------------------------------------------------------------
            Macros
-----------------------------------------------------------------------------*/
#define           FreeHeap(H) memfree(H)
#define           MaxSizeOfHeap(H)  (H->Size)
#define           SizeOfHeap(H)   (H->FirstFree - 1)
#define           InitHeap(H)   (H->FirstFree = 1)
#define           HeapFull(H)   ((H)->FirstFree > (H)->Size)
#define           HeapEmpty(H)    ((H)->FirstFree <= 1)

/* macros for accessing elements in heap by index.  The indicies vary from
  0 to SizeOfHeap-1.  No bounds checking is done.  Elements accessed in
  this manner are in random order relative to the Key values.  These
  macros should never be used as the LHS of an assignment statement as this
  will corrupt the heap.*/
#define           HeapKeyFor(H,E)   ((H)->Entry[(E)+1].Key)
#define           HeapDataFor(H,E)  ((H)->Entry[(E)+1].Data)

/*-----------------------------------------------------------------------------
          Public Function Prototypes
-----------------------------------------------------------------------------*/
HEAP *MakeHeap(int Size);

int HeapPop(HEAP *Heap, FLOAT32 *Key, void *out_ptr);

int HeapPopWorst(HEAP *Heap, FLOAT32 *Key, void *out_ptr);

void HeapPush(HEAP *Heap, FLOAT32 Key, void *Data);

void HeapStore(HEAP *Heap, HEAPENTRY *Entry);

int GetTopOfHeap(HEAP *Heap, HEAPENTRY *Entry);

void FreeHeapData(HEAP *Heap, void_dest destructor);
/////////////////////////////////////////////////////////////////oldheap////////////////////////////////////////

/////////////////////////////////////////////////////////////////cluster////////////////////////////////////////
/*----------------------------------------------------------------------
          Types
----------------------------------------------------------------------*/
typedef struct sample
{
  unsigned Clustered:1;          // TRUE if included in a higher cluster
  unsigned Prototype:1;          // TRUE if cluster represented by a proto
  unsigned SampleCount:30;       // number of samples in this cluster
  struct sample *Left;           // ptr to left sub-cluster
  struct sample *Right;          // ptr to right sub-cluster
  inT32 CharID;                  // identifier of char sample came from
  FLOAT32 Mean[1];               // mean of cluster - SampleSize floats
}


CLUSTER;

typedef CLUSTER SAMPLE;          // can refer to as either sample or cluster

typedef enum {
  spherical, elliptical, mixed, automatic
}


PROTOSTYLE;

typedef struct                   // parameters to control clustering
{
  PROTOSTYLE ProtoStyle;         // specifies types of protos to be made
  FLOAT32 MinSamples;            // min # of samples per proto - % of total
  FLOAT32 MaxIllegal;            // max percentage of samples in a cluster which have
  // more than 1 feature in that cluster
  FLOAT32 Independence;          // desired independence between dimensions
  FLOAT64 Confidence;            // desired confidence in prototypes created
  int MagicSamples;              // Ideal number of samples in a cluster.
}CLUSTERCONFIG;

typedef enum {
  normal, uniform, D_random
}


DISTRIBUTION;

typedef union
{
  FLOAT32 Spherical;
  FLOAT32 *Elliptical;

}


FLOATUNION;

typedef struct
{
  unsigned Significant:1;        // TRUE if prototype is significant
  unsigned Merged:1;             // Merged after clustering so do not output
                                 // but kept for display purposes. If it has no
                                 // samples then it was actually merged.
                                 // Otherwise it matched an already significant
                                 // cluster.
  unsigned Style:2;              // spherical, elliptical, or mixed
  unsigned NumSamples:28;        // number of samples in the cluster
  CLUSTER *Cluster;              // ptr to cluster which made prototype
  DISTRIBUTION *Distrib;         // different distribution for each dimension
  FLOAT32 *Mean;                 // prototype mean
  FLOAT32 TotalMagnitude;        // total magnitude over all dimensions
  FLOAT32 LogMagnitude;          // log base e of TotalMagnitude
  FLOATUNION Variance;           // prototype variance
  FLOATUNION Magnitude;          // magnitude of density function
  FLOATUNION Weight;             // weight of density function
}PROTOTYPE;

typedef struct
{
  inT16 SampleSize;              // number of parameters per sample
  PARAM_DESC *ParamDesc;         // description of each parameter
  inT32 NumberOfSamples;         // total number of samples being clustered
  KDTREE *KDTree;                // for optimal nearest neighbor searching
  CLUSTER *Root;                 // ptr to root cluster of cluster tree
  LIST ProtoList;                // list of prototypes
  inT32 NumChar;                 // # of characters represented by samples
}


CLUSTERER;

typedef struct
{
  inT32 NumSamples;              // number of samples in list
  inT32 MaxNumSamples;           // maximum size of list
  SAMPLE *Sample[1];             // array of ptrs to sample data structures
}SAMPLELIST;

// low level cluster tree analysis routines.
#define InitSampleSearch(S,C) (((C)==NULL)?(S=NIL):(S=push(NIL,(C))))

/*--------------------------------------------------------------------------
        Public Function Prototypes
--------------------------------------------------------------------------*/
CLUSTERER *MakeClusterer (inT16 SampleSize, PARAM_DESC ParamDesc[]);

SAMPLE *MakeSample (CLUSTERER * Clusterer, FLOAT32 Feature[], inT32 CharID);

LIST ClusterSamples(CLUSTERER *Clusterer, CLUSTERCONFIG *Config);

void FreeClusterer(CLUSTERER *Clusterer);

void FreeProtoList(LIST *ProtoList);

void FreePrototype(void *arg);  //PROTOTYPE     *Prototype);

CLUSTER *NextSample(LIST *SearchState);

FLOAT32 Mean(PROTOTYPE *Proto, uinT16 Dimension);

FLOAT32 StandardDeviation(PROTOTYPE *Proto, uinT16 Dimension);

inT32 MergeClusters(inT16 N, PARAM_DESC ParamDesc[], inT32 n1, inT32 n2,
                    FLOAT32 m[], FLOAT32 m1[], FLOAT32 m2[]);

//--------------Global Data Definitions and Declarations---------------------------
// define errors that can be trapped
#define ALREADYCLUSTERED  4000
/////////////////////////////////////////////////////////////////cluster////////////////////////////////////////

/////////////////////////////////////////////////////////////////clusttool////////////////////////////////////////
/*-------------------------------------------------------------------------
        Public Funtion Prototype
--------------------------------------------------------------------------*/
uinT16 ReadSampleSize(FILE *File);

PARAM_DESC *ReadParamDesc(FILE *File, uinT16 N);

PROTOTYPE *ReadPrototype(FILE *File, uinT16 N);

PROTOSTYLE ReadProtoStyle(FILE *File);

FLOAT32 *ReadNFloats (FILE * File, uinT16 N, FLOAT32 Buffer[]);

void WriteParamDesc (FILE * File, uinT16 N, PARAM_DESC ParamDesc[]);

void WritePrototype(FILE *File, uinT16 N, PROTOTYPE *Proto);

void WriteNFloats (FILE * File, uinT16 N, FLOAT32 Array[]);

void WriteProtoStyle(FILE *File, PROTOSTYLE ProtoStyle);

void WriteProtoList(
     FILE	*File,
     uinT16	N,
     PARAM_DESC	ParamDesc[],
     LIST	ProtoList,
     BOOL8	WriteSigProtos,
     BOOL8	WriteInsigProtos);

FLOAT32 UniformRandomNumber(FLOAT32 MMin, FLOAT32 MMax);

//--------------Global Data Definitions and Declarations---------------------
// define errors that can be trapped
#define ILLEGALSAMPLESIZE 5000
#define ILLEGALCIRCULARSPEC 5001
#define ILLEGALMINMAXSPEC 5002
#define ILLEGALSIGNIFICANCESPEC 5003
#define ILLEGALSTYLESPEC  5004
#define ILLEGALSAMPLECOUNT  5005
#define ILLEGALMEANSPEC 5006
#define ILLEGALVARIANCESPEC 5007
#define ILLEGALDISTRIBUTION 5008
#define ILLEGALFLOAT  5009
#define ILLEGALESSENTIALSPEC  5013
/////////////////////////////////////////////////////////////////clusttool////////////////////////////////////////

/////////////////////////////////////////////////////////////////hideedge////////////////////////////////////////
/**********************************************************************
 * is_hidden_edge
 *
 * Check to see if this edge is a hidden edge.  This will prohibit
 * feature extraction and display functions on this edge.  The
 * argument should be of type (EDGEPT*).
 **********************************************************************/

#define is_hidden_edge(edge) \
/*(hidden_edges &&*/ (edge->flags[0])     /*) */

/**********************************************************************
 * hide_edge
 *
 * Make this edge a hidden edge.  This will prohibit feature extraction
 * and display functions on this edge.  The argument should be of type
 * (EDGEPT*).
 **********************************************************************/

#define hide_edge(edge)  \
/*if (hidden_edges)*/ edge->flags[0] = TRUE

/**********************************************************************
 * reveal_edge
 *
 * Make this edge a unhidden edge.  This will prohibit feature extraction
 * and display functions on this edge.  The argument should be of type
 * (EDGEPT*).
 **********************************************************************/

#define reveal_edge(edge)  \
/*if (hidden_edges)*/ edge->flags[0] = FALSE
/////////////////////////////////////////////////////////////////hideedge////////////////////////////////////////

/////////////////////////////////////////////////////////////////mfoutline////////////////////////////////////////
#define NORMAL_X_HEIGHT   (0.5)
#define NORMAL_BASELINE   (0.0)

typedef LIST MFOUTLINE;

typedef enum
{
  north, south, east, west, northeast, northwest, southeast, southwest
}


DIRECTION;

typedef struct
{
  FPOINT Point;
  FLOAT32 Slope;
  unsigned Padding:20;
  BOOL8 Hidden:TRUE;
  BOOL8 ExtremityMark:TRUE;
  DIRECTION Direction:4;
  DIRECTION PreviousDirection:4;
}


MFEDGEPT;

typedef enum {
  outer, hole
}OUTLINETYPE;

typedef struct
{
  FLOAT64 Mx, My;                /* first moment of all outlines */
  FLOAT64 L;                     /* total length of all outlines */
  FLOAT64 x, y;                  /* center of mass of all outlines */
  FLOAT64 Ix, Iy;                /* second moments about center of mass axes */
  FLOAT64 Rx, Ry;                /* radius of gyration about center of mass axes */
}OUTLINE_STATS;

typedef enum
{
  baseline, character
}


NORM_METHOD;

/*----------------------------------------------------------------------------
            Variables
------------------------------------------------------------------------------*/
/* control knobs used to control normalization of outlines */
extern INT_VAR_H(classify_norm_method, character,
                 "Normalization Method   ...");
/* PREV DEFAULT "baseline" */
extern double_VAR_H(classify_char_norm_range, 0.2, "Character Normalization Range ...");
extern double_VAR_H(classify_min_norm_scale_x, 0.0, "Min char x-norm scale ...");

/* PREV DEFAULT 0.1 */
extern double_VAR_H(classify_max_norm_scale_x, 0.325, "Max char x-norm scale ...");

/* PREV DEFAULT 0.3 */
extern double_VAR_H(classify_min_norm_scale_y, 0.0, "Min char y-norm scale ...");

/* PREV DEFAULT 0.1 */
extern double_VAR_H(classify_max_norm_scale_y, 0.325, "Max char y-norm scale ...");
/* PREV DEFAULT 0.3 */

/**----------------------------------------------------------------------------
          Macros
----------------------------------------------------------------------------**/
#define AverageOf(A,B)    (((A) + (B)) / 2)

/* macro for computing the baseline of a row of text at an x position */
#define BaselineAt(L,X) (BASELINE_OFFSET)

/* macro for computing the scale factor to use to normalize characters */
#define ComputeScaleFactor(L)						\
(NORMAL_X_HEIGHT / ((classify_baseline_normalized)?			\
                (BASELINE_SCALE):					\
                ((L)->xheight)))

/* macros for manipulating micro-feature outlines */
#define DegenerateOutline(O)  (((O) == NIL) || ((O) == rest(O)))
#define PointAt(O)    ((MFEDGEPT *) first_node (O))
#define NextPointAfter(E) (rest (E))
#define MakeOutlineCircular(O)  (set_rest (last (O), (O)))

/* macros for manipulating micro-feature outline edge points */
#define ClearMark(P)    ((P)->ExtremityMark = FALSE)
#define MarkPoint(P)    ((P)->ExtremityMark = TRUE)

/**----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------**/
void ComputeBlobCenter(TBLOB *Blob, TPOINT *BlobCenter);

LIST ConvertBlob(TBLOB *Blob);

MFOUTLINE ConvertOutline(TESSLINE *Outline);

LIST ConvertOutlines(TESSLINE *Outline,
                     LIST ConvertedOutlines,
                     OUTLINETYPE OutlineType);

void ComputeOutlineStats(LIST Outlines, OUTLINE_STATS *OutlineStats);

void FilterEdgeNoise(MFOUTLINE Outline, FLOAT32 NoiseSegmentLength);

void FindDirectionChanges(MFOUTLINE Outline,
                          FLOAT32 MinSlope,
                          FLOAT32 MaxSlope);

void FreeMFOutline(void *agr);  //MFOUTLINE                             Outline);

void FreeOutlines(LIST Outlines);

void MarkDirectionChanges(MFOUTLINE Outline);

MFEDGEPT *NewEdgePoint();

MFOUTLINE NextExtremity(MFOUTLINE EdgePoint);

void NormalizeOutline(MFOUTLINE Outline,
                      LINE_STATS *LineStats,
                      FLOAT32 XOrigin);

void NormalizeOutlines(LIST Outlines,
                       LINE_STATS *LineStats,
                       FLOAT32 *XScale,
                       FLOAT32 *YScale);

void SettupBlobConversion(TBLOB *Blob);

void SmearExtremities(MFOUTLINE Outline, FLOAT32 XScale, FLOAT32 YScale);

/*----------------------------------------------------------------------------
          Private Function Prototypes
-----------------------------------------------------------------------------*/
void ChangeDirection(MFOUTLINE Start, MFOUTLINE End, DIRECTION Direction);

void CharNormalizeOutline(MFOUTLINE Outline,
                          FLOAT32 XCenter,
                          FLOAT32 YCenter,
                          FLOAT32 XScale,
                          FLOAT32 YScale);

void ComputeDirection(MFEDGEPT *Start,
                      MFEDGEPT *Finish,
                      FLOAT32 MinSlope,
                      FLOAT32 MaxSlope);

void FinishOutlineStats(register OUTLINE_STATS *OutlineStats);

void InitOutlineStats(OUTLINE_STATS *OutlineStats);

MFOUTLINE NextDirectionChange(MFOUTLINE EdgePoint);

void UpdateOutlineStats(register OUTLINE_STATS *OutlineStats,
                        register FLOAT32 x1,
                        register FLOAT32 x2,
                        register FLOAT32 y1,
                        register FLOAT32 y2);
/////////////////////////////////////////////////////////////////mfoutline////////////////////////////////////////

/////////////////////////////////////////////////////////////////intproto////////////////////////////////////////
/* define order of params in pruners */
#define PRUNER_X      0
#define PRUNER_Y      1
#define PRUNER_ANGLE    2

/* definition of coordinate system offsets for each table parameter */
#define ANGLE_SHIFT (0.0)
#define X_SHIFT   (0.5)
#define Y_SHIFT   (0.5)

#define MAX_PROTO_INDEX   24
#define BITS_PER_WERD   (8 * sizeof (uinT32))
/* Script detection: increase this number to 128 */
#define MAX_NUM_CONFIGS   64
#define MAX_NUM_PROTOS    512
#define PROTOS_PER_PROTO_SET  64
#define MAX_NUM_PROTO_SETS  (MAX_NUM_PROTOS / PROTOS_PER_PROTO_SET)
#define NUM_PP_PARAMS   3
#define NUM_PP_BUCKETS    64
#define NUM_CP_BUCKETS    24
#define CLASSES_PER_CP    32
#define NUM_BITS_PER_CLASS  2
#define CLASSES_PER_CP_WERD (CLASSES_PER_CP / NUM_BITS_PER_CLASS)
#define PROTOS_PER_PP_WERD  BITS_PER_WERD
#define BITS_PER_CP_VECTOR  (CLASSES_PER_CP * NUM_BITS_PER_CLASS)
#define MAX_NUM_CLASS_PRUNERS	((MAX_NUM_CLASSES + CLASSES_PER_CP - 1) /   \
                CLASSES_PER_CP)
#define WERDS_PER_CP_VECTOR (BITS_PER_CP_VECTOR / BITS_PER_WERD)
#define WERDS_PER_PP_VECTOR	((PROTOS_PER_PROTO_SET+BITS_PER_WERD-1)/    \
                BITS_PER_WERD)
#define WERDS_PER_PP		(NUM_PP_PARAMS * NUM_PP_BUCKETS *		\
                WERDS_PER_PP_VECTOR)
#define WERDS_PER_CP		(NUM_CP_BUCKETS * NUM_CP_BUCKETS *		\
                NUM_CP_BUCKETS * WERDS_PER_CP_VECTOR)
#define WERDS_PER_CONFIG_VEC	((MAX_NUM_CONFIGS + BITS_PER_WERD - 1) /    \
                BITS_PER_WERD)

/* The first 3 dimensions of the CLASS_PRUNER_STRUCT are the
 * 3 axes of the quantized feature space.
 * The position of the the bits recorded for each class in the
 * 4th dimension is determined by using CPrunerWordIndexFor(c),
 * where c is the corresponding class id. */
typedef uinT32 CLASS_PRUNER_STRUCT
[NUM_CP_BUCKETS][NUM_CP_BUCKETS][NUM_CP_BUCKETS][WERDS_PER_CP_VECTOR];

typedef uinT32 (*CLASS_PRUNER)[NUM_CP_BUCKETS][NUM_CP_BUCKETS][WERDS_PER_CP_VECTOR];

typedef struct
{
  inT8 A;
  uinT8 B;
  inT8 C;
  uinT8 Angle;
  uinT32 Configs[WERDS_PER_CONFIG_VEC];
}INT_PROTO_STRUCT, *INT_PROTO;

typedef uinT32 PROTO_PRUNER[NUM_PP_PARAMS][NUM_PP_BUCKETS][WERDS_PER_PP_VECTOR];

typedef struct
{
  PROTO_PRUNER ProtoPruner;
  INT_PROTO_STRUCT Protos[PROTOS_PER_PROTO_SET];
}PROTO_SET_STRUCT, *PROTO_SET;

typedef uinT32 CONFIG_PRUNER[NUM_PP_PARAMS][NUM_PP_BUCKETS][4];

/*
 * font_properties contains properties about boldness, italicness, fixed pitch,
 * serif, fraktur
 */
struct FontInfo {
  char*         name;
  uinT32        properties;
  bool is_italic() { return properties & 1; }
  bool is_bold() { return (properties & 2) != 0; }
  bool is_fixed_pitch() { return (properties & 4) != 0; }
  bool is_serif() { return (properties & 8) != 0; }
  bool is_fraktur() { return (properties & 16) != 0; }
};

// Every class (character) owns a FontSet that represents all the fonts that can
// render this character.
// Since almost all the characters from the same script share the same set of
// fonts, the sets are shared over multiple classes (see
// Classify::fontset_table_). Thus, a class only store an id to a set.
// Because some fonts cannot render just one character of a set, there are a
// lot of FontSet that differ only by one font. Rather than storing directly
// the FontInfo in the FontSet structure, it's better to share FontInfos among
// FontSets (Classify::fontinfo_table_).
struct FontSet {
  int           size;
  int*          configs;  // FontInfo ids
};


typedef struct
{
  uinT16 NumProtos;
  uinT8 NumProtoSets;
  uinT8 NumConfigs;
  PROTO_SET ProtoSets[MAX_NUM_PROTO_SETS];
  uinT8 *ProtoLengths;
  uinT16 ConfigLengths[MAX_NUM_CONFIGS];
  int font_set_id;  // FontSet id, see above
}INT_CLASS_STRUCT, *INT_CLASS;

typedef struct
{
  int NumClasses;
  int NumClassPruners;
  INT_CLASS Class[MAX_NUM_CLASSES];
  CLASS_PRUNER ClassPruner[MAX_NUM_CLASS_PRUNERS];
}INT_TEMPLATES_STRUCT, *INT_TEMPLATES;

/* definitions of integer features*/
#define MAX_NUM_INT_FEATURES 512
#define INT_CHAR_NORM_RANGE  256

struct INT_FEATURE_STRUCT
{
  uinT8 X;
  uinT8 Y;
  uinT8 Theta;
  inT8 CP_misses;
};
typedef INT_FEATURE_STRUCT *INT_FEATURE;
typedef INT_FEATURE_STRUCT INT_FEATURE_ARRAY[MAX_NUM_INT_FEATURES];

enum IntmatcherDebugAction {
  IDA_ADAPTIVE,
  IDA_STATIC,
  IDA_BOTH
};

/**----------------------------------------------------------------------------
            Macros
----------------------------------------------------------------------------**/

#define MaxNumIntProtosIn(C)  (C->NumProtoSets * PROTOS_PER_PROTO_SET)
#define SetForProto(P)    (P / PROTOS_PER_PROTO_SET)
#define IndexForProto(P)  (P % PROTOS_PER_PROTO_SET)
#define ProtoForProtoId(C,P)	(&((C->ProtoSets[SetForProto (P)])->	\
                    Protos [IndexForProto (P)]))
#define PPrunerWordIndexFor(I)	(((I) % PROTOS_PER_PROTO_SET) /		\
                PROTOS_PER_PP_WERD)
#define PPrunerBitIndexFor(I) ((I) % PROTOS_PER_PP_WERD)
#define PPrunerMaskFor(I) (1 << PPrunerBitIndexFor (I))

#define MaxNumClassesIn(T)    (T->NumClassPruners * CLASSES_PER_CP)
#define LegalClassId(c)   ((c) >= 0 && (c) <= MAX_CLASS_ID)
#define UnusedClassIdIn(T,c)  ((T)->Class[c] == NULL)
#define ClassForClassId(T,c) ((T)->Class[c])
#define ClassPrunersFor(T)  ((T)->ClassPruner)
#define CPrunerIdFor(c)   ((c) / CLASSES_PER_CP)
#define CPrunerFor(T,c)   ((T)->ClassPruner [CPrunerIdFor (c)])
#define CPrunerWordIndexFor(c)  (((c) % CLASSES_PER_CP) / CLASSES_PER_CP_WERD)
#define CPrunerBitIndexFor(c) (((c) % CLASSES_PER_CP) % CLASSES_PER_CP_WERD)
#define CPrunerMaskFor(L,c) (((L)+1) << CPrunerBitIndexFor (c) * NUM_BITS_PER_CLASS)

/* DEBUG macros*/
#define PRINT_MATCH_SUMMARY 0x001
#define DISPLAY_FEATURE_MATCHES 0x002
#define DISPLAY_PROTO_MATCHES 0x004
#define PRINT_FEATURE_MATCHES 0x008
#define PRINT_PROTO_MATCHES 0x010
#define CLIP_MATCH_EVIDENCE 0x020

#define MatchDebuggingOn(D)   (D)
#define PrintMatchSummaryOn(D)    ((D) & PRINT_MATCH_SUMMARY)
#define DisplayFeatureMatchesOn(D)  ((D) & DISPLAY_FEATURE_MATCHES)
#define DisplayProtoMatchesOn(D)  ((D) & DISPLAY_PROTO_MATCHES)
#define PrintFeatureMatchesOn(D)  ((D) & PRINT_FEATURE_MATCHES)
#define PrintProtoMatchesOn(D)    ((D) & PRINT_PROTO_MATCHES)
#define ClipMatchEvidenceOn(D)    ((D) & CLIP_MATCH_EVIDENCE)

/**----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------**/
void AddIntClass(INT_TEMPLATES Templates, CLASS_ID ClassId, INT_CLASS Class);

int AddIntConfig(INT_CLASS Class);

int AddIntProto(INT_CLASS Class);

void AddProtoToClassPruner(PROTO Proto,
                           CLASS_ID ClassId,
                           INT_TEMPLATES Templates);

void AddProtoToProtoPruner(PROTO Proto, int ProtoId, INT_CLASS Class);

int BucketFor(FLOAT32 Param, FLOAT32 Offset, int NumBuckets);

int CircBucketFor(FLOAT32 Param, FLOAT32 Offset, int NumBuckets);

void UpdateMatchDisplay();

void ConvertConfig(BIT_VECTOR Config, int ConfigId, INT_CLASS Class);

void ConvertProto(PROTO Proto, int ProtoId, INT_CLASS Class);

void DisplayIntFeature(INT_FEATURE Feature, FLOAT32 Evidence);

void DisplayIntProto(INT_CLASS Class, PROTO_ID ProtoId, FLOAT32 Evidence);

INT_CLASS NewIntClass(int MaxNumProtos, int MaxNumConfigs);

INT_TEMPLATES NewIntTemplates();

void free_int_templates(INT_TEMPLATES templates);

void ShowMatchDisplay();

/*----------------------------------------------------------------------------*/

void InitIntMatchWindowIfReqd();

void InitProtoDisplayWindowIfReqd();

void InitFeatureDisplayWindowIfReqd();
/////////////////////////////////////////////////////////////////intproto////////////////////////////////////////

/////////////////////////////////////////////////////////////////picofeat////////////////////////////////////////
typedef enum
{ PicoFeatY, PicoFeatDir, PicoFeatX }
PICO_FEAT_PARAM_NAME;

#define MAX_PICO_FEATURES (1000)

/*---------------------------------------------------------------------------
          Variables
----------------------------------------------------------------------------*/

extern double_VAR_H(classify_pico_feature_length, 0.05, "Pico Feature Length");


/**----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------**/
#define GetPicoFeatureLength()  (PicoFeatureLength)

FEATURE_SET ExtractPicoFeatures(TBLOB *Blob, LINE_STATS *LineStats);

/**----------------------------------------------------------------------------
        Global Data Definitions and Declarations
----------------------------------------------------------------------------**/
extern FEATURE_DESC_STRUCT PicoFeatDesc;
extern FLOAT32 PicoFeatureLength;
/////////////////////////////////////////////////////////////////picofeat////////////////////////////////////////

/////////////////////////////////////////////////////////////////intfx////////////////////////////////////////
typedef struct
{
  inT32 Length;                  /* total length of all outlines   */
  inT16 Xmean, Ymean;            /* center of mass of all outlines */
  inT16 Rx, Ry;                  /* radius of gyration             */
  inT16 NumBL, NumCN;            /* number of features extracted   */
}INT_FX_RESULT_STRUCT, *INT_FX_RESULT;

/**----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------**/
void InitIntegerFX();

int ExtractIntFeat(TBLOB *Blob,
                   INT_FEATURE_ARRAY BLFeat,
                   INT_FEATURE_ARRAY CNFeat,
                   INT_FX_RESULT Results);

uinT8 TableLookup(inT32 Y, inT32 X);

int SaveFeature(INT_FEATURE_ARRAY FeatureArray,
                uinT16 FeatureNum,
                inT16 X,
                inT16 Y,
                uinT8 Theta);

uinT16 MySqrt(inT32 X, inT32 Y);

uinT8 MySqrt2(uinT16 N, uinT32 I, uinT8 *Exp);

void ClipRadius(uinT8 *RxInv, uinT8 *RxExp, uinT8 *RyInv, uinT8 *RyExp);
/////////////////////////////////////////////////////////////////intfx////////////////////////////////////////

/////////////////////////////////////////////////////////////////speckle////////////////////////////////////////
/** macro for getting the height of a row of text */
#define RowHeight(R)	((classify_baseline_normalized)?			\
            (BASELINE_SCALE):				\
            ((R)->lineheight))

/*-----------------------------------------------------------------------------
          Public Function Prototypes
-----------------------------------------------------------------------------*/
void AddLargeSpeckleTo(BLOB_CHOICE_LIST *Choices);

BOOL8 LargeSpeckle(TBLOB *Blob, TEXTROW *Row);
/////////////////////////////////////////////////////////////////speckle////////////////////////////////////////

/////////////////////////////////////////////////////////////////outfeat////////////////////////////////////////
typedef enum {
  OutlineFeatX,
  OutlineFeatY,
  OutlineFeatLength,
  OutlineFeatDir
} OUTLINE_FEAT_PARAM_NAME;

#define MAX_OUTLINE_FEATURES  (100)
/**----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------**/
FEATURE_SET ExtractOutlineFeatures(TBLOB *Blob, LINE_STATS *LineStats);

/*---------------------------------------------------------------------------
          Privat Function Prototypes
----------------------------------------------------------------------------*/
void AddOutlineFeatureToSet(FPOINT *Start,
                            FPOINT *End,
                            FEATURE_SET FeatureSet);

void ConvertToOutlineFeatures(MFOUTLINE Outline, FEATURE_SET FeatureSet);

void NormalizeOutlineX(FEATURE_SET FeatureSet);

/**----------------------------------------------------------------------------
        Global Data Definitions and Declarations
----------------------------------------------------------------------------**/
extern FEATURE_DESC_STRUCT OutlineFeatDesc;
/////////////////////////////////////////////////////////////////outfeat////////////////////////////////////////

/////////////////////////////////////////////////////////////////adaptmatch////////////////////////////////////////
extern double_VAR_H(matcher_good_threshold, 0.125, "Good Match (0-1)");
extern double_VAR_H(matcher_great_threshold, 0.0, "Great Match (0-1)");
extern INT_VAR_H(matcher_failed_adaptations_before_reset, 150,
                 "Number of failed adaptions before adapted templates reset");
extern INT_VAR_H(matcher_min_examples_for_prototyping, 2,
               "Reliable Config Threshold");
extern BOOL_VAR_H(tess_cn_matching, 0, "Character Normalized Matching");
extern BOOL_VAR_H(tess_bn_matching, 0, "Baseline Normalized Matching");
extern INT_VAR_H(classify_learning_debug_level, 0, "Learning Debug Level: ");

/*-----------------------------------------------------------------------------
          Public Function Prototypes
-----------------------------------------------------------------------------*/
int GetAdaptiveFeatures(TBLOB *Blob, LINE_STATS *LineStats, INT_FEATURE_ARRAY IntFeatures, FEATURE_SET *FloatFeatures);
/////////////////////////////////////////////////////////////////adaptmatch////////////////////////////////////////

/////////////////////////////////////////////////////////////////adaptive////////////////////////////////////////
typedef struct
{
    uinT16 ProtoId;
    uinT16 dummy;
    PROTO_STRUCT Proto;
}


TEMP_PROTO_STRUCT;
typedef TEMP_PROTO_STRUCT *TEMP_PROTO;

typedef struct
{
    uinT8 NumTimesSeen;
    uinT8 ProtoVectorSize;
    PROTO_ID MaxProtoId;
    LIST ContextsSeen;
    BIT_VECTOR Protos;
} TEMP_CONFIG_STRUCT;
typedef TEMP_CONFIG_STRUCT *TEMP_CONFIG;

typedef UNICHAR_ID *PERM_CONFIG;

typedef union
{
    TEMP_CONFIG Temp;
    PERM_CONFIG Perm;
} ADAPTED_CONFIG;

typedef struct
{
    uinT8 NumPermConfigs;
    uinT8 dummy[3];
    BIT_VECTOR PermProtos;
    BIT_VECTOR PermConfigs;
    LIST TempProtos;
    ADAPTED_CONFIG Config[MAX_NUM_CONFIGS];
} ADAPT_CLASS_STRUCT;
typedef ADAPT_CLASS_STRUCT *ADAPT_CLASS;

typedef struct
{
    INT_TEMPLATES Templates;
    int NumNonEmptyClasses;
    uinT8 NumPermClasses;
    uinT8 dummy[3];
    ADAPT_CLASS Class[MAX_NUM_CLASSES];
} ADAPT_TEMPLATES_STRUCT;
typedef ADAPT_TEMPLATES_STRUCT *ADAPT_TEMPLATES;

/*----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------*/
#define NumNonEmptyClassesIn(Template) ((Template)->NumNonEmptyClasses)

#define IsEmptyAdaptedClass(Class) ((Class)->NumPermConfigs == 0 &&      \
    (Class)->TempProtos == NIL)

#define ConfigIsPermanent(Class,ConfigId)		\
 (test_bit ((Class)->PermConfigs, ConfigId))

#define MakeConfigPermanent(Class,ConfigId)	\
    (SET_BIT ((Class)->PermConfigs, ConfigId))

#define MakeProtoPermanent(Class,ProtoId)	\
    (SET_BIT ((Class)->PermProtos, ProtoId))

#define TempConfigFor(Class,ConfigId)	\
    ((Class)->Config[ConfigId].Temp)

#define PermConfigFor(Class,ConfigId)	\
    ((Class)->Config[ConfigId].Perm)

#define IncreaseConfidence(TempConfig)	\
    ((TempConfig)->NumTimesSeen++)

void AddAdaptedClass(ADAPT_TEMPLATES Templates, ADAPT_CLASS Class, CLASS_ID ClassId);

void FreeTempProto(void *arg);

void FreeTempConfig(TEMP_CONFIG Config);

ADAPT_CLASS NewAdaptedClass();

void free_adapted_class(ADAPT_CLASS adapt_class);

void free_adapted_templates(ADAPT_TEMPLATES templates);

TEMP_CONFIG NewTempConfig(int MaxProtoId);

TEMP_PROTO NewTempProto();

ADAPT_CLASS ReadAdaptedClass(FILE *File);

PERM_CONFIG ReadPermConfig(FILE *File);

TEMP_CONFIG ReadTempConfig(FILE *File);

void WriteAdaptedClass(FILE *File, ADAPT_CLASS Class, int NumConfigs);

void WritePermConfig(FILE *File, PERM_CONFIG Config);

void WriteTempConfig(FILE *File, TEMP_CONFIG Config);
/////////////////////////////////////////////////////////////////adaptive////////////////////////////////////////

/////////////////////////////////////////////////////////////////intmatcher////////////////////////////////////////
// Character fragments could be present in the trained templaes
// but turned on/off on the language-by-language basis or depending
// on particular properties of the corpus (e.g. when we expect the
// images to have low exposure).
extern BOOL_VAR_H(disable_character_fragments, FALSE,
                  "Do not include character fragments in the"
                  " results of the classifier");

extern INT_VAR_H(classify_integer_matcher_multiplier, 14,
                 "Integer Matcher Multiplier  0-255:   ");


/**----------------------------------------------------------------------------
          Include Files and Type Defines
----------------------------------------------------------------------------**/

typedef struct
{
  FLOAT32 Rating;
  uinT8 Config;
  uinT8 Config2;
  uinT16 FeatureMisses;
}


INT_RESULT_STRUCT, *INT_RESULT;

typedef struct
{
  FLOAT32 Rating;
  INT_RESULT_STRUCT IMResult;
  CLASS_ID Class;
}


CP_RESULT_STRUCT;

/*typedef CLASS_ID CLASS_PRUNER_RESULTS [MAX_NUM_CLASSES];	*/
typedef CP_RESULT_STRUCT CLASS_PRUNER_RESULTS[MAX_NUM_CLASSES];

typedef uinT8 CLASS_NORMALIZATION_ARRAY[MAX_NUM_CLASSES];

/*----------------------------------------------------------------------------
            Variables
-----------------------------------------------------------------------------*/

extern INT_VAR_H(classify_adapt_proto_thresh, 230,
                 "Threshold for good protos during adaptive 0-255:   ");

extern INT_VAR_H(classify_adapt_feature_thresh, 230,
                 "Threshold for good features during adaptive 0-255:   ");

/**----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------**/

void IntegerMatcher(INT_CLASS ClassTemplate,
                    BIT_VECTOR ProtoMask,
                    BIT_VECTOR ConfigMask,
                    uinT16 BlobLength,
                    inT16 NumFeatures,
                    INT_FEATURE_ARRAY Features,
                    uinT8 NormalizationFactor,
                    INT_RESULT Result,
                    int Debug);

int FindGoodProtos(INT_CLASS ClassTemplate,
                   BIT_VECTOR ProtoMask,
                   BIT_VECTOR ConfigMask,
                   uinT16 BlobLength,
                   inT16 NumFeatures,
                   INT_FEATURE_ARRAY Features,
                   PROTO_ID *ProtoArray,
                   int Debug);

int FindBadFeatures(INT_CLASS ClassTemplate,
                    BIT_VECTOR ProtoMask,
                    BIT_VECTOR ConfigMask,
                    uinT16 BlobLength,
                    inT16 NumFeatures,
                    INT_FEATURE_ARRAY Features,
                    FEATURE_ID *FeatureArray,
                    int Debug);

void InitIntegerMatcher();

void PrintIntMatcherStats(FILE *f);

void SetProtoThresh(FLOAT32 Threshold);

void SetFeatureThresh(FLOAT32 Threshold);

void SetBaseLineMatch();

void SetCharNormMatch();

/**----------------------------------------------------------------------------
          Private Function Prototypes
----------------------------------------------------------------------------**/
void IMClearTables (INT_CLASS ClassTemplate,
int SumOfFeatureEvidence[MAX_NUM_CONFIGS],
uinT8 ProtoEvidence[MAX_NUM_PROTOS][MAX_PROTO_INDEX]);

void IMClearFeatureEvidenceTable (uinT8 FeatureEvidence[MAX_NUM_CONFIGS],
int NumConfigs);

void IMDebugConfiguration(INT_FEATURE FeatureNum,
                          uinT16 ActualProtoNum,
                          uinT8 Evidence,
                          BIT_VECTOR ConfigMask,
                          uinT32 ConfigWord);

void IMDebugConfigurationSum(INT_FEATURE FeatureNum,
                             uinT8 *FeatureEvidence,
                             inT32 ConfigCount);

int IMUpdateTablesForFeature (INT_CLASS ClassTemplate,
BIT_VECTOR ProtoMask,
BIT_VECTOR ConfigMask,
int FeatureNum,
INT_FEATURE Feature,
uinT8 FeatureEvidence[MAX_NUM_CONFIGS],
int SumOfFeatureEvidence[MAX_NUM_CONFIGS],
uinT8
ProtoEvidence[MAX_NUM_PROTOS][MAX_PROTO_INDEX],
int Debug);

#ifndef GRAPHICS_DISABLED
void IMDebugFeatureProtoError (INT_CLASS ClassTemplate,
BIT_VECTOR ProtoMask,
BIT_VECTOR ConfigMask,
int SumOfFeatureEvidence[MAX_NUM_CONFIGS],
uinT8
ProtoEvidence[MAX_NUM_PROTOS][MAX_PROTO_INDEX],
inT16 NumFeatures, int Debug);

void IMDisplayProtoDebugInfo (INT_CLASS ClassTemplate,
BIT_VECTOR ProtoMask,
BIT_VECTOR ConfigMask,
uinT8
ProtoEvidence[MAX_NUM_PROTOS][MAX_PROTO_INDEX],
int Debug);

void IMDisplayFeatureDebugInfo(INT_CLASS ClassTemplate,
                               BIT_VECTOR ProtoMask,
                               BIT_VECTOR ConfigMask,
                               inT16 NumFeatures,
                               INT_FEATURE_ARRAY Features,
                               int Debug);
#endif

void IMUpdateSumOfProtoEvidences (INT_CLASS ClassTemplate,
BIT_VECTOR ConfigMask,
int SumOfFeatureEvidence[MAX_NUM_CONFIGS],
uinT8
ProtoEvidence[MAX_NUM_PROTOS]
[MAX_PROTO_INDEX], inT16 NumFeatures);

void IMNormalizeSumOfEvidences (INT_CLASS ClassTemplate,
int SumOfFeatureEvidence[MAX_NUM_CONFIGS],
inT16 NumFeatures, inT32 used_features);

int IMFindBestMatch (INT_CLASS ClassTemplate,
int SumOfFeatureEvidence[MAX_NUM_CONFIGS],
uinT16 BlobLength,
uinT8 NormalizationFactor, INT_RESULT Result);

#ifndef GRAPHICS_DISABLED
void IMDebugBestMatch(int BestMatch,
                      INT_RESULT Result,
                      uinT16 BlobLength,
                      uinT8 NormalizationFactor);
#endif

void HeapSort (int n, register int ra[], register int rb[]);

/**----------------------------------------------------------------------------
        Global Data Definitions and Declarations
----------------------------------------------------------------------------**/
extern uinT32 EvidenceMultMask;
/////////////////////////////////////////////////////////////////intmatcher////////////////////////////////////////

/////////////////////////////////////////////////////////////////normmatch////////////////////////////////////////
/**----------------------------------------------------------------------------
        Variables
----------------------------------------------------------------------------**/

/* control knobs used to control the normalization adjustment process */
extern double_VAR_H(classify_norm_adj_midpoint, 32.0,
                    "Norm adjust midpoint ...");
extern double_VAR_H(classify_norm_adj_curl, 2.0, "Norm adjust curl ...");
/////////////////////////////////////////////////////////////////normmatch////////////////////////////////////////

/////////////////////////////////////////////////////////////////float2int////////////////////////////////////////
#define INT_FEAT_RANGE    256
#define BASELINE_Y_SHIFT  (0.25)

/*-----------------------------------------------------------------------------
          Public Function Prototypes
-----------------------------------------------------------------------------*/
void ClearCharNormArray(INT_TEMPLATES Templates, CLASS_NORMALIZATION_ARRAY CharNormArray);

void ComputeIntFeatures(FEATURE_SET Features, INT_FEATURE_ARRAY IntFeatures);
/////////////////////////////////////////////////////////////////float2int////////////////////////////////////////

/////////////////////////////////////////////////////////////////normfeat////////////////////////////////////////
#define LENGTH_COMPRESSION  (10.0)

typedef enum
{ CharNormY, CharNormLength, CharNormRx, CharNormRy }
NORM_PARAM_NAME;

/**----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------**/
FLOAT32 ActualOutlineLength(FEATURE Feature);

FEATURE_SET ExtractCharNormFeatures(TBLOB *Blob, LINE_STATS *LineStats);

/*
#if defined(__STDC__) || defined(__cplusplus)
# define        _ARGS(s) s
#else
# define        _ARGS(s) ()
#endif*/

/* normfeat.c
FLOAT32 ActualOutlineLength
    _ARGS((FEATURE Feature));

FEATURE_SET ExtractCharNormFeatures
    _ARGS((BLOB *Blob,
  LINE_STATS *LineStats));

#undef _ARGS
*/

/**----------------------------------------------------------------------------
        Global Data Definitions and Declarations
----------------------------------------------------------------------------**/
extern FEATURE_DESC_STRUCT CharNormDesc;
/////////////////////////////////////////////////////////////////normfeat////////////////////////////////////////

/////////////////////////////////////////////////////////////////mfdefs////////////////////////////////////////
/* maximum size of a bulge for length=1 is sqrt(2)/3 */
#define BULGENORMALIZER   0.942809041

/* definition of a list of micro-features */
typedef LIST MICROFEATURES;

/* definition of structure of micro-features */
#define MFSIZE        6
typedef FLOAT32 MFBLOCK[MFSIZE];
typedef FLOAT32 *MICROFEATURE;

/* definitions of individual micro-feature parameters */
#define XPOSITION     0
#define YPOSITION     1
#define MFLENGTH      2
#define ORIENTATION     3
#define FIRSTBULGE      4
#define SECONDBULGE     5

/**----------------------------------------------------------------------------
            Macros
----------------------------------------------------------------------------**/

/* macros for accessing micro-feature lists */
#define NextFeatureOf(L)  ( (MICROFEATURE) first_node ( L ) )

/**----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------**/
MICROFEATURE NewMicroFeature();

void FreeMicroFeatures(MICROFEATURES MicroFeatures);
/////////////////////////////////////////////////////////////////mfdefs////////////////////////////////////////

/////////////////////////////////////////////////////////////////xform2d////////////////////////////////////////
typedef struct
{
  FLOAT32 a, b, c, d, tx, ty;
}MATRIX_2D, *MATRIX_2D_PTR;

/**----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------**/

void InitMatrix(MATRIX_2D *M);
void CopyMatrix(MATRIX_2D *A, MATRIX_2D *B);

/* matrix scaling, translation, rotation, mirroring, etc.*/
void TranslateMatrix(MATRIX_2D *M, FLOAT32 X, FLOAT32 Y);
void ScaleMatrix(MATRIX_2D *M, FLOAT32 X, FLOAT32 Y);

void MirrorMatrixInX(MATRIX_2D *M);
void MirrorMatrixInY(MATRIX_2D *M);
void MirrorMatrixInXY(MATRIX_2D *M);

/* using a matrix to map points*/
FLOAT32 MapX(MATRIX_2D *M, FLOAT32 X, FLOAT32 Y);

FLOAT32 MapY(MATRIX_2D *M, FLOAT32 X, FLOAT32 Y);

void MapPoint(MATRIX_2D *M, const FPOINT &A, FPOINT* B);

FLOAT32 MapDx(MATRIX_2D *M, FLOAT32 DX, FLOAT32 DY);
FLOAT32 MapDy(MATRIX_2D M, FLOAT32 DX, FLOAT32 DY);

void RotateMatrix(MATRIX_2D_PTR Matrix, FLOAT32 Angle);
/////////////////////////////////////////////////////////////////xform2d////////////////////////////////////////

/////////////////////////////////////////////////////////////////mfx////////////////////////////////////////
/* old numbers corresponded to 10.0 degrees and 80.0 degrees */
extern double_VAR_H(classify_min_slope, 0.414213562,
                    "Slope below which lines are called horizontal");
extern double_VAR_H(classify_max_slope, 2.414213562,
                    "Slope above which lines are called vertical");
extern double_VAR_H(classify_noise_segment_length, 0.00,
                    "Length below which outline segments"
                    "are treated as noise");

/**----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------**/
CHAR_FEATURES BlobMicroFeatures(TBLOB *Blob, LINE_STATS *LineStats);
/////////////////////////////////////////////////////////////////mfx////////////////////////////////////////

/////////////////////////////////////////////////////////////////mf////////////////////////////////////////
typedef enum {
  MFXPosition, MFYPosition,
  MFLength, MFDirection, MFBulge1, MFBulge2
} MF_PARAM_NAME;
/*----------------------------------------------------------------------------
          Private Function Prototypes
-----------------------------------------------------------------------------*/
FEATURE_SET ExtractMicros(TBLOB *Blob, LINE_STATS *LineStats);

/**----------------------------------------------------------------------------
        Global Data Definitions and Declarations
----------------------------------------------------------------------------**/
extern FEATURE_DESC_STRUCT MicroFeatureDesc;
/////////////////////////////////////////////////////////////////mf////////////////////////////////////////

/////////////////////////////////////////////////////////////////featdefs////////////////////////////////////////
/* Enumerate the different types of features currently defined. */
#define NUM_FEATURE_TYPES 4

/* define error traps which can be triggered by this module.*/
#define ILLEGAL_SHORT_NAME  2000

/* A character is described by multiple sets of extracted features.  Each
  set contains a number of features of a particular type, for example, a
  set of bays, or a set of closures, or a set of microfeatures.  Each
  feature consists of a number of parameters.  All features within a
  feature set contain the same number of parameters.*/
typedef FEATURE (*FEAT_FUNC) ();
typedef FEATURE_SET (*FX_FUNC) (TBLOB *, LINE_STATS *);
typedef FLOAT32 (*PENALTY_FUNC) ();
                                 /* one per feature type */

typedef struct fxs
{
  FX_FUNC Extractor;             /* func to extract features */
} FEATURE_EXT_STRUCT;

typedef struct
{
  uinT32 NumFeatureSets;
  FEATURE_SET FeatureSets[NUM_FEATURE_TYPES];
} CHAR_DESC_STRUCT;
typedef CHAR_DESC_STRUCT *CHAR_DESC;

typedef struct
{
  uinT32 NumFeatureTypes;
  FEATURE_DESC FeatureDesc[NUM_FEATURE_TYPES];
  FEATURE_EXT_STRUCT* FeatureExtractors[NUM_FEATURE_TYPES];
  int FeatureEnabled[NUM_FEATURE_TYPES];
} FEATURE_DEFS_STRUCT;
typedef FEATURE_DEFS_STRUCT *FEATURE_DEFS;

/*----------------------------------------------------------------------
    Generic functions for manipulating character descriptions
----------------------------------------------------------------------*/
void FreeCharDescription(CHAR_DESC CharDesc);

CHAR_DESC NewCharDescription();

void WriteCharDescription(FILE *File, CHAR_DESC CharDesc);

CHAR_DESC ReadCharDescription(FILE *File);

int ShortNameToFeatureType(const char *ShortName);

/**----------------------------------------------------------------------------
        Global Data Definitions and Declarations
----------------------------------------------------------------------------**/
extern FEATURE_DEFS_STRUCT FeatureDefs;
/////////////////////////////////////////////////////////////////featdefs////////////////////////////////////////

/////////////////////////////////////////////////////////////////fxdefs////////////////////////////////////////
/* define different modes for feature extractor - learning vs. classifying */

/** define a generic character description as a char pointer.  In reality,
  it will be a pointer to some data structure.  Paired feature
  extractors/matchers need to agree on the data structure to be used,
  however, the high level classifier does not need to know the details
  of this data structure. */


/*-----------------------------------------------------------------------------
            Macros
-----------------------------------------------------------------------------*/
/** macro to change and monitor the mode of the feature extractor.
  In general, learn mode smears features which would otherwise be discrete
  in nature; classify mode does not.*/
#define SetExtractMode(M) (ExtractMode = (M))
#define EnterLearnMode    (SetExtractMode (LEARN_MODE))
#define EnterClassifyMode (SetExtractMode (CLASSIFY_MODE))

/*----------------------------------------------------------------------------
          Public Function Prototypes
-----------------------------------------------------------------------------*/
void SetupExtractors();

void GetLineStatsFromRow(TEXTROW *Row, LINE_STATS *LineStats);

/*
#if defined(__STDC__) || defined(__cplusplus)
# define        _ARGS(s) s
#else
# define        _ARGS(s) ()
#endif*/

/* fxdefs.c
void GetLineStatsFromRow
    _ARGS((TEXTROW *Row,
  LINE_STATS *LineStats));

#undef _ARGS
*/

/*-----------------------------------------------------------------------------
        Global Data Definitions and Declarations
-----------------------------------------------------------------------------*/
/** flag to control learn mode vs. classify mode */
extern int ExtractMode;
/////////////////////////////////////////////////////////////////fxdefs////////////////////////////////////////

/////////////////////////////////////////////////////////////////ocrfeatures////////////////////////////////////////
/* A character is described by multiple sets of extracted features.  Each
  set contains a number of features of a particular type, for example, a
  set of bays, or a set of closures, or a set of microfeatures.  Each
  feature consists of a number of parameters.  All features within a
  feature set contain the same number of parameters.  All circular
  parameters are required to be the first parameters in the feature.*/

/* Define various function types which will be needed for "class methods"*/

/*----------------------------------------------------------------------
    Macros for defining the parameters of a new features
----------------------------------------------------------------------*/
#define StartParamDesc(Name)	\
static PARAM_DESC Name[] = {

#define DefineParam(Circular, NonEssential, Min, Max)	\
    {Circular, NonEssential, Min, Max,			\
    (Max) - (Min), (((Max) - (Min))/2.0), (((Max) + (Min))/2.0)},

#define EndParamDesc  };

/*----------------------------------------------------------------------
Macro for describing a new feature.  The parameters of the macro
are as follows:

DefineFeature (Name, NumLinear, NumCircular,
          MinFeatPerChar, MaxFeatPerChar,
          LongName, ShortName, ParamName)
----------------------------------------------------------------------*/
#define DefineFeature(Name, NL, NC, Min, Max, LN, SN, PN)		\
FEATURE_DESC_STRUCT Name = {						\
    ((NL) + (NC)), NL, NC, Min, Max, LN, SN, PN};

#define DefineFeatureExt(Name, E) FEATURE_EXT_STRUCT Name = {E};

/*----------------------------------------------------------------------
        Generic routines that work for all feature types
----------------------------------------------------------------------*/
BOOL8 AddFeature(FEATURE_SET FeatureSet, FEATURE Feature);

void FreeFeature(FEATURE Feature);

void FreeFeatureSet(FEATURE_SET FeatureSet);

FEATURE NewFeature(FEATURE_DESC FeatureDesc);

FEATURE_SET NewFeatureSet(int NumFeatures);

FEATURE ReadFeature(FILE *File, FEATURE_DESC FeatureDesc);

FEATURE_SET ReadFeatureSet(FILE *File, FEATURE_DESC FeatureDesc);

void WriteFeature(FILE *File, FEATURE Feature);

void WriteFeatureSet(FILE *File, FEATURE_SET FeatureSet);

void WriteOldParamDesc(FILE *File, FEATURE_DESC FeatureDesc);
/////////////////////////////////////////////////////////////////ocrfeatures////////////////////////////////////////

/////////////////////////////////////////////////////////////////classify////////////////////////////////////////
class WERD_CHOICE;
struct ADAPT_RESULTS;
struct NORM_PROTOS;

class Classify : public CCStruct {
 public:
  Classify();
  ~Classify();
  DictT& getDict() {
    return dict_;
  }
  /* adaptive.cpp ************************************************************/
  ADAPT_TEMPLATES NewAdaptedTemplates(bool InitFromUnicharset);
  int ClassPruner(INT_TEMPLATES IntTemplates,
                            inT16 NumFeatures,
                            INT_FEATURE_ARRAY Features,
                            CLASS_NORMALIZATION_ARRAY NormalizationFactors,
                            CLASS_CUTOFF_ARRAY ExpectedNumFeatures,
                            CLASS_PRUNER_RESULTS Results,
                            int Debug);
  void ReadNewCutoffs(FILE *CutoffFile, inT64 end_offset,
                      CLASS_CUTOFF_ARRAY Cutoffs);
  void PrintAdaptedTemplates(FILE *File, ADAPT_TEMPLATES Templates);
  void WriteAdaptedTemplates(FILE *File, ADAPT_TEMPLATES Templates);
  ADAPT_TEMPLATES ReadAdaptedTemplates(FILE *File);
  /* normmatch.cpp ************************************************************/
  FLOAT32 ComputeNormMatch(CLASS_ID ClassId, FEATURE Feature, BOOL8 DebugMatch);
  void FreeNormProtos();
  NORM_PROTOS *ReadNormProtos(FILE *File, inT64 end_offset);
  /* protos.cpp ***************************************************************/
  void ReadClassFile();
  INT_TEMPLATES
      CreateIntTemplates(CLASSES FloatProtos,
                         const UNICHARSET& target_unicharset);
  /* adaptmatch.cpp ***********************************************************/
  void AdaptToWord(TWERD *Word,
                   TEXTROW *Row,
                   const WERD_CHOICE& BestChoice,
                   const WERD_CHOICE& BestRawChoice,
                   const char *rejmap);
  void InitAdaptiveClassifier();
  void InitAdaptedClass(TBLOB *Blob,
                        LINE_STATS *LineStats,
                        CLASS_ID ClassId,
                        ADAPT_CLASS Class,
                        ADAPT_TEMPLATES Templates);
  void AdaptToPunc(TBLOB *Blob,
                   LINE_STATS *LineStats,
                   CLASS_ID ClassId,
                   FLOAT32 Threshold);
  void AmbigClassifier(TBLOB *Blob,
                       LINE_STATS *LineStats,
                       INT_TEMPLATES Templates,
                       int *Ambiguities,
                       ADAPT_RESULTS *Results);
  void MasterMatcher(INT_TEMPLATES templates,
                     inT16 num_features,
                     INT_FEATURE_ARRAY features,
                     CLASS_NORMALIZATION_ARRAY norm_factors,
                     ADAPT_CLASS* classes,
                     int debug,
                     int num_classes,
                     CLASS_PRUNER_RESULTS results,
                     ADAPT_RESULTS* final_results);
  void ConvertMatchesToChoices(ADAPT_RESULTS *Results,
                               BLOB_CHOICE_LIST *Choices);
  void AddNewResult(ADAPT_RESULTS *Results,
                    CLASS_ID ClassId,
                    FLOAT32 Rating,
                    int ConfigId);
#ifndef GRAPHICS_DISABLED
  void DebugAdaptiveClassifier(TBLOB *Blob,
                               LINE_STATS *LineStats,
                               ADAPT_RESULTS *Results);
#endif
  void GetAdaptThresholds (TWERD * Word,
                           LINE_STATS * LineStats,
                           const WERD_CHOICE& BestChoice,
                           const WERD_CHOICE& BestRawChoice,
                           FLOAT32 Thresholds[]);

  int MakeNewTemporaryConfig(ADAPT_TEMPLATES Templates,
                             CLASS_ID ClassId,
                             int NumFeatures,
                             INT_FEATURE_ARRAY Features,
                             FEATURE_SET FloatFeatures);
  void MakePermanent(ADAPT_TEMPLATES Templates,
                     CLASS_ID ClassId,
                     int ConfigId,
                     TBLOB *Blob,
                     LINE_STATS *LineStats);
  void PrintAdaptiveMatchResults(FILE *File, ADAPT_RESULTS *Results);
  void RemoveExtraPuncs(ADAPT_RESULTS *Results);
  void RemoveBadMatches(ADAPT_RESULTS *Results);
  void ShowBestMatchFor(TBLOB *Blob,
                        LINE_STATS *LineStats,
                        CLASS_ID ClassId,
                        BOOL8 AdaptiveOn,
                        BOOL8 PreTrainedOn);
  int *BaselineClassifier(TBLOB *Blob,
                                 LINE_STATS *LineStats,
                                 ADAPT_TEMPLATES Templates,
                                 ADAPT_RESULTS *Results);
  int CharNormClassifier(TBLOB *Blob,
                         LINE_STATS *LineStats,
                         INT_TEMPLATES Templates,
                         ADAPT_RESULTS *Results);
  int *GetAmbiguities(TBLOB *Blob,
                             LINE_STATS *LineStats,
                             CLASS_ID CorrectClass);
  void DoAdaptiveMatch(TBLOB *Blob,
                       LINE_STATS *LineStats,
                       ADAPT_RESULTS *Results);
  void AdaptToChar(TBLOB *Blob,
                   LINE_STATS *LineStats,
                   CLASS_ID ClassId,
                   FLOAT32 Threshold);
  int AdaptableWord(TWERD *Word,
                  const WERD_CHOICE &BestChoiceWord,
                  const WERD_CHOICE &RawChoiceWord);
  void EndAdaptiveClassifier();
  void PrintAdaptiveStatistics(FILE *File);
  void SettupPass1();
  void SettupPass2();
  void AdaptiveClassifier(TBLOB *Blob,
                          TBLOB *DotBlob,
                          TEXTROW *Row,
                          BLOB_CHOICE_LIST *Choices,
                          CLASS_PRUNER_RESULTS cp_results);
  void ClassifyAsNoise(ADAPT_RESULTS *Results);
  void ResetAdaptiveClassifier();

  FLOAT32 GetBestRatingFor(TBLOB *Blob,
                           LINE_STATS *LineStats,
                           CLASS_ID ClassId);
  int GetCharNormFeatures(TBLOB *Blob,
                          LINE_STATS *LineStats,
                          INT_TEMPLATES Templates,
                          INT_FEATURE_ARRAY IntFeatures,
                          CLASS_NORMALIZATION_ARRAY CharNormArray,
                          inT32 *BlobLength);
  int GetIntCharNormFeatures(TBLOB *Blob,
                             LINE_STATS *LineStats,
                             INT_TEMPLATES Templates,
                             INT_FEATURE_ARRAY IntFeatures,
                             CLASS_NORMALIZATION_ARRAY CharNormArray,
                             inT32 *BlobLength);

  /* float2int.cpp ************************************************************/
  void ComputeIntCharNormArray(FEATURE NormFeature,
                               INT_TEMPLATES Templates,
                               CLASS_NORMALIZATION_ARRAY CharNormArray);
  /* intproto.cpp *************************************************************/
  INT_TEMPLATES ReadIntTemplates(FILE *File);
  void WriteIntTemplates(FILE *File, INT_TEMPLATES Templates,
                         const UNICHARSET& target_unicharset);
  CLASS_ID GetClassToDebug(const char *Prompt);
  /* font detection ***********************************************************/
  UnicityTable<FontInfo>& get_fontinfo_table() {
    return fontinfo_table_;
  }
  UnicityTable<FontSet>& get_fontset_table() {
    return fontset_table_;
  }
  /* adaptmatch.cpp ***********************************************************/
  /* name of current image file being processed */
  INT_VAR_H(tessedit_single_match, FALSE, "Top choice only from CP");
  /* use class variables to hold onto built-in templates and adapted
     templates */
  INT_TEMPLATES PreTrainedTemplates;
  ADAPT_TEMPLATES AdaptedTemplates;
  // Successful load of inttemp allows base tesseract classfier to be used.
  bool inttemp_loaded_;

  /* create dummy proto and config masks for use with the built-in templates */
  BIT_VECTOR AllProtosOn;
  BIT_VECTOR PrunedProtos;
  BIT_VECTOR AllConfigsOn;
  BIT_VECTOR AllProtosOff;
  BIT_VECTOR AllConfigsOff;
  BIT_VECTOR TempProtoMask;
  // External control of adaption.
  BOOL_VAR_H(classify_enable_learning, true, "Enable adaptive classifier");
  // Internal control of Adaption so it doesn't work on pass2.
  BOOL_VAR_H(classify_recog_devanagari, false,
             "Whether recognizing a language with devanagari script.");
  bool EnableLearning;
  /* normmatch.cpp */
  NORM_PROTOS *NormProtos;
  /* font detection ***********************************************************/
  UnicityTable<FontInfo> fontinfo_table_;
  UnicityTable<FontSet> fontset_table_;
 private:
  DictT dict_;
};
/////////////////////////////////////////////////////////////////classify////////////////////////////////////////

/////////////////////////////////////////////////////////////////split////////////////////////////////////////
/*----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------*/
typedef struct split_record
{                                /*  SPLIT  */
  EDGEPT *point1;
  EDGEPT *point2;
} SPLIT;

typedef LIST SPLITS;             /*  SPLITS  */

/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/

extern BOOL_VAR_H(wordrec_display_splits, 0, "Display splits");

/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
/**********************************************************************
 * clone_split
 *
 * Create a new split record and set the contents equal to the contents
 * of this record.
 **********************************************************************/

#define clone_split(dest,source)                               \
if (source)                                                  \
    (dest) = new_split ((source)->point1, (source)->point2);  \
else                                                         \
    (dest) = (SPLIT*) NULL                                    \


/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
void delete_split(SPLIT *split);

EDGEPT *make_edgept(int x, int y, EDGEPT *next, EDGEPT *prev);

SPLIT *new_split(EDGEPT *point1, EDGEPT *point2);

void print_split(SPLIT *split);

void split_outline(EDGEPT *join_point1, EDGEPT *join_point2);

void unsplit_outlines(EDGEPT *p1, EDGEPT *p2);
/////////////////////////////////////////////////////////////////split////////////////////////////////////////

/////////////////////////////////////////////////////////////////olutil////////////////////////////////////////
/**********************************************************************
 * is_inside_angle
 *
 * Return true if the edgept supplied as input is an inside angle.  This
 * is determined by the angular change of the vectors from point to
 * point.

 **********************************************************************/

#define is_inside_angle(pt)                                  \
(angle_change ((pt)->prev, (pt), (pt)->next) < chop_inside_angle)

/**********************************************************************
 * point_in_outline
 *
 * Check to see if this point falls within the bounding box of this
 * outline.  Note that this does not totally ensure that the edge
 * point falls on this outline.
 **********************************************************************/

#define point_in_outline(p,o)         \
((p)->pos.x >= (o)->topleft.x  &&   \
    (p)->pos.y <= (o)->topleft.y  &&   \
    (p)->pos.x <= (o)->botright.x &&   \
    (p)->pos.y >= (o)->botright.y)     \


/**********************************************************************
 * same_outline_bounds
 *
 * Return TRUE if these two outlines have the same bounds.
 **********************************************************************/

#define same_outline_bounds(outline,other_outline)     \
(outline->topleft.x  == other_outline->topleft.x  && \
    outline->topleft.y  == other_outline->topleft.y  && \
    outline->botright.x == other_outline->botright.x && \
    outline->botright.y == other_outline->botright.y)   \


/**********************************************************************
 * weighted_edgept_dist
 *
 * Return the distance (squared) between the two edge points.
 **********************************************************************/

#define weighted_edgept_dist(p1,p2,chop_x_y_weight)  \
(((p1)->pos.x - (p2)->pos.x) *                \
    ((p1)->pos.x - (p2)->pos.x) * chop_x_y_weight +  \
    ((p1)->pos.y - (p2)->pos.y) *               \
    ((p1)->pos.y - (p2)->pos.y))

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
void check_outline_mem();

void correct_blob_order(TBLOB *blob1, TBLOB *blob2);

void eliminate_duplicate_outlines(TBLOB *blob);

void setup_outline(TESSLINE *outline);

void setup_blob_outlines(TBLOB *blob);
/////////////////////////////////////////////////////////////////olutil////////////////////////////////////////

/////////////////////////////////////////////////////////////////seam////////////////////////////////////////
/*----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------*/
typedef float PRIORITY;          /*  PRIORITY  */

typedef struct seam_record
{                                /*  SEAM  */
  PRIORITY priority;
  inT8 widthp;
  inT8 widthn;
  inT16 location;
  SPLIT *split1;
  SPLIT *split2;
  SPLIT *split3;
} SEAM;

typedef ARRAY SEAMS;             /*  SEAMS  */

extern SEAM *newseam();

/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
/**
 * @name clone_seam
 *
 * Create a new seam record and copy the contents of this seam into it.
 */

#define clone_seam(dest,source)                       \
if (source) {                                       \
    (dest) = newseam ();                     \
    (dest)->location = (source)->location;           \
    (dest)->widthp = (source)->widthp;           \
    (dest)->widthn = (source)->widthn;           \
    (dest)->priority = (source)->priority;           \
    clone_split ((dest)->split1, (source)->split1);  \
    clone_split ((dest)->split2, (source)->split2);  \
    clone_split ((dest)->split3, (source)->split3);  \
}                                                   \
else {                                              \
    (dest) = (SEAM*) NULL;                           \
}                                                   \


/**
 * exact_point
 *
 * Return TRUE if the point positions are the exactly the same. The
 * parameters must be of type (EDGEPT*).
 */

#define exact_point(p1,p2)                    \
    (! ((p1->pos.x - p2->pos.x) || (p1->pos.y - p2->pos.y)))

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
bool point_in_split(SPLIT *split, EDGEPT *point1, EDGEPT *point2);

bool point_in_seam(SEAM *seam, SPLIT *split);

SEAMS add_seam(SEAMS seam_list, SEAM *seam);

void combine_seams(SEAM *dest_seam, SEAM *source_seam);

void delete_seam(void *arg);  //SEAM  *seam);

void free_seam_list(SEAMS seam_list);

bool test_insert_seam(SEAMS seam_list,
                      int index,
                      TBLOB *left_blob,
                      TBLOB *first_blob);

SEAMS insert_seam(SEAMS seam_list,
                  int index,
                  SEAM *seam,
                  TBLOB *left_blob,
                  TBLOB *first_blob);

int account_splits_right(SEAM *seam, TBLOB *blob);

int account_splits_left(SEAM *seam, TBLOB *blob, TBLOB *end_blob);

bool find_split_in_blob(SPLIT *split, TBLOB *blob);

SEAM *join_two_seams(SEAM *seam1, SEAM *seam2);

SEAM *new_seam(PRIORITY priority,
               int x_location,
               SPLIT *split1,
               SPLIT *split2,
               SPLIT *split3);

SEAMS new_seam_list();

void print_seam(const char *label, SEAM *seam);

void print_seams(const char *label, SEAMS seams);

int shared_split_points(SEAM *seam1, SEAM *seam2);
/////////////////////////////////////////////////////////////////seam////////////////////////////////////////

/////////////////////////////////////////////////////////////////svshowim////////////////////////////////////////
// Override of a tesseract function to display an image in a window.
// This function redirects the display to ScrollView instead of the
// stubbed-out functions in tesseract.
void sv_show_sub_image(IMAGE*    source,         // Image to show.
                       inT32     xstart,         // Bottom-left coords.
                       inT32     ystart,
                       inT32     xext,           // Size of rectangle to show.
                       inT32     yext,
                       ScrollView*    win,            // Window to draw in.
                       inT32     xpos,           // Place to show bottom-left.
                       inT32     ypos);          // Y position.
/////////////////////////////////////////////////////////////////svshowim////////////////////////////////////////

/////////////////////////////////////////////////////////////////matrix////////////////////////////////////////
static BLOB_CHOICE_LIST* NOT_CLASSIFIED = NULL;

// A generic class to store a matrix with entries of type T.
template <class T>
class GENERIC_MATRIX {
 public:
  // Allocate a piece of memory to hold a matrix of the given dimension.
  // Initialize all the elements of the matrix to empty instead of assuming
  // that a default constructor can be used.
  GENERIC_MATRIX(int dimension, const T& empty) : empty_(empty) {
    matrix_ = new T[dimension * dimension];
    dimension_ = dimension;
    for (int x = 0; x < dimension; x++)
      for (int y = 0; y < dimension; y++)
        this->put(x, y, empty_);
  }
  ~GENERIC_MATRIX() { delete[] matrix_; }

  // Provide the dimension of this square matrix.
  long dimension() const { return dimension_; }

  // Expression to select a specific location in the matrix.
  int index(int column, int row) const {
    return (row * this->dimension() + column);
  }

  // Put a list element into the matrix at a specific location.
  void put(int column, int row, const T& thing) {
    matrix_[this->index(column, row)] = thing;
  }

  // Get the item at a specified location from the matrix.
  T get(int column, int row) const {
    return matrix_[this->index(column, row)];
  }

  // Delete objects pointed to by matrix_[i].
  void delete_matrix_pointers() {
    for (int x = 0; x < this->dimension(); x++) {
      for (int y = 0; y < this->dimension(); y++) {
        T matrix_cell = this->get(x, y);
        if (matrix_cell != empty_)
          delete matrix_cell;
      }
    }
  }

 private:
  T *matrix_;
  T empty_;  // The unused cell.
  int dimension_;
};

class MATRIX : public GENERIC_MATRIX<BLOB_CHOICE_LIST *> {
 public:
  MATRIX(int dimension) : GENERIC_MATRIX<BLOB_CHOICE_LIST *>(dimension,
                                                             NOT_CLASSIFIED) {}
  // Print a shortened version of the contents of the matrix.
  void print(const UNICHARSET &current_unicharset);
};
/////////////////////////////////////////////////////////////////matrix////////////////////////////////////////

/////////////////////////////////////////////////////////////////badwords////////////////////////////////////////
/**----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------**/
void PrintBadWords(FILE *File);

void SaveBadWord(const char *Word, FLOAT32 Certainty);
extern BOOL_VAR_H (tessedit_save_stats, FALSE, "Save final recognition statistics");
/////////////////////////////////////////////////////////////////badwords////////////////////////////////////////

/////////////////////////////////////////////////////////////////wordrec////////////////////////////////////////
struct CHUNKS_RECORD;
struct SEARCH_RECORD;

class Wordrec : public Classify {
 public:
  Wordrec();
  ~Wordrec();
  void save_summary(inT32 elapsed_time);
  /* tface.cpp ***************************************************************/
  void program_editup(const char *textbase, bool init_permute);
  BLOB_CHOICE_LIST_VECTOR *cc_recog(TWERD *tessword,
                                    WERD_CHOICE *best_choice,
                                    WERD_CHOICE *best_raw_choice,
                                    BOOL8 tester,
                                    BOOL8 trainer,
                                    bool last_word_on_line);
  void program_editdown(inT32 elasped_time);
  void set_pass1();
  void set_pass2();
  int end_recog();
  int start_recog(const char *textbase);
  BLOB_CHOICE_LIST *call_matcher(                  //call a matcher
                    TBLOB *ptblob,    //previous
                    TBLOB *tessblob,  //blob to match
                    TBLOB *ntblob,    //next
                    void *,           //unused parameter
                    TEXTROW *         //always null anyway
                   );
  /* tessinit.cpp ************************************************************/
  void program_init();
  /* wordclass.cpp ***********************************************************/
  BLOB_CHOICE_LIST *classify_blob(TBLOB *pblob,
                                  TBLOB *blob,
                                  TBLOB *nblob,
                                  TEXTROW *row,
                                  const char *string,
                                  C_COL color);
  void update_blob_classifications(TWERD *word,
                                   const BLOB_CHOICE_LIST_VECTOR &choices);
  /* bestfirst.cpp ***********************************************************/
  BLOB_CHOICE_LIST_VECTOR *evaluate_chunks(CHUNKS_RECORD *chunks_record,
                                           SEARCH_STATE search_state);
  void update_ratings(const BLOB_CHOICE_LIST_VECTOR &new_choices,
                      const CHUNKS_RECORD *chunks_record,
                      const SEARCH_STATE search_state);
  inT16 evaluate_state(CHUNKS_RECORD *chunks_record,
                       SEARCH_RECORD *the_search,
                       DANGERR *fixpt);
  void best_first_search(CHUNKS_RECORD *chunks_record,
                         WERD_CHOICE *best_choice,
                         WERD_CHOICE *raw_choice,
                         STATE *state,
                         DANGERR *fixpt,
                         STATE *best_state);
  void expand_node(FLOAT32 worst_priority,
                   CHUNKS_RECORD *chunks_record,
                   SEARCH_RECORD *the_search);
  BLOB_CHOICE_LIST_VECTOR *rebuild_current_state(
      TBLOB *blobs,
      SEAMS seam_list,
      STATE *state,
      BLOB_CHOICE_LIST_VECTOR *char_choices,
      int fx,
      bool force_rebuild,
      const WERD_CHOICE &best_choice,
      const MATRIX *ratings);
  BLOB_CHOICE_LIST *join_blobs_and_classify(
      TBLOB *blobs, SEAMS seam_list,
      int x, int y, int fx, const MATRIX *ratings,
      BLOB_CHOICE_LIST_VECTOR *old_choices);

  /* chopper.cpp *************************************************************/
  bool improve_one_blob(TWERD *word,
                        BLOB_CHOICE_LIST_VECTOR *char_choices,
                        int fx,
                        inT32 *blob_number,
                        SEAMS *seam_list,
                        DANGERR *fixpt,
                        bool split_next_to_fragment);
  void modify_blob_choice(BLOB_CHOICE_LIST *answer,
                          int chop_index);
  bool chop_one_blob(TWERD *word,
                     BLOB_CHOICE_LIST_VECTOR *char_choices,
                     inT32 *blob_number,
                     SEAMS *seam_list,
                     int *right_chop_index);
  BLOB_CHOICE_LIST_VECTOR *chop_word_main(register TWERD *word,
                                          int fx,
                                          WERD_CHOICE *best_choice,
                                          WERD_CHOICE *raw_choice,
                                          BOOL8 tester,
                                          BOOL8 trainer);
  void improve_by_chopping(register TWERD *word,
                           BLOB_CHOICE_LIST_VECTOR *char_choices,
                           int fx,
                           STATE *best_state,
                           WERD_CHOICE *best_choice,
                           WERD_CHOICE *raw_choice,
                           SEAMS *seam_list,
                           DANGERR *fixpt,
                           STATE *chop_states,
                           inT32 *state_count);
  MATRIX *word_associator(TBLOB *blobs,
                          SEAMS seams,
                          STATE *state,
                          int fxid,
                          WERD_CHOICE *best_choice,
                          WERD_CHOICE *raw_choice,
                          char *correct,
                          DANGERR *fixpt,
                          STATE *best_state);
  inT16 select_blob_to_split(const BLOB_CHOICE_LIST_VECTOR &char_choices,
                             float rating_ceiling,
                             bool split_next_to_fragment);
  /* mfvars.cpp **************************************************************/
  void mfeature_init();
  /* pieces.cpp **************************************************************/
  BLOB_CHOICE_LIST *classify_piece(TBLOB *pieces,
                                   SEAMS seams,
                                   inT16 start,
                                   inT16 end);
  BLOB_CHOICE_LIST *get_piece_rating(MATRIX *ratings,
                                     TBLOB *blobs,
                                     SEAMS seams,
                                     inT16 start,
                                     inT16 end);
  /* djmenus.cpp **************************************************************/
  // Prints out statistics gathered.
  void dj_statistics(FILE *File) {
    PrintAdaptiveStatistics(File);
    PrintBadWords(File);
  }
  // Does clean up (should be called at the end of the program).
  void dj_cleanup() { EndAdaptiveClassifier(); }


  /* heuristic.cpp ************************************************************/
  FLOAT32 prioritize_state(CHUNKS_RECORD *chunks_record,
                           SEARCH_RECORD *the_search);
  FLOAT32 width_priority(CHUNKS_RECORD *chunks_record,
                         STATE *state,
                         int num_joints);
  FLOAT32 seamcut_priority(SEAMS seams,
                           STATE *state,
                           int num_joints);
  FLOAT32 rating_priority(CHUNKS_RECORD *chunks_record,
                          STATE *state,
                          int num_joints);

  /* member variables *********************************************************/
  /* tface.cpp ****************************************************************/
  POLY_MATCHER tess_matcher;//current matcher
  POLY_TESTER tess_tester;  //current tester
  POLY_TESTER tess_trainer; //current trainer
  DENORM *tess_denorm;      //current denorm
  WERD *tess_word;          //current word
  int dict_word(const WERD_CHOICE &word);
};



/* ccmain/tstruct.cpp *********************************************************/
class FRAGMENT:public ELIST_LINK
{
  public:
    FRAGMENT() {  //constructor
    }
    FRAGMENT(EDGEPT *head_pt,   //start
             EDGEPT *tail_pt);  //end

    ICOORD head;                 //coords of start
    ICOORD tail;                 //coords of end
    EDGEPT *headpt;              //start point
    EDGEPT *tailpt;              //end point

    NEWDELETE2 (FRAGMENT)
};

ELISTIZEH (FRAGMENT)
PBLOB *make_ed_blob(                 //construct blob
                    TBLOB *tessblob  //blob to convert
                   );
OUTLINE *make_ed_outline(                     //constructoutline
                         FRAGMENT_LIST *list  //list of fragments
                        );
void register_outline(                     //add fragments
                      TESSLINE *outline,   //tess format
                      FRAGMENT_LIST *list  //list to add to
                     );

/////////////////////////////////////////////////////////////////wordrec////////////////////////////////////////

/////////////////////////////////////////////////////////////////tstruct////////////////////////////////////////
WERD *make_ed_word(                  //construct word
                   TWERD *tessword,  //word to convert
                   WERD *clone       //clone this one
                  );
void make_tess_row(                  //make fake row
                   DENORM *denorm,   //row info
                   TEXTROW *tessrow  //output row
                  );
TWERD *make_tess_word(              //convert owrd
                      WERD *word,   //word to do
                      TEXTROW *row  //fake row
                     );
TBLOB *make_tess_blobs(                      //make tess blobs
                       PBLOB_LIST *bloblist  //list to convert
                      );
TBLOB *make_rotated_tess_blob(const DENORM* denorm, PBLOB *blob,
                              BOOL8 flatten);
TBLOB *make_tess_blob(               //make tess blob
                      PBLOB *blob,   //blob to convert
                      BOOL8 flatten  //flatten outline structure
                     );
TESSLINE *make_tess_outlines(                            //make tess outlines
                             OUTLINE_LIST *outlinelist,  //list to convert
                             BOOL8 flatten               //flatten outline structure
                            );
EDGEPT *make_tess_edgepts(                          //make tess edgepts
                          POLYPT_LIST *edgeptlist,  //list to convert
                          TPOINT &tl,               //bounding box
                          TPOINT &br);
/////////////////////////////////////////////////////////////////tstruct////////////////////////////////////////

/////////////////////////////////////////////////////////////////tesseractclass////////////////////////////////////////

/*Maximum lengths of various strings*/
#define MAX_FONT_NAME   34       /*name of font */
#define MAX_OCR_NAME    32       /*name of engine */
#define MAX_OCR_VERSION   17     /*version code of engine */

/*Image parameters*/
#define MIN_IMAGE_SIZE    64     /*smallest image that will be passed */
#define IMAGE_ROUNDING    32     /*all sizes are multiple of this */

#if defined(__SLOW_TIMES__)
/*Maximum timeouts of various functions (in secs)*/
#define STARTUP_TIMEOUT   100    /*start of OCR engine */
#define SHUTDOWN_TIMEOUT  50     /*end of OCR engine */
#define SENDIM_TIMEOUT    50     /*send of image */
#define RELEASE_TIMEOUT   50     /*release of semaphore */
#define READIM_TIMEOUT    100    /*read of image */
#define READTEXT_TIMEOUT  50     /*read of text */
#define PROGRESS_TIMEOUT  30     /*progress every 3 seconds */
#define BADTIMES_TIMEOUT  7      /*max lack of progress */
#else
/*Maximum timeouts of various functions (in secs)*/
#define STARTUP_TIMEOUT   10     /*start of OCR engine */
#define SHUTDOWN_TIMEOUT  6      /*end of OCR engine */
#define SENDIM_TIMEOUT    5      /*send of image */
#define RELEASE_TIMEOUT   5      /*release of semaphore */
#define READIM_TIMEOUT    10     /*read of image */
#define READTEXT_TIMEOUT  5      /*read of text */
#define PROGRESS_TIMEOUT  3      /*progress every 3 seconds */
#define BADTIMES_TIMEOUT  7      /*max lack of progress */
#endif

/*language definitions are identical to RTF*/
#define LANGE_NONE      0x0400   /*no language */
#define LANGE_ALBANIAN    0x041c /*Albanian */
#define LANGE_BRITISH   0x0809   /*International English */
#define LANGE_BULGARIAN   0x0402 /*Bulgarian */
#define LANGE_CROATIAN    0x041a /*Croatian(latin alphabet) */
#define LANGE_CZECH     0x0405   /*Czech */
#define LANGE_DANISH    0x0406   /*Danish */
#define LANGE_DUTCH     0x0413   /*Dutch */
#define LANGE_FINNISH   0x040b   /*Finnish */
#define LANGE_FRENCH    0x040c   /*French */
#define LANGE_GERMAN    0x0407   /*German */
#define LANGE_GREEK     0x0408   /*Greek */
#define LANGE_HUNGARIAN   0x040e /*Hungarian */
#define LANGE_ITALIAN   0x0410   /*Italian */
#define LANGE_JAPANESE    0x0411 /*Japanese */
#define LANGE_KOREAN    0x0412   /*Korean */
#define LANGE_NORWEGIAN   0x0414 /*Bokmal */
#define LANGE_POLISH    0x0415   /*Polish */
#define LANGE_PORTUGESE   0x0416 /*Brazilian Portugese */
#define LANGE_ROMANIAN    0x0418 /*Romanian */
#define LANGE_RUSSIAN   0x0419   /*Russian */
#define LANGE_SCHINESE    0x0804 /*Simplified Chinese */
#define LANGE_SLOVAK    0x041b   /*Slovak */
#define LANGE_SPANISH   0x040a   /*Castilian */
#define LANGE_SWEDISH   0x041d   /*Swedish */
#define LANGE_TCHINESE    0x0404 /*Traditional Chinese */
#define LANGE_TURKISH   0x041f   /*Turkish */
#define LANGE_USENGLISH   0x0409 /*American */

/*font family definitions are identical to RTF*/
#define FFAM_NONE     0          /*unknown */
#define FFAM_ROMAN      1        /*serifed prop */
#define FFAM_SWISS      2        /*sans-serif prop */
#define FFAM_MODERN     3        /*fixed pitch */

/*character set definitions are identical to RTF*/
#define CHSET_ANSI      0        /*Ansi efigs */
#define CHSET_SHIFT_JIS   128    /*JIS X 0208-1990 */
#define CHSET_KOREAN    129      /*KS C 5601-1992 */
#define CHSET_SCHINESE    134    /*GB 2312-80 */
#define CHSET_BIG5      136      /*Big Five */
#define CHSET_CYRILLIC    204    /*Cyrillic */
#define CHSET_EEUROPE   238      /*Eastern Europe */

/*pitch set definitions are identical to RTF*/
#define PITCH_DEF     0          /*default */
#define PITCH_FIXED     1        /*fixed pitch */
#define PITCH_VAR     2          /*variable pitch */

/*Bitmasks for character enhancements.
OR these together for enhancement in ocr_append_char*/
#define EUC_BOLD      1          /*bold character */
#define EUC_ITALIC      2        /*italic char */
#define EUC_UNDERLINE   4        /*underlined char */
#define EUC_SUBSCRIPT   8        /*subscript char */
#define EUC_SUPERSCRIPT   16     /*superscript char */

/*enum for character rendering direction*/
enum OCR_CHAR_DIRECTION
{
  OCR_CDIR_RIGHT_LEFT,           /*right to left horizontal */
  OCR_CDIR_LEFT_RIGHT,           /*left to right horizontal */
  OCR_CDIR_TOP_BOTTOM,           /*top to bottom vertical */
  OCR_CDIR_BOTTOM_TOP            /*bottom to top vertical */
};

/*enum for line rendering direction*/
enum OCR_LINE_DIRECTION
{
  OCR_LDIR_DOWN_RIGHT,           /*horizontal lines go down */
  /*vertical lines go right */
  OCR_LDIR_UP_LEFT               /*horizontal lines go up */
};

/*enum for newline type*/
enum OCR_NEWLINE_TYPE
{
  OCR_NL_NONE,                   /*not a newline */
  OCR_NL_NEWLINE,                /*this is a newline but not new para */
  OCR_NL_NEWPARA                 /*this is a newline and a new para */
};

/*error codes that can be returned from the API functions other than OKAY and HPERR*/
#define OCR_API_NO_MEM    (-2)   /*filled output buffer */
#define OCR_API_BAD_CHAR  (-3)   /*whitespace sent to ocr_append_char */
#define OCR_API_BAD_STATE (-4)   /*invalid call sequence */

/*error codes used for passing errors back to the HP side*/
enum OCR_ERR_CODE
{
  OCR_ERR_NONE,                  /*no error */
  OCR_ERR_CLEAN_EXIT,            /*no error */
  OCR_ERR_NO_MEM,                /*out of memory */
  OCR_ERR_FILE_READ,             /*failed to read data file */
  OCR_ERR_TMP_WRITE,             /*failed to write temp file */
  OCR_ERR_TMP_READ,              /*failed to read temp file */
  OCR_ERR_BAD_DLL,               /*missing or invalid dll subcomponent */
  OCR_ERR_BAD_EXE,               /*missing or invalid exe subcomponent */
  OCR_ERR_BAD_LOAD,              /*failed to load subcomponent */
  OCR_ERR_BAD_LANG,              /*unable to recognize requested language */
  OCR_ERR_BAD_STATE,             /*engine did call out of sequence */
  OCR_ERR_INTERNAL1,             /*internal error type 1 */
  OCR_ERR_INTERNAL2,             /*internal error type 1 */
  OCR_ERR_INTERNAL3,             /*internal error type 1 */
  OCR_ERR_INTERNAL4,             /*internal error type 1 */
  OCR_ERR_INTERNAL5,             /*internal error type 1 */
  OCR_ERR_INTERNAL6,             /*internal error type 1 */
  OCR_ERR_INTERNAL7,             /*internal error type 1 */
  OCR_ERR_INTERNAL8,             /*internal error type 1 */
  OCR_ERR_TIMEOUT                /*timed out in comms */
};                               /*for calls to ocr_error */

/**********************************************************************
 * EFONT_DESC
 * Description of one font.
 * The information required is basically that used by RTF.
 * The name may be either a valid font on the system or the empty string.
 **********************************************************************/

typedef struct                   /*font description */
{
  uinT16 language;               /*default language */
  uinT8 font_family;             /*serif/not, fixed/not */
  uinT8 char_set;                /*character set standard */
  uinT8 pitch;                   /*fixed or prop */
  inT8 name[MAX_FONT_NAME + 1];  /*plain ascii name */
} EFONT_DESC;                    /*font description */

/**********************************************************************
 * EOCR_DESC
 * Description of the OCR engine provided at startup.
 * The name and version may be reported to the user at some point.
 * The fonts array should indicate the fonts that the OCR system
 * can recognize.
 **********************************************************************/

typedef struct                   /*startup info */
{
  inT32 protocol;                /*interface version */
  uinT32 font_count;             /*number of fonts */
  uinT16 language;               /*default language */
  uinT16 name[MAX_OCR_NAME + 1]; /*name of engine */
                                 /*version of engine */
  uinT16 version[MAX_OCR_VERSION + 1];
  EFONT_DESC fonts[1];           /*array of fonts */
} EOCR_DESC;                     /*startup info */

/**********************************************************************
 * ESTRIP_DESC
 * Description of the image strip as it is passed to the engine.
 * The image is always 1 bit, with 1=black.
 * The width is always a multiple of 32, so padding is always OK.
 * The height of the full image is always a multiple of 32.
 * The top y coordinate is 0, and increases down.
 * The top leftmost pixel is in the most significant bit of the first byte.
 **********************************************************************/

typedef struct                   /*bitmap strip */
{
  inT16 x_size;                  /*width in pixels */
  inT16 y_size;                  /*of full image */
  inT16 strip_size;              /*of this strip */
  inT16 resolution;              /*pixels per inch */
  uinT8 data[8];                 /*image data */
} ESTRIP_DESC;                   /*bitmap strip */

/**********************************************************************
 * EANYCODE_CHAR
 * Description of a single character. The character code is defined by
 * the character set of the current font.
 * Output text is sent as an array of these structures.
 * Spaces and line endings in the output are represented in the
 * structures of the surrounding characters. They are not directly
 * represented as characters.
 * The first character in a word has a positive value of blanks.
 * Missing information should be set to the defaults in the comments.
 * If word bounds are known, but not character bounds, then the top and
 * bottom of each character should be those of the word. The left of the
 * first and right of the last char in each word should be set. All other
 * lefts and rights should be set to -1.
 * If set, the values of right and bottom are left+width and top+height.
 * Most of the members come directly from the parameters to ocr_append_char.
 * The formatting member uses the enhancement parameter and combines the
 * line direction stuff into the top 3 bits.
 * The coding is 0=RL char, 1=LR char, 2=DR NL, 3=UL NL, 4=DR Para,
 * 5=UL Para, 6=TB char, 7=BT char. API users do not need to know what
 * the coding is, only that it is backwards compatible with the previous
 * version.
 **********************************************************************/

typedef struct                   /*single character */
{
// It should be noted that the format for char_code for version 2.0 and beyond is UTF8
// which means that ASCII characters will come out as one structure but other characters
// will be returned in two or more instances of this structure with a single byte of the
// UTF8 code in each, but each will have the same bounding box.
// Programs which want to handle languagues with different characters sets will need to
// handle extended characters appropriately, but *all* code needs to be prepared to
// receive UTF8 coded characters for characters such as bullet and fancy quotes.
  uinT16 char_code;              /*character itself */
  inT16 left;                    /*of char (-1) */
  inT16 right;                   /*of char (-1) */
  inT16 top;                     /*of char (-1) */
  inT16 bottom;                  /*of char (-1) */
  inT16 font_index;              /*what font (0) */
  uinT8 confidence;              /*0=perfect, 100=reject (0/100) */
  uinT8 point_size;              /*of char, 72=i inch, (10) */
  inT8 blanks;                   /*no of spaces before this char (1) */
  uinT8 formatting;              /*char formatting (0) */
} EANYCODE_CHAR;                 /*single character */

/**********************************************************************
 * ETEXT_DESC
 * Description of the output of the OCR engine.
 * This structure is used as both a progress monitor and the final
 * output header, since it needs to be a valid progress monitor while
 * the OCR engine is storing its output to shared memory.
 * During progress, all the buffer info is -1.
 * Progress starts at 0 and increases to 100 during OCR. No other constraint.
 * Every progress callback, the OCR engine must set ocr_alive to 1.
 * The HP side will set ocr_alive to 0. Repeated failure to reset
 * to 1 indicates that the OCR engine is dead.
 * If the cancel function is not null then it is called with the number of
 * user words found. If it returns true then operation is cancelled.
 **********************************************************************/
typedef bool (*CANCEL_FUNC)(void* cancel_this, int words);

typedef struct ETEXT_STRUCT      /*output header */
{
  inT16 count;                   /*chars in this buffer(0) */
  inT16 progress;                /*percent complete increasing (0-100) */
  inT8 more_to_come;             /*true if not last */
  inT8 ocr_alive;                /*ocr sets to 1, HP 0 */
  inT8 err_code;                 /*for errcode use */
  CANCEL_FUNC cancel;            /*returns true to cancel */
  void* cancel_this;             /*this or other data for cancel*/
  clock_t end_time;              /*time to stop if not 0*/
  EANYCODE_CHAR text[1];         /*character data */
} ETEXT_DESC;                    /*output header */

#ifdef __MSW32__
/**********************************************************************
 * ESHM_INFO
 * This data structure is used internally to the API to hold the handles
 * to the operating system tools used for interprocess communications.
 * API users do not access this structure directly.
 **********************************************************************/
typedef struct                   /*shared mem info */
{
  HANDLE shm_hand;               /*handle to shm */
  HANDLE mutex;                  /*alive check */
  HANDLE ocr_sem;                /*ocr semaphore */
  HANDLE hp_sem;                 /*hp semaphore */
  void *shm_mem;                 /*shared memory */
  inT32 shm_size;                /*size of shm */
} ESHM_INFO;                     /*shared mem info */
#elif defined (__MAC__)
typedef struct                   /*shared mem info */
{
  Boolean mutex;                 /*alive check */
  Boolean ocr_sem;               /*ocr semaphore */
  Boolean hp_sem;                /*hp semaphore */
  void *shm_mem;                 /*shared memory */
  inT32 shm_size;                /*size of shm */
  inT16 language;

  // Process management information follows:
  ProcessSerialNumber IPEProcess;
  ProcessSerialNumber OCRProcess;
} ESHM_INFO;
#elif defined (__UNIX__)
typedef struct                   /*shared mem info */
{
  void *shm_mem;                 /*shared memory */
  inT32 shm_size;                /*size of shm */
} ESHM_INFO;
#endif
/////////////////////////////////////////////////////////////////ocrclass////////////////////////////////////////

/////////////////////////////////////////////////////////////////svshowim////////////////////////////////////////
// Override of a tesseract function to display an image in a window.
// This function redirects the display to ScrollView instead of the
// stubbed-out functions in tesseract.
void sv_show_sub_image(IMAGE*    source,         // Image to show.
                       inT32     xstart,         // Bottom-left coords.
                       inT32     ystart,
                       inT32     xext,           // Size of rectangle to show.
                       inT32     yext,
                       ScrollView*    win,            // Window to draw in.
                       inT32     xpos,           // Place to show bottom-left.
                       inT32     ypos);          // Y position.
/////////////////////////////////////////////////////////////////svshowim////////////////////////////////////////

/////////////////////////////////////////////////////////////////matmatch////////////////////////////////////////
#define BINIM_BLACK 0
#define BINIM_WHITE 1
#define BAD_MATCH 9999.0

extern BOOL_VAR_H (tessedit_display_mm, FALSE, "Display matrix matches");
extern BOOL_VAR_H (tessedit_mm_debug, FALSE,
"Print debug information for matrix matcher");
extern INT_VAR_H (tessedit_mm_prototype_min_size, 3,
"Smallest number of samples in a cluster for a prototype to be used");
float matrix_match(  // returns match score
                   IMAGE *image1,
                   IMAGE *image2);
float match1(  /* returns match score */
             IMAGE *image_w,
             IMAGE *image_n);
void display_images(IMAGE *image_w, IMAGE *image_n, IMAGE *match_image);
ScrollView* display_image(IMAGE *image,
                     const char *title,
                     inT32 x,
                     inT32 y,
                     BOOL8 wait);
/////////////////////////////////////////////////////////////////matmatch////////////////////////////////////////

/////////////////////////////////////////////////////////////////charsample////////////////////////////////////////
#define BAD_SCORE MAX_INT32
#define FIRST_CHAR '!'
#define LAST_CHAR  '~'


enum ClusterType
{ UNKNOWN, BLOB_CLUSTER, IMAGE_CLUSTER };

class CHAR_SAMPLE;               //forward decl

ELISTIZEH (CHAR_SAMPLE)
class CHAR_SAMPLES;              //forward decl

ELISTIZEH (CHAR_SAMPLES)
class CHAR_PROTO;                //forward decl

class CHAR_SAMPLE:public ELIST_LINK
{
  public:
    CHAR_SAMPLE();  // empty constructor

    CHAR_SAMPLE(  // simple constructor
                PBLOB *blob,
                DENORM *denorm,
                char c
               );

    CHAR_SAMPLE(  // simple constructor
                IMAGE *image,
                char c
               );

    ~CHAR_SAMPLE () {
      // We own the image, so it has to be deleted.
      if (sample_image != NULL)
        delete sample_image;
    }

    float match_sample(CHAR_SAMPLE *test_sample, BOOL8 updating,
                       Tesseract* tess);

    inT32 n_matches() {
      return n_samples_matched;
    }

    IMAGE *image() {
      return sample_image;
    }

    PBLOB *blob() {
      return sample_blob;
    }

    DENORM *denorm() {
      return sample_denorm;
    }

    double mean_score();

    double variance();

    char character() {
      return ch;
    }

    void print(FILE *f);

    void reset_match_statistics();

    NEWDELETE2 (CHAR_SAMPLE) private:
    IMAGE * sample_image;
    PBLOB *sample_blob;
    DENORM *sample_denorm;
    inT32 n_samples_matched;
    double total_match_scores;
    double sumsq_match_scores;
    char ch;
};

class CHAR_SAMPLES:public ELIST_LINK
{
  public:
    CHAR_SAMPLES();  //empty constructor

    CHAR_SAMPLES(CHAR_SAMPLE *sample);

    ~CHAR_SAMPLES () {           //destructor
    }

    inT32 n_samples() {
      return samples.length ();
    }

    void add_sample(CHAR_SAMPLE *sample, Tesseract*);

    void build_prototype();

    void rebuild_prototype(inT32 new_xsize, inT32 new_ysize);

    void add_sample_to_prototype(CHAR_SAMPLE *sample);

    CHAR_PROTO *prototype() {
      return proto;
    }

    void find_best_sample();

    float match_score(CHAR_SAMPLE *sample, Tesseract* tess);

    float nn_match_score(CHAR_SAMPLE *sample, Tesseract* tess);

    char character() {
      return ch;
    }

    void assign_to_char();

    void print(FILE *f);

    NEWDELETE2 (CHAR_SAMPLES) private:
    ClusterType type;
    char ch;
    CHAR_PROTO *proto;
    CHAR_SAMPLE *best_sample;
    CHAR_SAMPLE_LIST samples;
};

class CHAR_PROTO
{
  public:
    CHAR_PROTO();  // empty constructor

    CHAR_PROTO(inT32 x_size,
               inT32 y_size,
               inT32 n_samples,
               float initial_value,
               char c);

    CHAR_PROTO(  // simple constructor
               CHAR_SAMPLE *sample);

    ~CHAR_PROTO ();

    float match_sample(CHAR_SAMPLE *test_sample);

    float match(CHAR_PROTO *test_proto);

    inT32 n_samples() {
      return nsamples;
    }

    inT32 x_size() {
      return xsize;
    }

    inT32 y_size() {
      return ysize;
    }

    float **data() {
      return proto;
    }
    char character() {
      return ch;
    }

    void enlarge_prototype(inT32 new_xsize, inT32 new_ysize);

    void add_sample(CHAR_SAMPLE *sample);

    IMAGE *make_image();

    void print(FILE *f);

    NEWDELETE2 (CHAR_PROTO) private:
    inT32 xsize;
    inT32 ysize;
    float *proto_data;
    float **proto;
    inT32 nsamples;
    char ch;
};
/////////////////////////////////////////////////////////////////charsample////////////////////////////////////////

/////////////////////////////////////////////////////////////////charcut////////////////////////////////////////
/**
 * @class PIXROW
 *
 * This class describes the pixels occupied by a blob. It uses two arrays, (min
 * and max), each with one element per row, to identify the min and max x
 * coordinates of the black pixels in the character on that row of the image.
 * The number of rows used to describe the blob is held in row_count - note that
 * some rows may be unoccupied - signified by max < min. The page coordinate of
 * the row defined by min[0] and max[0] is held in row_offset.
 */

class PIXROW:public ELIST_LINK
{
  public:
    inT16 row_offset;            ///< y coord of min[0]
    inT16 row_count;             ///< length of arrays
    inT16 *min;                  ///< array of min x
    inT16 *max;                  ///< array of max x
    /** empty constructor */
    PIXROW() {
      row_offset = 0;
      row_count = 0;
      min = NULL;
      max = NULL;
    }
    /** specified size */
    PIXROW(
           inT16 pos,
           inT16 count,
           PBLOB *blob);
    /** destructor */
    ~PIXROW () {
      if (min != NULL)
        free_mem(min);
      if (max != NULL)
        free_mem(max);
      max = NULL;
    }

    /**
     * use current settings
     * @param fd where to paint
     */
    void plot(ScrollView* fd) const;

    /**
     * return bounding box
     * @return true if box exceeds image
     */
    TBOX bounding_box() const;

    bool bad_box(int xsize, int ysize) const;

    /**
     * force end on black
     * @param imlines image array
     * @param x_offset of pixels[0]
     * @param foreground_colour 0 or 1
     */
    void contract(
                  IMAGELINE *imlines,
                  inT16 x_offset,
                  inT16 foreground_colour);

    /**
     * @param imlines image array
     * @param imbox image box
     * @param prev for prev blob
     * @param next for next blob
     * @param foreground_colour 0 or 1
     */
    BOOL8 extend(IMAGELINE *imlines,
                 TBOX &imbox,
                 PIXROW *prev,
                 PIXROW *next,
                 inT16 foreground_colour);

    /**
     * @param imlines box of imlines extnt
     * @param imbox image box
     * @param row row containing word
     * @param clip_image unscaled char image
     * @param baseline_pos baseline ht in image
     */
    void char_clip_image(IMAGELINE *imlines,
                         TBOX &im_box,
                         ROW *row,
                         IMAGE &clip_image,
                         float &baseline_pos);

};

ELISTIZEH (PIXROW)
extern INT_VAR_H (pix_word_margin, 3, "How far outside word BB to grow");
extern BOOL_VAR_H (show_char_clipping, TRUE, "Show clip image window?");
extern INT_VAR_H (net_image_width, 40, "NN input image width");
extern INT_VAR_H (net_image_height, 36, "NN input image height");
extern INT_VAR_H (net_image_x_height, 22, "NN input image x_height");
void char_clip_word(
                    WERD *word,                 ///< word to be processed
                    IMAGE &bin_image,           ///< whole image
                    PIXROW_LIST *&pixrow_list,  ///< pixrows built
                    IMAGELINE *&imlines,        ///< lines cut from image
                    TBOX &pix_box               ///< box defining imlines
                   );
/** get some imagelines */
IMAGELINE *generate_imlines(
                            IMAGE &bin_image,  ///< from here
                            TBOX &pix_box);

ScrollView* display_clip_image(WERD *word,           ///< word to be processed
                          IMAGE &bin_image,          ///< whole image
                          PIXROW_LIST *pixrow_list,  ///< pixrows built
                          TBOX &pix_box              ///< box of subimage
                         );
void display_images(IMAGE &clip_image, IMAGE &scaled_image);

/** plot for all blobs */
void plot_pixrows(
                  PIXROW_LIST *pixrow_list,
                  ScrollView* win);
/////////////////////////////////////////////////////////////////charcut////////////////////////////////////////

/////////////////////////////////////////////////////////////////polyblk////////////////////////////////////////
// Possible types for a POLY_BLOCK or ColPartition. Must be kept in sync with
// kPBColors. Used extensively by ColPartition, but polyblk is a lower-level
// file.
enum PolyBlockType {
  PT_UNKNOWN,        // Type is not yet known. Keep as the first element.
  PT_FLOWING_TEXT,   // Text that lives inside a column.
  PT_HEADING_TEXT,   // Text that spans more than one column.
  PT_PULLOUT_TEXT,   // Text that is in a cross-column pull-out region.
  PT_TABLE,          // Partition belonging to a table region.
  PT_VERTICAL_TEXT,  // Text-line runs vertically.
  PT_FLOWING_IMAGE,  // Image that lives inside a column.
  PT_HEADING_IMAGE,  // Image that spans more than one column.
  PT_PULLOUT_IMAGE,  // Image that is in a cross-column pull-out region.
  PT_FLOWING_LINE,   // H-Line that lives inside a column.
  PT_HEADING_LINE,   // H-Line that spans more than one column.
  PT_PULLOUT_LINE,   // H-Line that is in a cross-column pull-out region.
  PT_NOISE,          // Lies outside of any column.
  PT_COUNT
};

class POLY_BLOCK {
 public:
  POLY_BLOCK() {
  }
  POLY_BLOCK(ICOORDELT_LIST *points, PolyBlockType type);
  ~POLY_BLOCK () {
  }

  TBOX *bounding_box() {  // access function
    return &box;
  }

  ICOORDELT_LIST *points() {  // access function
    return &vertices;
  }

  void compute_bb();

  PolyBlockType isA() const {
    return type;
  }

  bool IsText() const {
    return IsTextType(type);
  }

  // Rotate about the origin by the given rotation. (Analogous to
  // multiplying by a complex number.
  void rotate(FCOORD rotation);
  // Move by adding shift to all coordinates.
  void move(ICOORD shift);

  void plot(ScrollView* window, inT32 num);

  void fill(ScrollView* window, ScrollView::Color colour);

  // Returns true if other is inside this.
  bool contains(POLY_BLOCK *other);

  // Returns true if the polygons of other and this overlap.
  bool overlap(POLY_BLOCK *other);

  // Returns the winding number of this around the test_pt.
  // Positive for anticlockwise, negative for clockwise, and zero for
  // test_pt outside this.
  inT16 winding_number(const ICOORD &test_pt);

  // Serialization.
  void prep_serialise() {
    vertices.prep_serialise();
  }
  void dump(FILE *f) {
    vertices.dump(f);
  }
  void de_dump(FILE *f) {
    vertices.de_dump(f);
  }
  make_serialise(POLY_BLOCK)
  void serialise_asc(FILE * f);
  void de_serialise_asc(FILE *f);

  // Static utility functions to handle the PolyBlockType.

  // Returns a color to draw the given type.
  static ScrollView::Color ColorForPolyBlockType(PolyBlockType type);

  // Returns true if PolyBlockType is of horizontal line type
  static bool IsLineType(PolyBlockType type) {
    return (type == PT_FLOWING_LINE) || (type == PT_HEADING_LINE) ||
        (type == PT_PULLOUT_LINE);
  }
  // Returns true if PolyBlockType is of image type
  static bool IsImageType(PolyBlockType type) {
    return (type == PT_FLOWING_IMAGE) || (type == PT_HEADING_IMAGE) ||
           (type == PT_PULLOUT_IMAGE);
  }
  // Returns true if PolyBlockType is of text type
  static bool IsTextType(PolyBlockType type) {
    return (type == PT_FLOWING_TEXT) || (type == PT_HEADING_TEXT) ||
           (type == PT_PULLOUT_TEXT) || (type == PT_TABLE) ||
           (type == PT_VERTICAL_TEXT);
  }

 private:
  ICOORDELT_LIST vertices;     // vertices
  TBOX box;                     // bounding box
  PolyBlockType type;              // Type of this region.
};

// Class to iterate the scanlines of a polygon.
class PB_LINE_IT {
 public:
  PB_LINE_IT(POLY_BLOCK *blkptr) {
    block = blkptr;
  }

  NEWDELETE2(PB_LINE_IT)

  void set_to_block(POLY_BLOCK * blkptr) {
    block = blkptr;
  }

  // Returns a list of runs of pixels for the given y coord.
  // Each element of the returned list is the start (x) and extent(y) of
  // a run inside the region.
  // Delete the returned list after use.
  ICOORDELT_LIST *get_line(inT16 y);

 private:
  POLY_BLOCK * block;
};
/////////////////////////////////////////////////////////////////polyblk////////////////////////////////////////

/////////////////////////////////////////////////////////////////pdblock////////////////////////////////////////
class PDBLK;              //forward decl

CLISTIZEH (PDBLK)
///page block
class PDBLK
{
    friend class BLOCK_RECT_IT;    //< block iterator

    public:
    ///empty constructor
    PDBLK()
    {
        hand_poly = NULL;
        index_ = 0;
    }

    ///simple constructor

    //< bottom left               //< top right
    PDBLK(inT16 xmin, inT16 ymin, inT16 xmax, inT16 ymax);

    ///set vertex lists
    ///@param left list of left vertices
    ///@param right list of right vertices
    void set_sides(ICOORDELT_LIST *left, ICOORDELT_LIST *right);

    ///destructor
    ~PDBLK ()
    {
        if (hand_poly) delete hand_poly;
    }

    POLY_BLOCK *poly_block()
    {
        return hand_poly;
    }

    ///set the poly block
    void set_poly_block(POLY_BLOCK *blk)
    {
        hand_poly = blk;
    }

    ///get box        //bottom left
    void bounding_box(ICOORD &bottom_left, ICOORD &top_right) const
    {  //topright
        bottom_left = box.botleft();
        top_right = box.topright();
    }

    ///get real box
    const TBOX &bounding_box() const
    {
        return box;
    }

    int index() const
    {
        return index_;
    }

    void set_index(int value)
    {
        index_ = value;
    }

    ///is pt inside block
    BOOL8 contains(ICOORD pt);

    /// reposition block
    void move(const ICOORD vec);  // by vector

    ///draw histogram
    ///@param window window to draw in
    ///@param serial serial number
    ///@param colour colour to draw in
    void plot(ScrollView* window, inT32 serial, ScrollView::Color colour);

    ///show image
    ///@param image image to show
    ///@param window window to show in
    void show(IMAGE *image, ScrollView* window);

    ///assignment
    ///@param source from this
    PDBLK & operator= (const PDBLK & source);

    protected:
    POLY_BLOCK *hand_poly;       //< wierd as well
    ICOORDELT_LIST leftside;     //< left side vertices
    ICOORDELT_LIST rightside;    //< right side vertices
    TBOX box;                    //< bounding box
    int index_;                  //< Serial number of this block.
};

class BLOCK_RECT_IT       //rectangle iterator
{
public:
    ///constructor
    ///@param blkptr block to iterate
    BLOCK_RECT_IT(PDBLK *blkptr);

    ///start (new) block
    NEWDELETE2 (BLOCK_RECT_IT) void set_to_block(PDBLK * blkptr);           //block to iterate

    ///start iteration
    void start_block();

    ///next rectangle
    void forward();

    ///test end
    BOOL8 cycled_rects()
    {
        return left_it.cycled_list () && right_it.cycled_list ();
    }

    ///current rectangle
    ///@param bleft bottom left
    ///@param tright top right
    void bounding_box(ICOORD &bleft, ICOORD &tright)
    {

        //bottom left
        bleft = ICOORD (left_it.data ()->x (), ymin);

        //top right
        tright = ICOORD (right_it.data ()->x (), ymax);
    }

private:
    inT16 ymin;                  //< bottom of rectangle
    inT16 ymax;                  //< top of rectangle
    PDBLK *block;                //< block to iterate
    ICOORDELT_IT left_it;        //< boundary iterators
    ICOORDELT_IT right_it;
};

///rectangle iterator
class BLOCK_LINE_IT
{
public:
    ///constructor
    ///@param blkptr from block
    BLOCK_LINE_IT (PDBLK * blkptr) :rect_it (blkptr)
    {
        block = blkptr;            //remember block
    }

    ///start (new) block
    ///@param blkptr block to start
    NEWDELETE2 (BLOCK_LINE_IT) void set_to_block (PDBLK * blkptr)
    {
        block = blkptr;            //remember block

        //set iterator
        rect_it.set_to_block (blkptr);
    }

    ///get a line
    ///@param y line to get
    ///@param xext output extent
    inT16 get_line(inT16 y, inT16 &xext);

private:
    PDBLK * block;               //< block to iterate
    BLOCK_RECT_IT rect_it;       //< rectangle iterator
};

int decreasing_top_order(const void *row1, const void *row2);
/////////////////////////////////////////////////////////////////pdblock////////////////////////////////////////

/////////////////////////////////////////////////////////////////ocrblock////////////////////////////////////////
ELISTIZEH_S (BLOCK)
class BLOCK : public ELIST_LINK, public PDBLK //page block
{
    friend class BLOCK_RECT_IT;    //block iterator

public:
BLOCK() : re_rotation_(1.0f, 0.0f), classify_rotation_(1.0f, 0.0f),skew_(1.0f, 0.0f)
{
    hand_poly = NULL;
}

BLOCK(const char *name,  //< filename
      BOOL8 prop,        //< proportional
      inT16 kern,        //< kerning
      inT16 space,       //< spacing
      inT16 xmin,        //< bottom left
      inT16 ymin,
      inT16 xmax,        //< top right
      inT16 ymax);

~BLOCK () {}

/**
   * set space size etc.
   * @param prop proportional
   * @param kern inter char size
   * @param space inter word size
   * @param ch_pitch pitch if fixed
   */
void set_stats(BOOL8 prop, inT16 kern, inT16 space, inT16 ch_pitch)
{
    proportional = prop;
    kerning = (inT8) kern;
    spacing = space;
    pitch = ch_pitch;
}

/// set char size
void set_xheight(inT32 height)
{
    xheight = height;
}

/// set font class
void set_font_class(inT16 font)
{
    font_class = font;
}

/// return proportional
BOOL8 prop() const {
    return proportional;
}

/// return pitch
inT32 fixed_pitch() const
{
    return pitch;
}

/// return kerning
inT16 kern() const
{
    return kerning;
}

/// return font class
inT16 font() const
{
    return font_class;
}

/// return spacing
inT16 space() const
{
    return spacing;
}

/// return filename
const char *name() const
{
    return filename.string ();
}

/// return xheight
inT32 x_height() const
{
    return xheight;
}

float cell_over_xheight() const
{
    return cell_over_xheight_;
}

void set_cell_over_xheight(float ratio)
{
    cell_over_xheight_ = ratio;
}

/// get rows
ROW_LIST *row_list()
{
    return &rows;
}

/// get blobs
C_BLOB_LIST *blob_list()
{
    return &c_blobs;
}

C_BLOB_LIST *reject_blobs()
{
    return &rej_blobs;
}

FCOORD re_rotation() const
{
    return re_rotation_;         // How to transform coords back to image.
}

void set_re_rotation(const FCOORD& rotation)
{
    re_rotation_ = rotation;
}

FCOORD classify_rotation() const
{
    return classify_rotation_;   // Apply this before classifying.
}

void set_classify_rotation(const FCOORD& rotation)
{
    classify_rotation_ = rotation;
}

FCOORD skew() const
{
    return skew_;                // Direction of true horizontal.
}

void set_skew(const FCOORD& skew)
{
    skew_ = skew;
}

const ICOORD& median_size() const
{
    return median_size_;
}

void set_median_size(int x, int y)
{
    median_size_.set_x(x);
    median_size_.set_y(y);
}

void rotate(const FCOORD& rotation);

/// decreasing y order
void sort_rows();

/// shrink white space
void compress();

/// check proportional
void check_pitch();

/// shrink white space and move by vector
void compress(const ICOORD vec);

/// dump whole table
void print(FILE *fp, BOOL8 dump);

/// set ptrs to counts
void prep_serialise()
{
    filename.prep_serialise();
    rows.prep_serialise();
    c_blobs.prep_serialise();
    rej_blobs.prep_serialise();
    leftside.prep_serialise();
    rightside.prep_serialise();
}

void dump(FILE *f)
{
    filename.dump(f);
    rows.dump(f);
    c_blobs.dump(f);
    rej_blobs.dump(f);
    leftside.dump(f);
    rightside.dump(f);
}

/// read external bits
void de_dump(FILE *f)
{
    filename.de_dump(f);
    rows.de_dump(f);
    c_blobs.de_dump(f);
    rej_blobs.de_dump(f);
    leftside.de_dump(f);
    rightside.de_dump(f);
}

make_serialise(BLOCK)

BLOCK& operator=(const BLOCK & source);

private:
BOOL8 proportional;          //< proportional
inT8 kerning;                //< inter blob gap
inT16 spacing;               //< inter word gap
inT16 pitch;                 //< pitch of non-props
inT16 font_class;            //< correct font class
inT32 xheight;               //< height of chars
float cell_over_xheight_;    //< Ratio of cell height to xheight.
STRING filename;             //< name of block
ROW_LIST rows;               //< rows in block
C_BLOB_LIST c_blobs;         //< before textord
C_BLOB_LIST rej_blobs;       //< duff stuff
FCOORD re_rotation_;         //< How to transform coords back to image.
FCOORD classify_rotation_;   //< Apply this before classifying.
FCOORD skew_;                //< Direction of true horizontal.
ICOORD median_size_;         //< Median size of blobs.
};

int decreasing_top_order(const void *row1, const void *row2);
/////////////////////////////////////////////////////////////////ocrblock////////////////////////////////////////

/////////////////////////////////////////////////////////////////varabled////////////////////////////////////////
class SVMenuNode;

/** A list of all possible variable types used. */
enum VarType {
  VT_INTEGER,
  VT_BOOLEAN,
  VT_STRING,
  VT_DOUBLE
};

/**
 * A rather hackish helper structure which can take any kind of variable input
 * (defined by VarType) and do a couple of common operations on them, like
 * comparisond or getting its value. It is used in the context of the
 * VariablesEditor as a bridge from the internal tesseract variables to the
 * ones displayed by the ScrollView server.
 */
class VariableContent : public ELIST_LINK {
 public:
  /** Compare two VC objects by their name. */
  static int Compare(const void* v1, const void* v2);

  /** Gets a VC object identified by its ID. */
  static VariableContent* GetVariableContentById(int id);

  /** Constructors for the various VarTypes. */
  VariableContent() {
  }
  VariableContent(STRING_VARIABLE* it);
  VariableContent(INT_VARIABLE* it);
  VariableContent(BOOL_VARIABLE* it);
  VariableContent(double_VARIABLE* it);


  /** Getters and Setters. */
  void SetValue(const char* val);
  const char* GetValue() const;
  const char* GetName() const;
  const char* GetDescription() const;

  int GetId() { return my_id_; }
  bool HasChanged() { return changed_; }

 private:
  /** The unique ID of this VC object. */
  int my_id_;
  /** Whether the variable was changed_ and thus needs to be rewritten. */
  bool changed_;
  /** The actual vartype of this VC object. */
  VarType var_type_;

  STRING_VARIABLE* sIt;
  INT_VARIABLE* iIt;
  BOOL_VARIABLE* bIt;
  double_VARIABLE* dIt;
};

ELISTIZEH(VariableContent)

/**
 * The variables editor enables the user to edit all the variables used within
 * tesseract. It can be invoked on its own, but is supposed to be invoked by
 * the program editor.
 */
class VariablesEditor : public SVEventHandler {
 public:
  /**
   * Integrate the variables editor as popupmenu into the existing scrollview
   * window (usually the pg editor). If sv == null, create a new empty
   * empty window and attach the variables editor to that window (ugly).
   */
  VariablesEditor(const Tesseract*, ScrollView* sv = NULL);

  /** Event listener. Waits for SVET_POPUP events and processes them. */
  void Notify(const SVEvent* sve);

 private:
  /**
   * Gets the up to the first 3 prefixes from s (split by _).
   * For example, tesseract_foo_bar will be split into tesseract, foo, and bar.
   */
  void GetPrefixes(const char* s, STRING* level_one,
                   STRING* level_two, STRING* level_three);

  /**
   * Gets the first n words (split by _) and puts them in t.
   * For example, tesseract_foo_bar with N=2 will yield tesseract_foo_.
   */
  void GetFirstWords(const char *s,  // source string
                     int n,          // number of words
                     char *t);       // target string

  /**
   * Find all editable variables used within tesseract and create a
   * SVMenuNode tree from it.
   */
  SVMenuNode *BuildListOfAllLeaves();

  /** Write all (changed_) variables to a config file. */
  void WriteVars(char* filename, bool changes_only);

  ScrollView* sv_window_;
};
/////////////////////////////////////////////////////////////////varabled////////////////////////////////////////

/////////////////////////////////////////////////////////////////pagewalk////////////////////////////////////////
#define BLOCK_SPACING   20
extern BOOL_VAR_H (current_word_quit, FALSE, "Stop processing this word");
extern BOOL_VAR_H (selection_quit, FALSE, "Stop processing this selection");
TBOX block_list_bounding_box(                        //find bounding box
                            BLOCK_LIST *block_list  //of this block list
                           );
const TBOX block_list_compress(  //shuffle up blocks
                              BLOCK_LIST *block_list);
void block_list_move(                         //move
                     BLOCK_LIST *block_list,  //this list
                     ICOORD vec               //by this vector
                    );
int block_name_order(                      //sort blocks
                     const void *block1p,  //ptr to ptr to block1
                     const void *block2p   //ptr to ptr to block2
                    );
void process_all_blobs (         //process blobs
BLOCK_LIST * block_list,         //blocks to check
BOOL8 blob_processor (           //function to call
                                 //function to call
BLOCK *, ROW *, WERD *, PBLOB *), BOOL8 c_blob_processor(
BLOCK
*,
ROW
*,
WERD
*,
C_BLOB
*));
void process_selected_blobs (    //process blobs
BLOCK_LIST * block_list,         //blocks to check
                                 //function to call
TBOX & selection_box, BOOL8 blob_processor (
                                 //function to call
BLOCK *, ROW *, WERD *, PBLOB *), BOOL8 c_blob_processor (
BLOCK
*,
ROW
*,
WERD
*,
C_BLOB
*));
void process_all_words (         //process words
BLOCK_LIST * block_list,         //blocks to check
BOOL8 word_processor (           //function to call
BLOCK *, ROW *, WERD *));
void process_selected_words (    //process words
BLOCK_LIST * block_list,         //blocks to check
                                 //function to call
TBOX & selection_box, BOOL8 word_processor (
BLOCK
*,
ROW
*,
WERD
*));

void process_all_words_it (      //process words
BLOCK_LIST * block_list,         //blocks to check
BOOL8 word_processor (           //function to call
BLOCK *,
ROW *,
WERD *,
BLOCK_IT &,
ROW_IT &, WERD_IT &));
void process_selected_words_it ( //process words
BLOCK_LIST * block_list,         //blocks to check
                                 //function to call
TBOX & selection_box, BOOL8 word_processor (
BLOCK
*,
ROW
*,
WERD
*,
BLOCK_IT
&,
ROW_IT
&,
WERD_IT
&));
void process_all_blocks (        //process blocks
BLOCK_LIST * block_list,         //blocks to check
BOOL8 block_processor (          //function to call
BLOCK *));
void process_selected_blocks (   //process blocks
BLOCK_LIST * block_list,         //blocks to check
                                 //function to call
TBOX & selection_box, BOOL8 block_processor (
BLOCK
*));
void process_all_rows (          //process words
BLOCK_LIST * block_list,         //blocks to check
BOOL8 row_processor (            //function to call
BLOCK *, ROW *));
void process_selected_rows (     //process rows
BLOCK_LIST * block_list,         //blocks to check
                                 //function to call
TBOX & selection_box, BOOL8 row_processor (
BLOCK
*,
ROW
*));
void process_all_rows_it (       //process words
BLOCK_LIST * block_list,         //blocks to check
BOOL8 row_processor (            //function to call
BLOCK *,
ROW *,
BLOCK_IT &, ROW_IT &));
void process_selected_rows_it (  //process rows
BLOCK_LIST * block_list,         //blocks to check
                                 //function to call
TBOX & selection_box, BOOL8 row_processor (
BLOCK
*,
ROW
*,
BLOCK_IT
&,
ROW_IT
&));
/////////////////////////////////////////////////////////////////pagewalk////////////////////////////////////////

/////////////////////////////////////////////////////////////////blread////////////////////////////////////////
bool read_unlv_file(                    //print list of sides
                     STRING name,        //basename of file
                     inT32 xsize,        //image size
                     inT32 ysize,        //image size
                     BLOCK_LIST *blocks  //output list
                    );
void FullPageBlock(int width, int height, BLOCK_LIST *blocks);
/////////////////////////////////////////////////////////////////blread////////////////////////////////////////

/////////////////////////////////////////////////////////////////statistc////////////////////////////////////////
class STATS               //statistics package
{
  inT32 rangemin;                //min of range
  inT32 rangemax;                //max of range
  inT32 total_count;             //no of samples
  inT32 *buckets;                //array of cells

  public:
    STATS(             //constructor
          inT32 min,   //min of range
          inT32 max);  //max of range

    STATS();  //empty for arrays

    ~STATS ();                   //destructor

    bool set_range(             //change range
                   inT32 min,   //min of range
                   inT32 max);  //max of range

    void clear();  //empty buckets

    void add(               //add sample
             inT32 value,   //bucket
             inT32 count);  //no to add

    inT32 mode();  //get mode of samples

    float mean();  //get mean of samples

    float sd();  //standard deviation

    //percentile
    float ile(float frac);  //[0,1] for percentil

    inT32 min_bucket();  //Find min

    inT32 max_bucket();  //Find max

    float median();  //get median of samples

    //apply blurring
    void smooth(inT32 factor);  //filter to stats

    inT32 cluster(                     //cluster samples
                  float lower,         //thresholds
                  float upper,
                  float multiple,      //distance threshold
                  inT32 max_clusters,  //max no to make
                  STATS *clusters);    //array of clusters

    //access function //pile to count
    inT32 pile_count(inT32 value)
    {
      return value > rangemin ? (value < rangemax ? buckets[value - rangemin] : buckets[rangemax - rangemin - 1]) : buckets[0];
    }

    //access function
    inT32 get_total()
    {
      return total_count;        //total of all piles
    }

    //test local minness
    BOOL8 local_min(inT32 x);

    void print(              //print summary/table
               FILE *fp,     //file to print on
               BOOL8 dump);  //dump whole table

    void short_print(              //print summary/table
                     FILE *fp,     //file to print on
                     BOOL8 dump);  //dump whole table

    void plot(                 //draw histogram rect
              ScrollView* window,   //window to draw in
              float xorigin,   //origin of histo
              float yorigin,   //gram
              float xscale,    //size of one unit
              float yscale,    //size of one uint
              ScrollView::Color colour);  //colour to draw in

    void plotline(                 //draw histogram line
                  ScrollView* window,   //window to draw in
                  float xorigin,   //origin of histo
                  float yorigin,   //gram
                  float xscale,    //size of one unit
                  float yscale,    //size of one uint
                  ScrollView::Color colour);  //colour to draw in
};

inT32 choose_nth_item(               //fast median
                             inT32 index,   //index to choose
                             float *array,  //array of items
                             inT32 count    //no of items
                            );

inT32 choose_nth_item (   //fast median
inT32 index,                     //index to choose
void *array,                     //array of items
inT32 count,                     //no of items
size_t size,                     //element size
                                 //comparator
int (*compar) (const void *, const void *)
);

void swap_entries(               //swap in place
                  void *array,   //array of entries
                  size_t size,   //size of entry
                  inT32 index1,  //entries to swap
                  inT32 index2);
/////////////////////////////////////////////////////////////////statistc////////////////////////////////////////

/////////////////////////////////////////////////////////////////bbgrid////////////////////////////////////////
class BLOCK;
#ifdef HAVE_LIBLEPT
// Helper function to return a scaled Pix with one pixel per grid cell,
// set (black) where the given outline enters the corresponding grid cell,
// and clear where the outline does not touch the grid cell.
// Also returns the grid coords of the bottom-left of the Pix, in *left
// and *bottom, which corresponds to (0, 0) on the Pix.
// Note that the Pix is used upside-down, with (0, 0) being the bottom-left.
Pix* TraceOutlineOnReducedPix(C_OUTLINE* outline, int gridsize, ICOORD bleft, int* left, int* bottom);

// As TraceOutlineOnReducedPix above, but on a BLOCK instead of a C_OUTLINE.
Pix* TraceBlockOnReducedPix(BLOCK* block, int gridsize, ICOORD bleft, int* left, int* bottom);
#endif

template<class BBC, class BBC_CLIST, class BBC_C_IT> class GridSearch;

// The BBGrid class holds C_LISTs of template classes BBC (bounding box class)
// in a grid for fast neighbour access.
// The BBC class must have a member const TBOX& bounding_box() const.
// The BBC class must have been CLISTIZEH'ed elsewhere to make the
// list class BBC_CLIST and the iterator BBC_C_IT.
// Use of C_LISTs enables BBCs to exist in multiple cells simultaneously.
// As a consequence, ownership of BBCs is assumed to be elsewhere and
// persistent for at least the life of the BBGrid, or at least until Clear is
// called which removes all references to inserted objects without actually
// deleting them.
// Most uses derive a class from a specific instantiation of BBGrid,
// thereby making most of the ugly template notation go away.
// The friend class GridSearch, with the same template arguments, is
// used to search a grid efficiently in one of several search patterns.
template<class BBC, class BBC_CLIST, class BBC_C_IT> class BBGrid
{
    friend class GridSearch<BBC, BBC_CLIST, BBC_C_IT>;
public:
    BBGrid();
    BBGrid(int gridsize, const ICOORD& bleft, const ICOORD& tright);
    virtual ~BBGrid();

    // (Re)Initialize the grid. The gridsize is the size in pixels of each cell,
    // and bleft, tright are the bounding box of everything to go in it.
    void Init(int gridsize, const ICOORD& bleft, const ICOORD& tright);

    // Empty all the lists but leave the grid itself intact.
    void Clear();
    // Deallocate the data in the lists but otherwise leave the lists and the grid
    // intact.
    void ClearGridData(void (*free_method)(BBC*));

    // Simple accessors.
    int gridsize() const
    {
        return gridsize_;
    }

    int gridwidth() const
    {
        return gridwidth_;
    }

    int gridheight() const
    {
        return gridheight_;
    }

    ICOORD bleft() const
    {
        return bleft_;
    }

    ICOORD tright() const
    {
        return tright_;
    }

    // Insert a bbox into the appropriate place in the grid.
    // If h_spread, then all cells covered horizontally by the box are
    // used, otherwise, just the bottom-left. Similarly for v_spread.
    // WARNING: InsertBBox may invalidate an active GridSearch. Call
    // RepositionIterator() on any GridSearches that are active on this grid.
    void InsertBBox(bool h_spread, bool v_spread, BBC* bbox);
#ifdef HAVE_LIBLEPT
    // Using a pix from TraceOutlineOnReducedPix or TraceBlockOnReducedPix, in
    // which each pixel corresponds to a grid cell, insert a bbox into every
    // place in the grid where the corresponding pixel is 1. The Pix is handled
    // upside-down to match the Tesseract coordinate system. (As created by
    // TraceOutlineOnReducedPix or TraceBlockOnReducedPix.)
    // (0, 0) in the pix corresponds to (left, bottom) in the
    // grid (in grid coords), and the pix works up the grid from there.
    // WARNING: InsertPixPtBBox may invalidate an active GridSearch. Call
    // RepositionIterator() on any GridSearches that are active on this grid.
    void InsertPixPtBBox(int left, int bottom, Pix* pix, BBC* bbox);
#endif
    // Remove the bbox from the grid.
    // WARNING: Any GridSearch operating on this grid could be invalidated!
    // If a GridSearch is operating, call GridSearch::RemoveBBox() instead.
    void RemoveBBox(BBC* bbox);

    // Compute the given grid coordinates from image coords.
    void GridCoords(int x, int y, int* grid_x, int* grid_y);

    // Clip the given grid coordinates to fit within the grid.
    void ClipGridCoords(int* x, int* y);

    // Make a window of an appropriate size to display things in the grid.
    ScrollView* MakeWindow(int x, int y, const char* window_name);

    // Display the bounding boxes of the BLOBNBOXes in this grid.
    // Use of this function requires an additional member of the BBC class:
    // ScrollView::Color BBC::BoxColor() const.
    void DisplayBoxes(ScrollView* window);

    // ASSERT_HOST that every cell contains no more than one copy of each entry.
    void AssertNoDuplicates();

    // Handle a click event in a display window.
    virtual void HandleClick(int x, int y);

protected:
    int gridsize_;     // Pixel size of each grid cell.
    int gridwidth_;    // Size of the grid in cells.
    int gridheight_;
    int gridbuckets_;  // Total cells in grid.
    ICOORD bleft_;     // Pixel coords of bottom-left of grid.
    ICOORD tright_;    // Pixel coords of top-right of grid.
    BBC_CLIST* grid_;  // 2-d array of CLISTS of BBC elements.

private:
};

// The GridSearch class enables neighbourhood searching on a BBGrid.
template<class BBC, class BBC_CLIST, class BBC_C_IT> class GridSearch
{
public:
    GridSearch(BBGrid<BBC, BBC_CLIST, BBC_C_IT>* grid) : grid_(grid), previous_return_(NULL), next_return_(NULL)
    {
    }

    // Get the grid x, y coords of the most recently returned BBC.
    int GridX() const
    {
        return x_;
    }

    int GridY() const
    {
        return y_;
    }

    // Apart from full search, all other searches return a box several
    // times if the box is inserted with h_spread or v_spread.
    // This method will return true for only one occurrance of each box
    // that was inserted with both h_spread and v_spread as true.
    // It will usually return false for boxes that were not inserted with
    // both h_spread=true and v_spread=true
    bool ReturnedSeedElement() const
    {
        TBOX box = previous_return_->bounding_box();
        int x_center = (box.left()+box.right())/2;
        int y_center = (box.top()+box.bottom())/2;
        int grid_x, grid_y;
        grid_->GridCoords(x_center, y_center, &grid_x, &grid_y);
        return (x_ == grid_x) && (y_ == grid_y);
    }

    // Various searching iterations... Note that these iterations
    // all share data members, so you can't run more than one iteration
    // in parallel in a single GridSearch instance, but multiple instances
    // can search the same BBGrid in parallel.
    // Note that all the searches can return blobs that may not exactly
    // match the search conditions, since they return everything in the
    // covered grid cells. It is up to the caller to check for
    // appropriateness.

    // Start a new full search. Will iterate all stored blobs, from the top.
    // If the blobs have been inserted using InsertBBox, (not InsertPixPtBBox)
    // then the full search guarantees to return each blob in the grid once.
    // Other searches may return a blob more than once if they have been
    // inserted using h_spread or v_spread.
    void StartFullSearch();

    // Return the next bbox in the search or NULL if done.
    BBC* NextFullSearch();

    // Start a new radius search. Will search in a spiral upto a
    // given maximum radius in grid cells from the given center in pixels.
    void StartRadSearch(int x, int y, int max_radius);

    // Return the next bbox in the radius search or NULL if the
    // maximum radius has been reached.
    BBC* NextRadSearch();

    // Start a new left or right-looking search. Will search to the side
    // for a box that vertically overlaps the given vertical line segment.
    // CAVEAT: This search returns all blobs from the cells to the side
    // of the start, and somewhat below, since there is no guarantee
    // that there may not be a taller object in a lower cell. The
    // blobs returned will include all those that vertically overlap and
    // are no more than twice as high, but may also include some that do
    // not overlap and some that are more than twice as high.
    void StartSideSearch(int x, int ymin, int ymax);

    // Return the next bbox in the side search or NULL if the
    // edge has been reached. Searches left to right or right to left
    // according to the flag.
    BBC* NextSideSearch(bool right_to_left);

    // Start a vertical-looking search. Will search up or down
    // for a box that horizontally overlaps the given line segment.
    void StartVerticalSearch(int xmin, int xmax, int y);

    // Return the next bbox in the vertical search or NULL if the
    // edge has been reached. Searches top to bottom or bottom to top
    // according to the flag.
    BBC* NextVerticalSearch(bool top_to_bottom);

    // Start a rectangular search. Will search for a box that overlaps the
    // given rectangle.
    void StartRectSearch(const TBOX& rect);

    // Return the next bbox in the rectangular search or NULL if complete.
    BBC* NextRectSearch();

    // Remove the last returned BBC. Will not invalidate this. May invalidate
    // any other concurrent GridSearch on the same grid. If any others are
    // in use, call RepositionIterator on those, to continue without harm.
    void RemoveBBox();
    void RepositionIterator();

private:
    // Factored out helper to start a search.
    void CommonStart(int x, int y);

    // Factored out helper to complete a next search.
    BBC* CommonNext();

    // Factored out final return when search is exhausted.
    BBC* CommonEnd();

    // Factored out function to set the iterator to the current x_, y_
    // grid coords and mark the cycle pt.
    void SetIterator();

private:
    // The grid we are searching.
    BBGrid<BBC, BBC_CLIST, BBC_C_IT>* grid_;

    // For executing a search. The different search algorithms use these in
    // different ways, but most use x_origin_ and y_origin_ as the start position.
    int x_origin_;
    int y_origin_;
    int max_radius_;
    int radius_;
    int rad_index_;
    int rad_dir_;
    TBOX rect_;
    int x_;  // The current location in grid coords, of the current search.
    int y_;
    BBC* previous_return_;  // Previous return from Next*.
    BBC* next_return_;  // Current value of it_.data() used for repositioning.

    // An iterator over the list at (x_, y_) in the grid_.
    BBC_C_IT it_;
};

// Sort function to sort a BBC by bounding_box().left().
template<class BBC> int SortByBoxLeft(const void* void1, const void* void2)
{
    // The void*s are actually doubly indirected, so get rid of one level.
    const BBC* p1 = *reinterpret_cast<const BBC* const *>(void1);
    const BBC* p2 = *reinterpret_cast<const BBC* const *>(void2);
    return p1->bounding_box().left() - p2->bounding_box().left();
}

///////////////////////////////////////////////////////////////////////
// BBGrid IMPLEMENTATION.
///////////////////////////////////////////////////////////////////////
template<class BBC, class BBC_CLIST, class BBC_C_IT> BBGrid<BBC, BBC_CLIST, BBC_C_IT>::BBGrid() : grid_(NULL)
{
}

template<class BBC, class BBC_CLIST, class BBC_C_IT> BBGrid<BBC, BBC_CLIST, BBC_C_IT>::BBGrid(int gridsize, const ICOORD& bleft, const ICOORD& tright) : grid_(NULL)
{
    Init(gridsize, bleft, tright);
}

template<class BBC, class BBC_CLIST, class BBC_C_IT> BBGrid<BBC, BBC_CLIST, BBC_C_IT>::~BBGrid()
{
    if (grid_ != NULL) delete [] grid_;
}

// (Re)Initialize the grid. The gridsize is the size in pixels of each cell,
// and bleft, tright are the bounding box of everything to go in it.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void BBGrid<BBC, BBC_CLIST, BBC_C_IT>::Init(int gridsize, const ICOORD& bleft, const ICOORD& tright)
{
    gridsize_ = gridsize;
    bleft_ = bleft;
    tright_ = tright;

    if (grid_ != NULL)
    {
        delete [] grid_;
    }

    if (gridsize_ == 0)
    {
        gridsize_ = 1;
    }

    gridwidth_ = (tright.x() - bleft.x() + gridsize_ - 1) / gridsize_;
    gridheight_ = (tright.y() - bleft.y() + gridsize_ - 1) / gridsize_;
    gridbuckets_ = gridwidth_ * gridheight_;
    grid_ = new BBC_CLIST[gridbuckets_];
}

// Clear all lists, but leave the array of lists present.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void BBGrid<BBC, BBC_CLIST, BBC_C_IT>::Clear()
{
    for (int i = 0; i < gridbuckets_; ++i)
    {
        grid_[i].shallow_clear();
    }
}

// Deallocate the data in the lists but otherwise leave the lists and the grid
// intact.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void BBGrid<BBC, BBC_CLIST, BBC_C_IT>::ClearGridData(void (*free_method)(BBC*))
{
    if (grid_ == NULL) return;
    GridSearch<BBC, BBC_CLIST, BBC_C_IT> search(this);
    search.StartFullSearch();
    BBC* bb;
    BBC_CLIST bb_list;
    BBC_C_IT it(&bb_list);

    while ((bb = search.NextFullSearch()) != NULL)
    {
        it.add_after_then_move(bb);
    }

    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
    {
        free_method(it.data());
    }
}

// Insert a bbox into the appropriate place in the grid.
// If h_spread, then all cells covered horizontally by the box are
// used, otherwise, just the bottom-left. Similarly for v_spread.
// WARNING: InsertBBox may invalidate an active GridSearch. Call
// RepositionIterator() on any GridSearches that are active on this grid.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void BBGrid<BBC, BBC_CLIST, BBC_C_IT>::InsertBBox(bool h_spread, bool v_spread, BBC* bbox)
{
    TBOX box = bbox->bounding_box();
    int start_x, start_y, end_x, end_y;
    GridCoords(box.left(), box.bottom(), &start_x, &start_y);
    GridCoords(box.right(), box.top(), &end_x, &end_y);

    if (!h_spread)
    {
        end_x = start_x;
    }

    if (!v_spread)
    {
        end_y = start_y;
    }

    int grid_index = start_y * gridwidth_;
    for (int y = start_y; y <= end_y; ++y, grid_index += gridwidth_)
    {
        for (int x = start_x; x <= end_x; ++x)
        {
            grid_[grid_index + x].add_sorted(SortByBoxLeft<BBC>, true, bbox);
        }
    }
}

#ifdef HAVE_LIBLEPT
// Using a pix from TraceOutlineOnReducedPix or TraceBlockOnReducedPix, in
// which each pixel corresponds to a grid cell, insert a bbox into every
// place in the grid where the corresponding pixel is 1. The Pix is handled
// upside-down to match the Tesseract coordinate system. (As created by
// TraceOutlineOnReducedPix or TraceBlockOnReducedPix.)
// (0, 0) in the pix corresponds to (left, bottom) in the
// grid (in grid coords), and the pix works up the grid from there.
// WARNING: InsertPixPtBBox may invalidate an active GridSearch. Call
// RepositionIterator() on any GridSearches that are active on this grid.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void BBGrid<BBC, BBC_CLIST, BBC_C_IT>::InsertPixPtBBox(int left, int bottom, Pix* pix, BBC* bbox)
{
    int width = pixGetWidth(pix);
    int height = pixGetHeight(pix);
    for (int y = 0; y < height; ++y)
    {
        l_uint32* data = pixGetData(pix) + y * pixGetWpl(pix);
        for (int x = 0; x < width; ++x)
        {
            if (GET_DATA_BIT(data, x))
            {
                grid_[(bottom + y) * gridwidth_ + x + left].add_sorted(SortByBoxLeft<BBC>, true, bbox);
            }
        }
    }
}
#endif

// Remove the bbox from the grid.
// WARNING: Any GridSearch operating on this grid could be invalidated!
// If a GridSearch is operating, call GridSearch::RemoveBBox() instead.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void BBGrid<BBC, BBC_CLIST, BBC_C_IT>::RemoveBBox(BBC* bbox)
{
    TBOX box = bbox->bounding_box();
    int start_x, start_y, end_x, end_y;
    GridCoords(box.left(), box.bottom(), &start_x, &start_y);
    GridCoords(box.right(), box.top(), &end_x, &end_y);
    int grid_index = start_y * gridwidth_;

    for (int y = start_y; y <= end_y; ++y, grid_index += gridwidth_)
    {
        for (int x = start_x; x <= end_x; ++x)
        {
            BBC_C_IT it(&grid_[grid_index + x]);

            for (it.mark_cycle_pt(); !it.cycled_list(); it.forward())
            {
                if (it.data() == bbox) it.extract();
            }
        }
    }
}

// Compute the given grid coordinates from image coords.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void BBGrid<BBC, BBC_CLIST, BBC_C_IT>::GridCoords(int x, int y,
                                                  int* grid_x, int* grid_y) {
    *grid_x = (x - bleft_.x()) / gridsize_;
    *grid_y = (y - bleft_.y()) / gridsize_;
    ClipGridCoords(grid_x, grid_y);
}

// Clip the given grid coordinates to fit within the grid.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void BBGrid<BBC, BBC_CLIST, BBC_C_IT>::ClipGridCoords(int* x, int* y)
{
    if (*x < 0) *x = 0;
    if (*x >= gridwidth_) *x = gridwidth_ - 1;
    if (*y < 0) *y = 0;
    if (*y >= gridheight_) *y = gridheight_ - 1;
}

template<class G> class TabEventHandler : public SVEventHandler
{
public:
    explicit TabEventHandler(G* grid) : grid_(grid){}

    void Notify(const SVEvent* sv_event)
    {
        if (sv_event->type == SVET_CLICK)
        {
            grid_->HandleClick(sv_event->x, sv_event->y);
        }
    }
private:
    G* grid_;
};

// Make a window of an appropriate size to display things in the grid.
// Position the window at the given x,y.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
ScrollView* BBGrid<BBC, BBC_CLIST, BBC_C_IT>::MakeWindow(int x, int y, const char* window_name)
{
    ScrollView* tab_win = NULL;
#ifndef GRAPHICS_DISABLED
    tab_win = new ScrollView(window_name, x, y, tright_.x() - bleft_.x(), tright_.y() - bleft_.y(), tright_.x() - bleft_.x(), tright_.y() - bleft_.y(), true);
    TabEventHandler<BBGrid<BBC, BBC_CLIST, BBC_C_IT> >* handler = new TabEventHandler<BBGrid<BBC, BBC_CLIST, BBC_C_IT> >(this);
    tab_win->AddEventHandler(handler);
    tab_win->Pen(ScrollView::GREY);
    tab_win->Rectangle(0, 0, tright_.x(), tright_.y());
#endif
    return tab_win;
}

// Create a window at (x,y) and display the bounding boxes of the
// BLOBNBOXes in this grid.
// Use of this function requires an additional member of the BBC class:
// ScrollView::Color BBC::BoxColor() const.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void BBGrid<BBC, BBC_CLIST, BBC_C_IT>::DisplayBoxes(ScrollView* tab_win)
{
#ifndef GRAPHICS_DISABLED
    tab_win->Pen(ScrollView::BLUE);
    tab_win->Brush(ScrollView::NONE);

    // For every bbox in the grid, display it.
    GridSearch<BBC, BBC_CLIST, BBC_C_IT> gsearch(this);
    gsearch.StartFullSearch();
    BBC* bbox;

    while ((bbox = gsearch.NextFullSearch()) != NULL)
    {
        TBOX box = bbox->bounding_box();
        int left_x = box.left();
        int right_x = box.right();
        int top_y = box.top();
        int bottom_y = box.bottom();
        ScrollView::Color box_color = bbox->BoxColor();
        tab_win->Pen(box_color);
        tab_win->Rectangle(left_x, bottom_y, right_x, top_y);
    }
    tab_win->Update();
#endif
}

// ASSERT_HOST that every cell contains no more than one copy of each entry.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void BBGrid<BBC, BBC_CLIST, BBC_C_IT>::AssertNoDuplicates()
{
    // Process all grid cells.
    for (int i = gridwidth_ * gridheight_ - 1; i >= 0; --i)
    {
        // Iterate over all elements excent the last.
        for (BBC_C_IT it(&grid_[i]); !it.at_last(); it.forward())
        {
            BBC* ptr = it.data();
            BBC_C_IT it2(it);

            // None of the rest of the elements in the list should equal ptr.
            for (it2.forward(); !it2.at_first(); it2.forward())
            {
                ASSERT_HOST(it2.data() != ptr);
            }
        }
    }
}

// Handle a click event in a display window.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void BBGrid<BBC, BBC_CLIST, BBC_C_IT>::HandleClick(int x, int y)
{
    tprintf("Click at (%d, %d)\n", x, y);
}

///////////////////////////////////////////////////////////////////////
// GridSearch IMPLEMENTATION.
///////////////////////////////////////////////////////////////////////

// Start a new full search. Will iterate all stored blobs.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void GridSearch<BBC, BBC_CLIST, BBC_C_IT>::StartFullSearch()
{
    // Full search uses x_ and y_ as the current grid
    // cell being searched.
    CommonStart(grid_->bleft_.x(), grid_->tright_.y());
}

// Return the next bbox in the search or NULL if done.
// The other searches will return a box that overlaps the grid cell
// thereby duplicating boxes, but NextFullSearch only returns each box once.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
BBC* GridSearch<BBC, BBC_CLIST, BBC_C_IT>::NextFullSearch()
{
    int x;
    int y;
    do
    {
        while (it_.cycled_list())
        {
            ++x_;
            if (x_ >= grid_->gridwidth_)
            {
                --y_;
                if (y_ < 0)
                    return CommonEnd();
                x_ = 0;
            }
            SetIterator();
        }

        CommonNext();
        TBOX box = previous_return_->bounding_box();
        grid_->GridCoords(box.left(), box.bottom(), &x, &y);
    } while (x != x_ || y != y_);

    return previous_return_;
}

// Start a new radius search.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void GridSearch<BBC, BBC_CLIST, BBC_C_IT>::StartRadSearch(int x, int y, int max_radius)
{
    // Rad search uses x_origin_ and y_origin_ as the center of the circle.
    // The radius_ is the radius of the (diamond-shaped) circle and
    // rad_index/rad_dir_ combine to determine the position around it.
    max_radius_ = max_radius;
    radius_ = 0;
    rad_index_ = 0;
    rad_dir_ = 3;
    CommonStart(x, y);
}

// Return the next bbox in the radius search or NULL if the
// maximum radius has been reached.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
BBC* GridSearch<BBC, BBC_CLIST, BBC_C_IT>::NextRadSearch()
{
    while (it_.cycled_list())
    {
        ++rad_index_;
        if (rad_index_ >= radius_)
        {
            ++rad_dir_;
            rad_index_ = 0;

            if (rad_dir_ >= 4)
            {
                ++radius_;
                if (radius_ > max_radius_)
                {
                    return CommonEnd();
                }

                rad_dir_ = 0;
            }
        }

        ICOORD offset = C_OUTLINE::chain_step(rad_dir_);
        offset *= radius_ - rad_index_;
        offset += C_OUTLINE::chain_step(rad_dir_ + 1) * rad_index_;
        x_ = x_origin_ + offset.x();
        y_ = y_origin_ + offset.y();
        if (x_ >= 0 && x_ < grid_->gridwidth_ && y_ >= 0 && y_ < grid_->gridheight_)
        {
            SetIterator();
        }
    }

    return CommonNext();
}

// Start a new left or right-looking search. Will search to the side
// for a box that vertically overlaps the given vertical line segment.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void GridSearch<BBC, BBC_CLIST, BBC_C_IT>::StartSideSearch(int x, int ymin, int ymax)
{
    // Right search records the x in x_origin_, the ymax in y_origin_
    // and the size of the vertical strip to search in radius_.
    // To guarantee finding overlapping objects of upto twice the
    // given size, double the height.
    radius_ = ((ymax - ymin) * 2 + grid_->gridsize_ - 1) / grid_->gridsize_;
    rad_index_ = 0;
    CommonStart(x, ymax);
}

// Return the next bbox in the side search or NULL if the
// edge has been reached. Searches left to right or right to left
// according to the flag.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
BBC* GridSearch<BBC, BBC_CLIST, BBC_C_IT>::NextSideSearch(bool right_to_left)
{
    while (it_.cycled_list())
    {
        ++rad_index_;
        if (rad_index_ > radius_)
        {
            if (right_to_left)
            {
                --x_;
            }
            else
            {
                ++x_;
            }

            rad_index_ = 0;
            if (x_ < 0 || x_ >= grid_->gridwidth_)
            {
                return CommonEnd();
            }
        }
        y_ = y_origin_ - rad_index_;
        if (y_ >= 0 && y_ < grid_->gridheight_)
        {
            SetIterator();
        }
    }

    return CommonNext();
}

// Start a vertical-looking search. Will search up or down
// for a box that horizontally overlaps the given line segment.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void GridSearch<BBC, BBC_CLIST, BBC_C_IT>::StartVerticalSearch(int xmin, int xmax, int y)
{
    // Right search records the xmin in x_origin_, the y in y_origin_
    // and the size of the horizontal strip to search in radius_.
    radius_ = (xmax - xmin + grid_->gridsize_ - 1) / grid_->gridsize_;
    rad_index_ = 0;
    CommonStart(xmin, y);
}

// Return the next bbox in the vertical search or NULL if the
// edge has been reached. Searches top to bottom or bottom to top
// according to the flag.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
BBC* GridSearch<BBC, BBC_CLIST, BBC_C_IT>::NextVerticalSearch(bool top_to_bottom)
{
    while (it_.cycled_list())
    {
        ++rad_index_;
        if (rad_index_ > radius_)
        {
            if (top_to_bottom)
            {
                --y_;
            }
            else
            {
                ++y_;
            }

            rad_index_ = 0;
            if (y_ < 0 || y_ >= grid_->gridheight_)
            {
                return CommonEnd();
            }
        }

        x_ = x_origin_ + rad_index_;
        if (x_ >= 0 && x_ < grid_->gridwidth_)
        {
            SetIterator();
        }
    }

    return CommonNext();
}

// Start a rectangular search. Will search for a box that overlaps the
// given rectangle.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void GridSearch<BBC, BBC_CLIST, BBC_C_IT>::StartRectSearch(const TBOX& rect)
{
    // Rect search records the xmin in x_origin_, the ymin in y_origin_
    // and the xmax in max_radius_.
    // The search proceeds left to right, top to bottom.
    rect_ = rect;
    CommonStart(rect.left(), rect.top());

    // - rect.height(),
    grid_->GridCoords(rect.right(), rect.bottom(), &max_radius_, &y_origin_);
}

// Return the next bbox in the rectangular search or NULL if complete.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
BBC* GridSearch<BBC, BBC_CLIST, BBC_C_IT>::NextRectSearch()
{
    while (it_.cycled_list())
    {
        ++x_;
        if (x_ > max_radius_)
        {
            --y_;
            x_ = x_origin_;

            if (y_ < y_origin_)
            {
                return CommonEnd();
            }
        }

        SetIterator();
    }

    return CommonNext();
}

// Remove the last returned BBC. Will not invalidate this. May invalidate
// any other concurrent GridSearch on the same grid. If any others are
// in use, call RepositionIterator on those, to continue without harm.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void GridSearch<BBC, BBC_CLIST, BBC_C_IT>::RemoveBBox()
{
    if (previous_return_ != NULL)
    {
        // Remove all instances of previous_return_ from the list, so the iterator
        // remains valid after removal from the rest of the grid cells.
        // if previous_return_ is not on the list, then it has been removed already.
        BBC* prev_data = NULL;
        BBC* new_previous_return = NULL;
        it_.move_to_first();

        for (it_.mark_cycle_pt(); !it_.cycled_list();)
        {
            if (it_.data() ==  previous_return_)
            {
                new_previous_return = prev_data;
                it_.extract();
                it_.forward();
                next_return_ = it_.cycled_list() ? NULL : it_.data();
            }
            else
            {
                prev_data = it_.data();
                it_.forward();
            }
        }

        grid_->RemoveBBox(previous_return_);
        previous_return_ = new_previous_return;
        RepositionIterator();
    }
}

template<class BBC, class BBC_CLIST, class BBC_C_IT>
void GridSearch<BBC, BBC_CLIST, BBC_C_IT>::RepositionIterator()
{
    // Reset the iterator back to one past the previous return.
    // If the previous_return_ is no longer in the list, then
    // next_return_ serves as a backup.
    it_.move_to_first();
    for (it_.mark_cycle_pt(); !it_.cycled_list(); it_.forward())
    {
        if (it_.data() == previous_return_ || it_.data_relative(1) == next_return_)
        {
            CommonNext();
            return;
        }
    }

    // We ran off the end of the list. Move to a new cell next time.
    previous_return_ = NULL;
    next_return_ = NULL;
}

// Factored out helper to start a search.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void GridSearch<BBC, BBC_CLIST, BBC_C_IT>::CommonStart(int x, int y)
{
    grid_->GridCoords(x, y, &x_origin_, &y_origin_);
    x_ = x_origin_;
    y_ = y_origin_;
    SetIterator();
    previous_return_ = NULL;
    next_return_ = it_.empty() ? NULL : it_.data();
}

// Factored out helper to complete a next search.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
BBC* GridSearch<BBC, BBC_CLIST, BBC_C_IT>::CommonNext()
{
    previous_return_ = it_.data();
    it_.forward();
    next_return_ = it_.cycled_list() ? NULL : it_.data();
    return previous_return_;
}

// Factored out final return when search is exhausted.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
BBC* GridSearch<BBC, BBC_CLIST, BBC_C_IT>::CommonEnd()
{
    previous_return_ = NULL;
    next_return_ = NULL;
    return NULL;
}

// Factored out function to set the iterator to the current x_, y_
// grid coords and mark the cycle pt.
template<class BBC, class BBC_CLIST, class BBC_C_IT>
void GridSearch<BBC, BBC_CLIST, BBC_C_IT>::SetIterator()
{
    it_= &(grid_->grid_[y_ * grid_->gridwidth_ + x_]);
    it_.mark_cycle_pt();
}
/////////////////////////////////////////////////////////////////bbgrid////////////////////////////////////////

/////////////////////////////////////////////////////////////////tabvector////////////////////////////////////////
// The alignment type that a tab vector represents.
// Keep this enum synced with kAlignmentNames in tabvector.cpp.
enum TabAlignment {
  TA_LEFT_ALIGNED,
  TA_LEFT_RAGGED,
  TA_CENTER,
  TA_RIGHT_ALIGNED,
  TA_RIGHT_RAGGED,
  TA_SEPARATOR,
  TA_COUNT
};

#undef TA_CENTER
class BLOBNBOX;
class ScrollView;

CLISTIZEH(BLOBNBOX)

// Forward declarations. The classes use their own list types, so we
// need to make the list types first.
class TabFind;
class TabVector;
class TabConstraint;
typedef BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> BlobGrid;

ELIST2IZEH(TabVector)
CLISTIZEH(TabVector)
ELISTIZEH(TabConstraint)

// TabConstraint is a totally self-contained class to maintain
// a list of [min,max] constraints, each referring to a TabVector.
// The constraints are manipulated through static methods that act
// on a list of constraints. The list itself is cooperatively owned
// by the TabVectors of the constraints on the list and managed
// by implicit reference counting via the elements of the list.
class TabConstraint : public ELIST_LINK {
 public:
  TabConstraint() {
    // This empty constructor is here only so that the class can be ELISTIZED.
    // TODO(rays) change deep_copy in elst.h line 955 to take a callback copier
    // and eliminate CLASSNAME##_copier.
  }

  // Create a constraint for the top or bottom of this TabVector.
  static void CreateConstraint(TabVector* vector, bool is_top);

  // Test to see if the constraints are compatible enough to merge.
  static bool CompatibleConstraints(TabConstraint_LIST* list1,
                                    TabConstraint_LIST* list2);

  // Merge the lists of constraints and update the TabVector pointers.
  // The second list is deleted.
  static void MergeConstraints(TabConstraint_LIST* list1,
                               TabConstraint_LIST* list2);

  // Set all the tops and bottoms as appropriate to a mean of the
  // constrained range. Delete all the constraints and list.
  static void ApplyConstraints(TabConstraint_LIST* constraints);

 private:
  TabConstraint(TabVector* vector, bool is_top);

  // Get the max of the mins and the min of the maxes.
  static void GetConstraints(TabConstraint_LIST* constraints,
                             int* y_min, int* y_max);

  // The TabVector this constraint applies to.
  TabVector* vector_;
  // If true then we refer to the top of the vector_.
  bool is_top_;
  // The allowed range of this vector_.
  int y_min_;
  int y_max_;
};

// Class to hold information about a single vector
// that represents a tab stop or a rule line.
class TabVector : public ELIST2_LINK {
 public:
  TabVector() {
    // TODO(rays) fix this in elst.h line 1076, where it should use the
    // copy constructor instead of operator=.
  }
  ~TabVector();

  // Public factory to build a TabVector from a list of boxes.
  // The TabVector will be of the given alignment type.
  // The input vertical vector is used in fitting, and the output
  // vertical_x, vertical_y have the resulting line vector added to them
  // if the alignment is not ragged.
  // The extended_start_y and extended_end_y are the maximum possible
  // extension to the line segment that can be used to align with others.
  // The input CLIST of BLOBNBOX good_points is consumed and taken over.
  static TabVector* FitVector(TabAlignment alignment, ICOORD vertical,
                              int  extended_start_y, int extended_end_y,
                              BLOBNBOX_CLIST* good_points,
                              int* vertical_x, int* vertical_y);

  // Build a ragged TabVector by copying another's direction, shifting it
  // to match the given blob, and making its initial extent the height
  // of the blob, but its extended bounds from the bounds of the original.
  TabVector(const TabVector& src, TabAlignment alignment,
            const ICOORD& vertical_skew, BLOBNBOX* blob);

  // Simple accessors.
  const ICOORD& startpt() const {
    return startpt_;
  }
  const ICOORD& endpt() const {
    return endpt_;
  }
  int extended_ymax() const {
    return extended_ymax_;
  }
  int extended_ymin() const {
    return extended_ymin_;
  }
  int sort_key() const {
    return sort_key_;
  }
  void set_top_constraints(TabConstraint_LIST* constraints) {
    top_constraints_ = constraints;
  }
  void set_bottom_constraints(TabConstraint_LIST* constraints) {
    bottom_constraints_ = constraints;
  }
  TabVector_CLIST* partners() {
    return &partners_;
  }

  // Inline quasi-accessors that require some computation.

  // Compute the x coordinate at the given y coordinate.
  int XAtY(int y) const {
    int height = endpt_.y() - startpt_.y();
    if (height != 0)
      return (y - startpt_.y()) * (endpt_.x() - startpt_.x()) / height +
             startpt_.x();
    else
      return startpt_.x();
  }

  // Compute the vertical overlap with the other TabVector.
  int VOverlap(const TabVector& other) const {
    return MIN(other.endpt_.y(), endpt_.y()) -
           MAX(other.startpt_.y(), startpt_.y());
  }
  // Compute the vertical overlap with the given y bounds.
  int VOverlap(int top_y, int bottom_y) const {
    return MIN(top_y, endpt_.y()) - MAX(bottom_y, startpt_.y());
  }
  // Compute the extended vertical overlap with the given y bounds.
  int ExtendedOverlap(int top_y, int bottom_y) const {
    return MIN(top_y, extended_ymax_) - MAX(bottom_y, extended_ymin_);
  }

  // Return true if this is a left tab stop, either aligned, or ragged.
  bool IsLeftTab() const {
    return alignment_ == TA_LEFT_ALIGNED || alignment_ == TA_LEFT_RAGGED;
  }
  // Return true if this is a right tab stop, either aligned, or ragged.
  bool IsRightTab() const {
    return alignment_ == TA_RIGHT_ALIGNED || alignment_ == TA_RIGHT_RAGGED;
  }
  // Return true if this is a separator.
  bool IsSeparator() const {
    return alignment_ == TA_SEPARATOR;
  }
  // Return true if this is a ragged tab top, either left or right.
  bool IsRagged() const {
    return alignment_ == TA_LEFT_RAGGED || alignment_ == TA_RIGHT_RAGGED;
  }

  // Return true if this vector is to the left of the other in terms
  // of sort_key_.
  bool IsLeftOf(const TabVector& other) const {
    return sort_key_ < other.sort_key_;
  }

  // Return true if the vector has no partners.
  bool Partnerless() {
    return partners_.empty();
  }

  // Return the number of tab boxes in this vector.
  int BoxCount() {
    return boxes_.length();
  }

  // Lock the vector from refits by clearing the boxes_ list.
  void Freeze() {
    boxes_.shallow_clear();
  }

  // Flip x and y on the ends so a vector can be created from flipped input.
  void XYFlip() {
    int x = startpt_.y();
    startpt_.set_y(startpt_.x());
    startpt_.set_x(x);
    x = endpt_.y();
    endpt_.set_y(endpt_.x());
    endpt_.set_x(x);
  }

  // Separate function to compute the sort key for a given coordinate pair.
  static int SortKey(const ICOORD& vertical, int x, int y) {
    ICOORD pt(x, y);
    return pt * vertical;
  }

  // Return the x at the given y for the given sort key.
  static int XAtY(const ICOORD& vertical, int sort_key, int y) {
    if (vertical.y() != 0)
      return (vertical.x() * y + sort_key) / vertical.y();
    else
      return sort_key;
  }

  // Sort function for E2LIST::sort to sort by sort_key_.
  static int SortVectorsByKey(const void* v1, const void* v2) {
    const TabVector* tv1 = *reinterpret_cast<const TabVector* const *>(v1);
    const TabVector* tv2 = *reinterpret_cast<const TabVector* const *>(v2);
    return tv1->sort_key_ - tv2->sort_key_;
  }

  // More complex members.

  // Extend this vector to include the supplied blob if it doesn't
  // already have it.
  void ExtendToBox(BLOBNBOX* blob);

  // Set the ycoord of the start and move the xcoord to match.
  void SetYStart(int start_y);
  // Set the ycoord of the end and move the xcoord to match.
  void SetYEnd(int end_y);

  // Rotate the ends by the given vector.
  void Rotate(const FCOORD& rotation);

  // Setup the initial constraints, being the limits of
  // the vector and the extended ends.
  void SetupConstraints();

  // Setup the constraints between the partners of this TabVector.
  void SetupPartnerConstraints();

  // Setup the constraints between this and its partner.
  void SetupPartnerConstraints(TabVector* partner);

  // Use the constraints to modify the top and bottom.
  void ApplyConstraints();

  // Merge close tab vectors of the same side that overlap.
  static void MergeSimilarTabVectors(const ICOORD& vertical,
                                     TabVector_LIST* vectors, BlobGrid* grid);

  // Return true if this vector is the same side, overlaps, and close
  // enough to the other to be merged.
  bool SimilarTo(const ICOORD& vertical,
                 const TabVector& other, BlobGrid* grid) const;

  // Eat the other TabVector into this and delete it.
  void MergeWith(const ICOORD& vertical, TabVector* other);

  // Add a new element to the list of partner TabVectors.
  // Partners must be added in order of increasing y coordinate of the text line
  // that makes them partners.
  // Groups of identical partners are merged into one.
  void AddPartner(TabVector* partner);

  // Return true if other is a partner of this.
  bool IsAPartner(const TabVector* other);

  // Print basic information about this tab vector.
  void Print(const char* prefix);

  // Print basic information about this tab vector and every box in it.
  void Debug(const char* prefix);

  // Draw this tabvector in place in the given window.
  void Display(ScrollView* tab_win);

  // Refit the line and/or re-evaluate the vector if the dirty flags are set.
  void FitAndEvaluateIfNeeded(const ICOORD& vertical, TabFind* finder);

  // Evaluate the vector in terms of coverage of its length by good-looking
  // box edges. A good looking box is one where its nearest neighbour on the
  // inside is nearer than half the distance its nearest neighbour on the
  // outside of the putative column. Bad boxes are removed from the line.
  // A second pass then further filters boxes by requiring that the gutter
  // width be a minimum fraction of the mean gutter along the line.
  void Evaluate(const ICOORD& vertical, TabFind* finder);

  // (Re)Fit a line to the stored points. Returns false if the line
  // is degenerate.
  bool Fit(ICOORD vertical, bool force_parallel);

  // Return the partner of this TabVector if the vector qualifies as
  // being a vertical text line, otherwise NULL.
  TabVector* VerticalTextlinePartner();

 private:
  // Constructor is private as the static factory is the external way
  // to build a TabVector.
  TabVector(int extended_ymin, int extended_ymax,
            TabAlignment alignment, BLOBNBOX_CLIST* boxes);

  // Delete this, but first, repoint all the partners to point to
  // replacement. If replacement is NULL, then partner relationships
  // are removed.
  void Delete(TabVector* replacement);

 private:
  // The bottom of the tab line.
  ICOORD startpt_;
  // The top of the tab line.
  ICOORD endpt_;
  // The lowest y that the vector might extend to.
  int extended_ymin_;
  // The highest y that the vector might extend to.
  int extended_ymax_;
  // Perpendicular distance of vector from a given vertical for sorting.
  int sort_key_;
  // Result of Evaluate 0-100. Coverage of line with good boxes.
  int percent_score_;
  // True if the boxes_ list has been modified, so a refit is needed.
  bool needs_refit_;
  // True if a fit has been done, so re-evaluation is needed.
  bool needs_evaluation_;
  // The type of this TabVector.
  TabAlignment alignment_;
  // The list of boxes whose edges are aligned at this TabVector.
  BLOBNBOX_CLIST boxes_;
  // List of TabVectors that have a connection with this via a text line.
  TabVector_CLIST partners_;
  // Constraints used to resolve the exact location of the top and bottom
  // of the tab line.
  TabConstraint_LIST* top_constraints_;
  TabConstraint_LIST* bottom_constraints_;
};
/////////////////////////////////////////////////////////////////tabvector////////////////////////////////////////

/////////////////////////////////////////////////////////////////alignedblob////////////////////////////////////////
enum PITCH_TYPE
{
  PITCH_DUNNO,                   //insufficient data
  PITCH_DEF_FIXED,               //definitely fixed
  PITCH_MAYBE_FIXED,             //could be
  PITCH_DEF_PROP,
  PITCH_MAYBE_PROP,
  PITCH_CORR_FIXED,
  PITCH_CORR_PROP
};

// The possible tab-stop types of each side of a BLOBNBOX.
enum TabType
{
  TT_NONE,         // Not a tab.
  TT_DELETED,      // Not a tab after detailed analysis.
  TT_UNCONFIRMED,  // Initial designation of a tab-stop candidate.
  TT_FAKE,         // Added by interpolation.
  TT_CONFIRMED,    // Aligned with neighbours.
  TT_VLINE         // Detected as a vertical line.
};

// The possible region types of a BLOBNBOX.
// Note: keep all the text types > BRT_UNKNOWN and all the image types less.
// Keep in sync with kBlobTypes in colpartition.cpp and BoxColor below.
enum BlobRegionType
{
  BRT_NOISE,      // Neither text nor image.
  BRT_HLINE,      // Horizontal separator line.
  BRT_RECTIMAGE,  // Rectangular image.
  BRT_POLYIMAGE,  // Non-rectangular image.
  BRT_UNKNOWN,    // Not determined yet.
  BRT_VERT_TEXT,  // Vertical alignment, not necessarily vertically oriented.
  BRT_TEXT,       // Convincing text.

  BRT_COUNT       // Number of possibilities.
};

extern INT_VAR_H(textord_debug_bugs, 0,
                 "Turn on output related to bugs in tab finding");
extern INT_VAR_H(textord_debug_tabfind, 2, "Debug tab finding");
extern BOOL_VAR_H(textord_debug_images, false,
                  "Use greyed image background for debug");
extern BOOL_VAR_H(textord_debug_printable, false,
                  "Make debug windows printable");

// Simple structure to hold the search parameters for AlignedBlob.
// The members are mostly derived from constants, which are
// conditioned on the alignment parameter.
// For finding vertical lines, a different set of constants are
// used, conditioned on the different constructor.
struct AlignedBlobParams
{
    // Constructor to set the parameters for finding aligned and ragged tabs.
    // Vertical_x and vertical_y are the current estimates of the true vertical
    // direction (up) in the image. Height is the height of the starter blob.
    // v_gap_multiple is the multiple of height that will be used as a limit
    // on vertical gap before giving up and calling the line ended.
    // resolution is the original image resolution, and align0 indicates the
    // type of tab stop to be found.
    AlignedBlobParams(int vertical_x, int vertical_y, int height, int v_gap_multiple, int resolution, TabAlignment alignment0);
    // Constructor to set the parameters for finding vertical lines.

    // Vertical_x and vertical_y are the current estimates of the true vertical
    // direction (up) in the image. Width is the width of the starter blob.
    AlignedBlobParams(int vertical_x, int vertical_y, int width);

    // Fit the vertical vector into an ICOORD, which is 16 bit.
    void set_vertical(int vertical_x, int vertical_y);

    double gutter_fraction;  // Multiple of height used for min_gutter.
    bool right_tab;          // We are looking at right edges.
    bool ragged;             // We are looking for a ragged (vs aligned) edge.
    TabAlignment alignment;  // The type we are trying to produce.
    TabType confirmed_type;  // Type to flag blobs if accepted.
    int max_v_gap;           // Max vertical gap to be tolerated.
    int min_gutter;          // Minimum gutter between columns.
    // Tolerances allowed on horizontal alignment of aligned edges.
    int l_align_tolerance;   // Left edges.
    int r_align_tolerance;   // Right edges.
    // Conditions for accepting a line.
    int min_points;          // Minimum number of points to be OK.
    int min_length;          // Min length of completed line.

    ICOORD vertical;         // Current estimate of logical vertical.
};

// The AlignedBlob class contains code to find vertically aligned blobs.
// This is factored out into a separate class, so it can be used by both
// vertical line finding (LineFind) and tabstop finding (TabFind).
class AlignedBlob : public BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT>
{
public:
    AlignedBlob(int gridsize, const ICOORD& bleft, const ICOORD& tright);
    virtual ~AlignedBlob();

    // Return true if the given coordinates are within the test rectangle
    // and the debug level is at least the given detail level.
    static bool WithinTestRegion(int detail_level, int x, int y);

    // Display the tab codes of the BLOBNBOXes in this grid.
    ScrollView* DisplayTabs(const char* window_name, ScrollView* tab_win);

    // Finds a vector corresponding to a set of vertically aligned blob edges
    // running through the given box. The type of vector returned and the
    // search parameters are determined by the AlignedBlobParams.
    // vertical_x and y are updated with an estimate of the real
    // vertical direction. (skew finding.)
    // Returns NULL if no decent vector can be found.
    TabVector* FindVerticalAlignment(AlignedBlobParams align_params, BLOBNBOX* bbox, int* vertical_x, int* vertical_y);

    // Increment the serial number counter and set the string to use
    // for a filename if textord_debug_images is true.
    static void IncrementDebugPix();

    // Return the string to use for a filename if textord_debug_images is true.
    // Use IncrementDebugPix first to set the filename, and each time is
    // to be incremented.
    static const STRING& textord_debug_pix()
    {
        return textord_debug_pix_;
    }

private:
    // Find a set of blobs that are aligned in the given vertical
    // direction with the given blob. Returns a list of aligned
    // blobs and the number in the list.
    // For other parameters see FindAlignedBlob below.
    int AlignTabs(const AlignedBlobParams& params, bool top_to_bottom, BLOBNBOX* bbox, BLOBNBOX_CLIST* good_points, int* end_y);

    // Search vertically for a blob that is aligned with the input bbox.
    // The search parameters are determined by AlignedBlobParams.
    // top_to_bottom tells whether to search down or up.
    // The return value is NULL if nothing was found in the search box
    // or if a blob was found in the gutter. On a NULL return, end_y
    // is set to the edge of the search box or the leading edge of the
    // gutter blob if one was found.
    BLOBNBOX* FindAlignedBlob(const AlignedBlobParams& p, bool top_to_bottom, BLOBNBOX* bbox, int x_start, int* end_y);

    // Name of image file to use if textord_debug_images is true.
    static STRING textord_debug_pix_;
    // Index to image file to use if textord_debug_images is true.
    static int debug_pix_index_;
};
/////////////////////////////////////////////////////////////////alignedblob////////////////////////////////////////

/////////////////////////////////////////////////////////////////tabfind////////////////////////////////////////
class BLOBNBOX;
class BLOBNBOX_LIST;
class TO_BLOCK;
class ScrollView;
struct Pix;
typedef ResultCallback1<bool, int> WidthCallback;

struct AlignedBlobParams;

/** Pixel resolution of column width estimates. */
const int kColumnWidthFactor = 20;

/**
 * The TabFind class contains code to find tab-stops and maintain the
 * vectors_ list of tab vectors.
 * Also provides an interface to find neighbouring blobs
 * in the grid of BLOBNBOXes that is used by multiple subclasses.
 * Searching is a complex operation because of the need to enforce
 * rule/separator lines, and tabstop boundaries, (when available), so
 * as the holder of the list of TabVectors this class provides the functions.
 */
class TabFind : public AlignedBlob {
 public:
  TabFind(int gridsize, const ICOORD& bleft, const ICOORD& tright,
          TabVector_LIST* vlines, int vertical_x, int vertical_y);
  virtual ~TabFind();

  /**
   * Insert a list of blobs into the given grid (not necessarily this).
   * If take_ownership is true, then the blobs are removed from the source list.
   * See InsertBlob for the other arguments.
   */
  void InsertBlobList(bool h_spread, bool v_spread, bool large,
                      BLOBNBOX_LIST* blobs, bool take_ownership,
                      BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT>* grid);

  /**
   * Insert a single blob into the given grid (not necessarily this).
   * If h_spread, then all cells covered horizontally by the box are
   * used, otherwise, just the bottom-left. Similarly for v_spread.
   * If large, then insert only if the bounding box doesn't intersect
   * anything else already in the grid. Returns true if the blob was inserted.
   * A side effect is that the left and right rule edges of the blob are
   * set according to the tab vectors in this (not grid).
   */
  bool InsertBlob(bool h_spread, bool v_spread, bool large, BLOBNBOX* blob,
                  BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT>* grid);

  /**
   * Find the gutter width and distance to inner neighbour for the given blob.
   */
  void GutterWidthAndNeighbourGap(int tab_x, int mean_height,
                                  int max_gutter, bool left,
                                  BLOBNBOX* bbox, int* gutter_width,
                                  int* neighbour_gap);

  /**
   * Find the next adjacent (to left or right) blob on this text line,
   * with the constraint that it must vertically significantly overlap
   * the input box.
   */
  BLOBNBOX* AdjacentBlob(const BLOBNBOX* bbox,
                         bool right_to_left, int gap_limit);

  /**
   * Compute and return, but do not set the type as being BRT_TEXT or
   * BRT_UNKNOWN according to how well it forms a text line.
   */
  BlobRegionType ComputeBlobType(BLOBNBOX* blob);

  /**
   * Return the x-coord that corresponds to the right edge for the given
   * box. If there is a rule line to the right that vertically overlaps it,
   * then return the x-coord of the rule line, otherwise return the right
   * edge of the page. For details see RightTabForBox below.
   */
  int RightEdgeForBox(const TBOX& box, bool crossing, bool extended);
  /**
   * As RightEdgeForBox, but finds the left Edge instead.
   */
  int LeftEdgeForBox(const TBOX& box, bool crossing, bool extended);

  /**
   * Compute the rotation required to deskew, and its inverse rotation.
   */
  void ComputeDeskewVectors(FCOORD* deskew, FCOORD* reskew);

  /**
   * Return true if the given width is close to one of the common
   * widths in column_widths_.
   */
  bool CommonWidth(int width);
  /**
   * Return true if the sizes are more than a
   * factor of 2 different.
   */
  static bool DifferentSizes(int size1, int size2);

  /**
   * Return a callback for testing CommonWidth.
   */
  WidthCallback* WidthCB() {
    return width_cb_;
  }

  /**
   * Return the coords at which to draw the image backdrop.
   */
  const ICOORD& image_origin() const {
    return image_origin_;
  }

 protected:
  /**
  // Accessors
   */
  TabVector_LIST* get_vectors() {
    return &vectors_;
  }

  /**
  // Top-level function to find TabVectors in an input page block.
   */
  void FindTabVectors(int resolution, TabVector_LIST* hlines,
                      BLOBNBOX_LIST* image_blobs, TO_BLOCK* block,
                      FCOORD* reskew, FCOORD* rerotate);

  /**
  // Top-level function to not find TabVectors in an input page block,
  // but setup for single column mode.
   */
  void DontFindTabVectors(int resolution, BLOBNBOX_LIST* image_blobs,
                          TO_BLOCK* block, FCOORD* reskew);

  /**
   * Return the TabVector that corresponds to the right edge for the given
   * box. If there is a TabVector to the right that vertically overlaps it,
   * then return it, otherwise return NULL. Note that Right and Left refer
   * to the position of the TabVector, not its type, ie RightTabForBox
   * returns the nearest TabVector to the right of the box, regardless of
   * its type.
   * If a TabVector crosses right through the box (as opposed to grazing one
   * edge or missing entirely), then crossing false will ignore such a line.
   * Crossing true will return the line for BOTH left and right edges.
   * If extended is true, then TabVectors are considered to extend to their
   * extended_start/end_y, otherwise, just the startpt_ and endpt_.
   * These functions make use of an internal iterator to the vectors_ list
   * for speed when used repeatedly on neighbouring boxes. The caveat is
   * that the iterator must be updated whenever the list is modified.
   */
  TabVector* RightTabForBox(const TBOX& box, bool crossing, bool extended);
  /**
   * As RightTabForBox, but finds the left TabVector instead.
   */
  TabVector* LeftTabForBox(const TBOX& box, bool crossing, bool extended);
  /**
   * Helper function to setup search limits for *TabForBox.
   */
  void SetupTabSearch(int x, int y, int* min_key, int* max_key);

  /**
   * Display the tab vectors found in this grid.
   */
  ScrollView* DisplayTabVectors(ScrollView* tab_win);

 private:
  // First part of FindTabVectors, which may be used twice if the text
  // is mostly of vertical alignment.
  void FindInitialTabVectors(BLOBNBOX_LIST* image_blobs, TO_BLOCK* block);

  // For each box in the grid, decide whether it is a candidate tab-stop,
  // and if so add it to the tab_grid_.
  ScrollView* FindTabBoxes();

  // Return true if this box looks like a candidate tab stop, and set
  // the appropriate tab type(s) to TT_UNCONFIRMED.
  bool TestBoxForTabs(BLOBNBOX* bbox);

  // Fills the list of TabVector with the tabstops found in the grid,
  // and estimates the logical vertical direction.
  void FindAllTabVectors();
  // Helper for FindAllTabVectors finds the vectors of a particular type.
  int FindTabVectors(int search_size_multiple,
                     TabAlignment alignment,
                     TabVector_LIST* vectors,
                     int* vertical_x, int* vertical_y);
  // Finds a vector corresponding to a tabstop running through the
  // given box of the given alignment type.
  // search_size_multiple is a multiple of height used to control
  // the size of the search.
  // vertical_x and y are updated with an estimate of the real
  // vertical direction. (skew finding.)
  // Returns NULL if no decent tabstop can be found.
  TabVector* FindTabVector(int search_size_multiple,
                           TabAlignment alignment,
                           BLOBNBOX* bbox,
                           int* vertical_x, int* vertical_y);

  // Set the vertical_skew_ member from the given vector and refit
  // all vectors parallel to the skew vector.
  void SetVerticalSkewAndParellelize(int vertical_x, int vertical_y);

  // Sort all the current vectors using the vertical_skew_ vector.
  void SortVectors();

  // Evaluate all the current tab vectors.
  void EvaluateTabs();

  // Trace textlines from one side to the other of each tab vector, saving
  // the most frequent column widths found in a list so that a given width
  // can be tested for being a common width with a simple callback function.
  void ComputeColumnWidths(ScrollView* tab_win);

  // Set the region_type_ member for all the blobs in the grid.
  void ComputeBlobGoodness();

  // Set the region_type_ member of the blob, if not already known.
  void SetBlobRegionType(BLOBNBOX* blob);

  // Mark blobs as being in a vertical text line where that is the case.
  void MarkVerticalText();

  // Returns true if the majority of the image is vertical text lines.
  bool TextMostlyVertical();

  // If this box looks like it is on a textline in the given direction,
  // return the width of the textline-like group of blobs, and the number
  // of blobs found.
  // For more detail see FindTextlineSegment below.
  int FindTextlineWidth(bool right_to_left, BLOBNBOX* bbox, int* blob_count);

  // Search from the given tabstop bbox to the next opposite
  // tabstop bbox on the same text line, which may be itself.
  // Returns true if the search is successful, and sets
  // start_pt, end_pt to the fitted baseline, width to the measured
  // width of the text line (column width estimate.)
  bool TraceTextline(BLOBNBOX* bbox, ICOORD* start_pt, ICOORD* end_pt,
                     int* left_edge, int* right_edge);

  // Search from the given bbox in the given direction until the next tab
  // vector is found or a significant horizontal gap is found.
  // Returns the width of the line if the search is successful, (defined
  // as good coverage of the width and a good fitting baseline) and sets
  // start_pt, end_pt to the fitted baseline, left_blob, right_blob to
  // the ends of the line. Returns zero otherwise.
  // Sets blob_count to the number of blobs found on the line.
  // On input, either both left_vector and right_vector should be NULL,
  // indicating a basic search, or both left_vector and right_vector should
  // be not NULL and one of *left_vector and *right_vector should be not NULL,
  // in which case the search is strictly between tab vectors and will return
  // zero if a gap is found before the opposite tab vector is reached, or a
  // conflicting tab vector is found.
  // If ignore_images is true, then blobs with aligned_text() < 0 are treated
  // as if they do not exist.
  int FindTextlineSegment(bool right_to_lefts, bool ignore_images,
                          BLOBNBOX* bbox, int* blob_count,
                          ICOORD* start_pt, ICOORD* end_pt,
                          TabVector** left_vector, TabVector** right_vector,
                          BLOBNBOX** left_blob, BLOBNBOX** right_blob);

  // Find the next adjacent (to left or right) blob on this text line,
  // with the constraint that it must vertically significantly overlap
  // the [top_y, bottom_y] range.
  // If ignore_images is true, then blobs with aligned_text() < 0 are treated
  // as if they do not exist.
  BLOBNBOX* AdjacentBlob(const BLOBNBOX* bbox,
                         bool right_to_left, bool ignore_images,
                         int gap_limit, int top_y, int bottom_y);

  // Add a bi-directional partner relationship between the left
  // and the right. If one (or both) of the vectors is a separator,
  // extend a nearby extendable vector or create a new one of the
  // correct type, using the given left or right blob as a guide.
  void AddPartnerVector(BLOBNBOX* left_blob, BLOBNBOX* right_blob,
                        TabVector* left, TabVector* right);

  /**
   * Remove separators and unused tabs from the main vectors_ list
   * to the dead_vectors_ list.
   */
  void CleanupTabs();

  /**
   * Deskew the tab vectors and blobs, computing the rotation and resetting
   * the storked vertical_skew_. The deskew inverse is returned in reskew.
   */
  void Deskew(TabVector_LIST* hlines, BLOBNBOX_LIST* image_blobs,
              TO_BLOCK* block, FCOORD* reskew);

  /**
   * Restart everything and rotate the input blobs ready for vertical text.
   */
  void ResetForVerticalText(TabVector_LIST* hlines, BLOBNBOX_LIST* image_blobs,
                            TO_BLOCK* block, FCOORD* rerotate);

  /**
   * Compute and apply constraints to the end positions of TabVectors so
   * that where possible partners end at the same y coordinate.
   */
  void ApplyTabConstraints();

 protected:
  ICOORD vertical_skew_;          //< Estimate of true vertical in this image.
  int resolution_;                //< Of source image in pixels per inch.
 private:
  ICOORD image_origin_;           // Top-left of image in deskewed coords
  TabVector_LIST vectors_;        //< List of rule line and tabstops.
  TabVector_IT v_it_;             //< Iterator for searching vectors_.
  TabVector_LIST dead_vectors_;   //< Separators and unpartnered tab vectors.
  ICOORDELT_LIST column_widths_;  //< List of commonly occurring widths.
  /** Callback to test an int for being a common width. */
  WidthCallback* width_cb_;
  /** Instance of the base class that contains only candidate tab stops. */
  BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT>* tab_grid_;
};
/////////////////////////////////////////////////////////////////tabfind////////////////////////////////////////

/////////////////////////////////////////////////////////////////blobbox////////////////////////////////////////
extern double_VAR_H (textord_error_weight, 3,
"Weighting for error in believability");
class ColPartition;
class BLOBNBOX;
ELISTIZEH (BLOBNBOX)
class BLOBNBOX:public ELIST_LINK
{
  public:
    BLOBNBOX()
    {
      blob_ptr = NULL;
      cblob_ptr = NULL;
      area = 0;
      Init();
    }
    explicit BLOBNBOX(PBLOB *srcblob)
    {
      blob_ptr = srcblob;
      cblob_ptr = NULL;
      box = srcblob->bounding_box ();
      area = (int) srcblob->area ();
      Init();
    }

    explicit BLOBNBOX(C_BLOB *srcblob)
    {
      blob_ptr = NULL;
      cblob_ptr = srcblob;
      box = srcblob->bounding_box();
      area = (int)srcblob->area();
      Init();
    }

    void rotate_box(FCOORD vec)
    {
      box.rotate(vec);
    }

    void translate_box(ICOORD v)
    {
      box.move(v);
    }

    void merge(BLOBNBOX *nextblob);

    void chop(                        // fake chop blob
              BLOBNBOX_IT *start_it,  // location of this
              BLOBNBOX_IT *blob_it,   // iterator
              FCOORD rotation,        // for landscape
              float xheight);         // line height

    // Simple accessors.
    const TBOX& bounding_box() const
    {
      return box;
    }

    void compute_bounding_box()
    {
      box = cblob_ptr != NULL ? cblob_ptr->bounding_box() : blob_ptr->bounding_box();
    }

    const TBOX& reduced_box() const
    {
      return red_box;
    }

    void set_reduced_box(TBOX new_box)
    {
      red_box = new_box;
      reduced = TRUE;
    }

    inT32 enclosed_area() const
    {
      return area;
    }

    bool joined_to_prev() const
    {
      return joined != 0;
    }

    bool red_box_set() const
    {
      return reduced != 0;
    }

    int repeated_set() const
    {
      return repeated_set_;
    }

    void set_repeated_set(int set_id)
    {
      repeated_set_ = set_id;
    }

    PBLOB *blob() const
    {
      return blob_ptr;
    }

    C_BLOB *cblob() const
    {
      return cblob_ptr;
    }

    TabType left_tab_type() const
    {
      return left_tab_type_;
    }

    void set_left_tab_type(TabType new_type)
    {
      left_tab_type_ = new_type;
    }

    TabType right_tab_type() const
    {
      return right_tab_type_;
    }

    void set_right_tab_type(TabType new_type)
    {
      right_tab_type_ = new_type;
    }

    BlobRegionType region_type() const
    {
      return region_type_;
    }

    void set_region_type(BlobRegionType new_type)
    {
      region_type_ = new_type;
    }

    int left_rule() const
    {
      return left_rule_;
    }

    void set_left_rule(int new_left)
    {
      left_rule_ = new_left;
    }

    int right_rule() const
    {
      return right_rule_;
    }

    void set_right_rule(int new_right)
    {
      right_rule_ = new_right;
    }

    int left_crossing_rule() const
    {
      return left_crossing_rule_;
    }

    void set_left_crossing_rule(int new_left)
    {
      left_crossing_rule_ = new_left;
    }

    int right_crossing_rule() const
    {
      return right_crossing_rule_;
    }

    void set_right_crossing_rule(int new_right)
    {
      right_crossing_rule_ = new_right;
    }

    float horz_stroke_width() const
    {
      return horz_stroke_width_;
    }

    void set_horz_stroke_width(float width)
    {
      horz_stroke_width_ = width;
    }

    float vert_stroke_width() const
    {
      return vert_stroke_width_;
    }

    void set_vert_stroke_width(float width)
    {
      vert_stroke_width_ = width;
    }

    ColPartition* owner() const
    {
      return owner_;
    }

    void set_owner(ColPartition* new_owner)
    {
      owner_ = new_owner;
    }

    void set_noise_flag(bool flag)
    {
      noise_flag_ = flag;
    }

    bool noise_flag() const
    {
      return noise_flag_;
    }

#ifndef GRAPHICS_DISABLED
    // Keep in sync with BlobRegionType.
    ScrollView::Color BoxColor() const
    {
      switch (region_type_)
      {
      case BRT_HLINE:
        return ScrollView::YELLOW;
      case BRT_RECTIMAGE:
        return ScrollView::RED;
      case BRT_POLYIMAGE:
        return ScrollView::ORANGE;
      case BRT_UNKNOWN:
        return ScrollView::CYAN;
      case BRT_VERT_TEXT:
        return ScrollView::GREEN;
      case BRT_TEXT:
        return ScrollView::BLUE;
      case BRT_NOISE:
      default:
        return ScrollView::GREY;
      }
    }

    void plot(ScrollView* window,                // window to draw in
              ScrollView::Color blob_colour,     // for outer bits
              ScrollView::Color child_colour)
    {
      // for holes
      if (blob_ptr != NULL)
      {
        blob_ptr->plot(window, blob_colour, child_colour);
      }

      if (cblob_ptr != NULL)
      {
        cblob_ptr->plot(window, blob_colour, child_colour);
      }
    }
#endif

    NEWDELETE2(BLOBNBOX)

 private:
  // Initializes the bulk of the members to default values.
  void Init()
    {
    joined = false;
    reduced = false;
    repeated_set_ = 0;
    left_tab_type_ = TT_NONE;
    right_tab_type_ = TT_NONE;
    region_type_ = BRT_UNKNOWN;
    left_rule_ = 0;
    right_rule_ = 0;
    left_crossing_rule_ = 0;
    right_crossing_rule_ = 0;
    horz_stroke_width_ = 0.0f;
    vert_stroke_width_ = 0.0f;
    owner_ = NULL;
    noise_flag_ = false;
  }

  PBLOB *blob_ptr;              // poly blob
  C_BLOB *cblob_ptr;            // edgestep blob
  TBOX box;                     // bounding box
  TBOX red_box;                 // bounding box
  int area:30;                  // enclosed area
  int joined:1;                 // joined to prev
  int reduced:1;                // reduced box set
  int repeated_set_;            // id of the set of repeated blobs
  TabType left_tab_type_;       // Indicates tab-stop assessment
  TabType right_tab_type_;      // Indicates tab-stop assessment
  BlobRegionType region_type_;  // Type of region this blob belongs to
  inT16 left_rule_;             // x-coord of nearest but not crossing rule line
  inT16 right_rule_;            // x-coord of nearest but not crossing rule line
  inT16 left_crossing_rule_;    // x-coord of nearest or crossing rule line
  inT16 right_crossing_rule_;   // x-coord of nearest or crossing rule line
  float horz_stroke_width_;     // Median horizontal stroke width
  float vert_stroke_width_;     // Median vertical stroke width
  ColPartition* owner_;  // Who will delete me when I am not needed
  // Was the blob flagged as noise in the initial filtering step
  bool noise_flag_;
};

class TO_ROW:public ELIST2_LINK
{
  public:
    TO_ROW()
    {
      num_repeated_sets_ = -1;
    }                            //empty
    TO_ROW(                 //constructor
           BLOBNBOX *blob,  //from first blob
           float top,       //of row //target height
           float bottom,
           float row_size);

    float max_y() const
    {  //access function
      return y_max;
    }

    float min_y() const
    {
      return y_min;
    }

    float mean_y() const
    {
      return (y_min + y_max) / 2.0f;
    }

    float initial_min_y() const
    {
      return initial_y_min;
    }

    float line_m() const
    {  //access to line fit
      return m;
    }

    float line_c() const
    {
      return c;
    }

    float line_error() const
    {
      return error;
    }

    float parallel_c() const
    {
      return para_c;
    }

    float parallel_error() const
    {
      return para_error;
    }

    float believability() const
    {  //baseline goodness
      return credibility;
    }

    float intercept() const
    {  //real parallel_c
      return y_origin;
    }

    void add_blob(                 //put in row
                  BLOBNBOX *blob,  //blob to add
                  float top,       //of row //target height
                  float bottom,
                  float row_size);

    //put in row in order
    void insert_blob(BLOBNBOX *blob);

    BLOBNBOX_LIST *blob_list()
    {  //get list
      return &blobs;
    }

    void set_line(              //set line spec
                  float new_m,  //line to set
                  float new_c,
                  float new_error)
    {
      m = new_m;
      c = new_c;
      error = new_error;
    }
    void set_parallel_line(                 //set fixed gradient line
                           float gradient,  //page gradient
                           float new_c,
                           float new_error)
    {
      para_c = new_c;
      para_error = new_error;
      credibility = (float) (blobs.length () - textord_error_weight * new_error);
      y_origin = (float) (new_c / sqrt (1 + gradient * gradient));
      //real intercept
    }
    void set_limits(                  //set min,max
                    float new_min,    //bottom and
                    float new_max)
    {  //top of row
      y_min = new_min;
      y_max = new_max;
    }

    void compute_vertical_projection();
    //get projection

    bool rep_chars_marked() const
    {
      return num_repeated_sets_ != -1;
    }

    void clear_rep_chars_marked()
    {
      num_repeated_sets_ = -1;
    }

    int num_repeated_sets() const
    {
      return num_repeated_sets_;
    }

    void set_num_repeated_sets(int num_sets)
    {
      num_repeated_sets_ = num_sets;
    }

                                 // true when dead
    NEWDELETE2 (TO_ROW) BOOL8 merged;
    BOOL8 all_caps;              // had no ascenders
    BOOL8 used_dm_model;         // in guessing pitch
    inT16 projection_left;       // start of projection
    inT16 projection_right;      // start of projection
    PITCH_TYPE pitch_decision;   // how strong is decision
    float fixed_pitch;           // pitch or 0
    float fp_space;              // sp if fixed pitch
    float fp_nonsp;              // nonsp if fixed pitch
    float pr_space;              // sp if prop
    float pr_nonsp;              // non sp if prop
    float spacing;               // to "next" row
    float xheight;               // of line
    int xheight_evidence;        // number of blobs of height xheight
    float ascrise;               // ascenders
    float descdrop;              // descenders
    inT32 min_space;             // min size for real space
    inT32 max_nonspace;          // max size of non-space
    inT32 space_threshold;       // space vs nonspace
    float kern_size;             // average non-space
    float space_size;            // average space
    WERD_LIST rep_words;         // repeated chars
    ICOORDELT_LIST char_cells;   // fixed pitch cells
    QSPLINE baseline;            // curved baseline
    STATS projection;            // vertical projection

  private:
    BLOBNBOX_LIST blobs;         //blobs in row
    float y_min;                 //coords
    float y_max;
    float initial_y_min;
    float m, c;                  //line spec
    float error;                 //line error
    float para_c;                //constrained fit
    float para_error;
    float y_origin;              //rotated para_c;
    float credibility;           //baseline believability
    int num_repeated_sets_;      // number of sets of repeated blobs
                                 // set to -1 if we have not searched
                                 // for repeated blobs in this row yet
};

ELIST2IZEH (TO_ROW)
class TO_BLOCK:public ELIST_LINK
{
  public:
    TO_BLOCK() {}                            //empty

    //constructor
    TO_BLOCK(BLOCK *src_block);  //real block
    ~TO_BLOCK();

    TO_ROW_LIST *get_rows()
    {
      //access function
      return &row_list;
    }

    void print_rows()
    {
      //debug info
      TO_ROW_IT row_it = &row_list;
      TO_ROW *row;

      for (row_it.mark_cycle_pt (); !row_it.cycled_list ();
      row_it.forward ())
      {
        row = row_it.data ();
        printf ("Row range (%g,%g), para_c=%g, blobcount=" INT32FORMAT
          "\n", row->min_y (), row->max_y (), row->parallel_c (),
          row->blob_list ()->length ());
      }
    }

    // Draw the blobs on on the various lists in the block in different colors.
#ifndef GRAPHICS_DISABLED
    void plot_graded_blobs(ScrollView* to_win);
#endif

    BLOBNBOX_LIST blobs;         //medium size
    BLOBNBOX_LIST underlines;    //underline blobs
    BLOBNBOX_LIST noise_blobs;   //very small
    BLOBNBOX_LIST small_blobs;   //fairly small
    BLOBNBOX_LIST large_blobs;   //big blobs
    BLOCK *block;                //real block
    PITCH_TYPE pitch_decision;   //how strong is decision
    float line_spacing;          //estimate
    float line_size;             //estimate
    float max_blob_size;         //line assignment limit
    float baseline_offset;       //phase shift
    float xheight;               //median blob size
    float fixed_pitch;           //pitch or 0
    float kern_size;             //average non-space
    float space_size;            //average space
    inT32 min_space;             //min definite space
    inT32 max_nonspace;          //max definite
    float fp_space;              //sp if fixed pitch
    float fp_nonsp;              //nonsp if fixed pitch
    float pr_space;              //sp if prop
    float pr_nonsp;              //non sp if prop
    TO_ROW *key_row;             //starting row

    NEWDELETE2 (TO_BLOCK) private:
    TO_ROW_LIST row_list;        //temporary rows
};

ELISTIZEH (TO_BLOCK)
extern double_VAR_H(textord_error_weight, 3, "Weighting for error in believability");

void find_blob_limits(                  //get y limits
                      PBLOB *blob,      //blob to search
                      float leftx,      //x limits
                      float rightx,
                      FCOORD rotation,  //for landscape
                      float &ymin,      //output y limits
                      float &ymax);

void find_cblob_limits(                  //get y limits
                       C_BLOB *blob,     //blob to search
                       float leftx,      //x limits
                       float rightx,
                       FCOORD rotation,  //for landscape
                       float &ymin,      //output y limits
                       float &ymax);

void find_cblob_vlimits(               //get y limits
                        C_BLOB *blob,  //blob to search
                        float leftx,   //x limits
                        float rightx,
                        float &ymin,   //output y limits
                        float &ymax);

void find_cblob_hlimits(                //get x limits
                        C_BLOB *blob,   //blob to search
                        float bottomy,  //y limits
                        float topy,
                        float &xmin,    //output x limits
                        float &xymax);

PBLOB *rotate_blob(                 //get y limits
                   PBLOB *blob,     //blob to search
                   FCOORD rotation  //vector to rotate by
                  );

PBLOB *rotate_cblob(                 //rotate it
                    C_BLOB *blob,    //blob to search
                    float xheight,   //for poly approx
                    FCOORD rotation  //for landscape
                   );

C_BLOB *crotate_cblob(                 //rotate it
                      C_BLOB *blob,    //blob to search
                      FCOORD rotation  //for landscape
                     );

//get bounding box  //iterator to blobds
TBOX box_next(BLOBNBOX_IT *it);

//get bounding box        //iterator to blobds
TBOX box_next_pre_chopped(BLOBNBOX_IT *it);

void vertical_blob_projection(              //project outlines
                              PBLOB *blob,  //blob to project
                              STATS *stats  //output
                             );


//project outlines
void vertical_outline_projection(OUTLINE *outline,  //outline to project
                                 STATS *stats       //output
                                );

void vertical_cblob_projection(               //project outlines
                               C_BLOB *blob,  //blob to project
                               STATS *stats   //output
                              );

void vertical_coutline_projection(                     //project outlines
                                  C_OUTLINE *outline,  //outline to project
                                  STATS *stats         //output
                                 );

#ifndef GRAPHICS_DISABLED
void plot_blob_list(ScrollView* win,                   // window to draw in
                    BLOBNBOX_LIST *list,               // blob list
                    ScrollView::Color body_colour,     // colour to draw
                    ScrollView::Color child_colour);   // colour of child
#endif //GRAPHICS_DISABLED
/////////////////////////////////////////////////////////////////blobbox////////////////////////////////////////

/////////////////////////////////////////////////////////////////colpartition///////////////////////////////////
class ColPartition;
class ColPartitionSet;
class WorkingPartSet;
class WorkingPartSet_LIST;

ELIST2IZEH(ColPartition)
CLISTIZEH(ColPartition)

/**
 * ColPartition is a partition of a horizontal slice of the page.
 * It starts out as a collection of blobs at a particular y-coord in the grid,
 * but ends up (after merging and uniquing) as an approximate text line.
 * ColPartitions are also used to hold a partitioning of the page into
 * columns, each representing one column. Although a ColPartition applies
 * to a given y-coordinate range, eventually, a ColPartitionSet of ColPartitions
 * emerges, which represents the columns over a wide y-coordinate range.
 */
class ColPartition : public ELIST2_LINK {
 public:
  ColPartition() {
    // This empty constructor is here only so that the class can be ELISTIZED.
    // TODO(rays) change deep_copy in elst.h line 955 to take a callback copier
    // and eliminate CLASSNAME##_copier.
  }
  /**
   * @param blob_type is the blob_region_type_ of the blobs in this partition.
   * @param vertical is the direction of logical vertical on the possibly skewed image.
   */
  ColPartition(BlobRegionType blob_type, const ICOORD& vertical);
  /**
   * Constructs a fake ColPartition with no BLOBNBOXes.
   * Used for making horizontal line ColPartitions and types it accordingly.
   */
  ColPartition(const ICOORD& vertical,
               int left, int bottom, int right, int top);

  // Constructs and returns a fake ColPartition with a single fake BLOBNBOX,
  // all made from a single TBOX.
  // WARNING: Despite being on C_LISTs, the BLOBNBOX owns the C_BLOB and
  // the ColPartition owns the BLOBNBOX!!!
  // Call DeleteBoxes before deleting the ColPartition.
  static ColPartition* FakePartition(const TBOX& box);

  ~ColPartition();

  // Simple accessors.
  const TBOX& bounding_box() const {
    return bounding_box_;
  }
  int left_margin() const {
    return left_margin_;
  }
  void set_left_margin(int margin) {
    left_margin_ = margin;
  }
  int right_margin() const {
    return right_margin_;
  }
  void set_right_margin(int margin) {
    right_margin_ = margin;
  }
  int median_top() const {
    return median_top_;
  }
  int median_bottom() const {
    return median_bottom_;
  }
  int median_size() const {
    return median_size_;
  }
  BlobRegionType blob_type() const {
    return blob_type_;
  }
  void set_blob_type(BlobRegionType t) {
    blob_type_ = t;
  }
  bool good_width() const {
    return good_width_;
  }
  bool good_column() const {
    return good_column_;
  }
  bool left_key_tab() const {
    return left_key_tab_;
  }
  int left_key() const {
    return left_key_;
  }
  bool right_key_tab() const {
    return right_key_tab_;
  }
  int right_key() const {
    return right_key_;
  }
  PolyBlockType type() const {
    return type_;
  }
  void set_type(PolyBlockType t) {
    type_ = t;
  }
  BLOBNBOX_CLIST* boxes() {
    return &boxes_;
  }
  ColPartition_CLIST* upper_partners() {
    return &upper_partners_;
  }
  ColPartition_CLIST* lower_partners() {
    return &lower_partners_;
  }
  void set_working_set(WorkingPartSet* working_set) {
    working_set_ = working_set;
  }
  ColPartitionSet* column_set() const {
    return column_set_;
  }
  void set_side_step(int step) {
    side_step_ = step;
  }
  int bottom_spacing() const {
    return bottom_spacing_;
  }
  void set_bottom_spacing(int spacing) {
    bottom_spacing_ = spacing;
  }
  int top_spacing() const {
    return top_spacing_;
  }
  void set_top_spacing(int spacing) {
    top_spacing_ = spacing;
  }

  void set_table_type() {
    if (type_ != PT_TABLE) {
      type_before_table_ = type_;
      type_ = PT_TABLE;
    }
  }
  void clear_table_type() {
    if (type_ == PT_TABLE)
      type_ = type_before_table_;
  }
  bool inside_table_column() {
    return inside_table_column_;
  }
  void set_inside_table_column(bool val) {
    inside_table_column_ = val;
  }
  ColPartition* nearest_neighbor_above() const {
    return nearest_neighbor_above_;
  }
  void set_nearest_neighbor_above(ColPartition* part) {
    nearest_neighbor_above_ = part;
  }
  ColPartition* nearest_neighbor_below() const {
    return nearest_neighbor_below_;
  }
  void set_nearest_neighbor_below(ColPartition* part) {
    nearest_neighbor_below_ = part;
  }
  int space_above() const {
    return space_above_;
  }
  void set_space_above(int space) {
    space_above_ = space;
  }
  int space_below() const {
    return space_below_;
  }
  void set_space_below(int space) {
    space_below_ = space;
  }
  int space_to_left() const {
    return space_to_left_;
  }
  void set_space_to_left(int space) {
    space_to_left_ = space;
  }
  int space_to_right() const {
    return space_to_right_;
  }
  void set_space_to_right(int space) {
    space_to_right_ = space;
  }

  // Inline quasi-accessors that require some computation.

  // Returns the middle y-coord of the bounding box.
  int MidY() const {
    return (bounding_box_.top() + bounding_box_.bottom()) / 2;
  }
  // Returns the middle y-coord of the median top and bottom.
  int MedianY() const {
    return (median_top_ + median_bottom_) / 2;
  }
  // Returns the sort key at any given x,y.
  int SortKey(int x, int y) const {
    return TabVector::SortKey(vertical_, x, y);
  }
  // Returns the x corresponding to the sortkey, y pair.
  int XAtY(int sort_key, int y) const {
    return TabVector::XAtY(vertical_, sort_key, y);
  }
  // Returns the x difference between the two sort keys.
  int KeyWidth(int left_key, int right_key) const {
    return (right_key - left_key) / vertical_.y();
  }
  // Returns the column width between the left and right keys.
  int ColumnWidth() const {
    return KeyWidth(left_key_, right_key_);
  }
  // Returns the sort key of the box left edge.
  int BoxLeftKey() const {
    return SortKey(bounding_box_.left(), MidY());
  }
  // Returns the sort key of the box right edge.
  int BoxRightKey() const {
    return SortKey(bounding_box_.right(), MidY());
  }
  // Returns the left edge at the given y, using the sort key.
  int LeftAtY(int y) const {
    return XAtY(left_key_, y);
  }
  // Returns the right edge at the given y, using the sort key.
  int RightAtY(int y) const {
    return XAtY(right_key_, y);
  }
  // Returns true if the right edge of this is to the left of the right
  // edge of other.
  bool IsLeftOf(const ColPartition& other) const {
    return bounding_box_.right() < other.bounding_box_.right();
  }
  // Returns true if the partition contains the given x coordinate at the y.
  bool ColumnContains(int x, int y) const {
    return LeftAtY(y) - 1 <= x && x <= RightAtY(y) + 1;
  }
  // Returns true if there are no blobs in the list.
  bool IsEmpty() {
    return boxes_.empty();
  }
  // Returns true if this and other overlap horizontally by bounding box.
  bool HOverlaps(const ColPartition& other) const {
    return bounding_box_.x_overlap(other.bounding_box_);
  }
  // Returns true if this and other can be combined without putting a
  // horizontal step in either left or right edge.
  bool HCompatible(const ColPartition& other) const {
    return left_margin_ <= other.bounding_box_.left() &&
           bounding_box_.left() >= other.left_margin_ &&
           bounding_box_.right() <= other.right_margin_ &&
           right_margin_ >= other.bounding_box_.right();
  }
  // Returns the vertical overlap (by median) of this and other.
  int VOverlap(const ColPartition& other) const {
    return MIN(median_top_, other.median_top_) -
           MAX(median_bottom_, other.median_bottom_);
  }
  // Returns true if this and other overlap significantly vertically.
  bool VOverlaps(const ColPartition& other) const {
    int overlap = VOverlap(other);
    int height = MIN(median_top_ - median_bottom_,
                     other.median_top_ - other.median_bottom_);
    return overlap * 3 > height;
  }
  // Returns true if the region types (aligned_text_) match.
  bool TypesMatch(const ColPartition& other) const {
    return TypesMatch(blob_type_, other.blob_type_);
  }
  static bool TypesMatch(BlobRegionType type1, BlobRegionType type2) {
    return type1 == type2 ||
           (type1 < BRT_UNKNOWN && type2 < BRT_UNKNOWN);
  }

  // Returns true if partitions is of horizontal line type
  bool IsLineType() {
    return POLY_BLOCK::IsLineType(type_);
  }
  // Returns true if partitions is of image type
  bool IsImageType() {
    return POLY_BLOCK::IsImageType(type_);
  }
  // Returns true if partitions is of text type
  bool IsTextType() {
    return POLY_BLOCK::IsTextType(type_);
  }

  // Adds the given box to the partition, updating the partition bounds.
  // The list of boxes in the partition is updated, ensuring that no box is
  // recorded twice, and the boxes are kept in increasing left position.
  void AddBox(BLOBNBOX* box);

  // Claims the boxes in the boxes_list by marking them with a this owner
  // pointer. If a box is already owned, then run Unique on it.
  void ClaimBoxes(WidthCallback* cb);

  // Delete the boxes that this partition owns.
  void DeleteBoxes();

  // Returns true if this is a legal partition - meaning that the conditions
  // left_margin <= bounding_box left
  // left_key <= bounding box left key
  // bounding box left <= bounding box right
  // and likewise for right margin and key
  // are all met.
  bool IsLegal();

  // Returns true if the left and right edges are approximately equal.
  bool MatchingColumns(const ColPartition& other) const;

  // Sets the sort key using either the tab vector, or the bounding box if
  // the tab vector is NULL. If the tab_vector lies inside the bounding_box,
  // use the edge of the box as a key any way.
  void SetLeftTab(const TabVector* tab_vector);
  void SetRightTab(const TabVector* tab_vector);

  // Copies the left/right tab from the src partition, but if take_box is
  // true, copies the box instead and uses that as a key.
  void CopyLeftTab(const ColPartition& src, bool take_box);
  void CopyRightTab(const ColPartition& src, bool take_box);

  // Add a partner above if upper, otherwise below.
  // Add them uniquely and keep the list sorted by box left.
  // Partnerships are added symmetrically to partner and this.
  void AddPartner(bool upper, ColPartition* partner);
  // Removes the partner from this, but does not remove this from partner.
  // This asymmetric removal is so as not to mess up the iterator that is
  // working on partner's partner list.
  void RemovePartner(bool upper, ColPartition* partner);
  // Returns the partner if the given partner is a singleton, otherwise NULL.
  ColPartition* SingletonPartner(bool upper);

  // Merge with the other partition and delete it.
  void Absorb(ColPartition* other, WidthCallback* cb);

  // Shares out any common boxes amongst the partitions, ensuring that no
  // box stays in both. Returns true if anything was done.
  bool Unique(ColPartition* other, WidthCallback* cb);

  // Splits this partition at the given x coordinate, returning the right
  // half and keeping the left half in this.
  ColPartition* SplitAt(int split_x);

  // Recalculates all the coordinate limits of the partition.
  void ComputeLimits();

  // Computes and sets the type_, first_column_, last_column_ and column_set_.
  void SetPartitionType(ColPartitionSet* columns);

  // Returns the first and last column touched by this partition.
  void ColumnRange(ColPartitionSet* columns, int* first_col, int* last_col);

  // Sets the internal flags good_width_ and good_column_.
  void SetColumnGoodness(WidthCallback* cb);

  // Adds this ColPartition to a matching WorkingPartSet if one can be found,
  // otherwise starts a new one in the appropriate column, ending the previous.
  void AddToWorkingSet(const ICOORD& bleft, const ICOORD& tright,
                       int resolution, ColPartition_LIST* used_parts,
                       WorkingPartSet_LIST* working_set);

  // From the given block_parts list, builds one or more BLOCKs and
  // corresponding TO_BLOCKs, such that the line spacing is uniform in each.
  // Created blocks are appended to the end of completed_blocks and to_blocks.
  // The used partitions are put onto used_parts, as they may still be referred
  // to in the partition grid. bleft, tright and resolution are the bounds
  // and resolution of the original image.
  static void LineSpacingBlocks(const ICOORD& bleft, const ICOORD& tright,
                                int resolution,
                                ColPartition_LIST* block_parts,
                                ColPartition_LIST* used_parts,
                                BLOCK_LIST* completed_blocks,
                                TO_BLOCK_LIST* to_blocks);
  // Constructs a block from the given list of partitions.
  // Arguments are as LineSpacingBlocks above.
  static TO_BLOCK* MakeBlock(const ICOORD& bleft, const ICOORD& tright,
                             ColPartition_LIST* block_parts,
                             ColPartition_LIST* used_parts);


  // Returns a copy of everything except the list of boxes. The resulting
  // ColPartition is only suitable for keeping in a column candidate list.
  ColPartition* ShallowCopy() const;

  // Provides a color for BBGrid to draw the rectangle.
  ScrollView::Color  BoxColor() const;

  // Prints debug information on this.
  void Print();

  // Sets the types of all partitions in the run to be the max of the types.
  void SmoothPartnerRun(int working_set_count);

  // Cleans up the partners of the given type so that there is at most
  // one partner. This makes block creation simpler.
  void RefinePartners(PolyBlockType type);

 private:
  // enum to refer to the entries in a neigbourhood of lines.
  // Used by SmoothSpacings to test for blips with OKSpacingBlip.
  enum SpacingNeighbourhood {
    PN_ABOVE2,
    PN_ABOVE1,
    PN_UPPER,
    PN_LOWER,
    PN_BELOW1,
    PN_BELOW2,
    PN_COUNT
  };

  // Cleans up the partners above if upper is true, else below.
  void RefinePartnersInternal(bool upper);
  // Restricts the partners to only desirable types. For text and BRT_HLINE this
  // means the same type_ , and for image types it means any image type.
  void RefinePartnersByType(bool upper, ColPartition_CLIST* partners);
  // Remove transitive partnerships: this<->a, and a<->b and this<->b.
  // Gets rid of this<->b, leaving a clean chain.
  // Also if we have this<->a and a<->this, then gets rid of this<->a, as
  // this has multiple partners.
  void RefinePartnerShortcuts(bool upper, ColPartition_CLIST* partners);
  // Keeps the partner with the longest sequence of singleton matching partners.
  // Converts all others to pullout.
  void RefineFlowingTextPartners(bool upper, ColPartition_CLIST* partners);
  // Keep the partner with the biggest overlap.
  void RefinePartnersByOverlap(bool upper, ColPartition_CLIST* partners);

  // Return true if bbox belongs better in this than other.
  bool ThisPartitionBetter(BLOBNBOX* bbox, const ColPartition& other);

  // Smoothes the spacings in the list into groups of equal linespacing.
  // resolution is the resolution of the original image, used as a basis
  // for thresholds in change of spacing. page_height is in pixels.
  static void SmoothSpacings(int resolution, int page_height,
                             ColPartition_LIST* parts);

  // Returns true if the parts array of pointers to partitions matches the
  // condition for a spacing blip. See SmoothSpacings for what this means
  // and how it is used.
  static bool OKSpacingBlip(int resolution, int median_spacing,
                            ColPartition** parts);

  // Returns true if both the top and bottom spacings of this match the given
  // spacing to within suitable margins dictated by the image resolution.
  bool SpacingEqual(int spacing, int resolution) const;

  // Returns true if both the top and bottom spacings of this and other
  // match to within suitable margins dictated by the image resolution.
  bool SpacingsEqual(const ColPartition& other, int resolution) const;

  // Returns true if the sum spacing of this and other match the given
  // spacing (or twice the given spacing) to within a suitable margin dictated
  // by the image resolution.
  bool SummedSpacingOK(const ColPartition& other,
                       int spacing, int resolution) const;

  // Returns a suitable spacing margin that can be applied to bottoms of
  // text lines, based on the resolution and the stored side_step_.
  int BottomSpacingMargin(int resolution) const;

  // Returns a suitable spacing margin that can be applied to tops of
  // text lines, based on the resolution and the stored side_step_.
  int TopSpacingMargin(int resolution) const;

  // Returns true if the median text sizes of this and other agree to within
  // a reasonable multiplicative factor.
  bool SizesSimilar(const ColPartition& other) const;

  // Computes and returns in start, end a line segment formed from a
  // forwards-iterated group of left edges of partitions that satisfy the
  // condition that the rightmost left margin is to the left of the
  // leftmost left bounding box edge.
  // TODO(rays) Not good enough. Needs improving to tightly wrap text in both
  // directions, and to loosely wrap images.
  static void LeftEdgeRun(ColPartition_IT* part_it,
                          ICOORD* start, ICOORD* end);
  // Computes and returns in start, end a line segment formed from a
  // backwards-iterated group of right edges of partitions that satisfy the
  // condition that the leftmost right margin is to the right of the
  // rightmost right bounding box edge.
  // TODO(rays) Not good enough. Needs improving to tightly wrap text in both
  // directions, and to loosely wrap images.
  static void RightEdgeRun(ColPartition_IT* part_it,
                           ICOORD* start, ICOORD* end);

  // The margins are determined by the position of the nearest vertically
  // overlapping neighbour to the side. They indicate the maximum extent
  // that the block/column may be extended without touching something else.
  // Leftmost coordinate that the region may occupy over the y limits.
  int left_margin_;
  // Rightmost coordinate that the region may occupy over the y limits.
  int right_margin_;
  // Bounding box of all blobs in the partition.
  TBOX bounding_box_;
  // Median top and bottom of blobs in this partition.
  int median_bottom_;
  int median_top_;
  // Median height of blobs in this partition.
  int median_size_;
  // blob_region_type_ for the blobs in this partition.
  BlobRegionType blob_type_;
  // True if this partition has a common width.
  bool good_width_;
  // True if this is a good column candidate.
  bool good_column_;
  // True if the left_key_ is from a tab vector.
  bool left_key_tab_;
  // True if the right_key_ is from a tab vector.
  bool right_key_tab_;
  // Left and right sort keys for the edges of the partition.
  // If the respective *_key_tab_ is true then this key came from a tab vector.
  // If not, then the class promises to keep the key equal to the sort key
  // for the respective edge of the bounding box at the MidY, so that
  // LeftAtY and RightAtY always returns an x coordinate on the line parallel
  // to vertical_ through the bounding box edge at MidY.
  int left_key_;
  int right_key_;
  // Type of this partition after looking at its relation to the columns.
  PolyBlockType type_;
  // All boxes in the partition stored in increasing left edge coordinate.
  BLOBNBOX_CLIST boxes_;
  // The global vertical skew direction.
  ICOORD vertical_;
  // The partitions above that matched this.
  ColPartition_CLIST upper_partners_;
  // The partitions below that matched this.
  ColPartition_CLIST lower_partners_;
  // The WorkingPartSet it lives in while blocks are being made.
  WorkingPartSet* working_set_;
  // True when the partition's ownership has been taken from the grid and
  // placed in a working set, or, after that, in the good_parts_ list.
  bool block_owned_;
  // The first and last column that this partition applies to.
  // Flowing partitions (see type_) will have an equal first and last value
  // of the form 2n + 1, where n is the zero-based index into the partitions
  // in column_set_. (See ColPartitionSet::GetColumnByIndex).
  // Heading partitions will have unequal values of the same form.
  // Pullout partitions will have equal values, but may have even values,
  // indicating placement between columns.
  int first_column_;
  int last_column_;
  // Column_set_ is the column layout applicable to this ColPartition.
  ColPartitionSet* column_set_;
  // Linespacing data.
  int side_step_;       // Median y-shift to next blob on same line.
  int top_spacing_;     // Line spacing from median_top_.
  int bottom_spacing_;  // Line spacing from median_bottom_.

  // Type of this partition before considering it as a table cell. This is
  // used to revert the type if a partition is first marked as a table cell but
  // later filtering steps decide it does not belong to a table
  PolyBlockType type_before_table_;
  bool inside_table_column_;  // Check whether the current partition has been
                              // assigned to a table column
  // Nearest neighbor above with major x-overlap
  ColPartition* nearest_neighbor_above_;
  // Nearest neighbor below with major x-overlap
  ColPartition* nearest_neighbor_below_;
  int space_above_;      // Distance from nearest_neighbor_above
  int space_below_;      // Distance from nearest_neighbor_below
  int space_to_left_;    // Distance from the left edge of the column
  int space_to_right_;   // Distance from the right edge of the column
};

// Typedef it now in case it becomes a class later.
typedef BBGrid<ColPartition,
               ColPartition_CLIST,
               ColPartition_C_IT> ColPartitionGrid;
typedef GridSearch<ColPartition,
               ColPartition_CLIST,
               ColPartition_C_IT> ColPartitionGridSearch;
/////////////////////////////////////////////////////////////////colpartition////////////////////////////////////////

  /////////////////////////////////////////////////////////////////workingpartset/////////////////////////////////
  // WorkingPartSet holds a working set of ColPartitions during transformation
  // from the grid-based storage to regions in logical reading order, and is
  // therefore only used during construction of the regions.
  class WorkingPartSet : public ELIST_LINK {
   public:
    WorkingPartSet() {
    }
    explicit WorkingPartSet(ColPartition* column)
      : column_(column), latest_part_(NULL), part_it_(&part_set_) {
    }

    // Simple accessors.
    ColPartition* column() const {
      return column_;
    }
    void set_column(ColPartition* col) {
      column_ = col;
    }

    // Add the partition to this WorkingPartSet. Partitions are generally
    // stored in the order in which they are received, but if the partition
    // has a SingletonPartner, make sure that it stays with its partner.
    void AddPartition(ColPartition* part);

    // Make blocks out of any partitions in this WorkingPartSet, and append
    // them to the end of the blocks list. bleft, tright and resolution give
    // the bounds and resolution of the source image, so that blocks can be
    // made to fit in the bounds.
    // All ColPartitions go in the used_parts list, as they need to be kept
    // around, but are no longer needed.
    void ExtractCompletedBlocks(const ICOORD& bleft, const ICOORD& tright,
                                int resolution, ColPartition_LIST* used_parts,
                                BLOCK_LIST* blocks, TO_BLOCK_LIST* to_blocks);

    // Insert the given blocks at the front of the completed_blocks_ list so
    // they can be kept in the correct reading order.
    void InsertCompletedBlocks(BLOCK_LIST* blocks, TO_BLOCK_LIST* to_blocks);

   private:
    // Convert the part_set_ into blocks, starting a new block at a break
    // in partnerships, or a change in linespacing (for text).
    void MakeBlocks(const ICOORD& bleft, const ICOORD& tright, int resolution,
                    ColPartition_LIST* used_parts);

    // The column that this working set applies to. Used by the caller.
    ColPartition* column_;
    // The most recently added partition.
    ColPartition* latest_part_;
    // All the partitions in the block that is currently under construction.
    ColPartition_LIST part_set_;
    // Iteratorn on part_set_ pointing to the most recent addition.
    ColPartition_IT part_it_;
    // The blocks that have been made so far and belong before the current block.
    BLOCK_LIST completed_blocks_;
    TO_BLOCK_LIST to_blocks_;
  };

  ELISTIZEH(WorkingPartSet)
  /////////////////////////////////////////////////////////////////workingpartset/////////////////////////////////

/////////////////////////////////////////////////////////////////lmedsq////////////////////////////////////////
class LMS
{
  public:
    LMS(              //constructor
        inT32 size);  //no of samples
    ~LMS ();                     //destructor
    void clear();  //clear samples
    void add(                 //add sample
             FCOORD sample);  //sample coords
    void fit(           //generate fit
             float &m,  //output line
             float &c);
    void constrained_fit(                //fixed gradient
                         float fixed_m,  //forced gradient
                         float &out_c);  //output line
    void fit_quadratic(                          //easy quadratic
                       float outlier_threshold,  //min outlier
                       double &a,                //x squared
                       float &b,                 //x
                       float &c);                //constant
    void plot(                 //plot fit
              ScrollView* win,      //window
              ScrollView::Color colour);  //colour to draw in
    float error()
    {  //get error
      return fitted ? line_error : -1;
    }

  private:

    void pick_line(           //random choice
                   float &m,  //output line
                   float &c);
    void pick_quadratic(            //random choice
                        double &a,  //output curve
                        float &b,
                        float &c);
    void compute_errors(          //find errors
                        float m,  //from line
                        float c);
                                 //find errors
    float compute_quadratic_errors(float outlier_threshold,  //min outlier
                                   double a,                 //from curve
                                   float m,
                                   float c);

    BOOL8 fitted;                //line parts valid
    inT32 samplesize;            //max samples
    inT32 samplecount;           //current sample size
    FCOORD *samples;             //array of samples
    float *errors;               //error distances
    double a;                    //x squared
    float m;                     //line gradient
    float c;
    float line_error;            //error of fit
};
extern INT_VAR_H (lms_line_trials, 12, "Number of linew fits to do");
/////////////////////////////////////////////////////////////////lmedsq////////////////////////////////////////

/////////////////////////////////////////////////////////////////fpchop////////////////////////////////////////
class OUTLINE_FRAG:public ELIST_LINK
{
  public:
    OUTLINE_FRAG() {
    }                            //empty constructor
                                 //head of fragment
    OUTLINE_FRAG(POLYPT_IT *head_it, POLYPT_IT *tail_it);  //tail of fragment
                                 //other end
    OUTLINE_FRAG(OUTLINE_FRAG *head, float tail_y);

    POLYPT_LIST polypts;         //only if a head
    OUTLINE_FRAG *other_end;     //head if a tail
    float ycoord;                //coord of cut pt

  private:
};

class C_OUTLINE_FRAG:public ELIST_LINK
{
  public:
    C_OUTLINE_FRAG() {  //empty constructor
      steps = NULL;
      stepcount = 0;
    }
    ~C_OUTLINE_FRAG () {
      if (steps != NULL)
        delete [] steps;
    }
                                 //start coord
    C_OUTLINE_FRAG(ICOORD start_pt,
                   ICOORD end_pt,       //end coord
                   C_OUTLINE *outline,  //source of steps
                   inT16 start_index,
                   inT16 end_index);
                                 //other end
    C_OUTLINE_FRAG(C_OUTLINE_FRAG *head, inT16 tail_y);
    C_OUTLINE *close();  //copy to outline
    C_OUTLINE_FRAG & operator= ( //assign
      const C_OUTLINE_FRAG & src);

    ICOORD start;                //start coord
    ICOORD end;                  //end coord
    DIR128 *steps;                //step array
    inT32 stepcount;             //no of steps
    C_OUTLINE_FRAG *other_end;   //head if a tail
    inT16 ycoord;                //coord of cut pt

  private:
};

ELISTIZEH (OUTLINE_FRAG) ELISTIZEH (C_OUTLINE_FRAG)
extern
INT_VAR_H (textord_fp_chop_error, 2,
"Max allowed bending of chop cells");
extern
double_VAR_H (textord_fp_chop_snap, 0.5,
"Max distance of chop pt from vertex");
ROW *fixed_pitch_words(                 //find lines
                       TO_ROW *row,     //row to do
                       FCOORD rotation  //for drawing
                      );
WERD *add_repeated_word(                         //move repeated word
                        WERD_IT *rep_it,         //repeated words
                        inT16 &rep_left,         //left edge of word
                        inT16 &prev_chop_coord,  //previous word end
                        uinT8 &blanks,           //no of blanks
                        float pitch,             //char cell size
                        WERD_IT *word_it         //list of words
                       );
void split_to_blob(                                 //split the blob
                   BLOBNBOX *blob,                  //blob to split
                   inT16 chop_coord,                //place to chop
                   float pitch_error,               //allowed deviation
                   OUTLINE_LIST *left_outlines,     //left half of chop
                   C_OUTLINE_LIST *left_coutlines,  //for cblobs
                   OUTLINE_LIST *right_outlines,    //right half of chop
                   C_OUTLINE_LIST *right_coutlines);
void fixed_chop_blob(                              //split the blob
                     PBLOB *blob,                  //blob to split
                     inT16 chop_coord,             //place to chop
                     float pitch_error,            //allowed deviation
                     OUTLINE_LIST *left_outlines,  //left half of chop
                     OUTLINE_LIST *right_outlines  //right half of chop
                    );
void fixed_split_outline(                      //chop the outline
                         OUTLINE *srcline,     //source outline
                         inT16 chop_coord,     //place to chop
                         float pitch_error,    //allowed deviation
                         OUTLINE_IT *left_it,  //left half of chop
                         OUTLINE_IT *right_it  //right half of chop
                        );
BOOL8 fixed_chop_outline(                                //chop the outline
                         OUTLINE *srcline,               //source outline
                         inT16 chop_coord,               //place to chop
                         float pitch_error,              //allowed deviation
                         OUTLINE_FRAG_LIST *left_frags,  //left half of chop
                         OUTLINE_FRAG_LIST *right_frags  //right half of chop
                        );
void save_chop_fragment(                          //chop the outline
                        POLYPT_IT *head_it,       //head of fragment
                        POLYPT_IT *tail_it,       //tail of fragment
                        OUTLINE_FRAG_LIST *frags  //fragment list
                       );
void add_frag_to_list(                          //ordered add
                      OUTLINE_FRAG *frag,       //fragment to add
                      OUTLINE_FRAG_LIST *frags  //fragment list
                     );
void insert_chop_pt(                  //make chop
                    POLYPT_IT *it,    //iterator
                    inT16 chop_coord  //required chop pt
                   );
FCOORD find_chop_coords(                  //make chop
                        POLYPT_IT *it,    //iterator
                        inT16 chop_coord  //required chop pt
                       );
void insert_extra_pt(               //make extra
                     POLYPT_IT *it  //iterator
                    );
void close_chopped_fragments(                           //chop the outline
                             OUTLINE_FRAG_LIST *frags,  //list to clear
                             OUTLINE_LIST *children,    //potential children
                             OUTLINE_IT *dest_it        //output list
                            );
void join_chopped_fragments(                       //join pieces
                            OUTLINE_FRAG *bottom,  //bottom of cut
                            OUTLINE_FRAG *top      //top of cut
                           );
void fixed_chop_cblob(                                //split the blob
                      C_BLOB *blob,                   //blob to split
                      inT16 chop_coord,               //place to chop
                      float pitch_error,              //allowed deviation
                      C_OUTLINE_LIST *left_outlines,  //left half of chop
                      C_OUTLINE_LIST *right_outlines  //right half of chop
                     );
void fixed_split_coutline(                        //chop the outline
                          C_OUTLINE *srcline,     //source outline
                          inT16 chop_coord,       //place to chop
                          float pitch_error,      //allowed deviation
                          C_OUTLINE_IT *left_it,  //left half of chop
                          C_OUTLINE_IT *right_it  //right half of chop
                         );
BOOL8 fixed_chop_coutline(                                  //chop the outline
                          C_OUTLINE *srcline,               //source outline
                          inT16 chop_coord,                 //place to chop
                          float pitch_error,                //allowed deviation
                          C_OUTLINE_FRAG_LIST *left_frags,  //left half of chop
                          C_OUTLINE_FRAG_LIST *right_frags  //right half of chop
                         );
inT16 next_anti_left_seg(                     //chop the outline
                         C_OUTLINE *srcline,  //source outline
                         inT16 tail_index,    //of tailpos
                         inT16 startindex,    //end of search
                         inT32 length,        //of outline
                         inT16 chop_coord,    //place to chop
                         float pitch_error,   //allowed deviation
                         ICOORD *tail_pos     //current position
                        );
inT16 next_anti_right_seg(                     //chop the outline
                          C_OUTLINE *srcline,  //source outline
                          inT16 tail_index,    //of tailpos
                          inT16 startindex,    //end of search
                          inT32 length,        //of outline
                          inT16 chop_coord,    //place to chop
                          float pitch_error,   //allowed deviation
                          ICOORD *tail_pos     //current position
                         );
inT16 next_clock_left_seg(                     //chop the outline
                          C_OUTLINE *srcline,  //source outline
                          inT16 tail_index,    //of tailpos
                          inT16 startindex,    //end of search
                          inT32 length,        //of outline
                          inT16 chop_coord,    //place to chop
                          float pitch_error,   //allowed deviation
                          ICOORD *tail_pos     //current position
                         );
inT16 next_clock_right_seg(                     //chop the outline
                           C_OUTLINE *srcline,  //source outline
                           inT16 tail_index,    //of tailpos
                           inT16 startindex,    //end of search
                           inT32 length,        //of outline
                           inT16 chop_coord,    //place to chop
                           float pitch_error,   //allowed deviation
                           ICOORD *tail_pos     //current position
                          );
void save_chop_cfragment(                            //chop the outline
                         inT16 head_index,           //head of fragment
                         ICOORD head_pos,            //head of fragment
                         inT16 tail_index,           //tail of fragment
                         ICOORD tail_pos,            //tail of fragment
                         C_OUTLINE *srcline,         //source of edgesteps
                         C_OUTLINE_FRAG_LIST *frags  //fragment list
                        );
void add_frag_to_list(                            //ordered add
                      C_OUTLINE_FRAG *frag,       //fragment to add
                      C_OUTLINE_FRAG_LIST *frags  //fragment list
                     );
void close_chopped_cfragments(                             //chop the outline
                              C_OUTLINE_FRAG_LIST *frags,  //list to clear
                              C_OUTLINE_LIST *children,    //potential children
                              float pitch_error,           //allowed shrinkage
                              C_OUTLINE_IT *dest_it        //output list
                             );
C_OUTLINE *join_chopped_fragments(                         //join pieces
                                  C_OUTLINE_FRAG *bottom,  //bottom of cut
                                  C_OUTLINE_FRAG *top      //top of cut
                                 );
void join_segments(                         //join pieces
                   C_OUTLINE_FRAG *bottom,  //bottom of cut
                   C_OUTLINE_FRAG *top      //top of cut
                  );
/////////////////////////////////////////////////////////////////fpchop////////////////////////////////////////

/////////////////////////////////////////////////////////////////underlin////////////////////////////////////////
extern double_VAR_H (textord_underline_offset, 0.1, "Fraction of x to ignore");
extern BOOL_VAR_H (textord_restore_underlines, FALSE, "Chop underlines & put back");

//get chop points             //block to do
void restore_underlined_blobs(TO_BLOCK *block);

//find best row
TO_ROW *most_overlapping_row(
                             TO_ROW_LIST *rows,  //list of rows
                             BLOBNBOX *blob      //blob to place
                            );

//get chop points
void find_underlined_blobs(BLOBNBOX *u_line,           //underlined unit
                           QSPLINE *baseline,          //actual baseline
                           float xheight,              //height of line
                           float baseline_offset,      //amount to shrinke it
                           ICOORDELT_LIST *chop_cells  //places to chop
                          );

//project outlines
void vertical_cunderline_projection(C_OUTLINE *outline,     //outline to project
                                    QSPLINE *baseline,      //actual baseline
                                    float xheight,          //height of line
                                    float baseline_offset,  //amount to shrinke it
                                    STATS *lower_proj,      //below baseline
                                    STATS *middle_proj,     //centre region
                                    STATS *upper_proj       //top region
                                   );
/////////////////////////////////////////////////////////////////underlin////////////////////////////////////////

/////////////////////////////////////////////////////////////////blkocc////////////////////////////////////////
/***************************************************************************
CLASS REGION_OCC

  The class REGION_OCC defines a section of outline which exists entirely
  within a single region. The only data held is the min and max x limits of
  the outline within the region.

  REGION_OCCs are held on lists, one list for each region.  The lists are
  built in sorted order of min x. Overlapping REGION_OCCs are not permitted on
  a single list. An overlapping region to be added causes the existing region
  to be extended. This extension may result in the following REGION_OCC on the
  list overlapping the ammended one. In this case the ammended REGION_OCC is
  further extended to include the range of the following one, so that the
  following one can be deleted.

****************************************************************************/

class REGION_OCC:public ELIST_LINK
{
public:
    float min_x;                 //Lowest x in region
    float max_x;                 //Highest x in region
    inT16 region_type;           //Type of crossing

    REGION_OCC() {}//constructor used

    //only in COPIER etc  //constructor
    REGION_OCC(float min, float max, inT16 region)
    {
        min_x = min;
        max_x = max;
        region_type = region;
    }
};

ELISTIZEH (REGION_OCC)
#define RANGE_IN_BAND( band_max, band_min, range_max, range_min ) \
    ( ((range_min) >= (band_min)) && ((range_max) < (band_max)) ) ? TRUE : FALSE
/************************************************************************
Adapted from the following procedure so that it can be used in the bands
class in an include file...

BOOL8						range_in_band[
              range within band?
inT16						band_max,
inT16						band_min,
inT16						range_max,
inT16						range_min]
{
  if ( (range_min >= band_min) && (range_max < band_max) )
    return TRUE;
  else
    return FALSE;
}
***********************************************************************/
#define RANGE_OVERLAPS_BAND( band_max, band_min, range_max, range_min ) \
    ( ((range_max) >= (band_min)) && ((range_min) < (band_max)) ) ? TRUE : FALSE
/************************************************************************
Adapted from the following procedure so that it can be used in the bands
class in an include file...

BOOL8						range_overlaps_band[
              range crosses band?
inT16						band_max,
inT16						band_min,
inT16						range_max,
inT16						range_min]
{
  if ( (range_max >= band_min) && (range_min < band_max) )
    return TRUE;
  else
    return FALSE;
}
***********************************************************************/
/**********************************************************************
  Bands
  -----

  BAND 4
--------------------------------
  BAND 3
--------------------------------

  BAND 2

--------------------------------

  BAND 1

Band 0 is the dot band

Each band has an error margin above and below. An outline is not considered to
have significantly changed bands until it has moved out of the error margin.
*************************************************************************/
class BAND
{
    public:
    inT16 max_max;               //upper max
    inT16 max;                   //nominal max
    inT16 min_max;               //lower max
    inT16 max_min;               //upper min
    inT16 min;                   //nominal min
    inT16 min_min;               //lower min

    BAND()
    {
    }                            // constructor

    void set(                      // initialise a band
                                   inT16 new_max_max,    // upper max
                                   inT16 new_max,        // new nominal max
                                   inT16 new_min_max,    // new lower max
                                   inT16 new_max_min,    // new upper min
                                   inT16 new_min,        // new nominal min
                                   inT16 new_min_min)
    {  // new lower min
        max_max = new_max_max;
        max = new_max;
        min_max = new_min_max;
        max_min = new_max_min;
        min = new_min;
        min_min = new_min_min;
    }

    //in minimal limits?
    BOOL8 in_minimal(float y)
    {  //y value
        if ((y >= max_min) && (y < min_max))
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    //in nominal limits?
    BOOL8 in_nominal(float y)
    {
        //y value
        if ((y >= min) && (y < max))
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    //in maximal limits?
    BOOL8 in_maximal(float y)
    {
        //y value
        if ((y >= min_min) && (y < max_max))
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    //overlaps min limits?  //one range limit
    BOOL8 range_overlaps_minimal(float y1, float y2)
    {
        //other range limit
        if (y1 > y2)
        {
            return RANGE_OVERLAPS_BAND (min_max, max_min, y1, y2);
        }
        else
        {
            return RANGE_OVERLAPS_BAND (min_max, max_min, y2, y1);
        }
    }

    //overlaps nom limits?    //one range limit
    BOOL8 range_overlaps_nominal(float y1, float y2)
    {
        //other range limit
        if (y1 > y2)
        {
            return RANGE_OVERLAPS_BAND (max, min, y1, y2);
        }
        else
        {
            return RANGE_OVERLAPS_BAND (max, min, y2, y1);
        }
    }

    //overlaps max limits?   //one range limit
    BOOL8 range_overlaps_maximal(float y1, float y2)
    {
        //other range limit
        if (y1 > y2)
        {
            return RANGE_OVERLAPS_BAND (max_max, min_min, y1, y2);
        }
        else
        {
            return RANGE_OVERLAPS_BAND (max_max, min_min, y2, y1);
        }
    }

    //within min limits?   //one range limit
    BOOL8 range_in_minimal(float y1, float y2)
    {
        //other range limit
        if (y1 > y2)
        {
            return RANGE_IN_BAND (min_max, max_min, y1, y2);
        }
        else
        {
            return RANGE_IN_BAND (min_max, max_min, y2, y1);
        }
    }

    //within nom limits? //one range limit
    BOOL8 range_in_nominal(float y1, float y2)
    {
        //other range limit
        if (y1 > y2)
        {
            return RANGE_IN_BAND (max, min, y1, y2);
        }
        else
        {
            return RANGE_IN_BAND (max, min, y2, y1);
        }
    }

    //within max limits? //one range limit
    BOOL8 range_in_maximal(float y1, float y2)
    {
        //other range limit
        if (y1 > y2)
        {
            return RANGE_IN_BAND (max_max, min_min, y1, y2);
        }
        else
        {
            return RANGE_IN_BAND (max_max, min_min, y2, y1);
        }
    }
};

/* Standard positions */

#define MAX_NUM_BANDS 5
#define UNDEFINED_BAND 99
#define NO_LOWER_LIMIT -9999
#define NO_UPPER_LIMIT 9999

#define DOT_BAND 0

/* Special occupancy code emitted for the 0 region at the end of a word */

#define END_OF_WERD_CODE 255

extern BOOL_VAR_H (blockocc_show_result, FALSE, "Show intermediate results");
extern INT_VAR_H (blockocc_desc_height, 0,
                  "Descender height after normalisation");
extern INT_VAR_H (blockocc_asc_height, 255,
                  "Ascender height after normalisation");
extern INT_VAR_H (blockocc_band_count, 4, "Number of bands used");
extern double_VAR_H (textord_underline_threshold, 0.9,
                     "Fraction of width occupied");
BOOL8 test_underline(                   //look for underlines
                                        BOOL8 testing_on,  //drawing blob
                                        PBLOB *blob,       //blob to test
                                        float baseline,    //coords of baseline
                                        float xheight      //height of line
                                        );
BOOL8 test_underline(                   //look for underlines
                                        BOOL8 testing_on,  //drawing blob
                                        C_BLOB *blob,      //blob to test
                                        inT16 baseline,    //coords of baseline
                                        inT16 xheight      //height of line
                                        );
void block_occ (PBLOB * blob,    //blob to do
                float occs[]                     //output histogram
                );
/////////////////////////////////////////////////////////////////blkocc////////////////////////////////////////

/////////////////////////////////////////////////////////////////quadlsq////////////////////////////////////////
class QLSQ
{
  public:
    QLSQ() {  //constructor
      clear();  //set to zeros
    }
    void clear();  //initialize

    void add(           //add element
             double x,  //coords to add
             double y);
    void remove(           //delete element
                double x,  //coords to delete
                double y);
    inT32 count() {  //no of elements
      return n;
    }

    void fit(              //fit the given
             int degree);  //return actual
    double get_a() {  //get x squard
      return a;
    }
    double get_b() {  //get x squard
      return b;
    }
    double get_c() {  //get x squard
      return c;
    }

  private:
    inT32 n;                     //no of elements
    double a, b, c;              //result
    double sigx;                 //sum of x
    double sigy;                 //sum of y
    double sigxx;                //sum x squared
    double sigxy;                //sum of xy
    double sigyy;                //sum y squared
    long double sigxxx;          //sum x cubed
    long double sigxxy;          //sum xsquared y
    long double sigxxxx;         //sum x fourth
};
/////////////////////////////////////////////////////////////////quadlsq////////////////////////////////////////

/////////////////////////////////////////////////////////////////oldbasel////////////////////////////////////////
extern BOOL_VAR_H (textord_really_old_xheight, FALSE, "Use original wiseowl xheight");
extern BOOL_VAR_H (textord_oldbl_debug, FALSE, "Debug old baseline generation");
extern BOOL_VAR_H (textord_debug_baselines, FALSE, "Debug baseline generation");
extern BOOL_VAR_H (textord_oldbl_paradef, TRUE, "Use para default mechanism");
extern BOOL_VAR_H (textord_oldbl_split_splines, TRUE, "Split stepped splines");
extern BOOL_VAR_H (textord_oldbl_merge_parts, TRUE, "Merge suspect partitions");
extern BOOL_VAR_H (oldbl_xhfix, FALSE, "Fix bug in modes threshold for xheights");
extern INT_VAR_H (oldbl_holed_losscount, 10, "Max lost before fallback line used");
extern double_VAR_H (oldbl_dot_error_size, 1.26, "Max aspect ratio of a dot");
extern double_VAR_H (textord_oldbl_jumplimit, 0.15, "X fraction for new partition");

//make splines
void make_old_baselines(TO_BLOCK *block,  //block to do
                        BOOL8 testing_on, //correct orientation
                        float gradient,
                        Tesseract *tess
                       );

//cleanup lines
void correlate_lines(TO_BLOCK *block, //block to do
                     float gradient,
                     Tesseract* tess
                    );

//fix bad rows
void correlate_neighbours(TO_BLOCK *block,  /*block rows are in */
                          TO_ROW **rows,    /*rows of block */
                          int rowcount,     /*no of rows to do */
                          Tesseract* tess
                         );

//fix xheights
int correlate_with_stats(TO_ROW **rows,  /*rows of block */
                         int rowcount,   /*no of rows to do */
                         TO_BLOCK *block  /*block rows are in */
                        );

//get baseline
void find_textlines(TO_BLOCK *block,  //block row is in
                    TO_ROW *row,      //row to do
                    int degree,       //required approximation
                    QSPLINE *spline,  //starting spline
                    Tesseract *tess
                   );

//get boxes
int get_blob_coords(TO_ROW *row,        //row to use
                    inT32 lineheight,   //block level
                    TBOX *blobcoords,    //ouput boxes
                    BOOL8 &holed_line,  //lost a lot of blobs
                    int &outcount       //no of real blobs
                   );

//initial approximation
void make_first_baseline(
                    TBOX blobcoords[],                /*blob bounding boxes */
                    int blobcount,                   /*no of blobcoords */
                    int xcoords[],                   /*coords for spline */
                    int ycoords[],                   /*approximator */
                    QSPLINE * spline,                /*initial spline */
                    QSPLINE * baseline,              /*output spline */
                    float jumplimit                  /*guess half descenders */
);

//initial approximation
void make_holed_baseline(TBOX blobcoords[],                /*blob bounding boxes */
                          int blobcount,                   /*no of blobcoords */
                          QSPLINE * spline,                /*initial spline */
                          QSPLINE * baseline,              /*output spline */
                          float gradient                   //of line
                         );

//partition blobs
int partition_line(
                TBOX blobcoords[],                //bounding boxes
                int blobcount,                   /*no of blobs on row */
                int *numparts,                   /*number of partitions */
                char partids[],                  /*partition no of each blob */
                int partsizes[],                 /*no in each partition */
                QSPLINE * spline,                /*curve to fit to */
                float jumplimit,                 /*allowed delta change */
                float ydiffs[]                   /*diff from spline */
               );

void merge_oldbl_parts (         //partition blobs
                TBOX blobcoords[],                //bounding boxes
                int blobcount,                   /*no of blobs on row */
                char partids[],                  /*partition no of each blob */
                int partsizes[],                 /*no in each partition */
                int biggestpart,                 //major partition
                float jumplimit                  /*allowed delta change */
);

int get_ydiffs (                 //evaluate differences
                TBOX blobcoords[],                //bounding boxes
                int blobcount,                   /*no of blobs */
                QSPLINE * spline,                /*approximating spline */
                float ydiffs[]                   /*output */
);

int choose_partition (           //select partition
                register float diff,             /*diff from spline */
                float partdiffs[],               /*diff on all parts */
                int lastpart,                    /*last assigned partition */
                float jumplimit,                 /*new part threshold */
                int *partcount                   /*no of partitions */
);

int partition_coords (           //find relevant coords
                TBOX blobcoords[],                //bounding boxes
                int blobcount,                   /*no of blobs in row */
                char partids[],                  /*partition no of each blob */
                int bestpart,                    /*best new partition */
                int xcoords[],                   /*points to work on */
                int ycoords[]                    /*points to work on */
);

int segment_spline (             //make xstarts
                TBOX blobcoords[],                //boundign boxes
                int blobcount,                   /*no of blobs in row */
                int xcoords[],                   /*points to work on */
                int ycoords[],                   /*points to work on */
                int degree, int pointcount,      /*no of points */
                int xstarts[]                    //result
);

BOOL8 split_stepped_spline (     //make xstarts
                QSPLINE * baseline,              //current shot
                float jumplimit,                 //max step fuction
                int xcoords[],                   /*points to work on */
                int xstarts[],                   //result
                int &segments                    //no of segments
);

void insert_spline_point (       //get descenders
                int xstarts[],                   //starts to shuffle
                int segment,                     //insertion pt
                int coord1,                      //coords to add
                int coord2, int &segments        //total segments
);

void find_lesser_parts (         //get descenders
                TO_ROW * row,                    //row to process
                TBOX blobcoords[],                //bounding boxes
                int blobcount,                   /*no of blobs */
                char partids[],                  /*partition of each blob */
                int partsizes[],                 /*size of each part */
                int partcount,                   /*no of partitions */
                int bestpart                     /*biggest partition */
);

void old_first_xheight (         //the wiseowl way
                TO_ROW * row,                    /*current row */
                TBOX blobcoords[],                /*blob bounding boxes */
                int initialheight,               //initial guess
                int blobcount,                   /*blobs in blobcoords */
                QSPLINE * baseline,              /*established */
                float jumplimit                  /*min ascender height */
);

void make_first_xheight (        //find xheight
                TO_ROW * row,                    /*current row */
                TBOX blobcoords[],                /*blob bounding boxes */
                int lineheight,                  //initial guess
                int init_lineheight,             //block level guess
                int blobcount,                   /*blobs in blobcoords */
                QSPLINE * baseline,              /*established */
                float jumplimit                  /*min ascender height */
);

int *make_height_array (         //get array of heights
                TBOX blobcoords[],                /*blob bounding boxes */
                int blobcount,                   /*blobs in blobcoords */
                QSPLINE * baseline               /*established */
);

void find_top_modes (            //get modes
                STATS * stats,                   //stats to hack
                int statnum,                     //no of piles
                int modelist[], int modenum      //no of modes to get
);

void pick_x_height(TO_ROW * row,                    //row to do
int modelist[],
int lefts[], int rights[],
STATS * heightstat,
int mode_threshold);
/////////////////////////////////////////////////////////////////oldbasel////////////////////////////////////////

/////////////////////////////////////////////////////////////////sortflts////////////////////////////////////////
class SORTED_FLOAT:public ELIST_LINK
{
  friend class SORTED_FLOATS;

  public:
    SORTED_FLOAT() {
    }                            //empty constructor
    SORTED_FLOAT(              //create one
                 float value,  //value of entry
                 inT32 key) {  //reference
      entry = value;
      address = key;
    }
  private:
    float entry;                 //value of float
    inT32 address;               //key
};

ELISTIZEH (SORTED_FLOAT)
class SORTED_FLOATS
{
  public:
    /** empty constructor */
    SORTED_FLOATS() {
      it.set_to_list (&list);
    }
    /**
     * add sample
     * @param value sample float
     * @param key retrieval key
     */
    void add(float value,
             inT32 key);
    /**
     * delete sample
     * @param key key to delete
     */
    void remove(inT32 key);
    /**
     * index to list
     * @param index item to get
     */
    float operator[] (inT32 index);

  private:
    SORTED_FLOAT_LIST list;      //list of floats
    SORTED_FLOAT_IT it;          //iterator built-in
};
/////////////////////////////////////////////////////////////////sortflts////////////////////////////////////////

/////////////////////////////////////////////////////////////////makerow////////////////////////////////////////
enum OVERLAP_STATE
{
  ASSIGN,                        //assign it to row
  REJECT,                        //reject it - dual overlap
  NEW_ROW
};

enum ROW_CATEGORY
{
  ROW_ASCENDERS_FOUND,
  ROW_DESCENDERS_FOUND,
  ROW_UNKNOWN,
  ROW_INVALID,
};

extern BOOL_VAR_H (textord_show_initial_rows, FALSE, "Display row accumulation");
extern BOOL_VAR_H (textord_show_parallel_rows, FALSE, "Display page correlated rows");
extern BOOL_VAR_H (textord_show_expanded_rows, FALSE, "Display rows after expanding");
extern BOOL_VAR_H (textord_show_final_rows, FALSE, "Display rows after final fitting");
extern BOOL_VAR_H (textord_show_final_blobs, FALSE, "Display blob bounds after pre-ass");
extern BOOL_VAR_H (textord_test_landscape, FALSE, "Tests refer to land/port");
extern BOOL_VAR_H (textord_parallel_baselines, TRUE, "Force parallel baselines");
extern BOOL_VAR_H (textord_straight_baselines, FALSE, "Force straight baselines");
extern BOOL_VAR_H (textord_quadratic_baselines, FALSE, "Use quadratic splines");
extern BOOL_VAR_H (textord_old_baselines, TRUE, "Use old baseline algorithm");
extern BOOL_VAR_H (textord_old_xheight, TRUE, "Use old xheight algorithm");
extern BOOL_VAR_H (textord_fix_xheight_bug, TRUE, "Use spline baseline");
extern BOOL_VAR_H (textord_fix_makerow_bug, TRUE, "Prevent multiple baselines");
extern BOOL_VAR_H (textord_cblob_blockocc, TRUE, "Use new projection for underlines");
extern BOOL_VAR_H (textord_debug_xheights, FALSE, "Test xheight algorithms");
extern INT_VAR_H (textord_test_x, 0, "coord of test pt");
extern INT_VAR_H (textord_test_y, 0, "coord of test pt");
extern INT_VAR_H (textord_min_blobs_in_row, 4, "Min blobs before gradient counted");
extern INT_VAR_H (textord_spline_minblobs, 8, "Min blobs in each spline segment");
extern INT_VAR_H (textord_spline_medianwin, 6,"Size of window for spline segmentation");
extern INT_VAR_H (textord_min_xheight, 10, "Min credible pixel xheight");
extern double_VAR_H (textord_spline_shift_fraction, 0.02, "Fraction of line spacing for quad");
extern double_VAR_H (textord_spline_outlier_fraction, 0.1, "Fraction of line spacing for outlier");
extern double_VAR_H (textord_skew_ile, 0.5, "Ile of gradients for page skew");
extern double_VAR_H (textord_skew_lag, 0.75,"Lag for skew on row accumulation");
extern double_VAR_H (textord_linespace_iqrlimit, 0.2,"Max iqr/median for linespace");
extern double_VAR_H (textord_width_limit, 8,"Max width of blobs to make rows");
extern double_VAR_H (textord_chop_width, 1.5, "Max width before chopping");
extern double_VAR_H (textord_merge_desc, 0.25,"Fraction of linespace for desc drop");
extern double_VAR_H (textord_merge_x, 0.5,"Fraction of linespace for x height");
extern double_VAR_H (textord_merge_asc, 0.25,"Fraction of linespace for asc height");
extern double_VAR_H (textord_minxh, 0.25,"fraction of linesize for min xheight");
extern double_VAR_H (textord_min_linesize, 1.25,"* blob height for initial linesize");
extern double_VAR_H (textord_excess_blobsize, 1.3,"New row made if blob makes row this big");
extern double_VAR_H (textord_occupancy_threshold, 0.4,"Fraction of neighbourhood");
extern double_VAR_H (textord_underline_width, 2.0,"Multiple of line_size for underline");
extern double_VAR_H(textord_min_blob_height_fraction, 0.75,"Min blob height/top to include blob top into xheight stats");
extern double_VAR_H (textord_xheight_mode_fraction, 0.4,"Min pile height to make xheight");
extern double_VAR_H (textord_ascheight_mode_fraction, 0.15,"Min pile height to make ascheight");
extern double_VAR_H (textord_ascx_ratio_min, 1.2, "Min cap/xheight");
extern double_VAR_H (textord_ascx_ratio_max, 1.7, "Max cap/xheight");
extern double_VAR_H (textord_descx_ratio_min, 0.15, "Min desc/xheight");
extern double_VAR_H (textord_descx_ratio_max, 0.6, "Max desc/xheight");
extern double_VAR_H (textord_xheight_error_margin, 0.1, "Accepted variation");

inline void get_min_max_xheight(double block_linesize, int *min_height, int *max_height)
{
  *min_height = static_cast<inT32>(floor(block_linesize * textord_minxh));

  if (*min_height < textord_min_xheight) *min_height = textord_min_xheight;
  {
        *max_height = static_cast<inT32>(ceil(block_linesize * 3));
  }
}

inline ROW_CATEGORY get_row_category(const TO_ROW *row)
{
  if (row->xheight <= 0) return ROW_INVALID;

  return (row->ascrise > 0) ? ROW_ASCENDERS_FOUND : (row->descdrop != 0) ? ROW_DESCENDERS_FOUND : ROW_UNKNOWN;
}

inline bool within_error_margin(float test, float num, float margin)
{
  return (test >= num * (1 - margin) && test <= num * (1 + margin));
}

void fill_heights(TO_ROW *row, float gradient, int min_height, int max_height, STATS *heights, STATS *floating_heights);

float make_single_row(ICOORD page_tr, TO_BLOCK* block, TO_BLOCK_LIST* blocks, Tesseract* tess);
float make_rows(                             //make rows
                ICOORD page_tr,              //top right
                BLOCK_LIST *blocks,          //block list
                TO_BLOCK_LIST *land_blocks,  //rotated for landscape
                TO_BLOCK_LIST *port_blocks,  //output list
                Tesseract* tess
               );

void make_initial_textrows(                  //find lines
                           ICOORD page_tr,
                           TO_BLOCK *block,  //block to do
                           FCOORD rotation,  //for drawing
                           BOOL8 testing_on  //correct orientation
                          );

void fit_lms_line(             //sort function
                  TO_ROW *row  //row to fit
                 );

void compute_page_skew(                        //get average gradient
                       TO_BLOCK_LIST *blocks,  //list of blocks
                       float &page_m,          //average gradient
                       float &page_err         //average error
                      );

void cleanup_rows(                   //find lines
                  ICOORD page_tr,    //top right
                  TO_BLOCK *block,   //block to do
                  float gradient,    //gradient to fit
                  FCOORD rotation,   //for drawing
                  inT32 block_edge,  //edge of block
                  BOOL8 testing_on,  //correct orientation
                  Tesseract* tess
                 );

void delete_non_dropout_rows(                   //find lines
                             TO_BLOCK *block,   //block to do
                             float gradient,    //global skew
                             FCOORD rotation,   //deskew vector
                             inT32 block_edge,  //left edge
                             BOOL8 testing_on   //correct orientation
                            );

BOOL8 find_best_dropout_row(                    //find neighbours
                            TO_ROW *row,        //row to test
                            inT32 distance,     //dropout dist
                            float dist_limit,   //threshold distance
                            inT32 line_index,   //index of row
                            TO_ROW_IT *row_it,  //current position
                            BOOL8 testing_on    //correct orientation
                           );

TBOX deskew_block_coords(                  //block box
                        TO_BLOCK *block,  //block to do
                        float gradient    //global skew
                       );

void compute_line_occupation(                    //project blobs
                             TO_BLOCK *block,    //block to do
                             float gradient,     //global skew
                             inT32 min_y,        //min coord in block
                             inT32 max_y,        //in block
                             inT32 *occupation,  //output projection
                             inT32 *deltas       //derivative
                            );

void compute_occupation_threshold(                    //project blobs
                                  inT32 low_window,   //below result point
                                  inT32 high_window,  //above result point
                                  inT32 line_count,   //array sizes
                                  inT32 *occupation,  //input projection
                                  inT32 *thresholds   //output thresholds
                                 );

void compute_dropout_distances(                    //project blobs
                               inT32 *occupation,  //input projection
                               inT32 *thresholds,  //output thresholds
                               inT32 line_count    //array sizes
                              );

void expand_rows(                   //find lines
                 ICOORD page_tr,    //top right
                 TO_BLOCK *block,   //block to do
                 float gradient,    //gradient to fit
                 FCOORD rotation,   //for drawing
                 inT32 block_edge,  //edge of block
                 BOOL8 testing_on   //correct orientation
                );

void adjust_row_limits(                 //tidy limits
                       TO_BLOCK *block  //block to do
                      );

void compute_row_stats(                  //find lines
                       TO_BLOCK *block,  //block to do
                       BOOL8 testing_on  //correct orientation
                      );

void compute_block_xheight(                  //find lines
                           TO_BLOCK *block,  //block to do
                           float gradient,   //global skew
                           Tesseract* tess
                          );

float median_block_xheight(                  //find lines
                           TO_BLOCK *block,  //block to do
                           float gradient    //global skew
                          );

void compute_row_xheight(                   //find lines
                         TO_ROW *row,       //row to do
                         float gradient,    //global skew
                         int block_height,  //a guess of block xheight
                         Tesseract* tess
                        );

int compute_xheight_from_modes(
    STATS *heights, STATS *floating_heights, int min_height,
    int max_height, float *xheight, float *ascrise);

inT32 compute_row_descdrop(                 // find lines
                           TO_ROW *row,     // row to do
                           float gradient,  // global skew
                           int xheight_blob_count,
                           STATS *heights
                          );

inT32 compute_height_modes(                   //find lines
                           STATS *heights,    //stats to search
                           inT32 min_height,  //bottom of range
                           inT32 max_height,  //top of range
                           inT32 *modes,      //output array
                           inT32 maxmodes     //size of modes
                          );

void correct_row_xheight(                //fix bad values
                         TO_ROW *row,    //row to fix
                         float xheight,  //average values
                         float ascrise,
                         float descdrop);

void separate_underlines(                  //make rough chars
                         TO_BLOCK *block,  //block to do
                         float gradient,   //skew angle
                         FCOORD rotation,  //inverse landscape
                         BOOL8 testing_on  //correct orientation
                        );

void pre_associate_blobs(                  //make rough chars
                         ICOORD page_tr,   //top right
                         TO_BLOCK *block,  //block to do
                         FCOORD rotation,  //inverse landscape
                         BOOL8 testing_on  //correct orientation
                        );

void fit_parallel_rows(                   //find lines
                       TO_BLOCK *block,   //block to do
                       float gradient,    //gradient to fit
                       FCOORD rotation,   //for drawing
                       inT32 block_edge,  //edge of block
                       BOOL8 testing_on   //correct orientation
                      );

void fit_parallel_lms(                 //sort function
                      float gradient,  //forced gradient
                      TO_ROW *row      //row to fit
                     );

void make_spline_rows(                   //find lines
                      TO_BLOCK *block,   //block to do
                      float gradient,    //gradient to fit
                      FCOORD rotation,   //for drawing
                      inT32 block_edge,  //edge of block
                      BOOL8 testing_on,  //correct orientation
                      Tesseract* tess
                     );

void make_baseline_spline(                 //sort function
                          TO_ROW *row,     //row to fit
                          TO_BLOCK *block  //block it came from
                         );

BOOL8 segment_baseline (         //split baseline
TO_ROW * row,                    //row to fit
TO_BLOCK * block,                //block it came from
inT32 & segments,                //no fo segments
inT32 xstarts[]                  //coords of segments
);

double *linear_spline_baseline ( //split baseline
TO_ROW * row,                    //row to fit
TO_BLOCK * block,                //block it came from
inT32 & segments,                //no fo segments
inT32 xstarts[]                  //coords of segments
);

void assign_blobs_to_rows(                      //find lines
                          TO_BLOCK *block,      //block to do
                          float *gradient,      //block skew
                          int pass,             //identification
                          BOOL8 reject_misses,  //chuck big ones out
                          BOOL8 make_new_rows,  //add rows for unmatched
                          BOOL8 drawing_skew    //draw smoothed skew
                         );
                                 //find best row
OVERLAP_STATE most_overlapping_row(TO_ROW_IT *row_it,  //iterator
                                   TO_ROW *&best_row,  //output row
                                   float top,          //top of blob
                                   float bottom,       //bottom of blob
                                   float rowsize,      //max row size
                                   BOOL8 testing_blob  //test stuff
                                  );

int blob_x_order(                    //sort function
                 const void *item1,  //items to compare
                 const void *item2);

int row_y_order(                    //sort function
                const void *item1,  //items to compare
                const void *item2);

int row_spacing_order(                    //sort function
                      const void *item1,  //items to compare
                      const void *item2);

void mark_repeated_chars(TO_ROW *row, float block_xheight,
                         Tesseract *tess);
/////////////////////////////////////////////////////////////////makerow////////////////////////////////////////

/////////////////////////////////////////////////////////////////topitch////////////////////////////////////////
extern BOOL_VAR_H (textord_debug_pitch_test, FALSE, "Debug on fixed pitch test");
extern BOOL_VAR_H (textord_debug_pitch_metric, FALSE, "Write full metric stuff");
extern BOOL_VAR_H (textord_show_row_cuts, FALSE, "Draw row-level cuts");
extern BOOL_VAR_H (textord_show_page_cuts, FALSE, "Draw page-level cuts");
extern BOOL_VAR_H (textord_pitch_cheat, FALSE, "Use correct answer for fixed/prop");
extern BOOL_VAR_H (textord_blockndoc_fixed, TRUE, "Attempt whole doc/block fixed pitch");
extern BOOL_VAR_H (textord_fast_pitch_test, FALSE, "Do even faster pitch algorithm");
extern double_VAR_H (textord_projection_scale, 0.125, "Ding rate for mid-cuts");
extern double_VAR_H (textord_balance_factor, 2.0, "Ding rate for unbalanced char cells");

void compute_fixed_pitch(                             //determine pitch
                         ICOORD page_tr,              //top right
                         TO_BLOCK_LIST *port_blocks,  //input list
                         float gradient,              //page skew
                         FCOORD rotation,             //for drawing
                         BOOL8 testing_on,            //correct orientation
                         Tesseract* tess
                        );

void fix_row_pitch(                        //get some value
                   TO_ROW *bad_row,        //row to fix
                   TO_BLOCK *bad_block,    //block of bad_row
                   TO_BLOCK_LIST *blocks,  //blocks to scan
                   inT32 row_target,       //number of row
                   inT32 block_target      //number of block
                  );

void compute_block_pitch(                    //process each block
                         TO_BLOCK *block,    //input list
                         FCOORD rotation,    //for drawing
                         inT32 block_index,  //block number
                         BOOL8 testing_on,   //correct orientation
                         Tesseract* tess
                        );

BOOL8 compute_rows_pitch(                    //find line stats
                         TO_BLOCK *block,    //block to do
                         inT32 block_index,  //block number
                         BOOL8 testing_on    //correct orientation
                        );

BOOL8 try_doc_fixed(                             //determine pitch
                    ICOORD page_tr,              //top right
                    TO_BLOCK_LIST *port_blocks,  //input list
                    float gradient               //page skew
                   );

BOOL8 try_block_fixed(                   //find line stats
                      TO_BLOCK *block,   //block to do
                      inT32 block_index  //block number
                     );

BOOL8 try_rows_fixed(                    //find line stats
                     TO_BLOCK *block,    //block to do
                     inT32 block_index,  //block number
                     BOOL8 testing_on    //correct orientation
                    );

void print_block_counts(                   //find line stats
                        TO_BLOCK *block,   //block to do
                        inT32 block_index  //block number
                       );

void count_block_votes(                   //find line stats
                       TO_BLOCK *block,   //block to do
                       inT32 &def_fixed,  //add to counts
                       inT32 &def_prop,
                       inT32 &maybe_fixed,
                       inT32 &maybe_prop,
                       inT32 &corr_fixed,
                       inT32 &corr_prop,
                       inT32 &dunno);

BOOL8 row_pitch_stats(                  //find line stats
                      TO_ROW *row,      //current row
                      inT32 maxwidth,   //of spaces
                      BOOL8 testing_on  //correct orientation
                     );

BOOL8 find_row_pitch(                    //find lines
                     TO_ROW *row,        //row to do
                     inT32 maxwidth,     //max permitted space
                     inT32 dm_gap,       //ignorable gaps
                     TO_BLOCK *block,    //block of row
                     inT32 block_index,  //block_number
                     inT32 row_index,    //number of row
                     BOOL8 testing_on    //correct orientation
                    );

BOOL8 fixed_pitch_row(                   //find lines
                      TO_ROW *row,       //row to do
                      inT32 block_index  //block_number
                     );

BOOL8 count_pitch_stats(                       //find lines
                        TO_ROW *row,           //row to do
                        STATS *gap_stats,      //blob gaps
                        STATS *pitch_stats,    //centre-centre stats
                        float initial_pitch,   //guess at pitch
                        float min_space,       //estimate space size
                        BOOL8 ignore_outsize,  //discard big objects
                        BOOL8 split_outsize,   //split big objects
                        inT32 dm_gap           //ignorable gaps
                       );

float tune_row_pitch(                             //find fp cells
                     TO_ROW *row,                 //row to do
                     STATS *projection,           //vertical projection
                     inT16 projection_left,       //edge of projection
                     inT16 projection_right,      //edge of projection
                     float space_size,            //size of blank
                     float &initial_pitch,        //guess at pitch
                     float &best_sp_sd,           //space sd
                     inT16 &best_mid_cuts,        //no of cheap cuts
                     ICOORDELT_LIST *best_cells,  //row cells
                     BOOL8 testing_on             //inidividual words
                    );

float tune_row_pitch2(                             //find fp cells
                      TO_ROW *row,                 //row to do
                      STATS *projection,           //vertical projection
                      inT16 projection_left,       //edge of projection
                      inT16 projection_right,      //edge of projection
                      float space_size,            //size of blank
                      float &initial_pitch,        //guess at pitch
                      float &best_sp_sd,           //space sd
                      inT16 &best_mid_cuts,        //no of cheap cuts
                      ICOORDELT_LIST *best_cells,  //row cells
                      BOOL8 testing_on             //inidividual words
                     );

float compute_pitch_sd(         //find fp cells
                    TO_ROW * row,                    //row to do
                    STATS * projection,              //vertical projection
                    inT16 projection_left,           //edge
                    inT16 projection_right,          //edge
                    float space_size,                //size of blank
                    float initial_pitch,             //guess at pitch
                    float &sp_sd,                    //space sd
                    inT16 & mid_cuts,                //no of free cuts
                    ICOORDELT_LIST * row_cells,      //list of chop pts
                    BOOL8 testing_on,                //inidividual words
                    inT16 start = 0,                 //start of good range
                    inT16 end = 0                    //end of good range
);

float compute_pitch_sd2(        //find fp cells
                    TO_ROW * row,                    //row to do
                    STATS * projection,              //vertical projection
                    inT16 projection_left,           //edge
                    inT16 projection_right,          //edge
                    float initial_pitch,             //guess at pitch
                    inT16 & occupation,              //no of occupied cells
                    inT16 & mid_cuts,                //no of free cuts
                    ICOORDELT_LIST * row_cells,      //list of chop pts
                    BOOL8 testing_on,                //inidividual words
                    inT16 start = 0,                 //start of good range
                    inT16 end = 0                    //end of good range
);

void print_pitch_sd(                        //find fp cells
                    TO_ROW *row,            //row to do
                    STATS *projection,      //vertical projection
                    inT16 projection_left,  //edges //size of blank
                    inT16 projection_right,
                    float space_size,
                    float initial_pitch     //guess at pitch
                   );

int sort_floats2(                   //qsort function
                 const void *arg1,  //ptrs to floats
                 const void *arg2);

void find_repeated_chars(                  //search for equal chars
                         TO_BLOCK *block,  //block to search
                         BOOL8 testing_on, //dbug mode
                         Tesseract* tess
                        );

void plot_fp_word(                  //draw block of words
                  TO_BLOCK *block,  //block to draw
                  float pitch,      //pitch to draw with
                  float nonspace    //for space threshold
                 );
/////////////////////////////////////////////////////////////////topitch////////////////////////////////////////

/////////////////////////////////////////////////////////////////pithsync////////////////////////////////////////
class FPSEGPT_LIST;
class FPCUTPT
{
  public:
    FPCUTPT() {  //empty
    }
    void setup (                 //start of cut
      FPCUTPT cutpts[],          //predecessors
      inT16 array_origin,        //start coord
      STATS * projection,        //occupation
      inT16 zero_count,          //official zero
      inT16 pitch,               //proposed pitch
      inT16 x,                   //position
      inT16 offset);             //dist to gap

    void assign (                //evaluate cut
      FPCUTPT cutpts[],          //predecessors
      inT16 array_origin,        //start coord
      inT16 x,                   //position
      BOOL8 faking,              //faking this one
      BOOL8 mid_cut,             //doing free cut
      inT16 offset,              //extra cost dist
      STATS * projection,        //occupation
      float projection_scale,    //scaling
      inT16 zero_count,          //official zero
      inT16 pitch,               //proposed pitch
      inT16 pitch_error);        //allowed tolerance

    void assign_cheap (          //evaluate cut
      FPCUTPT cutpts[],          //predecessors
      inT16 array_origin,        //start coord
      inT16 x,                   //position
      BOOL8 faking,              //faking this one
      BOOL8 mid_cut,             //doing free cut
      inT16 offset,              //extra cost dist
      STATS * projection,        //occupation
      float projection_scale,    //scaling
      inT16 zero_count,          //official zero
      inT16 pitch,               //proposed pitch
      inT16 pitch_error);        //allowed tolerance

    inT32 position() {  //acces func
      return xpos;
    }
    double cost_function() {
      return cost;
    }
    double squares() {
      return sq_sum;
    }
    double sum() {
      return mean_sum;
    }
    FPCUTPT *previous() {
      return pred;
    }
    inT16 cheap_cuts() const {  //no of mi cuts
      return mid_cuts;
    }
    inT16 index() const {
      return region_index;
    }

    BOOL8 faked;                 //faked split point
    BOOL8 terminal;              //successful end
    inT16 fake_count;            //total fakes to here

  private:
    inT16 region_index;          //cut serial number
    inT16 mid_cuts;              //no of cheap cuts
    inT32 xpos;                  //location
    uinT32 back_balance;         //proj backwards
    uinT32 fwd_balance;          //proj forwards
    FPCUTPT *pred;               //optimal previous
    double mean_sum;             //mean so far
    double sq_sum;               //summed distsances
    double cost;                 //cost function
};
double check_pitch_sync2(                          //find segmentation
                         BLOBNBOX_IT *blob_it,     //blobs to do
                         inT16 blob_count,         //no of blobs
                         inT16 pitch,              //pitch estimate
                         inT16 pitch_error,        //tolerance
                         STATS *projection,        //vertical
                         inT16 projection_left,    //edges //scale factor
                         inT16 projection_right,
                         float projection_scale,
                         inT16 &occupation_count,  //no of occupied cells
                         FPSEGPT_LIST *seg_list,   //output list
                         inT16 start,              //start of good range
                         inT16 end                 //end of good range
                        );
double check_pitch_sync3(                          //find segmentation
                         inT16 projection_left,    //edges //to be considered 0
                         inT16 projection_right,
                         inT16 zero_count,
                         inT16 pitch,              //pitch estimate
                         inT16 pitch_error,        //tolerance
                         STATS *projection,        //vertical
                         float projection_scale,   //scale factor
                         inT16 &occupation_count,  //no of occupied cells
                         FPSEGPT_LIST *seg_list,   //output list
                         inT16 start,              //start of good range
                         inT16 end                 //end of good range
                        );
/////////////////////////////////////////////////////////////////pithsync////////////////////////////////////////

/////////////////////////////////////////////////////////////////pitsync1////////////////////////////////////////
class FPSEGPT_LIST;
class FPSEGPT:public ELIST_LINK
{
  public:
    FPSEGPT() {  //empty
    }
    FPSEGPT(           //constructor
            inT16 x);  //position
    FPSEGPT(                           //constructor
            inT16 x,                   //position
            BOOL8 faking,              //faking this one
            inT16 offset,              //extra cost dist
            inT16 region_index,        //segment number
            inT16 pitch,               //proposed pitch
            inT16 pitch_error,         //allowed tolerance
            FPSEGPT_LIST *prev_list);  //previous segment
    FPSEGPT(FPCUTPT *cutpt);  //build from new type

    inT32 position() {  //acces func
      return xpos;
    }
    double cost_function() {
      return cost;
    }
    double squares() {
      return sq_sum;
    }
    double sum() {
      return mean_sum;
    }
    FPSEGPT *previous() {
      return pred;
    }
    inT16 cheap_cuts() const {  //no of cheap cuts
      return mid_cuts;
    }

                                 //faked split point
    NEWDELETE2 (FPSEGPT) BOOL8 faked;
    BOOL8 terminal;              //successful end
    inT16 fake_count;            //total fakes to here

  private:
    inT16 mid_cuts;              //no of cheap cuts
    inT32 xpos;                  //location
    FPSEGPT *pred;               //optimal previous
    double mean_sum;             //mean so far
    double sq_sum;               //summed distsances
    double cost;                 //cost function
};

ELISTIZEH (FPSEGPT) CLISTIZEH (FPSEGPT_LIST)
extern
BOOL_VAR_H (pitsync_projection_fix, FALSE,
"Fix bug in projection profile");
extern
INT_VAR_H (pitsync_linear_version, 0, "Use new fast algorithm");
extern
double_VAR_H (pitsync_joined_edge, 0.75,
"Dist inside big blob for chopping");
extern
double_VAR_H (pitsync_offset_freecut_fraction, 0.25,
"Fraction of cut for free cuts");
extern
INT_VAR_H (pitsync_fake_depth, 1, "Max advance fake generation");
double check_pitch_sync(                        //find segmentation
                        BLOBNBOX_IT *blob_it,   //blobs to do
                        inT16 blob_count,       //no of blobs
                        inT16 pitch,            //pitch estimate
                        inT16 pitch_error,      //tolerance
                        STATS *projection,      //vertical
                        FPSEGPT_LIST *seg_list  //output list
                       );
void make_illegal_segment(                          //find segmentation
                          FPSEGPT_LIST *prev_list,  //previous segments
                          TBOX blob_box,             //bounding box
                          BLOBNBOX_IT blob_it,      //iterator
                          inT16 region_index,       //number of segment
                          inT16 pitch,              //pitch estimate
                          inT16 pitch_error,        //tolerance
                          FPSEGPT_LIST *seg_list    //output list
                         );
inT16 vertical_torow_projection(                   //project whole row
                                TO_ROW *row,       //row to do
                                STATS *projection  //output
                               );
void vertical_blob_projection(              //project outlines
                              PBLOB *blob,  //blob to project
                              STATS *stats  //output
                             );
void vertical_outline_projection(                   //project outlines
                                 OUTLINE *outline,  //outline to project
                                 STATS *stats       //output
                                );
void vertical_cblob_projection(               //project outlines
                               C_BLOB *blob,  //blob to project
                               STATS *stats   //output
                              );
void vertical_coutline_projection(                     //project outlines
                                  C_OUTLINE *outline,  //outline to project
                                  STATS *stats         //output
                                 );
/////////////////////////////////////////////////////////////////pitsync1////////////////////////////////////////

/////////////////////////////////////////////////////////////////drawtord////////////////////////////////////////
#define NO_SMD        "none"
extern BOOL_VAR_H (textord_show_fixed_cuts, FALSE,
"Draw fixed pitch cell boundaries");
extern STRING_VAR_H (to_debugfile, DEBUG_WIN_NAME, "Name of debugfile");
extern STRING_VAR_H (to_smdfile, NO_SMD, "Name of SMD file");
extern ScrollView* to_win;
extern FILE *to_debug;
void create_to_win(                //make features win
                   ICOORD page_tr  //size of page
                  );
void close_to_win();  //make features win
void create_todebug_win();  //make gradients win
void plot_box_list(                      //make gradients win
                   ScrollView* win,           //window to draw in
                   BLOBNBOX_LIST *list,  //blob list
                   ScrollView::Color body_colour    //colour to draw
                  );
void plot_to_row(                 //draw a row
                 TO_ROW *row,     //row to draw
                 ScrollView::Color colour,   //colour to draw in
                 FCOORD rotation  //rotation for line
                );
void plot_parallel_row(                 //draw a row
                       TO_ROW *row,     //row to draw
                       float gradient,  //gradients of lines
                       inT32 left,      //edge of block
                       ScrollView::Color colour,   //colour to draw in
                       FCOORD rotation  //rotation for line
                      );
void draw_occupation (           //draw projection
inT32 xleft,                     //edge of block
inT32 ybottom,                   //bottom of block
inT32 min_y,                     //coordinate limits
inT32 max_y, inT32 occupation[], //projection counts
inT32 thresholds[]               //for drop out
);
void draw_meanlines(                  //draw a block
                    TO_BLOCK *block,  //block to draw
                    float gradient,   //gradients of lines
                    inT32 left,       //edge of block
                    ScrollView::Color colour,    //colour to draw in
                    FCOORD rotation   //rotation for line
                   );
void plot_word_decisions(              //draw words
                         ScrollView* win,   //window tro draw in
                         inT16 pitch,  //of block
                         TO_ROW *row   //row to draw
                        );
void plot_fp_cells(                        //draw words
                   ScrollView* win,             //window tro draw in
                   ScrollView::Color colour,          //colour of lines
                   BLOBNBOX_IT *blob_it,   //blobs
                   inT16 pitch,            //of block
                   inT16 blob_count,       //no of real blobs
                   STATS *projection,      //vertical
                   inT16 projection_left,  //edges //scale factor
                   inT16 projection_right,
                   float projection_scale);
void plot_fp_cells2(                        //draw words
                    ScrollView* win,             //window tro draw in
                    ScrollView::Color colour,          //colour of lines
                    TO_ROW *row,            //for location
                    FPSEGPT_LIST *seg_list  //segments to plot
                   );
void plot_row_cells(                       //draw words
                    ScrollView* win,            //window tro draw in
                    ScrollView::Color colour,         //colour of lines
                    TO_ROW *row,           //for location
                    float xshift,          //amount of shift
                    ICOORDELT_LIST *cells  //cells to draw
                   );
/////////////////////////////////////////////////////////////////drawtord////////////////////////////////////////

/////////////////////////////////////////////////////////////////gap_map////////////////////////////////////////
class GAPMAP
{
  public:
    GAPMAP(  //constructor
           TO_BLOCK *block);

    ~GAPMAP () {                 //destructor
      if (map != NULL)
        free_mem(map);
    }

    BOOL8 table_gap(               //Is gap a table?
                    inT16 left,    //From here
                    inT16 right);  //To here

  private:
    inT16 total_rows;            //in block
    inT16 min_left;              //Left extreme
    inT16 max_right;             //Right extreme
    inT16 bucket_size;           // half an x ht
    inT16 *map;                  //empty counts
    inT16 map_max;               //map[0..max_map]       defind
    BOOL8 any_tabs;
};

/*-----------------------------*/

extern BOOL_VAR_H (gapmap_debug, FALSE, "Say which blocks have tables");
extern BOOL_VAR_H (gapmap_use_ends, FALSE,
"Use large space at start and end of rows");
extern BOOL_VAR_H (gapmap_no_isolated_quanta, FALSE,
"Ensure gaps not less than 2quanta wide");
extern double_VAR_H (gapmap_big_gaps, 1.75, "xht multiplier");
/////////////////////////////////////////////////////////////////gap_map////////////////////////////////////////

/////////////////////////////////////////////////////////////////tospace////////////////////////////////////////
extern BOOL_VAR_H(tosp_old_to_method, FALSE, "Space stats use prechopping?");
extern BOOL_VAR_H(tosp_only_use_prop_rows, TRUE, "Block stats to use fixed pitch rows?");
extern BOOL_VAR_H(tosp_use_pre_chopping, FALSE, "Space stats use prechopping?");
extern BOOL_VAR_H(tosp_old_to_bug_fix, FALSE, "Fix suspected bug in old code");
extern BOOL_VAR_H(tosp_block_use_cert_spaces, TRUE, "Only stat OBVIOUS spaces");
extern BOOL_VAR_H(tosp_row_use_cert_spaces, TRUE, "Only stat OBVIOUS spaces");
extern BOOL_VAR_H(tosp_narrow_blobs_not_cert, TRUE, "Only stat OBVIOUS spaces");
extern BOOL_VAR_H(tosp_row_use_cert_spaces1, TRUE, "Only stat OBVIOUS spaces");
extern BOOL_VAR_H(tosp_recovery_isolated_row_stats, TRUE, "Use row alone when inadequate cert spaces");
extern BOOL_VAR_H(tosp_force_wordbreak_on_punct, FALSE,
"Force word breaks on punct to break long lines in non-space delimited langs");
extern BOOL_VAR_H(tosp_only_small_gaps_for_kern, FALSE, "Better guess");
extern BOOL_VAR_H(tosp_all_flips_fuzzy, FALSE, "Pass ANY flip to context?");
extern BOOL_VAR_H(tosp_fuzzy_limit_all, TRUE, "Dont restrict kn->sp fuzzy limit to tables");
extern BOOL_VAR_H(tosp_stats_use_xht_gaps, TRUE, "Use within xht gap for wd breaks");
extern BOOL_VAR_H(tosp_use_xht_gaps, TRUE, "Use within xht gap for wd breaks");
extern BOOL_VAR_H(tosp_only_use_xht_gaps, FALSE, "Only use within xht gap for wd breaks");
extern BOOL_VAR_H(tosp_rule_9_test_punct, FALSE, "Dont chng kn to space next to punct");
extern BOOL_VAR_H(tosp_flip_fuzz_kn_to_sp, TRUE, "Default flip");
extern BOOL_VAR_H(tosp_flip_fuzz_sp_to_kn, TRUE, "Default flip");
extern BOOL_VAR_H(tosp_improve_thresh, FALSE, "Enable improvement heuristic");
extern INT_VAR_H(tosp_debug_level, 0, "Debug data");
extern INT_VAR_H(tosp_enough_space_samples_for_median, 3, "or should we use mean");
extern INT_VAR_H(tosp_redo_kern_limit, 10, "No.samples reqd to reestimate for row");
extern INT_VAR_H(tosp_few_samples, 40, "No.gaps reqd with 1 large gap to treat as a table");
extern INT_VAR_H(tosp_short_row, 20, "No.gaps reqd with few cert spaces to use certs");
extern INT_VAR_H(tosp_sanity_method, 1, "How to avoid being silly");
extern double_VAR_H(tosp_threshold_bias1, 0, "how far between kern and space?");
extern double_VAR_H(tosp_threshold_bias2, 0, "how far between kern and space?");
extern double_VAR_H(tosp_narrow_fraction, 0.3, "Fract of xheight for narrow");
extern double_VAR_H(tosp_narrow_aspect_ratio, 0.48, "narrow if w/h less than this");
extern double_VAR_H(tosp_wide_fraction, 0.52, "Fract of xheight for wide");
extern double_VAR_H(tosp_wide_aspect_ratio, 0.0, "wide if w/h less than this");
extern double_VAR_H(tosp_fuzzy_space_factor, 0.6, "Fract of xheight for fuzz sp");
extern double_VAR_H(tosp_fuzzy_space_factor1, 0.5, "Fract of xheight for fuzz sp");
extern double_VAR_H(tosp_fuzzy_space_factor2, 0.72, "Fract of xheight for fuzz sp");
extern double_VAR_H(tosp_gap_factor, 0.83, "gap ratio to flip sp->kern");
extern double_VAR_H(tosp_kern_gap_factor1, 2.0, "gap ratio to flip kern->sp");
extern double_VAR_H(tosp_kern_gap_factor2, 1.3, "gap ratio to flip kern->sp");
extern double_VAR_H(tosp_kern_gap_factor3, 2.5, "gap ratio to flip kern->sp");
extern double_VAR_H(tosp_ignore_big_gaps, -1, "xht multiplier");
extern double_VAR_H(tosp_ignore_very_big_gaps, 3.5, "xht multiplier");
extern double_VAR_H(tosp_rep_space, 1.6, "rep gap multiplier for space");
extern double_VAR_H(tosp_enough_small_gaps, 0.65, "Fract of kerns reqd for isolated row stats");
extern double_VAR_H(tosp_table_kn_sp_ratio, 2.25, "Min difference of kn & sp in table");
extern double_VAR_H(tosp_table_xht_sp_ratio, 0.33, "Expect spaces bigger than this");
extern double_VAR_H(tosp_table_fuzzy_kn_sp_ratio, 3.0, "Fuzzy if less than this");
extern double_VAR_H(tosp_fuzzy_kn_fraction, 0.5, "New fuzzy kn alg");
extern double_VAR_H(tosp_fuzzy_sp_fraction, 0.5, "New fuzzy sp alg");
extern double_VAR_H(tosp_min_sane_kn_sp, 1.5, "Dont trust spaces less than this time kn");
extern double_VAR_H(tosp_init_guess_kn_mult, 2.2, "Thresh guess - mult kn by this");
extern double_VAR_H(tosp_init_guess_xht_mult, 0.28, "Thresh guess - mult xht by this");
extern double_VAR_H(tosp_max_sane_kn_thresh, 5.0, "Multiplier on kn to limit thresh");
extern double_VAR_H(tosp_flip_caution, 0.0, "Dont autoflip kn to sp when large separation");
extern double_VAR_H(tosp_large_kerning, 0.19, "Limit use of xht gap with large kns");
extern double_VAR_H(tosp_dont_fool_with_small_kerns, -1, "Limit use of xht gap with odd small kns");
extern double_VAR_H(tosp_near_lh_edge, 0, "Dont reduce box if the top left is non blank");
extern double_VAR_H(tosp_silly_kn_sp_gap, 0.2, "Dont let sp minus kn get too small");
extern double_VAR_H(tosp_pass_wide_fuzz_sp_to_context, 0.75, "How wide fuzzies need context");

void to_spacing(                       //set spacing
                ICOORD page_tr,        //topright of page
                TO_BLOCK_LIST *blocks  //blocks on page
               );

//DEBUG USE ONLY
void block_spacing_stats(TO_BLOCK *block,
                         GAPMAP *gapmap,
                         BOOL8 &old_text_ord_proportional,
                         inT16 &block_space_gap_width,     //resulting estimate
                         inT16 &block_non_space_gap_width  //resulting estimate
                        );

//estimate for block
void row_spacing_stats(TO_ROW *row,
                       GAPMAP *gapmap,
                       inT16 block_idx,
                       inT16 row_idx,
                       inT16 block_space_gap_width,
                       inT16 block_non_space_gap_width  //estimate for block
                      );

//estimate for block
void old_to_method(TO_ROW *row,
                   STATS *all_gap_stats,
                   STATS *space_gap_stats,
                   STATS *small_gap_stats,
                   inT16 block_space_gap_width,
                   inT16 block_non_space_gap_width  //estimate for block
                  );
BOOL8 isolated_row_stats(TO_ROW *row,
                         GAPMAP *gapmap,
                         STATS *all_gap_stats,
                         BOOL8 suspected_table,
                         inT16 block_idx,
                         inT16 row_idx);

inT16 stats_count_under(STATS *stats, inT16 threshold);
void improve_row_threshold(TO_ROW *row, STATS *all_gap_stats);

ROW *make_prop_words(                 // find lines
                     TO_ROW *row,     // row to make
                     FCOORD rotation  // for drawing
                    );

ROW *make_blob_words(                 // find lines
                     TO_ROW *row,     // row to make
                     FCOORD rotation  // for drawing
                    );

BOOL8 make_a_word_break(               // decide on word break
                        TO_ROW *row,   // row being made
                        TBOX blob_box, // for next_blob // how many blanks?
                        inT16 prev_gap,
                        TBOX prev_blob_box,
                        inT16 real_current_gap,
                        inT16 within_xht_current_gap,
                        TBOX next_blob_box,
                        inT16 next_gap,
                        uinT8 &blanks,
                        BOOL8 &fuzzy_sp,
                        BOOL8 &fuzzy_non);

BOOL8 narrow_blob(TO_ROW *row, TBOX blob_box);
BOOL8 wide_blob(TO_ROW *row, TBOX blob_box);
BOOL8 suspected_punct_blob(TO_ROW *row, TBOX box);

//A COPY FOR PEEKING
void peek_at_next_gap(TO_ROW *row,
                      BLOBNBOX_IT box_it,
                      TBOX &next_blob_box,
                      inT16 &next_gap,
                      inT16 &next_within_xht_gap);

void mark_gap(             //Debug stuff
              TBOX blob,    //blob following gap
              inT16 rule,  // heuristic id
              inT16 prev_gap,
              inT16 prev_blob_width,
              inT16 current_gap,
              inT16 next_blob_width,
              inT16 next_gap);

float find_mean_blob_spacing(WERD *word);

BOOL8 ignore_big_gap(TO_ROW *row,
                     inT32 row_length,
                     GAPMAP *gapmap,
                     inT16 left,
                     inT16 right);

TBOX reduced_box_next(                 //get bounding box
                     TO_ROW *row,     //current row
                     BLOBNBOX_IT *it  //iterator to blobds
                    );

TBOX reduced_box_for_blob(BLOBNBOX *blob, TO_ROW *row, inT16 *left_above_xht);
/////////////////////////////////////////////////////////////////tospace////////////////////////////////////////

/////////////////////////////////////////////////////////////////wordseg////////////////////////////////////////
extern BOOL_VAR_H (textord_fp_chopping, TRUE, "Do fixed pitch chopping");
extern BOOL_VAR_H(textord_force_make_prop_words, FALSE, "Force proportional word segmentation on all rows");
extern BOOL_VAR_H (textord_chopper_test, FALSE, "Chopper is being tested.");

void make_single_word(bool one_blob, TO_ROW_LIST *rows, ROW_LIST* real_rows);

void make_words(                             //make words
                ICOORD page_tr,              //top right
                float gradient,              //page skew
                BLOCK_LIST *blocks,          //block list
                TO_BLOCK_LIST *land_blocks,  //rotated for landscape
                TO_BLOCK_LIST *port_blocks,  //output list
                Tesseract*
               );

void set_row_spaces(                  //find space sizes
                    TO_BLOCK *block,  //block to do
                    FCOORD rotation,  //for drawing
                    BOOL8 testing_on  //correct orientation
                   );

inT32 row_words(                  //compute space size
                TO_BLOCK *block,  //block it came from
                TO_ROW *row,      //row to operate on
                inT32 maxwidth,   //max expected space size
                FCOORD rotation,  //for drawing
                BOOL8 testing_on  //for debug
               );

inT32 row_words2(                  //compute space size
                 TO_BLOCK *block,  //block it came from
                 TO_ROW *row,      //row to operate on
                 inT32 maxwidth,   //max expected space size
                 FCOORD rotation,  //for drawing
                 BOOL8 testing_on  //for debug
                );

void make_real_words(                  //find lines
                     TO_BLOCK *block,  //block to do
                     FCOORD rotation   //for drawing
                    );

ROW *make_rep_words(                 //make a row
                    TO_ROW *row,     //row to convert
                    TO_BLOCK *block  //block it lives in
                   );

WERD *make_real_word(                      //make a WERD
                     BLOBNBOX_IT *box_it,  //iterator
                     inT32 blobcount,      //no of blobs to use
                     BOOL8 bol,            //start of line
                     BOOL8 fuzzy_sp,       //fuzzy space
                     BOOL8 fuzzy_non,      //fuzzy non-space
                     uinT8 blanks          //no of blanks
                    );
/////////////////////////////////////////////////////////////////wordseg////////////////////////////////////////

/////////////////////////////////////////////////////////////////scanedg////////////////////////////////////////
void block_edges(                      //get edges in a block
                        IMAGE *t_image,       //threshold image
                        PDBLK *block,         //block in image
                        ICOORD page_tr        //corner of page
                       );

void make_margins(                         //get a line
                  PDBLK *block,            //block in image
                  BLOCK_LINE_IT *line_it,  //for old style
                  uinT8 *pixels,           //pixels to strip
                  uinT8 margin,            //white-out pixel
                  inT16 left,              //block edges
                  inT16 right,
                  inT16 y                  //line coord
                 );

void whiteout_block(                 //clean it
                    IMAGE *t_image,  //threshold image
                    PDBLK *block     //block in image
                   );

void line_edges (                //scan for edges
inT16 x,                         //coord of line start
inT16 y,                         //coord of line
inT16 xext,                      //width of line
uinT8 uppercolour,               //start of prev line
uinT8 * bwpos,                   //thresholded line
CRACKEDGE ** prevline            //edges in progress
);

CRACKEDGE *h_edge (              //horizontal edge
inT16 x,                         //xposition
inT16 y,                         //y position
inT8 sign,                       //sign of edge
CRACKEDGE * join                 //edge to join to
);

CRACKEDGE *v_edge (              //vertical edge
inT16 x,                         //xposition
inT16 y,                         //y position
inT8 sign,                       //sign of edge
CRACKEDGE * join                 //edge to join to
);

void join_edges(                   //join edge fragments
                CRACKEDGE *edge1,  //edges to join
                CRACKEDGE *edge2   //no specific order
               );

void free_crackedges(                  //really free them
                     CRACKEDGE *start  //start of loop
                    );
/////////////////////////////////////////////////////////////////scanedg////////////////////////////////////////

/////////////////////////////////////////////////////////////////drawedg////////////////////////////////////////
ScrollView* create_edges_window(                //make window
                           ICOORD page_tr  //size of image
                          );
void draw_raw_edge(                   //draw the cracks
                   ScrollView* fd,         //window to draw in
                   CRACKEDGE *start,  //start of loop
                   ScrollView::Color colour      //colour to draw in
                  );
/////////////////////////////////////////////////////////////////drawedg////////////////////////////////////////

/////////////////////////////////////////////////////////////////edgloop////////////////////////////////////////
#define BUCKETSIZE      16
extern double_VAR_H (edges_threshold_greyfraction, 0.07, "Min edge diff for grad vector");
extern BOOL_VAR_H (edges_show_paths, FALSE, "Draw raw outlines");
extern BOOL_VAR_H (edges_show_needles, FALSE, "Draw edge needles");
extern INT_VAR_H (edges_children_per_grandchild, 10, "Importance ratio for chucking outlines");
extern INT_VAR_H (edges_children_count_limit, 45, "Max holes allowed in blob");
extern INT_VAR_H (edges_maxedgelength, 16000, "Max steps in any outline");
extern double_VAR_H (edges_childarea, 0.5, "Max area fraction of child outline");
extern double_VAR_H (edges_boxarea, 0.8, "Min area fraction of grandchild for box");

void get_outlines(                      //edge detect
#ifndef GRAPHICS_DISABLED
                         ScrollView* window,        //window for output
#endif
                         IMAGE *image,         //image to scan
                         IMAGE *t_image,       //thresholded image
                         ICOORD page_tr,       //corner of page
                         PDBLK *block,         //block to scan
                         C_OUTLINE_IT *out_it  //output iterator
                        );

//clean and approximate
void complete_edge(CRACKEDGE *start ); //start of loop

//certify outline                  //start of loop
ScrollView::Color check_path_legal(CRACKEDGE *start);

//get bounding box      //edge loop        //bounding box
inT16 loop_bounding_box(CRACKEDGE *&start, ICOORD &botleft, ICOORD &topright);
/////////////////////////////////////////////////////////////////edgloop////////////////////////////////////////

/////////////////////////////////////////////////////////////////edgblob////////////////////////////////////////
#define BUCKETSIZE      16
class OL_BUCKETS
{
  public:
    //constructor  //corners
    OL_BUCKETS(ICOORD bleft,   ICOORD tright);

    ~OL_BUCKETS ()
    {
      //cleanup
      delete[]buckets;
    }

    C_OUTLINE_LIST *operator () (//array access
      inT16 x,                   //image coords
      inT16 y);
                                 //first non-empty bucket
    C_OUTLINE_LIST *start_scan()
    {
      for (index = 0; buckets[index].empty () && index < bxdim * bydim - 1; index++);
      {
            return &buckets[index];
      }
    }
                                 //next non-empty bucket
    C_OUTLINE_LIST *scan_next()
    {
      for (; buckets[index].empty () && index < bxdim * bydim - 1; index++);
      {
      return &buckets[index];
      }

    }
    inT32 count_children(                     //recursive sum
                         C_OUTLINE *outline,  //parent outline
                         inT32 max_count);    // max output

    inT32 outline_complexity(                 // new version of count_children
                         C_OUTLINE *outline,  // parent outline
                         inT32 max_count,     // max output
                         inT16 depth);        // level of recursion

    void extract_children(                     //single level get
                          C_OUTLINE *outline,  //parent outline
                          C_OUTLINE_IT *it);   //destination iterator

  private:
    C_OUTLINE_LIST * buckets;    //array of buckets
    inT16 bxdim;                 //size of array
    inT16 bydim;
    ICOORD bl;                   //corners
    ICOORD tr;
    inT32 index;                 //for extraction scan
};

void extract_edges(                 //find blobs
#ifndef GRAPHICS_DISABLED
                   ScrollView* window,   //window for output
#endif
                   IMAGE *image,    //image to scan
                   IMAGE *t_image,  //thresholded image
                   ICOORD page_tr,  //corner of page
                   BLOCK *block     //block to scan
                  );

void outlines_to_blobs(               //find blobs
                       BLOCK *block,  //block to scan
                       ICOORD bleft,  //block box //outlines in block
                       ICOORD tright,
                       C_OUTLINE_LIST *outlines);

void fill_buckets(                           //find blobs
                  C_OUTLINE_LIST *outlines,  //outlines in block
                  OL_BUCKETS *buckets        //output buckets
                 );

void empty_buckets(                     //find blobs
                   BLOCK *block,        //block to scan
                   OL_BUCKETS *buckets  //output buckets
                  );

BOOL8 capture_children(                       //find children
                       OL_BUCKETS *buckets,   //bucket sort clanss
                       C_BLOB_IT *reject_it,  //dead grandchildren
                       C_OUTLINE_IT *blob_it  //output outlines
                      );
/////////////////////////////////////////////////////////////////edgblob////////////////////////////////////////

/////////////////////////////////////////////////////////////////tordmain////////////////////////////////////////
class TO_BLOCK_LIST;

extern BOOL_VAR_H (textord_show_blobs, FALSE, "Display unsorted blobs");
extern BOOL_VAR_H (textord_new_initial_xheight, TRUE,
"Use test xheight mechanism");
extern BOOL_VAR_H (textord_exit_after, FALSE,
"Exit after completing textord");
extern INT_VAR_H (textord_max_noise_size, 7, "Pixel size of noise");
extern double_VAR_H (textord_blob_size_bigile, 95,
"Percentile for large blobs");
extern double_VAR_H (textord_noise_area_ratio, 0.7,
"Fraction of bounding box for noise");
extern double_VAR_H (textord_blob_size_smallile, 20,
"Percentile for small blobs");
extern double_VAR_H (textord_initialx_ile, 0.75,
"Ile of sizes for xheight guess");
extern double_VAR_H (textord_initialasc_ile, 0.90,
"Ile of sizes for xheight guess");
extern INT_VAR_H (textord_noise_sizefraction, 10,
"Fraction of size for maxima");
extern double_VAR_H (textord_noise_sizelimit, 0.5,
"Fraction of x for big t count");
extern INT_VAR_H (textord_noise_translimit, 16,
"Transitions for normal blob");
extern double_VAR_H (textord_noise_normratio, 2.0,
"Dot to norm ratio for deletion");
extern BOOL_VAR_H (textord_noise_rejwords, TRUE, "Reject noise-like words");
extern BOOL_VAR_H (textord_noise_rejrows, TRUE, "Reject noise-like rows");
extern double_VAR_H (textord_noise_syfract, 0.2,
"xh fract error for norm blobs");
extern double_VAR_H (textord_noise_sxfract, 0.4,
"xh fract width error for norm blobs");
extern INT_VAR_H (textord_noise_sncount, 1, "super norm blobs to save row");
extern double_VAR_H (textord_noise_rowratio, 6.0,
"Dot to norm ratio for deletion");
extern BOOL_VAR_H (textord_noise_debug, FALSE, "Debug row garbage detector");
extern double_VAR_H (textord_blshift_maxshift, 0.00, "Max baseline shift");
extern double_VAR_H (textord_blshift_xfraction, 9.99,
"Min size of baseline shift");
                                 //xiaofan
extern STRING_EVAR_H (tessedit_image_ext, ".tif", "Externsion for image file");
extern clock_t previous_cpu;
void make_blocks_from_blobs(                       //convert & textord
                            TBLOB *tessblobs,      //tess style input
                            const char *filename,  //blob file
                            ICOORD page_tr,        //top right
                            BOOL8 do_shift,        //shift tess coords
                            BLOCK_LIST *blocks     //block list
                           );
void find_components(  // find components in blocks
                       BLOCK_LIST *blocks,
                       TO_BLOCK_LIST *land_blocks,
                       TO_BLOCK_LIST *port_blocks,
                       TBOX *page_box);
void SetBlobStrokeWidth(bool debug, BLOBNBOX* blob);
void assign_blobs_to_blocks2(                             //split into groups
                             BLOCK_LIST *blocks,          //blocks to process
                             TO_BLOCK_LIST *land_blocks,  //rotated for landscape
                             TO_BLOCK_LIST *port_blocks   //output list
                            );
void filter_blobs(                        //split into groups
                  ICOORD page_tr,         //top right
                  TO_BLOCK_LIST *blocks,  //output list
                  BOOL8 testing_on        //for plotting
                 );
float filter_noise_blobs(                            //separate noise
                         BLOBNBOX_LIST *src_list,    //origonal list
                         BLOBNBOX_LIST *noise_list,  //noise list
                         BLOBNBOX_LIST *small_list,  //small blobs
                         BLOBNBOX_LIST *large_list   //large blobs
                        );
float filter_noise_blobs2(                            //separate noise
                          BLOBNBOX_LIST *src_list,    //origonal list
                          BLOBNBOX_LIST *noise_list,  //noise list
                          BLOBNBOX_LIST *small_list,  //small blobs
                          BLOBNBOX_LIST *large_list   //large blobs
                         );
void textord_page(                             //make rows & words
                  ICOORD page_tr,              //top right
                  BLOCK_LIST *blocks,          //block list
                  TO_BLOCK_LIST *land_blocks,  //rotated for landscape
                  TO_BLOCK_LIST *port_blocks,  //output list
                  Tesseract*
                 );
void cleanup_blocks(                    //remove empties
                    BLOCK_LIST *blocks  //list
                   );
BOOL8 clean_noise_from_row(          //remove empties
                           ROW *row  //row to clean
                          );
void clean_noise_from_words(          //remove empties
                            ROW *row  //row to clean
                           );
// Remove outlines that are a tiny fraction in either width or height
// of the word height.
void clean_small_noise_from_words(ROW *row);
void tweak_row_baseline(          //remove empties
                        ROW *row  //row to clean
                       );
inT32 blob_y_order(              //sort function
                   void *item1,  //items to compare
                   void *item2);
/////////////////////////////////////////////////////////////////tordmain////////////////////////////////////////

/////////////////////////////////////////////////////////////////genblob////////////////////////////////////////
int blob_comparator(                     //sort blobs
                    const void *blob1p,  //ptr to ptr to blob1
                    const void *blob2p   //ptr to ptr to blob2
                   );
int c_blob_comparator(                     //sort blobs
                      const void *blob1p,  //ptr to ptr to blob1
                      const void *blob2p   //ptr to ptr to blob2
                     );
TBOX gblob_bounding_box(                 //Get bounding box
                       PBLOB *blob,     //generic blob
                       BOOL8 polygonal  //is blob polygonal?
                      );
void gblob_sort_list(                        //Sort a gblob list
                     PBLOB_LIST *blob_list,  //generic blob list
                     BOOL8 polygonal         //is list polygonal?
                    );
OUTLINE_LIST *gblob_out_list(                 //Get outline list
                             PBLOB *blob,     //generic blob
                             BOOL8 polygonal  //is blob polygonal?
                            );
TBOX goutline_bounding_box(                   //Get bounding box
                          OUTLINE *outline,  //generic outline
                          BOOL8 polygonal    //is outline polygonal?
                         );
/////////////////////////////////////////////////////////////////genblob////////////////////////////////////////

/////////////////////////////////////////////////////////////////pgedit////////////////////////////////////////
// A small event handler class to process incoming events to
// this window.
class PGEventHandler : public SVEventHandler
{
  public:
   PGEventHandler(Tesseract* tess) : tess_(tess)
   {
   }
   void Notify(const SVEvent* sve);
  private:
    Tesseract* tess_;
};

extern BLOCK_LIST *current_block_list;
extern BOOL8 *current_image_changed;
extern STRING_VAR_H (editor_image_win_name, "EditorImage",
"Editor image window name");
extern INT_VAR_H (editor_image_xpos, 590, "Editor image X Pos");
extern INT_VAR_H (editor_image_ypos, 10, "Editor image Y Pos");
extern INT_VAR_H (editor_image_height, 680, "Editor image height");
extern INT_VAR_H (editor_image_width, 655, "Editor image width");
extern INT_VAR_H (editor_image_word_bb_color, BLUE,
"Word bounding box colour");
extern INT_VAR_H (editor_image_blob_bb_color, YELLOW,
"Blob bounding box colour");
extern INT_VAR_H (editor_image_text_color, WHITE, "Correct text colour");
extern STRING_VAR_H (editor_dbwin_name, "EditorDBWin",
"Editor debug window name");
extern INT_VAR_H (editor_dbwin_xpos, 50, "Editor debug window X Pos");
extern INT_VAR_H (editor_dbwin_ypos, 500, "Editor debug window Y Pos");
extern INT_VAR_H (editor_dbwin_height, 24, "Editor debug window height");
extern INT_VAR_H (editor_dbwin_width, 80, "Editor debug window width");
extern STRING_VAR_H (editor_word_name, "BlnWords",
"BL normalised word window");
extern INT_VAR_H (editor_word_xpos, 60, "Word window X Pos");
extern INT_VAR_H (editor_word_ypos, 510, "Word window Y Pos");
extern INT_VAR_H (editor_word_height, 240, "Word window height");
extern INT_VAR_H (editor_word_width, 655, "Word window width");
extern double_VAR_H (editor_smd_scale_factor, 1.0, "Scaling for smd image");

void add_word(                             //to block list
              WERD *word,                  //word to be added
              ROW *src_row,                //source row
              BLOCK *src_block,            //source block
              BLOCK_LIST *dest_block_list  //add to this
             );

ScrollView* bln_word_window_handle();  //return handle
void build_image_window(TBOX page_bounding_box);
void display_bln_lines(ScrollView window, ScrollView::Color colour, float scale_factor, float y_offset, float minx, float maxx);
                                 //function to call
void do_re_display (BOOL8 word_painter(BLOCK *, ROW *, WERD *));
const TBOX do_tidy_cmd();  //tidy
void do_view_cmd();

//serialise        //file name
void do_write_file(char *name);

//message display
void pgeditor_msg(const char *msg);

//display coords
void pgeditor_show_point(SVEvent *event);
void pgeditor_write_file(                    //serialise
                         char *name,         //file name
                         BLOCK_LIST *blocks  //block list to write
                        );
                                 //put bln word in       box
float re_scale_and_move_bln_word(WERD *norm_word,  //BL normalised word
                                 const TBOX &box    //destination box
                                );
void re_segment_word(                         //break/join words
                     BLOCK_LIST *block_list,  //blocks to check
                     TBOX &selection_box);
void block_space_stat(                         //show space stats
                      BLOCK_LIST *block_list,  //blocks to check
                      TBOX &selection_box);
void row_space_stat(                         //show space stats
                    BLOCK_LIST *block_list,  //blocks to check
                    TBOX &selection_box);
void show_point(                         //display posn of bloba word
                BLOCK_LIST *block_list,  //blocks to check
                float x,
                float y);
                                 //display a word
BOOL8 word_blank_and_set_display(BLOCK *block,  //block holding word
                                 ROW *row,      //row holding word
                                 WERD *word     //word to be processed
                                );
BOOL8 word_bln_display(            //bln & display
                       BLOCK *,    //block holding word
                       ROW *row,   //row holding word
                       WERD *word  //word to be processed
                      );
BOOL8 word_change_text(               //change correct text
                       BLOCK *block,  //block holding word
                       ROW *row,      //row holding word
                       WERD *word     //word to be processed
                      );
BOOL8 word_copy(               //copy a word
                BLOCK *block,  //block holding word
                ROW *row,      //row holding word
                WERD *word     //word to be processed
               );
BOOL8 word_delete(                     //delete a word
                  BLOCK *block,        //block holding word
                  ROW *row,            //row holding word
                  WERD *word,          //word to be processed
                  BLOCK_IT &block_it,  //block list iterator
                  ROW_IT &row_it,      //row list iterator
                  WERD_IT &word_it     //word list iterator
                 );
BOOL8 word_display(            // display a word
                   BLOCK *,    //block holding word
                   ROW *row,   //row holding word
                   WERD *word  //word to be processed
                  );
BOOL8 word_dumper(               //dump word
                  BLOCK *block,  //block holding word
                  ROW *row,      //row holding word
                  WERD *word     //word to be processed
                 );
BOOL8 word_set_display(               //display a word
                       BLOCK *block,  //block holding word
                       ROW *row,      //row holding word
                       WERD *word     //word to be processed
                      );
BOOL8 word_toggle_seg(            //toggle seg flag
                      BLOCK *,    //block holding word
                      ROW *,      //row holding word
                      WERD *word  //word to be processed
                     );
void do_check_mem(  //do it
                  inT32 level);
/////////////////////////////////////////////////////////////////pgedit////////////////////////////////////////

/////////////////////////////////////////////////////////////////rejctmap////////////////////////////////////////
extern BOOL_VAR_H (rejword_only_set_if_accepted, TRUE, "Mimic old reject_word");
extern BOOL_VAR_H (rejmap_allow_more_good_qual, FALSE, "Use initial good qual setting");
extern BOOL_VAR_H (rej_use_1Il_rej, TRUE, "1Il rejection enabled");

enum REJ_FLAGS
{
  /* Reject modes which are NEVER overridden */
  R_TESS_FAILURE,                // PERM Tess didnt classify
  R_SMALL_XHT,                   // PERM Xht too small
  R_EDGE_CHAR,                   // PERM Too close to edge of image
  R_1IL_CONFLICT,                // PERM 1Il confusion
  R_POSTNN_1IL,                  // PERM 1Il unrejected by NN
  R_REJ_CBLOB,                   // PERM Odd blob
  R_MM_REJECT,                   // PERM Matrix match rejection (m's)
  R_BAD_REPETITION,              // TEMP Repeated char which doesn't match trend

  /* Initial reject modes (pre NN_ACCEPT) */
  R_POOR_MATCH,                  // TEMP Ray's original heuristic (Not used)
  R_NOT_TESS_ACCEPTED,           // TEMP Tess didnt accept WERD
  R_CONTAINS_BLANKS,             // TEMP Tess failed on other chs in WERD
  R_BAD_PERMUTER,                // POTENTIAL Bad permuter for WERD

  /* Reject modes generated after NN_ACCEPT but before MM_ACCEPT */
  R_HYPHEN,                      // TEMP Post NN dodgy hyphen or full stop
  R_DUBIOUS,                     // TEMP Post NN dodgy chars
  R_NO_ALPHANUMS,                // TEMP No alphanumerics in word after NN
  R_MOSTLY_REJ,                  // TEMP Most of word rejected so rej the rest
  R_XHT_FIXUP,                   // TEMP Xht tests unsure

  /* Reject modes generated after MM_ACCEPT but before QUALITY_ACCEPT */
  R_BAD_QUALITY,                 // TEMP Quality metrics bad for WERD

  /* Reject modes generated after QUALITY_ACCEPT but before MINIMAL_REJ accep*/
  R_DOC_REJ,                     // TEMP Document rejection
  R_BLOCK_REJ,                   // TEMP Block rejection
  R_ROW_REJ,                     // TEMP Row rejection
  R_UNLV_REJ,                    // TEMP ~ turned to - or ^ turned to space

  /* Accept modes which occur inbetween the above rejection groups */
  R_NN_ACCEPT,                   //NN acceptance
  R_HYPHEN_ACCEPT,               //Hyphen acceptance
  R_MM_ACCEPT,                   //Matrix match acceptance
  R_QUALITY_ACCEPT,              //Accept word in good quality doc
  R_MINIMAL_REJ_ACCEPT           //Accept EVERYTHING except tess failures
};

/* REJECT MAP VALUES */

#define           MAP_ACCEPT '1'
#define           MAP_REJECT_PERM '0'
#define           MAP_REJECT_TEMP '2'
#define           MAP_REJECT_POTENTIAL '3'

class REJ
{
  BITS16 flags1;
  BITS16 flags2;

  void set_flag(REJ_FLAGS rej_flag) {
    if (rej_flag < 16)
      flags1.turn_on_bit (rej_flag);
    else
      flags2.turn_on_bit (rej_flag - 16);
  }

  BOOL8 rej_before_nn_accept();
  BOOL8 rej_between_nn_and_mm();
  BOOL8 rej_between_mm_and_quality_accept();
  BOOL8 rej_between_quality_and_minimal_rej_accept();
  BOOL8 rej_before_mm_accept();
  BOOL8 rej_before_quality_accept();

  public:
    REJ() {  //constructor
    }

    REJ(  //classwise copy
        const REJ &source) {
      flags1 = source.flags1;
      flags2 = source.flags2;
    }

    REJ & operator= (            //assign REJ
    const REJ & source) {        //from this
      flags1 = source.flags1;
      flags2 = source.flags2;
      return *this;
    }

    BOOL8 flag(REJ_FLAGS rej_flag) {
      if (rej_flag < 16)
        return flags1.bit (rej_flag);
      else
        return flags2.bit (rej_flag - 16);
    }

    char display_char() {
      if (perm_rejected ())
        return MAP_REJECT_PERM;
      else if (accept_if_good_quality ())
        return MAP_REJECT_POTENTIAL;
      else if (rejected ())
        return MAP_REJECT_TEMP;
      else
        return MAP_ACCEPT;
    }

    BOOL8 perm_rejected();  //Is char perm reject?

    BOOL8 rejected();  //Is char rejected?

    BOOL8 accepted() {  //Is char accepted?
      return !rejected ();
    }

                                 //potential rej?
    BOOL8 accept_if_good_quality();

    BOOL8 recoverable() {
      return (rejected () && !perm_rejected ());
    }

    void setrej_tess_failure();  //Tess generated blank
    void setrej_small_xht();  //Small xht char/wd
    void setrej_edge_char();  //Close to image edge
    void setrej_1Il_conflict();  //Initial reject map
    void setrej_postNN_1Il();  //1Il after NN
    void setrej_rej_cblob();  //Insert duff blob
    void setrej_mm_reject();  //Matrix matcher
                                 //Odd repeated char
    void setrej_bad_repetition();
    void setrej_poor_match();  //Failed Rays heuristic
                                 //TEMP reject_word
    void setrej_not_tess_accepted();
                                 //TEMP reject_word
    void setrej_contains_blanks();
    void setrej_bad_permuter();  //POTENTIAL reject_word
    void setrej_hyphen();  //PostNN dubious hyph or .
    void setrej_dubious();  //PostNN dubious limit
    void setrej_no_alphanums();  //TEMP reject_word
    void setrej_mostly_rej();  //TEMP reject_word
    void setrej_xht_fixup();  //xht fixup
    void setrej_bad_quality();  //TEMP reject_word
    void setrej_doc_rej();  //TEMP reject_word
    void setrej_block_rej();  //TEMP reject_word
    void setrej_row_rej();  //TEMP reject_word
    void setrej_unlv_rej();  //TEMP reject_word
    void setrej_nn_accept();  //NN Flipped a char
    void setrej_hyphen_accept();  //Good aspect ratio
    void setrej_mm_accept();  //Matrix matcher
                                 //Quality flip a char
    void setrej_quality_accept();
                                 //Accept all except blank
    void setrej_minimal_rej_accept();

    void full_print(FILE *fp);
};

class REJMAP
{
  REJ *ptr;                      //ptr to the chars
  inT16 len;                     //Number of chars

  public:
    REJMAP() {  //constructor
      ptr = NULL;
      len = 0;
    }

    REJMAP(  //classwise copy
           const REJMAP &rejmap);

    REJMAP & operator= (         //assign REJMAP
      const REJMAP & source);    //from this

    ~REJMAP () {                 //destructor
      if (ptr != NULL)
        free_struct (ptr, len * sizeof (REJ), "REJ");
    }

    void initialise(  //Redefine map
                    inT16 length);

    REJ & operator[](            //access function
      inT16 index) const         //map index
    {
      ASSERT_HOST (index < len);
      return ptr[index];         //no bounds checks
    }

    inT32 length() const {  //map length
      return len;
    }

    inT16 accept_count();  //How many accepted?

    inT16 reject_count() {  //How many rejects?
      return len - accept_count ();
    }

    void remove_pos(             //Cut out an element
                    inT16 pos);  //element to remove

    void print(FILE *fp);

    void full_print(FILE *fp);

    BOOL8 recoverable_rejects();  //Any non perm rejs?

    BOOL8 quality_recoverable_rejects();
    //Any potential rejs?

    void rej_word_small_xht();  //Reject whole word
                                 //Reject whole word
    void rej_word_tess_failure();
    void rej_word_not_tess_accepted();
    //Reject whole word
                                 //Reject whole word
    void rej_word_contains_blanks();
                                 //Reject whole word
    void rej_word_bad_permuter();
    void rej_word_xht_fixup();  //Reject whole word
                                 //Reject whole word
    void rej_word_no_alphanums();
    void rej_word_mostly_rej();  //Reject whole word
    void rej_word_bad_quality();  //Reject whole word
    void rej_word_doc_rej();  //Reject whole word
    void rej_word_block_rej();  //Reject whole word
    void rej_word_row_rej();  //Reject whole word
};
/////////////////////////////////////////////////////////////////rejctmap////////////////////////////////////////

/////////////////////////////////////////////////////////////////pageres////////////////////////////////////////
class BLOCK_RES;
ELISTIZEH (BLOCK_RES) CLISTIZEH (BLOCK_RES)
class ROW_RES;

ELISTIZEH (ROW_RES)
class WERD_RES;

ELISTIZEH (WERD_RES)
/*************************************************************************
 * PAGE_RES - Page results
 *************************************************************************/
class PAGE_RES                   //page result
{
    public:
    inT32 char_count;
    inT32 rej_count;
    BLOCK_RES_LIST block_res_list;
    BOOL8 rejected;

    PAGE_RES() {}                            //empty constructor

    //simple constructor
    PAGE_RES(BLOCK_LIST *block_list);  //real blocks

    //destructor
    ~PAGE_RES () {}
};

/*************************************************************************
 * BLOCK_RES - Block results
 *************************************************************************/

class BLOCK_RES:public ELIST_LINK
        //page block result
{
public:
    BLOCK * block;               //real block
    inT32 char_count;            //chars in block
    inT32 rej_count;             //rejected chars
    inT16 font_class;            //
    inT16 row_count;
    float x_height;
    BOOL8 font_assigned;         // block already

    //      processed
    BOOL8 bold;                  // all bold
    BOOL8 italic;                // all italic

    ROW_RES_LIST row_res_list;

    BLOCK_RES() {}                            //empty constructor

    //simple constructor
    BLOCK_RES(BLOCK *the_block);  //real block

    //destructor
    ~BLOCK_RES () {}
};

/*************************************************************************
 * ROW_RES - Row results
 *************************************************************************/

class ROW_RES:public ELIST_LINK  //row result
{
public:
    ROW * row;                   //real row
    inT32 char_count;            //chars in block
    inT32 rej_count;             //rejected chars
    inT32 whole_word_rej_count;  //rejs in total rej wds
    WERD_RES_LIST word_res_list;
    float font_class_score;
    inT16 font_class;            //
    inT32 italic;
    inT32 bold;
    inT8 font1;                  //primary font
    inT8 font1_count;            //no of voters
    inT8 font2;                  //secondary font
    inT8 font2_count;            //no of voters

    ROW_RES() {}                            //empty constructor

    //simple constructor
    ROW_RES(ROW *the_row);  //real row

    //destructor
    ~ROW_RES () {}
};

/*************************************************************************
 * WERD_RES - Word results
 *************************************************************************/
enum CRUNCH_MODE
{
    CR_NONE,
    CR_KEEP_SPACE,
    CR_LOOSE_SPACE,
    CR_DELETE
};

class WERD_RES:public ELIST_LINK //word result
{
public:
    WERD * word;                 //non-bln real word
    WERD *outword;               //bln best choice
    //segmentation
    DENORM denorm;               //for use on outword
    WERD_CHOICE *best_choice;    //tess output
    WERD_CHOICE *raw_choice;     //top choice permuter
    WERD_CHOICE *ep_choice;      //ep text
    REJMAP reject_map;           //best_choice rejects
    BOOL8 tess_failed;

    /*
      If tess_failed is TRUE, one of the following tests failed when Tess
      returned:
      - The outword blob list was not the same length as the best_choice string;
      - The best_choice string contained ALL blanks;
      - The best_choice string was zero length
    */
    BOOL8 tess_accepted;         //Tess thinks its ok?
    BOOL8 tess_would_adapt;      //Tess would adapt?
    BOOL8 done;                  //ready for output?
    inT8 italic;
    inT8 bold;
    inT8 font1;                  //primary font
    inT8 font1_count;            //no of voters
    inT8 font2;                  //secondary font
    inT8 font2_count;            //no of voters
    CRUNCH_MODE unlv_crunch_mode;
    float x_height;              //Post match estimate
    float caps_height;           //Post match estimate
    BOOL8 guessed_x_ht;
    BOOL8 guessed_caps_ht;
    /*
      To deal with fuzzy spaces we need to be able to combine "words" to form
      combinations when we suspect that the gap is a non-space. The (new) text
      ord code generates separate words for EVERY fuzzy gap - flags in the word
      indicate whether the gap is below the threshold (fuzzy kern) and is thus
      NOT a real word break by default, or above the threshold (fuzzy space) and
      this is a real word break by default.

      The WERD_RES list contains all these words PLUS "combination" words built
      out of (copies of) the words split by fuzzy kerns. The separate parts have
      their "part_of_combo" flag set true and should be IGNORED on a default
      reading of the list.

      Combination words are FOLLOWED by the sequence of part_of_combo words
      which they combine.
    */
    BOOL8 combination;           //of two fuzzy gap wds
    BOOL8 part_of_combo;         //part of a combo
    BOOL8 reject_spaces;         //Reject spacing?

    WERD_RES() {}                            //empty constructor

    //simple constructor
    WERD_RES(WERD *the_word)
    {
        //real word
        word = the_word;
        outword = NULL;
        best_choice = NULL;
        raw_choice = NULL;
        ep_choice = NULL;
        tess_failed = FALSE;
        tess_accepted = FALSE;
        tess_would_adapt = FALSE;
        done = FALSE;
        unlv_crunch_mode = CR_NONE;
        italic = FALSE;
        bold = FALSE;
        font1 = -1;
        font1_count = 0;
        font2 = -1;
        font2_count = 0;
        x_height = 0.0;
        caps_height = 0.0;
        guessed_x_ht = TRUE;
        guessed_caps_ht = TRUE;
        combination = FALSE;
        part_of_combo = FALSE;
        reject_spaces = FALSE;
    }

    WERD_RES(const WERD_RES &source) : ELIST_LINK(source)
    {
        *this = source;            //see operator=
    }

    ~WERD_RES ();                //destructor

    WERD_RES& operator=(const WERD_RES& source);  //from this

    static WERD_RES* deep_copy(const WERD_RES* src)
    {
        return new WERD_RES(*src);
    }

    //copy blobs onto word
    void copy_on(WERD_RES *word_res)
    {
        //from this word
        word->set_flag(W_EOL, word_res->word->flag (W_EOL));
        word->copy_on(word_res->word);
    }
};

/*************************************************************************
 * PAGE_RES_IT - Page results iterator
 *************************************************************************/

class PAGE_RES_IT
{
public:
    PAGE_RES * page_res;         //page being iterated

    PAGE_RES_IT() {}                            //empty contructor

    //empty contructor
    PAGE_RES_IT(PAGE_RES *the_page_res)
    {
        //page result
        page_res = the_page_res;
        restart_page();  //ready to scan
    }

    WERD_RES *restart_page();  //get ready

    //get next word
    WERD_RES *internal_forward(BOOL8 new_block);

    WERD_RES *forward()
    {
        //get next word
        return internal_forward (FALSE);
    }

    WERD_RES *forward_block();  //get first word in

    //next non-empty block
    WERD_RES *prev_word()
    {
        //previous word
        return prev_word_res;
    }

    ROW_RES *prev_row()
    {
        //row of prev word
        return prev_row_res;
    }

    BLOCK_RES *prev_block()
    {
        //block of prev word
        return prev_block_res;
    }

    WERD_RES *word()
    {
        //current word
        return word_res;
    }

    ROW_RES *row()
    {
        //row of current word
        return row_res;
    }

    BLOCK_RES *block()
    {
        //block of cur. word
        return block_res;
    }

    WERD_RES *next_word()
    {
        //next word
        return next_word_res;
    }

    ROW_RES *next_row()
    {
        //row of next word
        return next_row_res;
    }

    BLOCK_RES *next_block()
    {
        //block of next word
        return next_block_res;
    }

    void rej_stat_word();  //for page/block/row

private:
    WERD_RES * prev_word_res;    //previous word
    ROW_RES *prev_row_res;       //row of prev word
    BLOCK_RES *prev_block_res;   //block of prev word

    WERD_RES *word_res;          //current word
    ROW_RES *row_res;            //row of current word
    BLOCK_RES *block_res;        //block of cur. word

    WERD_RES *next_word_res;     //next word
    ROW_RES *next_row_res;       //row of next word
    BLOCK_RES *next_block_res;   //block of next word

    BLOCK_RES_IT block_res_it;   //iterators
    ROW_RES_IT row_res_it;
    WERD_RES_IT word_res_it;
};
/////////////////////////////////////////////////////////////////pageres////////////////////////////////////////

/////////////////////////////////////////////////////////////////fixspace////////////////////////////////////////
extern BOOL_VAR_H (fixsp_check_for_fp_noise_space, TRUE,
"Try turning noise to space in fixed pitch");
extern BOOL_VAR_H (fixsp_fp_eval, TRUE, "Use alternate evaluation for fp");
extern BOOL_VAR_H (fixsp_noise_score_fixing, TRUE, "More sophisticated?");
extern INT_VAR_H (fixsp_non_noise_limit, 1,
"How many non-noise blbs either side?");
extern double_VAR_H (fixsp_small_outlines_size, 0.28,
"Small if lt xht x this");
extern BOOL_VAR_H (fixsp_ignore_punct, TRUE, "In uniform spacing calc");
extern BOOL_VAR_H (fixsp_numeric_fix, TRUE, "Try to deal with numeric punct");
extern BOOL_VAR_H (fixsp_prefer_joined_1s, TRUE, "Arbitrary boost");
extern BOOL_VAR_H (tessedit_test_uniform_wd_spacing, FALSE,
"Limit context word spacing");
extern BOOL_VAR_H (tessedit_prefer_joined_punct, FALSE,
"Reward punctation joins");
extern INT_VAR_H (fixsp_done_mode, 1, "What constitutes done for spacing");
extern INT_VAR_H (debug_fix_space_level, 0, "Contextual fixspace debug");
extern STRING_VAR_H (numeric_punctuation, ".,",
"Punct. chs expected WITHIN numbers");
void initialise_search(WERD_RES_LIST &src_list, WERD_RES_LIST &new_list);
void transform_to_next_perm(WERD_RES_LIST &words);
void dump_words(WERD_RES_LIST &perm, inT16 score, inT16 mode, BOOL8 improved);
BOOL8 uniformly_spaced(  //sensible word
                       WERD_RES *word);
BOOL8 fixspace_thinks_word_done(WERD_RES *word);
void break_noisiest_blob_word(WERD_RES_LIST &words);
inT16 worst_noise_blob(WERD_RES *word_res, float *worst_noise_score);
float blob_noise_score(PBLOB *blob);
void fixspace_dbg(WERD_RES *word);
/////////////////////////////////////////////////////////////////fixspace////////////////////////////////////////

/////////////////////////////////////////////////////////////////tessvars////////////////////////////////////////
extern INT_VAR_H (tessedit_adapt_kludge, 0, "Use acceptable result or dangambigs");
extern BOOL_VAR_H (interactive_mode, FALSE, "Run interactively?");
extern BOOL_VAR_H (edit_variables, FALSE, "Variables Editor Window?");
//xiaofan extern STRING_VAR_H(file_type,".bl","Filename extension");
extern STRING_VAR_H (file_type, ".tif", "Filename extension");
extern INT_VAR_H (tessedit_truncate_wordchoice_log, 10, "Max words to keep in list");
extern INT_VAR_H (testedit_match_debug, 0, "Integer match debug ctrl");
extern INT_VAR_H (tessedit_truncate_chopper, 1, "Shorten chopper seam search");
extern INT_VAR_H (tessedit_fix_sideways_chops, 1, "Fix sideways chop problem");
extern INT_VAR_H (tessedit_dangambigs_chop, FALSE, "Use UnicharAmbigs to direct chop");
extern INT_VAR_H (tessedit_dangambigs_assoc, FALSE, "Use UnicharAmbigs to direct assoc");

extern IMAGE page_image;         //image of page
extern FILE *debug_fp;           //write debug stuff here
/////////////////////////////////////////////////////////////////tessvars////////////////////////////////////////

//////////////////////////////////////////////////////////////////imgscale////////////////////////////////////////
void dyn_prog(  //The clever bit
              int n,
              int *x,
              int *y,
              int ymax,
              int *oldx,
              int *oldy,
              int oldn,
              float factor);
/////////////////////////////////////////////////////////////////imgscale////////////////////////////////////////

/////////////////////////////////////////////////////////////////scaleimg////////////////////////////////////////
void scale_image(                     //scale an image
                 IMAGE &image,        //source image
                 IMAGE &target_image  //target image
                );
void scale_image_cop_out(                      //scale an image
                         IMAGE &image,         //source image
                         IMAGE &target_image,  //target image
                         float factor,         //scale factor
                         int *hires,
                         int *lores,
                         int *oldhires,
                         int *oldlores);
/////////////////////////////////////////////////////////////////scaleimg////////////////////////////////////////

/////////////////////////////////////////////////////////////////callnet////////////////////////////////////////
/** Initialise net */
void init_net();

/** Apply image to net */
void callnet(
             float *input_vector,
             char *top,
             float *top_score,
             char *next,
             float *next_score);
/////////////////////////////////////////////////////////////////callnet////////////////////////////////////////

/////////////////////////////////////////////////////////////////reject////////////////////////////////////////
extern INT_VAR_H (tessedit_reject_mode, 5, "Rejection algorithm");
extern INT_VAR_H (tessedit_ok_mode, 5, "Acceptance decision algorithm");
extern BOOL_VAR_H (tessedit_use_nn, TRUE, "");
extern BOOL_VAR_H (tessedit_rejection_debug, FALSE, "Adaption debug");
extern BOOL_VAR_H (tessedit_rejection_stats, FALSE, "Show NN stats");
extern BOOL_VAR_H (tessedit_flip_0O, TRUE, "Contextual 0O O0 flips");
extern double_VAR_H (tessedit_lower_flip_hyphen, 1.5,
"Aspect ratio dot/hyphen test");
extern double_VAR_H (tessedit_upper_flip_hyphen, 1.8,
"Aspect ratio dot/hyphen test");
extern BOOL_VAR_H (rej_trust_doc_dawg, FALSE,
"Use DOC dawg in 11l conf. detector");
extern BOOL_VAR_H (rej_1Il_use_dict_word, FALSE, "Use dictword test");
extern BOOL_VAR_H (rej_1Il_trust_permuter_type, TRUE, "Dont double check");
extern BOOL_VAR_H (one_ell_conflict_default, TRUE,
"one_ell_conflict default");
extern BOOL_VAR_H (show_char_clipping, FALSE, "Show clip image window?");
extern BOOL_VAR_H (nn_debug, FALSE, "NN DEBUGGING?");
extern BOOL_VAR_H (nn_reject_debug, FALSE, "NN DEBUG each char?");
extern BOOL_VAR_H (nn_lax, FALSE, "Use 2nd rate matches");
extern BOOL_VAR_H (nn_double_check_dict, FALSE, "Double check");
extern BOOL_VAR_H (nn_conf_double_check_dict, TRUE,
"Double check for confusions");
extern BOOL_VAR_H (nn_conf_1Il, TRUE, "NN use 1Il conflicts");
extern BOOL_VAR_H (nn_conf_Ss, TRUE, "NN use Ss conflicts");
extern BOOL_VAR_H (nn_conf_hyphen, TRUE, "NN hyphen conflicts");
extern BOOL_VAR_H (nn_conf_test_good_qual, FALSE, "NN dodgy 1Il cross check");
extern BOOL_VAR_H (nn_conf_test_dict, TRUE, "NN dodgy 1Il cross check");
extern BOOL_VAR_H (nn_conf_test_sensible, TRUE, "NN dodgy 1Il cross check");
extern BOOL_VAR_H (nn_conf_strict_on_dodgy_chs, TRUE,
"Require stronger NN match");
extern double_VAR_H (nn_dodgy_char_threshold, 0.99, "min accept score");
extern INT_VAR_H (nn_conf_accept_level, 4, "NN accept dodgy 1Il matches? ");
extern INT_VAR_H (nn_conf_initial_i_level, 3,
"NN accept initial Ii match level ");
extern BOOL_VAR_H (no_unrej_dubious_chars, TRUE,
"Dubious chars next to reject?");
extern BOOL_VAR_H (no_unrej_no_alphanum_wds, TRUE,
"Stop unrej of non A/N wds?");
extern BOOL_VAR_H (no_unrej_1Il, FALSE, "Stop unrej of 1Ilchars?");
extern BOOL_VAR_H (rej_use_tess_accepted, TRUE,
"Individual rejection control");
extern BOOL_VAR_H (rej_use_tess_blanks, TRUE, "Individual rejection control");
extern BOOL_VAR_H (rej_use_good_perm, TRUE, "Individual rejection control");
extern BOOL_VAR_H (rej_use_sensible_wd, FALSE, "Extend permuter check");
extern BOOL_VAR_H (rej_alphas_in_number_perm, FALSE, "Extend permuter check");
extern double_VAR_H (rej_whole_of_mostly_reject_word_fract, 0.85,
"if >this fract");
extern INT_VAR_H (rej_mostly_reject_mode, 1,
"0-never, 1-afterNN, 2-after new xht");
extern double_VAR_H (tessed_fullstop_aspect_ratio, 1.2,
"if >this fract then reject");
extern INT_VAR_H (net_image_width, 40, "NN input image width");
extern INT_VAR_H (net_image_height, 36, "NN input image height");
extern INT_VAR_H (net_image_x_height, 22, "NN input image x_height");
extern INT_VAR_H (tessedit_image_border, 2, "Rej blbs near image edge limit");
extern INT_VAR_H (net_bl_nodes, 20, "Number of baseline nodes");
extern double_VAR_H (nn_reject_threshold, 0.5, "NN min accept score");
extern double_VAR_H (nn_reject_head_and_shoulders, 0.6,
"top scores sep factor");
extern STRING_VAR_H (ok_single_ch_non_alphanum_wds, "-?\075",
"Allow NN to unrej");
extern STRING_VAR_H (ok_repeated_ch_non_alphanum_wds, "-?*\075",
"Allow NN to unrej");
extern STRING_VAR_H (conflict_set_I_l_1, "Il1[]", "Il1 conflict set");
extern STRING_VAR_H (conflict_set_S_s, "Ss$", "Ss conflict set");
extern STRING_VAR_H (conflict_set_hyphen, "-_~", "hyphen conflict set");
extern STRING_VAR_H (dubious_chars_left_of_reject, "!'+`()-./\\<>;:^_,~\"",
"Unreliable chars");
extern STRING_VAR_H (dubious_chars_right_of_reject, "!'+`()-./\\<>;:^_,~\"",
"Unreliable chars");
extern INT_VAR_H (min_sane_x_ht_pixels, 8,
"Reject any x-ht lt or eq than this");
void reject_blanks(WERD_RES *word);
void reject_I_1_L(WERD_RES *word);
                                 //detailed results
void reject_poor_matches(WERD_RES *word, BLOB_CHOICE_LIST_CLIST *blob_choices);
float compute_reject_threshold(  //compute threshold //detailed results
                               BLOB_CHOICE_LIST_CLIST *blob_choices);
int sort_floats(                   //qsort function
                const void *arg1,  //ptrs to floats
                const void *arg2);
void reject_edge_blobs(WERD_RES *word);
BOOL8 word_contains_non_1_digit(const char *word,
                                const char *word_lengths);
                                 //of character
inT16 nn_match_char(IMAGE &scaled_image,
                    float baseline_pos,       //rel to scaled_image
                    BOOL8 dict_word,          //part of dict wd?
                    BOOL8 checked_dict_word,  //part of dict wd?
                    BOOL8 sensible_word,      //part acceptable str?
                    BOOL8 centre,             //not at word ends?
                    BOOL8 good_quality_word,  //initial segmentation
                    char tess_ch              //confirm this?
                   );
inT16 evaluate_net_match(char top,
                         float top_score,
                         char next,
                         float next_score,
                         char tess_ch,
                         BOOL8 dict_word,
                         BOOL8 checked_dict_word,
                         BOOL8 sensible_word,
                         BOOL8 centre,
                         BOOL8 good_quality_word);
void dont_allow_dubious_chars(WERD_RES *word);

void dont_allow_1Il(WERD_RES *word);

void reject_mostly_rejects(  //rej all if most rejectd
                           WERD_RES *word);
void flip_hyphens(WERD_RES *word);
void flip_0O(WERD_RES *word);
BOOL8 non_0_digit(const char* str, int length);
/////////////////////////////////////////////////////////////////reject////////////////////////////////////////

/////////////////////////////////////////////////////////////////adaptions////////////////////////////////////////
extern BOOL_VAR_H (tessedit_reject_ems, FALSE, "Reject all m's");
extern BOOL_VAR_H (tessedit_reject_suspect_ems, FALSE, "Reject suspect m's");
extern double_VAR_H (tessedit_cluster_t1, 0.20, "t1 threshold for clustering samples");
extern double_VAR_H (tessedit_cluster_t2, 0.40, "t2 threshold for clustering samples");
extern double_VAR_H (tessedit_cluster_t3, 0.12, "Extra threshold for clustering samples, only keep a new sample if best score greater than this value");
extern double_VAR_H (tessedit_cluster_accept_fraction, 0.80,"Largest fraction of characters in cluster for it to be used for adaption");
extern INT_VAR_H (tessedit_cluster_min_size, 3,  "Smallest number of samples in a cluster for it to be used for adaption");
extern BOOL_VAR_H (tessedit_cluster_debug, FALSE, "Generate and print debug information for adaption by clustering");
extern BOOL_VAR_H (tessedit_use_best_sample, FALSE, "Use best sample from cluster when adapting");
extern BOOL_VAR_H (tessedit_test_cluster_input, FALSE, "Set reject map to enable cluster input to be measured");
extern BOOL_VAR_H (tessedit_matrix_match, TRUE, "Use matrix matcher");
extern BOOL_VAR_H (tessedit_old_matrix_match, FALSE, "Use matrix matcher");
extern BOOL_VAR_H (tessedit_mm_use_non_adaption_set, FALSE, "Don't try to adapt to characters on this list");
extern STRING_VAR_H (tessedit_non_adaption_set, ",.;:'~@*", "Characters to be avoided when adapting");
extern BOOL_VAR_H (tessedit_mm_adapt_using_prototypes, TRUE, "Use prototypes when adapting");
extern BOOL_VAR_H (tessedit_mm_use_prototypes, TRUE, "Use prototypes as clusters are built");
extern BOOL_VAR_H (tessedit_mm_use_rejmap, FALSE, "Adapt to characters using reject map");
extern BOOL_VAR_H (tessedit_mm_all_rejects, FALSE, "Adapt to all characters using, matrix matcher");
extern BOOL_VAR_H (tessedit_mm_only_match_same_char, FALSE, "Only match samples against clusters for the same character");
extern BOOL_VAR_H (tessedit_process_rns, FALSE, "Handle m - rn ambigs");
extern BOOL_VAR_H (tessedit_demo_adaption, FALSE, "Display cut images and matrix match for demo purposes");
extern INT_VAR_H (tessedit_demo_word1, 62, "Word number of first word to display");
extern INT_VAR_H (tessedit_demo_word2, 64, "Word number of second word to display");
extern STRING_VAR_H (tessedit_demo_file, "academe", "Name of document containing demo words");
extern BOOL_VAR_H(tessedit_adapt_to_char_fragments, TRUE, "Adapt to words that contain " " a character composed form fragments");

void print_em_stats(CHAR_SAMPLES_LIST *char_clusters, CHAR_SAMPLE_LIST *chars_waiting);
                                 //lines of the image
CHAR_SAMPLE *clip_sample(PIXROW *pixrow,
                         IMAGELINE *imlines,
                         TBOX pix_box,  //box of imlines extent
                         BOOL8 white_on_black,
                         char c);
void display_cluster_prototypes(CHAR_SAMPLES_LIST *char_clusters);
void reject_all_ems(WERD_RES *word);
void reject_all_fullstops(WERD_RES *word);
void reject_suspect_fullstops(WERD_RES *word);
BOOL8 suspect_em(WERD_RES *word, inT16 index);
BOOL8 suspect_fullstop(WERD_RES *word, inT16 i);
/////////////////////////////////////////////////////////////////adaptions////////////////////////////////////////

/////////////////////////////////////////////////////////////////plotedges////////////////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
extern ScrollView *edge_window;        /* Window for edges */

/*----------------------------------------------------------------------
            Macros
----------------------------------------------------------------------*/
/**********************************************************************
 * update_edge_window
 *
 * Refresh the display of the edge window.
 **********************************************************************/
#define update_edge_window()             \
if (wordrec_display_splits) {                  \
    c_make_current (edge_window);      \
}                                      \


/**********************************************************************
 * edge_window_wait
 *
 * Wait for someone to click in the edges window.
 **********************************************************************/

#define edge_window_wait()  \
if (wordrec_display_splits) window_wait (edge_window)

/*----------------------------------------------------------------------
              F u n c t i o n s
---------------------------------------------------------------------*/
void display_edgepts(LIST outlines);

void draw_blob_edges(TBLOB *blob);

void mark_outline(EDGEPT *edgept);

void mark_split(SPLIT *split);
/////////////////////////////////////////////////////////////////plotedges////////////////////////////////////////

/////////////////////////////////////////////////////////////////vecfuncs////////////////////////////////////////
/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
/**********************************************************************
 * CROSS
 *
 * cross product
 **********************************************************************/

#define CROSS(a,b) \
((a).x * (b).y - (a).y * (b).x)

/**********************************************************************
 * SCALAR
 *
 * scalar vector product
 **********************************************************************/

#define SCALAR(a,b) \
((a).x * (b).x + (a).y * (b).y)

/**********************************************************************
 * LENGTH
 *
 * length of vector
 **********************************************************************/

#define LENGTH(a) \
((a).x * (a).x + (a).y * (a).y)

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
int direction(EDGEPT *point);
/////////////////////////////////////////////////////////////////vecfuncs////////////////////////////////////////

/////////////////////////////////////////////////////////////////outlines////////////////////////////////////////
/*----------------------------------------------------------------------
              C o n s t a n t s
----------------------------------------------------------------------*/
#define LARGE_DISTANCE   100000  /* Used for closest dist */
#define MIN_BLOB_SIZE    10      /* Big units */
#define MAX_ASPECT_RATIO 2.5     /* Widest character */

/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
/**********************************************************************
 * same_point
 *
 * Return TRUE if the point values are the same. The parameters must
 * be of type POINT.
 **********************************************************************/
#define same_point(p1,p2)                    \
    ((abs (p1.x - p2.x) < chop_same_distance) && \
    (abs (p1.y - p2.y) < chop_same_distance))

/**********************************************************************
 * dist_square
 *
 * Return the square of the distance between these two points.  The
 * parameters must be of type POINT.
 **********************************************************************/

#define dist_square(p1,p2)                     \
    ((p2.x - p1.x) * (p2.x - p1.x) +            \
    (p2.y - p1.y) * (p2.y - p1.y))

/**********************************************************************
 * closest
 *
 * The expression provides the EDGEPT that is closest to the point in
 * question.  All three parameters must be of type EDGEPT.
 **********************************************************************/

#define closest(test_p,p1,p2)                   \
(p1 ?                                         \
    (p2 ?                                        \
    ((dist_square (test_p->pos, p1->pos) <      \
        dist_square (test_p->pos, p2->pos)) ?     \
    p1  :                                      \
    p2) :                                      \
    p1)  :                                      \
    p2)

/**********************************************************************
 * edgept_dist
 *
 * Return the distance (squared) between the two edge points.
 **********************************************************************/

#define edgept_dist(p1,p2)  \
(dist_square ((p1)->pos, (p2)->pos))

/**********************************************************************
 * is_exterior_point
 *
 * Return TRUE if the point supplied is an exterior projection from the
 * outline.
 **********************************************************************/

#define is_exterior_point(edge,point)                    \
(same_point (edge->prev->pos, point->pos)  ||          \
    same_point (edge->next->pos, point->pos)  ||          \
    (angle_change (edge->prev, edge, edge->next) -   \
    angle_change (edge->prev, edge, point) > 20))

/**********************************************************************
 * is_equal
 *
 * Return TRUE if the POINTs are equal.
 **********************************************************************/

#define is_equal(p1,p2)  \
(((p1).x == (p2).x) && ((p1).y == (p2).y))

/**********************************************************************
 * is_on_line
 *
 * Return TRUE if the point is on the line segment between the two end
 * points.  The two end points are included as part of the  line.  The
 * parameters must be of type POINT.
 **********************************************************************/

#define is_on_line(p,p0,p1)                  \
    (within_range ((p).x, (p0).x, (p1).x) &&  \
    within_range ((p).y, (p0).y, (p1).y))

/**********************************************************************
 * within_range
 *
 * Return TRUE if the first number is in between the second two numbers.
 * Return FALSE otherwise.
 **********************************************************************/

#define within_range(x,x0,x1) \
    (((x0 <= x) && (x <= x1)) || ((x1 <= x) && (x <= x0)))

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
int crosses_outline(EDGEPT *p0,  /* Start of line */
                    EDGEPT *p1,  /* End of line */
                    EDGEPT *outline);

int is_crossed(TPOINT a0, TPOINT a1, TPOINT b0, TPOINT b1);

int is_same_edgept(EDGEPT *p1, EDGEPT *p2);

EDGEPT *near_point(EDGEPT *point, EDGEPT *line_pt_0, EDGEPT *line_pt_1);

void reverse_outline(EDGEPT *outline);
/////////////////////////////////////////////////////////////////outlines////////////////////////////////////////

/////////////////////////////////////////////////////////////////chop////////////////////////////////////////
/*----------------------------------------------------------------------
              T y p e s
---------------------------------------------------------------------*/
#define MAX_NUM_POINTS 50
typedef HEAP *POINT_GROUP;
typedef HEAP *SPLIT_GROUP;

/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
extern INT_VAR_H(chop_debug, 0, "Chop debug");

extern BOOL_VAR_H(chop_enable, 1, "Chop enable");

extern BOOL_VAR_H(chop_vertical_creep, 0, "Vertical creep");

extern INT_VAR_H(chop_split_length, 10000, "Split Length");

extern INT_VAR_H(chop_same_distance, 2, "Same distance");

extern INT_VAR_H(chop_min_outline_points, 6,
                 "Min Number of Points on Outline");

extern INT_VAR_H(chop_inside_angle, -50, "Min Inside Angle Bend");

extern INT_VAR_H(chop_min_outline_area, 2000, "Min Outline Area");

extern double_VAR_H(chop_split_dist_knob, 0.5, "Split length adjustment");

extern double_VAR_H(chop_overlap_knob, 0.9, "Split overlap adjustment");

extern double_VAR_H(chop_center_knob, 0.15, "Split center adjustment");

extern double_VAR_H(chop_sharpness_knob, 0.06, "Split sharpness adjustment");

extern double_VAR_H(chop_width_change_knob, 5.0, "Width change adjustment");

extern double_VAR_H(chop_ok_split, 100.0, "OK split limit");

extern double_VAR_H(chop_good_split, 50.0, "Good split limit");

extern INT_VAR_H(chop_x_y_weight, 3, "X / Y  length weight");

/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
/**
 * @name point_bend_angle
 *
 * Measure the angle of bend at this edge point. The argument should
 * be of type EDGEPT.
 */
#define point_bend_angle(point) \
(angle_change ((point)->prev, (point), (point)->next))

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
PRIORITY point_priority(EDGEPT *point);

void add_point_to_list(POINT_GROUP point_list, EDGEPT *point);

int angle_change(EDGEPT *point1, EDGEPT *point2, EDGEPT *point3);

int is_little_chunk(EDGEPT *point1, EDGEPT *point2);

int is_small_area(EDGEPT *point1, EDGEPT *point2);

EDGEPT *pick_close_point(EDGEPT *critical_point,
                         EDGEPT *vertical_point,
                         int *best_dist);

void prioritize_points(TESSLINE *outline, POINT_GROUP points);

void new_min_point(EDGEPT *local_min, POINT_GROUP points);

void new_max_point(EDGEPT *local_max, POINT_GROUP points);

void vertical_projection_point(EDGEPT *split_point, EDGEPT *target_point,
                               EDGEPT** best_point);
/////////////////////////////////////////////////////////////////chop////////////////////////////////////////

/////////////////////////////////////////////////////////////////fxid////////////////////////////////////////
#define FEATURE_MATCHER    1     /**< Use micro-features */

#define WO_UNSCALED        0     /**< first square scaled fx */
#define STATISTICAL_WO     1     /**< new wo */
#define MICRO_FEATURES     2     /**< microfeature extractor */
#define WO_SCALED          3     /**< wiseowl scaled to baseline */
#define MAX_FX             3     /**< no of working fx-ers */
#define NO_FUNCTION        0     /**< special value for nothing */

/* This file contains declarations of the top-level feature
extractor functions as used by the Classify process*/

typedef LIST (*LISTFUNC) ();

//extern FUNCPTR             word_matchers[MAX_FX];

//extern LISTFUNC            blob_matchers[MAX_FX];

//extern FUNCPTR             feature_learners[MAX_FX];

extern char fx_ids[MAX_FX];      /*one-char ids */

extern char *fx_names[MAX_FX];
/////////////////////////////////////////////////////////////////fxid////////////////////////////////////////

/////////////////////////////////////////////////////////////////tface////////////////////////////////////////
extern BOOL_VAR_H(wordrec_no_block, false, "Don't output block information");

/*----------------------------------------------------------------------------
          Function Prototypes
----------------------------------------------------------------------------*/
void edit_with_ocr(const char *imagename);
/////////////////////////////////////////////////////////////////tface////////////////////////////////////////

/////////////////////////////////////////////////////////////////measure////////////////////////////////////////
/*
----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------
*/

typedef struct
{
  long num_samples;
  float sum_of_samples;
  float sum_of_squares;
} MEASUREMENT;

/*
----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------
*/

/**********************************************************************
 * add_sample
 *
 * Add one more sample to a measurement.
 **********************************************************************/

#define ADD_SAMPLE(m,s)                           \
(m.sum_of_samples += (float) (s),               \
    m.sum_of_squares += (float) (s) * (float) (s), \
    ++m.num_samples)

/**********************************************************************
 * mean
 *
 * Return the mean value of the measurement.
 **********************************************************************/

#define MEAN(m)                                       \
((m).num_samples ?                                  \
    ((float) ((m).sum_of_samples / (m).num_samples)) : \
    0)

/**********************************************************************
 * new_measurement
 *
 * Initalize a record to hold a measurement of a group of individual
 * samples.
 **********************************************************************/

#define new_measurement(m)   \
((m).num_samples    = 0, \
    (m).sum_of_samples = 0, \
    (m).sum_of_squares = 0)

/**********************************************************************
 * number_of_samples
 *
 * Return the number of samples in a measurement.
 **********************************************************************/

#define number_of_samples(m)  \
((m).num_samples)

/**********************************************************************
 * standard_deviation
 *
 * Return the standard deviation of the measurement.
 **********************************************************************/

#define standard_deviation(m)                                \
((float) sqrt (VARIANCE (m)))

/**********************************************************************
 * variance
 *
 * Return the variance of the measurement.
 **********************************************************************/

#define VARIANCE(m)                                   \
(((m).num_samples > 1) ?                            \
    ((float)                                           \
    (((m).num_samples * (m).sum_of_squares -          \
        (m).sum_of_samples * (m).sum_of_samples) /      \
    (((m).num_samples - 1) * (m).num_samples)))   :  \
    0)

/**********************************************************************
 * print_summary
 *
 * Summarize a MEASUREMENT record.
 **********************************************************************/

#define print_summary(string,measure)                       \
cprintf ("\t%-20s \tn = %d, \tm = %4.2f, \ts = %4.2f\n ",  \
            string,                                          \
            number_of_samples  (measure),                    \
            MEAN           (measure),                    \
            standard_deviation (measure))
//#endif
/////////////////////////////////////////////////////////////////measure////////////////////////////////////////

/////////////////////////////////////////////////////////////////tally////////////////////////////////////////
/*----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------*/
typedef struct _TALLY_
{
  int count;
  int num_buckets;
  int buckets[1];
} *TALLY;

/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
/**********************************************************************
 * inc_tally_bucket
 *
 * Increment the bucket count for the chosen bucket.
 **********************************************************************/

#define inc_tally_bucket(t,i) \
(t->count++,                \
    ((i < t->num_buckets) ?    \
    (t->buckets[i]++) :       \
    (t->buckets[t->num_buckets-1]++)))

/**********************************************************************
 * iterate_tally
 *
 * Iterate through all the buckets in a tally record.
 **********************************************************************/

#define iterate_tally(t,i)  \
for (i=0; i<t->num_buckets; i++)

/**********************************************************************
 * tally_entry
 *
 * Access one of the buckets of a tally record without bounds checking.
 **********************************************************************/

#define tally_entry(t,i)            \
(t->buckets[i])

/**********************************************************************
 * tally_value
 *
 * Access one of the buckets of a tally record with bounds checking.
 **********************************************************************

#define tally_value(t,i)            \
((i>=0 && i<t->num_buckets) ?     \
  (tally_entry (t,i))   :          \
  (cprintf ("error: tried to access non-existant bucket %d\n", i)))
*/

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
TALLY new_tally(int num_buckets);

void print_tally(FILE *file, const char *string, TALLY t);
/////////////////////////////////////////////////////////////////tally////////////////////////////////////////

/////////////////////////////////////////////////////////////////associate////////////////////////////////////////
/*
----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------
*/

/** List of (BLOB*) */
typedef LIST BLOBS;

/** List of (TESSLINE*) */
typedef LIST OUTLINES;

/** List of (EDGEPT*) */
typedef LIST EDGEPTS;

typedef inT16 BLOB_WEIGHTS[MAX_NUM_CHUNKS];

/** Each char evaluated */
typedef struct
{
    float match;
    float certainty;
    char character;
    int width;
    int gap;
} EVALUATION_RECORD;

/** Classification info for chunks */
struct CHUNKS_RECORD
{
    MATRIX *ratings;
    TBLOB *chunks;
    SEAMS splits;
    TEXTROW *row;
    int fx;
    int x_height;
    WIDTH_RECORD *chunk_widths;
    WIDTH_RECORD *char_widths;
    inT16 *weights;
};

/** Each segmentation */
typedef EVALUATION_RECORD EVALUATION_ARRAY[MAX_NUM_CHUNKS];

/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
extern EVALUATION_ARRAY last_segmentation;
extern WIDTH_RECORD *char_widths;
extern BOOL_VAR_H(wordrec_enable_assoc, 1, "Associator Enable");
extern BOOL_VAR_H(force_word_assoc, FALSE, "always force associator to run, independent of what enable_assoc is."
                  "This is used for CJK where component grouping is necessary.");

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
void init_associate_vars();
void print_eval_record(const char* label, EVALUATION_RECORD *eval_rec);
/////////////////////////////////////////////////////////////////associate////////////////////////////////////////

/////////////////////////////////////////////////////////////////closed////////////////////////////////////////
/*----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------*/
typedef STATE *HASH_TABLE;
#define NO_STATE ~0

/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
extern HASH_TABLE global_hash;

/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
/**
 * free_hash_table
 *
 * Free the memory taken by a state variable.
 */
#define free_hash_table(table) \
    global_hash = table

/*---------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
int hash_add(HASH_TABLE state_table, STATE *state);

int hash_lookup(HASH_TABLE state_table, STATE *state);

HASH_TABLE new_hash_table();
/////////////////////////////////////////////////////////////////closed////////////////////////////////////////

/////////////////////////////////////////////////////////////////render////////////////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
extern ScrollView *blob_window;        /* Window for blobs */
extern C_COL color_list[];       /* Colors for outlines */

extern BOOL_VAR_H(wordrec_display_all_blobs, 0, "Display Blobs");

extern BOOL_VAR_H(wordrec_display_all_words, 0, "Display Words");

extern BOOL_VAR_H(wordrec_blob_pause, 0, "Blob pause");

#define NUM_COLORS 6

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
void display_blob(TBLOB *blob, C_COL color);

void render_blob(void *window, TBLOB *blob, C_COL color);

void render_edgepts(void *window, EDGEPT *edgept, C_COL color);

void render_outline(void *window,
                    TESSLINE *outline,
                    C_COL color);
/////////////////////////////////////////////////////////////////render////////////////////////////////////////

/////////////////////////////////////////////////////////////////plotseg////////////////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
extern ScrollView *segm_window;
extern INT_VAR_H(wordrec_display_segmentations, 0, "Display Segmentations");

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
void display_segmentation(TBLOB *chunks, SEARCH_STATE segmentation);

void render_segmentation(ScrollView *window,
                         TBLOB *chunks,
                         SEARCH_STATE segmentation);
/////////////////////////////////////////////////////////////////plotseg////////////////////////////////////////

/////////////////////////////////////////////////////////////////matchtab////////////////////////////////////////
/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
void init_match_table();
void end_match_table();

void put_match(TBLOB *blob, BLOB_CHOICE_LIST *ratings);

BLOB_CHOICE_LIST *get_match(TBLOB *blob);

BLOB_CHOICE_LIST *get_match_by_bounds(unsigned int topleft,
                                      unsigned int botright);

void add_to_match(TBLOB *blob, BLOB_CHOICE_LIST *ratings);
/////////////////////////////////////////////////////////////////matchtab////////////////////////////////////////

/////////////////////////////////////////////////////////////////pieces////////////////////////////////////////
/*----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------*/
typedef struct
{                                /*  BOUNDS  */
  TPOINT topleft;
  TPOINT botright;
} BOUNDS;

typedef BOUNDS *BOUNDS_LIST;     /*  BOUNDS_LIST  */

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
void break_pieces(TBLOB *blobs, SEAMS seams, inT16 start, inT16 end);

void join_pieces(TBLOB *piece_blobs, SEAMS seams, inT16 start, inT16 end);

void hide_seam(SEAM *seam);

void hide_edge_pair(EDGEPT *pt1, EDGEPT *pt2);

void reveal_seam(SEAM *seam);

void reveal_edge_pair(EDGEPT *pt1, EDGEPT *pt2);

void bounds_of_piece(BOUNDS_LIST bounds,
                     inT16 start,
                     inT16 end,
                     TPOINT *extreme_tl,
                     TPOINT *extreme_br);

BOUNDS_LIST record_blob_bounds(TBLOB *blobs);

MATRIX *record_piece_ratings(TBLOB *blobs);
/////////////////////////////////////////////////////////////////pieces////////////////////////////////////////

/////////////////////////////////////////////////////////////////bestfirst////////////////////////////////////////
/*----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------*/
struct SEARCH_RECORD
{
    HEAP *open_states;
    HASH_TABLE closed_states;
    STATE *this_state;
    STATE *first_state;
    STATE *best_state;
    int num_joints;
    long num_states;
    long before_best;
    float segcost_bias;
    WERD_CHOICE *best_choice;
    WERD_CHOICE *raw_choice;
};

/*----------------------------------------------------------------------
              V a r i a b l e s
---------------------------------------------------------------------*/
extern INT_VAR_H(wordrec_num_seg_states, 30, "Segmentation states");

extern double_VAR_H(wordrec_worst_state, 1, "Worst segmentation state");


/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
int chunks_width(WIDTH_RECORD *width_record, int start_chunk, int last_chunk);
int chunks_gap(WIDTH_RECORD *width_record, int last_chunk);

void delete_search(SEARCH_RECORD *the_search);

SEARCH_RECORD *new_search(CHUNKS_RECORD *chunks_record, int num_joints, WERD_CHOICE *best_choice, WERD_CHOICE *raw_choice, STATE *state);

STATE *pop_queue(HEAP *queue);

void push_queue(HEAP *queue, STATE *state, FLOAT32 worst_priority, FLOAT32 priority);

void replace_char_widths(CHUNKS_RECORD *chunks_record, SEARCH_STATE state);

// Joins blobs between index x and y, hides corresponding seams and
// returns classification of the resulting merged blob.
BLOB_CHOICE_LIST *join_blobs_and_classify(TBLOB *blobs, SEAMS seam_list, int x, int y, int fx);
/////////////////////////////////////////////////////////////////bestfirst////////////////////////////////////////

/////////////////////////////////////////////////////////////////wordclass////////////////////////////////////////
/*----------------------------------------------------------------------
            Variables
----------------------------------------------------------------------*/
extern inT16 first_pass;

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
void write_text_files(TWERD *word,
                      char *raw_choice,
                      int same_row,
                      int good_word,
                      int firstpass);
/////////////////////////////////////////////////////////////////wordclass////////////////////////////////////////

/////////////////////////////////////////////////////////////////metrics////////////////////////////////////////
/*----------------------------------------------------------------------
              V a r i a b l e s
----------------------------------------------------------------------*/
extern int words_chopped1;
extern int words_chopped2;
extern int chops_attempted1;
extern int chops_performed1;
extern int chops_attempted2;
extern int chops_performed2;
extern int permutation_count;

extern int character_count;
extern int word_count;
extern int chars_classified;

extern MEASUREMENT width_measure;
extern MEASUREMENT width_priority_range;
extern MEASUREMENT match_priority_range;

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
void init_metrics();
void end_metrics();

void record_certainty(float certainty, int pass);

void record_search_status(int num_states, int before_best, float closeness);

void record_priorities(SEARCH_RECORD *the_search,
                       FLOAT32 priority_1,
                       FLOAT32 priority_2);

void record_samples(FLOAT32 match_pri, FLOAT32 width_pri);

void reset_width_tally();

void save_best_state(CHUNKS_RECORD *chunks_record);

void start_recording();

void stop_recording();
/////////////////////////////////////////////////////////////////metrics////////////////////////////////////////

/////////////////////////////////////////////////////////////////docqual////////////////////////////////////////
enum GARBAGE_LEVEL
{
  G_NEVER_CRUNCH,
  G_OK,
  G_DODGY,
  G_TERRIBLE
};

extern STRING_VAR_H (outlines_odd, "%| ", "Non standard number of outlines");
extern STRING_VAR_H (outlines_2, "ij!?%\":;", "Non standard number of outlines");
extern BOOL_VAR_H (docqual_excuse_outline_errs, FALSE, "Allow outline errs in unrejection?");
extern BOOL_VAR_H (tessedit_good_quality_unrej, TRUE, "Reduce rejection on good docs");
extern BOOL_VAR_H (tessedit_use_reject_spaces, TRUE, "Reject spaces?");
extern double_VAR_H (tessedit_reject_doc_percent, 65.00, "%rej allowed before rej whole doc");
extern double_VAR_H (tessedit_reject_block_percent, 45.00, "%rej allowed before rej whole block");
extern double_VAR_H (tessedit_reject_row_percent, 40.00, "%rej allowed before rej whole row");
extern double_VAR_H (tessedit_whole_wd_rej_row_percent, 70.00, "%of row rejects in whole word rejects which prevents whole row rejection");
extern BOOL_VAR_H (tessedit_preserve_blk_rej_perfect_wds, TRUE, "Only rej partially rejected words in block rejection");
extern BOOL_VAR_H (tessedit_preserve_row_rej_perfect_wds, TRUE, "Only rej partially rejected words in row rejection");
extern BOOL_VAR_H (tessedit_dont_blkrej_good_wds, FALSE, "Use word segmentation quality metric");
extern BOOL_VAR_H (tessedit_dont_rowrej_good_wds, FALSE, "Use word segmentation quality metric");
extern INT_VAR_H (tessedit_preserve_min_wd_len, 2, "Only preserve wds longer than this");
extern BOOL_VAR_H (tessedit_row_rej_good_docs, TRUE, "Apply row rejection to good docs");
extern double_VAR_H (tessedit_good_doc_still_rowrej_wd, 1.1, "rej good doc wd if more than this fraction rejected");
extern BOOL_VAR_H (tessedit_reject_bad_qual_wds, TRUE, "Reject all bad quality wds");
extern BOOL_VAR_H (tessedit_debug_doc_rejection, FALSE, "Page stats");
extern BOOL_VAR_H (tessedit_debug_quality_metrics, FALSE, "Output data to debug file");
extern BOOL_VAR_H (bland_unrej, FALSE, "unrej potential with no chekcs");
extern double_VAR_H (quality_rowrej_pc, 1.1, "good_quality_doc gte good char limit");
extern BOOL_VAR_H (unlv_tilde_crunching, TRUE, "Mark v.bad words for tilde crunch");
extern BOOL_VAR_H (crunch_early_merge_tess_fails, TRUE, "Before word crunch?");
extern BOOL_VAR_H (crunch_early_convert_bad_unlv_chs, FALSE, "Take out ~^ early?");
extern double_VAR_H (crunch_terrible_rating, 80.0, "crunch rating lt this");
extern BOOL_VAR_H (crunch_terrible_garbage, TRUE, "As it says");
extern double_VAR_H (crunch_poor_garbage_cert, -9.0, "crunch garbage cert lt this");
extern double_VAR_H (crunch_poor_garbage_rate, 60, "crunch garbage rating lt this");
extern double_VAR_H (crunch_pot_poor_rate, 40, "POTENTIAL crunch rating lt this");
extern double_VAR_H (crunch_pot_poor_cert, -8.0, "POTENTIAL crunch cert lt this");
extern BOOL_VAR_H (crunch_pot_garbage, TRUE, "POTENTIAL crunch garbage");
extern double_VAR_H (crunch_del_rating, 60, "POTENTIAL crunch rating lt this");
extern double_VAR_H (crunch_del_cert, -10.0, "POTENTIAL crunch cert lt this");
extern double_VAR_H (crunch_del_min_ht, 0.7, "Del if word ht lt xht x this");
extern double_VAR_H (crunch_del_max_ht, 3.0, "Del if word ht gt xht x this");
extern double_VAR_H (crunch_del_min_width, 3.0, "Del if word width lt xht x this");
extern double_VAR_H (crunch_del_high_word, 1.5, "Del if word gt xht x this above bl");
extern double_VAR_H (crunch_del_low_word, 0.5, "Del if word gt xht x this below bl");
extern double_VAR_H (crunch_small_outlines_size, 0.6, "Small if lt xht x this");
extern INT_VAR_H (crunch_rating_max, 10, "For adj length in rating per ch");
extern INT_VAR_H (crunch_pot_indicators, 1, "How many potential indicators needed");
extern BOOL_VAR_H (crunch_leave_ok_strings, TRUE, "Dont touch sensible strings");
extern BOOL_VAR_H (crunch_accept_ok, TRUE, "Use acceptability in okstring");
extern BOOL_VAR_H (crunch_leave_accept_strings, FALSE, "Dont pot crunch sensible strings");
extern BOOL_VAR_H (crunch_include_numerals, FALSE, "Fiddle alpha figures");
extern INT_VAR_H (crunch_leave_lc_strings, 4, "Dont crunch words with long lower case strings");
extern INT_VAR_H (crunch_leave_uc_strings, 4, "Dont crunch words with long lower case strings");
extern INT_VAR_H (crunch_long_repetitions, 3, "Crunch words with long repetitions");
extern INT_VAR_H (crunch_debug, 0, "As it says");

//Blob seg changes
inT16 word_blob_quality(WERD_RES *word, ROW *row);

//BOOL8 crude_match_blobs(PBLOB *blob1, PBLOB *blob2);
//Outline count errs
inT16 word_outline_errs(WERD_RES *word);

//Blob seg changes
void word_char_quality(WERD_RES *word, ROW *row, inT16 *match_count, inT16 *accepted_match_count);

//void unrej_good_chs(WERD_RES *word, ROW *row);
void print_boxes(WERD *word);
inT16 count_outline_errs(char c, inT16 outline_count);
void reject_whole_page(PAGE_RES_IT &page_res_it);
BOOL8 terrible_word_crunch(WERD_RES *word, GARBAGE_LEVEL garbage_level);

//word to do
CRUNCH_MODE word_deletable(WERD_RES *word, inT16 &delete_mode);
inT16 failure_count(WERD_RES *word);
BOOL8 noise_outlines(WERD *word);
/////////////////////////////////////////////////////////////////docqual////////////////////////////////////////

/////////////////////////////////////////////////////////////////ocrshell////////////////////////////////////////
#define EUC_FORMAT_MASK   0xe0

/**********************************************************************
 * ocr_open_shm
 *
 * Attempt to connect to the shared memory segment and semaphores used
 * in talking to the OCR engine. Called from OCR engine.
 * The parameters are the command line arguments in order.
 * The final parameter is a return value indicating the user-requested
 * language.					The value will be LANGE_NONE if the user wishes to use
 * the default.
 **********************************************************************/
#ifdef __MAC__
inT16 ocr_open_shm(uinT16 *lang);
#else
inT16 ocr_open_shm(                       /*open the shm */
                   const char *shm_h,     /*handle of shm */
                   const char *shm_size,  /*size of shm segment */
                   const char *mutex_h,   /*hp mutex */
                   const char *ocr_h,     /*ocr semaphore */
                   const char *hp_h,      /*hp semaphore */
                   const char *lang_str,  /*language */
                   uinT16 *lang           /*required language */
                  );
#endif

/**********************************************************************
 * ocr_append_fontinfo
 *
 * Initialize one of the font descriptors.
 **********************************************************************/

inT16 ocr_append_fontinfo(                    /*put info into shm */
                          uinT16 language,    /*default language */
                          uinT8 font_family,  /*serif/not, fixed/not */
                          uinT8 char_set,     /*character set standard */
                          uinT8 pitch,        /*fixed or prop */
                          const char *name    /*plain ascii name */
                         );

/**********************************************************************
 * ocr_setup_startinfo
 *
 * Setup the info on the OCR engine. Uses 16 bit chars to name the
 * engine.
 **********************************************************************/

inT16 ocr_setup_startinfo(                       /*put info into shm */
                          uinT32 protocol,       /*interface version */
                          uinT16 language,       /*default language */
                          const uinT16 *name,    /*name of engine */
                          const uinT16 *version  /*version of engine */
                         );

/**********************************************************************
 * ocr_setup_startinfo_ansi
 *
 * Setup the info on the OCR engine. Uses 8 bit chars to name the
 * engine.
 **********************************************************************/

inT16 ocr_setup_startinfo_ansi(                     /*put info into shm */
                               uinT32 protocol,     /*interface version */
                               uinT16 language,     /*default language */
                               const char *name,    /*name of engine */
                               const char *version  /*version of engine */
                              );

/**********************************************************************
 * ocr_get_first_image_strip
 *
 * Wait for the master to send the first image strip and return a
 * pointer to it. The result is NULL if it is time to exit.
 **********************************************************************/

                                 /*get image strip */
ESTRIP_DESC *ocr_get_first_image_strip();

/**********************************************************************
 * ocr_get_next_image_strip
 *
 * Wait for the master to send the next image strip and return a
 * pointer to it. The result is NULL if it is time to exit.
 **********************************************************************/

                                 /*get image strip */
ESTRIP_DESC *ocr_get_next_image_strip();

/**********************************************************************
 * ocr_setup_monitor
 *
 * Setup the progress monitor. Call before starting the recognize task.
 **********************************************************************/

ETEXT_DESC *ocr_setup_monitor();  /*setup monitor */

/**********************************************************************
 * ocr_char_space
 *
 * Return the number of chars that can be fitted into the buffer.
 **********************************************************************/

inT32 ocr_char_space();  /*put char into shm */

/**********************************************************************
 * ocr_append_char
 *
 * Add a character to the output. Returns OKAY if successful, HPERR
 * if there was insufficient room in the buffer.
 **********************************************************************/

inT16 ocr_append_char(                              /*put char into shm */
                      uinT16 char_code,             /*character itself */
                      inT16 left,                   /*of char (-1) */
                      inT16 right,                  /*of char (-1) */
                      inT16 top,                    /*of char (-1) */
                      inT16 bottom,                 /*of char (-1) */
                      inT16 font_index,             /*what font (-1) */
                      uinT8 confidence,             /*0=perfect, 100=reject (0/100) */
                      uinT8 point_size,             /*of char, 72=i inch, (10) */
                      inT8 blanks,                  /*no of spaces before this char (1) */
                      uinT8 enhancement,            /*char enhancement (0) */
                      OCR_CHAR_DIRECTION text_dir,  /*rendering direction (OCR_CDIR_RIGHT_LEFT) */
                      OCR_LINE_DIRECTION line_dir,  /*line rendering direction (OCR_LDIR_DOWN_RIGHT) */
                      OCR_NEWLINE_TYPE nl_type      /*type of newline (if any) (OCR_NL_NONE) */
                     );

/**********************************************************************
 * ocr_send_text
 *
 * Send the text to the host and wait for the ack.
 * Use this function after a sequence of ocr_append_text calls to
 * actually sent the text to the master process.
 * Set more to come TRUE if there is more text in this page, FALSE
 * if the OCR engine is now ready to receive another image.
 **********************************************************************/

inT16 ocr_send_text(                    /*send shm */
                    BOOL8 more_to_come  /*any text left */
                   );

/**********************************************************************
 * ocr_shutdown
 *
 * Closedown communications with the HP side and free up handles.
 **********************************************************************/

inT16 ocr_shutdown();  /*closedown */

/**********************************************************************
 * ocr_error
 *
 * Inform the HP side of an error.
 * The OCR engine should do any cleanup of its own and exit aferwards.
 * Uses the current state to determine how to send it and cleanup.
 **********************************************************************/

void ocr_error(                   /*send an error code */
               OCR_ERR_CODE code  /*error code */
              );
/////////////////////////////////////////////////////////////////ocrshell////////////////////////////////////////

/////////////////////////////////////////////////////////////////output////////////////////////////////////////
extern BOOL_EVAR_H (tessedit_write_block_separators, TRUE,
"Write block separators in output");
extern BOOL_VAR_H (tessedit_write_raw_output, FALSE,
"Write raw stuff to name.raw");
extern BOOL_EVAR_H (tessedit_write_output, TRUE, "Write text to name.txt");
extern BOOL_EVAR_H (tessedit_write_txt_map, TRUE,
"Write .txt to .etx map file");
extern BOOL_EVAR_H (tessedit_write_rep_codes, TRUE,
"Write repetition char code");
extern BOOL_EVAR_H (tessedit_write_unlv, FALSE, "Write .unlv output file");
extern STRING_EVAR_H (unrecognised_char, "|",
"Output char for unidentified blobs");
extern INT_EVAR_H (suspect_level, 99, "Suspect marker level");
extern INT_VAR_H (suspect_space_level, 100,
"Min suspect level for rejecting spaces");
extern INT_VAR_H (suspect_short_words, 2,
"Dont Suspect dict wds longer than this");
extern BOOL_VAR_H (suspect_constrain_1Il, FALSE,
"UNLV keep 1Il chars rejected");
extern double_VAR_H (suspect_rating_per_ch, 999.9,
"Dont touch bad rating limit");
extern double_VAR_H (suspect_accept_rating, -999.9,
"Accept good rating limit");
extern BOOL_EVAR_H (tessedit_minimal_rejection, FALSE,
"Only reject tess failures");
extern BOOL_VAR_H (tessedit_zero_rejection, FALSE, "Dont reject ANYTHING");
extern BOOL_VAR_H (tessedit_word_for_word, FALSE,
"Make output have exactly one word per WERD");
extern BOOL_VAR_H (tessedit_consistent_reps, TRUE,
"Force all rep chars the same");

/** output a word */
void write_results(
                   PAGE_RES_IT &page_res_it,  ///< full info
                   char newline_type,         ///< type of newline
                   BOOL8 force_eol,           ///< override tilde crunch?
                   BOOL8 write_to_shm         ///< send to api
                  );

/** convert one word */
WERD_CHOICE *make_epaper_choice(
                                WERD_RES *word,    ///< word to do
                                char newline_type  ///< type of newline
                               );
/** make reject code */
inT16 make_reject (
TBOX * inset_box,                ///< bounding box
inT16 prevright,                 ///< previous char
inT16 nextleft,                  ///< next char
DENORM * denorm,                 ///< de-normalizer
char word_string[]               ///< output string
);

/** test line ends */
char determine_newline_type(WERD *word,        ///< word to do
                            BLOCK *block,      ///< current block
                            WERD *next_word,   ///< next word
                            BLOCK *next_block  ///< block of next word
                           );
/** write output */
void write_cooked_text(WERD *word,          ///< word to do
                       const STRING &text,  ///< text to write
                       BOOL8 acceptable,    ///< good stuff
                       BOOL8 pass2,         ///< done on pass2
                       FILE *fp             ///< file to write
                      );
/** write output */
void write_shm_text(WERD_RES *word,     ///< word to do
                    BLOCK *block,       ///< block it is from
                    ROW_RES *row,       ///< row it is from
                    const STRING &text, ///< text to write
                    const STRING &text_lengths
                   );
/** output a map file */
void write_map(
               FILE *mapfile,  ///< mapfile to write to
               WERD_RES *word  ///< word
              );
/*FILE *open_outfile(  //open .map & .unlv file
                   const char *extension);*/
void write_unlv_text(WERD_RES *word);
void ensure_rep_chars_are_consistent(WERD_RES *word);
/////////////////////////////////////////////////////////////////output////////////////////////////////////////

/////////////////////////////////////////////////////////////////werdit////////////////////////////////////////
class WERDIT
{
  public:
    WERDIT() {
    }                            //empty contructor
    WERDIT(                          //empty contructor
           BLOCK_LIST *blocklist) {  //blocks on page
      start_page(blocklist);  //ready to scan
    }

    void start_page(                         //get ready
                    BLOCK_LIST *blocklist);  //blocks on page

    WERD *forward();  //get next word
    WERD *next_word() {  //get next word
      return word_it.data ();    //already at next
    }
    ROW *row() {  //get current row
      return word_it.cycled_list ()? NULL : row_it.data ();
    }
    ROW *next_row() {  //get next row
      return row_it.data_relative (1);
    }
    BLOCK *block() {  //get current block
      return block_it.data ();
    }

  private:
    BLOCK_IT block_it;           //iterators
    ROW_IT row_it;
    WERD_IT word_it;
};

//extern BOOL_VAR_H(wordit_linearc,FALSE,"Pass poly of linearc to Tess");
WERD *make_pseudo_word(                         //make fake word
                       BLOCK_LIST *block_list,  //blocks to check //block of selection
                       TBOX &selection_box,
                       BLOCK *&pseudo_block,
                       ROW *&pseudo_row         //row of selection
                      );
/////////////////////////////////////////////////////////////////werdit////////////////////////////////////////

/////////////////////////////////////////////////////////////////fixxht////////////////////////////////////////
extern double_VAR_H (x_ht_fraction_of_caps_ht, 0.7,
"Fract of cps ht est of xht");
extern double_VAR_H (x_ht_variation, 0.35,
"Err band as fract of caps/xht dist");
extern double_VAR_H (x_ht_sub_variation, 0.5,
"Err band as fract of caps/xht dist");
extern BOOL_VAR_H (rej_trial_ambigs, TRUE,
"reject x-ht ambigs when under trial");
extern BOOL_VAR_H (x_ht_conservative_ambigs, FALSE,
"Dont rely on ambigs + maxht");
extern BOOL_VAR_H (x_ht_check_est, TRUE, "Cross check estimates");
extern BOOL_VAR_H (x_ht_case_flip, FALSE, "Flip or reject suspect case");
extern BOOL_VAR_H (x_ht_include_dodgy_blobs, TRUE,
"Include blobs with possible noise?");
extern BOOL_VAR_H (x_ht_limit_flip_trials, TRUE,
"Dont do trial flips when ambigs are close to xht?");
extern BOOL_VAR_H (rej_use_check_block_occ, TRUE,
"Analyse rejection behaviour");
extern STRING_VAR_H (chs_non_ambig_caps_ht,
"!#$%&()/12346789?ABDEFGHIKLNQRT[]\\bdfhkl",
"Reliable ascenders");
extern STRING_VAR_H (chs_x_ht, "acegmnopqrsuvwxyz", "X height chars");
extern STRING_VAR_H (chs_non_ambig_x_ht, "aenqr", "reliable X height chars");
extern STRING_VAR_H (chs_ambig_caps_x, "cCmMoO05sSuUvVwWxXzZ",
"X ht or caps ht chars");
extern STRING_VAR_H (chs_bl_ambig_caps_x, "pPyY",
" Caps or descender ambigs");
extern STRING_VAR_H (chs_caps_ht,
"!#$%&()/0123456789?ABCDEFGHIJKLMNOPQRSTUVWXYZ[]\\bdfhkl{|}",
"Ascender chars");
extern STRING_VAR_H (chs_desc, "gjpqy", "Descender chars");
extern STRING_VAR_H (chs_non_ambig_bl,
"!#$%&01246789?ABCDEFGHIKLMNORSTUVWXYZabcdehiklmnorstuvwxz",
"Reliable baseline chars");
extern STRING_VAR_H (chs_odd_top, "ijt", "Chars with funny ascender region");
extern STRING_VAR_H (chs_odd_bot, "()35JQ[]\\/{}|", "Chars with funny base");
extern STRING_VAR_H (chs_bl,
"!#$%&()/01246789?ABCDEFGHIJKLMNOPRSTUVWXYZ[]\\abcdefhiklmnorstuvwxz{}",
"Baseline chars");
extern STRING_VAR_H (chs_non_ambig_desc, "gq", "Reliable descender chars");
void re_estimate_x_ht(                     //improve for 1 word
                      WERD_RES *word_res,  //word to do
                      float *trial_x_ht    //new match value
                     );
void check_blob_occ(char *proposed_char,
                    inT16 blob_ht_above_baseline,
                    float x_ht,
                    float caps_ht,
                    char *confirmed_char);
float estimate_from_stats(STATS &stats);
void improve_estimate(WERD_RES *word_res,
                      float &est_x_ht,
                      float &est_caps_ht,
                      STATS &x_ht,
                      STATS &caps_ht);
void reject_ambigs(  //rej any accepted xht ambig chars
                   WERD_RES *word);
                                 //xht ambig ht stats
void est_ambigs(WERD_RES *word_res,
                STATS &stats,
                float *ambig_lc_x_est,    //xht est
                float *ambig_uc_caps_est  //caps est
               );
BOOL8 dodgy_blob(PBLOB *blob);
/////////////////////////////////////////////////////////////////fixxht////////////////////////////////////////

/////////////////////////////////////////////////////////////////drawfx////////////////////////////////////////
extern STRING_VAR_H (fx_debugfile, DEBUG_WIN_NAME, "Name of debugfile");
extern ScrollView* fx_win;
extern FILE *fx_debug;
void create_fx_win();  //make features win
void clear_fx_win();  //make features win
void create_fxdebug_win();  //make gradients win
/////////////////////////////////////////////////////////////////drawfx////////////////////////////////////////

/////////////////////////////////////////////////////////////////expandblob////////////////////////////////////////
void free_blob(register TBLOB *blob);

void free_tree(register TESSLINE *outline);

void free_outline(register TESSLINE *outline);

void free_loop(register EDGEPT *startpt);
/////////////////////////////////////////////////////////////////expandblob////////////////////////////////////////

/////////////////////////////////////////////////////////////////efio////////////////////////////////////////
#define FOPENERROR      3000

/**----------------------------------------------------------------------------
          Public Function Prototype
----------------------------------------------------------------------------**/
FILE *Efopen(const char *Name, const char *Mode);
/////////////////////////////////////////////////////////////////efio////////////////////////////////////////

/////////////////////////////////////////////////////////////////flexfx////////////////////////////////////////
/**----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------**/
CHAR_DESC ExtractFlexFeatures(TBLOB *Blob, LINE_STATS *LineStats);
/////////////////////////////////////////////////////////////////flexfx////////////////////////////////////////

/////////////////////////////////////////////////////////////////extract////////////////////////////////////////
/*-----------------------------------------------------------------------------
          Public Function Prototypes
-----------------------------------------------------------------------------*/
CHAR_DESC ExtractBlobFeatures(TBLOB *Blob, LINE_STATS *LineStats);

/*---------------------------------------------------------------------------
          Private Function Prototypes
----------------------------------------------------------------------------*/
void ExtractorStub();
/////////////////////////////////////////////////////////////////extract////////////////////////////////////////

/////////////////////////////////////////////////////////////////blobclass////////////////////////////////////////
/*---------------------------------------------------------------------------
          Macros
----------------------------------------------------------------------------*/
/* macros for controlling the display of recognized characters */
#define EnableCharDisplay()   (DisplayCharacters = TRUE)
#define DisableCharDisplay()    (DisplayCharacters = FALSE)

/* macros for controlling the display of the entire match list */
#define EnableMatchDisplay()    (DisplayMatchList = TRUE)
#define DisableMatchDisplay()   (DisplayMatchList = FALSE)

/**----------------------------------------------------------------------------
          Public Function Prototypes
----------------------------------------------------------------------------**/
void LearnBlob(const STRING& filename,
               TBLOB * Blob, TEXTROW * Row, const char* BlobText);

void LearnBlob(FILE* File, TBLOB* Blob, TEXTROW* Row,
               const char* BlobText, const char* FontName);
/////////////////////////////////////////////////////////////////blobclass////////////////////////////////////////

/////////////////////////////////////////////////////////////////tessbox////////////////////////////////////////
void tess_training_tester(
                          const STRING& filename,
                          PBLOB *blob,
                          DENORM *denorm,
                          BOOL8 correct,
                          char *text,
                          inT32 count,
                          BLOB_CHOICE_LIST *ratings
                         );
/////////////////////////////////////////////////////////////////tessbox////////////////////////////////////////

/////////////////////////////////////////////////////////////////control////////////////////////////////////////
enum ACCEPTABLE_WERD_TYPE
{
    AC_UNACCEPTABLE,               ///< Unacceptable word
    AC_LOWER_CASE,                 ///< ALL lower case
    AC_UPPER_CASE,                 ///< ALL upper case
    AC_INITIAL_CAP,                ///< ALL but initial lc
    AC_LC_ABBREV,                  ///< a.b.c.
    AC_UC_ABBREV                   ///< A.B.C.
};

typedef BOOL8 (*BLOB_REJECTOR) (PBLOB *, BLOB_CHOICE_IT *, void *);

extern INT_VAR_H (tessedit_single_match, FALSE, "Top choice only from CP");
//extern BOOL_VAR_H(tessedit_small_match,FALSE,"Use small matrix matcher");
extern BOOL_VAR_H (tessedit_print_text, FALSE, "Write text to stdout");
extern BOOL_VAR_H (tessedit_draw_words, FALSE, "Draw source words");
extern BOOL_VAR_H (tessedit_draw_outwords, FALSE, "Draw output words");
extern BOOL_VAR_H (tessedit_training_wiseowl, FALSE,"Call WO to learn blobs");
extern BOOL_VAR_H (tessedit_training_tess, FALSE, "Call Tess to learn blobs");
extern BOOL_VAR_H (tessedit_matcher_is_wiseowl, FALSE, "Call WO to classify");
extern BOOL_VAR_H (tessedit_dump_choices, FALSE, "Dump char choices");
extern BOOL_VAR_H (tessedit_fix_fuzzy_spaces, TRUE,"Try to improve fuzzy spaces");
extern BOOL_VAR_H (tessedit_unrej_any_wd, FALSE,"Dont bother with word plausibility");
extern BOOL_VAR_H (tessedit_fix_hyphens, TRUE, "Crunch double hyphens?");
extern BOOL_VAR_H (tessedit_reject_fullstops, FALSE, "Reject all fullstops");
extern BOOL_VAR_H (tessedit_reject_suspect_fullstops, FALSE,"Reject suspect fullstops");
extern BOOL_VAR_H (tessedit_redo_xheight, TRUE, "Check/Correct x-height");
extern BOOL_VAR_H (tessedit_cluster_adaption_on, TRUE,"Do our own adaption - ems only");
extern BOOL_VAR_H (tessedit_enable_doc_dict, TRUE, "Add words to the document dictionary");
extern BOOL_VAR_H (word_occ_first, FALSE, "Do word occ before re-est xht");
extern BOOL_VAR_H (tessedit_xht_fiddles_on_done_wds, TRUE, "Apply xht fix up even if done");
extern BOOL_VAR_H (tessedit_xht_fiddles_on_no_rej_wds, TRUE, "Apply xht fix up even in no rejects");
extern INT_VAR_H (x_ht_check_word_occ, 2, "Check Char Block occupancy");
extern INT_VAR_H (x_ht_stringency, 1, "How many confirmed a/n to accept?");
extern BOOL_VAR_H (x_ht_quality_check, TRUE, "Dont allow worse quality");
extern BOOL_VAR_H (tessedit_debug_block_rejection, FALSE, "Block and Row stats");
extern INT_VAR_H (debug_x_ht_level, 0, "Reestimate debug");
extern BOOL_VAR_H (rej_use_xht, TRUE, "Individual rejection control");
extern BOOL_VAR_H (debug_acceptable_wds, FALSE, "Dump word pass/fail chk");
extern STRING_VAR_H (chs_leading_punct, "('`\"", "Leading punctuation");
extern STRING_VAR_H (chs_trailing_punct1, ").,;:?!", "1st Trailing punctuation");
extern STRING_VAR_H (chs_trailing_punct2, ")'`\"", "2nd Trailing punctuation");
extern double_VAR_H (quality_rej_pc, 0.08, "good_quality_doc lte rejection limit");
extern double_VAR_H (quality_blob_pc, 0.0, "good_quality_doc gte good blobs limit");
extern double_VAR_H (quality_outline_pc, 1.0, "good_quality_doc lte outline error limit");
extern double_VAR_H (quality_char_pc, 0.95, "good_quality_doc gte good char limit");
extern INT_VAR_H (quality_min_initial_alphas_reqd, 2, "alphas in a good word");
extern BOOL_VAR_H (tessedit_tess_adapt_to_rejmap, FALSE, "Use reject map to control Tesseract adaption");
extern INT_VAR_H (tessedit_tess_adaption_mode, 3, "Adaptation decision algorithm for tess");
extern INT_VAR_H (tessedit_em_adaption_mode, 62, "Adaptation decision algorithm for ems matrix matcher");
extern BOOL_VAR_H (tessedit_cluster_adapt_after_pass1, FALSE, "Adapt using clusterer after pass 1");
extern BOOL_VAR_H (tessedit_cluster_adapt_after_pass2, FALSE, "Adapt using clusterer after pass 1");
extern BOOL_VAR_H (tessedit_cluster_adapt_after_pass3, FALSE, "Adapt using clusterer after pass 1");
extern BOOL_VAR_H (tessedit_cluster_adapt_before_pass1, FALSE, "Adapt using clusterer before Tess adaping during pass 1");
extern INT_VAR_H (tessedit_cluster_adaption_mode, 0, "Adaptation decision algorithm for matrix matcher");
extern BOOL_VAR_H (tessedit_adaption_debug, FALSE, "Generate and print debug information for adaption");
extern BOOL_VAR_H (tessedit_minimal_rej_pass1, FALSE, "Do minimal rejection on pass 1 output");
extern BOOL_VAR_H (tessedit_test_adaption, FALSE, "Test adaption criteria");
extern BOOL_VAR_H (tessedit_global_adaption, FALSE, "Adapt to all docs over time");
extern BOOL_VAR_H (tessedit_matcher_log, FALSE, "Log matcher activity");
extern INT_VAR_H (tessedit_test_adaption_mode, 3, "Adaptation decision algorithm for tess");
extern BOOL_VAR_H (test_pt, FALSE, "Test for point");
extern double_VAR_H (test_pt_x, 99999.99, "xcoord");
extern double_VAR_H (test_pt_y, 99999.99, "ycoord");
extern BOOL_VAR_H(save_best_choices, FALSE, "Save the results of the recognition step" " (blob_choices) within the corresponding WERD_CHOICE");


/////////////////////////////////////////////////////////////////////////////////////////
class CHAR_SAMPLES_LIST;
class CHAR_SAMPLE_LIST;
class PAGE_RES;
class PAGE_RES_IT;
class BLOCK_LIST;
class TO_BLOCK_LIST;
class IMAGE;
class WERD_RES;
class ROW;
class TBOX;
class SVMenuNode;
struct Pix;
class WERD_CHOICE;


// Top-level class for all tesseract global instance data.
// This class either holds or points to all data used by an instance
// of Tesseract, including the memory allocator. When this is
// complete, Tesseract will be thread-safe. UNTIL THEN, IT IS NOT!
//
// NOTE to developers: Do not create cyclic dependencies through this class!
// The directory dependency tree must remain a tree! The keep this clean,
// lower-level code (eg in ccutil, the bottom level) must never need to
// know about the content of a higher-level directory.
// The following scheme will grant the easiest access to lower-level
// global members without creating a cyclic dependency:
// ccmain inherits wordrec, includes textord as a member
// wordrec inherits classify
// classify inherits ccstruct, includes dict as a member
// ccstruct inherits c_util, includes image as a member
// c_util inherits cc_util
// textord has a pointer to ccstruct, but doesn't own it.
// dict has a pointer to ccstruct, but doesn't own it.
//
// NOTE: that each level contains members that correspond to global
// data that is defined (and used) at that level, not necessarily where
// the type is defined so for instance:
// BOOL_VAR (textord_show_blobs, FALSE, "Display unsorted blobs");
// goes inside the Textord class, not the cc_util class.

class Tesseract : public Wordrec
{
public:
    Tesseract();
    ~Tesseract();

    void Clear();

    // Simple accessors.
    const FCOORD& reskew() const
    {
        return reskew_;
    }

    // Destroy any existing pix and return a pointer to the pointer.
    Pix** mutable_pix_binary()
    {
        Clear();
        return &pix_binary_;
    }

    Pix* pix_binary() const
    {
        return pix_binary_;
    }

    void SetBlackAndWhitelist();
    int SegmentPage(const STRING* input_file, IMAGE* image, BLOCK_LIST* blocks);
    int AutoPageSeg(int width, int height, int resolution, bool single_column, IMAGE* image, BLOCK_LIST* blocks, TO_BLOCK_LIST* to_blocks);

    //// control.h /////////////////////////////////////////////////////////

    //process words      //page structure      //progress monitor
    void recog_all_words(PAGE_RES *page_res, volatile ETEXT_DESC *monitor, TBOX *target_word_box=0L, inT16 dopasses=0);

    //recog one word         //word to do
    void classify_word_pass1(WERD_RES *word, ROW *row, BLOCK* block, BOOL8 cluster_adapt, CHAR_SAMPLES_LIST *char_clusters, CHAR_SAMPLE_LIST *chars_waiting);

    //recognize blobs      //blocks to check
    void recog_pseudo_word(BLOCK_LIST *block_list, TBOX &selection_box);

    // This method returns all the blobs in the specified blocks.
    // It's the caller's responsibility to destroy the returned list.
    // blocks to look at.
    C_BLOB_LIST* get_blobs_from_blocks(BLOCK_LIST* blocks);

    // This method can be used to perform word-level training using box files.
    // TODO: this can be modified to perform training in general case too.
    // File with boxes.     // Output file.         // Blocks to use.
    void train_word_level_with_boxes(const STRING& box_file, const STRING& out_file, BLOCK_LIST* blocks);
    void fix_rep_char(WERD_RES *word);

    //make double quotes  //choice to fix  //word to do //char choices
    void fix_quotes(WERD_CHOICE *choice,   WERD *word, BLOB_CHOICE_LIST_CLIST *blob_choices);
    ACCEPTABLE_WERD_TYPE acceptable_word_string(const char *s, const char *lengths);

    //recog one word     //word to do
    void match_word_pass2(WERD_RES *word, ROW *row, BLOCK* block, float x_height);

    //word to do
    void classify_word_pass2(WERD_RES *word, BLOCK* block, ROW *row);

    //recognize blobs       //block       //row of word  //word to recognize
    BOOL8 recog_interactive(BLOCK *block, ROW *row,      WERD *word);

    //crunch double hyphens  //choice to fix   //word to do //char choices
    void fix_hyphens(WERD_CHOICE *choice,      WERD *word,     BLOB_CHOICE_LIST_CLIST *blob_choices);

    // word to adapt to
    void set_word_fonts(WERD_RES *word, BLOB_CHOICE_LIST_CLIST *blob_choices);  // detailed results

    //good chars in word
    void font_recognition_pass(PAGE_RES_IT &page_res_it);

    //// output.h //////////////////////////////////////////////////////////

    //Tess output pass //send to api
    void output_pass(PAGE_RES_IT &page_res_it, BOOL8 write_to_shm, TBOX *target_word_box);

    //open .map & .unlv file
    FILE *open_outfile(const char *extension);

    //output a word    //full info                 //type of newline //override tilde crunch?    //send to api
    void write_results(PAGE_RES_IT &page_res_it,  char newline_type, BOOL8 force_eol,            BOOL8 write_to_shm);
    void set_unlv_suspects(WERD_RES *word);
    int get_rep_char(WERD_RES *word);  // what char is repeated?
    BOOL8 acceptable_number_string(const char *s,const char *lengths);
    inT16 count_alphanums(const WERD_CHOICE &word);
    inT16 count_alphas(const WERD_CHOICE &word);

    //// tessedit.h ////////////////////////////////////////////////////////
    void read_config_file(const char *filename, bool global_only);
    int init_tesseract(const char *arg0, const char *textbase, const char *language, char **configs, int configs_size, bool configs_global_only);

    int init_tesseract_lm(const char *arg0, const char *textbase, const char *language);

    // Initializes the tesseract classifier without loading language models.
    int init_tesseract_classifier(const char *arg0, const char *textbase, const char *language, char **configs, int configs_size, bool configs_global_only);

    void recognize_page(STRING& image_name);
    void end_tesseract();

    bool init_tesseract_lang_data(const char *arg0, const char *textbase, const char *language, char **configs, int configs_size, bool configs_global_only);

    //// pgedit.h //////////////////////////////////////////////////////////
    SVMenuNode *build_menu_new();
    void pgeditor_main(BLOCK_LIST *blocks);

    // action in image win
    void process_image_event(const SVEvent &event);

    // of serialised file                     // block list to add to
    void pgeditor_read_file(STRING &filename, BLOCK_LIST *blocks);

    // serialise
    void do_new_source();

    // UI command semantics     // which menu item?  // any prompt data
    BOOL8 process_cmd_win_event(inT32 cmd_event,     char *new_value);
    //// reject.h //////////////////////////////////////////////////////////

    const char *char_ambiguities(char c);

    //make rej map for wd //detailed results                                             //1st or 2nd?
    void make_reject_map(WERD_RES *word, BLOB_CHOICE_LIST_CLIST *blob_choices, ROW *row, inT16 pass);
    BOOL8 one_ell_conflict(WERD_RES *word_res, BOOL8 update_map);
    inT16 first_alphanum_index(const char *word, const char *word_lengths);
    inT16 first_alphanum_offset(const char *word, const char *word_lengths);
    inT16 alpha_count(const char *word, const char *word_lengths);
    BOOL8 word_contains_non_1_digit(const char *word, const char *word_lengths);
    void dont_allow_1Il(WERD_RES *word);

    //how many alphanums
    inT16 count_alphanums(WERD_RES *word);
    BOOL8 repeated_ch_string(const char *rep_ch_str, const char *lengths);
    void flip_0O(WERD_RES *word);
    BOOL8 non_0_digit(int unichar_id);
    BOOL8 non_O_upper(int unichar_id);
    BOOL8 repeated_nonalphanum_wd(WERD_RES *word, ROW *row);

    //Match a word
    void nn_match_word(WERD_RES *word, ROW *row);
    void nn_recover_rejects(WERD_RES *word, ROW *row);

    //test for ambiguity
    BOOL8 test_ambig_word(WERD_RES *word);

    //set done flag
    void set_done(WERD_RES *word, inT16 pass);
    inT16 safe_dict_word(const WERD_CHOICE  &word);
    void flip_hyphens(WERD_RES *word);

    //// adaptions.h ///////////////////////////////////////////////////////
    void adapt_to_good_ems(WERD_RES *word, CHAR_SAMPLES_LIST *char_clusters, CHAR_SAMPLE_LIST *chars_waiting);
    void adapt_to_good_samples(WERD_RES *word, CHAR_SAMPLES_LIST *char_clusters, CHAR_SAMPLE_LIST *chars_waiting);

    //should we adapt?
    BOOL8 word_adaptable(WERD_RES *word, uinT16 mode);
    void reject_suspect_ems(WERD_RES *word);
    void collect_ems_for_adaption(WERD_RES *word, CHAR_SAMPLES_LIST *char_clusters, CHAR_SAMPLE_LIST *chars_waiting);
    void collect_characters_for_adaption(WERD_RES *word, CHAR_SAMPLES_LIST *char_clusters, CHAR_SAMPLE_LIST *chars_waiting);
    void check_wait_list(CHAR_SAMPLE_LIST *chars_waiting, CHAR_SAMPLE *sample, CHAR_SAMPLES *best_cluster);
    void cluster_sample(CHAR_SAMPLE *sample, CHAR_SAMPLES_LIST *char_clusters, CHAR_SAMPLE_LIST *chars_waiting);
    void complete_clustering(CHAR_SAMPLES_LIST *char_clusters, CHAR_SAMPLE_LIST *chars_waiting);

    //// tfacepp.cpp ///////////////////////////////////////////////////////
    //recog one owrd
    WERD_CHOICE *recog_word_recursive(
            WERD *word,         //word to do
            DENORM *denorm,     //de-normaliser
            //matcher function
            POLY_MATCHER matcher,
            //tester function
            POLY_TESTER tester,
            //trainer function
            POLY_TESTER trainer,
            BOOL8 testing,      //true if answer driven
            //raw result
            WERD_CHOICE *&raw_choice,
            //list of blob lists
            BLOB_CHOICE_LIST_CLIST *blob_choices,
            WERD *&outword      //bln word output
            );

    WERD_CHOICE *recog_word(                           //recog one owrd
                                                       WERD *word,                //word to do
                                                       DENORM *denorm,            //de-normaliser
                                                       POLY_MATCHER matcher,      //matcher function
                                                       POLY_TESTER tester,        //tester function
                                                       POLY_TESTER trainer,       //trainer function
                                                       BOOL8 testing,             //true if answer driven
                                                       WERD_CHOICE *&raw_choice,  //raw result
                                                       //list of blob lists
                                                       BLOB_CHOICE_LIST_CLIST *blob_choices,
                                                       WERD *&outword             //bln word output
                                                       );

    WERD_CHOICE *split_and_recog_word(                    //recog one owrd
                                                          WERD *word,         //word to do
                                                          DENORM *denorm,     //de-normaliser
                                                          //matcher function
                                                          POLY_MATCHER matcher,
                                                          //tester function
                                                          POLY_TESTER tester,
                                                          //trainer function
                                                          POLY_TESTER trainer,
                                                          BOOL8 testing,      //true if answer driven
                                                          //raw result
                                                          WERD_CHOICE *&raw_choice,
                                                          //list of blob lists
                                                          BLOB_CHOICE_LIST_CLIST *blob_choices,
                                                          WERD *&outword      //bln word output
                                                          );
    //// fixspace.cpp ///////////////////////////////////////////////////////
    BOOL8 digit_or_numeric_punct(WERD_RES *word, int char_position);
    inT16 eval_word_spacing(WERD_RES_LIST &word_res_list);
    void match_current_words(WERD_RES_LIST &words, ROW *row, BLOCK* block);
    inT16 fp_eval_word_spacing(WERD_RES_LIST &word_res_list);
    void fix_noisy_space_list(WERD_RES_LIST &best_perm, ROW *row, BLOCK* block);

    //space explorer
    void fix_fuzzy_space_list(WERD_RES_LIST &best_perm, ROW *row, BLOCK* block);
    void fix_sp_fp_word(WERD_RES_IT &word_res_it, ROW *row, BLOCK* block);

    //find fuzzy words
    void fix_fuzzy_spaces(volatile ETEXT_DESC *monitor,  //progress monitor
                          inT32 word_count,              //count of words in doc
                          PAGE_RES *page_res);

    //// docqual.cpp ////////////////////////////////////////////////////////
    GARBAGE_LEVEL garbage_word(WERD_RES *word, BOOL8 ok_dict_word);
    BOOL8 potential_word_crunch(WERD_RES *word, GARBAGE_LEVEL garbage_level, BOOL8 ok_dict_word);
    void tilde_crunch(PAGE_RES_IT &page_res_it);

    //unreject potential
    void unrej_good_quality_words(PAGE_RES_IT &page_res_it);

    //reject big chunks
    void doc_and_block_rejection(PAGE_RES_IT &page_res_it, BOOL8 good_quality_doc);
    void quality_based_rejection(PAGE_RES_IT &page_res_it, BOOL8 good_quality_doc);
    void convert_bad_unlv_chs(WERD_RES *word_res);
    void merge_tess_fails(WERD_RES *word_res);
    void tilde_delete(PAGE_RES_IT &page_res_it);
    void insert_rej_cblobs(WERD_RES *word);
    //// pagewalk.cpp ///////////////////////////////////////////////////////
    void process_selected_words(
            BLOCK_LIST * block_list, //blocks to check
            //function to call
            TBOX & selection_box,
            BOOL8 (Tesseract::*word_processor)(BLOCK *, ROW *, WERD *));
    //// tessbox.cpp ///////////////////////////////////////////////////////
    //test acceptability   //after context
    void tess_add_doc_word(WERD_CHOICE *word_choice);

    void tess_adapter(//adapt to word
                      WERD *word,              //bln word
                      DENORM *denorm,          //de-normalise
                      const WERD_CHOICE& choice,      //string for word
                      const WERD_CHOICE& raw_choice,  //before context
                      const char *rejmap       //reject map
                      );

    WERD_CHOICE *test_segment_pass2(//recog one word
                                    WERD *word,             //bln word to do
                                    DENORM *denorm,         //de-normaliser
                                    POLY_MATCHER matcher,   //matcher function
                                    POLY_TESTER tester,     //tester function
                                    //raw result
                                    WERD_CHOICE *&raw_choice,
                                    //list of blob lists
                                    BLOB_CHOICE_LIST_CLIST *blob_choices,
                                    WERD *&outword          //bln word output
                                    );

    WERD_CHOICE *tess_segment_pass1(//recog one word
                                    WERD *word,             //bln word to do
                                    DENORM *denorm,         //de-normaliser
                                    POLY_MATCHER matcher,   //matcher function
                                    //raw result
                                    WERD_CHOICE *&raw_choice,
                                    //list of blob lists
                                    BLOB_CHOICE_LIST_CLIST *blob_choices,
                                    WERD *&outword             //bln word output
                                    );

    WERD_CHOICE *tess_segment_pass2(//recog one word
                                    WERD *word,             //bln word to do
                                    DENORM *denorm,         //de-normaliser
                                    POLY_MATCHER matcher,   //matcher function
                                    //raw result
                                    WERD_CHOICE *&raw_choice,
                                    //list of blob lists
                                    BLOB_CHOICE_LIST_CLIST *blob_choices,
                                    WERD *&outword          //bln word output
                                    );

    WERD_CHOICE *correct_segment_pass2(//recog one word
                                       WERD *word,            //bln word to do
                                       DENORM *denorm,        //de-normaliser
                                       POLY_MATCHER matcher,  //matcher function
                                       POLY_TESTER tester,    //tester function
                                       //raw result
                                       WERD_CHOICE *&raw_choice,
                                       //list of blob lists
                                       BLOB_CHOICE_LIST_CLIST *blob_choices,
                                       WERD *&outword         //bln word output
                                       );

    void tess_default_matcher(//call tess
                              PBLOB *pblob,               //previous blob
                              PBLOB *blob,                //blob to match
                              PBLOB *nblob,               //next blob
                              WERD *word,                 //word it came from
                              DENORM *denorm,             //de-normaliser
                              BLOB_CHOICE_LIST *ratings,  //list of results
                              const char* script
                              );

    void tess_bn_matcher(//call tess
                         PBLOB *pblob,              //previous blob
                         PBLOB *blob,               //blob to match
                         PBLOB *nblob,              //next blob
                         WERD *word,                //word it came from
                         DENORM *denorm,            //de-normaliser
                         BLOB_CHOICE_LIST *ratings  //list of results
                         );

    void tess_cn_matcher(//call tess
                         PBLOB *pblob,              //previous blob
                         PBLOB *blob,               //blob to match
                         PBLOB *nblob,              //next blob
                         WERD *word,                //word it came from
                         DENORM *denorm,            //de-normaliser
                         BLOB_CHOICE_LIST *ratings,  //list of results
                         // Sorted array of CP_RESULT_STRUCT from class pruner.
                         CLASS_PRUNER_RESULTS cpresults
                         );

    BOOL8 tess_adaptable_word(//test adaptability
                              WERD *word,                //word to test
                              WERD_CHOICE *word_choice,  //after context
                              WERD_CHOICE *raw_choice    //before context
                              );

    BOOL8 tess_acceptable_word(//test acceptability
                               WERD_CHOICE *word_choice,  //after context
                               WERD_CHOICE *raw_choice    //before context
                               );

    //// applybox.cpp //////////////////////////////////////////////////////
    void apply_box_testing(BLOCK_LIST *block_list);

    //real blocks
    void apply_boxes(const STRING& fname, BLOCK_LIST *block_list);

    // converts an array of boxes to a block list
    int Boxes2BlockList(int box_cnt, TBOX *boxes, BLOCK_LIST *block_list, bool right2left);

    //// blobcmp.cpp ///////////////////////////////////////////////////////
    float compare_tess_blobs(TBLOB *blob1, TEXTROW *row1, TBLOB *blob2, TEXTROW *row2);
    //// paircmp.cpp ///////////////////////////////////////////////////////
    float compare_bln_blobs(//match 2 blobs
                            PBLOB *blob1,  //first blob
                            DENORM *denorm1,
                            PBLOB *blob2,  //other blob
                            DENORM *denorm2);

    float compare_blobs(//match 2 blobs
                        PBLOB *blob1,  //first blob
                        ROW *row1,     //row it came from
                        PBLOB *blob2,  //other blob
                        ROW *row2);

    BOOL8 compare_blob_pairs(//blob processor
                             BLOCK *,
                             ROW *row,    //row it came from
                             WERD *,
                             PBLOB *blob  //blob to compare
                             );

    //// fixxht.cpp ///////////////////////////////////////////////////////
    void check_block_occ(WERD_RES *word_res);

    //// Data members ///////////////////////////////////////////////////////
    BOOL_VAR_H(tessedit_resegment_from_boxes, false, "Take segmentation and labeling from box file");
    BOOL_VAR_H(tessedit_train_from_boxes, false, "Generate training data from boxed chars");
    BOOL_VAR_H(tessedit_dump_pageseg_images, false, "Dump itermediate images made during page segmentation");
    INT_VAR_H(tessedit_pageseg_mode, 2, "Page seg mode: 0=auto, 1=col, 2=block, 3=line, 4=word, 6=char(Values from PageSegMode enum in baseapi.h)");
    INT_VAR_H(tessedit_accuracyvspeed, 0, "Accuracy V Speed tradeoff: 0 fastest, 100 most accurate(Values from AccuracyVSpeed enum in baseapi.h)");
    BOOL_VAR_H(tessedit_train_from_boxes_word_level, false, "Generate training data from boxed chars at word level.");
    STRING_VAR_H(tessedit_char_blacklist, "", "Blacklist of chars not to recognize");
    STRING_VAR_H(tessedit_char_whitelist, "", "Whitelist of chars to recognize");
    BOOL_VAR_H(global_tessedit_ambigs_training, false, "Perform training for ambiguities");
    //// ambigsrecog.cpp /////////////////////////////////////////////////////////
    FILE *init_ambigs_training(const STRING &fname);
    void ambigs_training_segmented(const STRING &fname, PAGE_RES *page_res, volatile ETEXT_DESC *monitor, FILE *output_file);
    void ambigs_classify_and_output(PAGE_RES_IT *page_res_it, const char *label, FILE *output_file);
private:
    Pix* pix_binary_;
    FCOORD deskew_;
    FCOORD reskew_;
    bool hindi_image_;
};
/////////////////////////////////////////////////////////////////tesseractclass////////////////////////////////////////

/////////////////////////////////////////////////////////////////ocrclass////////////////////////////////////////
/*
void classify_word_pass1(                 //recog one word
                         WERD_RES *word,  //word to do
                         ROW *row,
                         BOOL8 cluster_adapt,
                         CHAR_SAMPLES_LIST *char_clusters,
                         CHAR_SAMPLE_LIST *chars_waiting);
*/
//word to do
void classify_word_pass2(WERD_RES *word, ROW *row);
/**
 * recognize one word
 * @param word word to do
 */
void match_word_pass2(WERD_RES *word, ROW *row, float x_height);
/**
 * crunch double hyphens
 * @param choice string to fix
 * @param word word to do
 * @param blob_choices char choices
 */
void fix_hyphens(WERD_CHOICE *choice, WERD *word, BLOB_CHOICE_LIST_CLIST *blob_choices);

/**
 * combine 2 blobs
 * @param blob1 dest blob
 * @param blob2 source blob
 */
void merge_blobs(PBLOB *blob1, PBLOB *blob2);

/** dump chars in word */
void choice_dump_tester(
        PBLOB *,                   ///< blob
        DENORM *,                  ///< de-normaliser
        BOOL8 correct,             ///< ly segmented
        char *text,                ///< correct text
        inT32 count,               ///< chars in text
        BLOB_CHOICE_LIST *ratings  ///< list of results
        );

WERD *make_bln_copy(WERD *src_word, ROW *row, BLOCK* block, float x_height, DENORM *denorm);

BOOL8 check_debug_pt(WERD_RES *word, int location);

/** good chars in word */
void add_in_one_row(
        ROW_RES *row,  ///< current row
        STATS *fonts,  ///< font stats
        inT8 *italic,  ///< output count
        inT8 *bold     ///< output count
        );

/** good chars in word */
void find_modal_font(
        STATS *fonts,     ///< font stats
        inT8 *font_out,   ///< output font
        inT8 *font_count  ///< output count
        );
/////////////////////////////////////////////////////////////////control////////////////////////////////////////

/////////////////////////////////////////////////////////////////boxread////////////////////////////////////////
// Size of buffer used to read a line from a box file.
const int kBoxReadBufSize = 256;

// read_next_box factors out the code to interpret a line of a box
// file so that applybox and unicharset_extractor interpret the same way.
// This function returns the next valid box file utf8 string and coords
// and returns true, or false on eof (and closes the file).
// If ignores the uft8 file signature, checks for valid utf-8 and allows
// space or tab between fields.
// utf8_str must be at least kBoxReadBufSize in length.
// If there are page numbers in the file, it reads them all.
bool read_next_box(FILE* box_file, char* utf8_str,
                   int* x_min, int* y_min, int* x_max, int* y_max);
// As read_next_box above, but get a specific page number. (0-based)
// Use -1 to read any page number. Files without page number all
// read as if they are page 0.
bool read_next_box(int page, FILE* box_file, char* utf8_str,
                   int* x_min, int* y_min, int* x_max, int* y_max);
/////////////////////////////////////////////////////////////////boxread////////////////////////////////////////

/////////////////////////////////////////////////////////////////applybox////////////////////////////////////////
extern BOOL_VAR_H (applybox_rebalance, TRUE, "Drop dead");
extern INT_VAR_H (applybox_debug, 0, "Debug level");
extern INT_VAR_H (applybox_page, 0, "Page number to apply boxes from");
extern STRING_VAR_H (applybox_test_exclusions, "|", "Chars ignored for testing");
extern double_VAR_H (applybox_error_band, 0.15, "Err band as fract of xht");
extern STRING_VAR_H(exposure_pattern, "exp", "Exposure value follows this pattern in the image"
                    " filename. The name of the image files are expected" " to be in the form [lang].[fontname].exp[num].tif");

static const int kMinFragmentOutlineArea = 10;

                                                     //real blocks
void apply_boxes(const STRING& filename, BLOCK_LIST *block_list);

                     //real blocks           //from boxfile
ROW *find_row_of_box(BLOCK_LIST *block_list, const TBOX &box, inT16 &block_id, inT16 &row_id_to_process);

inT16 resegment_box(ROW *row, TBOX &box, UNICHAR_ID uch_id, inT16 block_id, inT16 row_id, inT16 boxfile_lineno,
                    inT16 boxfile_charno, inT16 *tgt_char_counts, bool learn_char_fragments, bool learning);

                        //real blocks
void tidy_up(BLOCK_LIST *block_list, inT16 &ok_char_count, inT16 &ok_row_count, inT16 &unlabelled_words,
             inT16 *tgt_char_counts, inT16 &rebalance_count, UNICHAR_ID *min_uch_id, inT16 &min_samples,
             inT16 &final_labelled_blob_count, bool learn_character_fragments, bool learning);

void report_failed_box(inT16 boxfile_lineno, inT16 boxfile_charno, TBOX box, const char *box_ch, const char *err_msg);

void apply_box_training(const STRING& filename, BLOCK_LIST *block_list);
/////////////////////////////////////////////////////////////////applybox////////////////////////////////////////

/////////////////////////////////////////////////////////////////gradechop////////////////////////////////////////
/*----------------------------------------------------------------------
              T y p e s
----------------------------------------------------------------------*/
typedef inT16 BOUNDS_RECT[4];

/*----------------------------------------------------------------------
              M a c r o s
----------------------------------------------------------------------*/
/**********************************************************************
 * partial_split_priority
 *
 * Assign a priority to this split based on the features that it has.
 * Grade it according to the different rating schemes and return the
 * value of its goodness.
 **********************************************************************/

#define partial_split_priority(split)  \
(grade_split_length   (split) +      \
    grade_sharpness      (split))       \


/**********************************************************************
 * split_bounds_overlap
 *
 * Check to see if this split might overlap with this outline.  Return
 * TRUE if there is a positive overlap in the bounding boxes of the two.
 **********************************************************************/

#define split_bounds_overlap(split,outline)  \
(outline->topleft.x  <= MAX (split->point1->pos.x,split->point2->pos.x) && \
    outline->botright.x >= MIN (split->point1->pos.x,split->point2->pos.x) && \
    outline->botright.y <= MAX (split->point1->pos.y,split->point2->pos.y) && \
    outline->topleft.y  >= MIN (split->point1->pos.y,split->point2->pos.y))

/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
PRIORITY full_split_priority(SPLIT *split, inT16 xmin, inT16 xmax);

PRIORITY grade_center_of_blob(register BOUNDS_RECT rect);

PRIORITY grade_overlap(register BOUNDS_RECT rect);

PRIORITY grade_split_length(register SPLIT *split);

PRIORITY grade_sharpness(register SPLIT *split);

PRIORITY grade_width_change(register BOUNDS_RECT rect);

void set_outline_bounds(register EDGEPT *point1,
                        register EDGEPT *point2,
                        BOUNDS_RECT rect);
/////////////////////////////////////////////////////////////////gradechop////////////////////////////////////////

/////////////////////////////////////////////////////////////////findseam////////////////////////////////////////
typedef HEAP *SEAM_QUEUE;
typedef ARRAY SEAM_PILE;
/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
void junk_worst_seam(SEAM_QUEUE seams, SEAM *new_seam, float new_priority);

void choose_best_seam(SEAM_QUEUE seam_queue,
                      SEAM_PILE *seam_pile,
                      SPLIT *split,
                      PRIORITY priority,
                      SEAM **seam_result,
                      TBLOB *blob);

void combine_seam(SEAM_QUEUE seam_queue, SEAM_PILE seam_pile, SEAM *seam);

inT16 constrained_split(SPLIT *split, TBLOB *blob);

void delete_seam_pile(SEAM_PILE seam_pile);

SEAM *pick_good_seam(TBLOB *blob);

PRIORITY seam_priority(SEAM *seam, inT16 xmin, inT16 xmax);

void try_point_pairs (EDGEPT * points[MAX_NUM_POINTS],
inT16 num_points,
SEAM_QUEUE seam_queue,
SEAM_PILE * seam_pile, SEAM ** seam, TBLOB * blob);

void try_vertical_splits (EDGEPT * points[MAX_NUM_POINTS],
inT16 num_points,
SEAM_QUEUE seam_queue,
SEAM_PILE * seam_pile, SEAM ** seam, TBLOB * blob);
/////////////////////////////////////////////////////////////////findseam////////////////////////////////////////

/////////////////////////////////////////////////////////////////makechop////////////////////////////////////////
/*----------------------------------------------------------------------
      M a c r o s
---------------------------------------------------------------------*/
/**********************************************************************
 * is_split_outline
 *
 * Check to see if both sides of the split fall within the bounding
 * box of this outline.
 **********************************************************************/

#define is_split_outline(outline,split)          \
(point_in_outline (split->point1, outline) &&  \
    point_in_outline (split->point2, outline))    \


/*----------------------------------------------------------------------
        Public Function Prototypes
----------------------------------------------------------------------*/
void apply_seam(TBLOB *blob, TBLOB *other_blob, SEAM *seam);

void divide_blobs(TBLOB *blob, TBLOB *other_blob, inT32 location);

void form_two_blobs(TBLOB *blob, TBLOB *other_blob, inT32 location);

void make_double_split(TBLOB *blob, TBLOB *other_blob, SEAM *seam);

void make_single_split(TESSLINE *outlines, SPLIT *split);

void make_split_blobs(TBLOB *blob, TBLOB *other_blob, SEAM *seam);

void make_triple_split(TBLOB *blob, TBLOB *other_blob, SEAM *seam);

void undo_seam(TBLOB *blob, TBLOB *other_blob, SEAM *seam);

void undo_single_split(TBLOB *blob, SPLIT *split);
/////////////////////////////////////////////////////////////////makechop////////////////////////////////////////

/////////////////////////////////////////////////////////////////chopper////////////////////////////////////////
/*---------------------------------------------------------------------------
          Variables
---------------------------------------------------------------------------*/

extern BOOL_VAR_H (fragments_guide_chopper, FALSE,
                   "Use information from fragments to guide chopping process");


/*----------------------------------------------------------------------
              F u n c t i o n s
----------------------------------------------------------------------*/
void preserve_outline(EDGEPT *start);

void preserve_outline_tree(TESSLINE *srcline);

EDGEPT *restore_outline(EDGEPT *start);

void restore_outline_tree(TESSLINE *srcline);

SEAM *attempt_blob_chop(TWERD *word, inT32 blob_number, SEAMS seam_list);

int any_shared_split_points(SEAMS seam_list, SEAM *seam);

int check_blob(TBLOB *blob);

inT16 check_seam_order(TBLOB *blob, SEAM *seam);

SEAMS start_seam_list(TBLOB *blobs);

inT16 total_containment(TBLOB *blob1, TBLOB *blob2);
/////////////////////////////////////////////////////////////////chopper////////////////////////////////////////

/////////////////////////////////////////////////////////////////qrsequence////////////////////////////////////////
class QRSequenceGenerator {
 public:
  // Object is initalized with the size of the output range.
  explicit QRSequenceGenerator(int N) : N_(N), next_num_(0) {
    num_bits_ = ceil(log(static_cast<double>(N)) / log(2.0));
  }

  // Main worker method that retrieves the next number in the sequence.
  // Returns kInvalidVal if called more than N times after object initialization
  int GetVal() {
    const int kInvalidVal = -1;
    const int kMaxNaturalNumberValue = 1 << num_bits_;
    if (next_num_ >= kMaxNaturalNumberValue)
      return kInvalidVal;
    int n = next_num_;

    while (next_num_ < kMaxNaturalNumberValue) {
      n = GetBinaryReversedInteger(next_num_++);
      if (n < N_) break;
    }
    return (next_num_ > kMaxNaturalNumberValue) ? kInvalidVal : n;
  }

 protected:
  // Outputs the integer formed by reversing the bits of the input integer. Only
  // the lowest num_bits_ bits of the input integer are reversed.
  int GetBinaryReversedInteger(int in_val) const {
    int bit_pos = num_bits_;
    int out_val = 0;
    while(bit_pos--) {
      // Set the value of the last bit.
      out_val |= (in_val & 0x1);
      if (bit_pos > 0) {
        // Left-shift output value to prepare for storing the next bit.
        out_val <<= 1;
      }
      // Right-shift input value to prepare for retrieving the next bit.
      in_val >>= 1;
    }
    return out_val;
  }
  int N_;
  // Next number to be considered for reversal and output.
  int next_num_;
  // number of bits required to represent the numbers of the sequence
  int num_bits_;
};
/////////////////////////////////////////////////////////////////qrsequence////////////////////////////////////////

/////////////////////////////////////////////////////////////////osdetect////////////////////////////////////////
class TO_BLOCK_LIST;
class BLOBNBOX;
class BLOB_CHOICE_LIST;

namespace tesseract {
class Tesseract;
}

// Max number of scripts in ICU + "NULL" + Japanese and Korean + Fraktur
const int kMaxNumberOfScripts = 116 + 1 + 2 + 1;

struct OSBestResult {
  int orientation;
  const char* script;
  float sconfidence;
  float oconfidence;
};

struct OSResults {
  OSResults() {
    for (int i = 0; i < 4; ++i) {
      for (int j = 0; j < kMaxNumberOfScripts; ++j)
        scripts_na[i][j] = 0;
      orientations[i] = 0;
    }
  }
  float orientations[4];
  float scripts_na[4][kMaxNumberOfScripts];

  UNICHARSET* unicharset;
  OSBestResult best_result;
};

class OrientationDetector {
 public:
  OrientationDetector(OSResults*);
  bool detect_blob(BLOB_CHOICE_LIST* scores);
  void update_best_orientation();
  int get_orientation();
 private:
  OSResults* osr_;
};

class ScriptDetector {
 public:
  ScriptDetector(OSResults*, Tesseract* tess);
  void detect_blob(BLOB_CHOICE_LIST* scores);
  void update_best_script(int);
  void get_script() ;
  bool must_stop(int orientation);
 private:
  OSResults* osr_;
  static const char* korean_script_;
  static const char* japanese_script_;
  static const char* fraktur_script_;
  int korean_id_;
  int japanese_id_;
  int katakana_id_;
  int hiragana_id_;
  int han_id_;
  int hangul_id_;
  int latin_id_;
  int fraktur_id_;
  Tesseract* tess_;
};

bool orientation_and_script_detection(STRING& filename,
                                      OSResults*,
                                      Tesseract*);

bool os_detect(TO_BLOCK_LIST* port_blocks,
               OSResults* osr,
               Tesseract* tess);

bool os_detect_blob(BLOBNBOX* bbox, OrientationDetector* o,
                    ScriptDetector* s, OSResults*,
                    Tesseract* tess);
/////////////////////////////////////////////////////////////////osdetect////////////////////////////////////////

/////////////////////////////////////////////////////////////////conversion////////////////////////////////////////
void convert_to_word_choice(const A_CHOICE *a_choice,
                            const UNICHARSET &current_unicharset,
                            WERD_CHOICE *word_choice);

WERD_CHOICE *get_best_delete_other(
    const UNICHARSET &current_unicharset,
    WERD_CHOICE *choice,
    A_CHOICE *a_choice);

CHOICES_LIST convert_to_choices_list(
    const BLOB_CHOICE_LIST_VECTOR &char_choices,
    const UNICHARSET &current_unicharset);
/////////////////////////////////////////////////////////////////conversion////////////////////////////////////////

/////////////////////////////////////////////////////////////////detlinefit////////////////////////////////////////
class DetLineFit {
 public:
  DetLineFit();
  ~DetLineFit();

  // Delete all Added points.
  void Clear();

  // Add a new point. Takes a copy - the pt doesn't need to stay in scope.
  // Add must be called on points in sequence along the line.
  void Add(const ICOORD& pt);

  // Fit a line to the points, returning the fitted line as a pair of
  // points, and the upper quartile error.
  double Fit(ICOORD* pt1, ICOORD* pt2);

 private:
  double ComputeErrors(const ICOORD start, const ICOORD end, int* distances);

  ICOORDELT_LIST pt_list_;  // All the added points.
};
/////////////////////////////////////////////////////////////////detlinefit////////////////////////////////////////

/////////////////////////////////////////////////////////////////colpartitionset////////////////////////////////////////
class WorkingPartSet_LIST;
class ColSegment_LIST;
class ColPartitionSet;
typedef GenericVector<ColPartitionSet*> PartSetVector;

// ColPartitionSet is a class that holds a list of ColPartitions.
// Its main use is in holding a candidate partitioning of the width of the
// image into columns, where each member ColPartition is a single column.
// ColPartitionSets are used in building the column layout of a page.
class ColPartitionSet : public ELIST_LINK {
 public:
  ColPartitionSet() {
  }
  explicit ColPartitionSet(ColPartition_LIST* partitions);
  explicit ColPartitionSet(ColPartition* partition);

  ~ColPartitionSet();

  // Simple accessors.
  const TBOX& bounding_box() const {
    return bounding_box_;
  }
  bool Empty() {
    return parts_.empty();
  }
  int ColumnCount() {
    return parts_.length();
  }

  // Return an element of the parts_ list from its index.
  ColPartition* GetColumnByIndex(int index);

  // Return the ColPartition that contains the given coords, if any, else NULL.
  ColPartition* ColumnContaining(int x, int y);

  // Return the bounding boxes of columns at the given y-range
  void GetColumnBoxes(int y_bottom, int y_top, ColSegment_LIST *segments);

  // Move the parts to the output list, giving up ownership.
  void ReturnParts(ColPartition_LIST* parts);

  // Merge any significantly overlapping partitions within the this and other,
  // and unique the boxes so that no two partitions use the same box.
  // Return true if any changes were made to either set.
  bool MergeOverlaps(ColPartitionSet* other, WidthCallback* cb);

  // Attempt to improve this by adding partitions or expanding partitions.
  void ImproveColumnCandidate(WidthCallback* cb, PartSetVector* src_sets);

  // If this set is good enough to represent a new partitioning into columns,
  // add it to the vector of sets, otherwise delete it.
  void AddToColumnSetsIfUnique(PartSetVector* column_sets, WidthCallback* cb);

  // Return true if the partitions in other are all compatible with the columns
  // in this.
  bool CompatibleColumns(bool debug, ColPartitionSet* other, WidthCallback* cb);

  // Return true if this ColPartitionSet makes a legal column candidate by
  // having legal individual partitions and non-overlapping adjacent pairs.
  bool LegalColumnCandidate();

  // Return a copy of this. If good_only will only copy the Good ColPartitions.
  ColPartitionSet* Copy(bool good_only);

  // Display the edges of the columns at the given y coords.
  void DisplayColumnEdges(int y_bottom, int y_top, ScrollView* win);

  // Return the PolyBlockType that best explains the columns overlapped
  // by the given coords(left,right,y), with the given margins.
  // Also return the first and last column index touched by the coords and
  // the leftmost and rightmost spanned columns.
  // Column indices are 2n + 1 for real colums (0 based) and even values
  // represent the gaps in between columns, with 0 being left of the leftmost.
  PolyBlockType SpanningType(BlobRegionType type, int left, int right, int y,
                             int left_margin, int right_margin,
                             int* first_col, int* last_col,
                             int* first_spanned_col, int* last_spanned_col);

  // The column_set has changed. Close down all in-progress WorkingPartSets in
  // columns that do not match and start new ones for the new columns in this.
  // As ColPartitions are turned into BLOCKs, the used ones are put in
  // used_parts, as they still need to be referenced in the grid.
  void ChangeWorkColumns(const ICOORD& bleft, const ICOORD& tright,
                         int resolution, ColPartition_LIST* used_parts,
                         WorkingPartSet_LIST* working_set);

  // Accumulate the widths and gaps into the given variables.
  void AccumulateColumnWidthsAndGaps(int* total_width, int* width_samples,
                                     int* total_gap, int* gap_samples);

  // Provide debug output for this ColPartitionSet and all the ColPartitions.
  void Print();

 private:
  // Add the given partition to the list in the appropriate place.
  void AddPartition(ColPartition* new_part, ColPartition_IT* it);

  // Compute the coverage and good column count.
  void ComputeCoverage();

  // The partitions in this column candidate.
  ColPartition_LIST parts_;
  // The number of partitions that have a frequent column width.
  int good_column_count_;
  // Total width of all the ColPartitions.
  int total_coverage_;
  // Bounding box of all partitions in the set.
  TBOX bounding_box_;
};

ELISTIZEH(ColPartitionSet)
/////////////////////////////////////////////////////////////////colpartitionset////////////////////////////////////////

/////////////////////////////////////////////////////////////////tablefind////////////////////////////////////////
// Possible types for a column segment.
enum ColSegType {
  COL_UNKNOWN,
  COL_TEXT,
  COL_TABLE,
  COL_MIXED,
  COL_COUNT
};

// ColSegment holds rectangular blocks that represent segmentation of a page
// into regions containing single column text/table.
class ColSegment;
ELISTIZEH(ColSegment)
CLISTIZEH(ColSegment)

class ColSegment : public ELIST_LINK {
 public:
  ColSegment() : num_table_cells_(0), num_text_cells_(0),
                 type_(COL_UNKNOWN) {
  }
  ~ColSegment() { }

  // Simple accessors and mutators
  const TBOX& bounding_box() const {
    return bounding_box_;
  }

  void set_top(int y) {
    bounding_box_.set_top(y);
  }

  void set_bottom(int y) {
    bounding_box_.set_bottom(y);
  }

  void set_left(int x) {
    bounding_box_.set_left(x);
  }

  void set_right(int x) {
    bounding_box_.set_right(x);
  }

  void set_bounding_box(const TBOX& other) {
    bounding_box_ = other;
  }

  int get_num_table_cells() {
    return num_table_cells_;
  }

  // set the number of table colpartitions covered by the bounding_box_
  void set_num_table_cells(int n) {
    num_table_cells_ = n;
  }

  int get_num_text_cells() {
    return num_text_cells_;
  }

  // set the number of text colpartitions covered by the bounding_box_
  void set_num_text_cells(int n) {
    num_text_cells_ = n;
  }

  ColSegType type() {
    return type_;
  }

  // set the type of the block based on the ratio of table to text
  // colpartitions covered by it.
  void set_type();

  // Provides a color for BBGrid to draw the rectangle.
  ScrollView::Color  BoxColor() const;

  // Insert a rectangle into bounding_box_
  void InsertBox(const TBOX& other);

 private:
  // Initializes the bulk of the members to default values.
  void Init() {
  }

  TBOX bounding_box_;                    // bounding box
  int num_table_cells_;
  int num_text_cells_;
  ColSegType type_;
};

// Typedef BBGrid of ColSegments
typedef BBGrid<ColSegment,
               ColSegment_CLIST,
               ColSegment_C_IT> ColSegmentGrid;
/////////////////////////////////////////////////////////////////tablefind////////////////////////////////////////

/////////////////////////////////////////////////////////////////strokewidth///////////////////////////////////
/**
 * The StrokeWidth class holds all the normal and large blobs.
 * It is used to find good large blobs and move them to the normal blobs
 * by virtue of having a reasonable strokewidth compatible neighbour.
 */
class StrokeWidth : public BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> {
 public:
  StrokeWidth(int gridsize, const ICOORD& bleft, const ICOORD& tright);
  virtual ~StrokeWidth();

  // Puts the block blobs (normal and large) into the grid.
  void InsertBlobs(TO_BLOCK* block, TabFind* line_grid);

  // Moves the large blobs that have good stroke-width neighbours to the normal
  // blobs list.
  void MoveGoodLargeBlobs(int resolution, TO_BLOCK* block);

  // Displays the blobs green or red according to whether they are good or not.
  ScrollView* DisplayGoodBlobs(const char* window_name, ScrollView* tab_win);

  // Handles a click event in a display window.
  virtual void HandleClick(int x, int y);

 private:
  // Returns true if there is at least one side neighbour that has a similar
  // stroke width.
  bool GoodTextBlob(BLOBNBOX* blob);
};
/////////////////////////////////////////////////////////////////strokewidth///////////////////////////////////

/////////////////////////////////////////////////////////////////colfind////////////////////////////////////////
class ScrollView;
class TO_BLOCK;
class STATS;
class BLOCK_LIST;
struct Boxa;
struct Pixa;

class StrokeWidth;
class LineSpacing;
class TempColumn_LIST;
class ColSegment_LIST;
class ColumnGroup_LIST;
class ColPartitionSet;
class ColPartitionSet_LIST;

// The ColumnFinder class finds columns in the grid.
class ColumnFinder : public TabFind {
 public:
  // Gridsize is an estimate of the text size in the image. A suitable value
  // is in TO_BLOCK::line_size after find_components has been used to make
  // the blobs.
  // bleft and tright are the bounds of the image (rectangle) being processed.
  // vlines is a (possibly empty) list of TabVector and vertical_x and y are
  // the sum logical vertical vector produced by LineFinder::FindVerticalLines.
  ColumnFinder(int gridsize, const ICOORD& bleft, const ICOORD& tright,
               TabVector_LIST* vlines, TabVector_LIST* hlines,
               int vertical_x, int vertical_y);
  virtual ~ColumnFinder();

  // Finds the text and image blocks, returning them in the blocks and to_blocks
  // lists. (Each TO_BLOCK points to the basic BLOCK and adds more information.)
  // If boxa and pixa are not NULL, they are assumed to be the output of
  // ImageFinder::FindImages, and are used to generate image blocks.
  // The input boxa and pixa are destroyed.
  // Imageheight and resolution should be the pixel height and resolution in
  // pixels per inch of the original image.
  // The input block is the result of a call to find_components, and contains
  // the blobs found in the image. These blobs will be removed and placed
  // in the output blocks, while unused ones will be deleted.
  // If single_column is true, the input is treated as single column, but
  // it is still divided into blocks of equal line spacing/text size.
  // Returns -1 if the user requested retry with more debug info.
  int FindBlocks(int imageheight, int resolution, bool single_column,
                 TO_BLOCK* block, Boxa* boxa, Pixa* pixa,
                 BLOCK_LIST* blocks, TO_BLOCK_LIST* to_blocks);

 private:
  // Displays the blob and block bounding boxes in a window called Blocks.
  void DisplayBlocks(BLOCK_LIST* blocks);
  // Displays the column edges at each grid y coordinate defined by
  // best_columns_.
  void DisplayColumnBounds(PartSetVector* sets);

  // Converts the arrays of Box/Pix to a list of C_OUTLINE, and then to blobs.
  // The output is a list of C_BLOBs for the images, but the C_OUTLINEs
  // contain no data.
  void ExtractImageBlobs(int image_height, Boxa* boxa, Pixa* pixa);

  ////// Functions involved in making the initial ColPartitions. /////

  // Creates the initial ColPartitions, and puts them in a ColPartitionSet
  // for each grid y coordinate, storing the ColPartitionSets in part_sets_.
  // After creating the ColPartitonSets, attempts to merge them where they
  // overlap and unique the BLOBNBOXes within.
  // The return value is the number of ColPartitionSets made.
  int MakeColumnPartitions();
  // Partition the BLOBNBOXES horizontally at the given grid y, creating a
  // ColPartitionSet which is returned. NULL is returned if there are no
  // BLOBNBOXES at the given grid y.
  ColPartitionSet* PartitionsAtGridY(int grid_y);
  // Insert the blobs in the given list into the main grid and for
  // each one also make it a separate unknown partition.
  // If filter is true, use only the blobs that are above a threshold in
  // size or a non-isolated.
  void InsertSmallBlobsAsUnknowns(bool filter, BLOBNBOX_LIST* blobs);
  // Helper function for PartitionsAtGridY, with a long argument list.
  // This bbox is of unknown type, so it is added to an unk_partition.
  // If the edge is past the unk_right_margin then unk_partition has to be
  // completed and a new one made. See CompletePartition and StartPartition
  // for the other args.
  void ProcessUnknownBlob(int page_edge, BLOBNBOX* bbox,
                          ColPartition** unk_partition,
                          ColPartition_IT* unk_part_it,
                          TabVector** unk_right_line,
                          int* unk_right_margin,
                          int* unk_prev_margin,
                          bool* unk_edge_is_left);
  // Creates and returns a new ColPartition of the given start_type
  // and adds the given bbox to it.
  // Also finds the left and right tabvectors that bound the textline, setting
  // the members of the returned ColPartition appropriately:
  // If the left tabvector is less constraining than the input left_margin
  // (assumed to be the right edge of the previous partition), then the
  // tabvector is ignored and the left_margin used instead.
  // If the right tabvector is more constraining than the input *right_margin,
  // (probably the right edge of the page), then the *right_margin is adjusted
  // to use the tabvector.
  // *edge_is_left is set to true if the right tabvector is good and used as the
  // margin, so we can include blobs that overhang the tabvector in this
  // partition.
  ColPartition* StartPartition(BlobRegionType start_type, int left_margin,
                               BLOBNBOX* bbox, TabVector** right_line,
                               int* right_margin, bool* edge_is_left);
  // Completes the given partition, and adds it to the given iterator.
  // The right_margin on input is the left edge of the next blob if there is
  // one. The right tab vector plus a margin is used as the right margin if
  // it is more constraining than the next blob, but if there are no more
  // blobs, we want the right margin to make it to the page edge.
  // The return value is the next left margin, being the right edge of the
  // bounding box of blobs.
  int CompletePartition(bool no_more_blobs, int page_edge,
                        TabVector* right_line, int* right_margin,
                        ColPartition** partition, ColPartition_IT* part_it);


  ////// Functions involved in determining the columns used on the page. /////

  // Makes an ordered list of candidates to partition the width of the page
  // into columns using the part_sets_.
  // See AddToColumnSetsIfUnique for the ordering.
  // If single_column, then it just makes a single page-wide fake column.
  void MakeColumnCandidates(bool single_column);
  // Attempt to improve the column_candidates by expanding the columns
  // and adding new partitions from the partition sets in src_sets.
  // Src_sets may be equal to column_candidates, in which case it will
  // use them as a source to improve themselves.
  void ImproveColumnCandidates(PartSetVector* src_sets,
                               PartSetVector* column_sets);
  // Prints debug information on the column candidates.
  void PrintColumnCandidates(const char* title);
  // Finds the optimal set of columns that cover the entire image with as
  // few changes in column partition as possible.
  void AssignColumns();
  // Finds the biggest range in part_sets_ that has no assigned column, but
  // column assignment is possible.
  bool BiggestUnassignedRange(const bool* any_columns_possible,
                              int* start, int* end);
  // Finds the modal compatible column_set_ index within the given range.
  int RangeModalColumnSet(bool** possible_column_sets,
                          int start, int end);
  // Given that there are many column_set_id compatible columns in the range,
  // shrinks the range to the longest contiguous run of compatibility, allowing
  // gaps where no columns are possible, but not where competing columns are
  // possible.
  void ShrinkRangeToLongestRun(bool** possible_column_sets,
                              const bool* any_columns_possible,
                              int column_set_id,
                              int* best_start, int* best_end);
  // Moves start in the direction of step, upto, but not including end while
  // the only incompatible regions are no more than kMaxIncompatibleColumnCount
  // in size, and the compatible regions beyond are bigger.
  void ExtendRangePastSmallGaps(bool** possible_column_sets,
                                const bool* any_columns_possible,
                                int column_set_id,
                                int step, int end, int* start);
  // Assigns the given column_set_id to the part_sets_ in the given range.
  void AssignColumnToRange(int column_set_id, int start, int end,
                           bool** assigned_column_sets);

  // Computes the mean_column_gap_.
  void ComputeMeanColumnGap();

  //////// Functions that manipulate ColPartitions in the part_grid_ /////
  //////// to split, merge, find margins, and find types.  //////////////

  // Removes the ColPartitions from part_sets_, the ColPartitionSets that
  // contain them, and puts them in the part_grid_ after ensuring that no
  // BLOBNBOX is owned by more than one of them.
  void MovePartitionsToGrid();
  // Splits partitions that cross columns where they have nothing in the gap.
  void GridSplitPartitions();
  // Merges partitions where there is vertical overlap, within a single column,
  // and the horizontal gap is small enough.
  void GridMergePartitions();
  // Resolves unknown partitions from the unknown_parts_ list by merging them
  // with a close neighbour, inserting them into the grid with a known type,
  // or declaring them to be noise.
  void GridInsertUnknowns();
  // Add horizontal line separators as partitions.
  void GridInsertHLinePartitions();
  // Improves the margins of the ColPartitions in the grid by calling
  // FindPartitionMargins on each.
  void GridFindMargins();
  // Improves the margins of the ColPartitions in the list by calling
  // FindPartitionMargins on each.
  void ListFindMargins(ColPartition_LIST* parts);
  // Improves the margins of the ColPartition by searching for
  // neighbours that vertically overlap significantly.
  void FindPartitionMargins(ColPartitionSet* columns, ColPartition* part);
  // Starting at x, and going in the specified direction, upto x_limit, finds
  // the margin for the given y range by searching sideways,
  // and ignoring not_this.
  int FindMargin(int x, bool right_to_left, int x_limit,
                 int y_bottom, int y_top, const ColPartition* not_this);
  // For every ColPartition in the grid, sets its type based on position
  // in the columns.
  void SetPartitionTypes();

  //////// Functions that manipulate ColPartitions in the part_grid_ /////
  //////// to find chains of partner partitions of the same type.  ///////

  // For every ColPartition in the grid, finds its upper and lower neighbours.
  void FindPartitionPartners();
  // Finds the best partner in the given direction for the given partition.
  // Stores the result with AddPartner.
  void FindPartitionPartners(bool upper, ColPartition* part);
  // For every ColPartition with multiple partners in the grid, reduces the
  // number of partners to 0 or 1.
  void RefinePartitionPartners();
  // Only images remain with multiple types in a run of partners.
  // Sets the type of all in the group to the maximum of the group.
  void SmoothPartnerRuns();

  //////// Functions that manipulate ColPartitions in the part_grid_ /////
  //////// to find tables.                                          ///////

  // Copy cleaned partitions from part_grid_ to clean_part_grid_ and
  // insert dot-like noise into period_grid_
  void GetCleanPartitions(TO_BLOCK* block);

  // High level function to perform table detection
  void LocateTables();

  // Get Column segments from best_columns_
  void GetColumnBlocks(ColSegment_LIST *col_segments);

  // Group Column segments into consecutive single column regions.
  void GroupColumnBlocks(ColSegment_LIST *current_segments,
                        ColSegment_LIST *col_segments);

  // Check if two boxes are consecutive within the same column
  bool ConsecutiveBoxes(const TBOX &b1, const TBOX &b2);

  // Set left, right and top, bottom spacings of each colpartition.
  // Left/right spacings are w.r.t the column boundaries
  // Top/bottom spacings are w.r.t. previous and next colpartitions
  void SetPartitionSpacings();

  // Set spacing and closest neighbors above and below a given colpartition.
  void SetVerticalSpacing(ColPartition* part);

  // Set global spacing estimates
  void SetGlobalSpacings();

  // Mark partitions as table rows/cells.
  void GridMarkTablePartitions();

  // Check if the partition has at lease one large gap between words or no
  // significant gap at all
  bool HasWideOrNoInterWordGap(ColPartition* part);

  // Check if a period lies in the inter-wrod gap in the parition boxes
  bool LiesInGap(BLOBNBOX* period, BLOBNBOX_CLIST* boxes);

  // Filter individual text partitions marked as table partitions
  // consisting of paragraph endings, small section headings, and
  // headers and footers.
  void FilterFalseAlarms();

  // Mark all ColPartitions as table cells that have a table cell above
  // and below them
  void SmoothTablePartitionRuns();

  // Set the ratio of candidate table partitions in each column
  void SetColumnsType(ColSegment_LIST* col_segments);

  // Move Column Blocks to col_seg_grid_
  void MoveColSegmentsToGrid(ColSegment_LIST *segments,
                             ColSegmentGrid *col_seg_grid);

  // Merge Column Blocks that were split due to the presence of a table
  void GridMergeColumnBlocks();

  // Merge table cells into table columns
  void GetTableColumns(ColSegment_LIST *table_columns);

  // Get Column segments from best_columns_
  void GetTableRegions(ColSegment_LIST *table_columns,
                       ColSegment_LIST *table_regions);

  // Merge table regions corresponding to tables spanning multiple columns
  void GridMergeTableRegions();
  bool BelongToOneTable(const TBOX &box1, const TBOX &box2);

  // Adjust table boundaries by building a tight bounding box around all
  // ColPartitions contained in it.
  void AdjustTableBoundaries();

  // Checks whether the horizontal line belong to the table by looking at the
  // side spacing of extra ColParitions that will be included in the table
  // due to expansion
  bool HLineBelongsToTable(ColPartition* part, const TBOX& table_box);

  // Look for isolated column headers above the given table box and
  // include them in the table
  void IncludeLeftOutColumnHeaders(TBOX& table_box);

  // Remove false alarms consiting of a single column
  void DeleteSingleColumnTables();

  // Return true if at least one gap larger than the global x-height
  // exists in the horizontal projection
  bool GapInXProjection(int* xprojection, int length);

  // Displays Colpartitions marked as table row. Overlays them on top of
  // part_grid_.
  void DisplayColSegments(ColSegment_LIST *cols, ScrollView* win,
                          ScrollView::Color color);

  // Displays the colpartitions using a new coloring on an existing window.
  // Note: This method is only for debug purpose during development and
  // would not be part of checked in code
  void DisplayColPartitions(ScrollView* win,
                            ScrollView::Color color);

  // Write ColParitions and Tables to a PIX image
  // Note: This method is only for debug purpose during development and
  // would not be part of checked in code
  void WriteToPix();

  // Merge all colpartitions in table regions to make them a single
  // colpartition and revert types of isolated table cells not
  // assigned to any table to their original types.
  void MakeTableBlocks();

  //////// Functions that make the final output blocks             ///////

  // Helper functions for TransformToBlocks.
  // Add the part to the temp list in the correct order.
  void AddToTempPartList(ColPartition* part, ColPartition_CLIST* temp_list);
  // Add everything from the temp list to the work_set assuming correct order.
  void EmptyTempPartList(ColPartition_CLIST* temp_list,
                         WorkingPartSet_LIST* work_set);

  // Transform the grid of partitions to the output blocks.
  void TransformToBlocks(BLOCK_LIST* blocks, TO_BLOCK_LIST* to_blocks);

  // Reskew the completed blocks to put them back to the original coords.
  // (Blob outlines are not corrected for skew.)
  // Rotate blobs and blocks individually so text line direction is
  // horizontal. Record appropriate inverse transformations and required
  // classifier transformation in the blocks.
  void RotateAndReskewBlocks(TO_BLOCK_LIST* to_blocks);


  // Move all the small and noise blobs into the main blobs list of
  // the block from the to_blocks list that contains them.
  void MoveSmallBlobs(BLOBNBOX_LIST* bblobs, TO_BLOCK_LIST* to_blocks);

  // The mean gap between columns over the page.
  int mean_column_gap_;
  // Estimate of median x-height over the page
  int global_median_xheight_;
  // Estimate of median ledding on the page
  int global_median_ledding_;
  // The rotation vector needed to convert deskewed back to original coords.
  FCOORD reskew_;
  // The rotation vector needed to convert the rotated back to original coords.
  FCOORD rerotate_;
  // The part_sets_ are the initial text-line-like partition of the grid,
  // and is a vector of ColPartitionSets.
  PartSetVector part_sets_;
  // The column_sets_ contain the ordered candidate ColPartitionSets that
  // define the possible divisions of the page into columns.
  PartSetVector column_sets_;
  // A simple array of pointers to the best assigned column division at
  // each grid y coordinate.
  ColPartitionSet** best_columns_;
  // The grid used to hold ColPartitions after the columns have been determined.
  ColPartitionGrid part_grid_;
  // Grid to hold cleaned colpartitions after removing all
  // colpartitions that consist of only noise blobs, and removing
  // noise blobs from remaining colpartitions.
  ColPartitionGrid clean_part_grid_;
  // Grid to hold periods, commas, i-dots etc.
  BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> period_grid_;
  // List of period blobs extracted from small and noise blobs
  BLOBNBOX_LIST period_blobs_;
  // Grid of page column blocks
  ColSegmentGrid col_seg_grid_;
  // Grid of detected tables
  ColSegmentGrid table_grid_;
  // List of ColPartitions that are no longer needed after they have been
  // turned into regions, but are kept around because they are referenced
  // by the part_grid_.
  ColPartition_LIST good_parts_;
  // List of ColPartitions of unknown type.
  ColPartition_LIST unknown_parts_;
  // List of ColPartitions that have been declared noise.
  ColPartition_LIST noise_parts_;
  // The fake blobs that are made from the input boxa/pixa pair.
  BLOBNBOX_LIST image_bblobs_;
  // Horizontal line separators.
  TabVector_LIST horizontal_lines_;
  // Allow a subsequent instance to reuse the blocks window.
  // Not thread-safe, but multiple threads shouldn't be using windows anyway.
  static ScrollView* blocks_win_;
};
/////////////////////////////////////////////////////////////////colfind////////////////////////////////////////

/////////////////////////////////////////////////////////////////TessBaseAPI////////////////////////////////////////
class PAGE_RES_IT;
class BLOCK_LIST;
class IMAGE;
struct Pix;
struct Box;
struct Pixa;
struct Boxa;
struct ETEXT_STRUCT;
struct TBOX;

#ifdef TESSDLL_EXPORTS
#define TESSDLL_API __declspec(dllexport)
#elif defined(TESSDLL_IMPORTS)
#define TESSDLL_API __declspec(dllimport)
#else
#define TESSDLL_API
#endif

class Tesseract;
class Trie;
class CubeRecoContext;
class TesseractCubeCombiner;
class CubeObject;
class CubeLineObject;
class Dawg;

extern ETEXT_DESC *global_monitor1;
typedef int (DictT::*DictFunc)(void* void_dawg_args, int char_index, const void *word, bool word_end);

enum PageSegMode
{
    PSM_AUTO,           ///< Fully automatic page segmentation.
    PSM_SINGLE_COLUMN,  ///< Assume a single column of text of variable sizes.
    PSM_SINGLE_BLOCK,   ///< Assume a single uniform block of text. (Default.)
    PSM_SINGLE_LINE,    ///< Treat the image as a single text line.
    PSM_SINGLE_WORD,    ///< Treat the image as a single word.
    PSM_SINGLE_CHAR,    ///< Treat the image as a single character.

    PSM_COUNT           ///< Number of enum entries.
};

/**
     * The values in the AccuracyVSpeed enum provide hints for how the engine
     * should trade speed for accuracy. There is no guarantee of any effect.
     */
enum AccuracyVSpeed
{
    AVS_FASTEST = 0,         ///< Fastest speed, but lowest accuracy.
    AVS_MOST_ACCURATE = 100  ///< Greatest accuracy, but slowest speed.
};

/**
     * Base class for all tesseract APIs.
     * Specific classes can add ability to work on different inputs or produce
     * different outputs.
     * This class is mostly an interface layer on top of the Tesseract instance
     * class to hide the data types so that users of this class don't have to
     * include any other Tesseract headers.
     */
class TESSDLL_API TessBaseAPI
{
public:
    TessBaseAPI();
    virtual ~TessBaseAPI();

    /**
       * Set the name of the input file. Needed only for training and
       * reading a UNLV zone file.
       */
    void SetInputName(const char* name);

    /** Set the name of the bonus output files. Needed only for debugging. */
    void SetOutputName(const char* name);

    /**
       * Set the value of an internal "variable" (of either old or new types).
       * Supply the name of the variable and the value as a string, just as
       * you would in a config file.
       * Returns false if the name lookup failed.
       * Eg SetVariable("tessedit_char_blacklist", "xyz"); to ignore x, y and z.
       * Or SetVariable("bln_numericmode", "1"); to set numeric-only mode.
       * SetVariable may be used before Init, but settings will revert to
       * defaults on End().
       */
    bool SetVariable(const char* variable, const char* value);

    /**
       * Eventually instances will be thread-safe and totally independent,
       * but for now, they all point to the same underlying engine,
       * and are NOT RE-ENTRANT OR THREAD-SAFE. For now:
       * it is safe to Init multiple TessBaseAPIs in the same language, use them
       * sequentially, and End or delete them all, but once one is Ended, you can't
       * do anything other than End the others. After End, it is safe to Init
       * again on the same one.
       *
       * Start tesseract. Returns zero on success and -1 on failure.
       * NOTE that the only members that may be called before Init are those
       * listed above here in the class definition.
       *
       * The datapath must be the name of the data directory (no ending /) or
       * some other file in which the data directory resides (for instance argv[0].)
       * The language is (usually) an ISO 639-3 string or NULL will default to eng.
       * It is entirely safe (and eventually will be efficient too) to call
       * Init multiple times on the same instance to change language, or just
       * to reset the classifier.
       * WARNING: On changing languages, all Variables are reset back to their
       * default values. If you have a rare need to set a Variable that controls
       * initialization for a second call to Init you should explicitly
       * call End() and then use SetVariable before Init. This is only a very
       * rare use case, since there are very few uses that require any variables
       * to be set before Init.
       */
    int Init(const char* datapath, const char* language, char **configs, int configs_size, bool configs_global_only);

    int Init(const char* datapath, const char* language)
    {
        return Init(datapath, language, 0, 0, false);
    }

    /**
       * Init only the lang model component of Tesseract. The only functions
       * that work after this init are SetVariable and IsValidWord.
       * WARNING: temporary! This function will be removed from here and placed
       * in a separate API at some future time.
       */
    int InitLangMod(const char* datapath, const char* language);

    /**
       * Init everything except the language model. Used to allow initialization for
       * the specified language without any available dawg models.
       */
    int InitWithoutLangModel(const char* datapath, const char* language);

    /**
       * Read a "config" file containing a set of variable, value pairs.
       * Searches the standard places: tessdata/configs, tessdata/tessconfigs
       * and also accepts a relative or absolute path name.
       */
    void ReadConfigFile(const char* filename, bool global_only);

    /**
       * Set the current page segmentation mode. Defaults to PSM_SINGLE_BLOCK.
       * The mode is stored as an INT_VARIABLE so it can also be modified by
       * ReadConfigFile or SetVariable("tessedit_pageseg_mode", mode as string).
       */
    void SetPageSegMode(PageSegMode mode);

    /** Return the current page segmentation mode. */
    PageSegMode GetPageSegMode() const;

    /**
       * Set the hint for trading accuracy against speed.
       * Default is AVS_FASTEST, which is the old behaviour.
       * Note that this is only a hint. Depending on the language and/or
       * build configuration, speed and accuracy may not be tradeable.
       * Also note that despite being an enum, any value in the range
       * AVS_FASTEST to AVS_MOST_ACCURATE can be provided, and may or may not
       * have an effect, depending on the implementation.
       * The mode is stored as an INT_VARIABLE so it can also be modified by
       * ReadConfigFile or SetVariable("tessedit_accuracyvspeed", mode as string).
       */
    void SetAccuracyVSpeed(AccuracyVSpeed mode);

    /**
       * Recognize a rectangle from an image and return the result as a string.
       * May be called many times for a single Init.
       * Currently has no error checking.
       * Greyscale of 8 and color of 24 or 32 bits per pixel may be given.
       * Palette color images will not work properly and must be converted to
       * 24 bit.
       * Binary images of 1 bit per pixel may also be given but they must be
       * byte packed with the MSB of the first byte being the first pixel, and a
       * 1 represents WHITE. For binary images set bytes_per_pixel=0.
       * The recognized text is returned as a char* which is coded
       * as UTF8 and must be freed with the delete [] operator.
       *
       * Note that TesseractRect is the simplified convenience interface.
       * For advanced uses, use SetImage, (optionally) SetRectangle, Recognize,
       * and one or more of the Get*Text functions below.
       */
    char* TesseractRect(const unsigned char* imagedata, int bytes_per_pixel, int bytes_per_line, int left, int top, int width, int height);

    /**
       * Call between pages or documents etc to free up memory and forget
       * adaptive data.
       */
    void ClearAdaptiveClassifier();

    /**
       * @defgroup AdvancedAPI Advanced API
       * The following methods break TesseractRect into pieces, so you can
       * get hold of the thresholded image, get the text in different formats,
       * get bounding boxes, confidences etc.
       */
    /* @{ */

    /**
       * Provide an image for Tesseract to recognize. Format is as
       * TesseractRect above. Does not copy the image buffer, or take
       * ownership. The source image may be destroyed after Recognize is called,
       * either explicitly or implicitly via one of the Get*Text functions.
       * SetImage clears all recognition results, and sets the rectangle to the
       * full image, so it may be followed immediately by a GetUTF8Text, and it
       * will automatically perform recognition.
       */
    void SetImage(const unsigned char* imagedata, int width, int height, int bytes_per_pixel, int bytes_per_line);

    /**
       * Provide an image for Tesseract to recognize. As with SetImage above,
       * Tesseract doesn't take a copy or ownership or pixDestroy the image, so
       * it must persist until after Recognize.
       * Pix vs raw, which to use?
       * Use Pix where possible. A future version of Tesseract may choose to use Pix
       * as its internal representation and discard IMAGE altogether.
       * Because of that, an implementation that sources and targets Pix may end up
       * with less copies than an implementation that does not.
       */
    void SetImage(const Pix* pix);

    /**
       * Restrict recognition to a sub-rectangle of the image. Call after SetImage.
       * Each SetRectangle clears the recogntion results so multiple rectangles
       * can be recognized with the same image.
       */
    void SetRectangle(int left, int top, int width, int height);

    /**
       * In extreme cases only, usually with a subclass of Thresholder, it
       * is possible to provide a different Thresholder. The Thresholder may
       * be preloaded with an image, settings etc, or they may be set after.
       * Note that Tesseract takes ownership of the Thresholder and will
       * delete it when it it is replaced or the API is destructed.
       */
    void SetThresholder(ImageThresholder* thresholder)
    {
        if (thresholder_ != 0) delete thresholder_;
        thresholder_ = thresholder;
        ClearResults();
    }

    /**
       * Get a copy of the internal thresholded image from Tesseract.
       * Caller takes ownership of the Pix and must pixDestroy it.
       * May be called any time after SetImage, or after TesseractRect.
       */
    Pix* GetThresholdedImage();

    /**
       * Get the result of page layout analysis as a leptonica-style
       * Boxa, Pixa pair, in reading order.
       * Can be called before or after Recognize.
       */
    Boxa* GetRegions(Pixa** pixa);

    /**
       * Get the textlines as a leptonica-style
       * Boxa, Pixa pair, in reading order.
       * Can be called before or after Recognize.
       * If blockids is not NULL, the block-id of each line is also returned as an
       * array of one element per line. delete [] after use.
       */
    Boxa* GetTextlines(Pixa** pixa, int** blockids);

    /**
       * Get the words as a leptonica-style
       * Boxa, Pixa pair, in reading order.
       * Can be called before or after Recognize.
       */
    Boxa* GetWords(Pixa** pixa);

    /**
       * Dump the internal binary image to a PGM file.
       * @deprecated Use GetThresholdedImage and write the image using pixWrite
       * instead if possible.
       */
    void DumpPGM(const char* filename);

    /**
       * Recognize the image from SetAndThresholdImage, generating Tesseract
       * internal structures. Returns 0 on success.
       * Optional. The Get*Text functions below will call Recognize if needed.
       * After Recognize, the output is kept internally until the next SetImage.
       */
    int Recognize(ETEXT_STRUCT* monitor);

    /**
       * Methods to retrieve information after SetAndThresholdImage(),
       * Recognize() or TesseractRect(). (Recognize is called implicitly if needed.)
       */

    /** Variant on Recognize used for testing chopper. */
    int RecognizeForChopTest(struct ETEXT_STRUCT* monitor);

    /**
       * The recognized text is returned as a char* which is coded
       * as UTF8 and must be freed with the delete [] operator.
       */
    char* GetUTF8Text();
    /**
       * Make a HTML-formatted string with hOCR markup from the internal
       * data structures.
       * STL removed from original patch submission and refactored by rays.
       * page_id is 1-based and will appear in the output.
       */
    char* GetHOCRText(int page_id);
    /**
       * The recognized text is returned as a char* which is coded in the same
       * format as a box file used in training. Returned string must be freed with
       * the delete [] operator.
       * Constructs coordinates in the original image - not just the rectangle.
       * page_number is a 0-base page index that will appear in the box file.
       */
    char* GetBoxText(int page_number);
    /**
       * The recognized text is returned as a char* which is coded
       * as UNLV format Latin-1 with specific reject and suspect codes
       * and must be freed with the delete [] operator.
       */
    char* GetUNLVText();
    /** Returns the (average) confidence value between 0 and 100. */
    int MeanTextConf();
    /**
       * Returns all word confidences (between 0 and 100) in an array, terminated
       * by -1.  The calling function must delete [] after use.
       * The number of confidences should correspond to the number of space-
       * delimited words in GetUTF8Text.
       */
    int* AllWordConfidences();

    /**
       * Free up recognition results and any stored image data, without actually
       * freeing any recognition data that would be time-consuming to reload.
       * Afterwards, you must call SetImage or TesseractRect before doing
       * any Recognize or Get* operation.
       */
    void Clear();

    /**
       * Close down tesseract and free up all memory. End() is equivalent to
       * destructing and reconstructing your TessBaseAPI.
       * Once End() has been used, none of the other API functions may be used
       * other than Init and anything declared above it in the class definition.
       */
    void End();

    /**
       * Check whether a word is valid according to Tesseract's language model
       * @return 0 if the word is invalid, non-zero if valid.
       * @warning temporary! This function will be removed from here and placed
       * in a separate API at some future time.
       */
    int IsValidWord(const char *word);

    bool GetTextDirection(int* out_offset, float* out_slope);

    /** Set the letter_is_okay function to point somewhere else. */
    void SetDictFunc(DictFunc f);

    /**
       * Estimates the Orientation And Script of the image.
       * @return true if the image was processed successfully.
       */
    bool DetectOS(OSResults*);

    /** This method returns the features associated with the input image. */
    void GetFeatures(INT_FEATURE_ARRAY int_features,
                     int* num_features);

    /** Return the pointer to the i-th dawg loaded into tesseract_ object. */
    const Dawg *GetDawg(int i) const;

    /** Return the number of dawgs loaded into tesseract_ object. */
    int NumDawgs() const;

    /** Return the language used in the last valid initialization. */
    const char* GetLastInitLanguage() const;

    /* @} */

protected:

    /** Common code for setting the image. Returns true if Init has been called. */
    bool InternalSetImage();

    /**
       * Run the thresholder to make the thresholded image. If pix is not NULL,
       * the source is thresholded to pix instead of the internal IMAGE.
       */
    virtual void Threshold(Pix** pix);

    /**
       * Find lines from the image making the BLOCK_LIST.
       * @return 0 on success.
       */
    int FindLines();

    /** Delete the pageres and block list ready for a new page. */
    void ClearResults();

    /**
       * Return the length of the output text string, as UTF8, assuming
       * one newline per line and one per block, with a terminator,
       * and assuming a single character reject marker for each rejected character.
       * Also return the number of recognized blobs in blob_count.
       */
    int TextLength(int* blob_count);

    /** @defgroup ocropusAddOns ocropus add-ons */

    /* @{ */
    /** Find lines from the image making the BLOCK_LIST. */
    BLOCK_LIST* FindLinesCreateBlockList();

    /**
       * Delete a block list.
       * This is to keep BLOCK_LIST pointer opaque
       * and let go of including the other headers.
       */
    static void DeleteBlockList(BLOCK_LIST* block_list);

    /**
       * Adapt to recognize the current image as the given character.
       * The image must be preloaded and be just an image of a single character.
       */
    void AdaptToCharacter(const char *unichar_repr, int length, float baseline, float xheight, float descender, float ascender);

    /** Recognize text doing one pass only, using settings for a given pass. */
    /*static*/ PAGE_RES* RecognitionPass1(BLOCK_LIST* block_list);
    /*static*/ PAGE_RES* RecognitionPass2(BLOCK_LIST* block_list, PAGE_RES* pass1_result);

    /**
       * Extract the OCR results, costs (penalty points for uncertainty),
       * and the bounding boxes of the characters.
       */
    static int TesseractExtractResult(char** text, int** lengths, float** costs, int** x0, int** y0, int** x1, int** y1, PAGE_RES* page_res);

    /**
       * Call the Cube OCR engine. Takes the Region, line and word segmentation
       * information from Tesseract as inputs. Makes changes or populates the
       * output PAGE_RES object which contains the recogntion results.
       * The behavior of this function depends on the
       * current language and the value of the tessedit_accuracyvspeed:
       * For English (and other Latin based scripts):
       *    If the accuracyvspeed flag is set to any value other than AVS_FASTEST,
       *    Cube uses the word information passed by Tesseract.
       *    Cube will run on a subset of the words segmented and recognized by
       *    Tesseract. The value of the accuracyvspeed and the Tesseract
       *    confidence of a word determines whether Cube runs on it or not and
       *    whether Cube's results override Tesseract's
       * For Arabic & Hindi:
       *    Cube uses the Region information passed by Tesseract. It then performs
       *    its own line segmentation. This will change once Tesseract's line
       *    segmentation works for Arabic. Cube then segments each line into
       *    phrases. Each phrase is then recognized in phrase mode which allows
       *    spaces in the results.
       *    Note that at this point, the line segmentation algorithm might have
       *    some problems with ill spaced Arabic document.
       */
    int Cube();
    /** Run Cube on the lines extracted by Tesseract. */
    int RunCubeOnLines();
    /**
       * Run Cube on a subset of the words already present in the page_res_ object
       * The subset, and whether Cube overrides the results is determined by
       * the SpeedVsAccuracy flag
       */
    int CubePostProcessWords();
    /** Create a Cube line object for each line */
    CubeLineObject **CreateLineObjects(Pixa* pixa_lines);
    /**
       * Create a TBox array corresponding to the phrases in the array of
       * line objects
       */
    TBOX *CreatePhraseBoxes(Boxa* boxa_lines, CubeLineObject **line_objs, int *phrase_cnt);

    /** Recognize the phrases saving the results to the page_res_ object */
    bool RecognizePhrases(int line_cnt, int phrase_cnt, CubeLineObject **line_objs, TBOX *phrase_boxes);

    /** Recognize a single phrase saving the results to the page_res_ object */
    bool RecognizePhrase(CubeObject *phrase, PAGE_RES_IT *result);

    /** Create the necessary Cube Objects */
    bool CreateCubeObjects();
    /* @} */

protected:
    Tesseract*        tesseract_;       ///< The underlying data object.
    ImageThresholder* thresholder_;     ///< Image thresholding module.
    bool              threshold_done_;  ///< Image has been passed to page_image.
    BLOCK_LIST*       block_list_;      ///< The page layout.
    PAGE_RES*         page_res_;        ///< The page-level data.
    STRING*           input_file_;      ///< Name used by training code.
    STRING*           output_file_;     ///< Name used by debug code.
    STRING*           datapath_;        ///< Current location of tessdata.
    STRING*           language_;        ///< Last initialized language.

    /**
       * @defgroup ThresholderParams
       * Parameters saved from the Thresholder. Needed to rebuild coordinates.
       */
    /* @{ */
    int rect_left_;
    int rect_top_;
    int rect_width_;
    int rect_height_;
    int image_width_;
    int image_height_;
    /* @} */
};
/////////////////////////////////////////////////////////////////TessBaseAPI//////////////////////////////////////

/////////////////////////////////////////////////////////////////unichar/////////////////////////////////
// Maximum number of characters that can be stored in a UNICHAR. Must be
// at least 4. Must not exceed 31 without changing the coding of length.

// The UNICHAR class holds a single classification result. This may be
// a single Unicode character (stored as between 1 and 4 utf8 bytes) or
// multple Unicode characters representing the NFKC expansion of a ligature
// such as fi, ffl etc. These are also stored as utf8.
class UNICHAR {
 public:
  UNICHAR() {
    memset(chars, 0, UNICHAR_LEN);
  }

  // Construct from a utf8 string. If len<0 then the string is null terminated.
  // If the string is too long to fit in the UNICHAR then it takes only what
  // will fit.
  UNICHAR(const char* utf8_str, int len);

  // Construct from a single UCS4 character.
  explicit UNICHAR(int unicode);

  // Default copy constructor and operator= are OK.

  // Get the first character as UCS-4.
  int first_uni() const;

  // Get the length of the UTF8 string.
  int utf8_len() const {
    int len = chars[UNICHAR_LEN - 1];
    return len >=0 && len < UNICHAR_LEN ? len : UNICHAR_LEN;
  }

  // Get a UTF8 string, but NOT NULL terminated.
  const char* utf8() const {
    return chars;
  }

  // Get a terminated UTF8 string: Must delete[] it after use.
  char* utf8_str() const;

  // Get the number of bytes in the first character of the given utf8 string.
  static int utf8_step(const char* utf8_str);

 private:
  // A UTF-8 representation of 1 or more Unicode characters.
  // The last element (chars[UNICHAR_LEN - 1]) is a length if
  // its value < UNICHAR_LEN, otherwise it is a genuine character.
  char chars[UNICHAR_LEN];
};
/////////////////////////////////////////////////////////////////unichar/////////////////////////////////

class OCR
{
public:
    OCR();
    int init(const QString &sDataPath);
    QString getRecognizeText(const Mat &matSrc);
private:
    TessBaseAPI m_tessBaseApi;
};

#endif // OCR_H
